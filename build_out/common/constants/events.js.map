{"version":3,"file":"events.js","sourceRoot":"","sources":["../../../src/common/constants/events.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;;;;AAMU,QAAA,aAAa,GAAG;IAC3B;;;OAGG;IACH,oBAAoB,EAAE,wBAAwB;IAE9C;;;OAGG;IACH,iBAAiB,EAAE,qBAAqB;IAExC;;;OAGG;IACH,mBAAmB,EAAE,uBAAuB;IAE5C;;;OAGG;IACH,iBAAiB,EAAE,qBAAqB;IAExC;;;OAGG;IACH,kBAAkB,EAAE,sBAAsB;IAE1C;;;OAGG;IACH,wBAAwB,EAAE,4BAA4B;IAEtD;;;;;;;;;;OAUG;IACH,sBAAsB,EAAE,0BAA0B;IAElD;;;OAGG;IACH,2BAA2B,EAAE,8BAA8B;IAE3D;;;OAGG;IACH,qBAAqB,EAAE,yBAAyB;IAEhD;;;OAGG;IACH,eAAe,EAAE,oBAAoB;IACrC;;;OAGG;IACH,wBAAwB,EAAE,4BAA4B;IAEtD;;;OAGG;IACH,kBAAkB,EAAE,sBAAsB;IAE1C;;;OAGG;IACH,sBAAsB,EAAE,yBAAyB;CACzC,CAAC;AAuDX;;;;;;;;;;;GAWG;AACH,2BACE,SAAY,EACZ,GAAG,IAAkF,EAChD;IACrC,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;IACtB,OAAO,IAAI,WAAW,CAAC,SAAS,EAAE,EAAE,MAAM,EAA6C,CAAC,CAAC;AAAA,CAC1F;AAED;;;GAGG;AACI,MAAM,qBAAqB,GAAG,CAAC,GAAW,EAAU,EAAE,CAAC,kBAAkB,GAAG,EAAE,CAAC;AAAzE,QAAA,qBAAqB,GAArB,qBAAqB,CAAoD","sourcesContent":["/**\r\n * Custom Event Constants & Types\r\n * These are window-level custom events used for cross-component communication\r\n *\r\n * Each event has a corresponding type in CustomEventPayloads for type safety\r\n */\r\n\r\nimport type { ThinkingLevel } from \"@/common/types/thinking\";\r\nimport type { ReviewNoteDataForDisplay } from \"@/common/types/message\";\r\nimport type { FilePart } from \"@/common/orpc/schemas\";\r\n\r\nexport const CUSTOM_EVENTS = {\r\n  /**\r\n   * Event to show a toast notification when thinking level changes\r\n   * Detail: { workspaceId: string, level: ThinkingLevel }\r\n   */\r\n  THINKING_LEVEL_TOAST: \"mux:thinkingLevelToast\",\r\n\r\n  /**\r\n   * Event to insert text into the chat input\r\n   * Detail: { text: string, mode?: \"replace\" | \"append\", fileParts?: FilePart[], reviews?: ReviewNoteDataForDisplay[] }\r\n   */\r\n  UPDATE_CHAT_INPUT: \"mux:updateChatInput\",\r\n\r\n  /**\r\n   * Event to open the model selector\r\n   * No detail\r\n   */\r\n  OPEN_MODEL_SELECTOR: \"mux:openModelSelector\",\r\n\r\n  /**\r\n   * Event to open the agent picker (AgentModePicker)\r\n   * No detail\r\n   */\r\n  OPEN_AGENT_PICKER: \"mux:openAgentPicker\",\r\n\r\n  /**\r\n   * Event to close the agent picker (AgentModePicker)\r\n   * No detail\r\n   */\r\n  CLOSE_AGENT_PICKER: \"mux:closeAgentPicker\",\r\n\r\n  /**\r\n   * Event to request a refresh of the agent definition list (AgentContext).\r\n   * No detail.\r\n   */\r\n  AGENTS_REFRESH_REQUESTED: \"mux:agentsRefreshRequested\",\r\n\r\n  /**\r\n   * Event to trigger resume check for a workspace\r\n   * Detail: { workspaceId: string }\r\n   *\r\n   * Emitted when:\r\n   * - Stream error occurs\r\n   * - Stream aborted\r\n   * - App startup (for all workspaces with interrupted streams)\r\n   *\r\n   * useResumeManager handles this idempotently - safe to emit multiple times\r\n   */\r\n  RESUME_CHECK_REQUESTED: \"mux:resumeCheckRequested\",\r\n\r\n  /**\r\n   * Event emitted when the mux gateway session expires.\r\n   * No detail\r\n   */\r\n  MUX_GATEWAY_SESSION_EXPIRED: \"mux:muxGatewaySessionExpired\",\r\n\r\n  /**\r\n   * Event to switch to a different workspace after fork\r\n   * Detail: { workspaceId: string, projectPath: string, projectName: string, workspacePath: string, branch: string }\r\n   */\r\n  WORKSPACE_FORK_SWITCH: \"mux:workspaceForkSwitch\",\r\n\r\n  /**\r\n   * Event to execute a command from the command palette\r\n   * Detail: { commandId: string }\r\n   */\r\n  EXECUTE_COMMAND: \"mux:executeCommand\",\r\n  /**\r\n   * Event to enter the chat-based workspace creation experience.\r\n   * Detail: { projectPath: string, startMessage?: string, model?: string, trunkBranch?: string, runtime?: string }\r\n   */\r\n  START_WORKSPACE_CREATION: \"mux:startWorkspaceCreation\",\r\n\r\n  /**\r\n   * Event to toggle voice input (dictation) mode\r\n   * No detail\r\n   */\r\n  TOGGLE_VOICE_INPUT: \"mux:toggleVoiceInput\",\r\n\r\n  /**\r\n   * Event to open the debug LLM request modal\r\n   * No detail\r\n   */\r\n  OPEN_DEBUG_LLM_REQUEST: \"mux:openDebugLlmRequest\",\r\n} as const;\r\n\r\n/**\r\n * Payload types for custom events\r\n * Maps event names to their detail payload structure\r\n */\r\nexport interface CustomEventPayloads {\r\n  [CUSTOM_EVENTS.THINKING_LEVEL_TOAST]: {\r\n    workspaceId: string;\r\n    level: ThinkingLevel;\r\n  };\r\n  [CUSTOM_EVENTS.UPDATE_CHAT_INPUT]: {\r\n    text: string;\r\n    mode?: \"replace\" | \"append\";\r\n    fileParts?: FilePart[];\r\n    reviews?: ReviewNoteDataForDisplay[];\r\n  };\r\n  [CUSTOM_EVENTS.OPEN_AGENT_PICKER]: never; // No payload\r\n  [CUSTOM_EVENTS.CLOSE_AGENT_PICKER]: never; // No payload\r\n  [CUSTOM_EVENTS.AGENTS_REFRESH_REQUESTED]: never; // No payload\r\n  [CUSTOM_EVENTS.OPEN_MODEL_SELECTOR]: never; // No payload\r\n  [CUSTOM_EVENTS.RESUME_CHECK_REQUESTED]: {\r\n    workspaceId: string;\r\n    isManual?: boolean; // true when user explicitly clicks retry (bypasses eligibility checks)\r\n  };\r\n  [CUSTOM_EVENTS.MUX_GATEWAY_SESSION_EXPIRED]: never; // No payload\r\n  [CUSTOM_EVENTS.WORKSPACE_FORK_SWITCH]: {\r\n    workspaceId: string;\r\n    projectPath: string;\r\n    projectName: string;\r\n    workspacePath: string;\r\n    branch: string;\r\n  };\r\n  [CUSTOM_EVENTS.EXECUTE_COMMAND]: {\r\n    commandId: string;\r\n  };\r\n  [CUSTOM_EVENTS.START_WORKSPACE_CREATION]: {\r\n    projectPath: string;\r\n    startMessage?: string;\r\n    model?: string;\r\n    trunkBranch?: string;\r\n    runtime?: string;\r\n  };\r\n  [CUSTOM_EVENTS.TOGGLE_VOICE_INPUT]: never; // No payload\r\n  [CUSTOM_EVENTS.OPEN_DEBUG_LLM_REQUEST]: never; // No payload\r\n}\r\n\r\n/**\r\n * Type-safe custom event type\r\n * Usage: CustomEventType<typeof CUSTOM_EVENTS.RESUME_CHECK_REQUESTED>\r\n */\r\nexport type CustomEventType<K extends keyof CustomEventPayloads> = CustomEvent<\r\n  CustomEventPayloads[K]\r\n>;\r\n\r\n/**\r\n * Helper to create a typed custom event\r\n *\r\n * @example\r\n * ```typescript\r\n * const event = createCustomEvent(CUSTOM_EVENTS.RESUME_CHECK_REQUESTED, {\r\n *   workspaceId: 'abc123',\r\n *   isManual: true\r\n * });\r\n * window.dispatchEvent(event);\r\n * ```\r\n */\r\nexport function createCustomEvent<K extends keyof CustomEventPayloads>(\r\n  eventName: K,\r\n  ...args: CustomEventPayloads[K] extends never ? [] : [detail: CustomEventPayloads[K]]\r\n): CustomEvent<CustomEventPayloads[K]> {\r\n  const [detail] = args;\r\n  return new CustomEvent(eventName, { detail } as CustomEventInit<CustomEventPayloads[K]>);\r\n}\r\n\r\n/**\r\n * Helper to create a storage change event name for a specific key\r\n * Used by usePersistedState for same-tab synchronization\r\n */\r\nexport const getStorageChangeEvent = (key: string): string => `storage-change:${key}`;\r\n"]}