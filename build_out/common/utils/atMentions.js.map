{"version":3,"file":"atMentions.js","sourceRoot":"","sources":["../../../src/common/utils/atMentions.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from \"@/common/utils/assert\";\r\n\r\nexport interface AtMentionLineRange {\r\n  startLine: number;\r\n  endLine: number;\r\n}\r\n\r\nexport interface AtMention {\r\n  /** Original (trimmed) token contents after the leading @ (e.g. \"src/foo.ts#L1-3\"). */\r\n  token: string;\r\n  /** The file path portion (e.g. \"src/foo.ts\"). */\r\n  path: string;\r\n  /** Parsed line range when provided in #Lx-y form. */\r\n  range?: AtMentionLineRange;\r\n  /** Error message if a #... fragment was present but not a supported #Lx-y range. */\r\n  rangeError?: string;\r\n}\r\n\r\nexport interface AtMentionCursorMatch {\r\n  /** Index of the leading '@' character. */\r\n  startIndex: number;\r\n  /** End index (exclusive) of the mention token (does not include trailing punctuation). */\r\n  endIndex: number;\r\n  /** The query text after '@' (does not include any #... fragment). */\r\n  query: string;\r\n}\r\n\r\nconst TRAILING_PUNCTUATION_RE = /[(){}<>,.;:!?\"'`\\]]+$/;\r\n\r\nfunction stripTrailingPunctuation(token: string): string {\r\n  return token.replace(TRAILING_PUNCTUATION_RE, \"\");\r\n}\r\n\r\nfunction isWordChar(ch: string | undefined): boolean {\r\n  return Boolean(ch && /[A-Za-z0-9_]/.test(ch));\r\n}\r\n\r\nfunction parseRange(\r\n  fragment: string\r\n):\r\n  | { range: AtMentionLineRange; rangeError?: undefined }\r\n  | { range?: undefined; rangeError: string } {\r\n  const match = /^L(\\d+)-(\\d+)$/i.exec(fragment);\r\n  if (!match) {\r\n    return {\r\n      rangeError: `Unsupported range fragment: #${fragment} (expected #L<start>-<end>)`,\r\n    };\r\n  }\r\n\r\n  const start = Number(match[1]);\r\n  const end = Number(match[2]);\r\n  if (!Number.isFinite(start) || !Number.isFinite(end)) {\r\n    return { rangeError: `Invalid range fragment: #${fragment}` };\r\n  }\r\n  if (!Number.isInteger(start) || !Number.isInteger(end)) {\r\n    return { rangeError: `Invalid range fragment: #${fragment}` };\r\n  }\r\n  if (start < 1 || end < 1) {\r\n    return { rangeError: `Invalid range fragment: #${fragment} (line numbers must be >= 1)` };\r\n  }\r\n  if (start > end) {\r\n    return { rangeError: `Invalid range fragment: #${fragment} (start must be <= end)` };\r\n  }\r\n\r\n  return { range: { startLine: start, endLine: end } };\r\n}\r\n\r\n/**\r\n * Extract @mentions from freeform text.\r\n *\r\n * MVP rules:\r\n * - A mention starts at '@' and continues until whitespace.\r\n * - Trailing punctuation (commas, parens, etc.) is ignored.\r\n * - Optional line range suffix: #L<start>-<end>\r\n *\r\n * NOTE: Callers should apply additional heuristics (e.g. only expand when path looks like a file).\r\n */\r\nexport function extractAtMentions(text: string): AtMention[] {\r\n  const result: AtMention[] = [];\r\n\r\n  for (const match of text.matchAll(/@(\\S+)/g)) {\r\n    const index = match.index;\r\n    if (typeof index !== \"number\") continue;\r\n\r\n    // Avoid matching email addresses or other \"word@word\" patterns.\r\n    if (index > 0 && isWordChar(text[index - 1])) {\r\n      continue;\r\n    }\r\n\r\n    const rawToken = match[1];\r\n    if (typeof rawToken !== \"string\") continue;\r\n\r\n    const token = stripTrailingPunctuation(rawToken);\r\n    if (!token) continue;\r\n\r\n    const [path, fragment] = token.split(\"#\", 2);\r\n    if (!path) continue;\r\n\r\n    if (!fragment) {\r\n      result.push({ token, path });\r\n      continue;\r\n    }\r\n\r\n    const parsed = parseRange(fragment);\r\n    result.push({ token, path, ...parsed });\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Find the @mention token currently under the cursor.\r\n *\r\n * This is used for interactive autocomplete (file path suggestions). It intentionally ignores\r\n * tokens that already have a \"#\" fragment, since the user is likely specifying a line range.\r\n */\r\nexport function findAtMentionAtCursor(text: string, cursor: number): AtMentionCursorMatch | null {\r\n  assert(Number.isInteger(cursor), \"cursor must be an integer\");\r\n  assert(cursor >= 0 && cursor <= text.length, \"cursor out of bounds\");\r\n\r\n  // Expand to token boundaries (whitespace-delimited).\r\n  let tokenStart = cursor;\r\n  while (tokenStart > 0 && !/\\s/.test(text[tokenStart - 1] ?? \"\")) {\r\n    tokenStart--;\r\n  }\r\n\r\n  let tokenEnd = cursor;\r\n  while (tokenEnd < text.length && !/\\s/.test(text[tokenEnd] ?? \"\")) {\r\n    tokenEnd++;\r\n  }\r\n\r\n  // Search backwards for an '@' within this token, but avoid \"word@word\" patterns.\r\n  let atIndex = -1;\r\n  for (let i = cursor - 1; i >= tokenStart; i--) {\r\n    if (text[i] === \"@\") {\r\n      atIndex = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (atIndex === -1) {\r\n    return null;\r\n  }\r\n\r\n  if (atIndex > 0 && isWordChar(text[atIndex - 1])) {\r\n    return null;\r\n  }\r\n\r\n  const rawAfterAt = text.slice(atIndex + 1, tokenEnd);\r\n  const cleanedAfterAt = stripTrailingPunctuation(rawAfterAt);\r\n\r\n  // Do not autocomplete after the user started specifying a fragment (e.g. #L1-10).\r\n  if (cleanedAfterAt.includes(\"#\")) {\r\n    return null;\r\n  }\r\n\r\n  return {\r\n    startIndex: atIndex,\r\n    endIndex: atIndex + 1 + cleanedAfterAt.length,\r\n    query: cleanedAfterAt,\r\n  };\r\n}\r\n"]}