{"version":3,"file":"atMentions.js","sourceRoot":"","sources":["../../../src/common/utils/atMentions.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from \"@/common/utils/assert\";\n\nexport interface AtMentionLineRange {\n  startLine: number;\n  endLine: number;\n}\n\nexport interface AtMention {\n  /** Original (trimmed) token contents after the leading @ (e.g. \"src/foo.ts#L1-3\"). */\n  token: string;\n  /** The file path portion (e.g. \"src/foo.ts\"). */\n  path: string;\n  /** Parsed line range when provided in #Lx-y form. */\n  range?: AtMentionLineRange;\n  /** Error message if a #... fragment was present but not a supported #Lx-y range. */\n  rangeError?: string;\n}\n\nexport interface AtMentionCursorMatch {\n  /** Index of the leading '@' character. */\n  startIndex: number;\n  /** End index (exclusive) of the mention token (does not include trailing punctuation). */\n  endIndex: number;\n  /** The query text after '@' (does not include any #... fragment). */\n  query: string;\n}\n\nconst TRAILING_PUNCTUATION_RE = /[(){}<>,.;:!?\"'`\\]]+$/;\n\nfunction stripTrailingPunctuation(token: string): string {\n  return token.replace(TRAILING_PUNCTUATION_RE, \"\");\n}\n\nfunction isWordChar(ch: string | undefined): boolean {\n  return Boolean(ch && /[A-Za-z0-9_]/.test(ch));\n}\n\nfunction parseRange(\n  fragment: string\n):\n  | { range: AtMentionLineRange; rangeError?: undefined }\n  | { range?: undefined; rangeError: string } {\n  const match = /^L(\\d+)-(\\d+)$/i.exec(fragment);\n  if (!match) {\n    return {\n      rangeError: `Unsupported range fragment: #${fragment} (expected #L<start>-<end>)`,\n    };\n  }\n\n  const start = Number(match[1]);\n  const end = Number(match[2]);\n  if (!Number.isFinite(start) || !Number.isFinite(end)) {\n    return { rangeError: `Invalid range fragment: #${fragment}` };\n  }\n  if (!Number.isInteger(start) || !Number.isInteger(end)) {\n    return { rangeError: `Invalid range fragment: #${fragment}` };\n  }\n  if (start < 1 || end < 1) {\n    return { rangeError: `Invalid range fragment: #${fragment} (line numbers must be >= 1)` };\n  }\n  if (start > end) {\n    return { rangeError: `Invalid range fragment: #${fragment} (start must be <= end)` };\n  }\n\n  return { range: { startLine: start, endLine: end } };\n}\n\n/**\n * Extract @mentions from freeform text.\n *\n * MVP rules:\n * - A mention starts at '@' and continues until whitespace.\n * - Trailing punctuation (commas, parens, etc.) is ignored.\n * - Optional line range suffix: #L<start>-<end>\n *\n * NOTE: Callers should apply additional heuristics (e.g. only expand when path looks like a file).\n */\nexport function extractAtMentions(text: string): AtMention[] {\n  const result: AtMention[] = [];\n\n  for (const match of text.matchAll(/@(\\S+)/g)) {\n    const index = match.index;\n    if (typeof index !== \"number\") continue;\n\n    // Avoid matching email addresses or other \"word@word\" patterns.\n    if (index > 0 && isWordChar(text[index - 1])) {\n      continue;\n    }\n\n    const rawToken = match[1];\n    if (typeof rawToken !== \"string\") continue;\n\n    const token = stripTrailingPunctuation(rawToken);\n    if (!token) continue;\n\n    const [path, fragment] = token.split(\"#\", 2);\n    if (!path) continue;\n\n    if (!fragment) {\n      result.push({ token, path });\n      continue;\n    }\n\n    const parsed = parseRange(fragment);\n    result.push({ token, path, ...parsed });\n  }\n\n  return result;\n}\n\n/**\n * Find the @mention token currently under the cursor.\n *\n * This is used for interactive autocomplete (file path suggestions). It intentionally ignores\n * tokens that already have a \"#\" fragment, since the user is likely specifying a line range.\n */\nexport function findAtMentionAtCursor(text: string, cursor: number): AtMentionCursorMatch | null {\n  assert(Number.isInteger(cursor), \"cursor must be an integer\");\n  assert(cursor >= 0 && cursor <= text.length, \"cursor out of bounds\");\n\n  // Expand to token boundaries (whitespace-delimited).\n  let tokenStart = cursor;\n  while (tokenStart > 0 && !/\\s/.test(text[tokenStart - 1] ?? \"\")) {\n    tokenStart--;\n  }\n\n  let tokenEnd = cursor;\n  while (tokenEnd < text.length && !/\\s/.test(text[tokenEnd] ?? \"\")) {\n    tokenEnd++;\n  }\n\n  // Search backwards for an '@' within this token, but avoid \"word@word\" patterns.\n  let atIndex = -1;\n  for (let i = cursor - 1; i >= tokenStart; i--) {\n    if (text[i] === \"@\") {\n      atIndex = i;\n      break;\n    }\n  }\n\n  if (atIndex === -1) {\n    return null;\n  }\n\n  if (atIndex > 0 && isWordChar(text[atIndex - 1])) {\n    return null;\n  }\n\n  const rawAfterAt = text.slice(atIndex + 1, tokenEnd);\n  const cleanedAfterAt = stripTrailingPunctuation(rawAfterAt);\n\n  // Do not autocomplete after the user started specifying a fragment (e.g. #L1-10).\n  if (cleanedAfterAt.includes(\"#\")) {\n    return null;\n  }\n\n  return {\n    startIndex: atIndex,\n    endIndex: atIndex + 1 + cleanedAfterAt.length,\n    query: cleanedAfterAt,\n  };\n}\n"]}