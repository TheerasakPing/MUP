{"version":3,"file":"asyncMessageQueue.js","sourceRoot":"","sources":["../../../src/common/utils/asyncMessageQueue.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,mCAIE;IACA,MAAM,KAAK,GAAQ,EAAE,CAAC;IACtB,IAAI,WAAW,GAAwB,IAAI,CAAC;IAC5C,IAAI,KAAK,GAAG,KAAK,CAAC;IAElB,MAAM,IAAI,GAAG,CAAC,GAAM,EAAE,EAAE,CAAC;QACvB,IAAI,KAAK;YAAE,OAAO;QAClB,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAChB,yCAAyC;QACzC,IAAI,WAAW,EAAE,CAAC;YAChB,MAAM,OAAO,GAAG,WAAW,CAAC;YAC5B,WAAW,GAAG,IAAI,CAAC;YACnB,OAAO,EAAE,CAAC;QACZ,CAAC;IAAA,CACF,CAAC;IAEF,KAAK,SAAS,CAAC,CAAC,OAAO,GAAsB;QAC3C,OAAO,CAAC,KAAK,EAAE,CAAC;YACd,gEAAgE;YAChE,mEAAmE;YACnE,gDAAgD;YAChD,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACxB,MAAM,KAAK,CAAC,KAAK,EAAG,CAAC;YACvB,CAAC;YACD,yBAAyB;YACzB,MAAM,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE,CAAC;gBACnC,WAAW,GAAG,OAAO,CAAC;YAAA,CACvB,CAAC,CAAC;QACL,CAAC;QACD,qDAAqD;QACrD,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACxB,MAAM,KAAK,CAAC,KAAK,EAAG,CAAC;QACvB,CAAC;IAAA,CACF;IAED,MAAM,GAAG,GAAG,GAAG,EAAE,CAAC;QAChB,KAAK,GAAG,IAAI,CAAC;QACb,sCAAsC;QACtC,IAAI,WAAW,EAAE,CAAC;YAChB,WAAW,EAAE,CAAC;QAChB,CAAC;IAAA,CACF,CAAC;IAEF,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC;AAAA,CAC/B","sourcesContent":["/**\r\n * Creates a queue-based async message stream.\r\n *\r\n * Messages pushed to the queue are yielded in batches (all queued messages\r\n * at once without async boundaries). This prevents premature React renders\r\n * when loading many messages quickly (e.g., history replay).\r\n *\r\n * Usage:\r\n * ```ts\r\n * const { push, iterate, end } = createAsyncMessageQueue<MyMessage>();\r\n *\r\n * // Push messages from any source\r\n * eventEmitter.on('message', push);\r\n *\r\n * // Consume as async generator\r\n * for await (const msg of iterate()) {\r\n *   handleMessage(msg);\r\n * }\r\n *\r\n * // Clean up\r\n * end();\r\n * ```\r\n */\r\nexport function createAsyncMessageQueue<T>(): {\r\n  push: (msg: T) => void;\r\n  iterate: () => AsyncGenerator<T>;\r\n  end: () => void;\r\n} {\r\n  const queue: T[] = [];\r\n  let resolveNext: (() => void) | null = null;\r\n  let ended = false;\r\n\r\n  const push = (msg: T) => {\r\n    if (ended) return;\r\n    queue.push(msg);\r\n    // Signal that new messages are available\r\n    if (resolveNext) {\r\n      const resolve = resolveNext;\r\n      resolveNext = null;\r\n      resolve();\r\n    }\r\n  };\r\n\r\n  async function* iterate(): AsyncGenerator<T> {\r\n    while (!ended) {\r\n      // Yield all queued messages synchronously (no async boundaries)\r\n      // This ensures all messages from a batch are processed in the same\r\n      // event loop tick, preventing premature renders\r\n      while (queue.length > 0) {\r\n        yield queue.shift()!;\r\n      }\r\n      // Wait for more messages\r\n      await new Promise<void>((resolve) => {\r\n        resolveNext = resolve;\r\n      });\r\n    }\r\n    // Yield any remaining messages after end() is called\r\n    while (queue.length > 0) {\r\n      yield queue.shift()!;\r\n    }\r\n  }\r\n\r\n  const end = () => {\r\n    ended = true;\r\n    // Wake up the iterator so it can exit\r\n    if (resolveNext) {\r\n      resolveNext();\r\n    }\r\n  };\r\n\r\n  return { push, iterate, end };\r\n}\r\n"]}