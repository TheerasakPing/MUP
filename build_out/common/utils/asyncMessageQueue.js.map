{"version":3,"file":"asyncMessageQueue.js","sourceRoot":"","sources":["../../../src/common/utils/asyncMessageQueue.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,mCAIE;IACA,MAAM,KAAK,GAAQ,EAAE,CAAC;IACtB,IAAI,WAAW,GAAwB,IAAI,CAAC;IAC5C,IAAI,KAAK,GAAG,KAAK,CAAC;IAElB,MAAM,IAAI,GAAG,CAAC,GAAM,EAAE,EAAE,CAAC;QACvB,IAAI,KAAK;YAAE,OAAO;QAClB,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAChB,yCAAyC;QACzC,IAAI,WAAW,EAAE,CAAC;YAChB,MAAM,OAAO,GAAG,WAAW,CAAC;YAC5B,WAAW,GAAG,IAAI,CAAC;YACnB,OAAO,EAAE,CAAC;QACZ,CAAC;IAAA,CACF,CAAC;IAEF,KAAK,SAAS,CAAC,CAAC,OAAO,GAAsB;QAC3C,OAAO,CAAC,KAAK,EAAE,CAAC;YACd,gEAAgE;YAChE,mEAAmE;YACnE,gDAAgD;YAChD,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACxB,MAAM,KAAK,CAAC,KAAK,EAAG,CAAC;YACvB,CAAC;YACD,yBAAyB;YACzB,MAAM,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE,CAAC;gBACnC,WAAW,GAAG,OAAO,CAAC;YAAA,CACvB,CAAC,CAAC;QACL,CAAC;QACD,qDAAqD;QACrD,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACxB,MAAM,KAAK,CAAC,KAAK,EAAG,CAAC;QACvB,CAAC;IAAA,CACF;IAED,MAAM,GAAG,GAAG,GAAG,EAAE,CAAC;QAChB,KAAK,GAAG,IAAI,CAAC;QACb,sCAAsC;QACtC,IAAI,WAAW,EAAE,CAAC;YAChB,WAAW,EAAE,CAAC;QAChB,CAAC;IAAA,CACF,CAAC;IAEF,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC;AAAA,CAC/B","sourcesContent":["/**\n * Creates a queue-based async message stream.\n *\n * Messages pushed to the queue are yielded in batches (all queued messages\n * at once without async boundaries). This prevents premature React renders\n * when loading many messages quickly (e.g., history replay).\n *\n * Usage:\n * ```ts\n * const { push, iterate, end } = createAsyncMessageQueue<MyMessage>();\n *\n * // Push messages from any source\n * eventEmitter.on('message', push);\n *\n * // Consume as async generator\n * for await (const msg of iterate()) {\n *   handleMessage(msg);\n * }\n *\n * // Clean up\n * end();\n * ```\n */\nexport function createAsyncMessageQueue<T>(): {\n  push: (msg: T) => void;\n  iterate: () => AsyncGenerator<T>;\n  end: () => void;\n} {\n  const queue: T[] = [];\n  let resolveNext: (() => void) | null = null;\n  let ended = false;\n\n  const push = (msg: T) => {\n    if (ended) return;\n    queue.push(msg);\n    // Signal that new messages are available\n    if (resolveNext) {\n      const resolve = resolveNext;\n      resolveNext = null;\n      resolve();\n    }\n  };\n\n  async function* iterate(): AsyncGenerator<T> {\n    while (!ended) {\n      // Yield all queued messages synchronously (no async boundaries)\n      // This ensures all messages from a batch are processed in the same\n      // event loop tick, preventing premature renders\n      while (queue.length > 0) {\n        yield queue.shift()!;\n      }\n      // Wait for more messages\n      await new Promise<void>((resolve) => {\n        resolveNext = resolve;\n      });\n    }\n    // Yield any remaining messages after end() is called\n    while (queue.length > 0) {\n      yield queue.shift()!;\n    }\n  }\n\n  const end = () => {\n    ended = true;\n    // Wake up the iterator so it can exit\n    if (resolveNext) {\n      resolveNext();\n    }\n  };\n\n  return { push, iterate, end };\n}\n"]}