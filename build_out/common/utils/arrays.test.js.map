{"version":3,"file":"arrays.test.js","sourceRoot":"","sources":["../../../src/common/utils/arrays.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { arraysEqualByReference } from \"./arrays\";\n\ndescribe(\"arraysEqualByReference\", () => {\n  it(\"returns true for two empty arrays\", () => {\n    expect(arraysEqualByReference([], [])).toBe(true);\n  });\n\n  it(\"returns true for arrays with same references\", () => {\n    const obj1 = { id: 1 };\n    const obj2 = { id: 2 };\n    const obj3 = { id: 3 };\n\n    const a = [obj1, obj2, obj3];\n    const b = [obj1, obj2, obj3];\n\n    expect(arraysEqualByReference(a, b)).toBe(true);\n  });\n\n  it(\"returns false for arrays with different lengths\", () => {\n    const obj1 = { id: 1 };\n    const obj2 = { id: 2 };\n\n    const a = [obj1, obj2];\n    const b = [obj1];\n\n    expect(arraysEqualByReference(a, b)).toBe(false);\n  });\n\n  it(\"returns false when objects differ by reference\", () => {\n    const obj1 = { id: 1 };\n    const obj2 = { id: 2 };\n    const obj3 = { id: 3 };\n    const obj4 = { id: 3 }; // Same value, different reference\n\n    const a = [obj1, obj2, obj3];\n    const b = [obj1, obj2, obj4];\n\n    expect(arraysEqualByReference(a, b)).toBe(false);\n  });\n\n  it(\"returns false for arrays with same elements in different order\", () => {\n    const obj1 = { id: 1 };\n    const obj2 = { id: 2 };\n\n    const a = [obj1, obj2];\n    const b = [obj2, obj1];\n\n    expect(arraysEqualByReference(a, b)).toBe(false);\n  });\n\n  it(\"short-circuits on first mismatch\", () => {\n    const obj1 = { id: 1 };\n    const obj2 = { id: 2 };\n    const obj3 = { id: 3 };\n\n    // Create large arrays where first element differs\n    const a = [obj1, ...Array<{ id: number }>(1000).fill(obj2)];\n    const b = [obj3, ...Array<{ id: number }>(1000).fill(obj2)];\n\n    // Should return false immediately without checking all 1001 elements\n    expect(arraysEqualByReference(a, b)).toBe(false);\n  });\n\n  it(\"works with primitive values\", () => {\n    const a = [1, 2, 3];\n    const b = [1, 2, 3];\n\n    expect(arraysEqualByReference(a, b)).toBe(true);\n  });\n\n  it(\"works with mixed types\", () => {\n    const obj = { id: 1 };\n    const a = [1, \"hello\", obj, true, null];\n    const b = [1, \"hello\", obj, true, null];\n\n    expect(arraysEqualByReference(a, b)).toBe(true);\n  });\n\n  it(\"returns false for undefined vs null at same index\", () => {\n    const a = [undefined];\n    const b = [null];\n\n    expect(arraysEqualByReference(a, b)).toBe(false);\n  });\n\n  it(\"handles arrays with undefined elements\", () => {\n    const a = [1, undefined, 3];\n    const b = [1, undefined, 3];\n\n    expect(arraysEqualByReference(a, b)).toBe(true);\n  });\n\n  it(\"returns true for same array reference\", () => {\n    const a = [1, 2, 3];\n\n    expect(arraysEqualByReference(a, a)).toBe(true);\n  });\n});\n"]}