{"version":3,"file":"gitStatus.js","sourceRoot":"","sources":["../../../../src/common/utils/git/gitStatus.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;AAEH;;;;;;GAMG;AACH,iCAAwC,OAAgB,EAAU;IAChE,8EAA8E;IAC9E,MAAM,eAAe,GAAG,OAAO,EAAE,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IAE/F,OAAO;;;oBAGW,eAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwFlC,CAAC;AAAA,CACD;AAED;;GAEG;AACU,QAAA,iBAAiB,GAAG,uBAAuB,EAAE,CAAC;AAmB3D,oCAA2C,MAAc,EAAgC;IACvF,sEAAsE;IACtE,MAAM,eAAe,GAAG,6CAA6C,CAAC;IACtE,MAAM,YAAY,GAAG,8CAA8C,CAAC;IACpE,MAAM,gBAAgB,GAAG,oCAAoC,CAAC;IAC9D,MAAM,UAAU,GAAG,qBAAqB,CAAC;IACzC,MAAM,cAAc,GAAG,kDAAkD,CAAC;IAE1E,MAAM,eAAe,GAAG,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACrD,MAAM,YAAY,GAAG,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC/C,MAAM,gBAAgB,GAAG,gBAAgB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACvD,MAAM,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC3C,MAAM,cAAc,GAAG,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAEnD,IAAI,CAAC,YAAY,IAAI,CAAC,gBAAgB,IAAI,CAAC,UAAU,EAAE,CAAC;QACtD,OAAO,IAAI,CAAC;IACd,CAAC;IAED,MAAM,KAAK,GAAG,QAAQ,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IAChD,MAAM,MAAM,GAAG,QAAQ,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IAEjD,IAAI,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC;QAChD,OAAO,IAAI,CAAC;IACd,CAAC;IAED,MAAM,iBAAiB,GAAG,cAAc,CAAC,CAAC,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/E,MAAM,iBAAiB,GAAG,cAAc,CAAC,CAAC,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/E,MAAM,iBAAiB,GAAG,cAAc,CAAC,CAAC,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/E,MAAM,iBAAiB,GAAG,cAAc,CAAC,CAAC,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAE/E,OAAO;QACL,UAAU,EAAE,eAAe,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE;QAC5D,aAAa,EAAE,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;QACrC,KAAK;QACL,MAAM;QACN,UAAU,EAAE,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QACvC,iBAAiB;QACjB,iBAAiB;QACjB,iBAAiB;QACjB,iBAAiB;KAClB,CAAC;AAAA,CACH;AAED;;;;;;;;;;;;GAYG;AACU,QAAA,gBAAgB,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0C/B,CAAC","sourcesContent":["/**\r\n * Git status script and parsing utilities.\r\n * Frontend-safe (no Node.js imports).\r\n */\r\n\r\n/**\r\n * Generate bash script to get git status for a workspace.\r\n * Returns structured output with base ref, ahead/behind counts, and dirty status.\r\n *\r\n * @param baseRef - The ref to compare against (e.g., \"origin/main\").\r\n *                  If not provided or not an origin/ ref, auto-detects.\r\n */\r\nexport function generateGitStatusScript(baseRef?: string): string {\r\n  // Extract branch name if it's an origin/ ref, otherwise empty for auto-detect\r\n  const preferredBranch = baseRef?.startsWith(\"origin/\") ? baseRef.replace(/^origin\\//, \"\") : \"\";\r\n\r\n  return `\r\n# Determine primary branch to compare against\r\nPRIMARY_BRANCH=\"\"\r\nPREFERRED_BRANCH=\"${preferredBranch}\"\r\n\r\n# Try preferred branch first if specified\r\nif [ -n \"$PREFERRED_BRANCH\" ]; then\r\n  if git rev-parse --verify \"refs/remotes/origin/$PREFERRED_BRANCH\" >/dev/null 2>&1; then\r\n    PRIMARY_BRANCH=\"$PREFERRED_BRANCH\"\r\n  fi\r\nfi\r\n\r\n# Fall back to auto-detection\r\nif [ -z \"$PRIMARY_BRANCH\" ]; then\r\n  # Method 1: symbolic-ref (fastest)\r\n  PRIMARY_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')\r\n\r\n  # Method 2: remote show origin (fallback)\r\n  if [ -z \"$PRIMARY_BRANCH\" ]; then\r\n    PRIMARY_BRANCH=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d' ' -f5)\r\n  fi\r\n\r\n  # Method 3: check for main or master\r\n  if [ -z \"$PRIMARY_BRANCH\" ]; then\r\n    PRIMARY_BRANCH=$(git branch -r 2>/dev/null | grep -E 'origin/(main|master)$' | head -1 | sed 's@^.*origin/@@')\r\n  fi\r\nfi\r\n\r\n# Exit if we can't determine primary branch\r\nif [ -z \"$PRIMARY_BRANCH\" ]; then\r\n  echo \"ERROR: Could not determine primary branch\"\r\n  exit 1\r\nfi\r\n\r\n# Avoid sampling while git is holding the index lock (e.g., mid-commit)\r\nGIT_DIR=$(git rev-parse --git-dir 2>/dev/null || echo \"\")\r\nif [ -n \"$GIT_DIR\" ]; then\r\n  LOCK_PATH=\"$GIT_DIR/index.lock\"\r\n  retries=0\r\n  while [ -f \"$LOCK_PATH\" ] && [ $retries -lt 20 ]; do\r\n    sleep 0.05\r\n    retries=$((retries + 1))\r\n  done\r\nfi\r\n\r\n# Stable ahead/behind counts (rev-list is format-stable across git versions)\r\nAHEAD_BEHIND=$(git rev-list --left-right --count HEAD...\"origin/$PRIMARY_BRANCH\" 2>/dev/null || echo \"\")\r\nif [ -z \"$AHEAD_BEHIND\" ]; then\r\n  AHEAD_BEHIND=\"0 0\"\r\nfi\r\n\r\n# Check for dirty (uncommitted changes)\r\nDIRTY_COUNT=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')\r\n\r\n# Compute line deltas (additions/deletions) vs merge-base with origin's primary branch.\r\n#\r\n# We emit *only* totals to keep output tiny (avoid output truncation in large repos).\r\nMERGE_BASE=$(git merge-base HEAD \"origin/$PRIMARY_BRANCH\" 2>/dev/null || echo \"\")\r\n\r\n# Outgoing: local changes vs merge-base (working tree vs base, includes uncommitted changes)\r\nOUTGOING_STATS=\"0 0\"\r\nif [ -n \"$MERGE_BASE\" ]; then\r\n  OUTGOING_STATS=$(git diff --numstat \"$MERGE_BASE\" 2>/dev/null | awk '{ if ($1 == \"-\" || $2 == \"-\") next; add += $1; del += $2 } END { printf \"%d %d\", add+0, del+0 }')\r\n  if [ -z \"$OUTGOING_STATS\" ]; then\r\n    OUTGOING_STATS=\"0 0\"\r\n  fi\r\nfi\r\n\r\n# Incoming: remote primary branch changes vs merge-base\r\nINCOMING_STATS=\"0 0\"\r\nif [ -n \"$MERGE_BASE\" ]; then\r\n  INCOMING_STATS=$(git diff --numstat \"$MERGE_BASE\" \"origin/$PRIMARY_BRANCH\" 2>/dev/null | awk '{ if ($1 == \"-\" || $2 == \"-\") next; add += $1; del += $2 } END { printf \"%d %d\", add+0, del+0 }')\r\n  if [ -z \"$INCOMING_STATS\" ]; then\r\n    INCOMING_STATS=\"0 0\"\r\n  fi\r\nfi\r\n\r\n# Detect current HEAD branch (for branch selector updates)\r\nHEAD_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo \"\")\r\n\r\n# Output sections\r\necho \"---HEAD_BRANCH---\"\r\necho \"$HEAD_BRANCH\"\r\necho \"---PRIMARY---\"\r\necho \"$PRIMARY_BRANCH\"\r\necho \"---AHEAD_BEHIND---\"\r\necho \"$AHEAD_BEHIND\"\r\necho \"---DIRTY---\"\r\necho \"$DIRTY_COUNT\"\r\necho \"---LINE_DELTA---\"\r\necho \"$OUTGOING_STATS $INCOMING_STATS\"\r\n`;\r\n}\r\n\r\n/**\r\n * Bash script to get git status for a workspace (auto-detects primary branch).\r\n */\r\nexport const GIT_STATUS_SCRIPT = generateGitStatusScript();\r\n\r\n/**\r\n * Parse the output from GIT_STATUS_SCRIPT.\r\n * Frontend-safe parsing function.\r\n */\r\nexport interface ParsedGitStatusOutput {\r\n  /** The current HEAD branch (empty string if detached HEAD) */\r\n  headBranch: string;\r\n  primaryBranch: string;\r\n  ahead: number;\r\n  behind: number;\r\n  dirtyCount: number;\r\n  outgoingAdditions: number;\r\n  outgoingDeletions: number;\r\n  incomingAdditions: number;\r\n  incomingDeletions: number;\r\n}\r\n\r\nexport function parseGitStatusScriptOutput(output: string): ParsedGitStatusOutput | null {\r\n  // Split by section markers using regex to get content between markers\r\n  const headBranchRegex = /---HEAD_BRANCH---\\s*([\\s\\S]*?)---PRIMARY---/;\r\n  const primaryRegex = /---PRIMARY---\\s*([\\s\\S]*?)---AHEAD_BEHIND---/;\r\n  const aheadBehindRegex = /---AHEAD_BEHIND---\\s*(\\d+)\\s+(\\d+)/;\r\n  const dirtyRegex = /---DIRTY---\\s*(\\d+)/;\r\n  const lineDeltaRegex = /---LINE_DELTA---\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)/;\r\n\r\n  const headBranchMatch = headBranchRegex.exec(output);\r\n  const primaryMatch = primaryRegex.exec(output);\r\n  const aheadBehindMatch = aheadBehindRegex.exec(output);\r\n  const dirtyMatch = dirtyRegex.exec(output);\r\n  const lineDeltaMatch = lineDeltaRegex.exec(output);\r\n\r\n  if (!primaryMatch || !aheadBehindMatch || !dirtyMatch) {\r\n    return null;\r\n  }\r\n\r\n  const ahead = parseInt(aheadBehindMatch[1], 10);\r\n  const behind = parseInt(aheadBehindMatch[2], 10);\r\n\r\n  if (Number.isNaN(ahead) || Number.isNaN(behind)) {\r\n    return null;\r\n  }\r\n\r\n  const outgoingAdditions = lineDeltaMatch ? parseInt(lineDeltaMatch[1], 10) : 0;\r\n  const outgoingDeletions = lineDeltaMatch ? parseInt(lineDeltaMatch[2], 10) : 0;\r\n  const incomingAdditions = lineDeltaMatch ? parseInt(lineDeltaMatch[3], 10) : 0;\r\n  const incomingDeletions = lineDeltaMatch ? parseInt(lineDeltaMatch[4], 10) : 0;\r\n\r\n  return {\r\n    headBranch: headBranchMatch ? headBranchMatch[1].trim() : \"\",\r\n    primaryBranch: primaryMatch[1].trim(),\r\n    ahead,\r\n    behind,\r\n    dirtyCount: parseInt(dirtyMatch[1], 10),\r\n    outgoingAdditions,\r\n    outgoingDeletions,\r\n    incomingAdditions,\r\n    incomingDeletions,\r\n  };\r\n}\r\n\r\n/**\r\n * Smart git fetch script that minimizes lock contention.\r\n *\r\n * Uses ls-remote to check if remote has new commits before fetching.\r\n * This avoids locks in the common case where remote SHA is already local\r\n * (e.g., IDE or user already fetched).\r\n *\r\n * Flow:\r\n * 1. ls-remote to get remote SHA (no lock, network only)\r\n * 2. cat-file to check if SHA exists locally (no lock)\r\n * 3. If local: skip fetch (no lock needed)\r\n * 4. If not local: fetch to get new commits (lock, but rare)\r\n */\r\nexport const GIT_FETCH_SCRIPT = `\r\n# Disable ALL prompts\r\nexport GIT_TERMINAL_PROMPT=0\r\nexport GIT_ASKPASS=echo\r\nexport SSH_ASKPASS=echo\r\nexport GIT_SSH_COMMAND=\"\\${GIT_SSH_COMMAND:-ssh} -o BatchMode=yes -o StrictHostKeyChecking=accept-new\"\r\n\r\n# Get primary branch name\r\nPRIMARY_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')\r\nif [ -z \"$PRIMARY_BRANCH\" ]; then\r\n  PRIMARY_BRANCH=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d' ' -f5)\r\nfi\r\nif [ -z \"$PRIMARY_BRANCH\" ]; then\r\n  PRIMARY_BRANCH=\"main\"\r\nfi\r\n\r\n# Check remote SHA via ls-remote (no lock, network only)\r\nREMOTE_SHA=$(git ls-remote origin \"refs/heads/$PRIMARY_BRANCH\" 2>/dev/null | cut -f1)\r\nif [ -z \"$REMOTE_SHA\" ]; then\r\n  echo \"SKIP: Could not get remote SHA\"\r\n  exit 0\r\nfi\r\n\r\n# Check current local remote-tracking ref (no lock)\r\nLOCAL_SHA=$(git rev-parse --verify \"refs/remotes/origin/$PRIMARY_BRANCH\" 2>/dev/null || echo \"\")\r\n\r\n# If local tracking ref already matches remote, skip fetch\r\nif [ \"$LOCAL_SHA\" = \"$REMOTE_SHA\" ]; then\r\n  echo \"SKIP: Remote SHA already fetched\"\r\n  exit 0\r\nfi\r\n\r\n# Remote has new commits or ref moved - fetch updates\r\ngit -c protocol.version=2 \\\\\r\n    -c fetch.negotiationAlgorithm=skipping \\\\\r\n    fetch origin \\\\\r\n    --prune \\\\\r\n    --no-tags \\\\\r\n    --no-recurse-submodules \\\\\r\n    --no-write-fetch-head \\\\\r\n    --filter=blob:none \\\\\r\n    2>&1\r\n`;\r\n"]}