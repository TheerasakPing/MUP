{"version":3,"file":"gitStatus.js","sourceRoot":"","sources":["../../../../src/common/utils/git/gitStatus.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Git status script and parsing utilities.\n * Frontend-safe (no Node.js imports).\n */\n\n/**\n * Generate bash script to get git status for a workspace.\n * Returns structured output with base ref, ahead/behind counts, and dirty status.\n *\n * @param baseRef - The ref to compare against (e.g., \"origin/main\").\n *                  If not provided or not an origin/ ref, auto-detects.\n */\nexport function generateGitStatusScript(baseRef?: string): string {\n  // Extract branch name if it's an origin/ ref, otherwise empty for auto-detect\n  const preferredBranch = baseRef?.startsWith(\"origin/\") ? baseRef.replace(/^origin\\//, \"\") : \"\";\n\n  return `\n# Determine primary branch to compare against\nPRIMARY_BRANCH=\"\"\nPREFERRED_BRANCH=\"${preferredBranch}\"\n\n# Try preferred branch first if specified\nif [ -n \"$PREFERRED_BRANCH\" ]; then\n  if git rev-parse --verify \"refs/remotes/origin/$PREFERRED_BRANCH\" >/dev/null 2>&1; then\n    PRIMARY_BRANCH=\"$PREFERRED_BRANCH\"\n  fi\nfi\n\n# Fall back to auto-detection\nif [ -z \"$PRIMARY_BRANCH\" ]; then\n  # Method 1: symbolic-ref (fastest)\n  PRIMARY_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')\n\n  # Method 2: remote show origin (fallback)\n  if [ -z \"$PRIMARY_BRANCH\" ]; then\n    PRIMARY_BRANCH=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d' ' -f5)\n  fi\n\n  # Method 3: check for main or master\n  if [ -z \"$PRIMARY_BRANCH\" ]; then\n    PRIMARY_BRANCH=$(git branch -r 2>/dev/null | grep -E 'origin/(main|master)$' | head -1 | sed 's@^.*origin/@@')\n  fi\nfi\n\n# Exit if we can't determine primary branch\nif [ -z \"$PRIMARY_BRANCH\" ]; then\n  echo \"ERROR: Could not determine primary branch\"\n  exit 1\nfi\n\n# Avoid sampling while git is holding the index lock (e.g., mid-commit)\nGIT_DIR=$(git rev-parse --git-dir 2>/dev/null || echo \"\")\nif [ -n \"$GIT_DIR\" ]; then\n  LOCK_PATH=\"$GIT_DIR/index.lock\"\n  retries=0\n  while [ -f \"$LOCK_PATH\" ] && [ $retries -lt 20 ]; do\n    sleep 0.05\n    retries=$((retries + 1))\n  done\nfi\n\n# Stable ahead/behind counts (rev-list is format-stable across git versions)\nAHEAD_BEHIND=$(git rev-list --left-right --count HEAD...\"origin/$PRIMARY_BRANCH\" 2>/dev/null || echo \"\")\nif [ -z \"$AHEAD_BEHIND\" ]; then\n  AHEAD_BEHIND=\"0 0\"\nfi\n\n# Check for dirty (uncommitted changes)\nDIRTY_COUNT=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')\n\n# Compute line deltas (additions/deletions) vs merge-base with origin's primary branch.\n#\n# We emit *only* totals to keep output tiny (avoid output truncation in large repos).\nMERGE_BASE=$(git merge-base HEAD \"origin/$PRIMARY_BRANCH\" 2>/dev/null || echo \"\")\n\n# Outgoing: local changes vs merge-base (working tree vs base, includes uncommitted changes)\nOUTGOING_STATS=\"0 0\"\nif [ -n \"$MERGE_BASE\" ]; then\n  OUTGOING_STATS=$(git diff --numstat \"$MERGE_BASE\" 2>/dev/null | awk '{ if ($1 == \"-\" || $2 == \"-\") next; add += $1; del += $2 } END { printf \"%d %d\", add+0, del+0 }')\n  if [ -z \"$OUTGOING_STATS\" ]; then\n    OUTGOING_STATS=\"0 0\"\n  fi\nfi\n\n# Incoming: remote primary branch changes vs merge-base\nINCOMING_STATS=\"0 0\"\nif [ -n \"$MERGE_BASE\" ]; then\n  INCOMING_STATS=$(git diff --numstat \"$MERGE_BASE\" \"origin/$PRIMARY_BRANCH\" 2>/dev/null | awk '{ if ($1 == \"-\" || $2 == \"-\") next; add += $1; del += $2 } END { printf \"%d %d\", add+0, del+0 }')\n  if [ -z \"$INCOMING_STATS\" ]; then\n    INCOMING_STATS=\"0 0\"\n  fi\nfi\n\n# Detect current HEAD branch (for branch selector updates)\nHEAD_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo \"\")\n\n# Output sections\necho \"---HEAD_BRANCH---\"\necho \"$HEAD_BRANCH\"\necho \"---PRIMARY---\"\necho \"$PRIMARY_BRANCH\"\necho \"---AHEAD_BEHIND---\"\necho \"$AHEAD_BEHIND\"\necho \"---DIRTY---\"\necho \"$DIRTY_COUNT\"\necho \"---LINE_DELTA---\"\necho \"$OUTGOING_STATS $INCOMING_STATS\"\n`;\n}\n\n/**\n * Bash script to get git status for a workspace (auto-detects primary branch).\n */\nexport const GIT_STATUS_SCRIPT = generateGitStatusScript();\n\n/**\n * Parse the output from GIT_STATUS_SCRIPT.\n * Frontend-safe parsing function.\n */\nexport interface ParsedGitStatusOutput {\n  /** The current HEAD branch (empty string if detached HEAD) */\n  headBranch: string;\n  primaryBranch: string;\n  ahead: number;\n  behind: number;\n  dirtyCount: number;\n  outgoingAdditions: number;\n  outgoingDeletions: number;\n  incomingAdditions: number;\n  incomingDeletions: number;\n}\n\nexport function parseGitStatusScriptOutput(output: string): ParsedGitStatusOutput | null {\n  // Split by section markers using regex to get content between markers\n  const headBranchRegex = /---HEAD_BRANCH---\\s*([\\s\\S]*?)---PRIMARY---/;\n  const primaryRegex = /---PRIMARY---\\s*([\\s\\S]*?)---AHEAD_BEHIND---/;\n  const aheadBehindRegex = /---AHEAD_BEHIND---\\s*(\\d+)\\s+(\\d+)/;\n  const dirtyRegex = /---DIRTY---\\s*(\\d+)/;\n  const lineDeltaRegex = /---LINE_DELTA---\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)/;\n\n  const headBranchMatch = headBranchRegex.exec(output);\n  const primaryMatch = primaryRegex.exec(output);\n  const aheadBehindMatch = aheadBehindRegex.exec(output);\n  const dirtyMatch = dirtyRegex.exec(output);\n  const lineDeltaMatch = lineDeltaRegex.exec(output);\n\n  if (!primaryMatch || !aheadBehindMatch || !dirtyMatch) {\n    return null;\n  }\n\n  const ahead = parseInt(aheadBehindMatch[1], 10);\n  const behind = parseInt(aheadBehindMatch[2], 10);\n\n  if (Number.isNaN(ahead) || Number.isNaN(behind)) {\n    return null;\n  }\n\n  const outgoingAdditions = lineDeltaMatch ? parseInt(lineDeltaMatch[1], 10) : 0;\n  const outgoingDeletions = lineDeltaMatch ? parseInt(lineDeltaMatch[2], 10) : 0;\n  const incomingAdditions = lineDeltaMatch ? parseInt(lineDeltaMatch[3], 10) : 0;\n  const incomingDeletions = lineDeltaMatch ? parseInt(lineDeltaMatch[4], 10) : 0;\n\n  return {\n    headBranch: headBranchMatch ? headBranchMatch[1].trim() : \"\",\n    primaryBranch: primaryMatch[1].trim(),\n    ahead,\n    behind,\n    dirtyCount: parseInt(dirtyMatch[1], 10),\n    outgoingAdditions,\n    outgoingDeletions,\n    incomingAdditions,\n    incomingDeletions,\n  };\n}\n\n/**\n * Smart git fetch script that minimizes lock contention.\n *\n * Uses ls-remote to check if remote has new commits before fetching.\n * This avoids locks in the common case where remote SHA is already local\n * (e.g., IDE or user already fetched).\n *\n * Flow:\n * 1. ls-remote to get remote SHA (no lock, network only)\n * 2. cat-file to check if SHA exists locally (no lock)\n * 3. If local: skip fetch (no lock needed)\n * 4. If not local: fetch to get new commits (lock, but rare)\n */\nexport const GIT_FETCH_SCRIPT = `\n# Disable ALL prompts\nexport GIT_TERMINAL_PROMPT=0\nexport GIT_ASKPASS=echo\nexport SSH_ASKPASS=echo\nexport GIT_SSH_COMMAND=\"\\${GIT_SSH_COMMAND:-ssh} -o BatchMode=yes -o StrictHostKeyChecking=accept-new\"\n\n# Get primary branch name\nPRIMARY_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')\nif [ -z \"$PRIMARY_BRANCH\" ]; then\n  PRIMARY_BRANCH=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d' ' -f5)\nfi\nif [ -z \"$PRIMARY_BRANCH\" ]; then\n  PRIMARY_BRANCH=\"main\"\nfi\n\n# Check remote SHA via ls-remote (no lock, network only)\nREMOTE_SHA=$(git ls-remote origin \"refs/heads/$PRIMARY_BRANCH\" 2>/dev/null | cut -f1)\nif [ -z \"$REMOTE_SHA\" ]; then\n  echo \"SKIP: Could not get remote SHA\"\n  exit 0\nfi\n\n# Check current local remote-tracking ref (no lock)\nLOCAL_SHA=$(git rev-parse --verify \"refs/remotes/origin/$PRIMARY_BRANCH\" 2>/dev/null || echo \"\")\n\n# If local tracking ref already matches remote, skip fetch\nif [ \"$LOCAL_SHA\" = \"$REMOTE_SHA\" ]; then\n  echo \"SKIP: Remote SHA already fetched\"\n  exit 0\nfi\n\n# Remote has new commits or ref moved - fetch updates\ngit -c protocol.version=2 \\\\\n    -c fetch.negotiationAlgorithm=skipping \\\\\n    fetch origin \\\\\n    --prune \\\\\n    --no-tags \\\\\n    --no-recurse-submodules \\\\\n    --no-write-fetch-head \\\\\n    --filter=blob:none \\\\\n    2>&1\n`;\n"]}