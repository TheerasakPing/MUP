{"version":3,"file":"diffParser.js","sourceRoot":"","sources":["../../../../src/common/utils/git/diffParser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Git diff parser - parses unified diff output into structured hunks\r\n */\r\n\r\nimport type { DiffHunk, FileDiff } from \"@/common/types/review\";\r\n\r\n/**\r\n * Generate a stable content-based ID for a hunk\r\n * Uses file path + line range + diff content to ensure uniqueness\r\n */\r\nfunction generateHunkId(\r\n  filePath: string,\r\n  oldStart: number,\r\n  newStart: number,\r\n  content: string\r\n): string {\r\n  // Hash file path + line range + diff content for uniqueness and rebase stability\r\n  const str = `${filePath}:${oldStart}-${newStart}:${content}`;\r\n  let hash = 0;\r\n  for (let i = 0; i < str.length; i++) {\r\n    const char = str.charCodeAt(i);\r\n    hash = (hash << 5) - hash + char;\r\n    hash = hash & hash; // Convert to 32bit integer\r\n  }\r\n  return `hunk-${Math.abs(hash).toString(16)}`;\r\n}\r\n\r\n/**\r\n * Parse a hunk header line (e.g., \"@@ -1,5 +1,6 @@ optional context\")\r\n * Returns null if the line is not a valid hunk header\r\n */\r\nfunction parseHunkHeader(line: string): {\r\n  oldStart: number;\r\n  oldLines: number;\r\n  newStart: number;\r\n  newLines: number;\r\n} | null {\r\n  const regex = /^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/;\r\n  const match = regex.exec(line);\r\n  if (!match) return null;\r\n\r\n  return {\r\n    oldStart: parseInt(match[1], 10),\r\n    oldLines: match[2] ? parseInt(match[2], 10) : 1,\r\n    newStart: parseInt(match[3], 10),\r\n    newLines: match[4] ? parseInt(match[4], 10) : 1,\r\n  };\r\n}\r\n\r\n/**\r\n * Parse unified diff output into structured file diffs with hunks\r\n * Supports standard git diff format with file headers and hunk markers\r\n */\r\nexport function parseDiff(diffOutput: string): FileDiff[] {\r\n  // Normalize line endings so CRLF diffs (and CRLF file contents) don't leak `\\r` into the UI.\r\n  // Note: a CRLF file often produces diff lines ending in `\\r\\n` (the `\\r` is part of the file line).\r\n  const lines = diffOutput.split(/\\r?\\n/);\r\n  // Intentionally keep the trailing empty line from a final newline.\r\n  // (When a hunk is still open, we convert it into a \" \" context line so the UI\r\n  // has a stable trailing line for selection/comment placement.)\r\n  const files: FileDiff[] = [];\r\n  let currentFile: FileDiff | null = null;\r\n  let currentHunk: Partial<DiffHunk> | null = null;\r\n  let hunkLines: string[] = [];\r\n\r\n  const finishHunk = () => {\r\n    if (currentHunk && currentFile && hunkLines.length > 0) {\r\n      const content = hunkLines.join(\"\\n\");\r\n      const hunkId = generateHunkId(\r\n        currentFile.filePath,\r\n        currentHunk.oldStart!,\r\n        currentHunk.newStart!,\r\n        content\r\n      );\r\n      currentFile.hunks.push({\r\n        ...currentHunk,\r\n        id: hunkId,\r\n        filePath: currentFile.filePath,\r\n        content,\r\n        changeType: currentFile.changeType,\r\n        oldPath: currentFile.oldPath,\r\n      } as DiffHunk);\r\n      hunkLines = [];\r\n      currentHunk = null;\r\n    }\r\n  };\r\n\r\n  const finishFile = () => {\r\n    finishHunk();\r\n    if (currentFile) {\r\n      files.push(currentFile);\r\n      currentFile = null;\r\n    }\r\n  };\r\n\r\n  for (const line of lines) {\r\n    // File header: diff --git a/... b/...\r\n    if (line.startsWith(\"diff --git \")) {\r\n      finishFile();\r\n      // Extract file paths from \"diff --git a/path b/path\"\r\n      const regex = /^diff --git a\\/(.+) b\\/(.+)$/;\r\n      const match = regex.exec(line);\r\n      if (match) {\r\n        const oldPath = match[1];\r\n        const newPath = match[2];\r\n        currentFile = {\r\n          filePath: newPath,\r\n          oldPath: oldPath !== newPath ? oldPath : undefined,\r\n          changeType: \"modified\",\r\n          isBinary: false,\r\n          hunks: [],\r\n        };\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (!currentFile) continue;\r\n\r\n    // Binary file marker\r\n    if (line.startsWith(\"Binary files \")) {\r\n      currentFile.isBinary = true;\r\n      continue;\r\n    }\r\n\r\n    // New file mode\r\n    if (line.startsWith(\"new file mode \")) {\r\n      currentFile.changeType = \"added\";\r\n      continue;\r\n    }\r\n\r\n    // Deleted file mode\r\n    if (line.startsWith(\"deleted file mode \")) {\r\n      currentFile.changeType = \"deleted\";\r\n      continue;\r\n    }\r\n\r\n    // Rename marker\r\n    if (line.startsWith(\"rename from \") || line.startsWith(\"rename to \")) {\r\n      currentFile.changeType = \"renamed\";\r\n      continue;\r\n    }\r\n\r\n    // Hunk header\r\n    if (line.startsWith(\"@@\")) {\r\n      finishHunk();\r\n      const parsed = parseHunkHeader(line);\r\n      if (parsed) {\r\n        currentHunk = {\r\n          ...parsed,\r\n          header: line,\r\n        };\r\n      }\r\n      continue;\r\n    }\r\n\r\n    // Hunk content (lines starting with +, -, or space)\r\n    if (currentHunk && (line.startsWith(\"+\") || line.startsWith(\"-\") || line.startsWith(\" \"))) {\r\n      hunkLines.push(line);\r\n      continue;\r\n    }\r\n\r\n    // Context line in hunk (no prefix, but within a hunk)\r\n    if (currentHunk && line.length === 0) {\r\n      hunkLines.push(\" \"); // Treat empty line as context\r\n      continue;\r\n    }\r\n  }\r\n\r\n  // Finish last file\r\n  finishFile();\r\n\r\n  return files;\r\n}\r\n\r\n/**\r\n * Extract all hunks from file diffs\r\n * Flattens the file -> hunks structure into a single array\r\n */\r\nexport function extractAllHunks(fileDiffs: FileDiff[]): DiffHunk[] {\r\n  return fileDiffs.flatMap((file) => file.hunks);\r\n}\r\n\r\n/**\r\n * Build git diff command based on diffBase and includeUncommitted flag\r\n * Shared logic between numstat (file tree) and diff (hunks) commands\r\n *\r\n * Git diff semantics:\r\n * - `git diff A...HEAD` (three-dot): Shows commits on current branch since branching from A\r\n *   → Uses merge-base(A, HEAD) as comparison point, so changes to A after branching don't appear\r\n * - `git diff $(git merge-base A HEAD)`: Shows all changes from branch point to working directory\r\n *   → Includes both committed changes on the branch AND uncommitted working directory changes\r\n *   → Single unified diff (no duplicate hunks from concatenation)\r\n * - `git diff HEAD`: Shows only uncommitted changes (working directory vs HEAD)\r\n * - `git diff --staged`: Shows only staged changes (index vs HEAD)\r\n *\r\n * The key insight: When includeUncommitted is true, we compare from the merge-base directly\r\n * to the working directory. This gives a stable comparison point (doesn't change when base\r\n * ref moves forward) while including both committed and uncommitted work in a single diff.\r\n *\r\n * @param diffBase - Base reference (\"main\", \"HEAD\", \"--staged\")\r\n * @param includeUncommitted - Include uncommitted working directory changes\r\n * @param pathFilter - Optional path filter (e.g., ' -- \"src/foo.ts\"')\r\n * @param command - \"diff\" (unified), \"numstat\" (file stats), or \"name-status\" (file status)\r\n */\r\nexport function buildGitDiffCommand(\r\n  diffBase: string,\r\n  includeUncommitted: boolean,\r\n  pathFilter: string,\r\n  command: \"diff\" | \"numstat\" | \"name-status\"\r\n): string {\r\n  const flags =\r\n    command === \"numstat\"\r\n      ? \" -M --numstat\"\r\n      : command === \"name-status\"\r\n        ? \" -M --name-status\"\r\n        : \" -M\";\r\n\r\n  if (diffBase === \"--staged\") {\r\n    // Staged changes, optionally with unstaged appended as separate diff\r\n    const base = `git diff --staged${flags}${pathFilter}`;\r\n    return includeUncommitted ? `${base} && git diff HEAD${flags}${pathFilter}` : base;\r\n  }\r\n\r\n  if (diffBase === \"HEAD\") {\r\n    // Uncommitted changes only (working vs HEAD)\r\n    return `git diff HEAD${flags}${pathFilter}`;\r\n  }\r\n\r\n  // Branch diff: use three-dot for committed only, or merge-base for committed+uncommitted\r\n  if (includeUncommitted) {\r\n    // Use merge-base to get a unified diff from branch point to working directory\r\n    // This includes both committed changes on the branch AND uncommitted working changes\r\n    // Single command avoids duplicate hunks from concatenation\r\n    // Stable comparison point: merge-base doesn't change when diffBase ref moves forward\r\n    return `git diff $(git merge-base ${diffBase} HEAD)${flags}${pathFilter}`;\r\n  } else {\r\n    // Three-dot: committed changes only (merge-base to HEAD)\r\n    return `git diff ${diffBase}...HEAD${flags}${pathFilter}`;\r\n  }\r\n}\r\n"]}