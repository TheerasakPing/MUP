{"version":3,"file":"diffParser.js","sourceRoot":"","sources":["../../../../src/common/utils/git/diffParser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Git diff parser - parses unified diff output into structured hunks\n */\n\nimport type { DiffHunk, FileDiff } from \"@/common/types/review\";\n\n/**\n * Generate a stable content-based ID for a hunk\n * Uses file path + line range + diff content to ensure uniqueness\n */\nfunction generateHunkId(\n  filePath: string,\n  oldStart: number,\n  newStart: number,\n  content: string\n): string {\n  // Hash file path + line range + diff content for uniqueness and rebase stability\n  const str = `${filePath}:${oldStart}-${newStart}:${content}`;\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return `hunk-${Math.abs(hash).toString(16)}`;\n}\n\n/**\n * Parse a hunk header line (e.g., \"@@ -1,5 +1,6 @@ optional context\")\n * Returns null if the line is not a valid hunk header\n */\nfunction parseHunkHeader(line: string): {\n  oldStart: number;\n  oldLines: number;\n  newStart: number;\n  newLines: number;\n} | null {\n  const regex = /^@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/;\n  const match = regex.exec(line);\n  if (!match) return null;\n\n  return {\n    oldStart: parseInt(match[1], 10),\n    oldLines: match[2] ? parseInt(match[2], 10) : 1,\n    newStart: parseInt(match[3], 10),\n    newLines: match[4] ? parseInt(match[4], 10) : 1,\n  };\n}\n\n/**\n * Parse unified diff output into structured file diffs with hunks\n * Supports standard git diff format with file headers and hunk markers\n */\nexport function parseDiff(diffOutput: string): FileDiff[] {\n  // Normalize line endings so CRLF diffs (and CRLF file contents) don't leak `\\r` into the UI.\n  // Note: a CRLF file often produces diff lines ending in `\\r\\n` (the `\\r` is part of the file line).\n  const lines = diffOutput.split(/\\r?\\n/);\n  // Intentionally keep the trailing empty line from a final newline.\n  // (When a hunk is still open, we convert it into a \" \" context line so the UI\n  // has a stable trailing line for selection/comment placement.)\n  const files: FileDiff[] = [];\n  let currentFile: FileDiff | null = null;\n  let currentHunk: Partial<DiffHunk> | null = null;\n  let hunkLines: string[] = [];\n\n  const finishHunk = () => {\n    if (currentHunk && currentFile && hunkLines.length > 0) {\n      const content = hunkLines.join(\"\\n\");\n      const hunkId = generateHunkId(\n        currentFile.filePath,\n        currentHunk.oldStart!,\n        currentHunk.newStart!,\n        content\n      );\n      currentFile.hunks.push({\n        ...currentHunk,\n        id: hunkId,\n        filePath: currentFile.filePath,\n        content,\n        changeType: currentFile.changeType,\n        oldPath: currentFile.oldPath,\n      } as DiffHunk);\n      hunkLines = [];\n      currentHunk = null;\n    }\n  };\n\n  const finishFile = () => {\n    finishHunk();\n    if (currentFile) {\n      files.push(currentFile);\n      currentFile = null;\n    }\n  };\n\n  for (const line of lines) {\n    // File header: diff --git a/... b/...\n    if (line.startsWith(\"diff --git \")) {\n      finishFile();\n      // Extract file paths from \"diff --git a/path b/path\"\n      const regex = /^diff --git a\\/(.+) b\\/(.+)$/;\n      const match = regex.exec(line);\n      if (match) {\n        const oldPath = match[1];\n        const newPath = match[2];\n        currentFile = {\n          filePath: newPath,\n          oldPath: oldPath !== newPath ? oldPath : undefined,\n          changeType: \"modified\",\n          isBinary: false,\n          hunks: [],\n        };\n      }\n      continue;\n    }\n\n    if (!currentFile) continue;\n\n    // Binary file marker\n    if (line.startsWith(\"Binary files \")) {\n      currentFile.isBinary = true;\n      continue;\n    }\n\n    // New file mode\n    if (line.startsWith(\"new file mode \")) {\n      currentFile.changeType = \"added\";\n      continue;\n    }\n\n    // Deleted file mode\n    if (line.startsWith(\"deleted file mode \")) {\n      currentFile.changeType = \"deleted\";\n      continue;\n    }\n\n    // Rename marker\n    if (line.startsWith(\"rename from \") || line.startsWith(\"rename to \")) {\n      currentFile.changeType = \"renamed\";\n      continue;\n    }\n\n    // Hunk header\n    if (line.startsWith(\"@@\")) {\n      finishHunk();\n      const parsed = parseHunkHeader(line);\n      if (parsed) {\n        currentHunk = {\n          ...parsed,\n          header: line,\n        };\n      }\n      continue;\n    }\n\n    // Hunk content (lines starting with +, -, or space)\n    if (currentHunk && (line.startsWith(\"+\") || line.startsWith(\"-\") || line.startsWith(\" \"))) {\n      hunkLines.push(line);\n      continue;\n    }\n\n    // Context line in hunk (no prefix, but within a hunk)\n    if (currentHunk && line.length === 0) {\n      hunkLines.push(\" \"); // Treat empty line as context\n      continue;\n    }\n  }\n\n  // Finish last file\n  finishFile();\n\n  return files;\n}\n\n/**\n * Extract all hunks from file diffs\n * Flattens the file -> hunks structure into a single array\n */\nexport function extractAllHunks(fileDiffs: FileDiff[]): DiffHunk[] {\n  return fileDiffs.flatMap((file) => file.hunks);\n}\n\n/**\n * Build git diff command based on diffBase and includeUncommitted flag\n * Shared logic between numstat (file tree) and diff (hunks) commands\n *\n * Git diff semantics:\n * - `git diff A...HEAD` (three-dot): Shows commits on current branch since branching from A\n *   → Uses merge-base(A, HEAD) as comparison point, so changes to A after branching don't appear\n * - `git diff $(git merge-base A HEAD)`: Shows all changes from branch point to working directory\n *   → Includes both committed changes on the branch AND uncommitted working directory changes\n *   → Single unified diff (no duplicate hunks from concatenation)\n * - `git diff HEAD`: Shows only uncommitted changes (working directory vs HEAD)\n * - `git diff --staged`: Shows only staged changes (index vs HEAD)\n *\n * The key insight: When includeUncommitted is true, we compare from the merge-base directly\n * to the working directory. This gives a stable comparison point (doesn't change when base\n * ref moves forward) while including both committed and uncommitted work in a single diff.\n *\n * @param diffBase - Base reference (\"main\", \"HEAD\", \"--staged\")\n * @param includeUncommitted - Include uncommitted working directory changes\n * @param pathFilter - Optional path filter (e.g., ' -- \"src/foo.ts\"')\n * @param command - \"diff\" (unified), \"numstat\" (file stats), or \"name-status\" (file status)\n */\nexport function buildGitDiffCommand(\n  diffBase: string,\n  includeUncommitted: boolean,\n  pathFilter: string,\n  command: \"diff\" | \"numstat\" | \"name-status\"\n): string {\n  const flags =\n    command === \"numstat\"\n      ? \" -M --numstat\"\n      : command === \"name-status\"\n        ? \" -M --name-status\"\n        : \" -M\";\n\n  if (diffBase === \"--staged\") {\n    // Staged changes, optionally with unstaged appended as separate diff\n    const base = `git diff --staged${flags}${pathFilter}`;\n    return includeUncommitted ? `${base} && git diff HEAD${flags}${pathFilter}` : base;\n  }\n\n  if (diffBase === \"HEAD\") {\n    // Uncommitted changes only (working vs HEAD)\n    return `git diff HEAD${flags}${pathFilter}`;\n  }\n\n  // Branch diff: use three-dot for committed only, or merge-base for committed+uncommitted\n  if (includeUncommitted) {\n    // Use merge-base to get a unified diff from branch point to working directory\n    // This includes both committed changes on the branch AND uncommitted working changes\n    // Single command avoids duplicate hunks from concatenation\n    // Stable comparison point: merge-base doesn't change when diffBase ref moves forward\n    return `git diff $(git merge-base ${diffBase} HEAD)${flags}${pathFilter}`;\n  } else {\n    // Three-dot: committed changes only (merge-base to HEAD)\n    return `git diff ${diffBase}...HEAD${flags}${pathFilter}`;\n  }\n}\n"]}