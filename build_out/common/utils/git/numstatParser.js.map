{"version":3,"file":"numstatParser.js","sourceRoot":"","sources":["../../../../src/common/utils/git/numstatParser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Parse git diff --numstat output\n * Format: <additions>\\t<deletions>\\t<filepath>\n */\nimport type { FileChangeType } from \"@/common/types/review\";\n\nexport interface FileStats {\n  filePath: string;\n  additions: number;\n  deletions: number;\n  changeType?: FileChangeType;\n  oldPath?: string;\n}\n\n/**\n * Parse git diff --numstat output into structured file stats\n */\nexport function parseNumstat(numstatOutput: string): FileStats[] {\n  const lines = numstatOutput.trim().split(\"\\n\").filter(Boolean);\n  const stats: FileStats[] = [];\n\n  for (const line of lines) {\n    const parts = line.split(\"\\t\");\n    if (parts.length !== 3) continue;\n\n    const [addStr, delStr, filePath] = parts;\n\n    // Handle binary files (marked with \"-\" for additions/deletions)\n    const additions = addStr === \"-\" ? 0 : parseInt(addStr, 10);\n    const deletions = delStr === \"-\" ? 0 : parseInt(delStr, 10);\n\n    if (!isNaN(additions) && !isNaN(deletions)) {\n      stats.push({\n        filePath,\n        additions,\n        deletions,\n      });\n    }\n  }\n\n  return stats;\n}\n\n/**\n * Extract the new file path from rename syntax\n * Examples:\n *   \"src/foo.ts\" -> \"src/foo.ts\"\n *   \"src/{old.ts => new.ts}\" -> \"src/new.ts\"\n *   \"{old.ts => new.ts}\" -> \"new.ts\"\n */\nexport function extractNewPath(filePath: string): string {\n  // Match rename syntax: {old => new}\n  const renameMatch = /^(.*)?\\{[^}]+ => ([^}]+)\\}(.*)$/.exec(filePath);\n  if (renameMatch) {\n    const [, prefix = \"\", newName, suffix = \"\"] = renameMatch;\n    return `${prefix}${newName}${suffix}`;\n  }\n\n  // Match rename syntax without braces: \"old => new\"\n  const arrowSeparator = \" => \";\n  if (filePath.includes(arrowSeparator)) {\n    return filePath.split(arrowSeparator).pop() ?? filePath;\n  }\n\n  return filePath;\n}\n\n/**\n * Build a tree structure from flat file paths\n */\nexport interface FileTreeNode {\n  name: string;\n  path: string;\n  isDirectory: boolean;\n  children: FileTreeNode[];\n  /** Whether this file/directory is gitignored */\n  ignored?: boolean;\n  stats?: FileStats;\n  /** Total stats including all children (for directories) */\n  totalStats?: FileStats;\n}\n\nexport function buildFileTree(fileStats: FileStats[]): FileTreeNode {\n  const root: FileTreeNode = {\n    name: \"\",\n    path: \"\",\n    isDirectory: true,\n    children: [],\n  };\n\n  for (const stat of fileStats) {\n    const parts = stat.filePath.split(\"/\");\n    let currentNode = root;\n\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n      const isLastPart = i === parts.length - 1;\n      const pathSoFar = parts.slice(0, i + 1).join(\"/\");\n\n      let childNode = currentNode.children.find((c) => c.name === part);\n\n      if (!childNode) {\n        childNode = {\n          name: part,\n          path: pathSoFar,\n          isDirectory: !isLastPart,\n          children: [],\n          stats: isLastPart ? stat : undefined,\n        };\n        currentNode.children.push(childNode);\n      }\n\n      currentNode = childNode;\n    }\n  }\n\n  // Calculate total stats for all directory nodes\n  function populateTotalStats(node: FileTreeNode): void {\n    if (node.isDirectory) {\n      let totalAdditions = 0;\n      let totalDeletions = 0;\n\n      for (const child of node.children) {\n        populateTotalStats(child); // Recursive\n\n        const childStats = child.isDirectory ? child.totalStats : child.stats;\n\n        if (childStats) {\n          totalAdditions += childStats.additions;\n          totalDeletions += childStats.deletions;\n        }\n      }\n\n      node.totalStats = {\n        additions: totalAdditions,\n        deletions: totalDeletions,\n        filePath: node.path, // Add filePath to satisfy FileStats interface\n      };\n    }\n  }\n\n  populateTotalStats(root);\n\n  return root;\n}\n\n/**\n * Extract the common path prefix from all file paths\n * Returns null if no common prefix or only single path component\n *\n * This is used for display purposes only - the actual paths in the tree\n * remain unchanged so git commands work correctly.\n */\nexport function extractCommonPrefix(fileStats: FileStats[]): string | null {\n  if (fileStats.length === 0) return null;\n\n  // Get all paths\n  const paths = fileStats.map((stat) => stat.filePath);\n\n  // Split first path into components\n  const firstParts = paths[0].split(\"/\");\n  if (firstParts.length === 1) return null; // No directory structure\n\n  // Find common prefix length\n  let commonLength = 0;\n  for (let i = 0; i < firstParts.length - 1; i++) {\n    // -1 to exclude filename\n    const part = firstParts[i];\n    if (paths.every((path) => path.split(\"/\")[i] === part)) {\n      commonLength = i + 1;\n    } else {\n      break;\n    }\n  }\n\n  // Return null if no common prefix\n  if (commonLength === 0) return null;\n\n  return firstParts.slice(0, commonLength).join(\"/\");\n}\n"]}