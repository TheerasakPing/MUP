{"version":3,"file":"numstatParser.js","sourceRoot":"","sources":["../../../../src/common/utils/git/numstatParser.ts"],"names":[],"mappings":";;;;;;AAcA;;GAEG;AACH,sBAA6B,aAAqB,EAAe;IAC/D,MAAM,KAAK,GAAG,aAAa,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IAC/D,MAAM,KAAK,GAAgB,EAAE,CAAC;IAE9B,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;QACzB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC/B,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC;YAAE,SAAS;QAEjC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,QAAQ,CAAC,GAAG,KAAK,CAAC;QAEzC,gEAAgE;QAChE,MAAM,SAAS,GAAG,MAAM,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAC5D,MAAM,SAAS,GAAG,MAAM,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAE5D,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC;YAC3C,KAAK,CAAC,IAAI,CAAC;gBACT,QAAQ;gBACR,SAAS;gBACT,SAAS;aACV,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAED,OAAO,KAAK,CAAC;AAAA,CACd;AAED;;;;;;GAMG;AACH,wBAA+B,QAAgB,EAAU;IACvD,oCAAoC;IACpC,MAAM,WAAW,GAAG,iCAAiC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACrE,IAAI,WAAW,EAAE,CAAC;QAChB,MAAM,CAAC,EAAE,MAAM,GAAG,EAAE,EAAE,OAAO,EAAE,MAAM,GAAG,EAAE,CAAC,GAAG,WAAW,CAAC;QAC1D,OAAO,GAAG,MAAM,GAAG,OAAO,GAAG,MAAM,EAAE,CAAC;IACxC,CAAC;IAED,mDAAmD;IACnD,MAAM,cAAc,GAAG,MAAM,CAAC;IAC9B,IAAI,QAAQ,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE,CAAC;QACtC,OAAO,QAAQ,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,GAAG,EAAE,IAAI,QAAQ,CAAC;IAC1D,CAAC;IAED,OAAO,QAAQ,CAAC;AAAA,CACjB;AAiBD,uBAA8B,SAAsB,EAAgB;IAClE,MAAM,IAAI,GAAiB;QACzB,IAAI,EAAE,EAAE;QACR,IAAI,EAAE,EAAE;QACR,WAAW,EAAE,IAAI;QACjB,QAAQ,EAAE,EAAE;KACb,CAAC;IAEF,KAAK,MAAM,IAAI,IAAI,SAAS,EAAE,CAAC;QAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACvC,IAAI,WAAW,GAAG,IAAI,CAAC;QAEvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACtC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,MAAM,UAAU,GAAG,CAAC,KAAK,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;YAC1C,MAAM,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAElD,IAAI,SAAS,GAAG,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;YAElE,IAAI,CAAC,SAAS,EAAE,CAAC;gBACf,SAAS,GAAG;oBACV,IAAI,EAAE,IAAI;oBACV,IAAI,EAAE,SAAS;oBACf,WAAW,EAAE,CAAC,UAAU;oBACxB,QAAQ,EAAE,EAAE;oBACZ,KAAK,EAAE,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS;iBACrC,CAAC;gBACF,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YACvC,CAAC;YAED,WAAW,GAAG,SAAS,CAAC;QAC1B,CAAC;IACH,CAAC;IAED,gDAAgD;IAChD,SAAS,kBAAkB,CAAC,IAAkB,EAAQ;QACpD,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YACrB,IAAI,cAAc,GAAG,CAAC,CAAC;YACvB,IAAI,cAAc,GAAG,CAAC,CAAC;YAEvB,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAClC,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,YAAY;gBAEvC,MAAM,UAAU,GAAG,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC;gBAEtE,IAAI,UAAU,EAAE,CAAC;oBACf,cAAc,IAAI,UAAU,CAAC,SAAS,CAAC;oBACvC,cAAc,IAAI,UAAU,CAAC,SAAS,CAAC;gBACzC,CAAC;YACH,CAAC;YAED,IAAI,CAAC,UAAU,GAAG;gBAChB,SAAS,EAAE,cAAc;gBACzB,SAAS,EAAE,cAAc;gBACzB,QAAQ,EAAE,IAAI,CAAC,IAAI,EAAE,8CAA8C;aACpE,CAAC;QACJ,CAAC;IAAA,CACF;IAED,kBAAkB,CAAC,IAAI,CAAC,CAAC;IAEzB,OAAO,IAAI,CAAC;AAAA,CACb;AAED;;;;;;GAMG;AACH,6BAAoC,SAAsB,EAAiB;IACzE,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,IAAI,CAAC;IAExC,gBAAgB;IAChB,MAAM,KAAK,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAErD,mCAAmC;IACnC,MAAM,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACvC,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,IAAI,CAAC,CAAC,yBAAyB;IAEnE,4BAA4B;IAC5B,IAAI,YAAY,GAAG,CAAC,CAAC;IACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC/C,yBAAyB;QACzB,MAAM,IAAI,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;QAC3B,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,EAAE,CAAC;YACvD,YAAY,GAAG,CAAC,GAAG,CAAC,CAAC;QACvB,CAAC;aAAM,CAAC;YACN,MAAM;QACR,CAAC;IACH,CAAC;IAED,kCAAkC;IAClC,IAAI,YAAY,KAAK,CAAC;QAAE,OAAO,IAAI,CAAC;IAEpC,OAAO,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAAA,CACpD","sourcesContent":["/**\r\n * Parse git diff --numstat output\r\n * Format: <additions>\\t<deletions>\\t<filepath>\r\n */\r\nimport type { FileChangeType } from \"@/common/types/review\";\r\n\r\nexport interface FileStats {\r\n  filePath: string;\r\n  additions: number;\r\n  deletions: number;\r\n  changeType?: FileChangeType;\r\n  oldPath?: string;\r\n}\r\n\r\n/**\r\n * Parse git diff --numstat output into structured file stats\r\n */\r\nexport function parseNumstat(numstatOutput: string): FileStats[] {\r\n  const lines = numstatOutput.trim().split(\"\\n\").filter(Boolean);\r\n  const stats: FileStats[] = [];\r\n\r\n  for (const line of lines) {\r\n    const parts = line.split(\"\\t\");\r\n    if (parts.length !== 3) continue;\r\n\r\n    const [addStr, delStr, filePath] = parts;\r\n\r\n    // Handle binary files (marked with \"-\" for additions/deletions)\r\n    const additions = addStr === \"-\" ? 0 : parseInt(addStr, 10);\r\n    const deletions = delStr === \"-\" ? 0 : parseInt(delStr, 10);\r\n\r\n    if (!isNaN(additions) && !isNaN(deletions)) {\r\n      stats.push({\r\n        filePath,\r\n        additions,\r\n        deletions,\r\n      });\r\n    }\r\n  }\r\n\r\n  return stats;\r\n}\r\n\r\n/**\r\n * Extract the new file path from rename syntax\r\n * Examples:\r\n *   \"src/foo.ts\" -> \"src/foo.ts\"\r\n *   \"src/{old.ts => new.ts}\" -> \"src/new.ts\"\r\n *   \"{old.ts => new.ts}\" -> \"new.ts\"\r\n */\r\nexport function extractNewPath(filePath: string): string {\r\n  // Match rename syntax: {old => new}\r\n  const renameMatch = /^(.*)?\\{[^}]+ => ([^}]+)\\}(.*)$/.exec(filePath);\r\n  if (renameMatch) {\r\n    const [, prefix = \"\", newName, suffix = \"\"] = renameMatch;\r\n    return `${prefix}${newName}${suffix}`;\r\n  }\r\n\r\n  // Match rename syntax without braces: \"old => new\"\r\n  const arrowSeparator = \" => \";\r\n  if (filePath.includes(arrowSeparator)) {\r\n    return filePath.split(arrowSeparator).pop() ?? filePath;\r\n  }\r\n\r\n  return filePath;\r\n}\r\n\r\n/**\r\n * Build a tree structure from flat file paths\r\n */\r\nexport interface FileTreeNode {\r\n  name: string;\r\n  path: string;\r\n  isDirectory: boolean;\r\n  children: FileTreeNode[];\r\n  /** Whether this file/directory is gitignored */\r\n  ignored?: boolean;\r\n  stats?: FileStats;\r\n  /** Total stats including all children (for directories) */\r\n  totalStats?: FileStats;\r\n}\r\n\r\nexport function buildFileTree(fileStats: FileStats[]): FileTreeNode {\r\n  const root: FileTreeNode = {\r\n    name: \"\",\r\n    path: \"\",\r\n    isDirectory: true,\r\n    children: [],\r\n  };\r\n\r\n  for (const stat of fileStats) {\r\n    const parts = stat.filePath.split(\"/\");\r\n    let currentNode = root;\r\n\r\n    for (let i = 0; i < parts.length; i++) {\r\n      const part = parts[i];\r\n      const isLastPart = i === parts.length - 1;\r\n      const pathSoFar = parts.slice(0, i + 1).join(\"/\");\r\n\r\n      let childNode = currentNode.children.find((c) => c.name === part);\r\n\r\n      if (!childNode) {\r\n        childNode = {\r\n          name: part,\r\n          path: pathSoFar,\r\n          isDirectory: !isLastPart,\r\n          children: [],\r\n          stats: isLastPart ? stat : undefined,\r\n        };\r\n        currentNode.children.push(childNode);\r\n      }\r\n\r\n      currentNode = childNode;\r\n    }\r\n  }\r\n\r\n  // Calculate total stats for all directory nodes\r\n  function populateTotalStats(node: FileTreeNode): void {\r\n    if (node.isDirectory) {\r\n      let totalAdditions = 0;\r\n      let totalDeletions = 0;\r\n\r\n      for (const child of node.children) {\r\n        populateTotalStats(child); // Recursive\r\n\r\n        const childStats = child.isDirectory ? child.totalStats : child.stats;\r\n\r\n        if (childStats) {\r\n          totalAdditions += childStats.additions;\r\n          totalDeletions += childStats.deletions;\r\n        }\r\n      }\r\n\r\n      node.totalStats = {\r\n        additions: totalAdditions,\r\n        deletions: totalDeletions,\r\n        filePath: node.path, // Add filePath to satisfy FileStats interface\r\n      };\r\n    }\r\n  }\r\n\r\n  populateTotalStats(root);\r\n\r\n  return root;\r\n}\r\n\r\n/**\r\n * Extract the common path prefix from all file paths\r\n * Returns null if no common prefix or only single path component\r\n *\r\n * This is used for display purposes only - the actual paths in the tree\r\n * remain unchanged so git commands work correctly.\r\n */\r\nexport function extractCommonPrefix(fileStats: FileStats[]): string | null {\r\n  if (fileStats.length === 0) return null;\r\n\r\n  // Get all paths\r\n  const paths = fileStats.map((stat) => stat.filePath);\r\n\r\n  // Split first path into components\r\n  const firstParts = paths[0].split(\"/\");\r\n  if (firstParts.length === 1) return null; // No directory structure\r\n\r\n  // Find common prefix length\r\n  let commonLength = 0;\r\n  for (let i = 0; i < firstParts.length - 1; i++) {\r\n    // -1 to exclude filename\r\n    const part = firstParts[i];\r\n    if (paths.every((path) => path.split(\"/\")[i] === part)) {\r\n      commonLength = i + 1;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Return null if no common prefix\r\n  if (commonLength === 0) return null;\r\n\r\n  return firstParts.slice(0, commonLength).join(\"/\");\r\n}\r\n"]}