{"version":3,"file":"truncateBashOutput.js","sourceRoot":"","sources":["../../../src/common/utils/truncateBashOutput.ts"],"names":[],"mappings":";AAAA;;;;;;;;GAQG;;;AAEH,8DAA0F;AAS1F,4BAAmC,MAAc,EAA4B;IAC3E,MAAM,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAEjD,uEAAuE;IACvE,wFAAwF;IACxF,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IACpC,MAAM,kBAAkB,GAAG,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;IACxE,MAAM,KAAK,GAAG,kBAAkB,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;IAEpE,IAAI,KAAK,CAAC,MAAM,IAAI,gCAAmB,IAAI,KAAK,IAAI,iCAAoB,EAAE,CAAC;QACzE,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,aAAa,EAAE,KAAK,CAAC,MAAM,EAAE,aAAa,EAAE,KAAK,EAAE,CAAC;IACzF,CAAC;IAED,wEAAwE;IACxE,IAAI,cAAc,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,gCAAmB,CAAC,CAAC;IACvD,+CAA+C;IAC/C,IAAI,eAAe,GAAG,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;IAEnF,iEAAiE;IACjE,IAAI,MAAM,CAAC,UAAU,CAAC,eAAe,EAAE,OAAO,CAAC,GAAG,iCAAoB,EAAE,CAAC;QACvE,uEAAuE;QACvE,OAAO,MAAM,CAAC,UAAU,CAAC,eAAe,EAAE,OAAO,CAAC,GAAG,iCAAoB,EAAE,CAAC;YAC1E,cAAc,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACzC,eAAe,GAAG,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC9C,CAAC;IACH,CAAC;IAED,OAAO;QACL,MAAM,EAAE,eAAe;QACvB,SAAS,EAAE,IAAI;QACf,aAAa,EAAE,KAAK,CAAC,MAAM;QAC3B,aAAa,EAAE,KAAK;KACrB,CAAC;AAAA,CACH","sourcesContent":["/**\n * Hard truncation for bash output to prevent unbounded context growth.\n *\n * This is a safety net that applies the same limits as foreground bash\n * (BASH_HARD_MAX_LINES / BASH_MAX_TOTAL_BYTES) to all bash-family tool output.\n *\n * Used by maybeFilterBashOutputWithSystem1 to ensure output is bounded even\n * when System1 compaction is skipped or fails.\n */\n\nimport { BASH_HARD_MAX_LINES, BASH_MAX_TOTAL_BYTES } from \"@/common/constants/toolLimits\";\n\nexport interface TruncateBashOutputResult {\n  output: string;\n  truncated: boolean;\n  originalLines: number;\n  originalBytes: number;\n}\n\nexport function truncateBashOutput(output: string): TruncateBashOutputResult {\n  const bytes = Buffer.byteLength(output, \"utf-8\");\n\n  // Split into lines, but don't count a trailing empty string as a line.\n  // \"line1\\nline2\\n\".split(\"\\n\") gives [\"line1\", \"line2\", \"\"], but that's 2 lines, not 3.\n  const rawLines = output.split(\"\\n\");\n  const hasTrailingNewline = output.endsWith(\"\\n\") && rawLines.length > 0;\n  const lines = hasTrailingNewline ? rawLines.slice(0, -1) : rawLines;\n\n  if (lines.length <= BASH_HARD_MAX_LINES && bytes <= BASH_MAX_TOTAL_BYTES) {\n    return { output, truncated: false, originalLines: lines.length, originalBytes: bytes };\n  }\n\n  // Keep tail (most recent output is usually most relevant for debugging)\n  let truncatedLines = lines.slice(-BASH_HARD_MAX_LINES);\n  // Restore trailing newline if original had one\n  let truncatedOutput = truncatedLines.join(\"\\n\") + (hasTrailingNewline ? \"\\n\" : \"\");\n\n  // Also enforce byte limit (slice from end to keep recent output)\n  if (Buffer.byteLength(truncatedOutput, \"utf-8\") > BASH_MAX_TOTAL_BYTES) {\n    // Binary search would be more efficient but this is simple and correct\n    while (Buffer.byteLength(truncatedOutput, \"utf-8\") > BASH_MAX_TOTAL_BYTES) {\n      truncatedLines = truncatedLines.slice(1);\n      truncatedOutput = truncatedLines.join(\"\\n\");\n    }\n  }\n\n  return {\n    output: truncatedOutput,\n    truncated: true,\n    originalLines: lines.length,\n    originalBytes: bytes,\n  };\n}\n"]}