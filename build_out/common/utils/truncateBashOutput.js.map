{"version":3,"file":"truncateBashOutput.js","sourceRoot":"","sources":["../../../src/common/utils/truncateBashOutput.ts"],"names":[],"mappings":";AAAA;;;;;;;;GAQG;;;AAEH,8DAA0F;AAS1F,4BAAmC,MAAc,EAA4B;IAC3E,MAAM,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAEjD,uEAAuE;IACvE,wFAAwF;IACxF,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IACpC,MAAM,kBAAkB,GAAG,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;IACxE,MAAM,KAAK,GAAG,kBAAkB,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;IAEpE,IAAI,KAAK,CAAC,MAAM,IAAI,gCAAmB,IAAI,KAAK,IAAI,iCAAoB,EAAE,CAAC;QACzE,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,aAAa,EAAE,KAAK,CAAC,MAAM,EAAE,aAAa,EAAE,KAAK,EAAE,CAAC;IACzF,CAAC;IAED,wEAAwE;IACxE,IAAI,cAAc,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,gCAAmB,CAAC,CAAC;IACvD,+CAA+C;IAC/C,IAAI,eAAe,GAAG,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;IAEnF,iEAAiE;IACjE,IAAI,MAAM,CAAC,UAAU,CAAC,eAAe,EAAE,OAAO,CAAC,GAAG,iCAAoB,EAAE,CAAC;QACvE,uEAAuE;QACvE,OAAO,MAAM,CAAC,UAAU,CAAC,eAAe,EAAE,OAAO,CAAC,GAAG,iCAAoB,EAAE,CAAC;YAC1E,cAAc,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACzC,eAAe,GAAG,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC9C,CAAC;IACH,CAAC;IAED,OAAO;QACL,MAAM,EAAE,eAAe;QACvB,SAAS,EAAE,IAAI;QACf,aAAa,EAAE,KAAK,CAAC,MAAM;QAC3B,aAAa,EAAE,KAAK;KACrB,CAAC;AAAA,CACH","sourcesContent":["/**\r\n * Hard truncation for bash output to prevent unbounded context growth.\r\n *\r\n * This is a safety net that applies the same limits as foreground bash\r\n * (BASH_HARD_MAX_LINES / BASH_MAX_TOTAL_BYTES) to all bash-family tool output.\r\n *\r\n * Used by maybeFilterBashOutputWithSystem1 to ensure output is bounded even\r\n * when System1 compaction is skipped or fails.\r\n */\r\n\r\nimport { BASH_HARD_MAX_LINES, BASH_MAX_TOTAL_BYTES } from \"@/common/constants/toolLimits\";\r\n\r\nexport interface TruncateBashOutputResult {\r\n  output: string;\r\n  truncated: boolean;\r\n  originalLines: number;\r\n  originalBytes: number;\r\n}\r\n\r\nexport function truncateBashOutput(output: string): TruncateBashOutputResult {\r\n  const bytes = Buffer.byteLength(output, \"utf-8\");\r\n\r\n  // Split into lines, but don't count a trailing empty string as a line.\r\n  // \"line1\\nline2\\n\".split(\"\\n\") gives [\"line1\", \"line2\", \"\"], but that's 2 lines, not 3.\r\n  const rawLines = output.split(\"\\n\");\r\n  const hasTrailingNewline = output.endsWith(\"\\n\") && rawLines.length > 0;\r\n  const lines = hasTrailingNewline ? rawLines.slice(0, -1) : rawLines;\r\n\r\n  if (lines.length <= BASH_HARD_MAX_LINES && bytes <= BASH_MAX_TOTAL_BYTES) {\r\n    return { output, truncated: false, originalLines: lines.length, originalBytes: bytes };\r\n  }\r\n\r\n  // Keep tail (most recent output is usually most relevant for debugging)\r\n  let truncatedLines = lines.slice(-BASH_HARD_MAX_LINES);\r\n  // Restore trailing newline if original had one\r\n  let truncatedOutput = truncatedLines.join(\"\\n\") + (hasTrailingNewline ? \"\\n\" : \"\");\r\n\r\n  // Also enforce byte limit (slice from end to keep recent output)\r\n  if (Buffer.byteLength(truncatedOutput, \"utf-8\") > BASH_MAX_TOTAL_BYTES) {\r\n    // Binary search would be more efficient but this is simple and correct\r\n    while (Buffer.byteLength(truncatedOutput, \"utf-8\") > BASH_MAX_TOTAL_BYTES) {\r\n      truncatedLines = truncatedLines.slice(1);\r\n      truncatedOutput = truncatedLines.join(\"\\n\");\r\n    }\r\n  }\r\n\r\n  return {\r\n    output: truncatedOutput,\r\n    truncated: true,\r\n    originalLines: lines.length,\r\n    originalBytes: bytes,\r\n  };\r\n}\r\n"]}