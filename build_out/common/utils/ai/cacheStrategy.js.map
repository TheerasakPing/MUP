{"version":3,"file":"cacheStrategy.js","sourceRoot":"","sources":["../../../../src/common/utils/ai/cacheStrategy.ts"],"names":[],"mappings":"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","sourcesContent":["import { tool as createTool, type ModelMessage, type Tool } from \"ai\";\r\nimport assert from \"@/common/utils/assert\";\r\nimport { cloneToolPreservingDescriptors } from \"@/common/utils/tools/cloneToolPreservingDescriptors\";\r\nimport { normalizeGatewayModel } from \"./models\";\r\n\r\n/**\r\n * Check if a model supports Anthropic cache control.\r\n * Matches:\r\n * - Direct Anthropic provider: \"anthropic:claude-opus-4-5\"\r\n * - Gateway providers routing to Anthropic: \"mux-gateway:anthropic/claude-opus-4-5\"\r\n * - OpenRouter Anthropic models: \"openrouter:anthropic/claude-3.5-sonnet\"\r\n */\r\nexport function supportsAnthropicCache(modelString: string): boolean {\r\n  const normalized = normalizeGatewayModel(modelString);\r\n  // Direct Anthropic provider (or normalized gateway model)\r\n  if (normalized.startsWith(\"anthropic:\")) {\r\n    return true;\r\n  }\r\n  // Other gateway/router providers routing to Anthropic (format: \"provider:anthropic/model\")\r\n  const [, modelId] = normalized.split(\":\");\r\n  if (modelId?.startsWith(\"anthropic/\")) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/** Cache control providerOptions for Anthropic */\r\nconst ANTHROPIC_CACHE_CONTROL = {\r\n  anthropic: {\r\n    cacheControl: { type: \"ephemeral\" as const },\r\n  },\r\n};\r\n\r\ntype ProviderNativeTool = Extract<Tool, { type: \"provider\" }>;\r\n\r\nfunction isProviderNativeTool(tool: Tool): tool is ProviderNativeTool {\r\n  return tool.type === \"provider\";\r\n}\r\n\r\n/**\r\n * Add providerOptions to the last content part of a message.\r\n * The SDK requires providerOptions on content parts, not on the message itself.\r\n *\r\n * For system messages with string content, we use message-level providerOptions\r\n * (which the SDK handles correctly). For user/assistant messages with array\r\n * content, we add providerOptions to the last content part.\r\n */\r\nfunction addCacheControlToLastContentPart(msg: ModelMessage): ModelMessage {\r\n  const content = msg.content;\r\n\r\n  // String content (typically system messages): use message-level providerOptions\r\n  // The SDK correctly translates this for system messages\r\n  if (typeof content === \"string\") {\r\n    return {\r\n      ...msg,\r\n      providerOptions: ANTHROPIC_CACHE_CONTROL,\r\n    };\r\n  }\r\n\r\n  // Array content: add providerOptions to the last part\r\n  // Use type assertion since we're adding providerOptions which is valid but not in base types\r\n  if (Array.isArray(content) && content.length > 0) {\r\n    const lastIndex = content.length - 1;\r\n    const newContent = content.map((part, i) =>\r\n      i === lastIndex ? { ...part, providerOptions: ANTHROPIC_CACHE_CONTROL } : part\r\n    );\r\n    // Type assertion needed: ModelMessage types are strict unions but providerOptions\r\n    // on content parts is valid per SDK docs\r\n    const result = { ...msg, content: newContent };\r\n    return result as ModelMessage;\r\n  }\r\n\r\n  // Empty or unexpected content: return as-is\r\n  return msg;\r\n}\r\n\r\n/**\r\n * Apply cache control to messages for Anthropic models.\r\n * Adds a cache marker to the last message so the entire conversation is cached.\r\n *\r\n * NOTE: The SDK requires providerOptions on content parts, not on the message.\r\n * We add cache_control to the last content part of the last message.\r\n */\r\nexport function applyCacheControl(messages: ModelMessage[], modelString: string): ModelMessage[] {\r\n  // Only apply cache control for Anthropic models\r\n  if (!supportsAnthropicCache(modelString)) {\r\n    return messages;\r\n  }\r\n\r\n  // Need at least 1 message to add a cache breakpoint\r\n  if (messages.length < 1) {\r\n    return messages;\r\n  }\r\n\r\n  // Add cache breakpoint at the last message\r\n  const cacheIndex = messages.length - 1;\r\n\r\n  return messages.map((msg, index) => {\r\n    if (index === cacheIndex) {\r\n      return addCacheControlToLastContentPart(msg);\r\n    }\r\n    return msg;\r\n  });\r\n}\r\n\r\n/**\r\n * Create a system message with cache control for Anthropic models.\r\n * System messages rarely change and should always be cached.\r\n */\r\nexport function createCachedSystemMessage(\r\n  systemContent: string,\r\n  modelString: string\r\n): ModelMessage | null {\r\n  if (!systemContent || !supportsAnthropicCache(modelString)) {\r\n    return null;\r\n  }\r\n\r\n  return {\r\n    role: \"system\" as const,\r\n    content: systemContent,\r\n    providerOptions: {\r\n      anthropic: {\r\n        cacheControl: {\r\n          type: \"ephemeral\" as const,\r\n        },\r\n      },\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Apply cache control to tool definitions for Anthropic models.\r\n * Tools are static per model and should always be cached.\r\n *\r\n * IMPORTANT: Anthropic has a 4 cache breakpoint limit. We use:\r\n * 1. System message (1 breakpoint)\r\n * 2. Conversation history (1 breakpoint)\r\n * 3. Last tool only (1 breakpoint) - caches all tools up to and including this one\r\n * = 3 total, leaving 1 for future use\r\n *\r\n * NOTE: Function tools with execute handlers are recreated so providerOptions is set\r\n * at creation time. Provider-native tools (type: \"provider\") and execute-less\r\n * dynamic/MCP tools keep their runtime metadata and are descriptor-cloned before\r\n * attaching providerOptions.\r\n */\r\nexport function applyCacheControlToTools<T extends Record<string, Tool>>(\r\n  tools: T,\r\n  modelString: string\r\n): T {\r\n  // Only apply cache control for Anthropic models\r\n  if (!supportsAnthropicCache(modelString) || !tools || Object.keys(tools).length === 0) {\r\n    return tools;\r\n  }\r\n\r\n  // Get the last tool key (tools are ordered, last one gets cached)\r\n  const toolKeys = Object.keys(tools);\r\n  const lastToolKey = toolKeys[toolKeys.length - 1];\r\n\r\n  // Clone tools and add cache control ONLY to the last tool\r\n  // Anthropic caches everything up to the cache breakpoint, so marking\r\n  // only the last tool will cache all tools\r\n  const cachedTools = {} as unknown as T;\r\n  for (const [key, existingTool] of Object.entries(tools)) {\r\n    if (key === lastToolKey) {\r\n      if (isProviderNativeTool(existingTool)) {\r\n        // Provider-native tools (e.g. Anthropic/OpenAI web search) cannot be recreated with\r\n        // createTool(). Clone while preserving descriptors/getters and attach providerOptions.\r\n        const cachedProviderTool = cloneToolPreservingDescriptors(\r\n          existingTool\r\n        ) as ProviderNativeTool;\r\n        cachedProviderTool.providerOptions = ANTHROPIC_CACHE_CONTROL;\r\n        cachedTools[key as keyof T] = cachedProviderTool as unknown as T[keyof T];\r\n      } else if (existingTool.execute == null) {\r\n        // Some MCP/dynamic tools are valid without execute handlers (provider-/client-executed).\r\n        // Keep their runtime shape and attach cache control without forcing recreation.\r\n        const cachedDynamicTool = cloneToolPreservingDescriptors(existingTool);\r\n        cachedDynamicTool.providerOptions = ANTHROPIC_CACHE_CONTROL;\r\n        cachedTools[key as keyof T] = cachedDynamicTool as unknown as T[keyof T];\r\n      } else {\r\n        assert(\r\n          existingTool.execute != null,\r\n          `Tool \"${key}\" must define execute before cache control is applied`\r\n        );\r\n\r\n        // Function tools with execute handlers: re-create with providerOptions (SDK requires this at creation time)\r\n        const cachedTool = createTool({\r\n          description: existingTool.description,\r\n          inputSchema: existingTool.inputSchema,\r\n          execute: existingTool.execute,\r\n          providerOptions: ANTHROPIC_CACHE_CONTROL,\r\n        });\r\n        cachedTools[key as keyof T] = cachedTool as unknown as T[keyof T];\r\n      }\r\n    } else {\r\n      // Other tools are copied as-is\r\n      cachedTools[key as keyof T] = existingTool as unknown as T[keyof T];\r\n    }\r\n  }\r\n\r\n  return cachedTools;\r\n}\r\n"]}