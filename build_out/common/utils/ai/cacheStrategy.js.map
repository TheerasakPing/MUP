{"version":3,"file":"cacheStrategy.js","sourceRoot":"","sources":["../../../../src/common/utils/ai/cacheStrategy.ts"],"names":[],"mappings":"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","sourcesContent":["import { tool as createTool, type ModelMessage, type Tool } from \"ai\";\nimport assert from \"@/common/utils/assert\";\nimport { cloneToolPreservingDescriptors } from \"@/common/utils/tools/cloneToolPreservingDescriptors\";\nimport { normalizeGatewayModel } from \"./models\";\n\n/**\n * Check if a model supports Anthropic cache control.\n * Matches:\n * - Direct Anthropic provider: \"anthropic:claude-opus-4-5\"\n * - Gateway providers routing to Anthropic: \"mux-gateway:anthropic/claude-opus-4-5\"\n * - OpenRouter Anthropic models: \"openrouter:anthropic/claude-3.5-sonnet\"\n */\nexport function supportsAnthropicCache(modelString: string): boolean {\n  const normalized = normalizeGatewayModel(modelString);\n  // Direct Anthropic provider (or normalized gateway model)\n  if (normalized.startsWith(\"anthropic:\")) {\n    return true;\n  }\n  // Other gateway/router providers routing to Anthropic (format: \"provider:anthropic/model\")\n  const [, modelId] = normalized.split(\":\");\n  if (modelId?.startsWith(\"anthropic/\")) {\n    return true;\n  }\n  return false;\n}\n\n/** Cache control providerOptions for Anthropic */\nconst ANTHROPIC_CACHE_CONTROL = {\n  anthropic: {\n    cacheControl: { type: \"ephemeral\" as const },\n  },\n};\n\ntype ProviderNativeTool = Extract<Tool, { type: \"provider\" }>;\n\nfunction isProviderNativeTool(tool: Tool): tool is ProviderNativeTool {\n  return tool.type === \"provider\";\n}\n\n/**\n * Add providerOptions to the last content part of a message.\n * The SDK requires providerOptions on content parts, not on the message itself.\n *\n * For system messages with string content, we use message-level providerOptions\n * (which the SDK handles correctly). For user/assistant messages with array\n * content, we add providerOptions to the last content part.\n */\nfunction addCacheControlToLastContentPart(msg: ModelMessage): ModelMessage {\n  const content = msg.content;\n\n  // String content (typically system messages): use message-level providerOptions\n  // The SDK correctly translates this for system messages\n  if (typeof content === \"string\") {\n    return {\n      ...msg,\n      providerOptions: ANTHROPIC_CACHE_CONTROL,\n    };\n  }\n\n  // Array content: add providerOptions to the last part\n  // Use type assertion since we're adding providerOptions which is valid but not in base types\n  if (Array.isArray(content) && content.length > 0) {\n    const lastIndex = content.length - 1;\n    const newContent = content.map((part, i) =>\n      i === lastIndex ? { ...part, providerOptions: ANTHROPIC_CACHE_CONTROL } : part\n    );\n    // Type assertion needed: ModelMessage types are strict unions but providerOptions\n    // on content parts is valid per SDK docs\n    const result = { ...msg, content: newContent };\n    return result as ModelMessage;\n  }\n\n  // Empty or unexpected content: return as-is\n  return msg;\n}\n\n/**\n * Apply cache control to messages for Anthropic models.\n * Adds a cache marker to the last message so the entire conversation is cached.\n *\n * NOTE: The SDK requires providerOptions on content parts, not on the message.\n * We add cache_control to the last content part of the last message.\n */\nexport function applyCacheControl(messages: ModelMessage[], modelString: string): ModelMessage[] {\n  // Only apply cache control for Anthropic models\n  if (!supportsAnthropicCache(modelString)) {\n    return messages;\n  }\n\n  // Need at least 1 message to add a cache breakpoint\n  if (messages.length < 1) {\n    return messages;\n  }\n\n  // Add cache breakpoint at the last message\n  const cacheIndex = messages.length - 1;\n\n  return messages.map((msg, index) => {\n    if (index === cacheIndex) {\n      return addCacheControlToLastContentPart(msg);\n    }\n    return msg;\n  });\n}\n\n/**\n * Create a system message with cache control for Anthropic models.\n * System messages rarely change and should always be cached.\n */\nexport function createCachedSystemMessage(\n  systemContent: string,\n  modelString: string\n): ModelMessage | null {\n  if (!systemContent || !supportsAnthropicCache(modelString)) {\n    return null;\n  }\n\n  return {\n    role: \"system\" as const,\n    content: systemContent,\n    providerOptions: {\n      anthropic: {\n        cacheControl: {\n          type: \"ephemeral\" as const,\n        },\n      },\n    },\n  };\n}\n\n/**\n * Apply cache control to tool definitions for Anthropic models.\n * Tools are static per model and should always be cached.\n *\n * IMPORTANT: Anthropic has a 4 cache breakpoint limit. We use:\n * 1. System message (1 breakpoint)\n * 2. Conversation history (1 breakpoint)\n * 3. Last tool only (1 breakpoint) - caches all tools up to and including this one\n * = 3 total, leaving 1 for future use\n *\n * NOTE: Function tools with execute handlers are recreated so providerOptions is set\n * at creation time. Provider-native tools (type: \"provider\") and execute-less\n * dynamic/MCP tools keep their runtime metadata and are descriptor-cloned before\n * attaching providerOptions.\n */\nexport function applyCacheControlToTools<T extends Record<string, Tool>>(\n  tools: T,\n  modelString: string\n): T {\n  // Only apply cache control for Anthropic models\n  if (!supportsAnthropicCache(modelString) || !tools || Object.keys(tools).length === 0) {\n    return tools;\n  }\n\n  // Get the last tool key (tools are ordered, last one gets cached)\n  const toolKeys = Object.keys(tools);\n  const lastToolKey = toolKeys[toolKeys.length - 1];\n\n  // Clone tools and add cache control ONLY to the last tool\n  // Anthropic caches everything up to the cache breakpoint, so marking\n  // only the last tool will cache all tools\n  const cachedTools = {} as unknown as T;\n  for (const [key, existingTool] of Object.entries(tools)) {\n    if (key === lastToolKey) {\n      if (isProviderNativeTool(existingTool)) {\n        // Provider-native tools (e.g. Anthropic/OpenAI web search) cannot be recreated with\n        // createTool(). Clone while preserving descriptors/getters and attach providerOptions.\n        const cachedProviderTool = cloneToolPreservingDescriptors(\n          existingTool\n        ) as ProviderNativeTool;\n        cachedProviderTool.providerOptions = ANTHROPIC_CACHE_CONTROL;\n        cachedTools[key as keyof T] = cachedProviderTool as unknown as T[keyof T];\n      } else if (existingTool.execute == null) {\n        // Some MCP/dynamic tools are valid without execute handlers (provider-/client-executed).\n        // Keep their runtime shape and attach cache control without forcing recreation.\n        const cachedDynamicTool = cloneToolPreservingDescriptors(existingTool);\n        cachedDynamicTool.providerOptions = ANTHROPIC_CACHE_CONTROL;\n        cachedTools[key as keyof T] = cachedDynamicTool as unknown as T[keyof T];\n      } else {\n        assert(\n          existingTool.execute != null,\n          `Tool \"${key}\" must define execute before cache control is applied`\n        );\n\n        // Function tools with execute handlers: re-create with providerOptions (SDK requires this at creation time)\n        const cachedTool = createTool({\n          description: existingTool.description,\n          inputSchema: existingTool.inputSchema,\n          execute: existingTool.execute,\n          providerOptions: ANTHROPIC_CACHE_CONTROL,\n        });\n        cachedTools[key as keyof T] = cachedTool as unknown as T[keyof T];\n      }\n    } else {\n      // Other tools are copied as-is\n      cachedTools[key as keyof T] = existingTool as unknown as T[keyof T];\n    }\n  }\n\n  return cachedTools;\n}\n"]}