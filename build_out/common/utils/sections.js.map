{"version":3,"file":"sections.js","sourceRoot":"","sources":["../../../src/common/utils/sections.ts"],"names":[],"mappings":";;;AAEA;;;;;GAKG;AACH,kCAAyC,QAAyB,EAAmB;IACnF,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,EAAE,CAAC;IAErC,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAErD,kEAAkE;IAClE,MAAM,aAAa,GAAG,IAAI,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;IAC7E,MAAM,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAE/D,gEAAgE;IAChE,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC;IAErC,MAAM,MAAM,GAAoB,EAAE,CAAC;IACnC,MAAM,OAAO,GAAG,IAAI,GAAG,EAAU,CAAC;IAClC,IAAI,OAAO,GAA8B,IAAI,CAAC;IAE9C,OAAO,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE,CAAC;QAC3C,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QACxB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACrB,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IAClE,CAAC;IAED,gDAAgD;IAChD,KAAK,MAAM,CAAC,IAAI,QAAQ,EAAE,CAAC;QACzB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;YACvB,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACjB,CAAC;IACH,CAAC;IAED,OAAO,MAAM,CAAC;AAAA,CACf","sourcesContent":["import type { SectionConfig } from \"@/common/types/project\";\n\n/**\n * Sort sections by their linked-list order (nextId pointers).\n *\n * Finds the head (section not referenced by any other's nextId),\n * then follows the chain. Orphaned sections are appended at the end.\n */\nexport function sortSectionsByLinkedList(sections: SectionConfig[]): SectionConfig[] {\n  if (sections.length === 0) return [];\n\n  const byId = new Map(sections.map((s) => [s.id, s]));\n\n  // Find head: section not referenced by any other section's nextId\n  const referencedIds = new Set(sections.map((s) => s.nextId).filter(Boolean));\n  const heads = sections.filter((s) => !referencedIds.has(s.id));\n\n  // If no clear head (cycle or empty), fall back to first section\n  const head = heads[0] ?? sections[0];\n\n  const sorted: SectionConfig[] = [];\n  const visited = new Set<string>();\n  let current: SectionConfig | undefined = head;\n\n  while (current && !visited.has(current.id)) {\n    visited.add(current.id);\n    sorted.push(current);\n    current = current.nextId ? byId.get(current.nextId) : undefined;\n  }\n\n  // Append orphaned sections (not in linked list)\n  for (const s of sections) {\n    if (!visited.has(s.id)) {\n      sorted.push(s);\n    }\n  }\n\n  return sorted;\n}\n"]}