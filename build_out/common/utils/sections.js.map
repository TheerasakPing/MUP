{"version":3,"file":"sections.js","sourceRoot":"","sources":["../../../src/common/utils/sections.ts"],"names":[],"mappings":";;;AAEA;;;;;GAKG;AACH,kCAAyC,QAAyB,EAAmB;IACnF,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,EAAE,CAAC;IAErC,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAErD,kEAAkE;IAClE,MAAM,aAAa,GAAG,IAAI,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;IAC7E,MAAM,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAE/D,gEAAgE;IAChE,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC;IAErC,MAAM,MAAM,GAAoB,EAAE,CAAC;IACnC,MAAM,OAAO,GAAG,IAAI,GAAG,EAAU,CAAC;IAClC,IAAI,OAAO,GAA8B,IAAI,CAAC;IAE9C,OAAO,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE,CAAC;QAC3C,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QACxB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACrB,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IAClE,CAAC;IAED,gDAAgD;IAChD,KAAK,MAAM,CAAC,IAAI,QAAQ,EAAE,CAAC;QACzB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;YACvB,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACjB,CAAC;IACH,CAAC;IAED,OAAO,MAAM,CAAC;AAAA,CACf","sourcesContent":["import type { SectionConfig } from \"@/common/types/project\";\r\n\r\n/**\r\n * Sort sections by their linked-list order (nextId pointers).\r\n *\r\n * Finds the head (section not referenced by any other's nextId),\r\n * then follows the chain. Orphaned sections are appended at the end.\r\n */\r\nexport function sortSectionsByLinkedList(sections: SectionConfig[]): SectionConfig[] {\r\n  if (sections.length === 0) return [];\r\n\r\n  const byId = new Map(sections.map((s) => [s.id, s]));\r\n\r\n  // Find head: section not referenced by any other section's nextId\r\n  const referencedIds = new Set(sections.map((s) => s.nextId).filter(Boolean));\r\n  const heads = sections.filter((s) => !referencedIds.has(s.id));\r\n\r\n  // If no clear head (cycle or empty), fall back to first section\r\n  const head = heads[0] ?? sections[0];\r\n\r\n  const sorted: SectionConfig[] = [];\r\n  const visited = new Set<string>();\r\n  let current: SectionConfig | undefined = head;\r\n\r\n  while (current && !visited.has(current.id)) {\r\n    visited.add(current.id);\r\n    sorted.push(current);\r\n    current = current.nextId ? byId.get(current.nextId) : undefined;\r\n  }\r\n\r\n  // Append orphaned sections (not in linked list)\r\n  for (const s of sections) {\r\n    if (!visited.has(s.id)) {\r\n      sorted.push(s);\r\n    }\r\n  }\r\n\r\n  return sorted;\r\n}\r\n"]}