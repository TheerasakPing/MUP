{"version":3,"file":"tokenMeterUtils.js","sourceRoot":"","sources":["../../../../src/common/utils/tokens/tokenMeterUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ChatUsageDisplay } from \"./usageAggregator\";\r\nimport { getModelStats } from \"./modelStats\";\r\nimport { supports1MContext } from \"../ai/models\";\r\nimport { CustomModelMetadata } from \"../../orpc/schemas/api\";\r\n\r\n// NOTE: Provide theme-matching fallbacks so token meters render consistently\r\n// even if a host environment doesn't define the CSS variables (e.g., an embedded UI).\r\nexport const TOKEN_COMPONENT_COLORS = {\r\n  cached: \"var(--color-token-cached, hsl(0 0% 50%))\",\r\n  cacheCreate: \"var(--color-token-cache-create, hsl(140 20% 55%))\",\r\n  input: \"var(--color-token-input, hsl(120 40% 35%))\",\r\n  output: \"var(--color-token-output, hsl(207 100% 40%))\",\r\n  thinking: \"var(--color-thinking-mode, hsl(271 76% 53%))\",\r\n} as const;\r\n\r\nexport interface TokenSegment {\r\n  type: \"cached\" | \"cacheCreate\" | \"input\" | \"output\" | \"reasoning\";\r\n  tokens: number;\r\n  percentage: number;\r\n  color: string;\r\n}\r\n\r\nexport interface TokenMeterData {\r\n  segments: TokenSegment[];\r\n  totalTokens: number;\r\n  maxTokens?: number;\r\n  totalPercentage: number;\r\n}\r\n\r\ninterface SegmentDef {\r\n  type: TokenSegment[\"type\"];\r\n  key: \"input\" | \"cached\" | \"cacheCreate\" | \"output\" | \"reasoning\";\r\n  color: string;\r\n  label: string;\r\n}\r\n\r\nconst SEGMENT_DEFS: SegmentDef[] = [\r\n  { type: \"cached\", key: \"cached\", color: TOKEN_COMPONENT_COLORS.cached, label: \"Cache Read\" },\r\n  {\r\n    type: \"cacheCreate\",\r\n    key: \"cacheCreate\",\r\n    color: TOKEN_COMPONENT_COLORS.cacheCreate,\r\n    label: \"Cache Create\",\r\n  },\r\n  { type: \"input\", key: \"input\", color: TOKEN_COMPONENT_COLORS.input, label: \"Input\" },\r\n  { type: \"output\", key: \"output\", color: TOKEN_COMPONENT_COLORS.output, label: \"Output\" },\r\n  {\r\n    type: \"reasoning\",\r\n    key: \"reasoning\",\r\n    color: TOKEN_COMPONENT_COLORS.thinking,\r\n    label: \"Thinking\",\r\n  },\r\n];\r\n\r\n/**\r\n * Calculate token meter data. When verticalProportions is true, segments are sized\r\n * proportionally to the request (e.g., 50% cached, 30% input) rather than context window.\r\n */\r\nexport function calculateTokenMeterData(\r\n  usage: ChatUsageDisplay | undefined,\r\n  model: string,\r\n  use1M: boolean,\r\n  verticalProportions = false,\r\n  customConfig?: CustomModelMetadata\r\n): TokenMeterData {\r\n  if (!usage) return { segments: [], totalTokens: 0, totalPercentage: 0 };\r\n\r\n  const modelStats = getModelStats(model, customConfig);\r\n  const maxTokens = use1M && supports1MContext(model) ? 1_000_000 : modelStats?.max_input_tokens;\r\n\r\n  // Total tokens used in the request.\r\n  // For Anthropic prompt caching, cacheCreate tokens are reported separately but still\r\n  // count toward total input tokens for the request.\r\n  const totalUsed =\r\n    usage.input.tokens +\r\n    usage.cached.tokens +\r\n    usage.cacheCreate.tokens +\r\n    usage.output.tokens +\r\n    usage.reasoning.tokens;\r\n\r\n  const toPercentage = (tokens: number) => {\r\n    if (verticalProportions) {\r\n      return totalUsed > 0 ? (tokens / totalUsed) * 100 : 0;\r\n    }\r\n    return maxTokens ? (tokens / maxTokens) * 100 : totalUsed > 0 ? (tokens / totalUsed) * 100 : 0;\r\n  };\r\n\r\n  const segments = SEGMENT_DEFS.filter((def) => usage[def.key].tokens > 0).map((def) => ({\r\n    type: def.type,\r\n    tokens: usage[def.key].tokens,\r\n    percentage: toPercentage(usage[def.key].tokens),\r\n    color: def.color,\r\n  }));\r\n\r\n  const contextPercentage = maxTokens ? (totalUsed / maxTokens) * 100 : 100;\r\n\r\n  return {\r\n    segments,\r\n    totalTokens: totalUsed,\r\n    maxTokens,\r\n    totalPercentage: verticalProportions\r\n      ? maxTokens\r\n        ? (totalUsed / maxTokens) * 100\r\n        : 0\r\n      : contextPercentage,\r\n  };\r\n}\r\n\r\nexport function formatTokens(tokens: number): string {\r\n  if (tokens >= 1_000_000) {\r\n    return `${(tokens / 1_000_000).toFixed(1)}M`;\r\n  }\r\n  if (tokens >= 1_000) {\r\n    return `${(tokens / 1_000).toFixed(1)}k`;\r\n  }\r\n  return tokens.toLocaleString();\r\n}\r\n\r\nexport function getSegmentLabel(type: TokenSegment[\"type\"]): string {\r\n  return SEGMENT_DEFS.find((def) => def.type === type)?.label ?? type;\r\n}\r\n"]}