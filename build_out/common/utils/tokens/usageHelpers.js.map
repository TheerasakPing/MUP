{"version":3,"file":"usageHelpers.js","sourceRoot":"","sources":["../../../../src/common/utils/tokens/usageHelpers.ts"],"names":[],"mappings":";AAAA;;;;;;;GAOG;;;;AAIH;;;GAGG;AACH,kBACE,CAAmC,EACnC,CAAuB,EACD;IACtB,OAAO;QACL,WAAW,EAAE,CAAC,CAAC,EAAE,WAAW,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,WAAW,IAAI,CAAC,CAAC;QACzD,YAAY,EAAE,CAAC,CAAC,EAAE,YAAY,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,YAAY,IAAI,CAAC,CAAC;QAC5D,WAAW,EAAE,CAAC,CAAC,EAAE,WAAW,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,WAAW,IAAI,CAAC,CAAC;QACzD,iBAAiB,EAAE,CAAC,CAAC,EAAE,iBAAiB,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,iBAAiB,IAAI,CAAC,CAAC;QAC3E,eAAe,EAAE,CAAC,CAAC,EAAE,eAAe,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,eAAe,IAAI,CAAC,CAAC;KACtE,CAAC;AAAA,CACH;AAED;;;;;GAKG;AACH,oCACE,QAA6C,EAC7C,IAAyC,EACJ;IACrC,IAAI,CAAC,IAAI;QAAE,OAAO,QAAQ,CAAC;IAC3B,IAAI,CAAC,QAAQ;QAAE,OAAO,IAAI,CAAC;IAE3B,0CAA0C;IAC1C,MAAM,mBAAmB,GACtB,QAAQ,CAAC,SAA+D;QACvE,EAAE,wBAAwB,IAAI,CAAC,CAAC;IACpC,MAAM,eAAe,GAClB,IAAI,CAAC,SAA+D;QACnE,EAAE,wBAAwB,IAAI,CAAC,CAAC;IAEpC,MAAM,gBAAgB,GAAG,mBAAmB,GAAG,eAAe,CAAC;IAE/D,wEAAwE;IACxE,IAAI,gBAAgB,KAAK,CAAC,EAAE,CAAC;QAC3B,OAAO,IAAI,CAAC;IACd,CAAC;IAED,+CAA+C;IAC/C,OAAO;QACL,GAAG,IAAI;QACP,SAAS,EAAE;YACT,GAAI,IAAI,CAAC,SAAiD;YAC1D,wBAAwB,EAAE,gBAAgB;SAC3C;KACF,CAAC;AAAA,CACH","sourcesContent":["/**\n * Helper functions for accumulating usage and provider metadata across multi-step tool calls.\n *\n * For multi-step tool calls, the AI SDK reports usage per-step. We need to:\n * - Sum usage across all steps for cost calculation\n * - Track last step's usage for context window display (inputTokens = actual context size)\n * - Accumulate provider-specific metadata (e.g., Anthropic cache creation tokens)\n */\n\nimport type { LanguageModelV2Usage } from \"@ai-sdk/provider\";\n\n/**\n * Add two LanguageModelV2Usage values together.\n * Handles undefined first argument and undefined fields within usage objects.\n */\nexport function addUsage(\n  a: LanguageModelV2Usage | undefined,\n  b: LanguageModelV2Usage\n): LanguageModelV2Usage {\n  return {\n    inputTokens: (a?.inputTokens ?? 0) + (b.inputTokens ?? 0),\n    outputTokens: (a?.outputTokens ?? 0) + (b.outputTokens ?? 0),\n    totalTokens: (a?.totalTokens ?? 0) + (b.totalTokens ?? 0),\n    cachedInputTokens: (a?.cachedInputTokens ?? 0) + (b.cachedInputTokens ?? 0),\n    reasoningTokens: (a?.reasoningTokens ?? 0) + (b.reasoningTokens ?? 0),\n  };\n}\n\n/**\n * Accumulate provider metadata across steps, specifically for cache creation tokens.\n *\n * For Anthropic, cache creation tokens are reported per-step and need to be summed.\n * Other provider metadata is taken from the latest step.\n */\nexport function accumulateProviderMetadata(\n  existing: Record<string, unknown> | undefined,\n  step: Record<string, unknown> | undefined\n): Record<string, unknown> | undefined {\n  if (!step) return existing;\n  if (!existing) return step;\n\n  // Extract cache creation tokens from both\n  const existingCacheCreate =\n    (existing.anthropic as { cacheCreationInputTokens?: number } | undefined)\n      ?.cacheCreationInputTokens ?? 0;\n  const stepCacheCreate =\n    (step.anthropic as { cacheCreationInputTokens?: number } | undefined)\n      ?.cacheCreationInputTokens ?? 0;\n\n  const totalCacheCreate = existingCacheCreate + stepCacheCreate;\n\n  // If no cache creation tokens to aggregate, just return step's metadata\n  if (totalCacheCreate === 0) {\n    return step;\n  }\n\n  // Merge with accumulated cache creation tokens\n  return {\n    ...step,\n    anthropic: {\n      ...(step.anthropic as Record<string, unknown> | undefined),\n      cacheCreationInputTokens: totalCacheCreate,\n    },\n  };\n}\n"]}