{"version":3,"file":"usageHelpers.js","sourceRoot":"","sources":["../../../../src/common/utils/tokens/usageHelpers.ts"],"names":[],"mappings":";AAAA;;;;;;;GAOG;;;;AAIH;;;GAGG;AACH,kBACE,CAAmC,EACnC,CAAuB,EACD;IACtB,OAAO;QACL,WAAW,EAAE,CAAC,CAAC,EAAE,WAAW,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,WAAW,IAAI,CAAC,CAAC;QACzD,YAAY,EAAE,CAAC,CAAC,EAAE,YAAY,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,YAAY,IAAI,CAAC,CAAC;QAC5D,WAAW,EAAE,CAAC,CAAC,EAAE,WAAW,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,WAAW,IAAI,CAAC,CAAC;QACzD,iBAAiB,EAAE,CAAC,CAAC,EAAE,iBAAiB,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,iBAAiB,IAAI,CAAC,CAAC;QAC3E,eAAe,EAAE,CAAC,CAAC,EAAE,eAAe,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,eAAe,IAAI,CAAC,CAAC;KACtE,CAAC;AAAA,CACH;AAED;;;;;GAKG;AACH,oCACE,QAA6C,EAC7C,IAAyC,EACJ;IACrC,IAAI,CAAC,IAAI;QAAE,OAAO,QAAQ,CAAC;IAC3B,IAAI,CAAC,QAAQ;QAAE,OAAO,IAAI,CAAC;IAE3B,0CAA0C;IAC1C,MAAM,mBAAmB,GACtB,QAAQ,CAAC,SAA+D;QACvE,EAAE,wBAAwB,IAAI,CAAC,CAAC;IACpC,MAAM,eAAe,GAClB,IAAI,CAAC,SAA+D;QACnE,EAAE,wBAAwB,IAAI,CAAC,CAAC;IAEpC,MAAM,gBAAgB,GAAG,mBAAmB,GAAG,eAAe,CAAC;IAE/D,wEAAwE;IACxE,IAAI,gBAAgB,KAAK,CAAC,EAAE,CAAC;QAC3B,OAAO,IAAI,CAAC;IACd,CAAC;IAED,+CAA+C;IAC/C,OAAO;QACL,GAAG,IAAI;QACP,SAAS,EAAE;YACT,GAAI,IAAI,CAAC,SAAiD;YAC1D,wBAAwB,EAAE,gBAAgB;SAC3C;KACF,CAAC;AAAA,CACH","sourcesContent":["/**\r\n * Helper functions for accumulating usage and provider metadata across multi-step tool calls.\r\n *\r\n * For multi-step tool calls, the AI SDK reports usage per-step. We need to:\r\n * - Sum usage across all steps for cost calculation\r\n * - Track last step's usage for context window display (inputTokens = actual context size)\r\n * - Accumulate provider-specific metadata (e.g., Anthropic cache creation tokens)\r\n */\r\n\r\nimport type { LanguageModelV2Usage } from \"@ai-sdk/provider\";\r\n\r\n/**\r\n * Add two LanguageModelV2Usage values together.\r\n * Handles undefined first argument and undefined fields within usage objects.\r\n */\r\nexport function addUsage(\r\n  a: LanguageModelV2Usage | undefined,\r\n  b: LanguageModelV2Usage\r\n): LanguageModelV2Usage {\r\n  return {\r\n    inputTokens: (a?.inputTokens ?? 0) + (b.inputTokens ?? 0),\r\n    outputTokens: (a?.outputTokens ?? 0) + (b.outputTokens ?? 0),\r\n    totalTokens: (a?.totalTokens ?? 0) + (b.totalTokens ?? 0),\r\n    cachedInputTokens: (a?.cachedInputTokens ?? 0) + (b.cachedInputTokens ?? 0),\r\n    reasoningTokens: (a?.reasoningTokens ?? 0) + (b.reasoningTokens ?? 0),\r\n  };\r\n}\r\n\r\n/**\r\n * Accumulate provider metadata across steps, specifically for cache creation tokens.\r\n *\r\n * For Anthropic, cache creation tokens are reported per-step and need to be summed.\r\n * Other provider metadata is taken from the latest step.\r\n */\r\nexport function accumulateProviderMetadata(\r\n  existing: Record<string, unknown> | undefined,\r\n  step: Record<string, unknown> | undefined\r\n): Record<string, unknown> | undefined {\r\n  if (!step) return existing;\r\n  if (!existing) return step;\r\n\r\n  // Extract cache creation tokens from both\r\n  const existingCacheCreate =\r\n    (existing.anthropic as { cacheCreationInputTokens?: number } | undefined)\r\n      ?.cacheCreationInputTokens ?? 0;\r\n  const stepCacheCreate =\r\n    (step.anthropic as { cacheCreationInputTokens?: number } | undefined)\r\n      ?.cacheCreationInputTokens ?? 0;\r\n\r\n  const totalCacheCreate = existingCacheCreate + stepCacheCreate;\r\n\r\n  // If no cache creation tokens to aggregate, just return step's metadata\r\n  if (totalCacheCreate === 0) {\r\n    return step;\r\n  }\r\n\r\n  // Merge with accumulated cache creation tokens\r\n  return {\r\n    ...step,\r\n    anthropic: {\r\n      ...(step.anthropic as Record<string, unknown> | undefined),\r\n      cacheCreationInputTokens: totalCacheCreate,\r\n    },\r\n  };\r\n}\r\n"]}