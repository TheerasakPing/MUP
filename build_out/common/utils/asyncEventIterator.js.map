{"version":3,"file":"asyncEventIterator.js","sourceRoot":"","sources":["../../../src/common/utils/asyncEventIterator.ts"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;GAwBG;AACI,KAAK,SAAS,CAAC,oBACpB,SAAgD,EAChD,WAAkD,EAClD,OAA8B,EACX;IACnB,MAAM,KAAK,GAAQ,EAAE,CAAC;IACtB,IAAI,WAAW,GAAgC,IAAI,CAAC;IACpD,IAAI,KAAK,GAAG,KAAK,CAAC;IAElB,MAAM,OAAO,GAAG,CAAC,KAAQ,EAAE,EAAE,CAAC;QAC5B,IAAI,KAAK;YAAE,OAAO;QAClB,IAAI,WAAW,EAAE,CAAC;YAChB,MAAM,OAAO,GAAG,WAAW,CAAC;YAC5B,WAAW,GAAG,IAAI,CAAC;YACnB,OAAO,CAAC,KAAK,CAAC,CAAC;QACjB,CAAC;aAAM,CAAC;YACN,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpB,CAAC;IAAA,CACF,CAAC;IAEF,SAAS,CAAC,OAAO,CAAC,CAAC;IAEnB,IAAI,CAAC;QACH,kCAAkC;QAClC,IAAI,OAAO,EAAE,YAAY,KAAK,SAAS,EAAE,CAAC;YACxC,MAAM,OAAO,CAAC,YAAY,CAAC;QAC7B,CAAC;QAED,OAAO,CAAC,KAAK,EAAE,CAAC;YACd,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACrB,MAAM,KAAK,CAAC,KAAK,EAAG,CAAC;YACvB,CAAC;iBAAM,CAAC;gBACN,MAAM,MAAM,IAAI,OAAO,CAAI,CAAC,OAAO,EAAE,EAAE,CAAC;oBACtC,WAAW,GAAG,OAAO,CAAC;gBAAA,CACvB,CAAC,CAAC;YACL,CAAC;QACH,CAAC;IACH,CAAC;YAAS,CAAC;QACT,KAAK,GAAG,IAAI,CAAC;QACb,WAAW,CAAC,OAAO,CAAC,CAAC;IACvB,CAAC;AAAA,CACF;AAED;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH,iCAIE;IACA,MAAM,KAAK,GAAQ,EAAE,CAAC;IACtB,IAAI,WAAW,GAAgC,IAAI,CAAC;IACpD,IAAI,KAAK,GAAG,KAAK,CAAC;IAElB,MAAM,IAAI,GAAG,CAAC,KAAQ,EAAE,EAAE,CAAC;QACzB,IAAI,KAAK;YAAE,OAAO;QAClB,IAAI,WAAW,EAAE,CAAC;YAChB,MAAM,OAAO,GAAG,WAAW,CAAC;YAC5B,WAAW,GAAG,IAAI,CAAC;YACnB,OAAO,CAAC,KAAK,CAAC,CAAC;QACjB,CAAC;aAAM,CAAC;YACN,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpB,CAAC;IAAA,CACF,CAAC;IAEF,KAAK,SAAS,CAAC,CAAC,OAAO,GAAsB;QAC3C,OAAO,CAAC,KAAK,EAAE,CAAC;YACd,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACrB,MAAM,KAAK,CAAC,KAAK,EAAG,CAAC;gBACrB,SAAS;YACX,CAAC;YAED,MAAM,KAAK,GAAG,MAAM,IAAI,OAAO,CAAI,CAAC,OAAO,EAAE,EAAE,CAAC;gBAC9C,WAAW,GAAG,OAAO,CAAC;YAAA,CACvB,CAAC,CAAC;YAEH,0EAA0E;YAC1E,8CAA8C;YAC9C,IAAI,KAAK,EAAE,CAAC;gBACV,OAAO;YACT,CAAC;YAED,MAAM,KAAK,CAAC;QACd,CAAC;IAAA,CACF;IAED,MAAM,GAAG,GAAG,GAAG,EAAE,CAAC;QAChB,KAAK,GAAG,IAAI,CAAC;QACb,uCAAuC;QACvC,IAAI,WAAW,EAAE,CAAC;YAChB,6DAA6D;YAC7D,WAAW,CAAC,SAAc,CAAC,CAAC;QAC9B,CAAC;IAAA,CACF,CAAC;IAEF,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC;AAAA,CAC/B","sourcesContent":["/**\r\n * Convert event emitter subscription to async iterator.\r\n *\r\n * Handles the common pattern of:\r\n * 1. Subscribe to events\r\n * 2. Yield events as async iterator\r\n * 3. Unsubscribe on cleanup\r\n *\r\n * Usage:\r\n * ```ts\r\n * yield* asyncEventIterator<MyEvent>(\r\n *   (handler) => emitter.on('event', handler),\r\n *   (handler) => emitter.off('event', handler)\r\n * );\r\n * ```\r\n *\r\n * Or with initialValue for immediate first yield:\r\n * ```ts\r\n * yield* asyncEventIterator<MyState>(\r\n *   (handler) => service.onChange(handler),\r\n *   (handler) => service.offChange(handler),\r\n *   { initialValue: await service.getState() }\r\n * );\r\n * ```\r\n */\r\nexport async function* asyncEventIterator<T>(\r\n  subscribe: (handler: (value: T) => void) => void,\r\n  unsubscribe: (handler: (value: T) => void) => void,\r\n  options?: { initialValue?: T }\r\n): AsyncGenerator<T> {\r\n  const queue: T[] = [];\r\n  let resolveNext: ((value: T) => void) | null = null;\r\n  let ended = false;\r\n\r\n  const handler = (value: T) => {\r\n    if (ended) return;\r\n    if (resolveNext) {\r\n      const resolve = resolveNext;\r\n      resolveNext = null;\r\n      resolve(value);\r\n    } else {\r\n      queue.push(value);\r\n    }\r\n  };\r\n\r\n  subscribe(handler);\r\n\r\n  try {\r\n    // Yield initial value if provided\r\n    if (options?.initialValue !== undefined) {\r\n      yield options.initialValue;\r\n    }\r\n\r\n    while (!ended) {\r\n      if (queue.length > 0) {\r\n        yield queue.shift()!;\r\n      } else {\r\n        yield await new Promise<T>((resolve) => {\r\n          resolveNext = resolve;\r\n        });\r\n      }\r\n    }\r\n  } finally {\r\n    ended = true;\r\n    unsubscribe(handler);\r\n  }\r\n}\r\n\r\n/**\r\n * Create an async event queue that can be pushed to from event handlers.\r\n *\r\n * This is useful when events don't directly yield values but trigger\r\n * async state fetches.\r\n *\r\n * Usage:\r\n * ```ts\r\n * const queue = createAsyncEventQueue<State>();\r\n *\r\n * const onChange = async () => {\r\n *   queue.push(await fetchState());\r\n * };\r\n *\r\n * emitter.on('change', onChange);\r\n * try {\r\n *   yield* queue.iterate();\r\n * } finally {\r\n *   emitter.off('change', onChange);\r\n * }\r\n * ```\r\n */\r\nexport function createAsyncEventQueue<T>(): {\r\n  push: (value: T) => void;\r\n  iterate: () => AsyncGenerator<T>;\r\n  end: () => void;\r\n} {\r\n  const queue: T[] = [];\r\n  let resolveNext: ((value: T) => void) | null = null;\r\n  let ended = false;\r\n\r\n  const push = (value: T) => {\r\n    if (ended) return;\r\n    if (resolveNext) {\r\n      const resolve = resolveNext;\r\n      resolveNext = null;\r\n      resolve(value);\r\n    } else {\r\n      queue.push(value);\r\n    }\r\n  };\r\n\r\n  async function* iterate(): AsyncGenerator<T> {\r\n    while (!ended) {\r\n      if (queue.length > 0) {\r\n        yield queue.shift()!;\r\n        continue;\r\n      }\r\n\r\n      const value = await new Promise<T>((resolve) => {\r\n        resolveNext = resolve;\r\n      });\r\n\r\n      // end() may have been called while we were waiting. Ensure we don't yield\r\n      // a sentinel/invalid value back to consumers.\r\n      if (ended) {\r\n        return;\r\n      }\r\n\r\n      yield value;\r\n    }\r\n  }\r\n\r\n  const end = () => {\r\n    ended = true;\r\n    // Wake up the iterator if it's waiting\r\n    if (resolveNext) {\r\n      // This will never be yielded since ended=true stops the loop\r\n      resolveNext(undefined as T);\r\n    }\r\n  };\r\n\r\n  return { push, iterate, end };\r\n}\r\n"]}