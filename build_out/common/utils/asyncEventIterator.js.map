{"version":3,"file":"asyncEventIterator.js","sourceRoot":"","sources":["../../../src/common/utils/asyncEventIterator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Convert event emitter subscription to async iterator.\n *\n * Handles the common pattern of:\n * 1. Subscribe to events\n * 2. Yield events as async iterator\n * 3. Unsubscribe on cleanup\n *\n * Usage:\n * ```ts\n * yield* asyncEventIterator<MyEvent>(\n *   (handler) => emitter.on('event', handler),\n *   (handler) => emitter.off('event', handler)\n * );\n * ```\n *\n * Or with initialValue for immediate first yield:\n * ```ts\n * yield* asyncEventIterator<MyState>(\n *   (handler) => service.onChange(handler),\n *   (handler) => service.offChange(handler),\n *   { initialValue: await service.getState() }\n * );\n * ```\n */\nexport async function* asyncEventIterator<T>(\n  subscribe: (handler: (value: T) => void) => void,\n  unsubscribe: (handler: (value: T) => void) => void,\n  options?: { initialValue?: T }\n): AsyncGenerator<T> {\n  const queue: T[] = [];\n  let resolveNext: ((value: T) => void) | null = null;\n  let ended = false;\n\n  const handler = (value: T) => {\n    if (ended) return;\n    if (resolveNext) {\n      const resolve = resolveNext;\n      resolveNext = null;\n      resolve(value);\n    } else {\n      queue.push(value);\n    }\n  };\n\n  subscribe(handler);\n\n  try {\n    // Yield initial value if provided\n    if (options?.initialValue !== undefined) {\n      yield options.initialValue;\n    }\n\n    while (!ended) {\n      if (queue.length > 0) {\n        yield queue.shift()!;\n      } else {\n        yield await new Promise<T>((resolve) => {\n          resolveNext = resolve;\n        });\n      }\n    }\n  } finally {\n    ended = true;\n    unsubscribe(handler);\n  }\n}\n\n/**\n * Create an async event queue that can be pushed to from event handlers.\n *\n * This is useful when events don't directly yield values but trigger\n * async state fetches.\n *\n * Usage:\n * ```ts\n * const queue = createAsyncEventQueue<State>();\n *\n * const onChange = async () => {\n *   queue.push(await fetchState());\n * };\n *\n * emitter.on('change', onChange);\n * try {\n *   yield* queue.iterate();\n * } finally {\n *   emitter.off('change', onChange);\n * }\n * ```\n */\nexport function createAsyncEventQueue<T>(): {\n  push: (value: T) => void;\n  iterate: () => AsyncGenerator<T>;\n  end: () => void;\n} {\n  const queue: T[] = [];\n  let resolveNext: ((value: T) => void) | null = null;\n  let ended = false;\n\n  const push = (value: T) => {\n    if (ended) return;\n    if (resolveNext) {\n      const resolve = resolveNext;\n      resolveNext = null;\n      resolve(value);\n    } else {\n      queue.push(value);\n    }\n  };\n\n  async function* iterate(): AsyncGenerator<T> {\n    while (!ended) {\n      if (queue.length > 0) {\n        yield queue.shift()!;\n        continue;\n      }\n\n      const value = await new Promise<T>((resolve) => {\n        resolveNext = resolve;\n      });\n\n      // end() may have been called while we were waiting. Ensure we don't yield\n      // a sentinel/invalid value back to consumers.\n      if (ended) {\n        return;\n      }\n\n      yield value;\n    }\n  }\n\n  const end = () => {\n    ended = true;\n    // Wake up the iterator if it's waiting\n    if (resolveNext) {\n      // This will never be yielded since ended=true stops the loop\n      resolveNext(undefined as T);\n    }\n  };\n\n  return { push, iterate, end };\n}\n"]}