{"version":3,"file":"extractEditedFiles.js","sourceRoot":"","sources":["../../../../src/common/utils/messages/extractEditedFiles.ts"],"names":[],"mappings":";;;;AACA,4EAA4E;AAC5E,gDAA4D;AAC5D,gEAAyF;AACzF,+BAA2D;AA4B3D;;;;;;;GAOG;AACH,gCAAuC,QAAsB,EAAY;IACvE,MAAM,WAAW,GAAa,EAAE,CAAC;IACjC,MAAM,IAAI,GAAG,IAAI,GAAG,EAAU,CAAC;IAE/B,oDAAoD;IACpD,KAAK,IAAI,CAAC,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC9C,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC5B,IAAI,OAAO,CAAC,IAAI,KAAK,WAAW;YAAE,SAAS;QAE3C,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC;YACjC,IAAI,IAAI,CAAC,IAAI,KAAK,cAAc;gBAAE,SAAS;YAC3C,IAAI,CAAC,4BAAoB,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAiD,CAAC;gBACxF,SAAS;YAEX,8DAA8D;YAC9D,IAAI,IAAI,CAAC,KAAK,KAAK,kBAAkB;gBAAE,SAAS;YAEhD,6CAA6C;YAC7C,MAAM,MAAM,GAAG,IAAI,CAAC,MAA2C,CAAC;YAChE,IAAI,CAAC,MAAM,EAAE,OAAO;gBAAE,SAAS;YAE/B,+BAA+B;YAC/B,MAAM,KAAK,GAAG,IAAI,CAAC,KAAsC,CAAC;YAC1D,MAAM,QAAQ,GAAG,KAAK,EAAE,SAAS,CAAC;YAClC,IAAI,QAAQ,IAAI,OAAO,QAAQ,KAAK,QAAQ,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;gBACpE,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;gBACnB,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC7B,CAAC;QACH,CAAC;IACH,CAAC;IAED,wDAAwD;IACxD,OAAO,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE,8BAAgB,CAAC,CAAC;AAAA,CAC/C;AAED;;;;;;;;;;;;GAYG;AACH,SAAS,wBAAwB,CAAC,KAAe,EAAU;IACzD,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,EAAE,CAAC;IAElC,MAAM,KAAK,GAAa,EAAE,CAAC;IAE3B,sEAAsE;IACtE,8EAA8E;IAC9E,0DAA0D;IAC1D,MAAM,wBAAwB,GAAG,IAAI,GAAG,EAAU,CAAC;IACnD,MAAM,qBAAqB,GAAG,IAAI,GAAG,EAAU,CAAC,CAAC,0CAA0C;IAE3F,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IAC3B,MAAM,YAAY,GAAG,IAAA,iBAAU,EAAC,SAAS,CAAC,CAAC;IAC3C,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC;QACrD,KAAK,MAAM,IAAI,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC;YACzC,IAAI,YAAY,GAAG,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;YACrC,IAAI,YAAY,GAAG,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;YAErC,kDAAkD;YAClD,OAAO,KAAK,CAAC,MAAM,GAAG,YAAY,EAAE,CAAC;gBACnC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YACjB,CAAC;YAED,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;gBAC9B,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC;oBACjD,mBAAmB;oBACnB,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBAC9B,IAAI,YAAY,IAAI,KAAK,CAAC,MAAM,EAAE,CAAC;wBACjC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;oBACtB,CAAC;yBAAM,CAAC;wBACN,KAAK,CAAC,YAAY,CAAC,GAAG,OAAO,CAAC;oBAChC,CAAC;oBACD,wBAAwB,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;oBAC3C,YAAY,EAAE,CAAC;gBACjB,CAAC;gBACD,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC;oBACjD,yDAAyD;oBACzD,qBAAqB,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;oBACxC,YAAY,EAAE,CAAC;gBACjB,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,+CAA+C;IAC/C,6DAA6D;IAC7D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QACtC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACtB,MAAM,OAAO,GAAG,IAAA,iBAAU,EAAC,IAAI,CAAC,CAAC;QACjC,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK;YAAE,SAAS;QAExD,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC;YACpC,8EAA8E;YAC9E,mEAAmE;YACnE,IAAI,SAAS,GAAG,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;YAElC,kDAAkD;YAClD,OAAO,KAAK,CAAC,MAAM,GAAG,SAAS,EAAE,CAAC;gBAChC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YACjB,CAAC;YAED,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;gBAC9B,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC;oBACjD,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBAE9B,gBAAgB;oBAChB,iEAAiE;oBACjE,6EAA6E;oBAC7E,yCAAyC;oBACzC,MAAM,uBAAuB,GAAG,wBAAwB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;oBACxE,MAAM,mBAAmB,GAAG,qBAAqB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;oBAEjE,IAAI,CAAC,uBAAuB,IAAI,CAAC,mBAAmB,EAAE,CAAC;wBACrD,IAAI,SAAS,IAAI,KAAK,CAAC,MAAM,EAAE,CAAC;4BAC9B,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;wBACtB,CAAC;6BAAM,IAAI,KAAK,CAAC,SAAS,CAAC,KAAK,EAAE,EAAE,CAAC;4BACnC,KAAK,CAAC,SAAS,CAAC,GAAG,OAAO,CAAC;wBAC7B,CAAC;oBACH,CAAC;oBACD,SAAS,EAAE,CAAC;gBACd,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAAA,CACzB;AAED;;;;;;;;;GASG;AACH,gCAAuC,QAAsB,EAAkB;IAC7E,yDAAyD;IACzD,MAAM,WAAW,GAAG,IAAI,GAAG,EAAoB,CAAC;IAChD,MAAM,SAAS,GAAa,EAAE,CAAC,CAAC,oCAAoC;IAEpE,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;QAC/B,IAAI,OAAO,CAAC,IAAI,KAAK,WAAW;YAAE,SAAS;QAE3C,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC;YACjC,IAAI,IAAI,CAAC,IAAI,KAAK,cAAc;gBAAE,SAAS;YAC3C,IAAI,CAAC,4BAAoB,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAiD,CAAC;gBACxF,SAAS;YACX,IAAI,IAAI,CAAC,KAAK,KAAK,kBAAkB;gBAAE,SAAS;YAEhD,MAAM,MAAM,GAAG,IAAI,CAAC,MAAwC,CAAC;YAC7D,IAAI,CAAC,MAAM,EAAE,OAAO;gBAAE,SAAS;YAE/B,MAAM,MAAM,GAAG,IAAA,sCAAmB,EAAC,MAAM,CAAC,CAAC;YAC3C,MAAM,IAAI,GAAG,MAAM,EAAE,SAAS,EAAE,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC;YACpD,IAAI,CAAC,IAAI;gBAAE,SAAS;YAEpB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAsC,CAAC;YAC1D,MAAM,QAAQ,GAAG,KAAK,EAAE,SAAS,CAAC;YAClC,IAAI,CAAC,QAAQ,IAAI,OAAO,QAAQ,KAAK,QAAQ;gBAAE,SAAS;YAExD,+BAA+B;YAC/B,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;gBAC/B,WAAW,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;YAChC,CAAC;YACD,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAEtC,oDAAoD;YACpD,MAAM,GAAG,GAAG,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;YACxC,IAAI,GAAG,KAAK,CAAC,CAAC;gBAAE,SAAS,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;YACzC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC3B,CAAC;IACH,CAAC;IAED,0DAA0D;IAC1D,MAAM,OAAO,GAAmB,EAAE,CAAC;IACnC,KAAK,IAAI,CAAC,GAAG,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,MAAM,GAAG,8BAAgB,EAAE,CAAC,EAAE,EAAE,CAAC;QACpF,MAAM,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;QAC9B,MAAM,KAAK,GAAG,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAE,CAAC;QAEzC,MAAM,QAAQ,GAAG,YAAY,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;QAC/C,IAAI,QAAQ,EAAE,CAAC;YACb,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACzB,CAAC;IACH,CAAC;IAED,OAAO,OAAO,CAAC;AAAA,CAChB;AAED;;;GAGG;AACH,SAAS,YAAY,CAAC,QAAgB,EAAE,KAAe,EAAuB;IAC5E,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,IAAI,CAAC;IAEpC,sCAAsC;IACtC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACvB,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACtB,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM,GAAG,mCAAqB,CAAC;QACtD,OAAO;YACL,IAAI,EAAE,QAAQ;YACd,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,mCAAqB,CAAC,CAAC,CAAC,CAAC,IAAI;YAC7D,SAAS;SACV,CAAC;IACJ,CAAC;IAED,mCAAmC;IACnC,sFAAsF;IACtF,IAAI,OAAO,GAAG,wBAAwB,CAAC,KAAK,CAAC,CAAC;IAC9C,MAAM,eAAe,GAAG,OAAO,CAAC;IAEhC,+BAA+B;IAC/B,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;QACzB,MAAM,MAAM,GAAG,IAAA,iBAAU,EAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QACzC,IAAI,MAAM,KAAK,KAAK,EAAE,CAAC;YACrB,gEAAgE;YAChE,MAAM,QAAQ,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YACzC,MAAM,SAAS,GAAG,QAAQ,CAAC,MAAM,GAAG,mCAAqB,CAAC;YAC1D,OAAO;gBACL,IAAI,EAAE,QAAQ;gBACd,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,mCAAqB,CAAC,CAAC,CAAC,CAAC,QAAQ;gBACrE,SAAS;aACV,CAAC;QACJ,CAAC;QACD,OAAO,GAAG,MAAM,CAAC;IACnB,CAAC;IAED,gDAAgD;IAChD,MAAM,YAAY,GAAG,IAAA,kBAAW,EAAC,QAAQ,EAAE,eAAe,EAAE,OAAO,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC;IAC7F,MAAM,SAAS,GAAG,YAAY,CAAC,MAAM,GAAG,mCAAqB,CAAC;IAE9D,OAAO;QACL,IAAI,EAAE,QAAQ;QACd,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE,mCAAqB,CAAC,CAAC,CAAC,CAAC,YAAY;QAC7E,SAAS;KACV,CAAC;AAAA,CACH","sourcesContent":["import type { MuxMessage } from \"@/common/types/message\";\nimport { getToolOutputUiOnly } from \"@/common/utils/tools/toolOutputUiOnly\";\nimport { FILE_EDIT_TOOL_NAMES } from \"@/common/types/tools\";\nimport { MAX_EDITED_FILES, MAX_FILE_CONTENT_SIZE } from \"@/common/constants/attachments\";\nimport { applyPatch, createPatch, parsePatch } from \"diff\";\n\n/**\n * Input shape for file edit tools.\n * All file edit tools have a file_path field.\n */\ninterface FileEditToolInput {\n  file_path?: string;\n}\n\n/**\n * Output shape for file edit tools.\n * Successful edits contain a diff field.\n */\ninterface FileEditToolOutput {\n  success?: boolean;\n  diff?: string;\n}\n\n/**\n * Represents a file and its combined diff from all edits.\n */\nexport interface FileEditDiff {\n  path: string;\n  diff: string;\n  truncated: boolean;\n}\n\n/**\n * Extract unique file paths that have been edited from message history.\n * Scans assistant messages for successful file_edit_* tool uses.\n * Returns most recently edited files first, limited to MAX_EDITED_FILES.\n *\n * @param messages - The message history to scan\n * @returns Array of unique absolute file paths that were edited (max MAX_EDITED_FILES)\n */\nexport function extractEditedFilePaths(messages: MuxMessage[]): string[] {\n  const editedFiles: string[] = [];\n  const seen = new Set<string>();\n\n  // Iterate in reverse to get most recent edits first\n  for (let i = messages.length - 1; i >= 0; i--) {\n    const message = messages[i];\n    if (message.role !== \"assistant\") continue;\n\n    for (const part of message.parts) {\n      if (part.type !== \"dynamic-tool\") continue;\n      if (!FILE_EDIT_TOOL_NAMES.includes(part.toolName as (typeof FILE_EDIT_TOOL_NAMES)[number]))\n        continue;\n\n      // Only count successful edits (output-available with success)\n      if (part.state !== \"output-available\") continue;\n\n      // Check if the tool result indicates success\n      const output = part.output as { success?: boolean } | undefined;\n      if (!output?.success) continue;\n\n      // Extract file path from input\n      const input = part.input as FileEditToolInput | undefined;\n      const filePath = input?.file_path;\n      if (filePath && typeof filePath === \"string\" && !seen.has(filePath)) {\n        seen.add(filePath);\n        editedFiles.push(filePath);\n      }\n    }\n  }\n\n  // Return most recent files, limited to MAX_EDITED_FILES\n  return editedFiles.slice(0, MAX_EDITED_FILES);\n}\n\n/**\n * Extract the original content from multiple unified diffs.\n * Parses all diffs and reconstructs what the file looked like before any edits.\n *\n * Strategy:\n * 1. The first diff's \"original\" side is the true original for regions it covers.\n * 2. For regions not covered by the first diff, later diffs provide the original\n *    content (since those regions weren't modified by earlier diffs).\n * 3. Lines that the first diff ADDS (new content) should not be filled from\n *    subsequent diffs, as they didn't exist in the original.\n *\n * Uses hunk positions to place content correctly and tracks claimed regions.\n */\nfunction extractOriginalFromDiffs(diffs: string[]): string {\n  if (diffs.length === 0) return \"\";\n\n  const lines: string[] = [];\n\n  // First pass: extract original from first diff and track its coverage\n  // Also track line indices that were ADDED by the first diff (in the new file)\n  // These indices shouldn't be filled from subsequent diffs\n  const firstDiffOriginalIndices = new Set<number>();\n  const firstDiffAddedIndices = new Set<number>(); // Indices in the NEW file that were added\n\n  const firstDiff = diffs[0];\n  const firstPatches = parsePatch(firstDiff);\n  if (firstPatches.length > 0 && firstPatches[0].hunks) {\n    for (const hunk of firstPatches[0].hunks) {\n      let oldLineIndex = hunk.oldStart - 1;\n      let newLineIndex = hunk.newStart - 1;\n\n      // Fill gap with placeholder empty lines if needed\n      while (lines.length < oldLineIndex) {\n        lines.push(\"\");\n      }\n\n      for (const line of hunk.lines) {\n        if (line.startsWith(\"-\") || line.startsWith(\" \")) {\n          // Original content\n          const content = line.slice(1);\n          if (oldLineIndex >= lines.length) {\n            lines.push(content);\n          } else {\n            lines[oldLineIndex] = content;\n          }\n          firstDiffOriginalIndices.add(oldLineIndex);\n          oldLineIndex++;\n        }\n        if (line.startsWith(\"+\") || line.startsWith(\" \")) {\n          // Track new-file indices for context lines and additions\n          firstDiffAddedIndices.add(newLineIndex);\n          newLineIndex++;\n        }\n      }\n    }\n  }\n\n  // Second pass: fill gaps from subsequent diffs\n  // Only add content for regions not covered by the first diff\n  for (let i = 1; i < diffs.length; i++) {\n    const diff = diffs[i];\n    const patches = parsePatch(diff);\n    if (patches.length === 0 || !patches[0].hunks) continue;\n\n    for (const hunk of patches[0].hunks) {\n      // The hunk's oldStart refers to line numbers in the file AFTER previous diffs\n      // For non-overlapping regions, this should match the original file\n      let lineIndex = hunk.oldStart - 1;\n\n      // Fill gap with placeholder empty lines if needed\n      while (lines.length < lineIndex) {\n        lines.push(\"\");\n      }\n\n      for (const line of hunk.lines) {\n        if (line.startsWith(\"-\") || line.startsWith(\" \")) {\n          const content = line.slice(1);\n\n          // Only fill if:\n          // 1. This index wasn't part of the first diff's original content\n          // 2. This index wasn't ADDED by the first diff (would be intermediate state)\n          // 3. We haven't already filled this slot\n          const isOriginalFromFirstDiff = firstDiffOriginalIndices.has(lineIndex);\n          const wasAddedByFirstDiff = firstDiffAddedIndices.has(lineIndex);\n\n          if (!isOriginalFromFirstDiff && !wasAddedByFirstDiff) {\n            if (lineIndex >= lines.length) {\n              lines.push(content);\n            } else if (lines[lineIndex] === \"\") {\n              lines[lineIndex] = content;\n            }\n          }\n          lineIndex++;\n        }\n      }\n    }\n  }\n\n  return lines.join(\"\\n\");\n}\n\n/**\n * Extract edited files with their combined diffs from message history.\n * Scans assistant messages for successful file_edit_* tool uses and combines\n * multiple edits to the same file into a single unified diff.\n *\n * Returns most recently edited files first, limited to MAX_EDITED_FILES.\n *\n * @param messages - The message history to scan\n * @returns Array of file diffs (max MAX_EDITED_FILES)\n */\nexport function extractEditedFileDiffs(messages: MuxMessage[]): FileEditDiff[] {\n  // Collect all diffs per file path in chronological order\n  const diffsByPath = new Map<string, string[]>();\n  const editOrder: string[] = []; // Track order of last edit per file\n\n  for (const message of messages) {\n    if (message.role !== \"assistant\") continue;\n\n    for (const part of message.parts) {\n      if (part.type !== \"dynamic-tool\") continue;\n      if (!FILE_EDIT_TOOL_NAMES.includes(part.toolName as (typeof FILE_EDIT_TOOL_NAMES)[number]))\n        continue;\n      if (part.state !== \"output-available\") continue;\n\n      const output = part.output as FileEditToolOutput | undefined;\n      if (!output?.success) continue;\n\n      const uiOnly = getToolOutputUiOnly(output);\n      const diff = uiOnly?.file_edit?.diff ?? output.diff;\n      if (!diff) continue;\n\n      const input = part.input as FileEditToolInput | undefined;\n      const filePath = input?.file_path;\n      if (!filePath || typeof filePath !== \"string\") continue;\n\n      // Add diff to this file's list\n      if (!diffsByPath.has(filePath)) {\n        diffsByPath.set(filePath, []);\n      }\n      diffsByPath.get(filePath)!.push(diff);\n\n      // Update edit order (move to end if already exists)\n      const idx = editOrder.indexOf(filePath);\n      if (idx !== -1) editOrder.splice(idx, 1);\n      editOrder.push(filePath);\n    }\n  }\n\n  // Process files in reverse edit order (most recent first)\n  const results: FileEditDiff[] = [];\n  for (let i = editOrder.length - 1; i >= 0 && results.length < MAX_EDITED_FILES; i--) {\n    const filePath = editOrder[i];\n    const diffs = diffsByPath.get(filePath)!;\n\n    const combined = combineDiffs(filePath, diffs);\n    if (combined) {\n      results.push(combined);\n    }\n  }\n\n  return results;\n}\n\n/**\n * Combine multiple diffs for the same file into a single unified diff.\n * Applies diffs sequentially to reconstruct originalâ†’final transformation.\n */\nfunction combineDiffs(filePath: string, diffs: string[]): FileEditDiff | null {\n  if (diffs.length === 0) return null;\n\n  // Single diff - no combination needed\n  if (diffs.length === 1) {\n    const diff = diffs[0];\n    const truncated = diff.length > MAX_FILE_CONTENT_SIZE;\n    return {\n      path: filePath,\n      diff: truncated ? diff.slice(0, MAX_FILE_CONTENT_SIZE) : diff,\n      truncated,\n    };\n  }\n\n  // Multiple diffs - need to combine\n  // Start by extracting original content from all diffs (each covers different regions)\n  let content = extractOriginalFromDiffs(diffs);\n  const originalContent = content;\n\n  // Apply each diff sequentially\n  for (const diff of diffs) {\n    const result = applyPatch(content, diff);\n    if (result === false) {\n      // Patch failed to apply - fall back to just using the last diff\n      const lastDiff = diffs[diffs.length - 1];\n      const truncated = lastDiff.length > MAX_FILE_CONTENT_SIZE;\n      return {\n        path: filePath,\n        diff: truncated ? lastDiff.slice(0, MAX_FILE_CONTENT_SIZE) : lastDiff,\n        truncated,\n      };\n    }\n    content = result;\n  }\n\n  // Generate combined diff from original to final\n  const combinedDiff = createPatch(filePath, originalContent, content, \"\", \"\", { context: 3 });\n  const truncated = combinedDiff.length > MAX_FILE_CONTENT_SIZE;\n\n  return {\n    path: filePath,\n    diff: truncated ? combinedDiff.slice(0, MAX_FILE_CONTENT_SIZE) : combinedDiff,\n    truncated,\n  };\n}\n"]}