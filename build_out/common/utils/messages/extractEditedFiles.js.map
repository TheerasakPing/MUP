{"version":3,"file":"extractEditedFiles.js","sourceRoot":"","sources":["../../../../src/common/utils/messages/extractEditedFiles.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MuxMessage } from \"@/common/types/message\";\r\nimport { getToolOutputUiOnly } from \"@/common/utils/tools/toolOutputUiOnly\";\r\nimport { FILE_EDIT_TOOL_NAMES } from \"@/common/types/tools\";\r\nimport { MAX_EDITED_FILES, MAX_FILE_CONTENT_SIZE } from \"@/common/constants/attachments\";\r\nimport { applyPatch, createPatch, parsePatch } from \"diff\";\r\n\r\n/**\r\n * Input shape for file edit tools.\r\n * All file edit tools have a file_path field.\r\n */\r\ninterface FileEditToolInput {\r\n  file_path?: string;\r\n}\r\n\r\n/**\r\n * Output shape for file edit tools.\r\n * Successful edits contain a diff field.\r\n */\r\ninterface FileEditToolOutput {\r\n  success?: boolean;\r\n  diff?: string;\r\n}\r\n\r\n/**\r\n * Represents a file and its combined diff from all edits.\r\n */\r\nexport interface FileEditDiff {\r\n  path: string;\r\n  diff: string;\r\n  truncated: boolean;\r\n}\r\n\r\n/**\r\n * Extract unique file paths that have been edited from message history.\r\n * Scans assistant messages for successful file_edit_* tool uses.\r\n * Returns most recently edited files first, limited to MAX_EDITED_FILES.\r\n *\r\n * @param messages - The message history to scan\r\n * @returns Array of unique absolute file paths that were edited (max MAX_EDITED_FILES)\r\n */\r\nexport function extractEditedFilePaths(messages: MuxMessage[]): string[] {\r\n  const editedFiles: string[] = [];\r\n  const seen = new Set<string>();\r\n\r\n  // Iterate in reverse to get most recent edits first\r\n  for (let i = messages.length - 1; i >= 0; i--) {\r\n    const message = messages[i];\r\n    if (message.role !== \"assistant\") continue;\r\n\r\n    for (const part of message.parts) {\r\n      if (part.type !== \"dynamic-tool\") continue;\r\n      if (!FILE_EDIT_TOOL_NAMES.includes(part.toolName as (typeof FILE_EDIT_TOOL_NAMES)[number]))\r\n        continue;\r\n\r\n      // Only count successful edits (output-available with success)\r\n      if (part.state !== \"output-available\") continue;\r\n\r\n      // Check if the tool result indicates success\r\n      const output = part.output as { success?: boolean } | undefined;\r\n      if (!output?.success) continue;\r\n\r\n      // Extract file path from input\r\n      const input = part.input as FileEditToolInput | undefined;\r\n      const filePath = input?.file_path;\r\n      if (filePath && typeof filePath === \"string\" && !seen.has(filePath)) {\r\n        seen.add(filePath);\r\n        editedFiles.push(filePath);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Return most recent files, limited to MAX_EDITED_FILES\r\n  return editedFiles.slice(0, MAX_EDITED_FILES);\r\n}\r\n\r\n/**\r\n * Extract the original content from multiple unified diffs.\r\n * Parses all diffs and reconstructs what the file looked like before any edits.\r\n *\r\n * Strategy:\r\n * 1. The first diff's \"original\" side is the true original for regions it covers.\r\n * 2. For regions not covered by the first diff, later diffs provide the original\r\n *    content (since those regions weren't modified by earlier diffs).\r\n * 3. Lines that the first diff ADDS (new content) should not be filled from\r\n *    subsequent diffs, as they didn't exist in the original.\r\n *\r\n * Uses hunk positions to place content correctly and tracks claimed regions.\r\n */\r\nfunction extractOriginalFromDiffs(diffs: string[]): string {\r\n  if (diffs.length === 0) return \"\";\r\n\r\n  const lines: string[] = [];\r\n\r\n  // First pass: extract original from first diff and track its coverage\r\n  // Also track line indices that were ADDED by the first diff (in the new file)\r\n  // These indices shouldn't be filled from subsequent diffs\r\n  const firstDiffOriginalIndices = new Set<number>();\r\n  const firstDiffAddedIndices = new Set<number>(); // Indices in the NEW file that were added\r\n\r\n  const firstDiff = diffs[0];\r\n  const firstPatches = parsePatch(firstDiff);\r\n  if (firstPatches.length > 0 && firstPatches[0].hunks) {\r\n    for (const hunk of firstPatches[0].hunks) {\r\n      let oldLineIndex = hunk.oldStart - 1;\r\n      let newLineIndex = hunk.newStart - 1;\r\n\r\n      // Fill gap with placeholder empty lines if needed\r\n      while (lines.length < oldLineIndex) {\r\n        lines.push(\"\");\r\n      }\r\n\r\n      for (const line of hunk.lines) {\r\n        if (line.startsWith(\"-\") || line.startsWith(\" \")) {\r\n          // Original content\r\n          const content = line.slice(1);\r\n          if (oldLineIndex >= lines.length) {\r\n            lines.push(content);\r\n          } else {\r\n            lines[oldLineIndex] = content;\r\n          }\r\n          firstDiffOriginalIndices.add(oldLineIndex);\r\n          oldLineIndex++;\r\n        }\r\n        if (line.startsWith(\"+\") || line.startsWith(\" \")) {\r\n          // Track new-file indices for context lines and additions\r\n          firstDiffAddedIndices.add(newLineIndex);\r\n          newLineIndex++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Second pass: fill gaps from subsequent diffs\r\n  // Only add content for regions not covered by the first diff\r\n  for (let i = 1; i < diffs.length; i++) {\r\n    const diff = diffs[i];\r\n    const patches = parsePatch(diff);\r\n    if (patches.length === 0 || !patches[0].hunks) continue;\r\n\r\n    for (const hunk of patches[0].hunks) {\r\n      // The hunk's oldStart refers to line numbers in the file AFTER previous diffs\r\n      // For non-overlapping regions, this should match the original file\r\n      let lineIndex = hunk.oldStart - 1;\r\n\r\n      // Fill gap with placeholder empty lines if needed\r\n      while (lines.length < lineIndex) {\r\n        lines.push(\"\");\r\n      }\r\n\r\n      for (const line of hunk.lines) {\r\n        if (line.startsWith(\"-\") || line.startsWith(\" \")) {\r\n          const content = line.slice(1);\r\n\r\n          // Only fill if:\r\n          // 1. This index wasn't part of the first diff's original content\r\n          // 2. This index wasn't ADDED by the first diff (would be intermediate state)\r\n          // 3. We haven't already filled this slot\r\n          const isOriginalFromFirstDiff = firstDiffOriginalIndices.has(lineIndex);\r\n          const wasAddedByFirstDiff = firstDiffAddedIndices.has(lineIndex);\r\n\r\n          if (!isOriginalFromFirstDiff && !wasAddedByFirstDiff) {\r\n            if (lineIndex >= lines.length) {\r\n              lines.push(content);\r\n            } else if (lines[lineIndex] === \"\") {\r\n              lines[lineIndex] = content;\r\n            }\r\n          }\r\n          lineIndex++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return lines.join(\"\\n\");\r\n}\r\n\r\n/**\r\n * Extract edited files with their combined diffs from message history.\r\n * Scans assistant messages for successful file_edit_* tool uses and combines\r\n * multiple edits to the same file into a single unified diff.\r\n *\r\n * Returns most recently edited files first, limited to MAX_EDITED_FILES.\r\n *\r\n * @param messages - The message history to scan\r\n * @returns Array of file diffs (max MAX_EDITED_FILES)\r\n */\r\nexport function extractEditedFileDiffs(messages: MuxMessage[]): FileEditDiff[] {\r\n  // Collect all diffs per file path in chronological order\r\n  const diffsByPath = new Map<string, string[]>();\r\n  const editOrder: string[] = []; // Track order of last edit per file\r\n\r\n  for (const message of messages) {\r\n    if (message.role !== \"assistant\") continue;\r\n\r\n    for (const part of message.parts) {\r\n      if (part.type !== \"dynamic-tool\") continue;\r\n      if (!FILE_EDIT_TOOL_NAMES.includes(part.toolName as (typeof FILE_EDIT_TOOL_NAMES)[number]))\r\n        continue;\r\n      if (part.state !== \"output-available\") continue;\r\n\r\n      const output = part.output as FileEditToolOutput | undefined;\r\n      if (!output?.success) continue;\r\n\r\n      const uiOnly = getToolOutputUiOnly(output);\r\n      const diff = uiOnly?.file_edit?.diff ?? output.diff;\r\n      if (!diff) continue;\r\n\r\n      const input = part.input as FileEditToolInput | undefined;\r\n      const filePath = input?.file_path;\r\n      if (!filePath || typeof filePath !== \"string\") continue;\r\n\r\n      // Add diff to this file's list\r\n      if (!diffsByPath.has(filePath)) {\r\n        diffsByPath.set(filePath, []);\r\n      }\r\n      diffsByPath.get(filePath)!.push(diff);\r\n\r\n      // Update edit order (move to end if already exists)\r\n      const idx = editOrder.indexOf(filePath);\r\n      if (idx !== -1) editOrder.splice(idx, 1);\r\n      editOrder.push(filePath);\r\n    }\r\n  }\r\n\r\n  // Process files in reverse edit order (most recent first)\r\n  const results: FileEditDiff[] = [];\r\n  for (let i = editOrder.length - 1; i >= 0 && results.length < MAX_EDITED_FILES; i--) {\r\n    const filePath = editOrder[i];\r\n    const diffs = diffsByPath.get(filePath)!;\r\n\r\n    const combined = combineDiffs(filePath, diffs);\r\n    if (combined) {\r\n      results.push(combined);\r\n    }\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\n/**\r\n * Combine multiple diffs for the same file into a single unified diff.\r\n * Applies diffs sequentially to reconstruct originalâ†’final transformation.\r\n */\r\nfunction combineDiffs(filePath: string, diffs: string[]): FileEditDiff | null {\r\n  if (diffs.length === 0) return null;\r\n\r\n  // Single diff - no combination needed\r\n  if (diffs.length === 1) {\r\n    const diff = diffs[0];\r\n    const truncated = diff.length > MAX_FILE_CONTENT_SIZE;\r\n    return {\r\n      path: filePath,\r\n      diff: truncated ? diff.slice(0, MAX_FILE_CONTENT_SIZE) : diff,\r\n      truncated,\r\n    };\r\n  }\r\n\r\n  // Multiple diffs - need to combine\r\n  // Start by extracting original content from all diffs (each covers different regions)\r\n  let content = extractOriginalFromDiffs(diffs);\r\n  const originalContent = content;\r\n\r\n  // Apply each diff sequentially\r\n  for (const diff of diffs) {\r\n    const result = applyPatch(content, diff);\r\n    if (result === false) {\r\n      // Patch failed to apply - fall back to just using the last diff\r\n      const lastDiff = diffs[diffs.length - 1];\r\n      const truncated = lastDiff.length > MAX_FILE_CONTENT_SIZE;\r\n      return {\r\n        path: filePath,\r\n        diff: truncated ? lastDiff.slice(0, MAX_FILE_CONTENT_SIZE) : lastDiff,\r\n        truncated,\r\n      };\r\n    }\r\n    content = result;\r\n  }\r\n\r\n  // Generate combined diff from original to final\r\n  const combinedDiff = createPatch(filePath, originalContent, content, \"\", \"\", { context: 3 });\r\n  const truncated = combinedDiff.length > MAX_FILE_CONTENT_SIZE;\r\n\r\n  return {\r\n    path: filePath,\r\n    diff: truncated ? combinedDiff.slice(0, MAX_FILE_CONTENT_SIZE) : combinedDiff,\r\n    truncated,\r\n  };\r\n}\r\n"]}