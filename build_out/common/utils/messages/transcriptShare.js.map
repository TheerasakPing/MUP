{"version":3,"file":"transcriptShare.js","sourceRoot":"","sources":["../../../../src/common/utils/messages/transcriptShare.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MuxMessage, MuxToolPart } from \"@/common/types/message\";\r\nimport type { NestedToolCall } from \"@/common/orpc/schemas/message\";\r\n\r\nexport interface BuildChatJsonlForSharingOptions {\r\n  /** Defaults to true */\r\n  includeToolOutput?: boolean;\r\n  /** Optional workspace context to match on-disk chat.jsonl entries */\r\n  workspaceId?: string;\r\n  /** Optional plan file snapshot to inline into propose_plan tool output. */\r\n  planSnapshot?: { path: string; content: string };\r\n}\r\n\r\ninterface ChatJsonlEntry extends MuxMessage {\r\n  workspaceId?: string;\r\n}\r\n\r\n/**\r\n * chat.jsonl can contain *streaming deltas* (especially in older history), which means assistant\r\n * messages may have thousands of tiny {type:\"text\"|\"reasoning\"} parts.\r\n *\r\n * For sharing, we compact adjacent text/reasoning runs into a single part each to drastically\r\n * reduce file size.\r\n */\r\nfunction mergeAdjacentTextAndReasoningPartsForSharing(\r\n  parts: MuxMessage[\"parts\"]\r\n): MuxMessage[\"parts\"] {\r\n  if (parts.length <= 1) return parts;\r\n\r\n  const merged: MuxMessage[\"parts\"] = [];\r\n  let pendingTexts: string[] = [];\r\n  let pendingTextTimestamp: number | undefined;\r\n  let pendingReasonings: string[] = [];\r\n  let pendingReasoningTimestamp: number | undefined;\r\n\r\n  const flushText = () => {\r\n    if (pendingTexts.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const text = pendingTexts.join(\"\");\r\n    if (pendingTextTimestamp === undefined) {\r\n      merged.push({ type: \"text\", text });\r\n    } else {\r\n      merged.push({ type: \"text\", text, timestamp: pendingTextTimestamp });\r\n    }\r\n\r\n    pendingTexts = [];\r\n    pendingTextTimestamp = undefined;\r\n  };\r\n\r\n  const flushReasoning = () => {\r\n    if (pendingReasonings.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const text = pendingReasonings.join(\"\");\r\n    if (pendingReasoningTimestamp === undefined) {\r\n      merged.push({ type: \"reasoning\", text });\r\n    } else {\r\n      merged.push({ type: \"reasoning\", text, timestamp: pendingReasoningTimestamp });\r\n    }\r\n\r\n    pendingReasonings = [];\r\n    pendingReasoningTimestamp = undefined;\r\n  };\r\n\r\n  for (const part of parts) {\r\n    if (part.type === \"text\") {\r\n      flushReasoning();\r\n      pendingTexts.push(part.text);\r\n      pendingTextTimestamp ??= part.timestamp;\r\n    } else if (part.type === \"reasoning\") {\r\n      flushText();\r\n      pendingReasonings.push(part.text);\r\n      pendingReasoningTimestamp ??= part.timestamp;\r\n    } else {\r\n      // Tool/file part - flush and keep as-is.\r\n      flushText();\r\n      flushReasoning();\r\n      merged.push(part);\r\n    }\r\n  }\r\n\r\n  flushText();\r\n  flushReasoning();\r\n\r\n  return merged;\r\n}\r\n\r\nfunction compactMessagePartsForSharing(messages: MuxMessage[]): MuxMessage[] {\r\n  return messages.map((msg) => {\r\n    const parts = mergeAdjacentTextAndReasoningPartsForSharing(msg.parts);\r\n    if (parts === msg.parts) {\r\n      return msg;\r\n    }\r\n    return {\r\n      ...msg,\r\n      parts,\r\n    };\r\n  });\r\n}\r\n\r\nfunction stripNestedToolCallOutput(call: NestedToolCall): NestedToolCall {\r\n  if (call.state !== \"output-available\") {\r\n    return call;\r\n  }\r\n\r\n  const { output: _output, ...rest } = call;\r\n  return {\r\n    ...rest,\r\n    state: \"output-redacted\",\r\n  };\r\n}\r\n\r\n// Tools whose output is preserved even when stripping — their output IS the content\r\n// (plan text, sub-agent reports) and can't be reconstructed from disk.\r\nconst PRESERVE_OUTPUT_TOOLS = new Set([\r\n  \"propose_plan\",\r\n  \"task\",\r\n  \"task_await\",\r\n  \"task_list\",\r\n  \"task_terminate\",\r\n  \"task_apply_git_patch\",\r\n]);\r\n\r\nfunction stripToolPartOutput(part: MuxToolPart): MuxToolPart {\r\n  const nestedCalls = part.nestedCalls?.map(stripNestedToolCallOutput);\r\n\r\n  if (PRESERVE_OUTPUT_TOOLS.has(part.toolName)) {\r\n    return nestedCalls ? { ...part, nestedCalls } : part;\r\n  }\r\n\r\n  if (part.state !== \"output-available\") {\r\n    return nestedCalls ? { ...part, nestedCalls } : part;\r\n  }\r\n\r\n  const { output: _output, ...rest } = part;\r\n  return {\r\n    ...rest,\r\n    state: \"output-redacted\",\r\n    nestedCalls,\r\n  };\r\n}\r\n\r\nfunction stripToolOutputsForSharing(messages: MuxMessage[]): MuxMessage[] {\r\n  return messages.map((msg) => {\r\n    if (msg.role !== \"assistant\") {\r\n      return msg;\r\n    }\r\n\r\n    const parts = msg.parts.map((part) => {\r\n      if (part.type !== \"dynamic-tool\") {\r\n        return part;\r\n      }\r\n      return stripToolPartOutput(part);\r\n    });\r\n\r\n    return {\r\n      ...msg,\r\n      parts,\r\n    };\r\n  });\r\n}\r\n\r\nfunction isRecord(value: unknown): value is Record<string, unknown> {\r\n  return value !== null && typeof value === \"object\";\r\n}\r\n\r\nfunction inlinePlanContentForSharing(\r\n  messages: MuxMessage[],\r\n  planSnapshot: { path: string; content: string }\r\n): MuxMessage[] {\r\n  return messages.map((msg) => {\r\n    if (msg.role !== \"assistant\") {\r\n      return msg;\r\n    }\r\n\r\n    let changed = false;\r\n\r\n    const parts = msg.parts.map((part) => {\r\n      if (part.type !== \"dynamic-tool\") {\r\n        return part;\r\n      }\r\n\r\n      if (part.toolName !== \"propose_plan\" || part.state !== \"output-available\") {\r\n        return part;\r\n      }\r\n\r\n      if (!isRecord(part.output)) {\r\n        return part;\r\n      }\r\n\r\n      const output = part.output;\r\n      if (output.success !== true) {\r\n        return part;\r\n      }\r\n\r\n      if (typeof output.planPath !== \"string\") {\r\n        return part;\r\n      }\r\n\r\n      // For shared transcripts, inline plan content into completed propose_plan tool calls.\r\n      // We intentionally do not try to match `planSnapshot.path` to `output.planPath` — tool output\r\n      // often uses `~/.mux/...` while the snapshot path is resolved, and path normalization is\r\n      // brittle across platforms.\r\n      if (\"planContent\" in output) {\r\n        return part;\r\n      }\r\n\r\n      changed = true;\r\n      return {\r\n        ...part,\r\n        output: {\r\n          ...output,\r\n          planContent: planSnapshot.content,\r\n        },\r\n      };\r\n    });\r\n\r\n    return changed ? { ...msg, parts } : msg;\r\n  });\r\n}\r\n\r\n/**\r\n * Build a JSONL transcript (one message per line, trailing newline) suitable for sharing.\r\n *\r\n * NOTE: This preserves chat.jsonl-compatible message structure (tool calls, files, etc), but\r\n * compacts adjacent text/reasoning deltas into a single part each to keep shared transcripts small.\r\n */\r\nexport function buildChatJsonlForSharing(\r\n  messages: MuxMessage[],\r\n  options: BuildChatJsonlForSharingOptions = {}\r\n): string {\r\n  if (messages.length === 0) return \"\";\r\n\r\n  const includeToolOutput = options.includeToolOutput ?? true;\r\n\r\n  const withPlanInlined = options.planSnapshot\r\n    ? inlinePlanContentForSharing(messages, options.planSnapshot)\r\n    : messages;\r\n\r\n  const sanitized = includeToolOutput\r\n    ? withPlanInlined\r\n    : stripToolOutputsForSharing(withPlanInlined);\r\n\r\n  const compacted = compactMessagePartsForSharing(sanitized);\r\n\r\n  return (\r\n    compacted\r\n      .map((msg): ChatJsonlEntry => {\r\n        if (options.workspaceId === undefined) {\r\n          return msg;\r\n        }\r\n        return {\r\n          ...msg,\r\n          workspaceId: options.workspaceId,\r\n        };\r\n      })\r\n      .map((msg) => JSON.stringify(msg))\r\n      .join(\"\\n\") + \"\\n\"\r\n  );\r\n}\r\n"]}