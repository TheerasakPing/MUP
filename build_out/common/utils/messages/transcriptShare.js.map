{"version":3,"file":"transcriptShare.js","sourceRoot":"","sources":["../../../../src/common/utils/messages/transcriptShare.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MuxMessage, MuxToolPart } from \"@/common/types/message\";\nimport type { NestedToolCall } from \"@/common/orpc/schemas/message\";\n\nexport interface BuildChatJsonlForSharingOptions {\n  /** Defaults to true */\n  includeToolOutput?: boolean;\n  /** Optional workspace context to match on-disk chat.jsonl entries */\n  workspaceId?: string;\n  /** Optional plan file snapshot to inline into propose_plan tool output. */\n  planSnapshot?: { path: string; content: string };\n}\n\ninterface ChatJsonlEntry extends MuxMessage {\n  workspaceId?: string;\n}\n\n/**\n * chat.jsonl can contain *streaming deltas* (especially in older history), which means assistant\n * messages may have thousands of tiny {type:\"text\"|\"reasoning\"} parts.\n *\n * For sharing, we compact adjacent text/reasoning runs into a single part each to drastically\n * reduce file size.\n */\nfunction mergeAdjacentTextAndReasoningPartsForSharing(\n  parts: MuxMessage[\"parts\"]\n): MuxMessage[\"parts\"] {\n  if (parts.length <= 1) return parts;\n\n  const merged: MuxMessage[\"parts\"] = [];\n  let pendingTexts: string[] = [];\n  let pendingTextTimestamp: number | undefined;\n  let pendingReasonings: string[] = [];\n  let pendingReasoningTimestamp: number | undefined;\n\n  const flushText = () => {\n    if (pendingTexts.length === 0) {\n      return;\n    }\n\n    const text = pendingTexts.join(\"\");\n    if (pendingTextTimestamp === undefined) {\n      merged.push({ type: \"text\", text });\n    } else {\n      merged.push({ type: \"text\", text, timestamp: pendingTextTimestamp });\n    }\n\n    pendingTexts = [];\n    pendingTextTimestamp = undefined;\n  };\n\n  const flushReasoning = () => {\n    if (pendingReasonings.length === 0) {\n      return;\n    }\n\n    const text = pendingReasonings.join(\"\");\n    if (pendingReasoningTimestamp === undefined) {\n      merged.push({ type: \"reasoning\", text });\n    } else {\n      merged.push({ type: \"reasoning\", text, timestamp: pendingReasoningTimestamp });\n    }\n\n    pendingReasonings = [];\n    pendingReasoningTimestamp = undefined;\n  };\n\n  for (const part of parts) {\n    if (part.type === \"text\") {\n      flushReasoning();\n      pendingTexts.push(part.text);\n      pendingTextTimestamp ??= part.timestamp;\n    } else if (part.type === \"reasoning\") {\n      flushText();\n      pendingReasonings.push(part.text);\n      pendingReasoningTimestamp ??= part.timestamp;\n    } else {\n      // Tool/file part - flush and keep as-is.\n      flushText();\n      flushReasoning();\n      merged.push(part);\n    }\n  }\n\n  flushText();\n  flushReasoning();\n\n  return merged;\n}\n\nfunction compactMessagePartsForSharing(messages: MuxMessage[]): MuxMessage[] {\n  return messages.map((msg) => {\n    const parts = mergeAdjacentTextAndReasoningPartsForSharing(msg.parts);\n    if (parts === msg.parts) {\n      return msg;\n    }\n    return {\n      ...msg,\n      parts,\n    };\n  });\n}\n\nfunction stripNestedToolCallOutput(call: NestedToolCall): NestedToolCall {\n  if (call.state !== \"output-available\") {\n    return call;\n  }\n\n  const { output: _output, ...rest } = call;\n  return {\n    ...rest,\n    state: \"output-redacted\",\n  };\n}\n\n// Tools whose output is preserved even when stripping — their output IS the content\n// (plan text, sub-agent reports) and can't be reconstructed from disk.\nconst PRESERVE_OUTPUT_TOOLS = new Set([\n  \"propose_plan\",\n  \"task\",\n  \"task_await\",\n  \"task_list\",\n  \"task_terminate\",\n  \"task_apply_git_patch\",\n]);\n\nfunction stripToolPartOutput(part: MuxToolPart): MuxToolPart {\n  const nestedCalls = part.nestedCalls?.map(stripNestedToolCallOutput);\n\n  if (PRESERVE_OUTPUT_TOOLS.has(part.toolName)) {\n    return nestedCalls ? { ...part, nestedCalls } : part;\n  }\n\n  if (part.state !== \"output-available\") {\n    return nestedCalls ? { ...part, nestedCalls } : part;\n  }\n\n  const { output: _output, ...rest } = part;\n  return {\n    ...rest,\n    state: \"output-redacted\",\n    nestedCalls,\n  };\n}\n\nfunction stripToolOutputsForSharing(messages: MuxMessage[]): MuxMessage[] {\n  return messages.map((msg) => {\n    if (msg.role !== \"assistant\") {\n      return msg;\n    }\n\n    const parts = msg.parts.map((part) => {\n      if (part.type !== \"dynamic-tool\") {\n        return part;\n      }\n      return stripToolPartOutput(part);\n    });\n\n    return {\n      ...msg,\n      parts,\n    };\n  });\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return value !== null && typeof value === \"object\";\n}\n\nfunction inlinePlanContentForSharing(\n  messages: MuxMessage[],\n  planSnapshot: { path: string; content: string }\n): MuxMessage[] {\n  return messages.map((msg) => {\n    if (msg.role !== \"assistant\") {\n      return msg;\n    }\n\n    let changed = false;\n\n    const parts = msg.parts.map((part) => {\n      if (part.type !== \"dynamic-tool\") {\n        return part;\n      }\n\n      if (part.toolName !== \"propose_plan\" || part.state !== \"output-available\") {\n        return part;\n      }\n\n      if (!isRecord(part.output)) {\n        return part;\n      }\n\n      const output = part.output;\n      if (output.success !== true) {\n        return part;\n      }\n\n      if (typeof output.planPath !== \"string\") {\n        return part;\n      }\n\n      // For shared transcripts, inline plan content into completed propose_plan tool calls.\n      // We intentionally do not try to match `planSnapshot.path` to `output.planPath` — tool output\n      // often uses `~/.mux/...` while the snapshot path is resolved, and path normalization is\n      // brittle across platforms.\n      if (\"planContent\" in output) {\n        return part;\n      }\n\n      changed = true;\n      return {\n        ...part,\n        output: {\n          ...output,\n          planContent: planSnapshot.content,\n        },\n      };\n    });\n\n    return changed ? { ...msg, parts } : msg;\n  });\n}\n\n/**\n * Build a JSONL transcript (one message per line, trailing newline) suitable for sharing.\n *\n * NOTE: This preserves chat.jsonl-compatible message structure (tool calls, files, etc), but\n * compacts adjacent text/reasoning deltas into a single part each to keep shared transcripts small.\n */\nexport function buildChatJsonlForSharing(\n  messages: MuxMessage[],\n  options: BuildChatJsonlForSharingOptions = {}\n): string {\n  if (messages.length === 0) return \"\";\n\n  const includeToolOutput = options.includeToolOutput ?? true;\n\n  const withPlanInlined = options.planSnapshot\n    ? inlinePlanContentForSharing(messages, options.planSnapshot)\n    : messages;\n\n  const sanitized = includeToolOutput\n    ? withPlanInlined\n    : stripToolOutputsForSharing(withPlanInlined);\n\n  const compacted = compactMessagePartsForSharing(sanitized);\n\n  return (\n    compacted\n      .map((msg): ChatJsonlEntry => {\n        if (options.workspaceId === undefined) {\n          return msg;\n        }\n        return {\n          ...msg,\n          workspaceId: options.workspaceId,\n        };\n      })\n      .map((msg) => JSON.stringify(msg))\n      .join(\"\\n\") + \"\\n\"\n  );\n}\n"]}