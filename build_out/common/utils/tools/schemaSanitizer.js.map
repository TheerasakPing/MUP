{"version":3,"file":"schemaSanitizer.js","sourceRoot":"","sources":["../../../../src/common/utils/tools/schemaSanitizer.ts"],"names":[],"mappings":"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","sourcesContent":["import { type Tool } from \"ai\";\r\n\r\n/**\r\n * JSON Schema properties that are not permitted by OpenAI's Responses API.\r\n *\r\n * OpenAI's Structured Outputs has stricter JSON Schema validation than other providers.\r\n * MCP tools may have schemas with these properties which work fine with Anthropic\r\n * but fail with OpenAI. We strip these properties to ensure compatibility.\r\n *\r\n * @see https://platform.openai.com/docs/guides/structured-outputs\r\n * @see https://github.com/vercel/ai/discussions/5164\r\n */\r\nconst OPENAI_UNSUPPORTED_SCHEMA_PROPERTIES = new Set([\r\n  // String validation\r\n  \"minLength\",\r\n  \"maxLength\",\r\n  \"pattern\",\r\n  \"format\",\r\n  // Number validation\r\n  \"minimum\",\r\n  \"maximum\",\r\n  \"exclusiveMinimum\",\r\n  \"exclusiveMaximum\",\r\n  \"multipleOf\",\r\n  // Array validation\r\n  \"minItems\",\r\n  \"maxItems\",\r\n  \"uniqueItems\",\r\n  // Object validation\r\n  \"minProperties\",\r\n  \"maxProperties\",\r\n  // General\r\n  \"default\",\r\n  \"examples\",\r\n  \"deprecated\",\r\n  \"readOnly\",\r\n  \"writeOnly\",\r\n  // Composition (partially supported - strip from items/properties)\r\n  // Note: oneOf/anyOf at root level may work, but not in nested contexts\r\n]);\r\n\r\n/**\r\n * Recursively strip unsupported schema properties for OpenAI compatibility.\r\n * This mutates the schema in place for efficiency.\r\n */\r\nfunction stripUnsupportedProperties(schema: unknown): void {\r\n  if (typeof schema !== \"object\" || schema === null) {\r\n    return;\r\n  }\r\n\r\n  const obj = schema as Record<string, unknown>;\r\n\r\n  // Remove unsupported properties at this level\r\n  for (const prop of OPENAI_UNSUPPORTED_SCHEMA_PROPERTIES) {\r\n    if (prop in obj) {\r\n      delete obj[prop];\r\n    }\r\n  }\r\n\r\n  // Recursively process nested schemas\r\n  if (obj.properties && typeof obj.properties === \"object\") {\r\n    for (const propSchema of Object.values(obj.properties as Record<string, unknown>)) {\r\n      stripUnsupportedProperties(propSchema);\r\n    }\r\n  }\r\n\r\n  if (obj.items) {\r\n    if (Array.isArray(obj.items)) {\r\n      for (const itemSchema of obj.items) {\r\n        stripUnsupportedProperties(itemSchema);\r\n      }\r\n    } else {\r\n      stripUnsupportedProperties(obj.items);\r\n    }\r\n  }\r\n\r\n  if (obj.additionalProperties && typeof obj.additionalProperties === \"object\") {\r\n    stripUnsupportedProperties(obj.additionalProperties);\r\n  }\r\n\r\n  // Handle anyOf/oneOf/allOf\r\n  for (const keyword of [\"anyOf\", \"oneOf\", \"allOf\"]) {\r\n    if (Array.isArray(obj[keyword])) {\r\n      for (const subSchema of obj[keyword] as unknown[]) {\r\n        stripUnsupportedProperties(subSchema);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Handle definitions/defs (JSON Schema draft-07 and later)\r\n  for (const defsKey of [\"definitions\", \"$defs\"]) {\r\n    if (obj[defsKey] && typeof obj[defsKey] === \"object\") {\r\n      for (const defSchema of Object.values(obj[defsKey] as Record<string, unknown>)) {\r\n        stripUnsupportedProperties(defSchema);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Sanitize a tool's parameter schema for OpenAI Responses API compatibility.\r\n *\r\n * OpenAI's Responses API has stricter JSON Schema validation than other providers.\r\n * This function creates a new tool with sanitized parameters that strips\r\n * unsupported schema properties like minLength, maximum, default, etc.\r\n *\r\n * Tools can have schemas in two places:\r\n * - `parameters`: Used by tools created with ai SDK's `tool()` function\r\n * - `inputSchema`: Used by MCP tools created with `dynamicTool()` from @ai-sdk/mcp\r\n *\r\n * @param tool - The original tool to sanitize\r\n * @returns A new tool with sanitized parameter schema\r\n */\r\nexport function sanitizeToolSchemaForOpenAI(tool: Tool): Tool {\r\n  // Access tool internals - the AI SDK tool structure varies:\r\n  // - Regular tools have `parameters` (Zod schema)\r\n  // - MCP/dynamic tools have `inputSchema` (JSON Schema wrapper with getter)\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  const toolRecord = tool as any as Record<string, unknown>;\r\n\r\n  // Check for inputSchema first (MCP tools use this)\r\n  // The inputSchema is a wrapper object with a jsonSchema getter\r\n  if (toolRecord.inputSchema && typeof toolRecord.inputSchema === \"object\") {\r\n    const inputSchemaWrapper = toolRecord.inputSchema as Record<string, unknown>;\r\n\r\n    // Get the actual JSON Schema - it's exposed via a getter\r\n    const rawJsonSchema = inputSchemaWrapper.jsonSchema;\r\n    if (rawJsonSchema && typeof rawJsonSchema === \"object\") {\r\n      // Deep clone and sanitize\r\n      const clonedSchema = JSON.parse(JSON.stringify(rawJsonSchema)) as Record<string, unknown>;\r\n      stripUnsupportedProperties(clonedSchema);\r\n\r\n      // Create a new inputSchema wrapper that returns our sanitized schema\r\n      const sanitizedInputSchema = {\r\n        ...inputSchemaWrapper,\r\n        // Override the jsonSchema getter with our sanitized version\r\n        get jsonSchema() {\r\n          return clonedSchema;\r\n        },\r\n      };\r\n\r\n      return {\r\n        ...tool,\r\n        inputSchema: sanitizedInputSchema,\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      } as any as Tool;\r\n    }\r\n  }\r\n\r\n  // Fall back to parameters (regular AI SDK tools)\r\n  if (!toolRecord.parameters) {\r\n    return tool;\r\n  }\r\n\r\n  // Deep clone the parameters to avoid mutating the original\r\n  const clonedParams = JSON.parse(JSON.stringify(toolRecord.parameters)) as unknown;\r\n\r\n  // Strip unsupported properties\r\n  stripUnsupportedProperties(clonedParams);\r\n\r\n  // Create a new tool with sanitized parameters\r\n  return {\r\n    ...tool,\r\n    parameters: clonedParams,\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  } as any as Tool;\r\n}\r\n\r\n/**\r\n * Sanitize all MCP tools for OpenAI compatibility.\r\n *\r\n * @param mcpTools - Record of MCP tools to sanitize\r\n * @returns Record of sanitized tools\r\n */\r\nexport function sanitizeMCPToolsForOpenAI(mcpTools: Record<string, Tool>): Record<string, Tool> {\r\n  const sanitized: Record<string, Tool> = {};\r\n  for (const [name, tool] of Object.entries(mcpTools)) {\r\n    sanitized[name] = sanitizeToolSchemaForOpenAI(tool);\r\n  }\r\n  return sanitized;\r\n}\r\n"]}