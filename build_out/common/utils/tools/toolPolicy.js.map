{"version":3,"file":"toolPolicy.js","sourceRoot":"","sources":["../../../../src/common/utils/tools/toolPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Tool } from \"ai\";\r\nimport type { z } from \"zod\";\r\nimport type { ToolPolicyFilterSchema, ToolPolicySchema } from \"@/common/orpc/schemas/stream\";\r\n\r\n/**\r\n * Filter for tool policy - determines if a tool should be enabled, disabled, or required\r\n * Inferred from ToolPolicyFilterSchema (single source of truth)\r\n */\r\nexport type ToolPolicyFilter = z.infer<typeof ToolPolicyFilterSchema>;\r\n\r\n/**\r\n * Tool policy - array of filters applied in order\r\n * Default behavior is \"allow\" (all tools enabled) for backwards compatibility\r\n * Inferred from ToolPolicySchema (single source of truth)\r\n */\r\nexport type ToolPolicy = z.infer<typeof ToolPolicySchema>;\r\n\r\n/**\r\n * Apply tool policy to filter available tools\r\n * @param tools All available tools\r\n * @param policy Optional policy to apply (default: allow all)\r\n * @returns Filtered tools based on policy\r\n *\r\n * Algorithm:\r\n * - Filters are applied in order, with default behavior \"allow all\".\r\n * - If any tool is marked as \"require\" (at most one tool may match across the whole policy),\r\n *   only that tool remains eligible. Later filters may still disable it (resulting in no tools).\r\n * - Without a required tool, enable/disable filters apply to all tools, and the last matching\r\n *   filter wins for each tool.\r\n */\r\nexport function applyToolPolicy(\r\n  tools: Record<string, Tool>,\r\n  policy?: ToolPolicy\r\n): Record<string, Tool> {\r\n  // No policy = allow all (backwards compatible)\r\n  if (!policy || policy.length === 0) {\r\n    return tools;\r\n  }\r\n\r\n  const toolNames = Object.keys(tools);\r\n\r\n  // First pass: find a single required tool (if any), validating that the policy\r\n  // never results in multiple required matches.\r\n  let requiredTool: string | null = null;\r\n  for (const filter of policy) {\r\n    if (filter.action !== \"require\") continue;\r\n\r\n    const regex = new RegExp(`^${filter.regex_match}$`);\r\n    const matches = toolNames.filter((toolName) => regex.test(toolName));\r\n\r\n    if (matches.length > 1) {\r\n      throw new Error(\r\n        `Tool policy error: Multiple tools marked as required (${matches.join(\", \")}). At most one tool can be required.`\r\n      );\r\n    }\r\n    if (matches.length === 0) continue;\r\n\r\n    if (requiredTool && requiredTool !== matches[0]) {\r\n      throw new Error(\r\n        `Tool policy error: Multiple tools marked as required (${requiredTool}, ${matches[0]}). At most one tool can be required.`\r\n      );\r\n    }\r\n    requiredTool = matches[0];\r\n  }\r\n\r\n  // If a tool is required, only that tool remains eligible, but later filters may disable it.\r\n  if (requiredTool) {\r\n    let enabled = true; // Default allow\r\n\r\n    for (const filter of policy) {\r\n      const regex = new RegExp(`^${filter.regex_match}$`);\r\n      if (!regex.test(requiredTool)) continue;\r\n\r\n      if (filter.action === \"disable\") {\r\n        enabled = false;\r\n        continue;\r\n      }\r\n      // enable/require both imply enabled for the required tool at this point in the policy\r\n      enabled = true;\r\n    }\r\n\r\n    return enabled ? { [requiredTool]: tools[requiredTool] } : {};\r\n  }\r\n\r\n  // No required tools: apply standard enable/disable logic\r\n  // Build a map of tool name -> enabled status\r\n  const toolStatus = new Map<string, boolean>();\r\n\r\n  // Initialize all tools as enabled (default allow)\r\n  for (const toolName of toolNames) {\r\n    toolStatus.set(toolName, true);\r\n  }\r\n\r\n  // Apply each filter in order (skip \"require\" actions as they were handled above)\r\n  for (const filter of policy) {\r\n    if (filter.action === \"require\") continue;\r\n\r\n    const regex = new RegExp(`^${filter.regex_match}$`);\r\n    const shouldEnable = filter.action === \"enable\";\r\n\r\n    // Apply filter to matching tools\r\n    for (const toolName of toolNames) {\r\n      if (regex.test(toolName)) {\r\n        toolStatus.set(toolName, shouldEnable);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Filter tools based on final status\r\n  const filteredTools: Record<string, Tool> = {};\r\n  for (const [toolName, tool] of Object.entries(tools)) {\r\n    if (toolStatus.get(toolName) === true) {\r\n      filteredTools[toolName] = tool;\r\n    }\r\n  }\r\n\r\n  return filteredTools;\r\n}\r\n"]}