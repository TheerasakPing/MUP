{"version":3,"file":"toolPolicy.js","sourceRoot":"","sources":["../../../../src/common/utils/tools/toolPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Tool } from \"ai\";\nimport type { z } from \"zod\";\nimport type { ToolPolicyFilterSchema, ToolPolicySchema } from \"@/common/orpc/schemas/stream\";\n\n/**\n * Filter for tool policy - determines if a tool should be enabled, disabled, or required\n * Inferred from ToolPolicyFilterSchema (single source of truth)\n */\nexport type ToolPolicyFilter = z.infer<typeof ToolPolicyFilterSchema>;\n\n/**\n * Tool policy - array of filters applied in order\n * Default behavior is \"allow\" (all tools enabled) for backwards compatibility\n * Inferred from ToolPolicySchema (single source of truth)\n */\nexport type ToolPolicy = z.infer<typeof ToolPolicySchema>;\n\n/**\n * Apply tool policy to filter available tools\n * @param tools All available tools\n * @param policy Optional policy to apply (default: allow all)\n * @returns Filtered tools based on policy\n *\n * Algorithm:\n * - Filters are applied in order, with default behavior \"allow all\".\n * - If any tool is marked as \"require\" (at most one tool may match across the whole policy),\n *   only that tool remains eligible. Later filters may still disable it (resulting in no tools).\n * - Without a required tool, enable/disable filters apply to all tools, and the last matching\n *   filter wins for each tool.\n */\nexport function applyToolPolicy(\n  tools: Record<string, Tool>,\n  policy?: ToolPolicy\n): Record<string, Tool> {\n  // No policy = allow all (backwards compatible)\n  if (!policy || policy.length === 0) {\n    return tools;\n  }\n\n  const toolNames = Object.keys(tools);\n\n  // First pass: find a single required tool (if any), validating that the policy\n  // never results in multiple required matches.\n  let requiredTool: string | null = null;\n  for (const filter of policy) {\n    if (filter.action !== \"require\") continue;\n\n    const regex = new RegExp(`^${filter.regex_match}$`);\n    const matches = toolNames.filter((toolName) => regex.test(toolName));\n\n    if (matches.length > 1) {\n      throw new Error(\n        `Tool policy error: Multiple tools marked as required (${matches.join(\", \")}). At most one tool can be required.`\n      );\n    }\n    if (matches.length === 0) continue;\n\n    if (requiredTool && requiredTool !== matches[0]) {\n      throw new Error(\n        `Tool policy error: Multiple tools marked as required (${requiredTool}, ${matches[0]}). At most one tool can be required.`\n      );\n    }\n    requiredTool = matches[0];\n  }\n\n  // If a tool is required, only that tool remains eligible, but later filters may disable it.\n  if (requiredTool) {\n    let enabled = true; // Default allow\n\n    for (const filter of policy) {\n      const regex = new RegExp(`^${filter.regex_match}$`);\n      if (!regex.test(requiredTool)) continue;\n\n      if (filter.action === \"disable\") {\n        enabled = false;\n        continue;\n      }\n      // enable/require both imply enabled for the required tool at this point in the policy\n      enabled = true;\n    }\n\n    return enabled ? { [requiredTool]: tools[requiredTool] } : {};\n  }\n\n  // No required tools: apply standard enable/disable logic\n  // Build a map of tool name -> enabled status\n  const toolStatus = new Map<string, boolean>();\n\n  // Initialize all tools as enabled (default allow)\n  for (const toolName of toolNames) {\n    toolStatus.set(toolName, true);\n  }\n\n  // Apply each filter in order (skip \"require\" actions as they were handled above)\n  for (const filter of policy) {\n    if (filter.action === \"require\") continue;\n\n    const regex = new RegExp(`^${filter.regex_match}$`);\n    const shouldEnable = filter.action === \"enable\";\n\n    // Apply filter to matching tools\n    for (const toolName of toolNames) {\n      if (regex.test(toolName)) {\n        toolStatus.set(toolName, shouldEnable);\n      }\n    }\n  }\n\n  // Filter tools based on final status\n  const filteredTools: Record<string, Tool> = {};\n  for (const [toolName, tool] of Object.entries(tools)) {\n    if (toolStatus.get(toolName) === true) {\n      filteredTools[toolName] = tool;\n    }\n  }\n\n  return filteredTools;\n}\n"]}