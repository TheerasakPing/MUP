{"version":3,"file":"secrets.js","sourceRoot":"","sources":["../../../src/common/types/secrets.ts"],"names":[],"mappings":";;;AAWA,SAAS,sBAAsB,CAAC,KAAc,EAA+B;IAC3E,OAAO,CACL,OAAO,KAAK,KAAK,QAAQ;QACzB,KAAK,KAAK,IAAI;QACd,QAAQ,IAAI,KAAK;QACjB,OAAQ,KAA8B,CAAC,MAAM,KAAK,QAAQ,CAC3D,CAAC;AAAA,CACH;AAED;;;;;;;;;GASG;AACH,yBAAgC,OAAiB,EAA0B;IACzE,kFAAkF;IAClF,MAAM,QAAQ,GAAG,IAAI,GAAG,EAA2B,CAAC;IACpD,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE,CAAC;QAC7B,sEAAsE;QACtE,IAAI,CAAC,MAAM,IAAI,OAAO,MAAM,CAAC,GAAG,KAAK,QAAQ,EAAE,CAAC;YAC9C,SAAS;QACX,CAAC;QAED,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;IACzC,CAAC;IAED,MAAM,QAAQ,GAAG,IAAI,GAAG,EAA8B,CAAC;IACvD,MAAM,SAAS,GAAG,IAAI,GAAG,EAAU,CAAC;IAEpC,MAAM,UAAU,GAAG,CAAC,GAAW,EAAsB,EAAE,CAAC;QACtD,IAAI,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;YACtB,OAAO,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC3B,CAAC;QAED,IAAI,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;YACvB,kBAAkB;YAClB,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;YAC7B,OAAO,SAAS,CAAC;QACnB,CAAC;QAED,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QACnB,IAAI,CAAC;YACH,MAAM,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAE9B,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE,CAAC;gBAC5B,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;gBACvB,OAAO,GAAG,CAAC;YACb,CAAC;YAED,IAAI,sBAAsB,CAAC,GAAG,CAAC,EAAE,CAAC;gBAChC,MAAM,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;gBACjC,IAAI,CAAC,MAAM,EAAE,CAAC;oBACZ,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;oBAC7B,OAAO,SAAS,CAAC;gBACnB,CAAC;gBAED,MAAM,KAAK,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;gBACjC,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;gBACzB,OAAO,KAAK,CAAC;YACf,CAAC;YAED,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;YAC7B,OAAO,SAAS,CAAC;QACnB,CAAC;gBAAS,CAAC;YACT,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QACxB,CAAC;IAAA,CACF,CAAC;IAEF,MAAM,MAAM,GAA2B,EAAE,CAAC;IAC1C,KAAK,MAAM,GAAG,IAAI,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC;QAClC,MAAM,KAAK,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;QAC9B,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;YACxB,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;QACtB,CAAC;IACH,CAAC;IAED,OAAO,MAAM,CAAC;AAAA,CACf","sourcesContent":["import type z from \"zod\";\nimport type { SecretSchema } from \"../orpc/schemas\";\n\nexport type Secret = z.infer<typeof SecretSchema>;\n\n/**\n * SecretsConfig - Maps project paths to their secrets\n * Format: { [projectPath: string]: Secret[] }\n */\nexport type SecretsConfig = Record<string, Secret[]>;\n\nfunction isSecretReferenceValue(value: unknown): value is { secret: string } {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"secret\" in value &&\n    typeof (value as { secret?: unknown }).secret === \"string\"\n  );\n}\n\n/**\n * Convert an array of secrets to a Record for environment variable injection.\n *\n * Secret values can either be literal strings, or aliases to other secret keys\n * (`{ secret: \"OTHER_KEY\" }`).\n *\n * Reference resolution is defensive:\n * - Missing references are omitted\n * - Cycles are omitted\n */\nexport function secretsToRecord(secrets: Secret[]): Record<string, string> {\n  // Merge-by-key (last writer wins) so lookups during resolution are deterministic.\n  const rawByKey = new Map<string, Secret[\"value\"]>();\n  for (const secret of secrets) {\n    // Defensive: avoid crashing if callers pass malformed persisted data.\n    if (!secret || typeof secret.key !== \"string\") {\n      continue;\n    }\n\n    rawByKey.set(secret.key, secret.value);\n  }\n\n  const resolved = new Map<string, string | undefined>();\n  const resolving = new Set<string>();\n\n  const resolveKey = (key: string): string | undefined => {\n    if (resolved.has(key)) {\n      return resolved.get(key);\n    }\n\n    if (resolving.has(key)) {\n      // Cycle detected.\n      resolved.set(key, undefined);\n      return undefined;\n    }\n\n    resolving.add(key);\n    try {\n      const raw = rawByKey.get(key);\n\n      if (typeof raw === \"string\") {\n        resolved.set(key, raw);\n        return raw;\n      }\n\n      if (isSecretReferenceValue(raw)) {\n        const target = raw.secret.trim();\n        if (!target) {\n          resolved.set(key, undefined);\n          return undefined;\n        }\n\n        const value = resolveKey(target);\n        resolved.set(key, value);\n        return value;\n      }\n\n      resolved.set(key, undefined);\n      return undefined;\n    } finally {\n      resolving.delete(key);\n    }\n  };\n\n  const record: Record<string, string> = {};\n  for (const key of rawByKey.keys()) {\n    const value = resolveKey(key);\n    if (value !== undefined) {\n      record[key] = value;\n    }\n  }\n\n  return record;\n}\n"]}