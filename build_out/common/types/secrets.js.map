{"version":3,"file":"secrets.js","sourceRoot":"","sources":["../../../src/common/types/secrets.ts"],"names":[],"mappings":";;;AAWA,SAAS,sBAAsB,CAAC,KAAc,EAA+B;IAC3E,OAAO,CACL,OAAO,KAAK,KAAK,QAAQ;QACzB,KAAK,KAAK,IAAI;QACd,QAAQ,IAAI,KAAK;QACjB,OAAQ,KAA8B,CAAC,MAAM,KAAK,QAAQ,CAC3D,CAAC;AAAA,CACH;AAED;;;;;;;;;GASG;AACH,yBAAgC,OAAiB,EAA0B;IACzE,kFAAkF;IAClF,MAAM,QAAQ,GAAG,IAAI,GAAG,EAA2B,CAAC;IACpD,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE,CAAC;QAC7B,sEAAsE;QACtE,IAAI,CAAC,MAAM,IAAI,OAAO,MAAM,CAAC,GAAG,KAAK,QAAQ,EAAE,CAAC;YAC9C,SAAS;QACX,CAAC;QAED,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;IACzC,CAAC;IAED,MAAM,QAAQ,GAAG,IAAI,GAAG,EAA8B,CAAC;IACvD,MAAM,SAAS,GAAG,IAAI,GAAG,EAAU,CAAC;IAEpC,MAAM,UAAU,GAAG,CAAC,GAAW,EAAsB,EAAE,CAAC;QACtD,IAAI,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;YACtB,OAAO,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC3B,CAAC;QAED,IAAI,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;YACvB,kBAAkB;YAClB,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;YAC7B,OAAO,SAAS,CAAC;QACnB,CAAC;QAED,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QACnB,IAAI,CAAC;YACH,MAAM,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAE9B,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE,CAAC;gBAC5B,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;gBACvB,OAAO,GAAG,CAAC;YACb,CAAC;YAED,IAAI,sBAAsB,CAAC,GAAG,CAAC,EAAE,CAAC;gBAChC,MAAM,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;gBACjC,IAAI,CAAC,MAAM,EAAE,CAAC;oBACZ,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;oBAC7B,OAAO,SAAS,CAAC;gBACnB,CAAC;gBAED,MAAM,KAAK,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;gBACjC,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;gBACzB,OAAO,KAAK,CAAC;YACf,CAAC;YAED,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;YAC7B,OAAO,SAAS,CAAC;QACnB,CAAC;gBAAS,CAAC;YACT,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QACxB,CAAC;IAAA,CACF,CAAC;IAEF,MAAM,MAAM,GAA2B,EAAE,CAAC;IAC1C,KAAK,MAAM,GAAG,IAAI,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC;QAClC,MAAM,KAAK,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;QAC9B,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;YACxB,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;QACtB,CAAC;IACH,CAAC;IAED,OAAO,MAAM,CAAC;AAAA,CACf","sourcesContent":["import type z from \"zod\";\r\nimport type { SecretSchema } from \"../orpc/schemas\";\r\n\r\nexport type Secret = z.infer<typeof SecretSchema>;\r\n\r\n/**\r\n * SecretsConfig - Maps project paths to their secrets\r\n * Format: { [projectPath: string]: Secret[] }\r\n */\r\nexport type SecretsConfig = Record<string, Secret[]>;\r\n\r\nfunction isSecretReferenceValue(value: unknown): value is { secret: string } {\r\n  return (\r\n    typeof value === \"object\" &&\r\n    value !== null &&\r\n    \"secret\" in value &&\r\n    typeof (value as { secret?: unknown }).secret === \"string\"\r\n  );\r\n}\r\n\r\n/**\r\n * Convert an array of secrets to a Record for environment variable injection.\r\n *\r\n * Secret values can either be literal strings, or aliases to other secret keys\r\n * (`{ secret: \"OTHER_KEY\" }`).\r\n *\r\n * Reference resolution is defensive:\r\n * - Missing references are omitted\r\n * - Cycles are omitted\r\n */\r\nexport function secretsToRecord(secrets: Secret[]): Record<string, string> {\r\n  // Merge-by-key (last writer wins) so lookups during resolution are deterministic.\r\n  const rawByKey = new Map<string, Secret[\"value\"]>();\r\n  for (const secret of secrets) {\r\n    // Defensive: avoid crashing if callers pass malformed persisted data.\r\n    if (!secret || typeof secret.key !== \"string\") {\r\n      continue;\r\n    }\r\n\r\n    rawByKey.set(secret.key, secret.value);\r\n  }\r\n\r\n  const resolved = new Map<string, string | undefined>();\r\n  const resolving = new Set<string>();\r\n\r\n  const resolveKey = (key: string): string | undefined => {\r\n    if (resolved.has(key)) {\r\n      return resolved.get(key);\r\n    }\r\n\r\n    if (resolving.has(key)) {\r\n      // Cycle detected.\r\n      resolved.set(key, undefined);\r\n      return undefined;\r\n    }\r\n\r\n    resolving.add(key);\r\n    try {\r\n      const raw = rawByKey.get(key);\r\n\r\n      if (typeof raw === \"string\") {\r\n        resolved.set(key, raw);\r\n        return raw;\r\n      }\r\n\r\n      if (isSecretReferenceValue(raw)) {\r\n        const target = raw.secret.trim();\r\n        if (!target) {\r\n          resolved.set(key, undefined);\r\n          return undefined;\r\n        }\r\n\r\n        const value = resolveKey(target);\r\n        resolved.set(key, value);\r\n        return value;\r\n      }\r\n\r\n      resolved.set(key, undefined);\r\n      return undefined;\r\n    } finally {\r\n      resolving.delete(key);\r\n    }\r\n  };\r\n\r\n  const record: Record<string, string> = {};\r\n  for (const key of rawByKey.keys()) {\r\n    const value = resolveKey(key);\r\n    if (value !== undefined) {\r\n      record[key] = value;\r\n    }\r\n  }\r\n\r\n  return record;\r\n}\r\n"]}