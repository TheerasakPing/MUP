{"version":3,"file":"message.js","sourceRoot":"","sources":["../../../src/common/types/message.ts"],"names":[],"mappings":"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","sourcesContent":["import type { UIMessage } from \"ai\";\nimport type { LanguageModelV2Usage } from \"@ai-sdk/provider\";\nimport type { StreamErrorType } from \"./errors\";\nimport type { ToolPolicy } from \"@/common/utils/tools/toolPolicy\";\nimport type { FilePart, MuxToolPartSchema } from \"@/common/orpc/schemas\";\nimport type { SendMessageOptions } from \"@/common/orpc/types\";\nimport type { z } from \"zod\";\nimport type { AgentMode } from \"./mode\";\nimport type { AgentSkillScope } from \"./agentSkill\";\nimport type { ThinkingLevel } from \"./thinking\";\nimport { type ReviewNoteData, formatReviewForModel } from \"./review\";\n\n/**\n * Review data stored in message metadata for display.\n * Alias for ReviewNoteData - they have identical shape.\n */\nexport type ReviewNoteDataForDisplay = ReviewNoteData;\n\n/**\n * Content that a user wants to send in a message.\n * Shared between normal send and continue-after-compaction to ensure\n * both paths handle the same fields (text, attachments, reviews).\n */\nexport interface UserMessageContent {\n  text: string;\n  fileParts?: FilePart[];\n  /** Review data - formatted into message text AND stored in metadata for display */\n  reviews?: ReviewNoteDataForDisplay[];\n}\n\n/**\n * Input for follow-up content - what call sites provide when triggering compaction.\n * Does not include model/agentId since those come from sendMessageOptions.\n */\nexport interface CompactionFollowUpInput extends UserMessageContent {\n  /** Frontend metadata to apply to the queued follow-up user message (e.g., preserve /skill display) */\n  muxMetadata?: MuxFrontendMetadata;\n}\n\n/**\n * SendMessageOptions fields that should be preserved across compaction.\n * These affect how the follow-up message is processed (thinking level, system instructions, etc.)\n * and should use the user's original settings, not compaction defaults.\n */\ntype PreservedSendOptions = Pick<\n  SendMessageOptions,\n  | \"thinkingLevel\"\n  | \"additionalSystemInstructions\"\n  | \"providerOptions\"\n  | \"experiments\"\n  | \"disableWorkspaceAgents\"\n>;\n\n/**\n * Extract the send options that should be preserved across compaction.\n * Use this helper to avoid duplicating the field list when building CompactionFollowUpRequest.\n */\nexport function pickPreservedSendOptions(options: SendMessageOptions): PreservedSendOptions {\n  return {\n    thinkingLevel: options.thinkingLevel,\n    additionalSystemInstructions: options.additionalSystemInstructions,\n    providerOptions: options.providerOptions,\n    experiments: options.experiments,\n    disableWorkspaceAgents: options.disableWorkspaceAgents,\n  };\n}\n\n/**\n * Content to send after compaction completes.\n * Extends CompactionFollowUpInput with model/agentId for the follow-up message,\n * plus preserved send options so the follow-up uses the same settings as the\n * original user message.\n *\n * These fields are required because compaction uses its own agentId (\"compact\")\n * and potentially a different model for summarization. The follow-up message\n * should use the user's original model, agentId, and send options.\n *\n * Call sites provide CompactionFollowUpInput; prepareCompactionMessage converts\n * it to CompactionFollowUpRequest by adding model/agentId/options from sendMessageOptions.\n */\nexport interface CompactionFollowUpRequest extends CompactionFollowUpInput, PreservedSendOptions {\n  /** Model to use for the follow-up message (user's original model, not compaction model) */\n  model: string;\n  /** Agent ID for the follow-up message (user's original agentId, not \"compact\") */\n  agentId: string;\n}\n\n/**\n * Brand symbol for ContinueMessage - ensures it can only be created via factory functions.\n * This prevents bugs where code manually constructs { text: \"...\" } and forgets fields.\n */\ndeclare const ContinueMessageBrand: unique symbol;\n\n/**\n * Message to continue with after compaction.\n * Branded type - must be created via buildContinueMessage() or rebuildContinueMessage().\n */\nexport type ContinueMessage = UserMessageContent & {\n  model?: string;\n  /** Agent ID for the continue message (determines tool policy via agent definitions). Defaults to 'exec'. */\n  agentId?: string;\n  /** Frontend metadata to apply to the queued follow-up user message (e.g., preserve /skill display) */\n  muxMetadata?: MuxFrontendMetadata;\n  /** Brand marker - not present at runtime, enforces factory usage at compile time */\n  readonly [ContinueMessageBrand]: true;\n};\n\n/**\n * Input options for building a ContinueMessage.\n * All content fields optional - returns undefined if no content provided.\n */\nexport interface BuildContinueMessageOptions {\n  text?: string;\n  fileParts?: FilePart[];\n  reviews?: ReviewNoteDataForDisplay[];\n  /** Optional frontend metadata to carry through to the queued follow-up user message */\n  muxMetadata?: MuxFrontendMetadata;\n  model: string;\n  agentId: string;\n}\n\n/**\n * Build a ContinueMessage from raw inputs.\n * Centralizes the has-content check and field construction.\n *\n * @returns ContinueMessage if there's content to continue with, undefined otherwise\n */\nexport function buildContinueMessage(\n  opts: BuildContinueMessageOptions\n): ContinueMessage | undefined {\n  const hasText = opts.text && opts.text.length > 0;\n  const hasFiles = opts.fileParts && opts.fileParts.length > 0;\n  const hasReviews = opts.reviews && opts.reviews.length > 0;\n  if (!hasText && !hasFiles && !hasReviews) return undefined;\n\n  // Type assertion is safe here - this is the only factory for ContinueMessage\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  const result: ContinueMessage = {\n    text: opts.text ?? \"\",\n    fileParts: opts.fileParts,\n    reviews: opts.reviews,\n    muxMetadata: opts.muxMetadata,\n    model: opts.model,\n    agentId: opts.agentId,\n  } as ContinueMessage;\n  return result;\n}\n\n/**\n * Persisted ContinueMessage shape - what we read from storage/history.\n * May be missing fields if saved by older code versions.\n */\nexport type PersistedContinueMessage = Partial<\n  Omit<ContinueMessage, typeof ContinueMessageBrand>\n> & {\n  /** @deprecated Legacy base mode persisted in older history entries. */\n  mode?: AgentMode;\n};\n\n/**\n * True when the content is the default resume sentinel (\"Continue\")\n * with no attachments.\n */\nexport function isDefaultSourceContent(content?: Partial<UserMessageContent>): boolean {\n  if (!content) return false;\n  const text = typeof content.text === \"string\" ? content.text.trim() : \"\";\n  const hasFiles = (content.fileParts?.length ?? 0) > 0;\n  const hasReviews = (content.reviews?.length ?? 0) > 0;\n  return text === \"Continue\" && !hasFiles && !hasReviews;\n}\n\n/**\n * Rebuild a ContinueMessage from persisted data.\n * Use this when reading from storage/history where the data may have been\n * saved by older code that didn't include all fields.\n *\n * @param persisted - Data from storage (may be partial)\n * @param defaults - Default values for model/mode if not in persisted data\n * @returns Branded ContinueMessage, or undefined if no content\n */\nexport function rebuildContinueMessage(\n  persisted: PersistedContinueMessage | undefined,\n  defaults: { model: string; agentId: string }\n): ContinueMessage | undefined {\n  if (!persisted) return undefined;\n\n  const persistedAgentId =\n    typeof persisted.agentId === \"string\" && persisted.agentId.trim().length > 0\n      ? persisted.agentId.trim()\n      : undefined;\n\n  const legacyMode = (persisted as { mode?: unknown }).mode;\n  const legacyAgentId = legacyMode === \"plan\" || legacyMode === \"exec\" ? legacyMode : undefined;\n\n  return buildContinueMessage({\n    text: persisted.text,\n    fileParts: persisted.fileParts,\n    reviews: persisted.reviews,\n    muxMetadata: persisted.muxMetadata,\n    model: persisted.model ?? defaults.model,\n    agentId: persistedAgentId ?? legacyAgentId ?? defaults.agentId,\n  });\n}\n\n// Parsed compaction request data (shared type for consistency)\nexport interface CompactionRequestData {\n  model?: string; // Custom model override for compaction\n  maxOutputTokens?: number;\n  /** Content to send after compaction completes. Backend binds model/agentId at send time. */\n  followUpContent?: CompactionFollowUpRequest;\n}\n\n/**\n * Process UserMessageContent into final message text and metadata.\n * Used by both normal send path and backend continue message processing.\n *\n * @param content - The user message content (text, attachments, reviews)\n * @param existingMetadata - Optional existing metadata to merge with (e.g., for compaction messages)\n * @returns Object with finalText (reviews prepended) and metadata (reviews for display)\n */\nexport function prepareUserMessageForSend(\n  content: UserMessageContent,\n  existingMetadata?: MuxFrontendMetadata\n): {\n  finalText: string;\n  metadata: MuxFrontendMetadata | undefined;\n} {\n  const { text, reviews } = content;\n\n  // Format reviews into message text\n  const reviewsText = reviews?.length ? reviews.map(formatReviewForModel).join(\"\\n\\n\") : \"\";\n  const finalText = reviewsText ? reviewsText + (text ? \"\\n\\n\" + text : \"\") : text;\n\n  // Build metadata with reviews for display\n  let metadata: MuxFrontendMetadata | undefined = existingMetadata;\n  if (reviews?.length) {\n    metadata = metadata ? { ...metadata, reviews } : { type: \"normal\", reviews };\n  }\n\n  return { finalText, metadata };\n}\n\nexport interface BuildAgentSkillMetadataOptions {\n  rawCommand: string;\n  skillName: string;\n  scope: AgentSkillScope;\n  commandPrefix?: string;\n}\n\nexport function buildAgentSkillMetadata(\n  options: BuildAgentSkillMetadataOptions\n): MuxFrontendMetadata {\n  return {\n    type: \"agent-skill\",\n    rawCommand: options.rawCommand,\n    commandPrefix: options.commandPrefix,\n    skillName: options.skillName,\n    scope: options.scope,\n  };\n}\n\n/** Base fields common to all metadata types */\ninterface MuxFrontendMetadataBase {\n  /** Structured review data for rich UI display (orthogonal to message type) */\n  reviews?: ReviewNoteDataForDisplay[];\n  /** Command prefix to highlight in UI (e.g., \"/compact -m sonnet\" or \"/react-effects\") */\n  commandPrefix?: string;\n  /**\n   * Model used for the pending send (UI-only).\n   *\n   * We stash this so the \"starting\" label reflects the actual model for one-shot\n   * and compaction sends instead of whatever happens to be persisted in localStorage.\n   */\n  requestedModel?: string;\n}\n\n/** Status to display in sidebar during background operations */\nexport interface DisplayStatus {\n  emoji: string;\n  message: string;\n}\n\nexport type MuxFrontendMetadata = MuxFrontendMetadataBase &\n  (\n    | {\n        type: \"compaction-request\";\n        rawCommand: string; // The original /compact command as typed by user (for display)\n        parsed: CompactionRequestData;\n        /** Source of compaction request: user-initiated (undefined) or idle-compaction (auto) */\n        source?: \"idle-compaction\";\n        /** Transient status to display in sidebar during this operation */\n        displayStatus?: DisplayStatus;\n      }\n    | {\n        type: \"compaction-summary\";\n        /**\n         * Follow-up content to dispatch after compaction completes.\n         * Stored on the summary so it survives crashes - the user message\n         * persisted by dispatch serves as proof of completion.\n         */\n        pendingFollowUp?: CompactionFollowUpRequest;\n      }\n    | {\n        type: \"agent-skill\";\n        /** The original /{skillName} invocation as typed by user (for display) */\n        rawCommand: string;\n        skillName: string;\n        scope: \"project\" | \"global\" | \"built-in\";\n      }\n    | {\n        type: \"plan-display\"; // Ephemeral plan display from /plan command\n        path: string;\n      }\n    | {\n        type: \"normal\"; // Regular messages\n        /** Original user input for one-shot overrides (e.g., \"/opus+high do something\") â€” used as display content so the command prefix remains visible. */\n        rawCommand?: string;\n      }\n  );\n\nexport function getCompactionFollowUpContent(\n  metadata?: MuxFrontendMetadata\n): CompactionRequestData[\"followUpContent\"] | undefined {\n  // Keep follow-up extraction centralized so callers don't duplicate legacy handling.\n  if (!metadata || metadata.type !== \"compaction-request\") {\n    return undefined;\n  }\n\n  // Legacy compaction requests stored follow-up content in `continueMessage`.\n  const parsed = metadata.parsed as CompactionRequestData & {\n    continueMessage?: CompactionRequestData[\"followUpContent\"];\n  };\n  return parsed.followUpContent ?? parsed.continueMessage;\n}\n\n/** Type for compaction-summary metadata variant */\nexport type CompactionSummaryMetadata = Extract<\n  MuxFrontendMetadata,\n  { type: \"compaction-summary\" }\n>;\n\n/** Type guard for compaction-summary metadata */\nexport function isCompactionSummaryMetadata(\n  metadata: MuxFrontendMetadata | undefined\n): metadata is CompactionSummaryMetadata {\n  return metadata?.type === \"compaction-summary\";\n}\n\n// Our custom metadata type\nexport interface MuxMetadata {\n  historySequence?: number; // Assigned by backend for global message ordering (required when writing to history)\n  duration?: number;\n  /** @deprecated Legacy base mode derived from agent definition. */\n  mode?: AgentMode;\n  timestamp?: number;\n  model?: string;\n  /** Effective thinking/reasoning level used for this response (after model policy clamping). */\n  thinkingLevel?: ThinkingLevel;\n  /** True when this response was routed through Mux Gateway (model stays canonical). */\n  routedThroughGateway?: boolean;\n  /**\n   * True when usage costs are included in a subscription (e.g., ChatGPT subscription routing).\n   * Token counts are still tracked, but the UI should display costs as $0.\n   */\n  costsIncluded?: boolean;\n  // Total usage across all steps (for cost calculation)\n  usage?: LanguageModelV2Usage;\n  // Last step's usage only (for context window display - inputTokens = current context size)\n  contextUsage?: LanguageModelV2Usage;\n  // Aggregated provider metadata across all steps (for cost calculation)\n  providerMetadata?: Record<string, unknown>;\n  // Last step's provider metadata (for context window cache display)\n  contextProviderMetadata?: Record<string, unknown>;\n  systemMessageTokens?: number; // Token count for system message sent with this request (calculated by AIService)\n  partial?: boolean; // Whether this message was interrupted and is incomplete\n  synthetic?: boolean; // Whether this message was synthetically generated (e.g., [CONTINUE] sentinel)\n  /**\n   * UI hint: show in the chat UI even when synthetic.\n   *\n   * Synthetic messages are hidden by default because most are for model context only.\n   * Set this flag for synthetic notices that should be visible to users.\n   */\n  uiVisible?: boolean;\n  error?: string; // Error message if stream failed\n  errorType?: StreamErrorType; // Error type/category if stream failed\n  // Compaction source: \"user\" (manual /compact), \"idle\" (auto-triggered), or legacy boolean `true`\n  // Readers should use helper: isCompacted = compacted !== undefined && compacted !== false\n  compacted?: \"user\" | \"idle\" | boolean;\n  /**\n   * Monotonic compaction epoch identifier.\n   *\n   * Legacy histories may omit this; compaction code backfills by counting historical compacted summaries.\n   */\n  compactionEpoch?: number;\n  /**\n   * Durable boundary marker for compaction summaries.\n   *\n   * This lets downstream logic identify compaction boundaries without mutating history.\n   */\n  compactionBoundary?: boolean;\n  toolPolicy?: ToolPolicy; // Tool policy active when this message was sent (user messages only)\n  agentId?: string; // Agent id active when this message was sent (assistant messages only)\n  cmuxMetadata?: MuxFrontendMetadata; // Frontend-defined metadata, backend treats as black-box\n  muxMetadata?: MuxFrontendMetadata; // Frontend-defined metadata, backend treats as black-box\n  /**\n   * @file mention snapshot token(s) this message provides content for.\n   * When present, injectFileAtMentions() skips re-reading these tokens,\n   * preserving prompt cache stability across turns.\n   */\n  fileAtMentionSnapshot?: string[];\n\n  /**\n   * Agent skill snapshot metadata for synthetic messages that inject skill bodies.\n   */\n  agentSkillSnapshot?: {\n    skillName: string;\n    scope: AgentSkillScope;\n    sha256: string;\n    /**\n     * YAML frontmatter for the resolved skill (no `---` delimiters).\n     * Optional for backwards compatibility with older histories.\n     */\n    frontmatterYaml?: string;\n  };\n}\n\n// Extended tool part type that supports interrupted tool calls (input-available state)\n// Standard AI SDK ToolUIPart only supports output-available (completed tools)\n// Uses discriminated union: output is required when state is \"output-available\", absent when \"input-available\"\nexport type MuxToolPart = z.infer<typeof MuxToolPartSchema>;\n\n// Text part type\nexport interface MuxTextPart {\n  type: \"text\";\n  text: string;\n  timestamp?: number;\n}\n\n// Reasoning part type for extended thinking content\nexport interface MuxReasoningPart {\n  type: \"reasoning\";\n  text: string;\n  timestamp?: number;\n  /**\n   * Anthropic thinking block signature for replay.\n   * Required to send reasoning back to Anthropic - the API validates signatures\n   * to ensure thinking blocks haven't been tampered with. Reasoning without\n   * signatures will be stripped before sending to avoid \"empty content\" errors.\n   */\n  signature?: string;\n  /**\n   * Provider options for SDK compatibility.\n   * When converting to ModelMessages via the SDK's convertToModelMessages,\n   * this is passed through. For Anthropic thinking blocks, this should contain\n   * { anthropic: { signature } } to allow reasoning replay.\n   */\n  providerOptions?: {\n    anthropic?: {\n      signature?: string;\n    };\n  };\n}\n\n// File part type for multimodal messages (matches AI SDK FileUIPart)\nexport interface MuxFilePart {\n  type: \"file\";\n  mediaType: string; // IANA media type, e.g., \"image/png\", \"application/pdf\"\n  url: string; // Data URL (e.g., \"data:application/pdf;base64,...\") or hosted URL\n  filename?: string; // Optional filename\n}\n\n// MuxMessage extends UIMessage with our metadata and custom parts\n// Supports text, reasoning, file, and tool parts (including interrupted tool calls)\nexport type MuxMessage = Omit<UIMessage<MuxMetadata, never, never>, \"parts\"> & {\n  parts: Array<MuxTextPart | MuxReasoningPart | MuxFilePart | MuxToolPart>;\n};\n\n// DisplayedMessage represents a single UI message block\n// This is what the UI components consume, splitting complex messages into separate visual blocks\nexport type DisplayedMessage =\n  | {\n      type: \"user\";\n      id: string; // Display ID for UI/React keys\n      historyId: string; // Original MuxMessage ID for history operations\n      content: string;\n      /**\n       * Command prefix to highlight in the UI (e.g. \"/compact -m sonnet\" or \"/react-effects\").\n       * Only set when a slash command was processed.\n       */\n      commandPrefix?: string;\n      fileParts?: FilePart[]; // Optional attachments\n      historySequence: number; // Global ordering across all messages\n      isSynthetic?: boolean;\n      timestamp?: number;\n      /** Present when this message invoked an agent skill via /{skill-name} */\n      agentSkill?: {\n        skillName: string;\n        scope: AgentSkillScope;\n        /**\n         * Optional snapshot content attached later by message aggregation (e.g. tooltips).\n         * Not persisted on the user message itself.\n         */\n        snapshot?: {\n          frontmatterYaml?: string;\n          body?: string;\n        };\n      };\n      /** Present when this message is a /compact command */\n      compactionRequest?: {\n        parsed: CompactionRequestData;\n      };\n      /** Structured review data for rich UI display (from muxMetadata) */\n      reviews?: ReviewNoteDataForDisplay[];\n    }\n  | {\n      type: \"assistant\";\n      id: string; // Display ID for UI/React keys\n      historyId: string; // Original MuxMessage ID for history operations\n      content: string;\n      historySequence: number; // Global ordering across all messages\n      streamSequence?: number; // Local ordering within this assistant message\n      isStreaming: boolean;\n      isPartial: boolean; // Whether this message was interrupted\n      isLastPartOfMessage?: boolean; // True if this is the last part of a multi-part message\n      isCompacted: boolean; // Whether this is a compacted summary\n      isIdleCompacted: boolean; // Whether this compaction was auto-triggered due to inactivity\n      model?: string;\n      routedThroughGateway?: boolean;\n      agentId?: string; // Agent id active when this message was sent (assistant messages only)\n      /** @deprecated Legacy base mode derived from agent definition. */\n      mode?: AgentMode;\n      timestamp?: number;\n      tokens?: number;\n    }\n  | {\n      type: \"tool\";\n      id: string; // Display ID for UI/React keys\n      historyId: string; // Original MuxMessage ID for history operations\n      toolCallId: string;\n      toolName: string;\n      args: unknown;\n      result?: unknown;\n      status: \"pending\" | \"executing\" | \"completed\" | \"failed\" | \"interrupted\" | \"redacted\";\n      isPartial: boolean; // Whether the parent message was interrupted\n      historySequence: number; // Global ordering across all messages\n      streamSequence?: number; // Local ordering within this assistant message\n      isLastPartOfMessage?: boolean; // True if this is the last part of a multi-part message\n      timestamp?: number;\n      // Nested tool calls for code_execution (from PTC streaming or reconstructed from result)\n      nestedCalls?: Array<{\n        toolCallId: string;\n        toolName: string;\n        input: unknown;\n        output?: unknown;\n        state: \"input-available\" | \"output-available\" | \"output-redacted\";\n        timestamp?: number;\n      }>;\n    }\n  | {\n      type: \"reasoning\";\n      id: string; // Display ID for UI/React keys\n      historyId: string; // Original MuxMessage ID for history operations\n      content: string;\n      historySequence: number; // Global ordering across all messages\n      streamSequence?: number; // Local ordering within this assistant message\n      isStreaming: boolean;\n      isPartial: boolean; // Whether the parent message was interrupted\n      isLastPartOfMessage?: boolean; // True if this is the last part of a multi-part message\n      timestamp?: number;\n      tokens?: number; // Reasoning tokens if available\n    }\n  | {\n      type: \"stream-error\";\n      id: string; // Display ID for UI/React keys\n      historyId: string; // Original MuxMessage ID for history operations\n      error: string; // Error message\n      errorType: StreamErrorType; // Error type/category\n      historySequence: number; // Global ordering across all messages\n      timestamp?: number;\n      model?: string;\n      routedThroughGateway?: boolean;\n      errorCount?: number; // Number of consecutive identical errors merged into this message\n    }\n  | {\n      type: \"compaction-boundary\";\n      id: string; // Display ID for UI/React keys\n      historySequence: number; // Sequence of the compaction summary this boundary belongs to\n      position: \"start\" | \"end\";\n      compactionEpoch?: number;\n    }\n  | {\n      type: \"history-hidden\";\n      id: string; // Display ID for UI/React keys\n      hiddenCount: number; // Number of messages hidden\n      historySequence: number; // Global ordering across all messages\n      /** Breakdown of omitted message types (when truncating for performance). */\n      omittedMessageCounts?: {\n        tool: number;\n        reasoning: number;\n      };\n    }\n  | {\n      type: \"workspace-init\";\n      id: string; // Display ID for UI/React keys\n      historySequence: number; // Position in message stream (-1 for ephemeral, non-persisted events)\n      status: \"running\" | \"success\" | \"error\";\n      hookPath: string; // Path to the init script being executed\n      lines: Array<{ line: string; isError: boolean }>; // Accumulated output lines (stderr tagged via isError)\n      exitCode: number | null; // Final exit code (null while running)\n      timestamp: number;\n      durationMs: number | null; // Duration in milliseconds (null while running)\n      truncatedLines?: number; // Number of lines dropped from middle when output was too long\n    }\n  | {\n      type: \"plan-display\"; // Ephemeral plan display from /plan command\n      id: string; // Display ID for UI/React keys\n      historyId: string; // Original MuxMessage ID (same as id for ephemeral messages)\n      content: string; // Plan markdown content\n      path: string; // Path to the plan file\n      historySequence: number; // Global ordering across all messages\n    };\n\n/** Convenience type alias for user-role DisplayedMessage */\nexport type DisplayedUserMessage = Extract<DisplayedMessage, { type: \"user\" }>;\n\nexport interface QueuedMessage {\n  id: string;\n  content: string;\n  fileParts?: FilePart[];\n  /** Structured review data for rich UI display (from muxMetadata) */\n  reviews?: ReviewNoteDataForDisplay[];\n  /** True when the queued message is a compaction request (/compact) */\n  hasCompactionRequest?: boolean;\n}\n\n// Helper to create a simple text message\nexport function createMuxMessage(\n  id: string,\n  role: \"user\" | \"assistant\",\n  content: string,\n  metadata?: MuxMetadata,\n  additionalParts?: MuxMessage[\"parts\"]\n): MuxMessage {\n  const textPart = content\n    ? [{ type: \"text\" as const, text: content, state: \"done\" as const }]\n    : [];\n  const parts = [...textPart, ...(additionalParts ?? [])];\n\n  // Validation: User messages must have at least one part with content\n  // This prevents empty user messages from being created (defense-in-depth)\n  if (role === \"user\" && parts.length === 0) {\n    throw new Error(\n      \"Cannot create user message with no parts. Empty messages should be rejected upstream.\"\n    );\n  }\n\n  return {\n    id,\n    role,\n    metadata,\n    parts,\n  };\n}\n"]}