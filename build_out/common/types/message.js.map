{"version":3,"file":"message.js","sourceRoot":"","sources":["../../../src/common/types/message.ts"],"names":[],"mappings":"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","sourcesContent":["import type { UIMessage } from \"ai\";\r\nimport type { LanguageModelV2Usage } from \"@ai-sdk/provider\";\r\nimport type { StreamErrorType } from \"./errors\";\r\nimport type { ToolPolicy } from \"@/common/utils/tools/toolPolicy\";\r\nimport type { FilePart, MuxToolPartSchema } from \"@/common/orpc/schemas\";\r\nimport type { SendMessageOptions } from \"@/common/orpc/types\";\r\nimport type { z } from \"zod\";\r\nimport type { AgentMode } from \"./mode\";\r\nimport type { AgentSkillScope } from \"./agentSkill\";\r\nimport type { ThinkingLevel } from \"./thinking\";\r\nimport { type ReviewNoteData, formatReviewForModel } from \"./review\";\r\n\r\n/**\r\n * Review data stored in message metadata for display.\r\n * Alias for ReviewNoteData - they have identical shape.\r\n */\r\nexport type ReviewNoteDataForDisplay = ReviewNoteData;\r\n\r\n/**\r\n * Content that a user wants to send in a message.\r\n * Shared between normal send and continue-after-compaction to ensure\r\n * both paths handle the same fields (text, attachments, reviews).\r\n */\r\nexport interface UserMessageContent {\r\n  text: string;\r\n  fileParts?: FilePart[];\r\n  /** Review data - formatted into message text AND stored in metadata for display */\r\n  reviews?: ReviewNoteDataForDisplay[];\r\n}\r\n\r\n/**\r\n * Input for follow-up content - what call sites provide when triggering compaction.\r\n * Does not include model/agentId since those come from sendMessageOptions.\r\n */\r\nexport interface CompactionFollowUpInput extends UserMessageContent {\r\n  /** Frontend metadata to apply to the queued follow-up user message (e.g., preserve /skill display) */\r\n  muxMetadata?: MuxFrontendMetadata;\r\n}\r\n\r\n/**\r\n * SendMessageOptions fields that should be preserved across compaction.\r\n * These affect how the follow-up message is processed (thinking level, system instructions, etc.)\r\n * and should use the user's original settings, not compaction defaults.\r\n */\r\ntype PreservedSendOptions = Pick<\r\n  SendMessageOptions,\r\n  | \"thinkingLevel\"\r\n  | \"additionalSystemInstructions\"\r\n  | \"providerOptions\"\r\n  | \"experiments\"\r\n  | \"disableWorkspaceAgents\"\r\n>;\r\n\r\n/**\r\n * Extract the send options that should be preserved across compaction.\r\n * Use this helper to avoid duplicating the field list when building CompactionFollowUpRequest.\r\n */\r\nexport function pickPreservedSendOptions(options: SendMessageOptions): PreservedSendOptions {\r\n  return {\r\n    thinkingLevel: options.thinkingLevel,\r\n    additionalSystemInstructions: options.additionalSystemInstructions,\r\n    providerOptions: options.providerOptions,\r\n    experiments: options.experiments,\r\n    disableWorkspaceAgents: options.disableWorkspaceAgents,\r\n  };\r\n}\r\n\r\n/**\r\n * Content to send after compaction completes.\r\n * Extends CompactionFollowUpInput with model/agentId for the follow-up message,\r\n * plus preserved send options so the follow-up uses the same settings as the\r\n * original user message.\r\n *\r\n * These fields are required because compaction uses its own agentId (\"compact\")\r\n * and potentially a different model for summarization. The follow-up message\r\n * should use the user's original model, agentId, and send options.\r\n *\r\n * Call sites provide CompactionFollowUpInput; prepareCompactionMessage converts\r\n * it to CompactionFollowUpRequest by adding model/agentId/options from sendMessageOptions.\r\n */\r\nexport interface CompactionFollowUpRequest extends CompactionFollowUpInput, PreservedSendOptions {\r\n  /** Model to use for the follow-up message (user's original model, not compaction model) */\r\n  model: string;\r\n  /** Agent ID for the follow-up message (user's original agentId, not \"compact\") */\r\n  agentId: string;\r\n}\r\n\r\n/**\r\n * Brand symbol for ContinueMessage - ensures it can only be created via factory functions.\r\n * This prevents bugs where code manually constructs { text: \"...\" } and forgets fields.\r\n */\r\ndeclare const ContinueMessageBrand: unique symbol;\r\n\r\n/**\r\n * Message to continue with after compaction.\r\n * Branded type - must be created via buildContinueMessage() or rebuildContinueMessage().\r\n */\r\nexport type ContinueMessage = UserMessageContent & {\r\n  model?: string;\r\n  /** Agent ID for the continue message (determines tool policy via agent definitions). Defaults to 'exec'. */\r\n  agentId?: string;\r\n  /** Frontend metadata to apply to the queued follow-up user message (e.g., preserve /skill display) */\r\n  muxMetadata?: MuxFrontendMetadata;\r\n  /** Brand marker - not present at runtime, enforces factory usage at compile time */\r\n  readonly [ContinueMessageBrand]: true;\r\n};\r\n\r\n/**\r\n * Input options for building a ContinueMessage.\r\n * All content fields optional - returns undefined if no content provided.\r\n */\r\nexport interface BuildContinueMessageOptions {\r\n  text?: string;\r\n  fileParts?: FilePart[];\r\n  reviews?: ReviewNoteDataForDisplay[];\r\n  /** Optional frontend metadata to carry through to the queued follow-up user message */\r\n  muxMetadata?: MuxFrontendMetadata;\r\n  model: string;\r\n  agentId: string;\r\n}\r\n\r\n/**\r\n * Build a ContinueMessage from raw inputs.\r\n * Centralizes the has-content check and field construction.\r\n *\r\n * @returns ContinueMessage if there's content to continue with, undefined otherwise\r\n */\r\nexport function buildContinueMessage(\r\n  opts: BuildContinueMessageOptions\r\n): ContinueMessage | undefined {\r\n  const hasText = opts.text && opts.text.length > 0;\r\n  const hasFiles = opts.fileParts && opts.fileParts.length > 0;\r\n  const hasReviews = opts.reviews && opts.reviews.length > 0;\r\n  if (!hasText && !hasFiles && !hasReviews) return undefined;\r\n\r\n  // Type assertion is safe here - this is the only factory for ContinueMessage\r\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\r\n  const result: ContinueMessage = {\r\n    text: opts.text ?? \"\",\r\n    fileParts: opts.fileParts,\r\n    reviews: opts.reviews,\r\n    muxMetadata: opts.muxMetadata,\r\n    model: opts.model,\r\n    agentId: opts.agentId,\r\n  } as ContinueMessage;\r\n  return result;\r\n}\r\n\r\n/**\r\n * Persisted ContinueMessage shape - what we read from storage/history.\r\n * May be missing fields if saved by older code versions.\r\n */\r\nexport type PersistedContinueMessage = Partial<\r\n  Omit<ContinueMessage, typeof ContinueMessageBrand>\r\n> & {\r\n  /** @deprecated Legacy base mode persisted in older history entries. */\r\n  mode?: AgentMode;\r\n};\r\n\r\n/**\r\n * True when the content is the default resume sentinel (\"Continue\")\r\n * with no attachments.\r\n */\r\nexport function isDefaultSourceContent(content?: Partial<UserMessageContent>): boolean {\r\n  if (!content) return false;\r\n  const text = typeof content.text === \"string\" ? content.text.trim() : \"\";\r\n  const hasFiles = (content.fileParts?.length ?? 0) > 0;\r\n  const hasReviews = (content.reviews?.length ?? 0) > 0;\r\n  return text === \"Continue\" && !hasFiles && !hasReviews;\r\n}\r\n\r\n/**\r\n * Rebuild a ContinueMessage from persisted data.\r\n * Use this when reading from storage/history where the data may have been\r\n * saved by older code that didn't include all fields.\r\n *\r\n * @param persisted - Data from storage (may be partial)\r\n * @param defaults - Default values for model/mode if not in persisted data\r\n * @returns Branded ContinueMessage, or undefined if no content\r\n */\r\nexport function rebuildContinueMessage(\r\n  persisted: PersistedContinueMessage | undefined,\r\n  defaults: { model: string; agentId: string }\r\n): ContinueMessage | undefined {\r\n  if (!persisted) return undefined;\r\n\r\n  const persistedAgentId =\r\n    typeof persisted.agentId === \"string\" && persisted.agentId.trim().length > 0\r\n      ? persisted.agentId.trim()\r\n      : undefined;\r\n\r\n  const legacyMode = (persisted as { mode?: unknown }).mode;\r\n  const legacyAgentId = legacyMode === \"plan\" || legacyMode === \"exec\" ? legacyMode : undefined;\r\n\r\n  return buildContinueMessage({\r\n    text: persisted.text,\r\n    fileParts: persisted.fileParts,\r\n    reviews: persisted.reviews,\r\n    muxMetadata: persisted.muxMetadata,\r\n    model: persisted.model ?? defaults.model,\r\n    agentId: persistedAgentId ?? legacyAgentId ?? defaults.agentId,\r\n  });\r\n}\r\n\r\n// Parsed compaction request data (shared type for consistency)\r\nexport interface CompactionRequestData {\r\n  model?: string; // Custom model override for compaction\r\n  maxOutputTokens?: number;\r\n  /** Content to send after compaction completes. Backend binds model/agentId at send time. */\r\n  followUpContent?: CompactionFollowUpRequest;\r\n}\r\n\r\n/**\r\n * Process UserMessageContent into final message text and metadata.\r\n * Used by both normal send path and backend continue message processing.\r\n *\r\n * @param content - The user message content (text, attachments, reviews)\r\n * @param existingMetadata - Optional existing metadata to merge with (e.g., for compaction messages)\r\n * @returns Object with finalText (reviews prepended) and metadata (reviews for display)\r\n */\r\nexport function prepareUserMessageForSend(\r\n  content: UserMessageContent,\r\n  existingMetadata?: MuxFrontendMetadata\r\n): {\r\n  finalText: string;\r\n  metadata: MuxFrontendMetadata | undefined;\r\n} {\r\n  const { text, reviews } = content;\r\n\r\n  // Format reviews into message text\r\n  const reviewsText = reviews?.length ? reviews.map(formatReviewForModel).join(\"\\n\\n\") : \"\";\r\n  const finalText = reviewsText ? reviewsText + (text ? \"\\n\\n\" + text : \"\") : text;\r\n\r\n  // Build metadata with reviews for display\r\n  let metadata: MuxFrontendMetadata | undefined = existingMetadata;\r\n  if (reviews?.length) {\r\n    metadata = metadata ? { ...metadata, reviews } : { type: \"normal\", reviews };\r\n  }\r\n\r\n  return { finalText, metadata };\r\n}\r\n\r\nexport interface BuildAgentSkillMetadataOptions {\r\n  rawCommand: string;\r\n  skillName: string;\r\n  scope: AgentSkillScope;\r\n  commandPrefix?: string;\r\n}\r\n\r\nexport function buildAgentSkillMetadata(\r\n  options: BuildAgentSkillMetadataOptions\r\n): MuxFrontendMetadata {\r\n  return {\r\n    type: \"agent-skill\",\r\n    rawCommand: options.rawCommand,\r\n    commandPrefix: options.commandPrefix,\r\n    skillName: options.skillName,\r\n    scope: options.scope,\r\n  };\r\n}\r\n\r\n/** Base fields common to all metadata types */\r\ninterface MuxFrontendMetadataBase {\r\n  /** Structured review data for rich UI display (orthogonal to message type) */\r\n  reviews?: ReviewNoteDataForDisplay[];\r\n  /** Command prefix to highlight in UI (e.g., \"/compact -m sonnet\" or \"/react-effects\") */\r\n  commandPrefix?: string;\r\n  /**\r\n   * Model used for the pending send (UI-only).\r\n   *\r\n   * We stash this so the \"starting\" label reflects the actual model for one-shot\r\n   * and compaction sends instead of whatever happens to be persisted in localStorage.\r\n   */\r\n  requestedModel?: string;\r\n}\r\n\r\n/** Status to display in sidebar during background operations */\r\nexport interface DisplayStatus {\r\n  emoji: string;\r\n  message: string;\r\n}\r\n\r\nexport type MuxFrontendMetadata = MuxFrontendMetadataBase &\r\n  (\r\n    | {\r\n        type: \"compaction-request\";\r\n        rawCommand: string; // The original /compact command as typed by user (for display)\r\n        parsed: CompactionRequestData;\r\n        /** Source of compaction request: user-initiated (undefined) or idle-compaction (auto) */\r\n        source?: \"idle-compaction\";\r\n        /** Transient status to display in sidebar during this operation */\r\n        displayStatus?: DisplayStatus;\r\n      }\r\n    | {\r\n        type: \"compaction-summary\";\r\n        /**\r\n         * Follow-up content to dispatch after compaction completes.\r\n         * Stored on the summary so it survives crashes - the user message\r\n         * persisted by dispatch serves as proof of completion.\r\n         */\r\n        pendingFollowUp?: CompactionFollowUpRequest;\r\n      }\r\n    | {\r\n        type: \"agent-skill\";\r\n        /** The original /{skillName} invocation as typed by user (for display) */\r\n        rawCommand: string;\r\n        skillName: string;\r\n        scope: \"project\" | \"global\" | \"built-in\";\r\n      }\r\n    | {\r\n        type: \"plan-display\"; // Ephemeral plan display from /plan command\r\n        path: string;\r\n      }\r\n    | {\r\n        type: \"normal\"; // Regular messages\r\n        /** Original user input for one-shot overrides (e.g., \"/opus+high do something\") â€” used as display content so the command prefix remains visible. */\r\n        rawCommand?: string;\r\n      }\r\n  );\r\n\r\nexport function getCompactionFollowUpContent(\r\n  metadata?: MuxFrontendMetadata\r\n): CompactionRequestData[\"followUpContent\"] | undefined {\r\n  // Keep follow-up extraction centralized so callers don't duplicate legacy handling.\r\n  if (!metadata || metadata.type !== \"compaction-request\") {\r\n    return undefined;\r\n  }\r\n\r\n  // Legacy compaction requests stored follow-up content in `continueMessage`.\r\n  const parsed = metadata.parsed as CompactionRequestData & {\r\n    continueMessage?: CompactionRequestData[\"followUpContent\"];\r\n  };\r\n  return parsed.followUpContent ?? parsed.continueMessage;\r\n}\r\n\r\n/** Type for compaction-summary metadata variant */\r\nexport type CompactionSummaryMetadata = Extract<\r\n  MuxFrontendMetadata,\r\n  { type: \"compaction-summary\" }\r\n>;\r\n\r\n/** Type guard for compaction-summary metadata */\r\nexport function isCompactionSummaryMetadata(\r\n  metadata: MuxFrontendMetadata | undefined\r\n): metadata is CompactionSummaryMetadata {\r\n  return metadata?.type === \"compaction-summary\";\r\n}\r\n\r\n// Our custom metadata type\r\nexport interface MuxMetadata {\r\n  historySequence?: number; // Assigned by backend for global message ordering (required when writing to history)\r\n  duration?: number;\r\n  /** @deprecated Legacy base mode derived from agent definition. */\r\n  mode?: AgentMode;\r\n  timestamp?: number;\r\n  model?: string;\r\n  /** Effective thinking/reasoning level used for this response (after model policy clamping). */\r\n  thinkingLevel?: ThinkingLevel;\r\n  /** True when this response was routed through Mux Gateway (model stays canonical). */\r\n  routedThroughGateway?: boolean;\r\n  /**\r\n   * True when usage costs are included in a subscription (e.g., ChatGPT subscription routing).\r\n   * Token counts are still tracked, but the UI should display costs as $0.\r\n   */\r\n  costsIncluded?: boolean;\r\n  // Total usage across all steps (for cost calculation)\r\n  usage?: LanguageModelV2Usage;\r\n  // Last step's usage only (for context window display - inputTokens = current context size)\r\n  contextUsage?: LanguageModelV2Usage;\r\n  // Aggregated provider metadata across all steps (for cost calculation)\r\n  providerMetadata?: Record<string, unknown>;\r\n  // Last step's provider metadata (for context window cache display)\r\n  contextProviderMetadata?: Record<string, unknown>;\r\n  systemMessageTokens?: number; // Token count for system message sent with this request (calculated by AIService)\r\n  partial?: boolean; // Whether this message was interrupted and is incomplete\r\n  synthetic?: boolean; // Whether this message was synthetically generated (e.g., [CONTINUE] sentinel)\r\n  /**\r\n   * UI hint: show in the chat UI even when synthetic.\r\n   *\r\n   * Synthetic messages are hidden by default because most are for model context only.\r\n   * Set this flag for synthetic notices that should be visible to users.\r\n   */\r\n  uiVisible?: boolean;\r\n  error?: string; // Error message if stream failed\r\n  errorType?: StreamErrorType; // Error type/category if stream failed\r\n  // Compaction source: \"user\" (manual /compact), \"idle\" (auto-triggered), or legacy boolean `true`\r\n  // Readers should use helper: isCompacted = compacted !== undefined && compacted !== false\r\n  compacted?: \"user\" | \"idle\" | boolean;\r\n  /**\r\n   * Monotonic compaction epoch identifier.\r\n   *\r\n   * Legacy histories may omit this; compaction code backfills by counting historical compacted summaries.\r\n   */\r\n  compactionEpoch?: number;\r\n  /**\r\n   * Durable boundary marker for compaction summaries.\r\n   *\r\n   * This lets downstream logic identify compaction boundaries without mutating history.\r\n   */\r\n  compactionBoundary?: boolean;\r\n  toolPolicy?: ToolPolicy; // Tool policy active when this message was sent (user messages only)\r\n  agentId?: string; // Agent id active when this message was sent (assistant messages only)\r\n  cmuxMetadata?: MuxFrontendMetadata; // Frontend-defined metadata, backend treats as black-box\r\n  muxMetadata?: MuxFrontendMetadata; // Frontend-defined metadata, backend treats as black-box\r\n  /**\r\n   * @file mention snapshot token(s) this message provides content for.\r\n   * When present, injectFileAtMentions() skips re-reading these tokens,\r\n   * preserving prompt cache stability across turns.\r\n   */\r\n  fileAtMentionSnapshot?: string[];\r\n\r\n  /**\r\n   * Agent skill snapshot metadata for synthetic messages that inject skill bodies.\r\n   */\r\n  agentSkillSnapshot?: {\r\n    skillName: string;\r\n    scope: AgentSkillScope;\r\n    sha256: string;\r\n    /**\r\n     * YAML frontmatter for the resolved skill (no `---` delimiters).\r\n     * Optional for backwards compatibility with older histories.\r\n     */\r\n    frontmatterYaml?: string;\r\n  };\r\n}\r\n\r\n// Extended tool part type that supports interrupted tool calls (input-available state)\r\n// Standard AI SDK ToolUIPart only supports output-available (completed tools)\r\n// Uses discriminated union: output is required when state is \"output-available\", absent when \"input-available\"\r\nexport type MuxToolPart = z.infer<typeof MuxToolPartSchema>;\r\n\r\n// Text part type\r\nexport interface MuxTextPart {\r\n  type: \"text\";\r\n  text: string;\r\n  timestamp?: number;\r\n}\r\n\r\n// Reasoning part type for extended thinking content\r\nexport interface MuxReasoningPart {\r\n  type: \"reasoning\";\r\n  text: string;\r\n  timestamp?: number;\r\n  /**\r\n   * Anthropic thinking block signature for replay.\r\n   * Required to send reasoning back to Anthropic - the API validates signatures\r\n   * to ensure thinking blocks haven't been tampered with. Reasoning without\r\n   * signatures will be stripped before sending to avoid \"empty content\" errors.\r\n   */\r\n  signature?: string;\r\n  /**\r\n   * Provider options for SDK compatibility.\r\n   * When converting to ModelMessages via the SDK's convertToModelMessages,\r\n   * this is passed through. For Anthropic thinking blocks, this should contain\r\n   * { anthropic: { signature } } to allow reasoning replay.\r\n   */\r\n  providerOptions?: {\r\n    anthropic?: {\r\n      signature?: string;\r\n    };\r\n  };\r\n}\r\n\r\n// File part type for multimodal messages (matches AI SDK FileUIPart)\r\nexport interface MuxFilePart {\r\n  type: \"file\";\r\n  mediaType: string; // IANA media type, e.g., \"image/png\", \"application/pdf\"\r\n  url: string; // Data URL (e.g., \"data:application/pdf;base64,...\") or hosted URL\r\n  filename?: string; // Optional filename\r\n}\r\n\r\n// MuxMessage extends UIMessage with our metadata and custom parts\r\n// Supports text, reasoning, file, and tool parts (including interrupted tool calls)\r\nexport type MuxMessage = Omit<UIMessage<MuxMetadata, never, never>, \"parts\"> & {\r\n  parts: Array<MuxTextPart | MuxReasoningPart | MuxFilePart | MuxToolPart>;\r\n};\r\n\r\n// DisplayedMessage represents a single UI message block\r\n// This is what the UI components consume, splitting complex messages into separate visual blocks\r\nexport type DisplayedMessage =\r\n  | {\r\n      type: \"user\";\r\n      id: string; // Display ID for UI/React keys\r\n      historyId: string; // Original MuxMessage ID for history operations\r\n      content: string;\r\n      /**\r\n       * Command prefix to highlight in the UI (e.g. \"/compact -m sonnet\" or \"/react-effects\").\r\n       * Only set when a slash command was processed.\r\n       */\r\n      commandPrefix?: string;\r\n      fileParts?: FilePart[]; // Optional attachments\r\n      historySequence: number; // Global ordering across all messages\r\n      isSynthetic?: boolean;\r\n      timestamp?: number;\r\n      /** Present when this message invoked an agent skill via /{skill-name} */\r\n      agentSkill?: {\r\n        skillName: string;\r\n        scope: AgentSkillScope;\r\n        /**\r\n         * Optional snapshot content attached later by message aggregation (e.g. tooltips).\r\n         * Not persisted on the user message itself.\r\n         */\r\n        snapshot?: {\r\n          frontmatterYaml?: string;\r\n          body?: string;\r\n        };\r\n      };\r\n      /** Present when this message is a /compact command */\r\n      compactionRequest?: {\r\n        parsed: CompactionRequestData;\r\n      };\r\n      /** Structured review data for rich UI display (from muxMetadata) */\r\n      reviews?: ReviewNoteDataForDisplay[];\r\n    }\r\n  | {\r\n      type: \"assistant\";\r\n      id: string; // Display ID for UI/React keys\r\n      historyId: string; // Original MuxMessage ID for history operations\r\n      content: string;\r\n      historySequence: number; // Global ordering across all messages\r\n      streamSequence?: number; // Local ordering within this assistant message\r\n      isStreaming: boolean;\r\n      isPartial: boolean; // Whether this message was interrupted\r\n      isLastPartOfMessage?: boolean; // True if this is the last part of a multi-part message\r\n      isCompacted: boolean; // Whether this is a compacted summary\r\n      isIdleCompacted: boolean; // Whether this compaction was auto-triggered due to inactivity\r\n      model?: string;\r\n      routedThroughGateway?: boolean;\r\n      agentId?: string; // Agent id active when this message was sent (assistant messages only)\r\n      /** @deprecated Legacy base mode derived from agent definition. */\r\n      mode?: AgentMode;\r\n      timestamp?: number;\r\n      tokens?: number;\r\n    }\r\n  | {\r\n      type: \"tool\";\r\n      id: string; // Display ID for UI/React keys\r\n      historyId: string; // Original MuxMessage ID for history operations\r\n      toolCallId: string;\r\n      toolName: string;\r\n      args: unknown;\r\n      result?: unknown;\r\n      status: \"pending\" | \"executing\" | \"completed\" | \"failed\" | \"interrupted\" | \"redacted\";\r\n      isPartial: boolean; // Whether the parent message was interrupted\r\n      historySequence: number; // Global ordering across all messages\r\n      streamSequence?: number; // Local ordering within this assistant message\r\n      isLastPartOfMessage?: boolean; // True if this is the last part of a multi-part message\r\n      timestamp?: number;\r\n      // Nested tool calls for code_execution (from PTC streaming or reconstructed from result)\r\n      nestedCalls?: Array<{\r\n        toolCallId: string;\r\n        toolName: string;\r\n        input: unknown;\r\n        output?: unknown;\r\n        state: \"input-available\" | \"output-available\" | \"output-redacted\";\r\n        timestamp?: number;\r\n      }>;\r\n    }\r\n  | {\r\n      type: \"reasoning\";\r\n      id: string; // Display ID for UI/React keys\r\n      historyId: string; // Original MuxMessage ID for history operations\r\n      content: string;\r\n      historySequence: number; // Global ordering across all messages\r\n      streamSequence?: number; // Local ordering within this assistant message\r\n      isStreaming: boolean;\r\n      isPartial: boolean; // Whether the parent message was interrupted\r\n      isLastPartOfMessage?: boolean; // True if this is the last part of a multi-part message\r\n      timestamp?: number;\r\n      tokens?: number; // Reasoning tokens if available\r\n    }\r\n  | {\r\n      type: \"stream-error\";\r\n      id: string; // Display ID for UI/React keys\r\n      historyId: string; // Original MuxMessage ID for history operations\r\n      error: string; // Error message\r\n      errorType: StreamErrorType; // Error type/category\r\n      historySequence: number; // Global ordering across all messages\r\n      timestamp?: number;\r\n      model?: string;\r\n      routedThroughGateway?: boolean;\r\n      errorCount?: number; // Number of consecutive identical errors merged into this message\r\n    }\r\n  | {\r\n      type: \"compaction-boundary\";\r\n      id: string; // Display ID for UI/React keys\r\n      historySequence: number; // Sequence of the compaction summary this boundary belongs to\r\n      position: \"start\" | \"end\";\r\n      compactionEpoch?: number;\r\n    }\r\n  | {\r\n      type: \"history-hidden\";\r\n      id: string; // Display ID for UI/React keys\r\n      hiddenCount: number; // Number of messages hidden\r\n      historySequence: number; // Global ordering across all messages\r\n      /** Breakdown of omitted message types (when truncating for performance). */\r\n      omittedMessageCounts?: {\r\n        tool: number;\r\n        reasoning: number;\r\n      };\r\n    }\r\n  | {\r\n      type: \"workspace-init\";\r\n      id: string; // Display ID for UI/React keys\r\n      historySequence: number; // Position in message stream (-1 for ephemeral, non-persisted events)\r\n      status: \"running\" | \"success\" | \"error\";\r\n      hookPath: string; // Path to the init script being executed\r\n      lines: Array<{ line: string; isError: boolean }>; // Accumulated output lines (stderr tagged via isError)\r\n      exitCode: number | null; // Final exit code (null while running)\r\n      timestamp: number;\r\n      durationMs: number | null; // Duration in milliseconds (null while running)\r\n      truncatedLines?: number; // Number of lines dropped from middle when output was too long\r\n    }\r\n  | {\r\n      type: \"plan-display\"; // Ephemeral plan display from /plan command\r\n      id: string; // Display ID for UI/React keys\r\n      historyId: string; // Original MuxMessage ID (same as id for ephemeral messages)\r\n      content: string; // Plan markdown content\r\n      path: string; // Path to the plan file\r\n      historySequence: number; // Global ordering across all messages\r\n    };\r\n\r\n/** Convenience type alias for user-role DisplayedMessage */\r\nexport type DisplayedUserMessage = Extract<DisplayedMessage, { type: \"user\" }>;\r\n\r\nexport interface QueuedMessage {\r\n  id: string;\r\n  content: string;\r\n  fileParts?: FilePart[];\r\n  /** Structured review data for rich UI display (from muxMetadata) */\r\n  reviews?: ReviewNoteDataForDisplay[];\r\n  /** True when the queued message is a compaction request (/compact) */\r\n  hasCompactionRequest?: boolean;\r\n}\r\n\r\n// Helper to create a simple text message\r\nexport function createMuxMessage(\r\n  id: string,\r\n  role: \"user\" | \"assistant\",\r\n  content: string,\r\n  metadata?: MuxMetadata,\r\n  additionalParts?: MuxMessage[\"parts\"]\r\n): MuxMessage {\r\n  const textPart = content\r\n    ? [{ type: \"text\" as const, text: content, state: \"done\" as const }]\r\n    : [];\r\n  const parts = [...textPart, ...(additionalParts ?? [])];\r\n\r\n  // Validation: User messages must have at least one part with content\r\n  // This prevents empty user messages from being created (defense-in-depth)\r\n  if (role === \"user\" && parts.length === 0) {\r\n    throw new Error(\r\n      \"Cannot create user message with no parts. Empty messages should be rejected upstream.\"\r\n    );\r\n  }\r\n\r\n  return {\r\n    id,\r\n    role,\r\n    metadata,\r\n    parts,\r\n  };\r\n}\r\n"]}