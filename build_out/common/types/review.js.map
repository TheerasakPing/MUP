{"version":3,"file":"review.js","sourceRoot":"","sources":["../../../src/common/types/review.ts"],"names":[],"mappings":";AAAA;;GAEG;;;;AA8LH,SAAS,gBAAgB,CAAC,SAAiB,EAAgC;IACzE,MAAM,KAAK,GAAG,oBAAoB,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC;IAC1D,IAAI,CAAC,KAAK;QAAE,OAAO,IAAI,CAAC;IAExB,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IAClC,MAAM,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;IACtD,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;QAAE,OAAO,IAAI,CAAC;IAExE,OAAO;QACL,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,CAAC;QACjC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,CAAC;KAChC,CAAC;AAAA,CACH;AAED;;;;;;GAMG;AACH,8BAAqC,SAAiB,EAAgC;IACpF,MAAM,MAAM,GAAG,SAAS,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IAC7D,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,IAAI,CAAC;IAErC,IAAI,QAA2C,CAAC;IAChD,IAAI,QAA2C,CAAC;IAEhD,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;QAC3B,IAAI,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC9C,MAAM,MAAM,GAAG,gBAAgB,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YAChD,IAAI,MAAM;gBAAE,QAAQ,GAAG,MAAM,CAAC;YAC9B,SAAS;QACX,CAAC;QAED,IAAI,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC9C,MAAM,MAAM,GAAG,gBAAgB,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YAChD,IAAI,MAAM;gBAAE,QAAQ,GAAG,MAAM,CAAC;YAC9B,SAAS;QACX,CAAC;QAED,sFAAsF;QACtF,MAAM,WAAW,GAAG,gBAAgB,CAAC,KAAK,CAAC,CAAC;QAC5C,IAAI,WAAW,EAAE,CAAC;YAChB,QAAQ,KAAR,QAAQ,GAAK,WAAW,EAAC;YACzB,QAAQ,KAAR,QAAQ,GAAK,WAAW,EAAC;QAC3B,CAAC;IACH,CAAC;IAED,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ;QAAE,OAAO,IAAI,CAAC;IAExC,OAAO;QACL,GAAG,EAAE,QAAQ;QACb,GAAG,EAAE,QAAQ;KACd,CAAC;AAAA,CACH;AACD;;;GAGG;AACH,8BAAqC,IAAoB,EAAU;IACjE,OAAO,gBAAgB,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,SAAS,aAAa,IAAI,CAAC,YAAY,eAAe,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,aAAa,CAAC;AAAA,CACtI","sourcesContent":["/**\r\n * Types for code review system\r\n */\r\n\r\n/**\r\n * Type of change for a file in a diff\r\n */\r\nexport type FileChangeType = \"added\" | \"deleted\" | \"modified\" | \"renamed\";\r\n\r\n/**\r\n * Individual hunk within a file diff\r\n */\r\nexport interface DiffHunk {\r\n  /** Unique identifier for this hunk (hash of file path + line ranges) */\r\n  id: string;\r\n  /** Path to the file relative to workspace root */\r\n  filePath: string;\r\n  /** Starting line number in old file */\r\n  oldStart: number;\r\n  /** Number of lines in old file */\r\n  oldLines: number;\r\n  /** Starting line number in new file */\r\n  newStart: number;\r\n  /** Number of lines in new file */\r\n  newLines: number;\r\n  /** Diff content (lines starting with +/-/space) */\r\n  content: string;\r\n  /** Hunk header line (e.g., \"@@ -1,5 +1,6 @@\") */\r\n  header: string;\r\n  /** Change type from parent file */\r\n  changeType?: FileChangeType;\r\n  /** Old file path (if renamed) */\r\n  oldPath?: string;\r\n}\r\n\r\n/**\r\n * Parsed file diff containing multiple hunks\r\n */\r\nexport interface FileDiff {\r\n  /** Path to the file relative to workspace root */\r\n  filePath: string;\r\n  /** Old file path (different if renamed) */\r\n  oldPath?: string;\r\n  /** Type of change */\r\n  changeType: FileChangeType;\r\n  /** Whether this is a binary file */\r\n  isBinary: boolean;\r\n  /** Hunks in this file */\r\n  hunks: DiffHunk[];\r\n}\r\n\r\n/**\r\n * Read state for a single hunk\r\n */\r\nexport interface HunkReadState {\r\n  /** ID of the hunk */\r\n  hunkId: string;\r\n  /** Whether this hunk has been marked as read */\r\n  isRead: boolean;\r\n  /** Timestamp when read state was last updated */\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * Workspace review state (persisted to localStorage)\r\n */\r\nexport interface ReviewState {\r\n  /** Workspace ID this review belongs to */\r\n  workspaceId: string;\r\n  /** Read state keyed by hunk ID */\r\n  readState: Record<string, HunkReadState>;\r\n  /** Timestamp of last update */\r\n  lastUpdated: number;\r\n}\r\n\r\n/**\r\n * Sort order options for review panel hunks\r\n */\r\nexport type ReviewSortOrder = \"file-order\" | \"last-edit\";\r\n\r\n/**\r\n * Filter options for review panel\r\n */\r\nexport interface ReviewFilters {\r\n  /** Whether to show hunks marked as read */\r\n  showReadHunks: boolean;\r\n  /** File path filter (regex or glob pattern) */\r\n  filePathFilter?: string;\r\n  /** Base reference to diff against (e.g., \"HEAD\", \"main\", \"origin/main\") */\r\n  diffBase: string;\r\n  /** Whether to include uncommitted changes (staged + unstaged) in the diff */\r\n  includeUncommitted: boolean;\r\n  /** Sort order for hunks */\r\n  sortOrder: ReviewSortOrder;\r\n}\r\n\r\n/**\r\n * Review statistics\r\n */\r\nexport interface ReviewStats {\r\n  /** Total number of hunks */\r\n  total: number;\r\n  /** Number of hunks marked as read */\r\n  read: number;\r\n  /** Number of unread hunks */\r\n  unread: number;\r\n}\r\n\r\n/**\r\n * Status of a review\r\n * - pending: In banner, not attached to chat input\r\n * - attached: Currently attached to chat input draft\r\n * - checked: Marked as done (after being sent)\r\n */\r\nexport type ReviewStatus = \"pending\" | \"attached\" | \"checked\";\r\n\r\n/**\r\n * Structured data for a review note.\r\n * Passed from DiffRenderer when user creates a review.\r\n * Stored as-is for rich UI display, formatted to message only when sending to chat.\r\n */\r\nexport interface ReviewNoteData {\r\n  /** File path being reviewed */\r\n  filePath: string;\r\n  /** Line range (e.g., \"-10-12 +14-16\", \"-10\", \"+14\", or legacy \"42-45\") */\r\n  lineRange: string;\r\n\r\n  /**\r\n   * Human-readable selected code included in the message payload.\r\n   * Historically this included embedded line numbers; keep for backwards compatibility.\r\n   */\r\n  selectedCode: string;\r\n\r\n  /**\r\n   * Raw diff snippet for UI rendering (lines start with + / - / space).\r\n   * When present, the UI should prefer this for consistent syntax highlighting.\r\n   */\r\n  selectedDiff?: string;\r\n\r\n  /** Starting old line number for rendering selectedDiff (if present). */\r\n  oldStart?: number;\r\n  /** Starting new line number for rendering selectedDiff (if present). */\r\n  newStart?: number;\r\n\r\n  /** User's review comment */\r\n  userNote: string;\r\n}\r\n\r\n/**\r\n * A single review note\r\n * Created when user adds a review note from the diff viewer\r\n */\r\nexport interface Review {\r\n  /** Unique identifier */\r\n  id: string;\r\n  /** Structured review data for rich UI display */\r\n  data: ReviewNoteData;\r\n  /** Current status */\r\n  status: ReviewStatus;\r\n  /** Timestamp when created */\r\n  createdAt: number;\r\n  /** Timestamp when status changed (checked/unchecked) */\r\n  statusChangedAt?: number;\r\n}\r\n\r\n/**\r\n * Persisted state for reviews (per workspace)\r\n * Contains reviews in all states: pending, attached, and checked\r\n */\r\nexport interface ReviewsState {\r\n  /** Workspace ID */\r\n  workspaceId: string;\r\n  /** All reviews keyed by ID */\r\n  reviews: Record<string, Review>;\r\n  /** Last update timestamp */\r\n  lastUpdated: number;\r\n}\r\n\r\n/**\r\n * Helpers for parsing ReviewNoteData.lineRange.\r\n */\r\n\r\nexport interface ReviewLineNumberRange {\r\n  start: number;\r\n  end: number;\r\n}\r\n\r\nexport interface ParsedReviewLineRange {\r\n  old?: ReviewLineNumberRange;\r\n  new?: ReviewLineNumberRange;\r\n}\r\n\r\nfunction parseNumberRange(rangeText: string): ReviewLineNumberRange | null {\r\n  const match = /^(\\d+)(?:-(\\d+))?$/.exec(rangeText.trim());\r\n  if (!match) return null;\r\n\r\n  const startNum = Number(match[1]);\r\n  const endNum = match[2] ? Number(match[2]) : startNum;\r\n  if (!Number.isFinite(startNum) || !Number.isFinite(endNum)) return null;\r\n\r\n  return {\r\n    start: Math.min(startNum, endNum),\r\n    end: Math.max(startNum, endNum),\r\n  };\r\n}\r\n\r\n/**\r\n * Parse a ReviewNoteData.lineRange string into numeric old/new ranges.\r\n *\r\n * Supports:\r\n * - Current format: \"-10-12 +14-16\", \"-10 +14\", \"-10\", \"+14-16\"\r\n * - Legacy format: \"42\" or \"42-45\" (treated as both old and new)\r\n */\r\nexport function parseReviewLineRange(lineRange: string): ParsedReviewLineRange | null {\r\n  const tokens = lineRange.trim().split(/\\s+/).filter(Boolean);\r\n  if (tokens.length === 0) return null;\r\n\r\n  let oldRange: ReviewLineNumberRange | undefined;\r\n  let newRange: ReviewLineNumberRange | undefined;\r\n\r\n  for (const token of tokens) {\r\n    if (token.startsWith(\"-\") && token.length > 1) {\r\n      const parsed = parseNumberRange(token.slice(1));\r\n      if (parsed) oldRange = parsed;\r\n      continue;\r\n    }\r\n\r\n    if (token.startsWith(\"+\") && token.length > 1) {\r\n      const parsed = parseNumberRange(token.slice(1));\r\n      if (parsed) newRange = parsed;\r\n      continue;\r\n    }\r\n\r\n    // Legacy: range without +/- prefix. Treat as matching either old or new line numbers.\r\n    const legacyRange = parseNumberRange(token);\r\n    if (legacyRange) {\r\n      oldRange ??= legacyRange;\r\n      newRange ??= legacyRange;\r\n    }\r\n  }\r\n\r\n  if (!oldRange && !newRange) return null;\r\n\r\n  return {\r\n    old: oldRange,\r\n    new: newRange,\r\n  };\r\n}\r\n/**\r\n * Format a ReviewNoteData into the message format for the model.\r\n * Used when preparing reviews for sending to chat.\r\n */\r\nexport function formatReviewForModel(data: ReviewNoteData): string {\r\n  return `<review>\\nRe ${data.filePath}:${data.lineRange}\\n\\`\\`\\`\\n${data.selectedCode}\\n\\`\\`\\`\\n> ${data.userNote.trim()}\\n</review>`;\r\n}\r\n"]}