{"version":3,"file":"signing.js","sourceRoot":"","sources":["../../../../src/common/orpc/schemas/signing.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;;;AAEH,6BAAwB;AAExB,gCAAgC;AAEnB,QAAA,wBAAwB,GAAG,OAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AAExC,QAAA,kBAAkB,GAAG,OAAC,CAAC,MAAM,CAAC;IACzC,oBAAoB;IACpB,OAAO,EAAE,OAAC,CAAC,MAAM,EAAE;IACnB,mEAAmE;IACnE,eAAe,EAAE,OAAC,CAAC,OAAO,EAAE;CAC7B,CAAC,CAAC;AAEU,QAAA,yBAAyB,GAAG,OAAC,CAAC,MAAM,CAAC;IAChD,sFAAsF;IACtF,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;IAChC,uCAAuC;IACvC,UAAU,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;IACjC,6DAA6D;IAC7D,KAAK,EAAE,QAAA,kBAAkB,CAAC,QAAQ,EAAE;CACrC,CAAC,CAAC;AAIH,+BAA+B;AAC/B,2EAA2E;AAE9D,QAAA,uBAAuB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC9C,GAAG,EAAE,OAAC,CAAC,MAAM,EAAE;IACf,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE;IACrB,UAAU,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;CAClC,CAAC,CAAC;AAIU,QAAA,gBAAgB,GAAG,OAAC;KAC9B,MAAM,CAAC;IACN,OAAO,EAAE,OAAC,CAAC,MAAM,EAAE;CACpB,CAAC;KACD,MAAM,EAAE,CAAC;AAEC,QAAA,iBAAiB,GAAG,QAAA,uBAAuB,CAAC;AAEzD,wCAAwC;AAE3B,QAAA,uBAAuB,GAAG,OAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACvC,QAAA,wBAAwB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC/C,OAAO,EAAE,OAAC,CAAC,OAAO,EAAE;CACrB,CAAC,CAAC;AAEH,6BAA6B;AAChB,QAAA,OAAO,GAAG;IACrB,YAAY,EAAE;QACZ,KAAK,EAAE,QAAA,wBAAwB;QAC/B,MAAM,EAAE,QAAA,yBAAyB;KAClC;IACD,WAAW,EAAE;QACX,KAAK,EAAE,QAAA,gBAAgB;QACvB,MAAM,EAAE,QAAA,iBAAiB;KAC1B;IACD,kBAAkB,EAAE;QAClB,KAAK,EAAE,QAAA,uBAAuB;QAC9B,MAAM,EAAE,QAAA,wBAAwB;KACjC;CACF,CAAC","sourcesContent":["/**\r\n * Signing ORPC schemas\r\n *\r\n * Defines input/output schemas for mux.md message signing endpoints.\r\n * Used for signing shared content with optional GitHub identity attribution.\r\n */\r\n\r\nimport { z } from \"zod\";\r\n\r\n// --- Capabilities endpoint ---\r\n\r\nexport const signingCapabilitiesInput = z.object({});\r\n\r\nexport const signingErrorOutput = z.object({\r\n  /** Error message */\r\n  message: z.string(),\r\n  /** True if a compatible key was found but requires a passphrase */\r\n  hasEncryptedKey: z.boolean(),\r\n});\r\n\r\nexport const signingCapabilitiesOutput = z.object({\r\n  /** Public key in OpenSSH format (ssh-ed25519 AAAA...), null if no key is available */\r\n  publicKey: z.string().nullable(),\r\n  /** Detected GitHub username, if any */\r\n  githubUser: z.string().nullable(),\r\n  /** Error info if key loading or identity detection failed */\r\n  error: signingErrorOutput.nullable(),\r\n});\r\n\r\nexport type SigningCapabilities = z.infer<typeof signingCapabilitiesOutput>;\r\n\r\n// --- signMessage endpoint ---\r\n// Returns a mux.md-compatible signature envelope for the provided content.\r\n\r\nexport const signatureEnvelopeOutput = z.object({\r\n  sig: z.string(),\r\n  publicKey: z.string(),\r\n  githubUser: z.string().optional(),\r\n});\r\n\r\nexport type SignatureEnvelope = z.infer<typeof signatureEnvelopeOutput>;\r\n\r\nexport const signMessageInput = z\r\n  .object({\r\n    content: z.string(),\r\n  })\r\n  .strict();\r\n\r\nexport const signMessageOutput = signatureEnvelopeOutput;\r\n\r\n// --- Clear identity cache endpoint ---\r\n\r\nexport const clearIdentityCacheInput = z.object({});\r\nexport const clearIdentityCacheOutput = z.object({\r\n  success: z.boolean(),\r\n});\r\n\r\n// Grouped schemas for router\r\nexport const signing = {\r\n  capabilities: {\r\n    input: signingCapabilitiesInput,\r\n    output: signingCapabilitiesOutput,\r\n  },\r\n  signMessage: {\r\n    input: signMessageInput,\r\n    output: signMessageOutput,\r\n  },\r\n  clearIdentityCache: {\r\n    input: clearIdentityCacheInput,\r\n    output: clearIdentityCacheOutput,\r\n  },\r\n};\r\n"]}