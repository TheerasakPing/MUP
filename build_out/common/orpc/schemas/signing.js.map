{"version":3,"file":"signing.js","sourceRoot":"","sources":["../../../../src/common/orpc/schemas/signing.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;;;AAEH,6BAAwB;AAExB,gCAAgC;AAEnB,QAAA,wBAAwB,GAAG,OAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AAExC,QAAA,kBAAkB,GAAG,OAAC,CAAC,MAAM,CAAC;IACzC,oBAAoB;IACpB,OAAO,EAAE,OAAC,CAAC,MAAM,EAAE;IACnB,mEAAmE;IACnE,eAAe,EAAE,OAAC,CAAC,OAAO,EAAE;CAC7B,CAAC,CAAC;AAEU,QAAA,yBAAyB,GAAG,OAAC,CAAC,MAAM,CAAC;IAChD,sFAAsF;IACtF,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;IAChC,uCAAuC;IACvC,UAAU,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;IACjC,6DAA6D;IAC7D,KAAK,EAAE,QAAA,kBAAkB,CAAC,QAAQ,EAAE;CACrC,CAAC,CAAC;AAIH,+BAA+B;AAC/B,2EAA2E;AAE9D,QAAA,uBAAuB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC9C,GAAG,EAAE,OAAC,CAAC,MAAM,EAAE;IACf,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE;IACrB,UAAU,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;CAClC,CAAC,CAAC;AAIU,QAAA,gBAAgB,GAAG,OAAC;KAC9B,MAAM,CAAC;IACN,OAAO,EAAE,OAAC,CAAC,MAAM,EAAE;CACpB,CAAC;KACD,MAAM,EAAE,CAAC;AAEC,QAAA,iBAAiB,GAAG,QAAA,uBAAuB,CAAC;AAEzD,wCAAwC;AAE3B,QAAA,uBAAuB,GAAG,OAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACvC,QAAA,wBAAwB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC/C,OAAO,EAAE,OAAC,CAAC,OAAO,EAAE;CACrB,CAAC,CAAC;AAEH,6BAA6B;AAChB,QAAA,OAAO,GAAG;IACrB,YAAY,EAAE;QACZ,KAAK,EAAE,QAAA,wBAAwB;QAC/B,MAAM,EAAE,QAAA,yBAAyB;KAClC;IACD,WAAW,EAAE;QACX,KAAK,EAAE,QAAA,gBAAgB;QACvB,MAAM,EAAE,QAAA,iBAAiB;KAC1B;IACD,kBAAkB,EAAE;QAClB,KAAK,EAAE,QAAA,uBAAuB;QAC9B,MAAM,EAAE,QAAA,wBAAwB;KACjC;CACF,CAAC","sourcesContent":["/**\n * Signing ORPC schemas\n *\n * Defines input/output schemas for mux.md message signing endpoints.\n * Used for signing shared content with optional GitHub identity attribution.\n */\n\nimport { z } from \"zod\";\n\n// --- Capabilities endpoint ---\n\nexport const signingCapabilitiesInput = z.object({});\n\nexport const signingErrorOutput = z.object({\n  /** Error message */\n  message: z.string(),\n  /** True if a compatible key was found but requires a passphrase */\n  hasEncryptedKey: z.boolean(),\n});\n\nexport const signingCapabilitiesOutput = z.object({\n  /** Public key in OpenSSH format (ssh-ed25519 AAAA...), null if no key is available */\n  publicKey: z.string().nullable(),\n  /** Detected GitHub username, if any */\n  githubUser: z.string().nullable(),\n  /** Error info if key loading or identity detection failed */\n  error: signingErrorOutput.nullable(),\n});\n\nexport type SigningCapabilities = z.infer<typeof signingCapabilitiesOutput>;\n\n// --- signMessage endpoint ---\n// Returns a mux.md-compatible signature envelope for the provided content.\n\nexport const signatureEnvelopeOutput = z.object({\n  sig: z.string(),\n  publicKey: z.string(),\n  githubUser: z.string().optional(),\n});\n\nexport type SignatureEnvelope = z.infer<typeof signatureEnvelopeOutput>;\n\nexport const signMessageInput = z\n  .object({\n    content: z.string(),\n  })\n  .strict();\n\nexport const signMessageOutput = signatureEnvelopeOutput;\n\n// --- Clear identity cache endpoint ---\n\nexport const clearIdentityCacheInput = z.object({});\nexport const clearIdentityCacheOutput = z.object({\n  success: z.boolean(),\n});\n\n// Grouped schemas for router\nexport const signing = {\n  capabilities: {\n    input: signingCapabilitiesInput,\n    output: signingCapabilitiesOutput,\n  },\n  signMessage: {\n    input: signMessageInput,\n    output: signMessageOutput,\n  },\n  clearIdentityCache: {\n    input: clearIdentityCacheInput,\n    output: clearIdentityCacheOutput,\n  },\n};\n"]}