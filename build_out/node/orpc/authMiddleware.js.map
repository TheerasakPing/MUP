{"version":3,"file":"authMiddleware.js","sourceRoot":"","sources":["../../../src/node/orpc/authMiddleware.ts"],"names":[],"mappings":"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","sourcesContent":["import { timingSafeEqual } from \"crypto\";\nimport { os } from \"@orpc/server\";\nimport type { IncomingHttpHeaders, IncomingMessage } from \"http\";\nimport { URL } from \"url\";\n\n// Best-effort time-constant string comparison.\n//\n// We intentionally use Node's native `timingSafeEqual` (battle-tested + optimized).\n// It requires equal-length inputs, so we pad both sides to maxLen first, then fold\n// the original length equality into the final result.\n//\n// Tradeoff: this allocates temporary buffers. That's acceptable here (called once\n// per auth check) and avoids tricky timing branches.\nexport function safeEq(a: string, b: string): boolean {\n  const bufA = Buffer.from(a);\n  const bufB = Buffer.from(b);\n\n  const maxLen = Math.max(bufA.length, bufB.length);\n\n  // timingSafeEqual requires equal-length buffers.\n  const paddedA = Buffer.alloc(maxLen);\n  const paddedB = Buffer.alloc(maxLen);\n  bufA.copy(paddedA);\n  bufB.copy(paddedB);\n\n  const bytesMatch = timingSafeEqual(paddedA, paddedB);\n  return bytesMatch && bufA.length === bufB.length;\n}\n\nfunction extractBearerToken(header: string | string[] | undefined): string | null {\n  const h = Array.isArray(header) ? header[0] : header;\n  if (!h?.toLowerCase().startsWith(\"bearer \")) return null;\n  return h.slice(7).trim() || null;\n}\n\n/** Create auth middleware that validates Authorization header from context */\nexport function createAuthMiddleware(authToken?: string) {\n  if (!authToken?.trim()) {\n    return os.middleware(({ next }) => next());\n  }\n\n  const expectedToken = authToken.trim();\n\n  return os\n    .$context<{ headers?: IncomingHttpHeaders }>()\n    .errors({\n      UNAUTHORIZED: {\n        message: \"Invalid or missing auth token\",\n      },\n    })\n    .middleware(({ context, errors, next }) => {\n      const presentedToken = extractBearerToken(context.headers?.authorization);\n\n      if (!presentedToken || !safeEq(presentedToken, expectedToken)) {\n        throw errors.UNAUTHORIZED();\n      }\n\n      return next();\n    });\n}\n\n/** Extract auth token from WS upgrade request and build headers object with synthetic Authorization */\nexport function extractWsHeaders(req: IncomingMessage): IncomingHttpHeaders {\n  // Start with actual headers\n  const headers = { ...req.headers };\n\n  // If no Authorization header, try fallback methods\n  if (!headers.authorization) {\n    // 1) Query param: ?token=...\n    try {\n      const url = new URL(req.url ?? \"\", \"http://localhost\");\n      const qp = url.searchParams.get(\"token\");\n      if (qp?.trim()) {\n        headers.authorization = `Bearer ${qp.trim()}`;\n        return headers;\n      }\n    } catch {\n      /* ignore */\n    }\n\n    // 2) Sec-WebSocket-Protocol (first value as token)\n    const proto = req.headers[\"sec-websocket-protocol\"];\n    if (typeof proto === \"string\") {\n      const first = proto\n        .split(\",\")\n        .map((s) => s.trim())\n        .find((s) => s);\n      if (first) {\n        headers.authorization = `Bearer ${first}`;\n      }\n    }\n  }\n\n  return headers;\n}\n"]}