{"version":3,"file":"authMiddleware.js","sourceRoot":"","sources":["../../../src/node/orpc/authMiddleware.ts"],"names":[],"mappings":"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","sourcesContent":["import { timingSafeEqual } from \"crypto\";\r\nimport { os } from \"@orpc/server\";\r\nimport type { IncomingHttpHeaders, IncomingMessage } from \"http\";\r\nimport { URL } from \"url\";\r\n\r\n// Best-effort time-constant string comparison.\r\n//\r\n// We intentionally use Node's native `timingSafeEqual` (battle-tested + optimized).\r\n// It requires equal-length inputs, so we pad both sides to maxLen first, then fold\r\n// the original length equality into the final result.\r\n//\r\n// Tradeoff: this allocates temporary buffers. That's acceptable here (called once\r\n// per auth check) and avoids tricky timing branches.\r\nexport function safeEq(a: string, b: string): boolean {\r\n  const bufA = Buffer.from(a);\r\n  const bufB = Buffer.from(b);\r\n\r\n  const maxLen = Math.max(bufA.length, bufB.length);\r\n\r\n  // timingSafeEqual requires equal-length buffers.\r\n  const paddedA = Buffer.alloc(maxLen);\r\n  const paddedB = Buffer.alloc(maxLen);\r\n  bufA.copy(paddedA);\r\n  bufB.copy(paddedB);\r\n\r\n  const bytesMatch = timingSafeEqual(paddedA, paddedB);\r\n  return bytesMatch && bufA.length === bufB.length;\r\n}\r\n\r\nfunction extractBearerToken(header: string | string[] | undefined): string | null {\r\n  const h = Array.isArray(header) ? header[0] : header;\r\n  if (!h?.toLowerCase().startsWith(\"bearer \")) return null;\r\n  return h.slice(7).trim() || null;\r\n}\r\n\r\n/** Create auth middleware that validates Authorization header from context */\r\nexport function createAuthMiddleware(authToken?: string) {\r\n  if (!authToken?.trim()) {\r\n    return os.middleware(({ next }) => next());\r\n  }\r\n\r\n  const expectedToken = authToken.trim();\r\n\r\n  return os\r\n    .$context<{ headers?: IncomingHttpHeaders }>()\r\n    .errors({\r\n      UNAUTHORIZED: {\r\n        message: \"Invalid or missing auth token\",\r\n      },\r\n    })\r\n    .middleware(({ context, errors, next }) => {\r\n      const presentedToken = extractBearerToken(context.headers?.authorization);\r\n\r\n      if (!presentedToken || !safeEq(presentedToken, expectedToken)) {\r\n        throw errors.UNAUTHORIZED();\r\n      }\r\n\r\n      return next();\r\n    });\r\n}\r\n\r\n/** Extract auth token from WS upgrade request and build headers object with synthetic Authorization */\r\nexport function extractWsHeaders(req: IncomingMessage): IncomingHttpHeaders {\r\n  // Start with actual headers\r\n  const headers = { ...req.headers };\r\n\r\n  // If no Authorization header, try fallback methods\r\n  if (!headers.authorization) {\r\n    // 1) Query param: ?token=...\r\n    try {\r\n      const url = new URL(req.url ?? \"\", \"http://localhost\");\r\n      const qp = url.searchParams.get(\"token\");\r\n      if (qp?.trim()) {\r\n        headers.authorization = `Bearer ${qp.trim()}`;\r\n        return headers;\r\n      }\r\n    } catch {\r\n      /* ignore */\r\n    }\r\n\r\n    // 2) Sec-WebSocket-Protocol (first value as token)\r\n    const proto = req.headers[\"sec-websocket-protocol\"];\r\n    if (typeof proto === \"string\") {\r\n      const first = proto\r\n        .split(\",\")\r\n        .map((s) => s.trim())\r\n        .find((s) => s);\r\n      if (first) {\r\n        headers.authorization = `Bearer ${first}`;\r\n      }\r\n    }\r\n  }\r\n\r\n  return headers;\r\n}\r\n"]}