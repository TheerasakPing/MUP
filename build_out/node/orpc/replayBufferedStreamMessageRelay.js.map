{"version":3,"file":"replayBufferedStreamMessageRelay.js","sourceRoot":"","sources":["../../../src/node/orpc/replayBufferedStreamMessageRelay.ts"],"names":[],"mappings":"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","sourcesContent":["import type { WorkspaceChatMessage } from \"@/common/orpc/types\";\n\ntype ReplayBufferedStreamMessage = Extract<\n  WorkspaceChatMessage,\n  {\n    type: \"stream-delta\" | \"reasoning-delta\" | \"stream-end\" | \"stream-abort\" | \"stream-error\";\n  }\n>;\n\ntype ReplayBufferedDeltaMessage = Extract<\n  ReplayBufferedStreamMessage,\n  { type: \"stream-delta\" | \"reasoning-delta\" }\n>;\n\nfunction isReplayBufferedStreamMessage(\n  message: WorkspaceChatMessage\n): message is ReplayBufferedStreamMessage {\n  return (\n    message.type === \"stream-delta\" ||\n    message.type === \"reasoning-delta\" ||\n    message.type === \"stream-end\" ||\n    message.type === \"stream-abort\" ||\n    message.type === \"stream-error\"\n  );\n}\n\nfunction isReplayBufferedDeltaMessage(\n  message: ReplayBufferedStreamMessage\n): message is ReplayBufferedDeltaMessage {\n  return message.type === \"stream-delta\" || message.type === \"reasoning-delta\";\n}\n\nfunction isReplayMessage(message: WorkspaceChatMessage): boolean {\n  return (message as { replay?: unknown }).replay === true;\n}\n\nfunction replayBufferedDeltaKey(message: ReplayBufferedDeltaMessage): string {\n  return JSON.stringify([message.type, message.messageId, message.timestamp, message.delta]);\n}\n\nexport function createReplayBufferedStreamMessageRelay(\n  push: (message: WorkspaceChatMessage) => void\n): {\n  handleSessionMessage: (message: WorkspaceChatMessage) => void;\n  finishReplay: () => void;\n} {\n  let isReplaying = true;\n  const bufferedLiveStreamMessages: ReplayBufferedStreamMessage[] = [];\n\n  // Counter (not a Set) so we don't drop more buffered events than were replayed.\n  const replayedDeltaKeyCounts = new Map<string, number>();\n\n  const noteReplayedDelta = (message: ReplayBufferedDeltaMessage) => {\n    const key = replayBufferedDeltaKey(message);\n    replayedDeltaKeyCounts.set(key, (replayedDeltaKeyCounts.get(key) ?? 0) + 1);\n  };\n\n  const shouldDropBufferedDelta = (message: ReplayBufferedDeltaMessage): boolean => {\n    const key = replayBufferedDeltaKey(message);\n    const remaining = replayedDeltaKeyCounts.get(key) ?? 0;\n    if (remaining <= 0) {\n      return false;\n    }\n    if (remaining === 1) {\n      replayedDeltaKeyCounts.delete(key);\n    } else {\n      replayedDeltaKeyCounts.set(key, remaining - 1);\n    }\n    return true;\n  };\n\n  const handleSessionMessage = (message: WorkspaceChatMessage) => {\n    if (isReplaying && isReplayBufferedStreamMessage(message)) {\n      if (!isReplayMessage(message)) {\n        // Preserve stream event order during replay buffering (P1): if we buffer only deltas,\n        // terminal events like stream-end can overtake them and flip the message back to partial\n        // in the frontend event processor.\n        bufferedLiveStreamMessages.push(message);\n        return;\n      }\n\n      // Track replayed deltas so we can skip replay/live duplicates (P2).\n      if (isReplayBufferedDeltaMessage(message)) {\n        noteReplayedDelta(message);\n      }\n    }\n\n    push(message);\n  };\n\n  const finishReplay = () => {\n    // Flush buffered live stream messages after replay (`caught-up` already queued by replayHistory).\n    for (const message of bufferedLiveStreamMessages) {\n      if (isReplayBufferedDeltaMessage(message) && shouldDropBufferedDelta(message)) {\n        continue;\n      }\n      push(message);\n    }\n\n    isReplaying = false;\n\n    // Avoid retaining replay delta keys (including delta text) for the lifetime of the subscription.\n    replayedDeltaKeyCounts.clear();\n    bufferedLiveStreamMessages.length = 0;\n  };\n\n  return { handleSessionMessage, finishReplay };\n}\n"]}