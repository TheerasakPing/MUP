{"version":3,"file":"Runtime.js","sourceRoot":"","sources":["../../../src/node/runtime/Runtime.ts"],"names":[],"mappings":";;;AA4UA;;GAEG;AACU,QAAA,4BAA4B,GAAG,mDAAmD,CAAC;AAuRhG;;GAEG;AACH,kBAA0B,SAAQ,KAAK;IAGnB,IAAI;IACJ,KAAK;IAHvB,YACE,OAAe,EACC,IAAgD,EAChD,KAAa,EAC7B;QACA,KAAK,CAAC,OAAO,CAAC,CAAC;oBAHC,IAAI;qBACJ,KAAK;QAGrB,IAAI,CAAC,IAAI,GAAG,cAAc,CAAC;IAAA,CAC5B;CACF","sourcesContent":["import type { RuntimeConfig, RuntimeAvailabilityStatus } from \"@/common/types/runtime\";\nimport type { RuntimeStatusEvent as StreamRuntimeStatusEvent } from \"@/common/types/stream\";\nimport type { Result } from \"@/common/types/result\";\n\n/**\n * Runtime abstraction for executing tools in different environments.\n *\n * DESIGN PRINCIPLE: Keep this interface minimal and low-level.\n * - Prefer streaming primitives over buffered APIs\n * - Implement shared helpers (utils/runtime/) that work across all runtimes\n * - Avoid duplicating helper logic in each runtime implementation\n *\n * This interface allows tools to run locally, in Docker containers, over SSH, etc.\n */\n\n/**\n * PATH TERMINOLOGY & HIERARCHY\n *\n * srcBaseDir (base directory for all workspaces):\n *   - Where mux stores ALL workspace directories\n *   - Local: ~/.mux/src (tilde expanded to full path by LocalRuntime)\n *   - SSH: /home/user/workspace (tilde paths are allowed and are resolved before use)\n *\n * Workspace Path Computation:\n *   {srcBaseDir}/{projectName}/{workspaceName}\n *\n *   - projectName: basename(projectPath)\n *     Example: \"/Users/me/git/my-project\" → \"my-project\"\n *\n *   - workspaceName: branch name or custom name\n *     Example: \"feature-123\" or \"main\"\n *\n * Full Example (Local):\n *   srcBaseDir:    ~/.mux/src (expanded to /home/user/.mux/src)\n *   projectPath:   /Users/me/git/my-project (local git repo)\n *   projectName:   my-project (extracted)\n *   workspaceName: feature-123\n *   → Workspace:   /home/user/.mux/src/my-project/feature-123\n *\n * Full Example (SSH):\n *   srcBaseDir:    /home/user/workspace (absolute path required)\n *   projectPath:   /Users/me/git/my-project (local git repo)\n *   projectName:   my-project (extracted)\n *   workspaceName: feature-123\n *   → Workspace:   /home/user/workspace/my-project/feature-123\n */\n\n/**\n * Options for executing a command\n */\nexport interface ExecOptions {\n  /** Working directory for command execution */\n  cwd: string;\n  /** Environment variables to inject */\n  env?: Record<string, string>;\n  /**\n   * Timeout in seconds.\n   *\n   * When provided, prevents zombie processes by ensuring spawned processes are killed.\n   * Even long-running commands should have a reasonable upper bound (e.g., 3600s for 1 hour).\n   *\n   * When omitted, no timeout is applied - use only for internal operations like\n   * spawning background processes that are designed to run indefinitely.\n   */\n  timeout?: number;\n  /** Abort signal for cancellation */\n  abortSignal?: AbortSignal;\n  /** Force PTY allocation (SSH only - adds -t flag) */\n  forcePTY?: boolean;\n}\n\n/**\n * Handle to a background process.\n * Abstracts away whether process is local or remote.\n *\n * Output is written directly to a unified output.log file by shell redirection.\n * This handle is for lifecycle management and output directory operations.\n */\nexport interface BackgroundHandle {\n  /** Output directory containing output.log, meta.json, exit_code */\n  readonly outputDir: string;\n\n  /**\n   * Get the exit code if the process has exited.\n   * Returns null if still running.\n   * Async because SSH needs to read remote exit_code file.\n   */\n  getExitCode(): Promise<number | null>;\n\n  /**\n   * Terminate the process (SIGTERM → wait → SIGKILL).\n   */\n  terminate(): Promise<void>;\n\n  /**\n   * Clean up resources (called after process exits or on error).\n   */\n  dispose(): Promise<void>;\n\n  /**\n   * Write meta.json to the output directory.\n   */\n  writeMeta(metaJson: string): Promise<void>;\n\n  /**\n   * Get the current size of output.log in bytes.\n   * Used to tail output without reading the entire file.\n   */\n  getOutputFileSize(): Promise<number>;\n\n  /**\n   * Read output from output.log at the given byte offset.\n   * Returns the content read and the new offset (for incremental reads).\n   * Works on both local and SSH runtimes by using runtime.exec() internally.\n   */\n  readOutput(offset: number): Promise<{ content: string; newOffset: number }>;\n}\n\n/**\n * Streaming result from executing a command\n */\nexport interface ExecStream {\n  /** Standard output stream */\n  stdout: ReadableStream<Uint8Array>;\n  /** Standard error stream */\n  stderr: ReadableStream<Uint8Array>;\n  /** Standard input stream */\n  stdin: WritableStream<Uint8Array>;\n  /** Promise that resolves with exit code when process completes */\n  exitCode: Promise<number>;\n  /** Promise that resolves with wall clock duration in milliseconds */\n  duration: Promise<number>;\n}\n\n/**\n * File statistics\n */\nexport interface FileStat {\n  /** File size in bytes */\n  size: number;\n  /** Last modified time */\n  modifiedTime: Date;\n  /** True if path is a directory (false implies regular file for our purposes) */\n  isDirectory: boolean;\n}\n\n/**\n * Logger for streaming workspace initialization events to frontend.\n * Used to report progress during workspace creation and init hook execution.\n */\nexport interface InitLogger {\n  /** Log a creation step (e.g., \"Creating worktree\", \"Syncing files\") */\n  logStep(message: string): void;\n  /** Log stdout line from init hook */\n  logStdout(line: string): void;\n  /** Log stderr line from init hook */\n  logStderr(line: string): void;\n  /** Report init hook completion */\n  logComplete(exitCode: number): void;\n  /** Signal that the init hook is about to run (starts timeout window). */\n  enterHookPhase?(): void;\n}\n\n/**\n * Parameters for workspace creation\n */\nexport interface WorkspaceCreationParams {\n  /** Absolute path to project directory on local machine */\n  projectPath: string;\n  /** Branch name to checkout in workspace */\n  branchName: string;\n  /** Trunk branch to base new branches on */\n  trunkBranch: string;\n  /** Directory name to use for workspace (typically branch name) */\n  directoryName: string;\n  /** Logger for streaming creation progress and init hook output */\n  initLogger: InitLogger;\n  /** Optional abort signal for cancellation */\n  abortSignal?: AbortSignal;\n}\n\n/**\n * Result from workspace creation\n */\nexport interface WorkspaceCreationResult {\n  success: boolean;\n  /** Absolute path to workspace (local path for LocalRuntime, remote path for SSHRuntime) */\n  workspacePath?: string;\n  error?: string;\n}\n\n/**\n * Parameters for workspace initialization\n */\nexport interface WorkspaceInitParams {\n  /** Absolute path to project directory on local machine */\n  projectPath: string;\n  /** Branch name to checkout in workspace */\n  branchName: string;\n  /** Trunk branch to base new branches on */\n  trunkBranch: string;\n  /** Absolute path to workspace (from createWorkspace result) */\n  workspacePath: string;\n  /** Logger for streaming initialization progress and output */\n  initLogger: InitLogger;\n  /** Optional abort signal for cancellation */\n  abortSignal?: AbortSignal;\n  /** Environment variables to inject (MUX_ vars + secrets) */\n  env?: Record<string, string>;\n\n  /**\n   * When true, skip running the project's .mux/init hook.\n   *\n   * NOTE: This skips only hook execution, not runtime provisioning.\n   */\n  skipInitHook?: boolean;\n}\n\n/**\n * Result from workspace initialization\n */\nexport interface WorkspaceInitResult {\n  success: boolean;\n  error?: string;\n}\n\n/**\n * Runtime interface - minimal, low-level abstraction for tool execution environments.\n *\n * All methods return streaming primitives for memory efficiency.\n * Use helpers in utils/runtime/ for convenience wrappers (e.g., readFileString, execBuffered).\n\n/**\n * Parameters for forking an existing workspace\n */\nexport interface WorkspaceForkParams {\n  /** Project root path (local path) */\n  projectPath: string;\n  /** Name of the source workspace to fork from */\n  sourceWorkspaceName: string;\n  /** Name for the new workspace */\n  newWorkspaceName: string;\n  /** Logger for streaming initialization events */\n  initLogger: InitLogger;\n  /** Signal to abort long-running operations (e.g. cp -R -P or git worktree add) */\n  abortSignal?: AbortSignal;\n}\n\n/**\n * Result of forking a workspace\n */\nexport interface WorkspaceForkResult {\n  /** Whether the fork operation succeeded */\n  success: boolean;\n  /** Path to the new workspace (if successful) */\n  workspacePath?: string;\n  /** Branch that was forked from */\n  sourceBranch?: string;\n  /** Error message (if failed) */\n  error?: string;\n  /** Runtime config for the forked workspace (if different from source) */\n  forkedRuntimeConfig?: RuntimeConfig;\n  /** Updated runtime config for source workspace (e.g., mark as shared) */\n  sourceRuntimeConfig?: RuntimeConfig;\n  /**\n   * When true and success=false, don't fall back to createWorkspace.\n   * Use when the runtime provisions shared infrastructure that subagents must share.\n   */\n  failureIsFatal?: boolean;\n}\n\n/**\n * Flags that control workspace creation behavior in WorkspaceService.\n * Allows runtimes to customize the create flow without WorkspaceService\n * needing runtime-specific conditionals.\n */\nexport interface RuntimeCreateFlags {\n  /**\n   * Skip srcBaseDir resolution before createWorkspace.\n   * Use when runtime access doesn't exist until postCreateSetup (e.g., Coder).\n   */\n  deferredRuntimeAccess?: boolean;\n\n  /**\n   * Use config-level collision detection instead of runtime.createWorkspace.\n   * Use when createWorkspace can't detect existing workspaces (host doesn't exist).\n   */\n  configLevelCollisionDetection?: boolean;\n}\n\n/**\n * Runtime status update payload for ensureReady progress.\n *\n * Derived from the stream schema type to keep phase/runtimeType/detail consistent\n * across backend + frontend.\n */\nexport type RuntimeStatusEvent = Pick<StreamRuntimeStatusEvent, \"phase\" | \"runtimeType\" | \"detail\">;\n\n/**\n * Callback for runtime status updates during ensureReady().\n */\nexport type RuntimeStatusSink = (status: RuntimeStatusEvent) => void;\n\n/**\n * Options for ensureReady().\n */\nexport interface EnsureReadyOptions {\n  /**\n   * Callback to emit runtime-status events for UX feedback.\n   * Coder uses this to show \"Starting Coder workspace...\" during boot.\n   */\n  statusSink?: RuntimeStatusSink;\n\n  /**\n   * Abort signal to cancel long-running operations.\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * Result of ensureReady().\n * Distinguishes between permanent failures (runtime_not_ready) and\n * transient failures (runtime_start_failed) for retry logic.\n */\nexport type EnsureReadyResult =\n  | { ready: true }\n  | {\n      ready: false;\n      error: string;\n      errorType: \"runtime_not_ready\" | \"runtime_start_failed\";\n    };\n\n/**\n * Shared error message for missing repositories during runtime readiness checks.\n */\nexport const WORKSPACE_REPO_MISSING_ERROR = \"Workspace setup incomplete: repository not found.\";\n\n/**\n * Runtime interface - minimal, low-level abstraction for tool execution environments.\n *\n * All methods return streaming primitives for memory efficiency.\n * Use helpers in utils/runtime/ for convenience wrappers (e.g., readFileString, execBuffered).\n */\nexport interface Runtime {\n  /**\n   * Flags that control workspace creation behavior.\n   * If not provided, defaults to standard behavior (no flags set).\n   */\n  readonly createFlags?: RuntimeCreateFlags;\n  /**\n   * Execute a bash command with streaming I/O\n   * @param command The bash script to execute\n   * @param options Execution options (cwd, env, timeout, etc.)\n   * @returns Promise that resolves to streaming handles for stdin/stdout/stderr and completion promises\n   * @throws RuntimeError if execution fails in an unrecoverable way\n   */\n  exec(command: string, options: ExecOptions): Promise<ExecStream>;\n\n  /**\n   * Read file contents as a stream\n   * @param path Absolute or relative path to file\n   * @param abortSignal Optional abort signal for cancellation\n   * @returns Readable stream of file contents\n   * @throws RuntimeError if file cannot be read\n   */\n  readFile(path: string, abortSignal?: AbortSignal): ReadableStream<Uint8Array>;\n\n  /**\n   * Write file contents atomically from a stream\n   * @param path Absolute or relative path to file\n   * @param abortSignal Optional abort signal for cancellation\n   * @returns Writable stream for file contents\n   * @throws RuntimeError if file cannot be written\n   */\n  writeFile(path: string, abortSignal?: AbortSignal): WritableStream<Uint8Array>;\n\n  /**\n   * Get file statistics\n   * @param path Absolute or relative path to file/directory\n   * @param abortSignal Optional abort signal for cancellation\n   * @returns File statistics\n   * @throws RuntimeError if path does not exist or cannot be accessed\n   */\n  stat(path: string, abortSignal?: AbortSignal): Promise<FileStat>;\n\n  /**\n   * Ensure a directory exists (mkdir -p semantics).\n   *\n   * This intentionally lives on the Runtime abstraction so local runtimes can use\n   * Node fs APIs (Windows-safe) while remote runtimes can use shell commands.\n   */\n  ensureDir(path: string): Promise<void>;\n\n  /**\n   * Resolve a path to its absolute, canonical form (expanding tildes, resolving symlinks, etc.).\n   * This is used at workspace creation time to normalize srcBaseDir paths in config.\n   *\n   * @param path Path to resolve (may contain tildes or be relative)\n   * @returns Promise resolving to absolute path\n   * @throws RuntimeError if path cannot be resolved (e.g., doesn't exist, permission denied)\n   *\n   * @example\n   * // LocalRuntime\n   * await runtime.resolvePath(\"~/mux\")      // => \"/home/user/mux\"\n   * await runtime.resolvePath(\"./relative\")  // => \"/current/dir/relative\"\n   *\n   * // SSHRuntime\n   * await runtime.resolvePath(\"~/mux\")      // => \"/home/user/mux\" (via SSH shell expansion)\n   */\n  resolvePath(path: string): Promise<string>;\n\n  /**\n   * Normalize a path for comparison purposes within this runtime's context.\n   * Handles runtime-specific path semantics (local vs remote).\n   *\n   * @param targetPath Path to normalize (may be relative or absolute)\n   * @param basePath Base path to resolve relative paths against\n   * @returns Normalized path suitable for string comparison\n   *\n   * @example\n   * // LocalRuntime\n   * runtime.normalizePath(\".\", \"/home/user\") // => \"/home/user\"\n   * runtime.normalizePath(\"../other\", \"/home/user/project\") // => \"/home/user/other\"\n   *\n   * // SSHRuntime\n   * runtime.normalizePath(\".\", \"/home/user\") // => \"/home/user\"\n   * runtime.normalizePath(\"~/project\", \"~\") // => \"~/project\"\n   */\n  normalizePath(targetPath: string, basePath: string): string;\n\n  /**\n   * Compute absolute workspace path from project and workspace name.\n   * This is the SINGLE source of truth for workspace path computation.\n   *\n   * - LocalRuntime: {workdir}/{project-name}/{workspace-name}\n   * - SSHRuntime: {workdir}/{project-name}/{workspace-name}\n   *\n   * All Runtime methods (create, delete, rename) MUST use this method internally\n   * to ensure consistent path computation.\n   *\n   * @param projectPath Project root path (local path, used to extract project name)\n   * @param workspaceName Workspace name (typically branch name)\n   * @returns Absolute path to workspace directory\n   */\n  getWorkspacePath(projectPath: string, workspaceName: string): string;\n\n  /**\n   * Create a workspace for this runtime (fast, returns immediately)\n   * - LocalRuntime: Creates git worktree\n   * - SSHRuntime: Creates remote directory only\n   * Does NOT run init hook or sync files.\n   * @param params Workspace creation parameters\n   * @returns Result with workspace path or error\n   */\n  createWorkspace(params: WorkspaceCreationParams): Promise<WorkspaceCreationResult>;\n\n  /**\n   * Finalize runtime config after collision handling.\n   * Called with final branch name (may have collision suffix).\n   *\n   * Use cases:\n   * - Coder: derive workspace name from branch, compute SSH host\n   *\n   * @param finalBranchName Branch name after collision handling\n   * @param config Current runtime config\n   * @returns Updated runtime config, or error\n   */\n  finalizeConfig?(\n    finalBranchName: string,\n    config: RuntimeConfig\n  ): Promise<Result<RuntimeConfig, string>>;\n\n  /**\n   * Validate before persisting workspace metadata.\n   * Called after finalizeConfig, before editConfig.\n   * May make network calls for external validation.\n   *\n   * Use cases:\n   * - Coder: check if workspace name already exists\n   *\n   * IMPORTANT: This hook runs AFTER createWorkspace(). Only implement this if:\n   * - createWorkspace() is side-effect-free for this runtime, OR\n   * - The runtime can tolerate/clean up side effects on validation failure\n   *\n   * If your runtime's createWorkspace() has side effects (e.g., creates directories)\n   * and validation failure would leave orphaned resources, consider whether those\n   * checks belong in createWorkspace() itself instead.\n   *\n   * @param finalBranchName Branch name after collision handling\n   * @param config Finalized runtime config\n   * @returns Success, or error message\n   */\n  validateBeforePersist?(\n    finalBranchName: string,\n    config: RuntimeConfig\n  ): Promise<Result<void, string>>;\n\n  /**\n   * Optional long-running setup that runs after mux persists workspace metadata.\n   * Used for provisioning steps that must happen before initWorkspace but after\n   * the workspace is registered (e.g., creating Coder workspaces, pulling Docker images).\n   *\n   * Contract:\n   * - MAY take minutes (streams progress via initLogger)\n   * - MUST NOT call initLogger.logComplete() - that's handled by the caller\n   * - On failure: throw; caller will log error and mark init failed\n   * - Runtimes with this hook expect callers to use runFullInit/runBackgroundInit\n   *\n   * @param params Same as initWorkspace params\n   */\n  postCreateSetup?(params: WorkspaceInitParams): Promise<void>;\n\n  /**\n   * Initialize workspace asynchronously (may be slow, streams progress)\n   * - LocalRuntime: Runs init hook if present\n   * - SSHRuntime: Syncs files, checks out branch, runs init hook\n   * Streams progress via initLogger.\n   * @param params Workspace initialization parameters\n   * @returns Result indicating success or error\n   */\n  initWorkspace(params: WorkspaceInitParams): Promise<WorkspaceInitResult>;\n\n  /**\n   * Rename workspace directory\n   * - LocalRuntime: Uses git worktree move (worktrees managed by git)\n   * - SSHRuntime: Uses mv (plain directories on remote, not worktrees)\n   * Runtime computes workspace paths internally from workdir + projectPath + workspace names.\n   * @param projectPath Project root path (local path, used for git commands in LocalRuntime and to extract project name)\n   * @param oldName Current workspace name\n   * @param newName New workspace name\n   * @param abortSignal Optional abort signal for cancellation\n   * @returns Promise resolving to Result with old/new paths on success, or error message\n   */\n  renameWorkspace(\n    projectPath: string,\n    oldName: string,\n    newName: string,\n    abortSignal?: AbortSignal\n  ): Promise<\n    { success: true; oldPath: string; newPath: string } | { success: false; error: string }\n  >;\n\n  /**\n   * Delete workspace directory\n   * - LocalRuntime: Uses git worktree remove (with --force only if force param is true)\n   * - SSHRuntime: Checks for uncommitted changes unless force is true, then uses rm -rf\n   * Runtime computes workspace path internally from workdir + projectPath + workspaceName.\n   *\n   * **CRITICAL: Implementations must NEVER auto-apply --force or skip dirty checks without explicit force=true.**\n   * If workspace has uncommitted changes and force=false, implementations MUST return error.\n   * The force flag is the user's explicit intent - implementations must not override it.\n   *\n   * @param projectPath Project root path (local path, used for git commands in LocalRuntime and to extract project name)\n   * @param workspaceName Workspace name to delete\n   * @param force If true, force deletion even with uncommitted changes or special conditions (submodules, etc.)\n   * @param abortSignal Optional abort signal for cancellation\n   * @returns Promise resolving to Result with deleted path on success, or error message\n   */\n  deleteWorkspace(\n    projectPath: string,\n    workspaceName: string,\n    force: boolean,\n    abortSignal?: AbortSignal\n  ): Promise<{ success: true; deletedPath: string } | { success: false; error: string }>;\n\n  /**\n   * Ensure the runtime is ready for operations.\n   * - LocalRuntime: Always returns ready (no-op)\n   * - DockerRuntime: Starts container if stopped\n   * - SSHRuntime: Could verify connection (future)\n   * - CoderSSHRuntime: Checks workspace status, starts if stopped, waits for ready\n   *\n   * Called automatically by AIService before streaming.\n   *\n   * @param options Optional config: statusSink for progress events, signal for cancellation\n   * @returns Result indicating ready or failure with error type for retry decisions\n   */\n  ensureReady(options?: EnsureReadyOptions): Promise<EnsureReadyResult>;\n\n  /**\n   * Fork an existing workspace to create a new one\n   * Creates a new workspace branching from the source workspace's current branch\n   * - LocalRuntime: Detects source branch via git, creates new worktree from that branch\n   * - SSHRuntime: Currently unimplemented (returns static error)\n   *\n   * @param params Fork parameters (source workspace name, new workspace name, etc.)\n   * @returns Result with new workspace path and source branch, or error\n   */\n  forkWorkspace(params: WorkspaceForkParams): Promise<WorkspaceForkResult>;\n\n  /**\n   * Get the runtime's temp directory (absolute path, resolved).\n   * - LocalRuntime: /tmp (or OS temp dir)\n   * - SSHRuntime: Resolved remote temp dir (e.g., /tmp)\n   *\n   * Used for background process output, temporary files, etc.\n   */\n  tempDir(): Promise<string>;\n\n  /**\n   * Get the mux home directory for this runtime.\n   * Used for storing plan files and other mux-specific data.\n   * - LocalRuntime/SSHRuntime: ~/.mux (tilde expanded by runtime)\n   * - DockerRuntime: /var/mux (world-readable, avoids /root permission issues)\n   */\n  getMuxHome(): string;\n}\n\n/**\n * Result of checking if a runtime type is available for a project.\n * Re-exported for backward compatibility with existing imports.\n */\nexport type RuntimeAvailability = RuntimeAvailabilityStatus;\n\n/**\n * Error thrown by runtime implementations\n */\nexport class RuntimeError extends Error {\n  constructor(\n    message: string,\n    public readonly type: \"exec\" | \"file_io\" | \"network\" | \"unknown\",\n    public readonly cause?: Error\n  ) {\n    super(message);\n    this.name = \"RuntimeError\";\n  }\n}\n"]}