{"version":3,"file":"Runtime.js","sourceRoot":"","sources":["../../../src/node/runtime/Runtime.ts"],"names":[],"mappings":";;;AA4UA;;GAEG;AACU,QAAA,4BAA4B,GAAG,mDAAmD,CAAC;AAuRhG;;GAEG;AACH,kBAA0B,SAAQ,KAAK;IAGnB,IAAI;IACJ,KAAK;IAHvB,YACE,OAAe,EACC,IAAgD,EAChD,KAAa,EAC7B;QACA,KAAK,CAAC,OAAO,CAAC,CAAC;oBAHC,IAAI;qBACJ,KAAK;QAGrB,IAAI,CAAC,IAAI,GAAG,cAAc,CAAC;IAAA,CAC5B;CACF","sourcesContent":["import type { RuntimeConfig, RuntimeAvailabilityStatus } from \"@/common/types/runtime\";\r\nimport type { RuntimeStatusEvent as StreamRuntimeStatusEvent } from \"@/common/types/stream\";\r\nimport type { Result } from \"@/common/types/result\";\r\n\r\n/**\r\n * Runtime abstraction for executing tools in different environments.\r\n *\r\n * DESIGN PRINCIPLE: Keep this interface minimal and low-level.\r\n * - Prefer streaming primitives over buffered APIs\r\n * - Implement shared helpers (utils/runtime/) that work across all runtimes\r\n * - Avoid duplicating helper logic in each runtime implementation\r\n *\r\n * This interface allows tools to run locally, in Docker containers, over SSH, etc.\r\n */\r\n\r\n/**\r\n * PATH TERMINOLOGY & HIERARCHY\r\n *\r\n * srcBaseDir (base directory for all workspaces):\r\n *   - Where mux stores ALL workspace directories\r\n *   - Local: ~/.mux/src (tilde expanded to full path by LocalRuntime)\r\n *   - SSH: /home/user/workspace (tilde paths are allowed and are resolved before use)\r\n *\r\n * Workspace Path Computation:\r\n *   {srcBaseDir}/{projectName}/{workspaceName}\r\n *\r\n *   - projectName: basename(projectPath)\r\n *     Example: \"/Users/me/git/my-project\" → \"my-project\"\r\n *\r\n *   - workspaceName: branch name or custom name\r\n *     Example: \"feature-123\" or \"main\"\r\n *\r\n * Full Example (Local):\r\n *   srcBaseDir:    ~/.mux/src (expanded to /home/user/.mux/src)\r\n *   projectPath:   /Users/me/git/my-project (local git repo)\r\n *   projectName:   my-project (extracted)\r\n *   workspaceName: feature-123\r\n *   → Workspace:   /home/user/.mux/src/my-project/feature-123\r\n *\r\n * Full Example (SSH):\r\n *   srcBaseDir:    /home/user/workspace (absolute path required)\r\n *   projectPath:   /Users/me/git/my-project (local git repo)\r\n *   projectName:   my-project (extracted)\r\n *   workspaceName: feature-123\r\n *   → Workspace:   /home/user/workspace/my-project/feature-123\r\n */\r\n\r\n/**\r\n * Options for executing a command\r\n */\r\nexport interface ExecOptions {\r\n  /** Working directory for command execution */\r\n  cwd: string;\r\n  /** Environment variables to inject */\r\n  env?: Record<string, string>;\r\n  /**\r\n   * Timeout in seconds.\r\n   *\r\n   * When provided, prevents zombie processes by ensuring spawned processes are killed.\r\n   * Even long-running commands should have a reasonable upper bound (e.g., 3600s for 1 hour).\r\n   *\r\n   * When omitted, no timeout is applied - use only for internal operations like\r\n   * spawning background processes that are designed to run indefinitely.\r\n   */\r\n  timeout?: number;\r\n  /** Abort signal for cancellation */\r\n  abortSignal?: AbortSignal;\r\n  /** Force PTY allocation (SSH only - adds -t flag) */\r\n  forcePTY?: boolean;\r\n}\r\n\r\n/**\r\n * Handle to a background process.\r\n * Abstracts away whether process is local or remote.\r\n *\r\n * Output is written directly to a unified output.log file by shell redirection.\r\n * This handle is for lifecycle management and output directory operations.\r\n */\r\nexport interface BackgroundHandle {\r\n  /** Output directory containing output.log, meta.json, exit_code */\r\n  readonly outputDir: string;\r\n\r\n  /**\r\n   * Get the exit code if the process has exited.\r\n   * Returns null if still running.\r\n   * Async because SSH needs to read remote exit_code file.\r\n   */\r\n  getExitCode(): Promise<number | null>;\r\n\r\n  /**\r\n   * Terminate the process (SIGTERM → wait → SIGKILL).\r\n   */\r\n  terminate(): Promise<void>;\r\n\r\n  /**\r\n   * Clean up resources (called after process exits or on error).\r\n   */\r\n  dispose(): Promise<void>;\r\n\r\n  /**\r\n   * Write meta.json to the output directory.\r\n   */\r\n  writeMeta(metaJson: string): Promise<void>;\r\n\r\n  /**\r\n   * Get the current size of output.log in bytes.\r\n   * Used to tail output without reading the entire file.\r\n   */\r\n  getOutputFileSize(): Promise<number>;\r\n\r\n  /**\r\n   * Read output from output.log at the given byte offset.\r\n   * Returns the content read and the new offset (for incremental reads).\r\n   * Works on both local and SSH runtimes by using runtime.exec() internally.\r\n   */\r\n  readOutput(offset: number): Promise<{ content: string; newOffset: number }>;\r\n}\r\n\r\n/**\r\n * Streaming result from executing a command\r\n */\r\nexport interface ExecStream {\r\n  /** Standard output stream */\r\n  stdout: ReadableStream<Uint8Array>;\r\n  /** Standard error stream */\r\n  stderr: ReadableStream<Uint8Array>;\r\n  /** Standard input stream */\r\n  stdin: WritableStream<Uint8Array>;\r\n  /** Promise that resolves with exit code when process completes */\r\n  exitCode: Promise<number>;\r\n  /** Promise that resolves with wall clock duration in milliseconds */\r\n  duration: Promise<number>;\r\n}\r\n\r\n/**\r\n * File statistics\r\n */\r\nexport interface FileStat {\r\n  /** File size in bytes */\r\n  size: number;\r\n  /** Last modified time */\r\n  modifiedTime: Date;\r\n  /** True if path is a directory (false implies regular file for our purposes) */\r\n  isDirectory: boolean;\r\n}\r\n\r\n/**\r\n * Logger for streaming workspace initialization events to frontend.\r\n * Used to report progress during workspace creation and init hook execution.\r\n */\r\nexport interface InitLogger {\r\n  /** Log a creation step (e.g., \"Creating worktree\", \"Syncing files\") */\r\n  logStep(message: string): void;\r\n  /** Log stdout line from init hook */\r\n  logStdout(line: string): void;\r\n  /** Log stderr line from init hook */\r\n  logStderr(line: string): void;\r\n  /** Report init hook completion */\r\n  logComplete(exitCode: number): void;\r\n  /** Signal that the init hook is about to run (starts timeout window). */\r\n  enterHookPhase?(): void;\r\n}\r\n\r\n/**\r\n * Parameters for workspace creation\r\n */\r\nexport interface WorkspaceCreationParams {\r\n  /** Absolute path to project directory on local machine */\r\n  projectPath: string;\r\n  /** Branch name to checkout in workspace */\r\n  branchName: string;\r\n  /** Trunk branch to base new branches on */\r\n  trunkBranch: string;\r\n  /** Directory name to use for workspace (typically branch name) */\r\n  directoryName: string;\r\n  /** Logger for streaming creation progress and init hook output */\r\n  initLogger: InitLogger;\r\n  /** Optional abort signal for cancellation */\r\n  abortSignal?: AbortSignal;\r\n}\r\n\r\n/**\r\n * Result from workspace creation\r\n */\r\nexport interface WorkspaceCreationResult {\r\n  success: boolean;\r\n  /** Absolute path to workspace (local path for LocalRuntime, remote path for SSHRuntime) */\r\n  workspacePath?: string;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Parameters for workspace initialization\r\n */\r\nexport interface WorkspaceInitParams {\r\n  /** Absolute path to project directory on local machine */\r\n  projectPath: string;\r\n  /** Branch name to checkout in workspace */\r\n  branchName: string;\r\n  /** Trunk branch to base new branches on */\r\n  trunkBranch: string;\r\n  /** Absolute path to workspace (from createWorkspace result) */\r\n  workspacePath: string;\r\n  /** Logger for streaming initialization progress and output */\r\n  initLogger: InitLogger;\r\n  /** Optional abort signal for cancellation */\r\n  abortSignal?: AbortSignal;\r\n  /** Environment variables to inject (MUX_ vars + secrets) */\r\n  env?: Record<string, string>;\r\n\r\n  /**\r\n   * When true, skip running the project's .mux/init hook.\r\n   *\r\n   * NOTE: This skips only hook execution, not runtime provisioning.\r\n   */\r\n  skipInitHook?: boolean;\r\n}\r\n\r\n/**\r\n * Result from workspace initialization\r\n */\r\nexport interface WorkspaceInitResult {\r\n  success: boolean;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Runtime interface - minimal, low-level abstraction for tool execution environments.\r\n *\r\n * All methods return streaming primitives for memory efficiency.\r\n * Use helpers in utils/runtime/ for convenience wrappers (e.g., readFileString, execBuffered).\r\n\r\n/**\r\n * Parameters for forking an existing workspace\r\n */\r\nexport interface WorkspaceForkParams {\r\n  /** Project root path (local path) */\r\n  projectPath: string;\r\n  /** Name of the source workspace to fork from */\r\n  sourceWorkspaceName: string;\r\n  /** Name for the new workspace */\r\n  newWorkspaceName: string;\r\n  /** Logger for streaming initialization events */\r\n  initLogger: InitLogger;\r\n  /** Signal to abort long-running operations (e.g. cp -R -P or git worktree add) */\r\n  abortSignal?: AbortSignal;\r\n}\r\n\r\n/**\r\n * Result of forking a workspace\r\n */\r\nexport interface WorkspaceForkResult {\r\n  /** Whether the fork operation succeeded */\r\n  success: boolean;\r\n  /** Path to the new workspace (if successful) */\r\n  workspacePath?: string;\r\n  /** Branch that was forked from */\r\n  sourceBranch?: string;\r\n  /** Error message (if failed) */\r\n  error?: string;\r\n  /** Runtime config for the forked workspace (if different from source) */\r\n  forkedRuntimeConfig?: RuntimeConfig;\r\n  /** Updated runtime config for source workspace (e.g., mark as shared) */\r\n  sourceRuntimeConfig?: RuntimeConfig;\r\n  /**\r\n   * When true and success=false, don't fall back to createWorkspace.\r\n   * Use when the runtime provisions shared infrastructure that subagents must share.\r\n   */\r\n  failureIsFatal?: boolean;\r\n}\r\n\r\n/**\r\n * Flags that control workspace creation behavior in WorkspaceService.\r\n * Allows runtimes to customize the create flow without WorkspaceService\r\n * needing runtime-specific conditionals.\r\n */\r\nexport interface RuntimeCreateFlags {\r\n  /**\r\n   * Skip srcBaseDir resolution before createWorkspace.\r\n   * Use when runtime access doesn't exist until postCreateSetup (e.g., Coder).\r\n   */\r\n  deferredRuntimeAccess?: boolean;\r\n\r\n  /**\r\n   * Use config-level collision detection instead of runtime.createWorkspace.\r\n   * Use when createWorkspace can't detect existing workspaces (host doesn't exist).\r\n   */\r\n  configLevelCollisionDetection?: boolean;\r\n}\r\n\r\n/**\r\n * Runtime status update payload for ensureReady progress.\r\n *\r\n * Derived from the stream schema type to keep phase/runtimeType/detail consistent\r\n * across backend + frontend.\r\n */\r\nexport type RuntimeStatusEvent = Pick<StreamRuntimeStatusEvent, \"phase\" | \"runtimeType\" | \"detail\">;\r\n\r\n/**\r\n * Callback for runtime status updates during ensureReady().\r\n */\r\nexport type RuntimeStatusSink = (status: RuntimeStatusEvent) => void;\r\n\r\n/**\r\n * Options for ensureReady().\r\n */\r\nexport interface EnsureReadyOptions {\r\n  /**\r\n   * Callback to emit runtime-status events for UX feedback.\r\n   * Coder uses this to show \"Starting Coder workspace...\" during boot.\r\n   */\r\n  statusSink?: RuntimeStatusSink;\r\n\r\n  /**\r\n   * Abort signal to cancel long-running operations.\r\n   */\r\n  signal?: AbortSignal;\r\n}\r\n\r\n/**\r\n * Result of ensureReady().\r\n * Distinguishes between permanent failures (runtime_not_ready) and\r\n * transient failures (runtime_start_failed) for retry logic.\r\n */\r\nexport type EnsureReadyResult =\r\n  | { ready: true }\r\n  | {\r\n      ready: false;\r\n      error: string;\r\n      errorType: \"runtime_not_ready\" | \"runtime_start_failed\";\r\n    };\r\n\r\n/**\r\n * Shared error message for missing repositories during runtime readiness checks.\r\n */\r\nexport const WORKSPACE_REPO_MISSING_ERROR = \"Workspace setup incomplete: repository not found.\";\r\n\r\n/**\r\n * Runtime interface - minimal, low-level abstraction for tool execution environments.\r\n *\r\n * All methods return streaming primitives for memory efficiency.\r\n * Use helpers in utils/runtime/ for convenience wrappers (e.g., readFileString, execBuffered).\r\n */\r\nexport interface Runtime {\r\n  /**\r\n   * Flags that control workspace creation behavior.\r\n   * If not provided, defaults to standard behavior (no flags set).\r\n   */\r\n  readonly createFlags?: RuntimeCreateFlags;\r\n  /**\r\n   * Execute a bash command with streaming I/O\r\n   * @param command The bash script to execute\r\n   * @param options Execution options (cwd, env, timeout, etc.)\r\n   * @returns Promise that resolves to streaming handles for stdin/stdout/stderr and completion promises\r\n   * @throws RuntimeError if execution fails in an unrecoverable way\r\n   */\r\n  exec(command: string, options: ExecOptions): Promise<ExecStream>;\r\n\r\n  /**\r\n   * Read file contents as a stream\r\n   * @param path Absolute or relative path to file\r\n   * @param abortSignal Optional abort signal for cancellation\r\n   * @returns Readable stream of file contents\r\n   * @throws RuntimeError if file cannot be read\r\n   */\r\n  readFile(path: string, abortSignal?: AbortSignal): ReadableStream<Uint8Array>;\r\n\r\n  /**\r\n   * Write file contents atomically from a stream\r\n   * @param path Absolute or relative path to file\r\n   * @param abortSignal Optional abort signal for cancellation\r\n   * @returns Writable stream for file contents\r\n   * @throws RuntimeError if file cannot be written\r\n   */\r\n  writeFile(path: string, abortSignal?: AbortSignal): WritableStream<Uint8Array>;\r\n\r\n  /**\r\n   * Get file statistics\r\n   * @param path Absolute or relative path to file/directory\r\n   * @param abortSignal Optional abort signal for cancellation\r\n   * @returns File statistics\r\n   * @throws RuntimeError if path does not exist or cannot be accessed\r\n   */\r\n  stat(path: string, abortSignal?: AbortSignal): Promise<FileStat>;\r\n\r\n  /**\r\n   * Ensure a directory exists (mkdir -p semantics).\r\n   *\r\n   * This intentionally lives on the Runtime abstraction so local runtimes can use\r\n   * Node fs APIs (Windows-safe) while remote runtimes can use shell commands.\r\n   */\r\n  ensureDir(path: string): Promise<void>;\r\n\r\n  /**\r\n   * Resolve a path to its absolute, canonical form (expanding tildes, resolving symlinks, etc.).\r\n   * This is used at workspace creation time to normalize srcBaseDir paths in config.\r\n   *\r\n   * @param path Path to resolve (may contain tildes or be relative)\r\n   * @returns Promise resolving to absolute path\r\n   * @throws RuntimeError if path cannot be resolved (e.g., doesn't exist, permission denied)\r\n   *\r\n   * @example\r\n   * // LocalRuntime\r\n   * await runtime.resolvePath(\"~/mux\")      // => \"/home/user/mux\"\r\n   * await runtime.resolvePath(\"./relative\")  // => \"/current/dir/relative\"\r\n   *\r\n   * // SSHRuntime\r\n   * await runtime.resolvePath(\"~/mux\")      // => \"/home/user/mux\" (via SSH shell expansion)\r\n   */\r\n  resolvePath(path: string): Promise<string>;\r\n\r\n  /**\r\n   * Normalize a path for comparison purposes within this runtime's context.\r\n   * Handles runtime-specific path semantics (local vs remote).\r\n   *\r\n   * @param targetPath Path to normalize (may be relative or absolute)\r\n   * @param basePath Base path to resolve relative paths against\r\n   * @returns Normalized path suitable for string comparison\r\n   *\r\n   * @example\r\n   * // LocalRuntime\r\n   * runtime.normalizePath(\".\", \"/home/user\") // => \"/home/user\"\r\n   * runtime.normalizePath(\"../other\", \"/home/user/project\") // => \"/home/user/other\"\r\n   *\r\n   * // SSHRuntime\r\n   * runtime.normalizePath(\".\", \"/home/user\") // => \"/home/user\"\r\n   * runtime.normalizePath(\"~/project\", \"~\") // => \"~/project\"\r\n   */\r\n  normalizePath(targetPath: string, basePath: string): string;\r\n\r\n  /**\r\n   * Compute absolute workspace path from project and workspace name.\r\n   * This is the SINGLE source of truth for workspace path computation.\r\n   *\r\n   * - LocalRuntime: {workdir}/{project-name}/{workspace-name}\r\n   * - SSHRuntime: {workdir}/{project-name}/{workspace-name}\r\n   *\r\n   * All Runtime methods (create, delete, rename) MUST use this method internally\r\n   * to ensure consistent path computation.\r\n   *\r\n   * @param projectPath Project root path (local path, used to extract project name)\r\n   * @param workspaceName Workspace name (typically branch name)\r\n   * @returns Absolute path to workspace directory\r\n   */\r\n  getWorkspacePath(projectPath: string, workspaceName: string): string;\r\n\r\n  /**\r\n   * Create a workspace for this runtime (fast, returns immediately)\r\n   * - LocalRuntime: Creates git worktree\r\n   * - SSHRuntime: Creates remote directory only\r\n   * Does NOT run init hook or sync files.\r\n   * @param params Workspace creation parameters\r\n   * @returns Result with workspace path or error\r\n   */\r\n  createWorkspace(params: WorkspaceCreationParams): Promise<WorkspaceCreationResult>;\r\n\r\n  /**\r\n   * Finalize runtime config after collision handling.\r\n   * Called with final branch name (may have collision suffix).\r\n   *\r\n   * Use cases:\r\n   * - Coder: derive workspace name from branch, compute SSH host\r\n   *\r\n   * @param finalBranchName Branch name after collision handling\r\n   * @param config Current runtime config\r\n   * @returns Updated runtime config, or error\r\n   */\r\n  finalizeConfig?(\r\n    finalBranchName: string,\r\n    config: RuntimeConfig\r\n  ): Promise<Result<RuntimeConfig, string>>;\r\n\r\n  /**\r\n   * Validate before persisting workspace metadata.\r\n   * Called after finalizeConfig, before editConfig.\r\n   * May make network calls for external validation.\r\n   *\r\n   * Use cases:\r\n   * - Coder: check if workspace name already exists\r\n   *\r\n   * IMPORTANT: This hook runs AFTER createWorkspace(). Only implement this if:\r\n   * - createWorkspace() is side-effect-free for this runtime, OR\r\n   * - The runtime can tolerate/clean up side effects on validation failure\r\n   *\r\n   * If your runtime's createWorkspace() has side effects (e.g., creates directories)\r\n   * and validation failure would leave orphaned resources, consider whether those\r\n   * checks belong in createWorkspace() itself instead.\r\n   *\r\n   * @param finalBranchName Branch name after collision handling\r\n   * @param config Finalized runtime config\r\n   * @returns Success, or error message\r\n   */\r\n  validateBeforePersist?(\r\n    finalBranchName: string,\r\n    config: RuntimeConfig\r\n  ): Promise<Result<void, string>>;\r\n\r\n  /**\r\n   * Optional long-running setup that runs after mux persists workspace metadata.\r\n   * Used for provisioning steps that must happen before initWorkspace but after\r\n   * the workspace is registered (e.g., creating Coder workspaces, pulling Docker images).\r\n   *\r\n   * Contract:\r\n   * - MAY take minutes (streams progress via initLogger)\r\n   * - MUST NOT call initLogger.logComplete() - that's handled by the caller\r\n   * - On failure: throw; caller will log error and mark init failed\r\n   * - Runtimes with this hook expect callers to use runFullInit/runBackgroundInit\r\n   *\r\n   * @param params Same as initWorkspace params\r\n   */\r\n  postCreateSetup?(params: WorkspaceInitParams): Promise<void>;\r\n\r\n  /**\r\n   * Initialize workspace asynchronously (may be slow, streams progress)\r\n   * - LocalRuntime: Runs init hook if present\r\n   * - SSHRuntime: Syncs files, checks out branch, runs init hook\r\n   * Streams progress via initLogger.\r\n   * @param params Workspace initialization parameters\r\n   * @returns Result indicating success or error\r\n   */\r\n  initWorkspace(params: WorkspaceInitParams): Promise<WorkspaceInitResult>;\r\n\r\n  /**\r\n   * Rename workspace directory\r\n   * - LocalRuntime: Uses git worktree move (worktrees managed by git)\r\n   * - SSHRuntime: Uses mv (plain directories on remote, not worktrees)\r\n   * Runtime computes workspace paths internally from workdir + projectPath + workspace names.\r\n   * @param projectPath Project root path (local path, used for git commands in LocalRuntime and to extract project name)\r\n   * @param oldName Current workspace name\r\n   * @param newName New workspace name\r\n   * @param abortSignal Optional abort signal for cancellation\r\n   * @returns Promise resolving to Result with old/new paths on success, or error message\r\n   */\r\n  renameWorkspace(\r\n    projectPath: string,\r\n    oldName: string,\r\n    newName: string,\r\n    abortSignal?: AbortSignal\r\n  ): Promise<\r\n    { success: true; oldPath: string; newPath: string } | { success: false; error: string }\r\n  >;\r\n\r\n  /**\r\n   * Delete workspace directory\r\n   * - LocalRuntime: Uses git worktree remove (with --force only if force param is true)\r\n   * - SSHRuntime: Checks for uncommitted changes unless force is true, then uses rm -rf\r\n   * Runtime computes workspace path internally from workdir + projectPath + workspaceName.\r\n   *\r\n   * **CRITICAL: Implementations must NEVER auto-apply --force or skip dirty checks without explicit force=true.**\r\n   * If workspace has uncommitted changes and force=false, implementations MUST return error.\r\n   * The force flag is the user's explicit intent - implementations must not override it.\r\n   *\r\n   * @param projectPath Project root path (local path, used for git commands in LocalRuntime and to extract project name)\r\n   * @param workspaceName Workspace name to delete\r\n   * @param force If true, force deletion even with uncommitted changes or special conditions (submodules, etc.)\r\n   * @param abortSignal Optional abort signal for cancellation\r\n   * @returns Promise resolving to Result with deleted path on success, or error message\r\n   */\r\n  deleteWorkspace(\r\n    projectPath: string,\r\n    workspaceName: string,\r\n    force: boolean,\r\n    abortSignal?: AbortSignal\r\n  ): Promise<{ success: true; deletedPath: string } | { success: false; error: string }>;\r\n\r\n  /**\r\n   * Ensure the runtime is ready for operations.\r\n   * - LocalRuntime: Always returns ready (no-op)\r\n   * - DockerRuntime: Starts container if stopped\r\n   * - SSHRuntime: Could verify connection (future)\r\n   * - CoderSSHRuntime: Checks workspace status, starts if stopped, waits for ready\r\n   *\r\n   * Called automatically by AIService before streaming.\r\n   *\r\n   * @param options Optional config: statusSink for progress events, signal for cancellation\r\n   * @returns Result indicating ready or failure with error type for retry decisions\r\n   */\r\n  ensureReady(options?: EnsureReadyOptions): Promise<EnsureReadyResult>;\r\n\r\n  /**\r\n   * Fork an existing workspace to create a new one\r\n   * Creates a new workspace branching from the source workspace's current branch\r\n   * - LocalRuntime: Detects source branch via git, creates new worktree from that branch\r\n   * - SSHRuntime: Currently unimplemented (returns static error)\r\n   *\r\n   * @param params Fork parameters (source workspace name, new workspace name, etc.)\r\n   * @returns Result with new workspace path and source branch, or error\r\n   */\r\n  forkWorkspace(params: WorkspaceForkParams): Promise<WorkspaceForkResult>;\r\n\r\n  /**\r\n   * Get the runtime's temp directory (absolute path, resolved).\r\n   * - LocalRuntime: /tmp (or OS temp dir)\r\n   * - SSHRuntime: Resolved remote temp dir (e.g., /tmp)\r\n   *\r\n   * Used for background process output, temporary files, etc.\r\n   */\r\n  tempDir(): Promise<string>;\r\n\r\n  /**\r\n   * Get the mux home directory for this runtime.\r\n   * Used for storing plan files and other mux-specific data.\r\n   * - LocalRuntime/SSHRuntime: ~/.mux (tilde expanded by runtime)\r\n   * - DockerRuntime: /var/mux (world-readable, avoids /root permission issues)\r\n   */\r\n  getMuxHome(): string;\r\n}\r\n\r\n/**\r\n * Result of checking if a runtime type is available for a project.\r\n * Re-exported for backward compatibility with existing imports.\r\n */\r\nexport type RuntimeAvailability = RuntimeAvailabilityStatus;\r\n\r\n/**\r\n * Error thrown by runtime implementations\r\n */\r\nexport class RuntimeError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public readonly type: \"exec\" | \"file_io\" | \"network\" | \"unknown\",\r\n    public readonly cause?: Error\r\n  ) {\r\n    super(message);\r\n    this.name = \"RuntimeError\";\r\n  }\r\n}\r\n"]}