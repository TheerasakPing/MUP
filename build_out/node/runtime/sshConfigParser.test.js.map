{"version":3,"file":"sshConfigParser.test.js","sourceRoot":"","sources":["../../../src/node/runtime/sshConfigParser.test.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs/promises\";\nimport * as os from \"os\";\nimport * as path from \"path\";\nimport { resolveSSHConfig } from \"./sshConfigParser\";\n\ndescribe(\"resolveSSHConfig\", () => {\n  test(\"applies Host + Match host proxy rules\", async () => {\n    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), \"mux-ssh-config-\"));\n    const previousUserProfile = process.env.USERPROFILE;\n\n    process.env.USERPROFILE = tempDir;\n\n    try {\n      await fs.mkdir(path.join(tempDir, \".ssh\"), { recursive: true });\n\n      const config = [\n        \"Host *.coder\",\n        \"  User coder-user\",\n        \"  UserKnownHostsFile /dev/null\",\n        \"\",\n        'Match host *.coder !exec \"exit 1\"',\n        \"  ProxyCommand /usr/local/bin/coder --stdio %h\",\n        \"\",\n      ].join(\"\\n\");\n\n      await fs.writeFile(path.join(tempDir, \".ssh\", \"config\"), config, \"utf8\");\n\n      const resolved = await resolveSSHConfig(\"pog2.coder\");\n\n      expect(resolved.user).toBe(\"coder-user\");\n      expect(resolved.hostName).toBe(\"pog2.coder\");\n      expect(resolved.proxyCommand).toBe(\"/usr/local/bin/coder --stdio %h\");\n    } finally {\n      if (previousUserProfile === undefined) {\n        delete process.env.USERPROFILE;\n      } else {\n        process.env.USERPROFILE = previousUserProfile;\n      }\n\n      await fs.rm(tempDir, { recursive: true, force: true });\n    }\n  });\n\n  test(\"defaults %r to local username when no User is specified\", async () => {\n    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), \"mux-ssh-config-\"));\n    const previousUserProfile = process.env.USERPROFILE;\n\n    process.env.USERPROFILE = tempDir;\n\n    try {\n      await fs.mkdir(path.join(tempDir, \".ssh\"), { recursive: true });\n\n      // Config with no User directive - %r should default to local username\n      // The !exec command checks if %r is non-empty; if it were empty, exit 0\n      // would cause the Match to NOT apply (since !exec means \"apply if command fails\")\n      const config = [\n        \"Host test-host\",\n        \"  HostName 10.0.0.1\",\n        \"\",\n        // !exec \"test -n %r\" fails when %r is non-empty (test -n returns 0 for non-empty)\n        // So we use \"test -z %r\" which returns 0 when %r IS empty, 1 when non-empty\n        // With %r defaulting to local username, test -z will fail, Match applies\n        'Match host 10.0.0.1 !exec \"test -z %r\"',\n        \"  ProxyCommand /usr/bin/proxy --user %r\",\n        \"\",\n      ].join(\"\\n\");\n\n      await fs.writeFile(path.join(tempDir, \".ssh\", \"config\"), config, \"utf8\");\n\n      const resolved = await resolveSSHConfig(\"test-host\");\n\n      // Should apply ProxyCommand because %r is non-empty (local username)\n      expect(resolved.proxyCommand).toBe(\"/usr/bin/proxy --user %r\");\n      // user should be undefined since no User directive\n      expect(resolved.user).toBeUndefined();\n    } finally {\n      if (previousUserProfile === undefined) {\n        delete process.env.USERPROFILE;\n      } else {\n        process.env.USERPROFILE = previousUserProfile;\n      }\n\n      await fs.rm(tempDir, { recursive: true, force: true });\n    }\n  });\n});\n"]}