{"version":3,"file":"gitBundleSync.js","sourceRoot":"","sources":["../../../src/node/runtime/gitBundleSync.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Shared git-bundle sync logic for remote runtimes (SSH, Docker).\r\n *\r\n * Each runtime is responsible for creating a bundle on the remote runtime (via pipe/cp/etc.).\r\n * This module handles the common steps once a remote bundle path exists.\r\n */\r\n\r\nimport type { ExecOptions, ExecStream, InitLogger } from \"./Runtime\";\r\nimport { streamToString, shescape } from \"./streamUtils\";\r\nimport { execAsync } from \"@/node/utils/disposableExec\";\r\nimport { getErrorMessage } from \"@/common/utils/errors\";\r\nimport { log } from \"@/node/services/log\";\r\n\r\nexport interface OriginUrlResult {\r\n  originUrl: string | null;\r\n}\r\n\r\n/**\r\n * Detect the origin remote URL for a local project.\r\n * Returns null if no origin exists, or if the URL points to a bundle file.\r\n * Exported for reuse by SSHRuntime's worktree-based sync path.\r\n */\r\nexport async function getOriginUrlForBundle(\r\n  projectPath: string,\r\n  initLogger: InitLogger,\r\n  logErrors: boolean\r\n): Promise<OriginUrlResult> {\r\n  try {\r\n    // Use git -C to avoid shell-specific `cd && ...` quoting.\r\n    using proc = execAsync(`git -C \"${projectPath}\" remote get-url origin`);\r\n    const { stdout } = await proc.result;\r\n    const url = stdout.trim();\r\n\r\n    if (url && !url.includes(\".bundle\") && !url.includes(\".mux-bundle\")) {\r\n      return { originUrl: url };\r\n    }\r\n\r\n    return { originUrl: null };\r\n  } catch (error) {\r\n    // Not fatal (repo may not have an origin remote).\r\n    if (logErrors) {\r\n      initLogger.logStderr(`Could not get origin URL: ${getErrorMessage(error)}`);\r\n    } else {\r\n      log.debug(\"Could not get origin URL\", { error: getErrorMessage(error) });\r\n    }\r\n    return { originUrl: null };\r\n  }\r\n}\r\n\r\nconst TRACKING_BRANCHES_COMMAND =\r\n  \"for branch in $(git for-each-ref --format='%(refname:short)' refs/remotes/origin/ | grep -v 'origin/HEAD'); do localname=${branch#origin/}; git show-ref --verify --quiet refs/heads/$localname || git branch $localname $branch; done\";\r\n\r\nexport interface GitBundleSyncParams {\r\n  /** Local project path (where git bundle is created) */\r\n  projectPath: string;\r\n  /** Destination workspace path on the remote runtime */\r\n  workspacePath: string;\r\n  /** Remote temp directory for clone/cleanup (e.g., \"~\" or \"/tmp\") */\r\n  remoteTmpDir: string;\r\n  /** Remote path where the bundle will be created/copied */\r\n  remoteBundlePath: string;\r\n\r\n  /** Remote exec implementation (typically runtime.exec) */\r\n  exec: (command: string, options: ExecOptions) => Promise<ExecStream>;\r\n  /** Quote/expand a path for the remote shell */\r\n  quoteRemotePath: (path: string) => string;\r\n\r\n  /** Logger for progress streaming */\r\n  initLogger: InitLogger;\r\n  /** Whether to surface origin-lookup failures to init logger (default: false) */\r\n  logOriginErrors?: boolean;\r\n\r\n  /** Optional abort signal */\r\n  abortSignal?: AbortSignal;\r\n\r\n  /**\r\n   * Runtime-specific hook that ensures `remoteBundlePath` exists on the remote runtime.\r\n   * May perform multiple steps (e.g., create bundle locally + transfer).\r\n   */\r\n  createRemoteBundle: (args: {\r\n    remoteBundlePath: string;\r\n    initLogger: InitLogger;\r\n    abortSignal?: AbortSignal;\r\n  }) => Promise<{\r\n    cleanupLocal?: () => Promise<void>;\r\n  } | void>;\r\n\r\n  /** Step label for cloning (runtime-specific: remote vs container) */\r\n  cloneStep: string;\r\n}\r\n\r\nexport async function syncProjectViaGitBundle(params: GitBundleSyncParams): Promise<void> {\r\n  const {\r\n    projectPath,\r\n    workspacePath,\r\n    remoteTmpDir,\r\n    remoteBundlePath,\r\n    exec,\r\n    quoteRemotePath,\r\n    initLogger,\r\n    logOriginErrors,\r\n    abortSignal,\r\n    createRemoteBundle,\r\n    cloneStep,\r\n  } = params;\r\n\r\n  if (abortSignal?.aborted) {\r\n    throw new Error(\"Sync operation aborted before starting\");\r\n  }\r\n\r\n  const { originUrl } = await getOriginUrlForBundle(\r\n    projectPath,\r\n    initLogger,\r\n    logOriginErrors ?? false\r\n  );\r\n\r\n  // Ensure the bundle exists on the remote runtime.\r\n  initLogger.logStep(\"Creating git bundle...\");\r\n  let createResult: Awaited<ReturnType<GitBundleSyncParams[\"createRemoteBundle\"]>>;\r\n  try {\r\n    createResult = await createRemoteBundle({ remoteBundlePath, initLogger, abortSignal });\r\n  } catch (error) {\r\n    // Best-effort cleanup (remote bundle may have been partially written).\r\n    try {\r\n      const rmStream = await exec(`rm -f ${quoteRemotePath(remoteBundlePath)}`, {\r\n        cwd: remoteTmpDir,\r\n        timeout: 10,\r\n        abortSignal,\r\n      });\r\n      await rmStream.exitCode;\r\n    } catch {\r\n      // Ignore cleanup errors.\r\n    }\r\n\r\n    throw error;\r\n  }\r\n\r\n  try {\r\n    // Clone from the bundle on the remote runtime.\r\n    initLogger.logStep(cloneStep);\r\n    const cloneStream = await exec(\r\n      `git clone --quiet ${quoteRemotePath(remoteBundlePath)} ${quoteRemotePath(workspacePath)}`,\r\n      {\r\n        cwd: remoteTmpDir,\r\n        timeout: 300,\r\n        abortSignal,\r\n      }\r\n    );\r\n\r\n    const [cloneStdout, cloneStderr, cloneExitCode] = await Promise.all([\r\n      streamToString(cloneStream.stdout),\r\n      streamToString(cloneStream.stderr),\r\n      cloneStream.exitCode,\r\n    ]);\r\n\r\n    if (cloneExitCode !== 0) {\r\n      throw new Error(`Failed to clone repository: ${cloneStderr || cloneStdout}`);\r\n    }\r\n\r\n    // Create local tracking branches.\r\n    initLogger.logStep(\"Creating local tracking branches...\");\r\n    const trackingStream = await exec(TRACKING_BRANCHES_COMMAND, {\r\n      cwd: workspacePath,\r\n      timeout: 30,\r\n      abortSignal,\r\n    });\r\n    await trackingStream.exitCode;\r\n\r\n    // Update origin remote.\r\n    if (originUrl) {\r\n      initLogger.logStep(`Setting origin remote to ${originUrl}...`);\r\n      const setOriginStream = await exec(`git remote set-url origin ${shescape.quote(originUrl)}`, {\r\n        cwd: workspacePath,\r\n        timeout: 10,\r\n        abortSignal,\r\n      });\r\n\r\n      const setOriginExitCode = await setOriginStream.exitCode;\r\n      if (setOriginExitCode !== 0) {\r\n        const stderr = await streamToString(setOriginStream.stderr);\r\n        log.debug(\"Failed to set origin remote\", { stderr });\r\n      }\r\n    } else {\r\n      initLogger.logStep(\"Removing bundle origin remote...\");\r\n      const removeOriginStream = await exec(`git remote remove origin 2>/dev/null || true`, {\r\n        cwd: workspacePath,\r\n        timeout: 10,\r\n        abortSignal,\r\n      });\r\n      await removeOriginStream.exitCode;\r\n    }\r\n\r\n    // Clean up remote bundle.\r\n    initLogger.logStep(\"Cleaning up bundle file...\");\r\n    const rmStream = await exec(`rm -f ${quoteRemotePath(remoteBundlePath)}`, {\r\n      cwd: remoteTmpDir,\r\n      timeout: 10,\r\n      abortSignal,\r\n    });\r\n\r\n    const rmExitCode = await rmStream.exitCode;\r\n    if (rmExitCode !== 0) {\r\n      log.debug(\"Failed to remove remote bundle file\", { remoteBundlePath });\r\n    }\r\n\r\n    if (createResult && \"cleanupLocal\" in createResult && createResult.cleanupLocal) {\r\n      await createResult.cleanupLocal();\r\n    }\r\n\r\n    initLogger.logStep(\"Repository cloned successfully\");\r\n  } catch (error) {\r\n    // Best-effort cleanup (remote bundle + any local temp file).\r\n    try {\r\n      const rmStream = await exec(`rm -f ${quoteRemotePath(remoteBundlePath)}`, {\r\n        cwd: remoteTmpDir,\r\n        timeout: 10,\r\n        abortSignal,\r\n      });\r\n      await rmStream.exitCode;\r\n    } catch {\r\n      // Ignore cleanup errors.\r\n    }\r\n\r\n    try {\r\n      if (createResult && \"cleanupLocal\" in createResult && createResult.cleanupLocal) {\r\n        await createResult.cleanupLocal();\r\n      }\r\n    } catch {\r\n      // Ignore cleanup errors.\r\n    }\r\n\r\n    throw error;\r\n  }\r\n}\r\n"]}