{"version":3,"file":"gitBundleSync.js","sourceRoot":"","sources":["../../../src/node/runtime/gitBundleSync.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Shared git-bundle sync logic for remote runtimes (SSH, Docker).\n *\n * Each runtime is responsible for creating a bundle on the remote runtime (via pipe/cp/etc.).\n * This module handles the common steps once a remote bundle path exists.\n */\n\nimport type { ExecOptions, ExecStream, InitLogger } from \"./Runtime\";\nimport { streamToString, shescape } from \"./streamUtils\";\nimport { execAsync } from \"@/node/utils/disposableExec\";\nimport { getErrorMessage } from \"@/common/utils/errors\";\nimport { log } from \"@/node/services/log\";\n\nexport interface OriginUrlResult {\n  originUrl: string | null;\n}\n\n/**\n * Detect the origin remote URL for a local project.\n * Returns null if no origin exists, or if the URL points to a bundle file.\n * Exported for reuse by SSHRuntime's worktree-based sync path.\n */\nexport async function getOriginUrlForBundle(\n  projectPath: string,\n  initLogger: InitLogger,\n  logErrors: boolean\n): Promise<OriginUrlResult> {\n  try {\n    // Use git -C to avoid shell-specific `cd && ...` quoting.\n    using proc = execAsync(`git -C \"${projectPath}\" remote get-url origin`);\n    const { stdout } = await proc.result;\n    const url = stdout.trim();\n\n    if (url && !url.includes(\".bundle\") && !url.includes(\".mux-bundle\")) {\n      return { originUrl: url };\n    }\n\n    return { originUrl: null };\n  } catch (error) {\n    // Not fatal (repo may not have an origin remote).\n    if (logErrors) {\n      initLogger.logStderr(`Could not get origin URL: ${getErrorMessage(error)}`);\n    } else {\n      log.debug(\"Could not get origin URL\", { error: getErrorMessage(error) });\n    }\n    return { originUrl: null };\n  }\n}\n\nconst TRACKING_BRANCHES_COMMAND =\n  \"for branch in $(git for-each-ref --format='%(refname:short)' refs/remotes/origin/ | grep -v 'origin/HEAD'); do localname=${branch#origin/}; git show-ref --verify --quiet refs/heads/$localname || git branch $localname $branch; done\";\n\nexport interface GitBundleSyncParams {\n  /** Local project path (where git bundle is created) */\n  projectPath: string;\n  /** Destination workspace path on the remote runtime */\n  workspacePath: string;\n  /** Remote temp directory for clone/cleanup (e.g., \"~\" or \"/tmp\") */\n  remoteTmpDir: string;\n  /** Remote path where the bundle will be created/copied */\n  remoteBundlePath: string;\n\n  /** Remote exec implementation (typically runtime.exec) */\n  exec: (command: string, options: ExecOptions) => Promise<ExecStream>;\n  /** Quote/expand a path for the remote shell */\n  quoteRemotePath: (path: string) => string;\n\n  /** Logger for progress streaming */\n  initLogger: InitLogger;\n  /** Whether to surface origin-lookup failures to init logger (default: false) */\n  logOriginErrors?: boolean;\n\n  /** Optional abort signal */\n  abortSignal?: AbortSignal;\n\n  /**\n   * Runtime-specific hook that ensures `remoteBundlePath` exists on the remote runtime.\n   * May perform multiple steps (e.g., create bundle locally + transfer).\n   */\n  createRemoteBundle: (args: {\n    remoteBundlePath: string;\n    initLogger: InitLogger;\n    abortSignal?: AbortSignal;\n  }) => Promise<{\n    cleanupLocal?: () => Promise<void>;\n  } | void>;\n\n  /** Step label for cloning (runtime-specific: remote vs container) */\n  cloneStep: string;\n}\n\nexport async function syncProjectViaGitBundle(params: GitBundleSyncParams): Promise<void> {\n  const {\n    projectPath,\n    workspacePath,\n    remoteTmpDir,\n    remoteBundlePath,\n    exec,\n    quoteRemotePath,\n    initLogger,\n    logOriginErrors,\n    abortSignal,\n    createRemoteBundle,\n    cloneStep,\n  } = params;\n\n  if (abortSignal?.aborted) {\n    throw new Error(\"Sync operation aborted before starting\");\n  }\n\n  const { originUrl } = await getOriginUrlForBundle(\n    projectPath,\n    initLogger,\n    logOriginErrors ?? false\n  );\n\n  // Ensure the bundle exists on the remote runtime.\n  initLogger.logStep(\"Creating git bundle...\");\n  let createResult: Awaited<ReturnType<GitBundleSyncParams[\"createRemoteBundle\"]>>;\n  try {\n    createResult = await createRemoteBundle({ remoteBundlePath, initLogger, abortSignal });\n  } catch (error) {\n    // Best-effort cleanup (remote bundle may have been partially written).\n    try {\n      const rmStream = await exec(`rm -f ${quoteRemotePath(remoteBundlePath)}`, {\n        cwd: remoteTmpDir,\n        timeout: 10,\n        abortSignal,\n      });\n      await rmStream.exitCode;\n    } catch {\n      // Ignore cleanup errors.\n    }\n\n    throw error;\n  }\n\n  try {\n    // Clone from the bundle on the remote runtime.\n    initLogger.logStep(cloneStep);\n    const cloneStream = await exec(\n      `git clone --quiet ${quoteRemotePath(remoteBundlePath)} ${quoteRemotePath(workspacePath)}`,\n      {\n        cwd: remoteTmpDir,\n        timeout: 300,\n        abortSignal,\n      }\n    );\n\n    const [cloneStdout, cloneStderr, cloneExitCode] = await Promise.all([\n      streamToString(cloneStream.stdout),\n      streamToString(cloneStream.stderr),\n      cloneStream.exitCode,\n    ]);\n\n    if (cloneExitCode !== 0) {\n      throw new Error(`Failed to clone repository: ${cloneStderr || cloneStdout}`);\n    }\n\n    // Create local tracking branches.\n    initLogger.logStep(\"Creating local tracking branches...\");\n    const trackingStream = await exec(TRACKING_BRANCHES_COMMAND, {\n      cwd: workspacePath,\n      timeout: 30,\n      abortSignal,\n    });\n    await trackingStream.exitCode;\n\n    // Update origin remote.\n    if (originUrl) {\n      initLogger.logStep(`Setting origin remote to ${originUrl}...`);\n      const setOriginStream = await exec(`git remote set-url origin ${shescape.quote(originUrl)}`, {\n        cwd: workspacePath,\n        timeout: 10,\n        abortSignal,\n      });\n\n      const setOriginExitCode = await setOriginStream.exitCode;\n      if (setOriginExitCode !== 0) {\n        const stderr = await streamToString(setOriginStream.stderr);\n        log.debug(\"Failed to set origin remote\", { stderr });\n      }\n    } else {\n      initLogger.logStep(\"Removing bundle origin remote...\");\n      const removeOriginStream = await exec(`git remote remove origin 2>/dev/null || true`, {\n        cwd: workspacePath,\n        timeout: 10,\n        abortSignal,\n      });\n      await removeOriginStream.exitCode;\n    }\n\n    // Clean up remote bundle.\n    initLogger.logStep(\"Cleaning up bundle file...\");\n    const rmStream = await exec(`rm -f ${quoteRemotePath(remoteBundlePath)}`, {\n      cwd: remoteTmpDir,\n      timeout: 10,\n      abortSignal,\n    });\n\n    const rmExitCode = await rmStream.exitCode;\n    if (rmExitCode !== 0) {\n      log.debug(\"Failed to remove remote bundle file\", { remoteBundlePath });\n    }\n\n    if (createResult && \"cleanupLocal\" in createResult && createResult.cleanupLocal) {\n      await createResult.cleanupLocal();\n    }\n\n    initLogger.logStep(\"Repository cloned successfully\");\n  } catch (error) {\n    // Best-effort cleanup (remote bundle + any local temp file).\n    try {\n      const rmStream = await exec(`rm -f ${quoteRemotePath(remoteBundlePath)}`, {\n        cwd: remoteTmpDir,\n        timeout: 10,\n        abortSignal,\n      });\n      await rmStream.exitCode;\n    } catch {\n      // Ignore cleanup errors.\n    }\n\n    try {\n      if (createResult && \"cleanupLocal\" in createResult && createResult.cleanupLocal) {\n        await createResult.cleanupLocal();\n      }\n    } catch {\n      // Ignore cleanup errors.\n    }\n\n    throw error;\n  }\n}\n"]}