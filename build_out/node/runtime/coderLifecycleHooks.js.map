{"version":3,"file":"coderLifecycleHooks.js","sourceRoot":"","sources":["../../../src/node/runtime/coderLifecycleHooks.ts"],"names":[],"mappings":"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","sourcesContent":["import { isSSHRuntime } from \"@/common/types/runtime\";\nimport { Err, Ok, type Result } from \"@/common/types/result\";\nimport type { CoderService, WorkspaceStatusResult } from \"@/node/services/coderService\";\nimport { log } from \"@/node/services/log\";\nimport type {\n  AfterUnarchiveHook,\n  BeforeArchiveHook,\n} from \"@/node/services/workspaceLifecycleHooks\";\n\nconst DEFAULT_STOP_TIMEOUT_MS = 60_000;\nconst DEFAULT_START_TIMEOUT_MS = 60_000;\nconst DEFAULT_STATUS_TIMEOUT_MS = 10_000;\n\nconst DEFAULT_STOPPING_WAIT_TIMEOUT_MS = 15_000;\nconst DEFAULT_STOPPING_POLL_INTERVAL_MS = 1_000;\n\nfunction sleep(ms: number): Promise<void> {\n  if (ms <= 0) {\n    return Promise.resolve();\n  }\n\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nfunction isAlreadyStoppedOrGone(status: WorkspaceStatusResult): boolean {\n  if (status.kind === \"not_found\") {\n    return true;\n  }\n\n  if (status.kind !== \"ok\") {\n    return false;\n  }\n\n  // \"stopping\" is treated as \"good enough\" for archive — we don't want to block the user on a\n  // long tail stop operation when the workspace is already on its way down.\n  return (\n    status.status === \"stopped\" ||\n    status.status === \"stopping\" ||\n    status.status === \"deleted\" ||\n    status.status === \"deleting\"\n  );\n}\n\nfunction isAlreadyRunningOrStarting(status: WorkspaceStatusResult): boolean {\n  if (status.kind !== \"ok\") {\n    return false;\n  }\n\n  return status.status === \"running\" || status.status === \"starting\";\n}\n\nexport function createStopCoderOnArchiveHook(options: {\n  coderService: CoderService;\n  shouldStopOnArchive: () => boolean;\n  timeoutMs?: number;\n}): BeforeArchiveHook {\n  const timeoutMs = options.timeoutMs ?? DEFAULT_STOP_TIMEOUT_MS;\n\n  return async ({ workspaceId, workspaceMetadata }): Promise<Result<void>> => {\n    // Config default is ON (undefined behaves true).\n    if (!options.shouldStopOnArchive()) {\n      return Ok(undefined);\n    }\n\n    const runtimeConfig = workspaceMetadata.runtimeConfig;\n    if (!isSSHRuntime(runtimeConfig) || !runtimeConfig.coder) {\n      return Ok(undefined);\n    }\n\n    const coder = runtimeConfig.coder;\n\n    // Important safety invariant:\n    // Only stop Coder workspaces that mux created (dedicated workspaces). If the user connected\n    // mux to an existing Coder workspace, archiving in mux should *not* stop their environment.\n    if (coder.existingWorkspace === true) {\n      return Ok(undefined);\n    }\n\n    const workspaceName = coder.workspaceName?.trim();\n    if (!workspaceName) {\n      return Ok(undefined);\n    }\n\n    // Best-effort: skip the stop call if the control-plane already thinks the workspace is down.\n    const status = await options.coderService.getWorkspaceStatus(workspaceName, {\n      timeoutMs: DEFAULT_STATUS_TIMEOUT_MS,\n    });\n\n    if (isAlreadyStoppedOrGone(status)) {\n      return Ok(undefined);\n    }\n\n    log.debug(\"Stopping Coder workspace before mux archive\", {\n      workspaceId,\n      coderWorkspaceName: workspaceName,\n      statusKind: status.kind,\n      status: status.kind === \"ok\" ? status.status : undefined,\n    });\n\n    const stopResult = await options.coderService.stopWorkspace(workspaceName, { timeoutMs });\n    if (!stopResult.success) {\n      return Err(`Failed to stop Coder workspace \"${workspaceName}\": ${stopResult.error}`);\n    }\n\n    return Ok(undefined);\n  };\n}\n\nexport function createStartCoderOnUnarchiveHook(options: {\n  coderService: CoderService;\n  shouldStopOnArchive: () => boolean;\n  timeoutMs?: number;\n  stoppingWaitTimeoutMs?: number;\n  stoppingPollIntervalMs?: number;\n}): AfterUnarchiveHook {\n  const timeoutMs = options.timeoutMs ?? DEFAULT_START_TIMEOUT_MS;\n\n  return async ({ workspaceId, workspaceMetadata }): Promise<Result<void>> => {\n    // Config default is ON (undefined behaves true).\n    if (!options.shouldStopOnArchive()) {\n      return Ok(undefined);\n    }\n\n    const runtimeConfig = workspaceMetadata.runtimeConfig;\n    if (!isSSHRuntime(runtimeConfig) || !runtimeConfig.coder) {\n      return Ok(undefined);\n    }\n\n    const coder = runtimeConfig.coder;\n\n    // Important safety invariant:\n    // Only start Coder workspaces that mux created (dedicated workspaces). If the user connected\n    // mux to an existing Coder workspace, unarchiving in mux should *not* start their environment.\n    if (coder.existingWorkspace === true) {\n      return Ok(undefined);\n    }\n\n    const workspaceName = coder.workspaceName?.trim();\n    if (!workspaceName) {\n      return Ok(undefined);\n    }\n\n    let status = await options.coderService.getWorkspaceStatus(workspaceName, {\n      timeoutMs: DEFAULT_STATUS_TIMEOUT_MS,\n    });\n\n    // Unarchive can happen immediately after archive, while the Coder workspace is still\n    // transitioning through \"stopping\". Starting during that transition can fail, so we\n    // best-effort poll briefly until it reaches a terminal state.\n    if (status.kind === \"ok\" && status.status === \"stopping\") {\n      const waitTimeoutMs = options.stoppingWaitTimeoutMs ?? DEFAULT_STOPPING_WAIT_TIMEOUT_MS;\n      const pollIntervalMs = options.stoppingPollIntervalMs ?? DEFAULT_STOPPING_POLL_INTERVAL_MS;\n      const deadlineMs = Date.now() + waitTimeoutMs;\n\n      log.debug(\n        \"Coder workspace is still stopping after mux unarchive; waiting briefly before starting\",\n        {\n          workspaceId,\n          coderWorkspaceName: workspaceName,\n          waitTimeoutMs,\n          pollIntervalMs,\n        }\n      );\n\n      while (status.kind === \"ok\" && status.status === \"stopping\") {\n        const remainingMs = deadlineMs - Date.now();\n        if (remainingMs <= 0) {\n          break;\n        }\n\n        await sleep(Math.min(pollIntervalMs, remainingMs));\n\n        const statusRemainingMs = deadlineMs - Date.now();\n        if (statusRemainingMs <= 0) {\n          break;\n        }\n\n        status = await options.coderService.getWorkspaceStatus(workspaceName, {\n          timeoutMs: Math.min(DEFAULT_STATUS_TIMEOUT_MS, statusRemainingMs),\n        });\n      }\n\n      if (status.kind === \"ok\" && status.status === \"stopping\") {\n        log.debug(\"Timed out waiting for Coder workspace to stop after mux unarchive\", {\n          workspaceId,\n          coderWorkspaceName: workspaceName,\n          waitTimeoutMs,\n        });\n        return Ok(undefined);\n      }\n    }\n\n    // If the workspace is gone, that's \"good enough\" — there's nothing to start.\n    if (status.kind === \"not_found\") {\n      return Ok(undefined);\n    }\n\n    if (status.kind === \"error\") {\n      log.debug(\"Skipping Coder workspace start after mux unarchive due to status check error\", {\n        workspaceId,\n        coderWorkspaceName: workspaceName,\n        error: status.error,\n      });\n      return Ok(undefined);\n    }\n\n    // Best-effort: don't start if the control-plane already thinks the workspace is coming up.\n    if (isAlreadyRunningOrStarting(status)) {\n      return Ok(undefined);\n    }\n\n    // Only start when the workspace is definitively stopped.\n    if (status.status !== \"stopped\") {\n      return Ok(undefined);\n    }\n\n    log.debug(\"Starting Coder workspace after mux unarchive\", {\n      workspaceId,\n      coderWorkspaceName: workspaceName,\n      status: status.status,\n    });\n\n    const startResult = await options.coderService.startWorkspace(workspaceName, { timeoutMs });\n    if (!startResult.success) {\n      return Err(`Failed to start Coder workspace \"${workspaceName}\": ${startResult.error}`);\n    }\n\n    return Ok(undefined);\n  };\n}\n"]}