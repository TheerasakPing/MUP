{"version":3,"file":"coderLifecycleHooks.js","sourceRoot":"","sources":["../../../src/node/runtime/coderLifecycleHooks.ts"],"names":[],"mappings":";;;;AAAA,oDAAsD;AACtD,kDAA6D;AAE7D,6CAA0C;AAM1C,MAAM,uBAAuB,GAAG,MAAM,CAAC;AACvC,MAAM,wBAAwB,GAAG,MAAM,CAAC;AACxC,MAAM,yBAAyB,GAAG,MAAM,CAAC;AAEzC,MAAM,gCAAgC,GAAG,MAAM,CAAC;AAChD,MAAM,iCAAiC,GAAG,KAAK,CAAC;AAEhD,SAAS,KAAK,CAAC,EAAU,EAAiB;IACxC,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC;QACZ,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAC3B,CAAC;IAED,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC;AAAA,CAC1D;AAED,SAAS,sBAAsB,CAAC,MAA6B,EAAW;IACtE,IAAI,MAAM,CAAC,IAAI,KAAK,WAAW,EAAE,CAAC;QAChC,OAAO,IAAI,CAAC;IACd,CAAC;IAED,IAAI,MAAM,CAAC,IAAI,KAAK,IAAI,EAAE,CAAC;QACzB,OAAO,KAAK,CAAC;IACf,CAAC;IAED,8FAA4F;IAC5F,0EAA0E;IAC1E,OAAO,CACL,MAAM,CAAC,MAAM,KAAK,SAAS;QAC3B,MAAM,CAAC,MAAM,KAAK,UAAU;QAC5B,MAAM,CAAC,MAAM,KAAK,SAAS;QAC3B,MAAM,CAAC,MAAM,KAAK,UAAU,CAC7B,CAAC;AAAA,CACH;AAED,SAAS,0BAA0B,CAAC,MAA6B,EAAW;IAC1E,IAAI,MAAM,CAAC,IAAI,KAAK,IAAI,EAAE,CAAC;QACzB,OAAO,KAAK,CAAC;IACf,CAAC;IAED,OAAO,MAAM,CAAC,MAAM,KAAK,SAAS,IAAI,MAAM,CAAC,MAAM,KAAK,UAAU,CAAC;AAAA,CACpE;AAED,sCAA6C,OAI5C,EAAqB;IACpB,MAAM,SAAS,GAAG,OAAO,CAAC,SAAS,IAAI,uBAAuB,CAAC;IAE/D,OAAO,KAAK,EAAE,EAAE,WAAW,EAAE,iBAAiB,EAAE,EAAyB,EAAE,CAAC;QAC1E,iDAAiD;QACjD,IAAI,CAAC,OAAO,CAAC,mBAAmB,EAAE,EAAE,CAAC;YACnC,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;QACvB,CAAC;QAED,MAAM,aAAa,GAAG,iBAAiB,CAAC,aAAa,CAAC;QACtD,IAAI,CAAC,IAAA,sBAAY,EAAC,aAAa,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC;YACzD,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;QACvB,CAAC;QAED,MAAM,KAAK,GAAG,aAAa,CAAC,KAAK,CAAC;QAElC,8BAA8B;QAC9B,4FAA4F;QAC5F,4FAA4F;QAC5F,IAAI,KAAK,CAAC,iBAAiB,KAAK,IAAI,EAAE,CAAC;YACrC,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;QACvB,CAAC;QAED,MAAM,aAAa,GAAG,KAAK,CAAC,aAAa,EAAE,IAAI,EAAE,CAAC;QAClD,IAAI,CAAC,aAAa,EAAE,CAAC;YACnB,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;QACvB,CAAC;QAED,6FAA6F;QAC7F,MAAM,MAAM,GAAG,MAAM,OAAO,CAAC,YAAY,CAAC,kBAAkB,CAAC,aAAa,EAAE;YAC1E,SAAS,EAAE,yBAAyB;SACrC,CAAC,CAAC;QAEH,IAAI,sBAAsB,CAAC,MAAM,CAAC,EAAE,CAAC;YACnC,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;QACvB,CAAC;QAED,SAAG,CAAC,KAAK,CAAC,6CAA6C,EAAE;YACvD,WAAW;YACX,kBAAkB,EAAE,aAAa;YACjC,UAAU,EAAE,MAAM,CAAC,IAAI;YACvB,MAAM,EAAE,MAAM,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS;SACzD,CAAC,CAAC;QAEH,MAAM,UAAU,GAAG,MAAM,OAAO,CAAC,YAAY,CAAC,aAAa,CAAC,aAAa,EAAE,EAAE,SAAS,EAAE,CAAC,CAAC;QAC1F,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC;YACxB,OAAO,IAAA,YAAG,EAAC,mCAAmC,aAAa,MAAM,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC;QACvF,CAAC;QAED,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;IAAA,CACtB,CAAC;AAAA,CACH;AAED,yCAAgD,OAM/C,EAAsB;IACrB,MAAM,SAAS,GAAG,OAAO,CAAC,SAAS,IAAI,wBAAwB,CAAC;IAEhE,OAAO,KAAK,EAAE,EAAE,WAAW,EAAE,iBAAiB,EAAE,EAAyB,EAAE,CAAC;QAC1E,iDAAiD;QACjD,IAAI,CAAC,OAAO,CAAC,mBAAmB,EAAE,EAAE,CAAC;YACnC,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;QACvB,CAAC;QAED,MAAM,aAAa,GAAG,iBAAiB,CAAC,aAAa,CAAC;QACtD,IAAI,CAAC,IAAA,sBAAY,EAAC,aAAa,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC;YACzD,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;QACvB,CAAC;QAED,MAAM,KAAK,GAAG,aAAa,CAAC,KAAK,CAAC;QAElC,8BAA8B;QAC9B,6FAA6F;QAC7F,+FAA+F;QAC/F,IAAI,KAAK,CAAC,iBAAiB,KAAK,IAAI,EAAE,CAAC;YACrC,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;QACvB,CAAC;QAED,MAAM,aAAa,GAAG,KAAK,CAAC,aAAa,EAAE,IAAI,EAAE,CAAC;QAClD,IAAI,CAAC,aAAa,EAAE,CAAC;YACnB,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;QACvB,CAAC;QAED,IAAI,MAAM,GAAG,MAAM,OAAO,CAAC,YAAY,CAAC,kBAAkB,CAAC,aAAa,EAAE;YACxE,SAAS,EAAE,yBAAyB;SACrC,CAAC,CAAC;QAEH,qFAAqF;QACrF,oFAAoF;QACpF,8DAA8D;QAC9D,IAAI,MAAM,CAAC,IAAI,KAAK,IAAI,IAAI,MAAM,CAAC,MAAM,KAAK,UAAU,EAAE,CAAC;YACzD,MAAM,aAAa,GAAG,OAAO,CAAC,qBAAqB,IAAI,gCAAgC,CAAC;YACxF,MAAM,cAAc,GAAG,OAAO,CAAC,sBAAsB,IAAI,iCAAiC,CAAC;YAC3F,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,aAAa,CAAC;YAE9C,SAAG,CAAC,KAAK,CACP,wFAAwF,EACxF;gBACE,WAAW;gBACX,kBAAkB,EAAE,aAAa;gBACjC,aAAa;gBACb,cAAc;aACf,CACF,CAAC;YAEF,OAAO,MAAM,CAAC,IAAI,KAAK,IAAI,IAAI,MAAM,CAAC,MAAM,KAAK,UAAU,EAAE,CAAC;gBAC5D,MAAM,WAAW,GAAG,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;gBAC5C,IAAI,WAAW,IAAI,CAAC,EAAE,CAAC;oBACrB,MAAM;gBACR,CAAC;gBAED,MAAM,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,WAAW,CAAC,CAAC,CAAC;gBAEnD,MAAM,iBAAiB,GAAG,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;gBAClD,IAAI,iBAAiB,IAAI,CAAC,EAAE,CAAC;oBAC3B,MAAM;gBACR,CAAC;gBAED,MAAM,GAAG,MAAM,OAAO,CAAC,YAAY,CAAC,kBAAkB,CAAC,aAAa,EAAE;oBACpE,SAAS,EAAE,IAAI,CAAC,GAAG,CAAC,yBAAyB,EAAE,iBAAiB,CAAC;iBAClE,CAAC,CAAC;YACL,CAAC;YAED,IAAI,MAAM,CAAC,IAAI,KAAK,IAAI,IAAI,MAAM,CAAC,MAAM,KAAK,UAAU,EAAE,CAAC;gBACzD,SAAG,CAAC,KAAK,CAAC,mEAAmE,EAAE;oBAC7E,WAAW;oBACX,kBAAkB,EAAE,aAAa;oBACjC,aAAa;iBACd,CAAC,CAAC;gBACH,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;YACvB,CAAC;QACH,CAAC;QAED,+EAA6E;QAC7E,IAAI,MAAM,CAAC,IAAI,KAAK,WAAW,EAAE,CAAC;YAChC,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;QACvB,CAAC;QAED,IAAI,MAAM,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;YAC5B,SAAG,CAAC,KAAK,CAAC,8EAA8E,EAAE;gBACxF,WAAW;gBACX,kBAAkB,EAAE,aAAa;gBACjC,KAAK,EAAE,MAAM,CAAC,KAAK;aACpB,CAAC,CAAC;YACH,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;QACvB,CAAC;QAED,2FAA2F;QAC3F,IAAI,0BAA0B,CAAC,MAAM,CAAC,EAAE,CAAC;YACvC,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;QACvB,CAAC;QAED,yDAAyD;QACzD,IAAI,MAAM,CAAC,MAAM,KAAK,SAAS,EAAE,CAAC;YAChC,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;QACvB,CAAC;QAED,SAAG,CAAC,KAAK,CAAC,8CAA8C,EAAE;YACxD,WAAW;YACX,kBAAkB,EAAE,aAAa;YACjC,MAAM,EAAE,MAAM,CAAC,MAAM;SACtB,CAAC,CAAC;QAEH,MAAM,WAAW,GAAG,MAAM,OAAO,CAAC,YAAY,CAAC,cAAc,CAAC,aAAa,EAAE,EAAE,SAAS,EAAE,CAAC,CAAC;QAC5F,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC;YACzB,OAAO,IAAA,YAAG,EAAC,oCAAoC,aAAa,MAAM,WAAW,CAAC,KAAK,EAAE,CAAC,CAAC;QACzF,CAAC;QAED,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;IAAA,CACtB,CAAC;AAAA,CACH","sourcesContent":["import { isSSHRuntime } from \"@/common/types/runtime\";\r\nimport { Err, Ok, type Result } from \"@/common/types/result\";\r\nimport type { CoderService, WorkspaceStatusResult } from \"@/node/services/coderService\";\r\nimport { log } from \"@/node/services/log\";\r\nimport type {\r\n  AfterUnarchiveHook,\r\n  BeforeArchiveHook,\r\n} from \"@/node/services/workspaceLifecycleHooks\";\r\n\r\nconst DEFAULT_STOP_TIMEOUT_MS = 60_000;\r\nconst DEFAULT_START_TIMEOUT_MS = 60_000;\r\nconst DEFAULT_STATUS_TIMEOUT_MS = 10_000;\r\n\r\nconst DEFAULT_STOPPING_WAIT_TIMEOUT_MS = 15_000;\r\nconst DEFAULT_STOPPING_POLL_INTERVAL_MS = 1_000;\r\n\r\nfunction sleep(ms: number): Promise<void> {\r\n  if (ms <= 0) {\r\n    return Promise.resolve();\r\n  }\r\n\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n\r\nfunction isAlreadyStoppedOrGone(status: WorkspaceStatusResult): boolean {\r\n  if (status.kind === \"not_found\") {\r\n    return true;\r\n  }\r\n\r\n  if (status.kind !== \"ok\") {\r\n    return false;\r\n  }\r\n\r\n  // \"stopping\" is treated as \"good enough\" for archive — we don't want to block the user on a\r\n  // long tail stop operation when the workspace is already on its way down.\r\n  return (\r\n    status.status === \"stopped\" ||\r\n    status.status === \"stopping\" ||\r\n    status.status === \"deleted\" ||\r\n    status.status === \"deleting\"\r\n  );\r\n}\r\n\r\nfunction isAlreadyRunningOrStarting(status: WorkspaceStatusResult): boolean {\r\n  if (status.kind !== \"ok\") {\r\n    return false;\r\n  }\r\n\r\n  return status.status === \"running\" || status.status === \"starting\";\r\n}\r\n\r\nexport function createStopCoderOnArchiveHook(options: {\r\n  coderService: CoderService;\r\n  shouldStopOnArchive: () => boolean;\r\n  timeoutMs?: number;\r\n}): BeforeArchiveHook {\r\n  const timeoutMs = options.timeoutMs ?? DEFAULT_STOP_TIMEOUT_MS;\r\n\r\n  return async ({ workspaceId, workspaceMetadata }): Promise<Result<void>> => {\r\n    // Config default is ON (undefined behaves true).\r\n    if (!options.shouldStopOnArchive()) {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    const runtimeConfig = workspaceMetadata.runtimeConfig;\r\n    if (!isSSHRuntime(runtimeConfig) || !runtimeConfig.coder) {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    const coder = runtimeConfig.coder;\r\n\r\n    // Important safety invariant:\r\n    // Only stop Coder workspaces that mux created (dedicated workspaces). If the user connected\r\n    // mux to an existing Coder workspace, archiving in mux should *not* stop their environment.\r\n    if (coder.existingWorkspace === true) {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    const workspaceName = coder.workspaceName?.trim();\r\n    if (!workspaceName) {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    // Best-effort: skip the stop call if the control-plane already thinks the workspace is down.\r\n    const status = await options.coderService.getWorkspaceStatus(workspaceName, {\r\n      timeoutMs: DEFAULT_STATUS_TIMEOUT_MS,\r\n    });\r\n\r\n    if (isAlreadyStoppedOrGone(status)) {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    log.debug(\"Stopping Coder workspace before mux archive\", {\r\n      workspaceId,\r\n      coderWorkspaceName: workspaceName,\r\n      statusKind: status.kind,\r\n      status: status.kind === \"ok\" ? status.status : undefined,\r\n    });\r\n\r\n    const stopResult = await options.coderService.stopWorkspace(workspaceName, { timeoutMs });\r\n    if (!stopResult.success) {\r\n      return Err(`Failed to stop Coder workspace \"${workspaceName}\": ${stopResult.error}`);\r\n    }\r\n\r\n    return Ok(undefined);\r\n  };\r\n}\r\n\r\nexport function createStartCoderOnUnarchiveHook(options: {\r\n  coderService: CoderService;\r\n  shouldStopOnArchive: () => boolean;\r\n  timeoutMs?: number;\r\n  stoppingWaitTimeoutMs?: number;\r\n  stoppingPollIntervalMs?: number;\r\n}): AfterUnarchiveHook {\r\n  const timeoutMs = options.timeoutMs ?? DEFAULT_START_TIMEOUT_MS;\r\n\r\n  return async ({ workspaceId, workspaceMetadata }): Promise<Result<void>> => {\r\n    // Config default is ON (undefined behaves true).\r\n    if (!options.shouldStopOnArchive()) {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    const runtimeConfig = workspaceMetadata.runtimeConfig;\r\n    if (!isSSHRuntime(runtimeConfig) || !runtimeConfig.coder) {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    const coder = runtimeConfig.coder;\r\n\r\n    // Important safety invariant:\r\n    // Only start Coder workspaces that mux created (dedicated workspaces). If the user connected\r\n    // mux to an existing Coder workspace, unarchiving in mux should *not* start their environment.\r\n    if (coder.existingWorkspace === true) {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    const workspaceName = coder.workspaceName?.trim();\r\n    if (!workspaceName) {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    let status = await options.coderService.getWorkspaceStatus(workspaceName, {\r\n      timeoutMs: DEFAULT_STATUS_TIMEOUT_MS,\r\n    });\r\n\r\n    // Unarchive can happen immediately after archive, while the Coder workspace is still\r\n    // transitioning through \"stopping\". Starting during that transition can fail, so we\r\n    // best-effort poll briefly until it reaches a terminal state.\r\n    if (status.kind === \"ok\" && status.status === \"stopping\") {\r\n      const waitTimeoutMs = options.stoppingWaitTimeoutMs ?? DEFAULT_STOPPING_WAIT_TIMEOUT_MS;\r\n      const pollIntervalMs = options.stoppingPollIntervalMs ?? DEFAULT_STOPPING_POLL_INTERVAL_MS;\r\n      const deadlineMs = Date.now() + waitTimeoutMs;\r\n\r\n      log.debug(\r\n        \"Coder workspace is still stopping after mux unarchive; waiting briefly before starting\",\r\n        {\r\n          workspaceId,\r\n          coderWorkspaceName: workspaceName,\r\n          waitTimeoutMs,\r\n          pollIntervalMs,\r\n        }\r\n      );\r\n\r\n      while (status.kind === \"ok\" && status.status === \"stopping\") {\r\n        const remainingMs = deadlineMs - Date.now();\r\n        if (remainingMs <= 0) {\r\n          break;\r\n        }\r\n\r\n        await sleep(Math.min(pollIntervalMs, remainingMs));\r\n\r\n        const statusRemainingMs = deadlineMs - Date.now();\r\n        if (statusRemainingMs <= 0) {\r\n          break;\r\n        }\r\n\r\n        status = await options.coderService.getWorkspaceStatus(workspaceName, {\r\n          timeoutMs: Math.min(DEFAULT_STATUS_TIMEOUT_MS, statusRemainingMs),\r\n        });\r\n      }\r\n\r\n      if (status.kind === \"ok\" && status.status === \"stopping\") {\r\n        log.debug(\"Timed out waiting for Coder workspace to stop after mux unarchive\", {\r\n          workspaceId,\r\n          coderWorkspaceName: workspaceName,\r\n          waitTimeoutMs,\r\n        });\r\n        return Ok(undefined);\r\n      }\r\n    }\r\n\r\n    // If the workspace is gone, that's \"good enough\" — there's nothing to start.\r\n    if (status.kind === \"not_found\") {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    if (status.kind === \"error\") {\r\n      log.debug(\"Skipping Coder workspace start after mux unarchive due to status check error\", {\r\n        workspaceId,\r\n        coderWorkspaceName: workspaceName,\r\n        error: status.error,\r\n      });\r\n      return Ok(undefined);\r\n    }\r\n\r\n    // Best-effort: don't start if the control-plane already thinks the workspace is coming up.\r\n    if (isAlreadyRunningOrStarting(status)) {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    // Only start when the workspace is definitively stopped.\r\n    if (status.status !== \"stopped\") {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    log.debug(\"Starting Coder workspace after mux unarchive\", {\r\n      workspaceId,\r\n      coderWorkspaceName: workspaceName,\r\n      status: status.status,\r\n    });\r\n\r\n    const startResult = await options.coderService.startWorkspace(workspaceName, { timeoutMs });\r\n    if (!startResult.success) {\r\n      return Err(`Failed to start Coder workspace \"${workspaceName}\": ${startResult.error}`);\r\n    }\r\n\r\n    return Ok(undefined);\r\n  };\r\n}\r\n"]}