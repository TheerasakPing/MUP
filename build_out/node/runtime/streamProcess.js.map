{"version":3,"file":"streamProcess.js","sourceRoot":"","sources":["../../../src/node/runtime/streamProcess.ts"],"names":[],"mappings":";AAAA;;GAEG;;;AAKH;;;;;;;;;;;;GAYG;AACH,+BACE,OAAqB,EACrB,UAAsB,EACtB,OASC,EACW;IACZ,MAAM,EAAE,SAAS,GAAG,KAAK,EAAE,SAAS,GAAG,IAAI,EAAE,OAAO,EAAE,WAAW,EAAE,GAAG,OAAO,IAAI,EAAE,CAAC;IAEpF,+CAA+C;IAC/C,IAAI,OAAO,EAAE,CAAC;QACZ,UAAU,CAAC,OAAO,CAAC,cAAc,OAAO,EAAE,CAAC,CAAC;IAC9C,CAAC;IAED,8BAA8B;IAC9B,MAAM,YAAY,GAAG,WAAW;QAC9B,CAAC,CAAC,GAAG,EAAE,CAAC;YACJ,OAAO,CAAC,IAAI,EAAE,CAAC;QAAA,CAChB;QACH,CAAC,CAAC,IAAI,CAAC;IACT,IAAI,YAAY,IAAI,WAAW,EAAE,CAAC;QAChC,WAAW,CAAC,gBAAgB,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;IACtD,CAAC;IAED,uCAAuC;IACvC,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;QACnB,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAY,EAAE,EAAE,CAAC;YAC1C,IAAI,SAAS,EAAE,CAAC;gBACd,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAC/B,6CAA6C;gBAC7C,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBAC1E,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;oBACzB,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;gBAC7B,CAAC;YACH,CAAC;YACD,sDAAsD;QADrD,CAEF,CAAC,CAAC;IACL,CAAC;IAED,0BAA0B;IAC1B,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;QACnB,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAY,EAAE,EAAE,CAAC;YAC1C,IAAI,SAAS,EAAE,CAAC;gBACd,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAC/B,6CAA6C;gBAC7C,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBAC1E,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;oBACzB,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;gBAC7B,CAAC;YACH,CAAC;YACD,sDAAsD;QADrD,CAEF,CAAC,CAAC;IACL,CAAC;IAED,mDAAmD;IACnD,OAAO,GAAG,EAAE,CAAC;QACX,IAAI,YAAY,IAAI,WAAW,EAAE,CAAC;YAChC,WAAW,CAAC,mBAAmB,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;QACzD,CAAC;IAAA,CACF,CAAC;AAAA,CACH","sourcesContent":["/**\n * Helper utilities for streaming child process output to InitLogger\n */\n\nimport type { ChildProcess } from \"child_process\";\nimport type { InitLogger } from \"./Runtime\";\n\n/**\n * Stream child process stdout/stderr to initLogger\n * Prevents pipe buffer overflow by draining both streams.\n *\n * This is essential to prevent child processes from hanging when their\n * output buffers fill up (typically 64KB). Always call this when spawning\n * processes that may produce output.\n *\n * @param process Child process to stream from\n * @param initLogger Logger to stream output to\n * @param options Configuration for which streams to log\n * @returns Cleanup function to remove abort signal listener (call this in process close/error handlers)\n */\nexport function streamProcessToLogger(\n  process: ChildProcess,\n  initLogger: InitLogger,\n  options?: {\n    /** If true, log stdout via logStdout. If false, drain silently. Default: false */\n    logStdout?: boolean;\n    /** If true, log stderr via logStderr. If false, drain silently. Default: true */\n    logStderr?: boolean;\n    /** Optional: Command string to log before streaming starts */\n    command?: string;\n    /** Optional: Abort signal to kill process on cancellation */\n    abortSignal?: AbortSignal;\n  }\n): () => void {\n  const { logStdout = false, logStderr = true, command, abortSignal } = options ?? {};\n\n  // Log the command being executed (if provided)\n  if (command) {\n    initLogger.logStep(`Executing: ${command}`);\n  }\n\n  // Set up abort signal handler\n  const abortHandler = abortSignal\n    ? () => {\n        process.kill();\n      }\n    : null;\n  if (abortHandler && abortSignal) {\n    abortSignal.addEventListener(\"abort\", abortHandler);\n  }\n\n  // Drain stdout (prevent pipe overflow)\n  if (process.stdout) {\n    process.stdout.on(\"data\", (data: Buffer) => {\n      if (logStdout) {\n        const output = data.toString();\n        // Split by lines and log each non-empty line\n        const lines = output.split(\"\\n\").filter((line) => line.trim().length > 0);\n        for (const line of lines) {\n          initLogger.logStdout(line);\n        }\n      }\n      // Otherwise drain silently to prevent buffer overflow\n    });\n  }\n\n  // Stream stderr to logger\n  if (process.stderr) {\n    process.stderr.on(\"data\", (data: Buffer) => {\n      if (logStderr) {\n        const output = data.toString();\n        // Split by lines and log each non-empty line\n        const lines = output.split(\"\\n\").filter((line) => line.trim().length > 0);\n        for (const line of lines) {\n          initLogger.logStderr(line);\n        }\n      }\n      // Otherwise drain silently to prevent buffer overflow\n    });\n  }\n\n  // Return cleanup function to remove abort listener\n  return () => {\n    if (abortHandler && abortSignal) {\n      abortSignal.removeEventListener(\"abort\", abortHandler);\n    }\n  };\n}\n"]}