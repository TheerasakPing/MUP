{"version":3,"file":"streamProcess.js","sourceRoot":"","sources":["../../../src/node/runtime/streamProcess.ts"],"names":[],"mappings":";AAAA;;GAEG;;;AAKH;;;;;;;;;;;;GAYG;AACH,+BACE,OAAqB,EACrB,UAAsB,EACtB,OASC,EACW;IACZ,MAAM,EAAE,SAAS,GAAG,KAAK,EAAE,SAAS,GAAG,IAAI,EAAE,OAAO,EAAE,WAAW,EAAE,GAAG,OAAO,IAAI,EAAE,CAAC;IAEpF,+CAA+C;IAC/C,IAAI,OAAO,EAAE,CAAC;QACZ,UAAU,CAAC,OAAO,CAAC,cAAc,OAAO,EAAE,CAAC,CAAC;IAC9C,CAAC;IAED,8BAA8B;IAC9B,MAAM,YAAY,GAAG,WAAW;QAC9B,CAAC,CAAC,GAAG,EAAE,CAAC;YACJ,OAAO,CAAC,IAAI,EAAE,CAAC;QAAA,CAChB;QACH,CAAC,CAAC,IAAI,CAAC;IACT,IAAI,YAAY,IAAI,WAAW,EAAE,CAAC;QAChC,WAAW,CAAC,gBAAgB,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;IACtD,CAAC;IAED,uCAAuC;IACvC,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;QACnB,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAY,EAAE,EAAE,CAAC;YAC1C,IAAI,SAAS,EAAE,CAAC;gBACd,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAC/B,6CAA6C;gBAC7C,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBAC1E,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;oBACzB,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;gBAC7B,CAAC;YACH,CAAC;YACD,sDAAsD;QADrD,CAEF,CAAC,CAAC;IACL,CAAC;IAED,0BAA0B;IAC1B,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;QACnB,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAY,EAAE,EAAE,CAAC;YAC1C,IAAI,SAAS,EAAE,CAAC;gBACd,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAC/B,6CAA6C;gBAC7C,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBAC1E,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;oBACzB,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;gBAC7B,CAAC;YACH,CAAC;YACD,sDAAsD;QADrD,CAEF,CAAC,CAAC;IACL,CAAC;IAED,mDAAmD;IACnD,OAAO,GAAG,EAAE,CAAC;QACX,IAAI,YAAY,IAAI,WAAW,EAAE,CAAC;YAChC,WAAW,CAAC,mBAAmB,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;QACzD,CAAC;IAAA,CACF,CAAC;AAAA,CACH","sourcesContent":["/**\r\n * Helper utilities for streaming child process output to InitLogger\r\n */\r\n\r\nimport type { ChildProcess } from \"child_process\";\r\nimport type { InitLogger } from \"./Runtime\";\r\n\r\n/**\r\n * Stream child process stdout/stderr to initLogger\r\n * Prevents pipe buffer overflow by draining both streams.\r\n *\r\n * This is essential to prevent child processes from hanging when their\r\n * output buffers fill up (typically 64KB). Always call this when spawning\r\n * processes that may produce output.\r\n *\r\n * @param process Child process to stream from\r\n * @param initLogger Logger to stream output to\r\n * @param options Configuration for which streams to log\r\n * @returns Cleanup function to remove abort signal listener (call this in process close/error handlers)\r\n */\r\nexport function streamProcessToLogger(\r\n  process: ChildProcess,\r\n  initLogger: InitLogger,\r\n  options?: {\r\n    /** If true, log stdout via logStdout. If false, drain silently. Default: false */\r\n    logStdout?: boolean;\r\n    /** If true, log stderr via logStderr. If false, drain silently. Default: true */\r\n    logStderr?: boolean;\r\n    /** Optional: Command string to log before streaming starts */\r\n    command?: string;\r\n    /** Optional: Abort signal to kill process on cancellation */\r\n    abortSignal?: AbortSignal;\r\n  }\r\n): () => void {\r\n  const { logStdout = false, logStderr = true, command, abortSignal } = options ?? {};\r\n\r\n  // Log the command being executed (if provided)\r\n  if (command) {\r\n    initLogger.logStep(`Executing: ${command}`);\r\n  }\r\n\r\n  // Set up abort signal handler\r\n  const abortHandler = abortSignal\r\n    ? () => {\r\n        process.kill();\r\n      }\r\n    : null;\r\n  if (abortHandler && abortSignal) {\r\n    abortSignal.addEventListener(\"abort\", abortHandler);\r\n  }\r\n\r\n  // Drain stdout (prevent pipe overflow)\r\n  if (process.stdout) {\r\n    process.stdout.on(\"data\", (data: Buffer) => {\r\n      if (logStdout) {\r\n        const output = data.toString();\r\n        // Split by lines and log each non-empty line\r\n        const lines = output.split(\"\\n\").filter((line) => line.trim().length > 0);\r\n        for (const line of lines) {\r\n          initLogger.logStdout(line);\r\n        }\r\n      }\r\n      // Otherwise drain silently to prevent buffer overflow\r\n    });\r\n  }\r\n\r\n  // Stream stderr to logger\r\n  if (process.stderr) {\r\n    process.stderr.on(\"data\", (data: Buffer) => {\r\n      if (logStderr) {\r\n        const output = data.toString();\r\n        // Split by lines and log each non-empty line\r\n        const lines = output.split(\"\\n\").filter((line) => line.trim().length > 0);\r\n        for (const line of lines) {\r\n          initLogger.logStderr(line);\r\n        }\r\n      }\r\n      // Otherwise drain silently to prevent buffer overflow\r\n    });\r\n  }\r\n\r\n  // Return cleanup function to remove abort listener\r\n  return () => {\r\n    if (abortHandler && abortSignal) {\r\n      abortSignal.removeEventListener(\"abort\", abortHandler);\r\n    }\r\n  };\r\n}\r\n"]}