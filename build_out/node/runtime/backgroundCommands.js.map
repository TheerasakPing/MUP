{"version":3,"file":"backgroundCommands.js","sourceRoot":"","sources":["../../../src/node/runtime/backgroundCommands.ts"],"names":[],"mappings":"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","sourcesContent":["import { shellQuote } from \"@/common/utils/shell\";\nexport { shellQuote };\n\n/** Exit code for process killed by SIGKILL (128 + 9) */\nexport const EXIT_CODE_SIGKILL = 137;\n\n/** Exit code for process killed by SIGTERM (128 + 15) */\nexport const EXIT_CODE_SIGTERM = 143;\n\n/**\n * Parse exit code from file content.\n * Returns null if content is empty or not a valid number.\n */\nexport function parseExitCode(content: string): number | null {\n  const code = parseInt(content.trim(), 10);\n  return isNaN(code) ? null : code;\n}\n/**\n * Parse PID from buildSpawnCommand output.\n * Returns the PID or null if invalid.\n */\nexport function parsePid(output: string): number | null {\n  const pid = parseInt(output.trim(), 10);\n  return isNaN(pid) || pid <= 0 ? null : pid;\n}\n\n/**\n * Shared command builders for background process management.\n * Used by both LocalRuntime and SSHRuntime for parity.\n */\n\n/**\n * Options for building the wrapper script that runs inside bash.\n */\nexport interface WrapperScriptOptions {\n  /** Path where exit code will be written */\n  exitCodePath: string;\n  /** Working directory for the script */\n  cwd: string;\n  /** Environment variables to export */\n  env?: Record<string, string>;\n  /** The actual script to run */\n  script: string;\n}\n\n/**\n * Build the wrapper script that captures exit code and sets up environment.\n * Pattern: trap 'echo $? > exit_code' EXIT && cd /path && export K=V && script\n */\nexport function buildWrapperScript(options: WrapperScriptOptions): string {\n  const parts: string[] = [];\n\n  // Set up trap first to capture exit code.\n  //\n  // IMPORTANT: Do NOT inline shellQuote(exitCodePath) inside a double-quoted trap string.\n  // If the path contains a single quote (e.g. processId derived from script contains quotes),\n  // shellQuote() will emit the POSIX escape pattern '\\''\"'\"'\\'', which contains double quotes\n  // and will break the surrounding double quotes.\n  //\n  // Instead, assign the (quoted) path to a variable and reference it from the trap.\n  parts.push(`__MUX_EXIT_CODE_PATH=${shellQuote(options.exitCodePath)}`);\n  parts.push(`trap 'echo $? > \"$__MUX_EXIT_CODE_PATH\"' EXIT`);\n\n  // Change to working directory\n  parts.push(`cd ${shellQuote(options.cwd)}`);\n\n  // Add environment variable exports\n  if (options.env) {\n    for (const [key, value] of Object.entries(options.env)) {\n      parts.push(`export ${key}=${shellQuote(value)}`);\n    }\n  }\n\n  // Add the actual script\n  parts.push(options.script);\n\n  return parts.join(\" && \");\n}\n\n/**\n * Options for building the spawn command.\n */\nexport interface SpawnCommandOptions {\n  /** The wrapper script to execute */\n  wrapperScript: string;\n  /** Path for unified output (stdout + stderr) redirection */\n  outputPath: string;\n  /** Path to bash executable (defaults to \"bash\") */\n  bashPath?: string;\n  /** Function to quote paths for shell (default: shellQuote). Use expandTildeForSSH for SSH. */\n  quotePath?: (path: string) => string;\n}\n\n/**\n * Build the spawn command using subshell + nohup pattern.\n *\n * Uses subshell (...) to isolate the process group so the outer shell exits immediately.\n * set -m: enables job control so backgrounded process gets its own process group (PID === PGID)\n * nohup: ignores SIGHUP (survives terminal hangup)\n *\n * stdout and stderr are merged into a single output file with 2>&1 for unified display.\n *\n * Returns PID via echo. With set -m, PID === PGID (process is its own group leader).\n */\nexport function buildSpawnCommand(options: SpawnCommandOptions): string {\n  const bash = options.bashPath ?? \"bash\";\n  const quotePath = options.quotePath ?? shellQuote;\n\n  return (\n    `(set -m; nohup ${shellQuote(bash)} -c ${shellQuote(options.wrapperScript)} ` +\n    `> ${quotePath(options.outputPath)} 2>&1 ` +\n    `< /dev/null & echo $!)`\n  );\n}\n\n/**\n * Build the terminate command for killing a process group.\n *\n * Uses negative PID to kill entire process group.\n * Relies on set -m ensuring PID === PGID (process is its own group leader).\n * Sends SIGTERM, waits 2 seconds, then SIGKILL if still running.\n * Writes EXIT_CODE_SIGKILL on force kill.\n *\n * @param pid - Process ID (equals PGID due to set -m in buildSpawnCommand)\n * @param exitCodePath - Path to write exit code (raw, will be quoted by quotePath)\n * @param quotePath - Function to quote path (default: shellQuote). Use expandTildeForSSH for SSH.\n */\nexport function buildTerminateCommand(\n  pid: number,\n  exitCodePath: string,\n  quotePath: (p: string) => string = shellQuote\n): string {\n  const negPid = -pid; // Negative PID targets process group (PID === PGID due to set -m)\n  // Send SIGTERM, wait for process to exit, then write the correct exit code.\n  // We can't write immediately because the process's EXIT trap would overwrite it.\n  // After sleep 2, either the process exited (write SIGTERM code) or we escalate to SIGKILL.\n  return (\n    `kill -15 ${negPid} 2>/dev/null || true; ` +\n    `sleep 2; ` +\n    `if kill -0 ${negPid} 2>/dev/null; then ` +\n    `kill -9 ${negPid} 2>/dev/null || true; ` +\n    `echo ${EXIT_CODE_SIGKILL} > ${quotePath(exitCodePath)}; ` +\n    `else ` +\n    `echo ${EXIT_CODE_SIGTERM} > ${quotePath(exitCodePath)}; ` +\n    `fi`\n  );\n}\n"]}