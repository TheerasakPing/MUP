{"version":3,"file":"backgroundCommands.js","sourceRoot":"","sources":["../../../src/node/runtime/backgroundCommands.ts"],"names":[],"mappings":"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","sourcesContent":["import { shellQuote } from \"@/common/utils/shell\";\r\nexport { shellQuote };\r\n\r\n/** Exit code for process killed by SIGKILL (128 + 9) */\r\nexport const EXIT_CODE_SIGKILL = 137;\r\n\r\n/** Exit code for process killed by SIGTERM (128 + 15) */\r\nexport const EXIT_CODE_SIGTERM = 143;\r\n\r\n/**\r\n * Parse exit code from file content.\r\n * Returns null if content is empty or not a valid number.\r\n */\r\nexport function parseExitCode(content: string): number | null {\r\n  const code = parseInt(content.trim(), 10);\r\n  return isNaN(code) ? null : code;\r\n}\r\n/**\r\n * Parse PID from buildSpawnCommand output.\r\n * Returns the PID or null if invalid.\r\n */\r\nexport function parsePid(output: string): number | null {\r\n  const pid = parseInt(output.trim(), 10);\r\n  return isNaN(pid) || pid <= 0 ? null : pid;\r\n}\r\n\r\n/**\r\n * Shared command builders for background process management.\r\n * Used by both LocalRuntime and SSHRuntime for parity.\r\n */\r\n\r\n/**\r\n * Options for building the wrapper script that runs inside bash.\r\n */\r\nexport interface WrapperScriptOptions {\r\n  /** Path where exit code will be written */\r\n  exitCodePath: string;\r\n  /** Working directory for the script */\r\n  cwd: string;\r\n  /** Environment variables to export */\r\n  env?: Record<string, string>;\r\n  /** The actual script to run */\r\n  script: string;\r\n}\r\n\r\n/**\r\n * Build the wrapper script that captures exit code and sets up environment.\r\n * Pattern: trap 'echo $? > exit_code' EXIT && cd /path && export K=V && script\r\n */\r\nexport function buildWrapperScript(options: WrapperScriptOptions): string {\r\n  const parts: string[] = [];\r\n\r\n  // Set up trap first to capture exit code.\r\n  //\r\n  // IMPORTANT: Do NOT inline shellQuote(exitCodePath) inside a double-quoted trap string.\r\n  // If the path contains a single quote (e.g. processId derived from script contains quotes),\r\n  // shellQuote() will emit the POSIX escape pattern '\\''\"'\"'\\'', which contains double quotes\r\n  // and will break the surrounding double quotes.\r\n  //\r\n  // Instead, assign the (quoted) path to a variable and reference it from the trap.\r\n  parts.push(`__MUX_EXIT_CODE_PATH=${shellQuote(options.exitCodePath)}`);\r\n  parts.push(`trap 'echo $? > \"$__MUX_EXIT_CODE_PATH\"' EXIT`);\r\n\r\n  // Change to working directory\r\n  parts.push(`cd ${shellQuote(options.cwd)}`);\r\n\r\n  // Add environment variable exports\r\n  if (options.env) {\r\n    for (const [key, value] of Object.entries(options.env)) {\r\n      parts.push(`export ${key}=${shellQuote(value)}`);\r\n    }\r\n  }\r\n\r\n  // Add the actual script\r\n  parts.push(options.script);\r\n\r\n  return parts.join(\" && \");\r\n}\r\n\r\n/**\r\n * Options for building the spawn command.\r\n */\r\nexport interface SpawnCommandOptions {\r\n  /** The wrapper script to execute */\r\n  wrapperScript: string;\r\n  /** Path for unified output (stdout + stderr) redirection */\r\n  outputPath: string;\r\n  /** Path to bash executable (defaults to \"bash\") */\r\n  bashPath?: string;\r\n  /** Function to quote paths for shell (default: shellQuote). Use expandTildeForSSH for SSH. */\r\n  quotePath?: (path: string) => string;\r\n}\r\n\r\n/**\r\n * Build the spawn command using subshell + nohup pattern.\r\n *\r\n * Uses subshell (...) to isolate the process group so the outer shell exits immediately.\r\n * set -m: enables job control so backgrounded process gets its own process group (PID === PGID)\r\n * nohup: ignores SIGHUP (survives terminal hangup)\r\n *\r\n * stdout and stderr are merged into a single output file with 2>&1 for unified display.\r\n *\r\n * Returns PID via echo. With set -m, PID === PGID (process is its own group leader).\r\n */\r\nexport function buildSpawnCommand(options: SpawnCommandOptions): string {\r\n  const bash = options.bashPath ?? \"bash\";\r\n  const quotePath = options.quotePath ?? shellQuote;\r\n\r\n  return (\r\n    `(set -m; nohup ${shellQuote(bash)} -c ${shellQuote(options.wrapperScript)} ` +\r\n    `> ${quotePath(options.outputPath)} 2>&1 ` +\r\n    `< /dev/null & echo $!)`\r\n  );\r\n}\r\n\r\n/**\r\n * Build the terminate command for killing a process group.\r\n *\r\n * Uses negative PID to kill entire process group.\r\n * Relies on set -m ensuring PID === PGID (process is its own group leader).\r\n * Sends SIGTERM, waits 2 seconds, then SIGKILL if still running.\r\n * Writes EXIT_CODE_SIGKILL on force kill.\r\n *\r\n * @param pid - Process ID (equals PGID due to set -m in buildSpawnCommand)\r\n * @param exitCodePath - Path to write exit code (raw, will be quoted by quotePath)\r\n * @param quotePath - Function to quote path (default: shellQuote). Use expandTildeForSSH for SSH.\r\n */\r\nexport function buildTerminateCommand(\r\n  pid: number,\r\n  exitCodePath: string,\r\n  quotePath: (p: string) => string = shellQuote\r\n): string {\r\n  const negPid = -pid; // Negative PID targets process group (PID === PGID due to set -m)\r\n  // Send SIGTERM, wait for process to exit, then write the correct exit code.\r\n  // We can't write immediately because the process's EXIT trap would overwrite it.\r\n  // After sleep 2, either the process exited (write SIGTERM code) or we escalate to SIGKILL.\r\n  return (\r\n    `kill -15 ${negPid} 2>/dev/null || true; ` +\r\n    `sleep 2; ` +\r\n    `if kill -0 ${negPid} 2>/dev/null; then ` +\r\n    `kill -9 ${negPid} 2>/dev/null || true; ` +\r\n    `echo ${EXIT_CODE_SIGKILL} > ${quotePath(exitCodePath)}; ` +\r\n    `else ` +\r\n    `echo ${EXIT_CODE_SIGTERM} > ${quotePath(exitCodePath)}; ` +\r\n    `fi`\r\n  );\r\n}\r\n"]}