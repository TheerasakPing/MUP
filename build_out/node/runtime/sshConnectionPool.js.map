{"version":3,"file":"sshConnectionPool.js","sourceRoot":"","sources":["../../../src/node/runtime/sshConnectionPool.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * SSH Connection Pool\n *\n * Manages SSH connections with:\n * - Deterministic ControlPath generation for connection multiplexing\n * - Health tracking to avoid re-probing known-healthy connections\n * - Exponential backoff to prevent thundering herd on failures\n * - Singleflighting to coalesce concurrent connection attempts\n *\n * Design:\n * - acquireConnection() ensures a healthy connection before proceeding\n * - Known-healthy connections return immediately (no probe)\n * - Failed connections enter backoff before retry\n * - Concurrent calls to same host share a single probe\n */\n\nimport * as crypto from \"crypto\";\nimport * as path from \"path\";\nimport * as os from \"os\";\nimport { spawn } from \"child_process\";\nimport { log } from \"@/node/services/log\";\n\n/**\n * SSH connection configuration (host/port/identity only).\n */\nexport interface SSHConnectionConfig {\n  /** SSH host (can be hostname, user@host, or SSH config alias) */\n  host: string;\n  /** Optional: Path to SSH private key (if not using ~/.ssh/config or ssh-agent) */\n  identityFile?: string;\n  /** Optional: SSH port (default: 22) */\n  port?: number;\n}\n\n/**\n * SSH Runtime Configuration (defined here to avoid circular deps with SSHRuntime)\n */\nexport interface SSHRuntimeConfig extends SSHConnectionConfig {\n  /** Working directory on remote host */\n  srcBaseDir: string;\n  /** Directory on remote for background process output (default: /tmp/mux-bashes) */\n  bgOutputDir?: string;\n}\n\n/**\n * Connection health status\n */\nexport type ConnectionStatus = \"healthy\" | \"unhealthy\" | \"unknown\";\n\n/**\n * Connection health state for a single SSH target\n */\nexport interface ConnectionHealth {\n  status: ConnectionStatus;\n  lastSuccess?: Date;\n  lastFailure?: Date;\n  lastError?: string;\n  backoffUntil?: Date;\n  consecutiveFailures: number;\n}\n\n/**\n * Backoff schedule in seconds: 1s → 2s → 4s → 7s → 10s (cap)\n * Kept short to avoid blocking user actions; thundering herd is mitigated by jitter.\n */\nconst BACKOFF_SCHEDULE = [1, 2, 4, 7, 10];\n\n/**\n * Add ±20% jitter to prevent thundering herd when multiple clients recover simultaneously.\n */\nfunction withJitter(seconds: number): number {\n  const jitterFactor = 0.8 + Math.random() * 0.4; // 0.8 to 1.2\n  return seconds * jitterFactor;\n}\n\n/**\n * Time after which a \"healthy\" connection should be re-probed.\n * Prevents stale health state when network silently degrades.\n */\nconst HEALTHY_TTL_MS = 15 * 1000; // 15 seconds\n\nconst DEFAULT_PROBE_TIMEOUT_MS = 10_000;\nconst DEFAULT_MAX_WAIT_MS = 2 * 60 * 1000; // 2 minutes\n\nexport interface AcquireConnectionOptions {\n  /** Timeout for the health check probe. */\n  timeoutMs?: number;\n\n  /**\n   * Max time to wait (ms) for a host to become healthy (waits + probes).\n   *\n   * - Omit to use the default (waits through backoff).\n   * - Set to 0 to fail fast.\n   */\n  maxWaitMs?: number;\n\n  /** Optional abort signal to cancel any waiting. */\n  abortSignal?: AbortSignal;\n\n  /**\n   * Called when acquireConnection is waiting due to backoff.\n   *\n   * Useful for user-facing progress logs (e.g. workspace init).\n   */\n  onWait?: (waitMs: number) => void;\n\n  /**\n   * Test seam.\n   *\n   * If provided, this is used for sleeping between wait cycles.\n   */\n  sleep?: (ms: number, abortSignal?: AbortSignal) => Promise<void>;\n}\n\nasync function sleepWithAbort(ms: number, abortSignal?: AbortSignal): Promise<void> {\n  if (ms <= 0) return;\n  if (abortSignal?.aborted) {\n    throw new Error(\"Operation aborted\");\n  }\n\n  await new Promise<void>((resolve, reject) => {\n    const timer = setTimeout(() => {\n      cleanup();\n      resolve();\n    }, ms);\n\n    const onAbort = () => {\n      cleanup();\n      reject(new Error(\"Operation aborted\"));\n    };\n\n    const cleanup = () => {\n      clearTimeout(timer);\n      abortSignal?.removeEventListener(\"abort\", onAbort);\n    };\n\n    abortSignal?.addEventListener(\"abort\", onAbort);\n  });\n}\n\n/**\n * SSH Connection Pool\n *\n * Call acquireConnection() before any SSH operation to ensure the connection\n * is healthy. This prevents thundering herd issues by:\n * 1. Returning immediately for known-healthy connections\n * 2. Coalescing concurrent probes via singleflighting\n * 3. Enforcing backoff after failures\n */\nexport class SSHConnectionPool {\n  private health = new Map<string, ConnectionHealth>();\n  private inflight = new Map<string, Promise<void>>();\n\n  /**\n   * Ensure connection is healthy before proceeding.\n   *\n   * By default, acquireConnection waits through backoff (bounded) so user-facing\n   * actions don’t immediately fail during transient SSH outages.\n   *\n   * Callers can opt into fail-fast behavior by passing `{ maxWaitMs: 0 }`.\n   */\n  async acquireConnection(config: SSHConnectionConfig, timeoutMs?: number): Promise<void>;\n  async acquireConnection(\n    config: SSHConnectionConfig,\n    options?: AcquireConnectionOptions\n  ): Promise<void>;\n  async acquireConnection(\n    config: SSHConnectionConfig,\n    timeoutMsOrOptions: number | AcquireConnectionOptions = DEFAULT_PROBE_TIMEOUT_MS\n  ): Promise<void> {\n    const options: AcquireConnectionOptions =\n      typeof timeoutMsOrOptions === \"number\"\n        ? { timeoutMs: timeoutMsOrOptions }\n        : (timeoutMsOrOptions ?? {});\n\n    const timeoutMs = options.timeoutMs ?? DEFAULT_PROBE_TIMEOUT_MS;\n    const sleep = options.sleep ?? sleepWithAbort;\n\n    const maxWaitMs = options.maxWaitMs ?? DEFAULT_MAX_WAIT_MS;\n    const shouldWait = maxWaitMs > 0;\n\n    const key = makeConnectionKey(config);\n    const startTime = Date.now();\n\n    while (true) {\n      if (options.abortSignal?.aborted) {\n        throw new Error(\"Operation aborted\");\n      }\n\n      const health = this.health.get(key);\n\n      // If in backoff: either fail fast or wait (bounded).\n      if (health?.backoffUntil && health.backoffUntil > new Date()) {\n        const remainingMs = health.backoffUntil.getTime() - Date.now();\n        const remainingSecs = Math.ceil(remainingMs / 1000);\n\n        if (!shouldWait) {\n          throw new Error(\n            `SSH connection to ${config.host} is in backoff for ${remainingSecs}s. ` +\n              `Last error: ${health.lastError ?? \"unknown\"}`\n          );\n        }\n\n        const elapsedMs = Date.now() - startTime;\n        const budgetMs = Math.max(0, maxWaitMs - elapsedMs);\n        if (budgetMs <= 0) {\n          throw new Error(\n            `SSH connection to ${config.host} did not become healthy within ${maxWaitMs}ms. ` +\n              `Last error: ${health.lastError ?? \"unknown\"}`\n          );\n        }\n\n        const waitMs = Math.min(remainingMs, budgetMs);\n        options.onWait?.(waitMs);\n        await sleep(waitMs, options.abortSignal);\n        continue;\n      }\n\n      // Return immediately if known healthy and not stale.\n      if (health?.status === \"healthy\") {\n        const age = Date.now() - (health.lastSuccess?.getTime() ?? 0);\n        if (age < HEALTHY_TTL_MS) {\n          log.debug(`SSH connection to ${config.host} is known healthy, skipping probe`);\n          return;\n        }\n        log.debug(\n          `SSH connection to ${config.host} health is stale (${Math.round(age / 1000)}s), re-probing`\n        );\n      }\n\n      // Check for inflight probe - singleflighting.\n      const existing = this.inflight.get(key);\n      if (existing) {\n        log.debug(`SSH connection to ${config.host} has inflight probe, waiting...`);\n        try {\n          await existing;\n          return;\n        } catch (error) {\n          // Probe failed; if we're in wait mode we'll loop and sleep through the backoff.\n          if (!shouldWait) {\n            throw error;\n          }\n          continue;\n        }\n      }\n\n      // Start new probe.\n      log.debug(`SSH connection to ${config.host} needs probe, starting health check`);\n      const probe = this.probeConnection(config, timeoutMs, key);\n      this.inflight.set(key, probe);\n\n      try {\n        await probe;\n        return;\n      } catch (error) {\n        if (!shouldWait) {\n          throw error;\n        }\n        // In wait mode: probeConnection() recorded backoff; loop and wait.\n        continue;\n      } finally {\n        this.inflight.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Get current health status for a connection\n   */\n  getConnectionHealth(config: SSHConnectionConfig): ConnectionHealth | undefined {\n    const key = makeConnectionKey(config);\n    return this.health.get(key);\n  }\n\n  /**\n   * Get deterministic controlPath for SSH config.\n   */\n  getControlPath(config: SSHConnectionConfig): string {\n    return getControlPath(config);\n  }\n\n  /**\n   * Reset backoff for a connection (e.g., after user intervention)\n   */\n  resetBackoff(config: SSHConnectionConfig): void {\n    const key = makeConnectionKey(config);\n    const health = this.health.get(key);\n    if (health) {\n      health.backoffUntil = undefined;\n      health.consecutiveFailures = 0;\n      health.status = \"unknown\";\n      log.info(`Reset backoff for SSH connection to ${config.host}`);\n    }\n  }\n\n  /**\n   * Mark connection as healthy.\n   * Call after successful SSH operations to maintain health state.\n   */\n  markHealthy(config: SSHConnectionConfig): void {\n    const key = makeConnectionKey(config);\n    this.markHealthyByKey(key);\n  }\n\n  /**\n   * Report a connection failure.\n   * Call when SSH operations fail due to connection issues (not command failures).\n   * This triggers backoff to prevent thundering herd on a failing host.\n   */\n  reportFailure(config: SSHConnectionConfig, error: string): void {\n    const key = makeConnectionKey(config);\n    this.markFailedByKey(key, error);\n  }\n\n  /**\n   * Mark connection as healthy by key (internal use)\n   */\n  private markHealthyByKey(key: string): void {\n    this.health.set(key, {\n      status: \"healthy\",\n      lastSuccess: new Date(),\n      consecutiveFailures: 0,\n    });\n  }\n\n  /**\n   * Mark connection as failed (internal use after failed probe)\n   */\n  private markFailedByKey(key: string, error: string): void {\n    const current = this.health.get(key);\n    const failures = (current?.consecutiveFailures ?? 0) + 1;\n    const backoffIndex = Math.min(failures - 1, BACKOFF_SCHEDULE.length - 1);\n    const backoffSecs = withJitter(BACKOFF_SCHEDULE[backoffIndex]);\n\n    this.health.set(key, {\n      status: \"unhealthy\",\n      lastFailure: new Date(),\n      lastError: error,\n      backoffUntil: new Date(Date.now() + backoffSecs * 1000),\n      consecutiveFailures: failures,\n    });\n\n    log.warn(\n      `SSH connection failed (${failures} consecutive). Backoff for ${backoffSecs.toFixed(1)}s. Error: ${error}`\n    );\n  }\n\n  /**\n   * Clear all health state. Used in tests to reset between test cases\n   * so backoff from one test doesn't affect subsequent tests.\n   */\n  clearAllHealth(): void {\n    this.health.clear();\n    this.inflight.clear();\n  }\n\n  /**\n   * Probe connection health by running a simple command\n   */\n  private async probeConnection(\n    config: SSHConnectionConfig,\n    timeoutMs: number,\n    key: string\n  ): Promise<void> {\n    const controlPath = getControlPath(config);\n\n    const args: string[] = [\"-T\"]; // No PTY needed for probe\n\n    if (config.port) {\n      args.push(\"-p\", config.port.toString());\n    }\n\n    if (config.identityFile) {\n      args.push(\"-i\", config.identityFile);\n      args.push(\"-o\", \"StrictHostKeyChecking=no\");\n      args.push(\"-o\", \"UserKnownHostsFile=/dev/null\");\n      args.push(\"-o\", \"LogLevel=ERROR\");\n    }\n\n    // Connection multiplexing\n    args.push(\"-o\", \"ControlMaster=auto\");\n    args.push(\"-o\", `ControlPath=${controlPath}`);\n    args.push(\"-o\", \"ControlPersist=60\");\n\n    // Aggressive timeouts for probe\n    const connectTimeout = Math.min(Math.ceil(timeoutMs / 1000), 15);\n    args.push(\"-o\", `ConnectTimeout=${connectTimeout}`);\n    args.push(\"-o\", \"ServerAliveInterval=5\");\n    args.push(\"-o\", \"ServerAliveCountMax=2\");\n\n    args.push(config.host, \"echo ok\");\n\n    log.debug(`SSH probe: ssh ${args.join(\" \")}`);\n\n    return new Promise((resolve, reject) => {\n      const proc = spawn(\"ssh\", args, { stdio: [\"ignore\", \"pipe\", \"pipe\"] });\n\n      let stderr = \"\";\n      proc.stderr.on(\"data\", (data: Buffer) => {\n        stderr += data.toString();\n      });\n\n      let timedOut = false;\n      const timeout = setTimeout(() => {\n        timedOut = true;\n        proc.kill(\"SIGKILL\");\n        const error = \"SSH probe timed out\";\n        this.markFailedByKey(key, error);\n        reject(new Error(error));\n      }, timeoutMs);\n\n      proc.on(\"close\", (code) => {\n        clearTimeout(timeout);\n        if (timedOut) return; // Already handled by timeout\n\n        if (code === 0) {\n          this.markHealthyByKey(key);\n          log.debug(`SSH probe to ${config.host} succeeded`);\n          resolve();\n        } else {\n          const error = stderr.trim() || `SSH probe failed with code ${code ?? \"unknown\"}`;\n          this.markFailedByKey(key, error);\n          reject(new Error(error));\n        }\n      });\n\n      proc.on(\"error\", (err) => {\n        clearTimeout(timeout);\n        const error = `SSH probe spawn error: ${err.message}`;\n        this.markFailedByKey(key, error);\n        reject(new Error(error));\n      });\n    });\n  }\n}\n\n/**\n * Singleton instance for application-wide use\n */\nexport const sshConnectionPool = new SSHConnectionPool();\n\n/**\n * Get deterministic controlPath for SSH config.\n * Multiple calls with identical config return the same path,\n * enabling ControlMaster to multiplex connections.\n *\n * Socket files are created by SSH and cleaned up automatically:\n * - ControlPersist=60: Removes socket 60s after last use\n * - OS: Cleans /tmp on reboot\n *\n * Includes local username in hash to prevent cross-user collisions on\n * multi-user systems (different users connecting to same remote would\n * otherwise generate same socket path, causing permission errors).\n */\nexport function getControlPath(config: SSHConnectionConfig): string {\n  const key = makeConnectionKey(config);\n  const hash = hashKey(key);\n  return path.join(os.tmpdir(), `mux-ssh-${hash}`);\n}\n\n/**\n * Generate stable key from config.\n * Identical configs produce identical keys.\n * Includes local username to prevent cross-user socket collisions.\n */\nfunction makeConnectionKey(config: SSHConnectionConfig): string {\n  // Note: srcBaseDir is intentionally excluded - connection identity is determined\n  // by user + host + port + key. This allows health tracking and multiplexing\n  // to be shared across workspaces on the same host.\n  const parts = [\n    os.userInfo().username, // Include local user to prevent cross-user collisions\n    config.host,\n    config.port?.toString() ?? \"22\",\n    config.identityFile ?? \"default\",\n  ];\n  return parts.join(\":\");\n}\n\n/**\n * Generate deterministic hash for controlPath naming.\n * Uses first 12 chars of SHA-256 for human-readable uniqueness.\n */\nfunction hashKey(key: string): string {\n  return crypto.createHash(\"sha256\").update(key).digest(\"hex\").substring(0, 12);\n}\n"]}