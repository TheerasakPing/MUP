{"version":3,"file":"sshConnectionPool.js","sourceRoot":"","sources":["../../../src/node/runtime/sshConnectionPool.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * SSH Connection Pool\r\n *\r\n * Manages SSH connections with:\r\n * - Deterministic ControlPath generation for connection multiplexing\r\n * - Health tracking to avoid re-probing known-healthy connections\r\n * - Exponential backoff to prevent thundering herd on failures\r\n * - Singleflighting to coalesce concurrent connection attempts\r\n *\r\n * Design:\r\n * - acquireConnection() ensures a healthy connection before proceeding\r\n * - Known-healthy connections return immediately (no probe)\r\n * - Failed connections enter backoff before retry\r\n * - Concurrent calls to same host share a single probe\r\n */\r\n\r\nimport * as crypto from \"crypto\";\r\nimport * as path from \"path\";\r\nimport * as os from \"os\";\r\nimport { spawn } from \"child_process\";\r\nimport { log } from \"@/node/services/log\";\r\n\r\n/**\r\n * SSH connection configuration (host/port/identity only).\r\n */\r\nexport interface SSHConnectionConfig {\r\n  /** SSH host (can be hostname, user@host, or SSH config alias) */\r\n  host: string;\r\n  /** Optional: Path to SSH private key (if not using ~/.ssh/config or ssh-agent) */\r\n  identityFile?: string;\r\n  /** Optional: SSH port (default: 22) */\r\n  port?: number;\r\n}\r\n\r\n/**\r\n * SSH Runtime Configuration (defined here to avoid circular deps with SSHRuntime)\r\n */\r\nexport interface SSHRuntimeConfig extends SSHConnectionConfig {\r\n  /** Working directory on remote host */\r\n  srcBaseDir: string;\r\n  /** Directory on remote for background process output (default: /tmp/mux-bashes) */\r\n  bgOutputDir?: string;\r\n}\r\n\r\n/**\r\n * Connection health status\r\n */\r\nexport type ConnectionStatus = \"healthy\" | \"unhealthy\" | \"unknown\";\r\n\r\n/**\r\n * Connection health state for a single SSH target\r\n */\r\nexport interface ConnectionHealth {\r\n  status: ConnectionStatus;\r\n  lastSuccess?: Date;\r\n  lastFailure?: Date;\r\n  lastError?: string;\r\n  backoffUntil?: Date;\r\n  consecutiveFailures: number;\r\n}\r\n\r\n/**\r\n * Backoff schedule in seconds: 1s → 2s → 4s → 7s → 10s (cap)\r\n * Kept short to avoid blocking user actions; thundering herd is mitigated by jitter.\r\n */\r\nconst BACKOFF_SCHEDULE = [1, 2, 4, 7, 10];\r\n\r\n/**\r\n * Add ±20% jitter to prevent thundering herd when multiple clients recover simultaneously.\r\n */\r\nfunction withJitter(seconds: number): number {\r\n  const jitterFactor = 0.8 + Math.random() * 0.4; // 0.8 to 1.2\r\n  return seconds * jitterFactor;\r\n}\r\n\r\n/**\r\n * Time after which a \"healthy\" connection should be re-probed.\r\n * Prevents stale health state when network silently degrades.\r\n */\r\nconst HEALTHY_TTL_MS = 15 * 1000; // 15 seconds\r\n\r\nconst DEFAULT_PROBE_TIMEOUT_MS = 10_000;\r\nconst DEFAULT_MAX_WAIT_MS = 2 * 60 * 1000; // 2 minutes\r\n\r\nexport interface AcquireConnectionOptions {\r\n  /** Timeout for the health check probe. */\r\n  timeoutMs?: number;\r\n\r\n  /**\r\n   * Max time to wait (ms) for a host to become healthy (waits + probes).\r\n   *\r\n   * - Omit to use the default (waits through backoff).\r\n   * - Set to 0 to fail fast.\r\n   */\r\n  maxWaitMs?: number;\r\n\r\n  /** Optional abort signal to cancel any waiting. */\r\n  abortSignal?: AbortSignal;\r\n\r\n  /**\r\n   * Called when acquireConnection is waiting due to backoff.\r\n   *\r\n   * Useful for user-facing progress logs (e.g. workspace init).\r\n   */\r\n  onWait?: (waitMs: number) => void;\r\n\r\n  /**\r\n   * Test seam.\r\n   *\r\n   * If provided, this is used for sleeping between wait cycles.\r\n   */\r\n  sleep?: (ms: number, abortSignal?: AbortSignal) => Promise<void>;\r\n}\r\n\r\nasync function sleepWithAbort(ms: number, abortSignal?: AbortSignal): Promise<void> {\r\n  if (ms <= 0) return;\r\n  if (abortSignal?.aborted) {\r\n    throw new Error(\"Operation aborted\");\r\n  }\r\n\r\n  await new Promise<void>((resolve, reject) => {\r\n    const timer = setTimeout(() => {\r\n      cleanup();\r\n      resolve();\r\n    }, ms);\r\n\r\n    const onAbort = () => {\r\n      cleanup();\r\n      reject(new Error(\"Operation aborted\"));\r\n    };\r\n\r\n    const cleanup = () => {\r\n      clearTimeout(timer);\r\n      abortSignal?.removeEventListener(\"abort\", onAbort);\r\n    };\r\n\r\n    abortSignal?.addEventListener(\"abort\", onAbort);\r\n  });\r\n}\r\n\r\n/**\r\n * SSH Connection Pool\r\n *\r\n * Call acquireConnection() before any SSH operation to ensure the connection\r\n * is healthy. This prevents thundering herd issues by:\r\n * 1. Returning immediately for known-healthy connections\r\n * 2. Coalescing concurrent probes via singleflighting\r\n * 3. Enforcing backoff after failures\r\n */\r\nexport class SSHConnectionPool {\r\n  private health = new Map<string, ConnectionHealth>();\r\n  private inflight = new Map<string, Promise<void>>();\r\n\r\n  /**\r\n   * Ensure connection is healthy before proceeding.\r\n   *\r\n   * By default, acquireConnection waits through backoff (bounded) so user-facing\r\n   * actions don’t immediately fail during transient SSH outages.\r\n   *\r\n   * Callers can opt into fail-fast behavior by passing `{ maxWaitMs: 0 }`.\r\n   */\r\n  async acquireConnection(config: SSHConnectionConfig, timeoutMs?: number): Promise<void>;\r\n  async acquireConnection(\r\n    config: SSHConnectionConfig,\r\n    options?: AcquireConnectionOptions\r\n  ): Promise<void>;\r\n  async acquireConnection(\r\n    config: SSHConnectionConfig,\r\n    timeoutMsOrOptions: number | AcquireConnectionOptions = DEFAULT_PROBE_TIMEOUT_MS\r\n  ): Promise<void> {\r\n    const options: AcquireConnectionOptions =\r\n      typeof timeoutMsOrOptions === \"number\"\r\n        ? { timeoutMs: timeoutMsOrOptions }\r\n        : (timeoutMsOrOptions ?? {});\r\n\r\n    const timeoutMs = options.timeoutMs ?? DEFAULT_PROBE_TIMEOUT_MS;\r\n    const sleep = options.sleep ?? sleepWithAbort;\r\n\r\n    const maxWaitMs = options.maxWaitMs ?? DEFAULT_MAX_WAIT_MS;\r\n    const shouldWait = maxWaitMs > 0;\r\n\r\n    const key = makeConnectionKey(config);\r\n    const startTime = Date.now();\r\n\r\n    while (true) {\r\n      if (options.abortSignal?.aborted) {\r\n        throw new Error(\"Operation aborted\");\r\n      }\r\n\r\n      const health = this.health.get(key);\r\n\r\n      // If in backoff: either fail fast or wait (bounded).\r\n      if (health?.backoffUntil && health.backoffUntil > new Date()) {\r\n        const remainingMs = health.backoffUntil.getTime() - Date.now();\r\n        const remainingSecs = Math.ceil(remainingMs / 1000);\r\n\r\n        if (!shouldWait) {\r\n          throw new Error(\r\n            `SSH connection to ${config.host} is in backoff for ${remainingSecs}s. ` +\r\n              `Last error: ${health.lastError ?? \"unknown\"}`\r\n          );\r\n        }\r\n\r\n        const elapsedMs = Date.now() - startTime;\r\n        const budgetMs = Math.max(0, maxWaitMs - elapsedMs);\r\n        if (budgetMs <= 0) {\r\n          throw new Error(\r\n            `SSH connection to ${config.host} did not become healthy within ${maxWaitMs}ms. ` +\r\n              `Last error: ${health.lastError ?? \"unknown\"}`\r\n          );\r\n        }\r\n\r\n        const waitMs = Math.min(remainingMs, budgetMs);\r\n        options.onWait?.(waitMs);\r\n        await sleep(waitMs, options.abortSignal);\r\n        continue;\r\n      }\r\n\r\n      // Return immediately if known healthy and not stale.\r\n      if (health?.status === \"healthy\") {\r\n        const age = Date.now() - (health.lastSuccess?.getTime() ?? 0);\r\n        if (age < HEALTHY_TTL_MS) {\r\n          log.debug(`SSH connection to ${config.host} is known healthy, skipping probe`);\r\n          return;\r\n        }\r\n        log.debug(\r\n          `SSH connection to ${config.host} health is stale (${Math.round(age / 1000)}s), re-probing`\r\n        );\r\n      }\r\n\r\n      // Check for inflight probe - singleflighting.\r\n      const existing = this.inflight.get(key);\r\n      if (existing) {\r\n        log.debug(`SSH connection to ${config.host} has inflight probe, waiting...`);\r\n        try {\r\n          await existing;\r\n          return;\r\n        } catch (error) {\r\n          // Probe failed; if we're in wait mode we'll loop and sleep through the backoff.\r\n          if (!shouldWait) {\r\n            throw error;\r\n          }\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Start new probe.\r\n      log.debug(`SSH connection to ${config.host} needs probe, starting health check`);\r\n      const probe = this.probeConnection(config, timeoutMs, key);\r\n      this.inflight.set(key, probe);\r\n\r\n      try {\r\n        await probe;\r\n        return;\r\n      } catch (error) {\r\n        if (!shouldWait) {\r\n          throw error;\r\n        }\r\n        // In wait mode: probeConnection() recorded backoff; loop and wait.\r\n        continue;\r\n      } finally {\r\n        this.inflight.delete(key);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current health status for a connection\r\n   */\r\n  getConnectionHealth(config: SSHConnectionConfig): ConnectionHealth | undefined {\r\n    const key = makeConnectionKey(config);\r\n    return this.health.get(key);\r\n  }\r\n\r\n  /**\r\n   * Get deterministic controlPath for SSH config.\r\n   */\r\n  getControlPath(config: SSHConnectionConfig): string {\r\n    return getControlPath(config);\r\n  }\r\n\r\n  /**\r\n   * Reset backoff for a connection (e.g., after user intervention)\r\n   */\r\n  resetBackoff(config: SSHConnectionConfig): void {\r\n    const key = makeConnectionKey(config);\r\n    const health = this.health.get(key);\r\n    if (health) {\r\n      health.backoffUntil = undefined;\r\n      health.consecutiveFailures = 0;\r\n      health.status = \"unknown\";\r\n      log.info(`Reset backoff for SSH connection to ${config.host}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mark connection as healthy.\r\n   * Call after successful SSH operations to maintain health state.\r\n   */\r\n  markHealthy(config: SSHConnectionConfig): void {\r\n    const key = makeConnectionKey(config);\r\n    this.markHealthyByKey(key);\r\n  }\r\n\r\n  /**\r\n   * Report a connection failure.\r\n   * Call when SSH operations fail due to connection issues (not command failures).\r\n   * This triggers backoff to prevent thundering herd on a failing host.\r\n   */\r\n  reportFailure(config: SSHConnectionConfig, error: string): void {\r\n    const key = makeConnectionKey(config);\r\n    this.markFailedByKey(key, error);\r\n  }\r\n\r\n  /**\r\n   * Mark connection as healthy by key (internal use)\r\n   */\r\n  private markHealthyByKey(key: string): void {\r\n    this.health.set(key, {\r\n      status: \"healthy\",\r\n      lastSuccess: new Date(),\r\n      consecutiveFailures: 0,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Mark connection as failed (internal use after failed probe)\r\n   */\r\n  private markFailedByKey(key: string, error: string): void {\r\n    const current = this.health.get(key);\r\n    const failures = (current?.consecutiveFailures ?? 0) + 1;\r\n    const backoffIndex = Math.min(failures - 1, BACKOFF_SCHEDULE.length - 1);\r\n    const backoffSecs = withJitter(BACKOFF_SCHEDULE[backoffIndex]);\r\n\r\n    this.health.set(key, {\r\n      status: \"unhealthy\",\r\n      lastFailure: new Date(),\r\n      lastError: error,\r\n      backoffUntil: new Date(Date.now() + backoffSecs * 1000),\r\n      consecutiveFailures: failures,\r\n    });\r\n\r\n    log.warn(\r\n      `SSH connection failed (${failures} consecutive). Backoff for ${backoffSecs.toFixed(1)}s. Error: ${error}`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Clear all health state. Used in tests to reset between test cases\r\n   * so backoff from one test doesn't affect subsequent tests.\r\n   */\r\n  clearAllHealth(): void {\r\n    this.health.clear();\r\n    this.inflight.clear();\r\n  }\r\n\r\n  /**\r\n   * Probe connection health by running a simple command\r\n   */\r\n  private async probeConnection(\r\n    config: SSHConnectionConfig,\r\n    timeoutMs: number,\r\n    key: string\r\n  ): Promise<void> {\r\n    const controlPath = getControlPath(config);\r\n\r\n    const args: string[] = [\"-T\"]; // No PTY needed for probe\r\n\r\n    if (config.port) {\r\n      args.push(\"-p\", config.port.toString());\r\n    }\r\n\r\n    if (config.identityFile) {\r\n      args.push(\"-i\", config.identityFile);\r\n      args.push(\"-o\", \"StrictHostKeyChecking=no\");\r\n      args.push(\"-o\", \"UserKnownHostsFile=/dev/null\");\r\n      args.push(\"-o\", \"LogLevel=ERROR\");\r\n    }\r\n\r\n    // Connection multiplexing\r\n    args.push(\"-o\", \"ControlMaster=auto\");\r\n    args.push(\"-o\", `ControlPath=${controlPath}`);\r\n    args.push(\"-o\", \"ControlPersist=60\");\r\n\r\n    // Aggressive timeouts for probe\r\n    const connectTimeout = Math.min(Math.ceil(timeoutMs / 1000), 15);\r\n    args.push(\"-o\", `ConnectTimeout=${connectTimeout}`);\r\n    args.push(\"-o\", \"ServerAliveInterval=5\");\r\n    args.push(\"-o\", \"ServerAliveCountMax=2\");\r\n\r\n    args.push(config.host, \"echo ok\");\r\n\r\n    log.debug(`SSH probe: ssh ${args.join(\" \")}`);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const proc = spawn(\"ssh\", args, { stdio: [\"ignore\", \"pipe\", \"pipe\"] });\r\n\r\n      let stderr = \"\";\r\n      proc.stderr.on(\"data\", (data: Buffer) => {\r\n        stderr += data.toString();\r\n      });\r\n\r\n      let timedOut = false;\r\n      const timeout = setTimeout(() => {\r\n        timedOut = true;\r\n        proc.kill(\"SIGKILL\");\r\n        const error = \"SSH probe timed out\";\r\n        this.markFailedByKey(key, error);\r\n        reject(new Error(error));\r\n      }, timeoutMs);\r\n\r\n      proc.on(\"close\", (code) => {\r\n        clearTimeout(timeout);\r\n        if (timedOut) return; // Already handled by timeout\r\n\r\n        if (code === 0) {\r\n          this.markHealthyByKey(key);\r\n          log.debug(`SSH probe to ${config.host} succeeded`);\r\n          resolve();\r\n        } else {\r\n          const error = stderr.trim() || `SSH probe failed with code ${code ?? \"unknown\"}`;\r\n          this.markFailedByKey(key, error);\r\n          reject(new Error(error));\r\n        }\r\n      });\r\n\r\n      proc.on(\"error\", (err) => {\r\n        clearTimeout(timeout);\r\n        const error = `SSH probe spawn error: ${err.message}`;\r\n        this.markFailedByKey(key, error);\r\n        reject(new Error(error));\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Singleton instance for application-wide use\r\n */\r\nexport const sshConnectionPool = new SSHConnectionPool();\r\n\r\n/**\r\n * Get deterministic controlPath for SSH config.\r\n * Multiple calls with identical config return the same path,\r\n * enabling ControlMaster to multiplex connections.\r\n *\r\n * Socket files are created by SSH and cleaned up automatically:\r\n * - ControlPersist=60: Removes socket 60s after last use\r\n * - OS: Cleans /tmp on reboot\r\n *\r\n * Includes local username in hash to prevent cross-user collisions on\r\n * multi-user systems (different users connecting to same remote would\r\n * otherwise generate same socket path, causing permission errors).\r\n */\r\nexport function getControlPath(config: SSHConnectionConfig): string {\r\n  const key = makeConnectionKey(config);\r\n  const hash = hashKey(key);\r\n  return path.join(os.tmpdir(), `mux-ssh-${hash}`);\r\n}\r\n\r\n/**\r\n * Generate stable key from config.\r\n * Identical configs produce identical keys.\r\n * Includes local username to prevent cross-user socket collisions.\r\n */\r\nfunction makeConnectionKey(config: SSHConnectionConfig): string {\r\n  // Note: srcBaseDir is intentionally excluded - connection identity is determined\r\n  // by user + host + port + key. This allows health tracking and multiplexing\r\n  // to be shared across workspaces on the same host.\r\n  const parts = [\r\n    os.userInfo().username, // Include local user to prevent cross-user collisions\r\n    config.host,\r\n    config.port?.toString() ?? \"22\",\r\n    config.identityFile ?? \"default\",\r\n  ];\r\n  return parts.join(\":\");\r\n}\r\n\r\n/**\r\n * Generate deterministic hash for controlPath naming.\r\n * Uses first 12 chars of SHA-256 for human-readable uniqueness.\r\n */\r\nfunction hashKey(key: string): string {\r\n  return crypto.createHash(\"sha256\").update(key).digest(\"hex\").substring(0, 12);\r\n}\r\n"]}