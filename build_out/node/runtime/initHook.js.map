{"version":3,"file":"initHook.js","sourceRoot":"","sources":["../../../src/node/runtime/initHook.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs\";\r\nimport * as fsPromises from \"fs/promises\";\r\nimport * as path from \"path\";\r\nimport type { ExecOptions, ExecStream, InitLogger } from \"./Runtime\";\r\nimport {\r\n  isWorktreeRuntime,\r\n  isSSHRuntime,\r\n  isDockerRuntime,\r\n  isDevcontainerRuntime,\r\n  type RuntimeConfig,\r\n  type RuntimeMode,\r\n} from \"@/common/types/runtime\";\r\n\r\nimport type { ThinkingLevel } from \"@/common/types/thinking\";\r\n\r\n/**\r\n * Check if .mux/init hook exists and is executable\r\n * @param projectPath - Path to the project root\r\n * @returns true if hook exists and is executable, false otherwise\r\n */\r\nexport async function checkInitHookExists(projectPath: string): Promise<boolean> {\r\n  const hookPath = path.join(projectPath, \".mux\", \"init\");\r\n\r\n  try {\r\n    await fsPromises.access(hookPath, fs.constants.X_OK);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Get the init hook path for a project\r\n */\r\nexport function getInitHookPath(projectPath: string): string {\r\n  return path.join(projectPath, \".mux\", \"init\");\r\n}\r\n\r\n/**\r\n * Get MUX_ environment variables for bash execution.\r\n * Used by both init hook and regular bash tool calls.\r\n * @param projectPath - Path to project root (local path for LocalRuntime, remote path for SSHRuntime)\r\n * @param runtime - Runtime type: \"local\", \"worktree\", \"ssh\", or \"docker\"\r\n * @param workspaceName - Name of the workspace (branch name or custom name)\r\n */\r\nexport function getMuxEnv(\r\n  projectPath: string,\r\n  runtime: RuntimeMode,\r\n  workspaceName: string,\r\n  options?: {\r\n    modelString?: string;\r\n    thinkingLevel?: ThinkingLevel;\r\n    /** Cumulative session costs in USD (if available) */\r\n    costsUsd?: number;\r\n  }\r\n): Record<string, string> {\r\n  if (!projectPath) {\r\n    throw new Error(\"getMuxEnv: projectPath is required\");\r\n  }\r\n  if (!workspaceName) {\r\n    throw new Error(\"getMuxEnv: workspaceName is required\");\r\n  }\r\n\r\n  const env: Record<string, string> = {\r\n    MUX_PROJECT_PATH: projectPath,\r\n    MUX_RUNTIME: runtime,\r\n    MUX_WORKSPACE_NAME: workspaceName,\r\n  };\r\n\r\n  if (options?.modelString) {\r\n    env.MUX_MODEL_STRING = options.modelString;\r\n  }\r\n\r\n  if (options?.thinkingLevel !== undefined) {\r\n    env.MUX_THINKING_LEVEL = options.thinkingLevel;\r\n  }\r\n\r\n  if (options?.costsUsd !== undefined) {\r\n    env.MUX_COSTS_USD = options.costsUsd.toFixed(2);\r\n  }\r\n\r\n  return env;\r\n}\r\n\r\n/**\r\n * Get the effective runtime type from a RuntimeConfig.\r\n * Handles legacy \"local\" with srcBaseDir â†’ \"worktree\" mapping.\r\n */\r\nexport function getRuntimeType(config: RuntimeConfig | undefined): RuntimeMode {\r\n  if (!config) return \"worktree\"; // Default to worktree for undefined config\r\n  if (isSSHRuntime(config)) return \"ssh\";\r\n  if (isDockerRuntime(config)) return \"docker\";\r\n  if (isDevcontainerRuntime(config)) return \"devcontainer\";\r\n  if (isWorktreeRuntime(config)) return \"worktree\";\r\n  return \"local\";\r\n}\r\n\r\n/**\r\n * Line-buffered logger that splits stream output into lines and logs them\r\n * Handles incomplete lines by buffering until a newline is received\r\n */\r\nexport class LineBuffer {\r\n  private buffer = \"\";\r\n  private readonly logLine: (line: string) => void;\r\n\r\n  constructor(logLine: (line: string) => void) {\r\n    this.logLine = logLine;\r\n  }\r\n\r\n  /**\r\n   * Process a chunk of data, splitting on newlines and logging complete lines\r\n   */\r\n  append(data: string): void {\r\n    this.buffer += data;\r\n    const lines = this.buffer.split(\"\\n\");\r\n    this.buffer = lines.pop() ?? \"\"; // Keep last incomplete line\r\n    for (const line of lines) {\r\n      if (line) this.logLine(line);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Flush any remaining buffered data (called when stream closes)\r\n   */\r\n  flush(): void {\r\n    if (this.buffer) {\r\n      this.logLine(this.buffer);\r\n      this.buffer = \"\";\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create line-buffered loggers for stdout and stderr\r\n * Returns an object with append and flush methods for each stream\r\n */\r\nexport function createLineBufferedLoggers(initLogger: InitLogger) {\r\n  const stdoutBuffer = new LineBuffer((line) => initLogger.logStdout(line));\r\n  const stderrBuffer = new LineBuffer((line) => initLogger.logStderr(line));\r\n\r\n  return {\r\n    stdout: {\r\n      append: (data: string) => stdoutBuffer.append(data),\r\n      flush: () => stdoutBuffer.flush(),\r\n    },\r\n    stderr: {\r\n      append: (data: string) => stderrBuffer.append(data),\r\n      flush: () => stderrBuffer.flush(),\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Minimal runtime interface needed for running init hooks.\r\n * This allows the helper to work with any runtime implementation.\r\n */\r\nexport interface InitHookRuntime {\r\n  exec(command: string, options: ExecOptions): Promise<ExecStream>;\r\n}\r\n\r\n/**\r\n * Run .mux/init hook on a runtime and stream output to logger.\r\n * Shared implementation used by SSH and Docker runtimes.\r\n *\r\n * @param runtime - Runtime instance with exec capability\r\n * @param hookPath - Full path to the init hook (e.g., \"/src/.mux/init\" or \"~/mux/project/workspace/.mux/init\")\r\n * @param workspacePath - Working directory for the hook\r\n * @param muxEnv - MUX_ environment variables from getMuxEnv()\r\n * @param initLogger - Logger for streaming output\r\n * @param abortSignal - Optional abort signal\r\n */\r\nexport async function runInitHookOnRuntime(\r\n  runtime: InitHookRuntime,\r\n  hookPath: string,\r\n  workspacePath: string,\r\n  muxEnv: Record<string, string>,\r\n  initLogger: InitLogger,\r\n  abortSignal?: AbortSignal\r\n): Promise<void> {\r\n  initLogger.logStep(`Running init hook: ${hookPath}`);\r\n\r\n  const hookStream = await runtime.exec(hookPath, {\r\n    cwd: workspacePath,\r\n    timeout: 3600, // 1 hour - generous timeout for init hooks\r\n    abortSignal,\r\n    // When init is cancellable (archive/remove), we want abort to actually stop the remote hook.\r\n    // With OpenSSH, allocating a PTY ensures the remote process is tied to the session and\r\n    // receives a hangup when the client disconnects.\r\n    forcePTY: abortSignal !== undefined,\r\n    env: muxEnv,\r\n  });\r\n\r\n  // Create line-buffered loggers for proper output handling\r\n  const loggers = createLineBufferedLoggers(initLogger);\r\n  const stdoutReader = hookStream.stdout.getReader();\r\n  const stderrReader = hookStream.stderr.getReader();\r\n  const decoder = new TextDecoder();\r\n\r\n  // Read stdout in parallel\r\n  const readStdout = async () => {\r\n    try {\r\n      while (true) {\r\n        const { done, value } = await stdoutReader.read();\r\n        if (done) break;\r\n        loggers.stdout.append(decoder.decode(value, { stream: true }));\r\n      }\r\n      loggers.stdout.flush();\r\n    } finally {\r\n      stdoutReader.releaseLock();\r\n    }\r\n  };\r\n\r\n  // Read stderr in parallel\r\n  const readStderr = async () => {\r\n    try {\r\n      while (true) {\r\n        const { done, value } = await stderrReader.read();\r\n        if (done) break;\r\n        loggers.stderr.append(decoder.decode(value, { stream: true }));\r\n      }\r\n      loggers.stderr.flush();\r\n    } finally {\r\n      stderrReader.releaseLock();\r\n    }\r\n  };\r\n\r\n  // Wait for all streams and exit code\r\n  const [exitCode] = await Promise.all([hookStream.exitCode, readStdout(), readStderr()]);\r\n\r\n  // Log completion with exit code - hook failures are non-fatal per docs/hooks/init.mdx\r\n  // (\"failures are logged but don't prevent workspace usage\")\r\n  initLogger.logComplete(exitCode);\r\n}\r\n"]}