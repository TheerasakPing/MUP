{"version":3,"file":"initHook.js","sourceRoot":"","sources":["../../../src/node/runtime/initHook.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs\";\nimport * as fsPromises from \"fs/promises\";\nimport * as path from \"path\";\nimport type { ExecOptions, ExecStream, InitLogger } from \"./Runtime\";\nimport {\n  isWorktreeRuntime,\n  isSSHRuntime,\n  isDockerRuntime,\n  isDevcontainerRuntime,\n  type RuntimeConfig,\n  type RuntimeMode,\n} from \"@/common/types/runtime\";\n\nimport type { ThinkingLevel } from \"@/common/types/thinking\";\n\n/**\n * Check if .mux/init hook exists and is executable\n * @param projectPath - Path to the project root\n * @returns true if hook exists and is executable, false otherwise\n */\nexport async function checkInitHookExists(projectPath: string): Promise<boolean> {\n  const hookPath = path.join(projectPath, \".mux\", \"init\");\n\n  try {\n    await fsPromises.access(hookPath, fs.constants.X_OK);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get the init hook path for a project\n */\nexport function getInitHookPath(projectPath: string): string {\n  return path.join(projectPath, \".mux\", \"init\");\n}\n\n/**\n * Get MUX_ environment variables for bash execution.\n * Used by both init hook and regular bash tool calls.\n * @param projectPath - Path to project root (local path for LocalRuntime, remote path for SSHRuntime)\n * @param runtime - Runtime type: \"local\", \"worktree\", \"ssh\", or \"docker\"\n * @param workspaceName - Name of the workspace (branch name or custom name)\n */\nexport function getMuxEnv(\n  projectPath: string,\n  runtime: RuntimeMode,\n  workspaceName: string,\n  options?: {\n    modelString?: string;\n    thinkingLevel?: ThinkingLevel;\n    /** Cumulative session costs in USD (if available) */\n    costsUsd?: number;\n  }\n): Record<string, string> {\n  if (!projectPath) {\n    throw new Error(\"getMuxEnv: projectPath is required\");\n  }\n  if (!workspaceName) {\n    throw new Error(\"getMuxEnv: workspaceName is required\");\n  }\n\n  const env: Record<string, string> = {\n    MUX_PROJECT_PATH: projectPath,\n    MUX_RUNTIME: runtime,\n    MUX_WORKSPACE_NAME: workspaceName,\n  };\n\n  if (options?.modelString) {\n    env.MUX_MODEL_STRING = options.modelString;\n  }\n\n  if (options?.thinkingLevel !== undefined) {\n    env.MUX_THINKING_LEVEL = options.thinkingLevel;\n  }\n\n  if (options?.costsUsd !== undefined) {\n    env.MUX_COSTS_USD = options.costsUsd.toFixed(2);\n  }\n\n  return env;\n}\n\n/**\n * Get the effective runtime type from a RuntimeConfig.\n * Handles legacy \"local\" with srcBaseDir â†’ \"worktree\" mapping.\n */\nexport function getRuntimeType(config: RuntimeConfig | undefined): RuntimeMode {\n  if (!config) return \"worktree\"; // Default to worktree for undefined config\n  if (isSSHRuntime(config)) return \"ssh\";\n  if (isDockerRuntime(config)) return \"docker\";\n  if (isDevcontainerRuntime(config)) return \"devcontainer\";\n  if (isWorktreeRuntime(config)) return \"worktree\";\n  return \"local\";\n}\n\n/**\n * Line-buffered logger that splits stream output into lines and logs them\n * Handles incomplete lines by buffering until a newline is received\n */\nexport class LineBuffer {\n  private buffer = \"\";\n  private readonly logLine: (line: string) => void;\n\n  constructor(logLine: (line: string) => void) {\n    this.logLine = logLine;\n  }\n\n  /**\n   * Process a chunk of data, splitting on newlines and logging complete lines\n   */\n  append(data: string): void {\n    this.buffer += data;\n    const lines = this.buffer.split(\"\\n\");\n    this.buffer = lines.pop() ?? \"\"; // Keep last incomplete line\n    for (const line of lines) {\n      if (line) this.logLine(line);\n    }\n  }\n\n  /**\n   * Flush any remaining buffered data (called when stream closes)\n   */\n  flush(): void {\n    if (this.buffer) {\n      this.logLine(this.buffer);\n      this.buffer = \"\";\n    }\n  }\n}\n\n/**\n * Create line-buffered loggers for stdout and stderr\n * Returns an object with append and flush methods for each stream\n */\nexport function createLineBufferedLoggers(initLogger: InitLogger) {\n  const stdoutBuffer = new LineBuffer((line) => initLogger.logStdout(line));\n  const stderrBuffer = new LineBuffer((line) => initLogger.logStderr(line));\n\n  return {\n    stdout: {\n      append: (data: string) => stdoutBuffer.append(data),\n      flush: () => stdoutBuffer.flush(),\n    },\n    stderr: {\n      append: (data: string) => stderrBuffer.append(data),\n      flush: () => stderrBuffer.flush(),\n    },\n  };\n}\n\n/**\n * Minimal runtime interface needed for running init hooks.\n * This allows the helper to work with any runtime implementation.\n */\nexport interface InitHookRuntime {\n  exec(command: string, options: ExecOptions): Promise<ExecStream>;\n}\n\n/**\n * Run .mux/init hook on a runtime and stream output to logger.\n * Shared implementation used by SSH and Docker runtimes.\n *\n * @param runtime - Runtime instance with exec capability\n * @param hookPath - Full path to the init hook (e.g., \"/src/.mux/init\" or \"~/mux/project/workspace/.mux/init\")\n * @param workspacePath - Working directory for the hook\n * @param muxEnv - MUX_ environment variables from getMuxEnv()\n * @param initLogger - Logger for streaming output\n * @param abortSignal - Optional abort signal\n */\nexport async function runInitHookOnRuntime(\n  runtime: InitHookRuntime,\n  hookPath: string,\n  workspacePath: string,\n  muxEnv: Record<string, string>,\n  initLogger: InitLogger,\n  abortSignal?: AbortSignal\n): Promise<void> {\n  initLogger.logStep(`Running init hook: ${hookPath}`);\n\n  const hookStream = await runtime.exec(hookPath, {\n    cwd: workspacePath,\n    timeout: 3600, // 1 hour - generous timeout for init hooks\n    abortSignal,\n    // When init is cancellable (archive/remove), we want abort to actually stop the remote hook.\n    // With OpenSSH, allocating a PTY ensures the remote process is tied to the session and\n    // receives a hangup when the client disconnects.\n    forcePTY: abortSignal !== undefined,\n    env: muxEnv,\n  });\n\n  // Create line-buffered loggers for proper output handling\n  const loggers = createLineBufferedLoggers(initLogger);\n  const stdoutReader = hookStream.stdout.getReader();\n  const stderrReader = hookStream.stderr.getReader();\n  const decoder = new TextDecoder();\n\n  // Read stdout in parallel\n  const readStdout = async () => {\n    try {\n      while (true) {\n        const { done, value } = await stdoutReader.read();\n        if (done) break;\n        loggers.stdout.append(decoder.decode(value, { stream: true }));\n      }\n      loggers.stdout.flush();\n    } finally {\n      stdoutReader.releaseLock();\n    }\n  };\n\n  // Read stderr in parallel\n  const readStderr = async () => {\n    try {\n      while (true) {\n        const { done, value } = await stderrReader.read();\n        if (done) break;\n        loggers.stderr.append(decoder.decode(value, { stream: true }));\n      }\n      loggers.stderr.flush();\n    } finally {\n      stderrReader.releaseLock();\n    }\n  };\n\n  // Wait for all streams and exit code\n  const [exitCode] = await Promise.all([hookStream.exitCode, readStdout(), readStderr()]);\n\n  // Log completion with exit code - hook failures are non-fatal per docs/hooks/init.mdx\n  // (\"failures are logged but don't prevent workspace usage\")\n  initLogger.logComplete(exitCode);\n}\n"]}