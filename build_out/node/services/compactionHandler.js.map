{"version":3,"file":"compactionHandler.js","sourceRoot":"","sources":["../../../src/node/services/compactionHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import type { EventEmitter } from \"events\";\nimport * as fsPromises from \"fs/promises\";\nimport assert from \"@/common/utils/assert\";\nimport * as path from \"path\";\n\nimport type { HistoryService } from \"./historyService\";\nimport type { PartialService } from \"./partialService\";\n\nimport type { StreamEndEvent } from \"@/common/types/stream\";\nimport type { WorkspaceChatMessage } from \"@/common/orpc/types\";\nimport type { Result } from \"@/common/types/result\";\nimport { Ok, Err } from \"@/common/types/result\";\nimport type { LanguageModelV2Usage } from \"@ai-sdk/provider\";\n\nimport {\n  createMuxMessage,\n  getCompactionFollowUpContent,\n  type CompactionFollowUpRequest,\n  type CompactionSummaryMetadata,\n  type MuxMessage,\n} from \"@/common/types/message\";\nimport { createCompactionSummaryMessageId } from \"@/node/services/utils/messageIds\";\nimport type { TelemetryService } from \"@/node/services/telemetryService\";\nimport { MAX_EDITED_FILES, MAX_FILE_CONTENT_SIZE } from \"@/common/constants/attachments\";\nimport { roundToBase2 } from \"@/common/telemetry/utils\";\nimport { log } from \"@/node/services/log\";\nimport { computeRecencyFromMessages } from \"@/common/utils/recency\";\nimport {\n  extractEditedFileDiffs,\n  type FileEditDiff,\n} from \"@/common/utils/messages/extractEditedFiles\";\nimport { sliceMessagesFromLatestCompactionBoundary } from \"@/common/utils/messages/compactionBoundary\";\n\n/**\n * Check if a string is just a raw JSON object, which suggests the model\n * tried to output a tool call as text (happens when tools are disabled).\n *\n * A valid compaction summary should be prose text describing the conversation,\n * not a JSON blob. This general check catches any tool that might leak through.\n */\nfunction looksLikeRawJsonObject(text: string): boolean {\n  const trimmed = text.trim();\n\n  // Must be a JSON object (not array, not primitive)\n  if (!trimmed.startsWith(\"{\") || !trimmed.endsWith(\"}\")) {\n    return false;\n  }\n\n  try {\n    const parsed: unknown = JSON.parse(trimmed);\n    // Must parse as a non-null, non-array object\n    return typeof parsed === \"object\" && parsed !== null && !Array.isArray(parsed);\n  } catch {\n    return false;\n  }\n}\n\nconst POST_COMPACTION_STATE_FILENAME = \"post-compaction.json\";\n\ninterface PersistedPostCompactionStateV1 {\n  version: 1;\n  createdAt: number;\n  diffs: FileEditDiff[];\n}\n\nfunction coerceFileEditDiffs(value: unknown): FileEditDiff[] {\n  if (!Array.isArray(value)) {\n    return [];\n  }\n\n  const diffs: FileEditDiff[] = [];\n  for (const item of value) {\n    if (!item || typeof item !== \"object\") {\n      continue;\n    }\n\n    const filePath = (item as { path?: unknown }).path;\n    const diff = (item as { diff?: unknown }).diff;\n    const truncated = (item as { truncated?: unknown }).truncated;\n\n    if (typeof filePath !== \"string\") continue;\n    const trimmedPath = filePath.trim();\n    if (trimmedPath.length === 0) continue;\n\n    if (typeof diff !== \"string\") continue;\n    if (typeof truncated !== \"boolean\") continue;\n\n    const clampedDiff =\n      diff.length > MAX_FILE_CONTENT_SIZE ? diff.slice(0, MAX_FILE_CONTENT_SIZE) : diff;\n\n    diffs.push({\n      path: trimmedPath,\n      diff: clampedDiff,\n      truncated: truncated || diff.length > MAX_FILE_CONTENT_SIZE,\n    });\n\n    if (diffs.length >= MAX_EDITED_FILES) {\n      break;\n    }\n  }\n\n  return diffs;\n}\n\nfunction coercePersistedPostCompactionState(value: unknown): PersistedPostCompactionStateV1 | null {\n  if (!value || typeof value !== \"object\") {\n    return null;\n  }\n\n  const version = (value as { version?: unknown }).version;\n  if (version !== 1) {\n    return null;\n  }\n\n  const createdAt = (value as { createdAt?: unknown }).createdAt;\n  if (typeof createdAt !== \"number\") {\n    return null;\n  }\n\n  const diffsRaw = (value as { diffs?: unknown }).diffs;\n  const diffs = coerceFileEditDiffs(diffsRaw);\n\n  return {\n    version: 1,\n    createdAt,\n    diffs,\n  };\n}\n\nfunction hasDurableCompactedMarker(value: unknown): value is true | \"user\" | \"idle\" {\n  return value === true || value === \"user\" || value === \"idle\";\n}\n\nfunction isCompactedSummaryMessage(message: MuxMessage): boolean {\n  return hasDurableCompactedMarker(message.metadata?.compacted);\n}\n\nfunction isPositiveInteger(value: unknown): value is number {\n  return (\n    typeof value === \"number\" && Number.isFinite(value) && Number.isInteger(value) && value > 0\n  );\n}\n\nfunction isNonNegativeInteger(value: unknown): value is number {\n  return (\n    typeof value === \"number\" && Number.isFinite(value) && Number.isInteger(value) && value >= 0\n  );\n}\n\nfunction getNextCompactionEpoch(messages: MuxMessage[]): number {\n  let epochCursor = 0;\n\n  for (const message of messages) {\n    const metadata = message.metadata;\n    if (!metadata) {\n      continue;\n    }\n\n    const isCompactedSummary = isCompactedSummaryMessage(message);\n    const hasBoundaryMarker = metadata.compactionBoundary === true;\n    const epoch = metadata.compactionEpoch;\n\n    if (hasBoundaryMarker && !isCompactedSummary) {\n      // Self-healing read path: skip malformed persisted boundary markers.\n      // Boundary markers are only valid on compacted summaries.\n      log.warn(\"Skipping malformed compaction boundary while deriving next epoch\", {\n        messageId: message.id,\n        reason: \"compactionBoundary set on non-compacted message\",\n      });\n      continue;\n    }\n\n    if (!isCompactedSummary) {\n      continue;\n    }\n\n    if (hasBoundaryMarker) {\n      if (!isPositiveInteger(epoch)) {\n        // Self-healing read path: invalid boundary metadata should not brick compaction.\n        log.warn(\"Skipping malformed compaction boundary while deriving next epoch\", {\n          messageId: message.id,\n          reason: \"compactionBoundary missing positive integer compactionEpoch\",\n        });\n        continue;\n      }\n      epochCursor = Math.max(epochCursor, epoch);\n      continue;\n    }\n\n    if (epoch === undefined) {\n      // Legacy compacted summaries predate compactionEpoch metadata.\n      epochCursor += 1;\n      continue;\n    }\n\n    if (!isPositiveInteger(epoch)) {\n      // Self-healing read path: malformed compactionEpoch should not crash compaction.\n      log.warn(\"Skipping malformed compactionEpoch while deriving next epoch\", {\n        messageId: message.id,\n        reason: \"compactionEpoch must be a positive integer when present\",\n      });\n      continue;\n    }\n\n    epochCursor = Math.max(epochCursor, epoch);\n  }\n\n  const nextEpoch = epochCursor + 1;\n  assert(nextEpoch > 0, \"next compaction epoch must be positive\");\n  return nextEpoch;\n}\n\ninterface CompactionHandlerOptions {\n  workspaceId: string;\n  historyService: HistoryService;\n  partialService: PartialService;\n  sessionDir: string;\n  telemetryService?: TelemetryService;\n  emitter: EventEmitter;\n  /** Called when compaction completes successfully (e.g., to clear idle compaction pending state) */\n  onCompactionComplete?: () => void;\n}\n\n/**\n * Handles history compaction for agent sessions\n *\n * Responsible for:\n * - Detecting compaction requests in stream events\n * - Appending compacted summaries as durable history boundaries\n * - Preserving cumulative usage across compactions\n */\nexport class CompactionHandler {\n  private readonly workspaceId: string;\n  private readonly historyService: HistoryService;\n  private readonly sessionDir: string;\n  private readonly postCompactionStatePath: string;\n  private persistedPendingStateLoaded = false;\n  private readonly partialService: PartialService;\n  private readonly telemetryService?: TelemetryService;\n  private readonly emitter: EventEmitter;\n  private readonly processedCompactionRequestIds: Set<string> = new Set<string>();\n\n  private readonly onCompactionComplete?: () => void;\n\n  /** Flag indicating post-compaction attachments should be generated on next turn */\n  private postCompactionAttachmentsPending = false;\n  /** Cached file diffs extracted from history before appending compaction summary */\n  private cachedFileDiffs: FileEditDiff[] = [];\n\n  constructor(options: CompactionHandlerOptions) {\n    assert(options, \"CompactionHandler requires options\");\n    assert(typeof options.sessionDir === \"string\", \"sessionDir must be a string\");\n    const trimmedSessionDir = options.sessionDir.trim();\n    assert(trimmedSessionDir.length > 0, \"sessionDir must not be empty\");\n\n    this.workspaceId = options.workspaceId;\n    this.historyService = options.historyService;\n    this.sessionDir = trimmedSessionDir;\n    this.postCompactionStatePath = path.join(trimmedSessionDir, POST_COMPACTION_STATE_FILENAME);\n    this.partialService = options.partialService;\n    this.telemetryService = options.telemetryService;\n    this.emitter = options.emitter;\n    this.onCompactionComplete = options.onCompactionComplete;\n  }\n\n  private async loadPersistedPendingStateIfNeeded(): Promise<void> {\n    if (this.persistedPendingStateLoaded || this.postCompactionAttachmentsPending) {\n      return;\n    }\n\n    this.persistedPendingStateLoaded = true;\n\n    let raw: string;\n    try {\n      raw = await fsPromises.readFile(this.postCompactionStatePath, \"utf-8\");\n    } catch {\n      return;\n    }\n\n    let parsed: unknown;\n    try {\n      parsed = JSON.parse(raw);\n    } catch {\n      log.warn(\"Invalid post-compaction state JSON; ignoring\", { workspaceId: this.workspaceId });\n      await this.deletePersistedPendingStateBestEffort();\n      return;\n    }\n\n    const state = coercePersistedPostCompactionState(parsed);\n    if (!state) {\n      log.warn(\"Invalid post-compaction state schema; ignoring\", { workspaceId: this.workspaceId });\n      await this.deletePersistedPendingStateBestEffort();\n      return;\n    }\n\n    // Note: We intentionally do not validate against chat history here.\n    // The presence of this file is the source of truth that a compaction occurred (or at least started),\n    // and pre-compaction diffs may have been deleted from history.\n\n    this.cachedFileDiffs = state.diffs;\n    this.postCompactionAttachmentsPending = true;\n  }\n\n  /**\n   * Peek pending post-compaction diffs without consuming them.\n   * Returns null if no compaction occurred, otherwise returns the cached diffs.\n   */\n  async peekPendingDiffs(): Promise<FileEditDiff[] | null> {\n    if (!this.postCompactionAttachmentsPending) {\n      await this.loadPersistedPendingStateIfNeeded();\n    }\n\n    if (!this.postCompactionAttachmentsPending) {\n      return null;\n    }\n\n    return this.cachedFileDiffs;\n  }\n\n  /**\n   * Acknowledge that pending post-compaction state has been consumed successfully.\n   * Clears in-memory state and deletes the persisted snapshot from disk.\n   */\n  async ackPendingDiffsConsumed(): Promise<void> {\n    // If we never loaded persisted state but it exists, clear it anyway.\n    if (!this.postCompactionAttachmentsPending && !this.persistedPendingStateLoaded) {\n      await this.loadPersistedPendingStateIfNeeded();\n    }\n\n    this.postCompactionAttachmentsPending = false;\n    this.cachedFileDiffs = [];\n    await this.deletePersistedPendingStateBestEffort();\n  }\n\n  /**\n   * Drop pending post-compaction state (e.g., because it caused context_exceeded).\n   */\n  async discardPendingDiffs(reason: string): Promise<void> {\n    await this.loadPersistedPendingStateIfNeeded();\n\n    if (!this.postCompactionAttachmentsPending) {\n      return;\n    }\n\n    log.warn(\"Discarding pending post-compaction state\", {\n      workspaceId: this.workspaceId,\n      reason,\n      trackedFiles: this.cachedFileDiffs.length,\n    });\n\n    await this.ackPendingDiffsConsumed();\n  }\n\n  private async deletePersistedPendingStateBestEffort(): Promise<void> {\n    try {\n      await fsPromises.unlink(this.postCompactionStatePath);\n    } catch {\n      // ignore\n    }\n  }\n\n  private async persistPendingStateBestEffort(diffs: FileEditDiff[]): Promise<void> {\n    try {\n      await fsPromises.mkdir(this.sessionDir, { recursive: true });\n\n      const persisted: PersistedPostCompactionStateV1 = {\n        version: 1,\n        createdAt: Date.now(),\n        diffs,\n      };\n\n      await fsPromises.writeFile(this.postCompactionStatePath, JSON.stringify(persisted));\n    } catch (error) {\n      log.warn(\"Failed to persist post-compaction state\", {\n        workspaceId: this.workspaceId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n\n  /**\n   * Peek at cached file paths without consuming them.\n   * Returns paths of files that will be reinjected after compaction.\n   * Returns null if no pending compaction attachments.\n   */\n  peekCachedFilePaths(): string[] | null {\n    if (!this.postCompactionAttachmentsPending) {\n      return null;\n    }\n    return this.cachedFileDiffs.map((diff) => diff.path);\n  }\n\n  /**\n   * Handle compaction stream completion\n   *\n   * Detects when a compaction stream finishes, extracts the summary,\n   * and appends a durable compaction boundary message.\n   */\n  async handleCompletion(event: StreamEndEvent): Promise<boolean> {\n    // Check if the last user message is a compaction-request.\n    // Only need recent messages â€” the compaction-request is always near the tail.\n    const historyResult = await this.historyService.getLastMessages(this.workspaceId, 10);\n    if (!historyResult.success) {\n      return false;\n    }\n\n    const messages = historyResult.data;\n    const lastUserMsg = [...messages].reverse().find((m) => m.role === \"user\");\n    const muxMeta = lastUserMsg?.metadata?.muxMetadata;\n    const isCompaction = muxMeta?.type === \"compaction-request\";\n\n    if (!isCompaction || !lastUserMsg) {\n      return false;\n    }\n\n    // Dedupe: If we've already processed this compaction-request, skip\n    if (this.processedCompactionRequestIds.has(lastUserMsg.id)) {\n      return true;\n    }\n\n    const summary = event.parts\n      .filter((part): part is { type: \"text\"; text: string } => part.type === \"text\")\n      .map((part) => part.text)\n      .join(\"\");\n\n    // Self-healing: Reject empty summaries (stream crashed before producing content)\n    if (!summary.trim()) {\n      // Log detailed part info to help debug why no text was produced\n      const partsSummary = event.parts.map((p) => ({\n        type: p.type,\n        // Include preview for text-like parts to understand what the model produced\n        preview: \"text\" in p && typeof p.text === \"string\" ? p.text.slice(0, 100) : undefined,\n      }));\n      log.warn(\"Compaction summary is empty - aborting compaction to prevent corrupted history\", {\n        workspaceId: this.workspaceId,\n        model: event.metadata.model,\n        partsCount: event.parts.length,\n        parts: partsSummary,\n      });\n      // Don't mark as processed so user can retry\n      return false;\n    }\n\n    // Self-healing: Reject compaction if summary is just a raw JSON object.\n    // This happens when tools are disabled but the model still tries to output a tool call.\n    // A valid summary should be prose text, not a JSON blob.\n    if (looksLikeRawJsonObject(summary)) {\n      log.warn(\n        \"Compaction summary is a raw JSON object - aborting compaction to prevent corrupted history\",\n        {\n          workspaceId: this.workspaceId,\n          summaryPreview: summary.slice(0, 200),\n        }\n      );\n      // Don't mark as processed so user can retry\n      return false;\n    }\n\n    // Check if this was an idle-compaction (auto-triggered due to inactivity)\n    const isIdleCompaction =\n      muxMeta?.type === \"compaction-request\" && muxMeta.source === \"idle-compaction\";\n\n    // Extract follow-up content to attach to summary for crash-safe dispatch\n    const pendingFollowUp = getCompactionFollowUpContent(muxMeta);\n\n    // Mark as processed before performing compaction\n    this.processedCompactionRequestIds.add(lastUserMsg.id);\n\n    const result = await this.performCompaction(\n      summary,\n      event.metadata,\n      messages,\n      event.messageId,\n      isIdleCompaction,\n      pendingFollowUp\n    );\n    if (!result.success) {\n      log.error(\"Compaction failed:\", result.error);\n      return false;\n    }\n\n    const durationSecs =\n      typeof event.metadata.duration === \"number\" ? event.metadata.duration / 1000 : 0;\n    const inputTokens =\n      event.metadata.contextUsage?.inputTokens ?? event.metadata.usage?.inputTokens ?? 0;\n    const outputTokens =\n      event.metadata.contextUsage?.outputTokens ?? event.metadata.usage?.outputTokens ?? 0;\n\n    this.telemetryService?.capture({\n      event: \"compaction_completed\",\n      properties: {\n        model: event.metadata.model,\n        duration_b2: roundToBase2(durationSecs),\n        input_tokens_b2: roundToBase2(inputTokens ?? 0),\n        output_tokens_b2: roundToBase2(outputTokens ?? 0),\n        compaction_source: isIdleCompaction ? \"idle\" : \"manual\",\n      },\n    });\n\n    // Notify that compaction completed (clears idle compaction pending state)\n    this.onCompactionComplete?.();\n\n    // Emit a sanitized stream-end so UI can close streaming state without\n    // re-introducing stale provider metadata from the pre-compaction row.\n    this.emitChatEvent(this.sanitizeCompactionStreamEndEvent(event));\n    return true;\n  }\n\n  private sanitizeCompactionStreamEndEvent(event: StreamEndEvent): StreamEndEvent {\n    const sanitizedEvent: StreamEndEvent = {\n      ...event,\n      metadata: {\n        ...event.metadata,\n        providerMetadata: undefined,\n        contextProviderMetadata: undefined,\n        // contextUsage reflects the pre-compaction context window; keeping it\n        // would inflate the usage indicator until the next real request.\n        contextUsage: undefined,\n      },\n    };\n\n    assert(\n      sanitizedEvent.metadata.providerMetadata === undefined &&\n        sanitizedEvent.metadata.contextProviderMetadata === undefined &&\n        sanitizedEvent.metadata.contextUsage === undefined,\n      \"Compaction stream-end event must not carry stale provider metadata or context usage\"\n    );\n\n    return sanitizedEvent;\n  }\n\n  private findPersistedStreamSummaryMessage(\n    messages: MuxMessage[],\n    streamedSummaryMessageId: string\n  ): MuxMessage | null {\n    for (let i = messages.length - 1; i >= 0; i -= 1) {\n      const candidate = messages[i];\n      if (candidate.id !== streamedSummaryMessageId) {\n        continue;\n      }\n\n      if (candidate.role !== \"assistant\") {\n        // Self-healing read path: persisted message IDs can be corrupted.\n        log.warn(\"Cannot reuse streamed compaction summary with non-assistant role\", {\n          workspaceId: this.workspaceId,\n          messageId: candidate.id,\n          role: candidate.role,\n        });\n        return null;\n      }\n\n      const historySequence = candidate.metadata?.historySequence;\n      if (!isNonNegativeInteger(historySequence)) {\n        // Self-healing read path: invalid sequence means we cannot safely update in-place.\n        log.warn(\"Cannot reuse streamed compaction summary without valid historySequence\", {\n          workspaceId: this.workspaceId,\n          messageId: candidate.id,\n          historySequence,\n        });\n        return null;\n      }\n\n      return candidate;\n    }\n\n    return null;\n  }\n\n  /**\n   * Perform history compaction by persisting a durable summary boundary.\n   *\n   * Steps:\n   * 1. Delete partial state to avoid stale partial replay\n   * 2. Persist post-compaction attachment state\n   * 3. Prefer updating the streamed summary in-place, otherwise append a fallback summary\n   * 4. Emit summary message to frontend\n   */\n  private async performCompaction(\n    summary: string,\n    metadata: {\n      model: string;\n      usage?: LanguageModelV2Usage;\n      duration?: number;\n      providerMetadata?: Record<string, unknown>;\n      systemMessageTokens?: number;\n    },\n    messages: MuxMessage[],\n    streamedSummaryMessageId: string,\n    isIdleCompaction = false,\n    pendingFollowUp?: CompactionFollowUpRequest\n  ): Promise<Result<void, string>> {\n    assert(summary.trim().length > 0, \"performCompaction requires a non-empty summary\");\n    assert(metadata.model.trim().length > 0, \"Compaction summary requires a model\");\n    assert(\n      streamedSummaryMessageId.trim().length > 0,\n      \"performCompaction requires streamed summary message ID\"\n    );\n\n    // CRITICAL: Delete partial.json BEFORE persisting compaction summary.\n    // This prevents a race condition where:\n    // 1. CompactionHandler persists summary\n    // 2. sendQueuedMessages triggers commitToHistory\n    // 3. commitToHistory finds stale partial.json and appends it to history\n    // By deleting partial first, commitToHistory becomes a no-op\n    const deletePartialResult = await this.partialService.deletePartial(this.workspaceId);\n    if (!deletePartialResult.success) {\n      log.warn(`Failed to delete partial before compaction: ${deletePartialResult.error}`);\n      // Continue anyway - the partial may not exist, which is fine\n    }\n\n    // Extract diffs from the latest compaction epoch only, so append-only history\n    // does not re-inject stale pre-boundary edits after subsequent compactions.\n    // If boundary markers are malformed, slicing self-heals by falling back to\n    // full history instead of crashing or dropping all diffs.\n    const latestCompactionEpochMessages = sliceMessagesFromLatestCompactionBoundary(messages);\n    this.cachedFileDiffs = extractEditedFileDiffs(latestCompactionEpochMessages);\n\n    // Persist pending state before append so pre-compaction diffs survive crashes/restarts.\n    // Best-effort: compaction must not fail just because persistence fails.\n    await this.persistPendingStateBestEffort(this.cachedFileDiffs);\n\n    const nextCompactionEpoch = getNextCompactionEpoch(messages);\n    assert(Number.isInteger(nextCompactionEpoch), \"next compaction epoch must be an integer\");\n\n    const maxExistingHistorySequence = messages.reduce((maxSeq, message) => {\n      const sequence = message.metadata?.historySequence;\n      if (sequence === undefined) {\n        return maxSeq;\n      }\n\n      if (!isNonNegativeInteger(sequence)) {\n        // Self-healing read path: malformed persisted historySequence should not brick compaction.\n        log.warn(\n          \"Ignoring malformed historySequence while deriving compaction monotonicity bound\",\n          {\n            workspaceId: this.workspaceId,\n            messageId: message.id,\n            historySequence: sequence,\n          }\n        );\n        return maxSeq;\n      }\n\n      return Math.max(maxSeq, sequence);\n    }, -1);\n\n    // For idle compaction, preserve the original recency timestamp so the workspace\n    // doesn't appear \"recently used\" in the sidebar. Use the shared recency utility\n    // to ensure consistency with how the sidebar computes recency.\n    let timestamp = Date.now();\n    if (isIdleCompaction) {\n      const recency = computeRecencyFromMessages(messages);\n      if (recency !== null) {\n        timestamp = recency;\n      }\n    }\n\n    // Create summary message with metadata.\n    // We omit providerMetadata because it contains cacheCreationInputTokens from the\n    // pre-compaction context, which inflates context usage display.\n    // Note: We no longer store historicalUsage here. Cumulative costs are tracked in\n    // session-usage.json, which is updated on every stream-end. If that file is deleted\n    // or corrupted, pre-compaction costs are lost - this is acceptable since manual\n    // file deletion is out of scope for data recovery.\n    //\n    // The summary's muxMetadata stores the pending follow-up (if any) for crash-safe dispatch.\n    // After compaction, agentSession checks if the last message is a summary with pendingFollowUp\n    // and dispatches it. The user message persisted by that dispatch serves as proof of completion.\n    const summaryMuxMetadata: CompactionSummaryMetadata = {\n      type: \"compaction-summary\",\n      pendingFollowUp,\n    };\n\n    // StreamManager persists the final assistant message before stream-end.\n    // Prefer updating that streamed summary in-place so append-only mode keeps\n    // exactly one durable summary message per /compact cycle.\n    const persistedStreamSummary = this.findPersistedStreamSummaryMessage(\n      messages,\n      streamedSummaryMessageId\n    );\n    const persistedSummaryHistorySequence = persistedStreamSummary?.metadata?.historySequence;\n\n    const summaryMessage = createMuxMessage(\n      persistedStreamSummary?.id ?? createCompactionSummaryMessageId(),\n      \"assistant\",\n      summary,\n      {\n        // Do not spread persisted streamed metadata here. Those rows can contain\n        // pre-compaction usage/context provider fields that would inflate post-\n        // compaction cache/context token displays.\n        timestamp,\n        compacted: isIdleCompaction ? \"idle\" : \"user\",\n        compactionEpoch: nextCompactionEpoch,\n        compactionBoundary: true,\n        model: metadata.model,\n        usage: metadata.usage,\n        duration: metadata.duration,\n        systemMessageTokens: metadata.systemMessageTokens,\n        muxMetadata: summaryMuxMetadata,\n      }\n    );\n    if (persistedSummaryHistorySequence !== undefined) {\n      summaryMessage.metadata = {\n        ...(summaryMessage.metadata ?? {}),\n        historySequence: persistedSummaryHistorySequence,\n      };\n    }\n\n    assert(\n      summaryMessage.metadata?.compactionBoundary === true,\n      \"Compaction summary must be marked as a compaction boundary\"\n    );\n    assert(\n      summaryMessage.metadata?.compactionEpoch === nextCompactionEpoch,\n      \"Compaction summary must persist the computed compaction epoch\"\n    );\n    assert(\n      summaryMessage.metadata?.providerMetadata === undefined,\n      \"Compaction summary must not persist stale providerMetadata\"\n    );\n    assert(\n      summaryMessage.metadata?.contextProviderMetadata === undefined,\n      \"Compaction summary must not persist stale contextProviderMetadata\"\n    );\n\n    const persistenceResult = persistedStreamSummary\n      ? await this.historyService.updateHistory(this.workspaceId, summaryMessage)\n      : await this.historyService.appendToHistory(this.workspaceId, summaryMessage);\n    if (!persistenceResult.success) {\n      this.cachedFileDiffs = [];\n      await this.deletePersistedPendingStateBestEffort();\n      const operation = persistedStreamSummary ? \"update streamed summary\" : \"append summary\";\n      return Err(`Failed to ${operation}: ${persistenceResult.error}`);\n    }\n\n    const persistedSequence = summaryMessage.metadata?.historySequence;\n    assert(\n      isNonNegativeInteger(persistedSequence),\n      \"Compaction summary persistence must produce a non-negative historySequence\"\n    );\n    if (persistedStreamSummary) {\n      assert(\n        persistedSummaryHistorySequence !== undefined &&\n          persistedSequence === persistedSummaryHistorySequence,\n        \"Compaction summary update must preserve existing historySequence\"\n      );\n    } else if (maxExistingHistorySequence >= 0) {\n      assert(\n        persistedSequence > maxExistingHistorySequence,\n        \"Compaction summary historySequence must remain monotonic\"\n      );\n    }\n\n    // Set flag to trigger post-compaction attachment injection on next turn\n    this.postCompactionAttachmentsPending = true;\n\n    // Emit summary message to frontend (add type: \"message\" for discriminated union)\n    this.emitChatEvent({ ...summaryMessage, type: \"message\" });\n\n    return Ok(undefined);\n  }\n\n  /**\n   * Emit chat event through the session's emitter\n   */\n  private emitChatEvent(message: WorkspaceChatMessage): void {\n    this.emitter.emit(\"chat-event\", {\n      workspaceId: this.workspaceId,\n      message,\n    });\n  }\n}\n"]}