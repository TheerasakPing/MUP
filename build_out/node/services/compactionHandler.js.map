{"version":3,"file":"compactionHandler.js","sourceRoot":"","sources":["../../../src/node/services/compactionHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import type { EventEmitter } from \"events\";\r\nimport * as fsPromises from \"fs/promises\";\r\nimport assert from \"@/common/utils/assert\";\r\nimport * as path from \"path\";\r\n\r\nimport type { HistoryService } from \"./historyService\";\r\nimport type { PartialService } from \"./partialService\";\r\n\r\nimport type { StreamEndEvent } from \"@/common/types/stream\";\r\nimport type { WorkspaceChatMessage } from \"@/common/orpc/types\";\r\nimport type { Result } from \"@/common/types/result\";\r\nimport { Ok, Err } from \"@/common/types/result\";\r\nimport type { LanguageModelV2Usage } from \"@ai-sdk/provider\";\r\n\r\nimport {\r\n  createMuxMessage,\r\n  getCompactionFollowUpContent,\r\n  type CompactionFollowUpRequest,\r\n  type CompactionSummaryMetadata,\r\n  type MuxMessage,\r\n} from \"@/common/types/message\";\r\nimport { createCompactionSummaryMessageId } from \"@/node/services/utils/messageIds\";\r\nimport type { TelemetryService } from \"@/node/services/telemetryService\";\r\nimport { MAX_EDITED_FILES, MAX_FILE_CONTENT_SIZE } from \"@/common/constants/attachments\";\r\nimport { roundToBase2 } from \"@/common/telemetry/utils\";\r\nimport { log } from \"@/node/services/log\";\r\nimport { computeRecencyFromMessages } from \"@/common/utils/recency\";\r\nimport {\r\n  extractEditedFileDiffs,\r\n  type FileEditDiff,\r\n} from \"@/common/utils/messages/extractEditedFiles\";\r\nimport { sliceMessagesFromLatestCompactionBoundary } from \"@/common/utils/messages/compactionBoundary\";\r\n\r\n/**\r\n * Check if a string is just a raw JSON object, which suggests the model\r\n * tried to output a tool call as text (happens when tools are disabled).\r\n *\r\n * A valid compaction summary should be prose text describing the conversation,\r\n * not a JSON blob. This general check catches any tool that might leak through.\r\n */\r\nfunction looksLikeRawJsonObject(text: string): boolean {\r\n  const trimmed = text.trim();\r\n\r\n  // Must be a JSON object (not array, not primitive)\r\n  if (!trimmed.startsWith(\"{\") || !trimmed.endsWith(\"}\")) {\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    const parsed: unknown = JSON.parse(trimmed);\r\n    // Must parse as a non-null, non-array object\r\n    return typeof parsed === \"object\" && parsed !== null && !Array.isArray(parsed);\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nconst POST_COMPACTION_STATE_FILENAME = \"post-compaction.json\";\r\n\r\ninterface PersistedPostCompactionStateV1 {\r\n  version: 1;\r\n  createdAt: number;\r\n  diffs: FileEditDiff[];\r\n}\r\n\r\nfunction coerceFileEditDiffs(value: unknown): FileEditDiff[] {\r\n  if (!Array.isArray(value)) {\r\n    return [];\r\n  }\r\n\r\n  const diffs: FileEditDiff[] = [];\r\n  for (const item of value) {\r\n    if (!item || typeof item !== \"object\") {\r\n      continue;\r\n    }\r\n\r\n    const filePath = (item as { path?: unknown }).path;\r\n    const diff = (item as { diff?: unknown }).diff;\r\n    const truncated = (item as { truncated?: unknown }).truncated;\r\n\r\n    if (typeof filePath !== \"string\") continue;\r\n    const trimmedPath = filePath.trim();\r\n    if (trimmedPath.length === 0) continue;\r\n\r\n    if (typeof diff !== \"string\") continue;\r\n    if (typeof truncated !== \"boolean\") continue;\r\n\r\n    const clampedDiff =\r\n      diff.length > MAX_FILE_CONTENT_SIZE ? diff.slice(0, MAX_FILE_CONTENT_SIZE) : diff;\r\n\r\n    diffs.push({\r\n      path: trimmedPath,\r\n      diff: clampedDiff,\r\n      truncated: truncated || diff.length > MAX_FILE_CONTENT_SIZE,\r\n    });\r\n\r\n    if (diffs.length >= MAX_EDITED_FILES) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return diffs;\r\n}\r\n\r\nfunction coercePersistedPostCompactionState(value: unknown): PersistedPostCompactionStateV1 | null {\r\n  if (!value || typeof value !== \"object\") {\r\n    return null;\r\n  }\r\n\r\n  const version = (value as { version?: unknown }).version;\r\n  if (version !== 1) {\r\n    return null;\r\n  }\r\n\r\n  const createdAt = (value as { createdAt?: unknown }).createdAt;\r\n  if (typeof createdAt !== \"number\") {\r\n    return null;\r\n  }\r\n\r\n  const diffsRaw = (value as { diffs?: unknown }).diffs;\r\n  const diffs = coerceFileEditDiffs(diffsRaw);\r\n\r\n  return {\r\n    version: 1,\r\n    createdAt,\r\n    diffs,\r\n  };\r\n}\r\n\r\nfunction hasDurableCompactedMarker(value: unknown): value is true | \"user\" | \"idle\" {\r\n  return value === true || value === \"user\" || value === \"idle\";\r\n}\r\n\r\nfunction isCompactedSummaryMessage(message: MuxMessage): boolean {\r\n  return hasDurableCompactedMarker(message.metadata?.compacted);\r\n}\r\n\r\nfunction isPositiveInteger(value: unknown): value is number {\r\n  return (\r\n    typeof value === \"number\" && Number.isFinite(value) && Number.isInteger(value) && value > 0\r\n  );\r\n}\r\n\r\nfunction isNonNegativeInteger(value: unknown): value is number {\r\n  return (\r\n    typeof value === \"number\" && Number.isFinite(value) && Number.isInteger(value) && value >= 0\r\n  );\r\n}\r\n\r\nfunction getNextCompactionEpoch(messages: MuxMessage[]): number {\r\n  let epochCursor = 0;\r\n\r\n  for (const message of messages) {\r\n    const metadata = message.metadata;\r\n    if (!metadata) {\r\n      continue;\r\n    }\r\n\r\n    const isCompactedSummary = isCompactedSummaryMessage(message);\r\n    const hasBoundaryMarker = metadata.compactionBoundary === true;\r\n    const epoch = metadata.compactionEpoch;\r\n\r\n    if (hasBoundaryMarker && !isCompactedSummary) {\r\n      // Self-healing read path: skip malformed persisted boundary markers.\r\n      // Boundary markers are only valid on compacted summaries.\r\n      log.warn(\"Skipping malformed compaction boundary while deriving next epoch\", {\r\n        messageId: message.id,\r\n        reason: \"compactionBoundary set on non-compacted message\",\r\n      });\r\n      continue;\r\n    }\r\n\r\n    if (!isCompactedSummary) {\r\n      continue;\r\n    }\r\n\r\n    if (hasBoundaryMarker) {\r\n      if (!isPositiveInteger(epoch)) {\r\n        // Self-healing read path: invalid boundary metadata should not brick compaction.\r\n        log.warn(\"Skipping malformed compaction boundary while deriving next epoch\", {\r\n          messageId: message.id,\r\n          reason: \"compactionBoundary missing positive integer compactionEpoch\",\r\n        });\r\n        continue;\r\n      }\r\n      epochCursor = Math.max(epochCursor, epoch);\r\n      continue;\r\n    }\r\n\r\n    if (epoch === undefined) {\r\n      // Legacy compacted summaries predate compactionEpoch metadata.\r\n      epochCursor += 1;\r\n      continue;\r\n    }\r\n\r\n    if (!isPositiveInteger(epoch)) {\r\n      // Self-healing read path: malformed compactionEpoch should not crash compaction.\r\n      log.warn(\"Skipping malformed compactionEpoch while deriving next epoch\", {\r\n        messageId: message.id,\r\n        reason: \"compactionEpoch must be a positive integer when present\",\r\n      });\r\n      continue;\r\n    }\r\n\r\n    epochCursor = Math.max(epochCursor, epoch);\r\n  }\r\n\r\n  const nextEpoch = epochCursor + 1;\r\n  assert(nextEpoch > 0, \"next compaction epoch must be positive\");\r\n  return nextEpoch;\r\n}\r\n\r\ninterface CompactionHandlerOptions {\r\n  workspaceId: string;\r\n  historyService: HistoryService;\r\n  partialService: PartialService;\r\n  sessionDir: string;\r\n  telemetryService?: TelemetryService;\r\n  emitter: EventEmitter;\r\n  /** Called when compaction completes successfully (e.g., to clear idle compaction pending state) */\r\n  onCompactionComplete?: () => void;\r\n}\r\n\r\n/**\r\n * Handles history compaction for agent sessions\r\n *\r\n * Responsible for:\r\n * - Detecting compaction requests in stream events\r\n * - Appending compacted summaries as durable history boundaries\r\n * - Preserving cumulative usage across compactions\r\n */\r\nexport class CompactionHandler {\r\n  private readonly workspaceId: string;\r\n  private readonly historyService: HistoryService;\r\n  private readonly sessionDir: string;\r\n  private readonly postCompactionStatePath: string;\r\n  private persistedPendingStateLoaded = false;\r\n  private readonly partialService: PartialService;\r\n  private readonly telemetryService?: TelemetryService;\r\n  private readonly emitter: EventEmitter;\r\n  private readonly processedCompactionRequestIds: Set<string> = new Set<string>();\r\n\r\n  private readonly onCompactionComplete?: () => void;\r\n\r\n  /** Flag indicating post-compaction attachments should be generated on next turn */\r\n  private postCompactionAttachmentsPending = false;\r\n  /** Cached file diffs extracted from history before appending compaction summary */\r\n  private cachedFileDiffs: FileEditDiff[] = [];\r\n\r\n  constructor(options: CompactionHandlerOptions) {\r\n    assert(options, \"CompactionHandler requires options\");\r\n    assert(typeof options.sessionDir === \"string\", \"sessionDir must be a string\");\r\n    const trimmedSessionDir = options.sessionDir.trim();\r\n    assert(trimmedSessionDir.length > 0, \"sessionDir must not be empty\");\r\n\r\n    this.workspaceId = options.workspaceId;\r\n    this.historyService = options.historyService;\r\n    this.sessionDir = trimmedSessionDir;\r\n    this.postCompactionStatePath = path.join(trimmedSessionDir, POST_COMPACTION_STATE_FILENAME);\r\n    this.partialService = options.partialService;\r\n    this.telemetryService = options.telemetryService;\r\n    this.emitter = options.emitter;\r\n    this.onCompactionComplete = options.onCompactionComplete;\r\n  }\r\n\r\n  private async loadPersistedPendingStateIfNeeded(): Promise<void> {\r\n    if (this.persistedPendingStateLoaded || this.postCompactionAttachmentsPending) {\r\n      return;\r\n    }\r\n\r\n    this.persistedPendingStateLoaded = true;\r\n\r\n    let raw: string;\r\n    try {\r\n      raw = await fsPromises.readFile(this.postCompactionStatePath, \"utf-8\");\r\n    } catch {\r\n      return;\r\n    }\r\n\r\n    let parsed: unknown;\r\n    try {\r\n      parsed = JSON.parse(raw);\r\n    } catch {\r\n      log.warn(\"Invalid post-compaction state JSON; ignoring\", { workspaceId: this.workspaceId });\r\n      await this.deletePersistedPendingStateBestEffort();\r\n      return;\r\n    }\r\n\r\n    const state = coercePersistedPostCompactionState(parsed);\r\n    if (!state) {\r\n      log.warn(\"Invalid post-compaction state schema; ignoring\", { workspaceId: this.workspaceId });\r\n      await this.deletePersistedPendingStateBestEffort();\r\n      return;\r\n    }\r\n\r\n    // Note: We intentionally do not validate against chat history here.\r\n    // The presence of this file is the source of truth that a compaction occurred (or at least started),\r\n    // and pre-compaction diffs may have been deleted from history.\r\n\r\n    this.cachedFileDiffs = state.diffs;\r\n    this.postCompactionAttachmentsPending = true;\r\n  }\r\n\r\n  /**\r\n   * Peek pending post-compaction diffs without consuming them.\r\n   * Returns null if no compaction occurred, otherwise returns the cached diffs.\r\n   */\r\n  async peekPendingDiffs(): Promise<FileEditDiff[] | null> {\r\n    if (!this.postCompactionAttachmentsPending) {\r\n      await this.loadPersistedPendingStateIfNeeded();\r\n    }\r\n\r\n    if (!this.postCompactionAttachmentsPending) {\r\n      return null;\r\n    }\r\n\r\n    return this.cachedFileDiffs;\r\n  }\r\n\r\n  /**\r\n   * Acknowledge that pending post-compaction state has been consumed successfully.\r\n   * Clears in-memory state and deletes the persisted snapshot from disk.\r\n   */\r\n  async ackPendingDiffsConsumed(): Promise<void> {\r\n    // If we never loaded persisted state but it exists, clear it anyway.\r\n    if (!this.postCompactionAttachmentsPending && !this.persistedPendingStateLoaded) {\r\n      await this.loadPersistedPendingStateIfNeeded();\r\n    }\r\n\r\n    this.postCompactionAttachmentsPending = false;\r\n    this.cachedFileDiffs = [];\r\n    await this.deletePersistedPendingStateBestEffort();\r\n  }\r\n\r\n  /**\r\n   * Drop pending post-compaction state (e.g., because it caused context_exceeded).\r\n   */\r\n  async discardPendingDiffs(reason: string): Promise<void> {\r\n    await this.loadPersistedPendingStateIfNeeded();\r\n\r\n    if (!this.postCompactionAttachmentsPending) {\r\n      return;\r\n    }\r\n\r\n    log.warn(\"Discarding pending post-compaction state\", {\r\n      workspaceId: this.workspaceId,\r\n      reason,\r\n      trackedFiles: this.cachedFileDiffs.length,\r\n    });\r\n\r\n    await this.ackPendingDiffsConsumed();\r\n  }\r\n\r\n  private async deletePersistedPendingStateBestEffort(): Promise<void> {\r\n    try {\r\n      await fsPromises.unlink(this.postCompactionStatePath);\r\n    } catch {\r\n      // ignore\r\n    }\r\n  }\r\n\r\n  private async persistPendingStateBestEffort(diffs: FileEditDiff[]): Promise<void> {\r\n    try {\r\n      await fsPromises.mkdir(this.sessionDir, { recursive: true });\r\n\r\n      const persisted: PersistedPostCompactionStateV1 = {\r\n        version: 1,\r\n        createdAt: Date.now(),\r\n        diffs,\r\n      };\r\n\r\n      await fsPromises.writeFile(this.postCompactionStatePath, JSON.stringify(persisted));\r\n    } catch (error) {\r\n      log.warn(\"Failed to persist post-compaction state\", {\r\n        workspaceId: this.workspaceId,\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Peek at cached file paths without consuming them.\r\n   * Returns paths of files that will be reinjected after compaction.\r\n   * Returns null if no pending compaction attachments.\r\n   */\r\n  peekCachedFilePaths(): string[] | null {\r\n    if (!this.postCompactionAttachmentsPending) {\r\n      return null;\r\n    }\r\n    return this.cachedFileDiffs.map((diff) => diff.path);\r\n  }\r\n\r\n  /**\r\n   * Handle compaction stream completion\r\n   *\r\n   * Detects when a compaction stream finishes, extracts the summary,\r\n   * and appends a durable compaction boundary message.\r\n   */\r\n  async handleCompletion(event: StreamEndEvent): Promise<boolean> {\r\n    // Check if the last user message is a compaction-request.\r\n    // Only need recent messages â€” the compaction-request is always near the tail.\r\n    const historyResult = await this.historyService.getLastMessages(this.workspaceId, 10);\r\n    if (!historyResult.success) {\r\n      return false;\r\n    }\r\n\r\n    const messages = historyResult.data;\r\n    const lastUserMsg = [...messages].reverse().find((m) => m.role === \"user\");\r\n    const muxMeta = lastUserMsg?.metadata?.muxMetadata;\r\n    const isCompaction = muxMeta?.type === \"compaction-request\";\r\n\r\n    if (!isCompaction || !lastUserMsg) {\r\n      return false;\r\n    }\r\n\r\n    // Dedupe: If we've already processed this compaction-request, skip\r\n    if (this.processedCompactionRequestIds.has(lastUserMsg.id)) {\r\n      return true;\r\n    }\r\n\r\n    const summary = event.parts\r\n      .filter((part): part is { type: \"text\"; text: string } => part.type === \"text\")\r\n      .map((part) => part.text)\r\n      .join(\"\");\r\n\r\n    // Self-healing: Reject empty summaries (stream crashed before producing content)\r\n    if (!summary.trim()) {\r\n      // Log detailed part info to help debug why no text was produced\r\n      const partsSummary = event.parts.map((p) => ({\r\n        type: p.type,\r\n        // Include preview for text-like parts to understand what the model produced\r\n        preview: \"text\" in p && typeof p.text === \"string\" ? p.text.slice(0, 100) : undefined,\r\n      }));\r\n      log.warn(\"Compaction summary is empty - aborting compaction to prevent corrupted history\", {\r\n        workspaceId: this.workspaceId,\r\n        model: event.metadata.model,\r\n        partsCount: event.parts.length,\r\n        parts: partsSummary,\r\n      });\r\n      // Don't mark as processed so user can retry\r\n      return false;\r\n    }\r\n\r\n    // Self-healing: Reject compaction if summary is just a raw JSON object.\r\n    // This happens when tools are disabled but the model still tries to output a tool call.\r\n    // A valid summary should be prose text, not a JSON blob.\r\n    if (looksLikeRawJsonObject(summary)) {\r\n      log.warn(\r\n        \"Compaction summary is a raw JSON object - aborting compaction to prevent corrupted history\",\r\n        {\r\n          workspaceId: this.workspaceId,\r\n          summaryPreview: summary.slice(0, 200),\r\n        }\r\n      );\r\n      // Don't mark as processed so user can retry\r\n      return false;\r\n    }\r\n\r\n    // Check if this was an idle-compaction (auto-triggered due to inactivity)\r\n    const isIdleCompaction =\r\n      muxMeta?.type === \"compaction-request\" && muxMeta.source === \"idle-compaction\";\r\n\r\n    // Extract follow-up content to attach to summary for crash-safe dispatch\r\n    const pendingFollowUp = getCompactionFollowUpContent(muxMeta);\r\n\r\n    // Mark as processed before performing compaction\r\n    this.processedCompactionRequestIds.add(lastUserMsg.id);\r\n\r\n    const result = await this.performCompaction(\r\n      summary,\r\n      event.metadata,\r\n      messages,\r\n      event.messageId,\r\n      isIdleCompaction,\r\n      pendingFollowUp\r\n    );\r\n    if (!result.success) {\r\n      log.error(\"Compaction failed:\", result.error);\r\n      return false;\r\n    }\r\n\r\n    const durationSecs =\r\n      typeof event.metadata.duration === \"number\" ? event.metadata.duration / 1000 : 0;\r\n    const inputTokens =\r\n      event.metadata.contextUsage?.inputTokens ?? event.metadata.usage?.inputTokens ?? 0;\r\n    const outputTokens =\r\n      event.metadata.contextUsage?.outputTokens ?? event.metadata.usage?.outputTokens ?? 0;\r\n\r\n    this.telemetryService?.capture({\r\n      event: \"compaction_completed\",\r\n      properties: {\r\n        model: event.metadata.model,\r\n        duration_b2: roundToBase2(durationSecs),\r\n        input_tokens_b2: roundToBase2(inputTokens ?? 0),\r\n        output_tokens_b2: roundToBase2(outputTokens ?? 0),\r\n        compaction_source: isIdleCompaction ? \"idle\" : \"manual\",\r\n      },\r\n    });\r\n\r\n    // Notify that compaction completed (clears idle compaction pending state)\r\n    this.onCompactionComplete?.();\r\n\r\n    // Emit a sanitized stream-end so UI can close streaming state without\r\n    // re-introducing stale provider metadata from the pre-compaction row.\r\n    this.emitChatEvent(this.sanitizeCompactionStreamEndEvent(event));\r\n    return true;\r\n  }\r\n\r\n  private sanitizeCompactionStreamEndEvent(event: StreamEndEvent): StreamEndEvent {\r\n    const sanitizedEvent: StreamEndEvent = {\r\n      ...event,\r\n      metadata: {\r\n        ...event.metadata,\r\n        providerMetadata: undefined,\r\n        contextProviderMetadata: undefined,\r\n        // contextUsage reflects the pre-compaction context window; keeping it\r\n        // would inflate the usage indicator until the next real request.\r\n        contextUsage: undefined,\r\n      },\r\n    };\r\n\r\n    assert(\r\n      sanitizedEvent.metadata.providerMetadata === undefined &&\r\n        sanitizedEvent.metadata.contextProviderMetadata === undefined &&\r\n        sanitizedEvent.metadata.contextUsage === undefined,\r\n      \"Compaction stream-end event must not carry stale provider metadata or context usage\"\r\n    );\r\n\r\n    return sanitizedEvent;\r\n  }\r\n\r\n  private findPersistedStreamSummaryMessage(\r\n    messages: MuxMessage[],\r\n    streamedSummaryMessageId: string\r\n  ): MuxMessage | null {\r\n    for (let i = messages.length - 1; i >= 0; i -= 1) {\r\n      const candidate = messages[i];\r\n      if (candidate.id !== streamedSummaryMessageId) {\r\n        continue;\r\n      }\r\n\r\n      if (candidate.role !== \"assistant\") {\r\n        // Self-healing read path: persisted message IDs can be corrupted.\r\n        log.warn(\"Cannot reuse streamed compaction summary with non-assistant role\", {\r\n          workspaceId: this.workspaceId,\r\n          messageId: candidate.id,\r\n          role: candidate.role,\r\n        });\r\n        return null;\r\n      }\r\n\r\n      const historySequence = candidate.metadata?.historySequence;\r\n      if (!isNonNegativeInteger(historySequence)) {\r\n        // Self-healing read path: invalid sequence means we cannot safely update in-place.\r\n        log.warn(\"Cannot reuse streamed compaction summary without valid historySequence\", {\r\n          workspaceId: this.workspaceId,\r\n          messageId: candidate.id,\r\n          historySequence,\r\n        });\r\n        return null;\r\n      }\r\n\r\n      return candidate;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Perform history compaction by persisting a durable summary boundary.\r\n   *\r\n   * Steps:\r\n   * 1. Delete partial state to avoid stale partial replay\r\n   * 2. Persist post-compaction attachment state\r\n   * 3. Prefer updating the streamed summary in-place, otherwise append a fallback summary\r\n   * 4. Emit summary message to frontend\r\n   */\r\n  private async performCompaction(\r\n    summary: string,\r\n    metadata: {\r\n      model: string;\r\n      usage?: LanguageModelV2Usage;\r\n      duration?: number;\r\n      providerMetadata?: Record<string, unknown>;\r\n      systemMessageTokens?: number;\r\n    },\r\n    messages: MuxMessage[],\r\n    streamedSummaryMessageId: string,\r\n    isIdleCompaction = false,\r\n    pendingFollowUp?: CompactionFollowUpRequest\r\n  ): Promise<Result<void, string>> {\r\n    assert(summary.trim().length > 0, \"performCompaction requires a non-empty summary\");\r\n    assert(metadata.model.trim().length > 0, \"Compaction summary requires a model\");\r\n    assert(\r\n      streamedSummaryMessageId.trim().length > 0,\r\n      \"performCompaction requires streamed summary message ID\"\r\n    );\r\n\r\n    // CRITICAL: Delete partial.json BEFORE persisting compaction summary.\r\n    // This prevents a race condition where:\r\n    // 1. CompactionHandler persists summary\r\n    // 2. sendQueuedMessages triggers commitToHistory\r\n    // 3. commitToHistory finds stale partial.json and appends it to history\r\n    // By deleting partial first, commitToHistory becomes a no-op\r\n    const deletePartialResult = await this.partialService.deletePartial(this.workspaceId);\r\n    if (!deletePartialResult.success) {\r\n      log.warn(`Failed to delete partial before compaction: ${deletePartialResult.error}`);\r\n      // Continue anyway - the partial may not exist, which is fine\r\n    }\r\n\r\n    // Extract diffs from the latest compaction epoch only, so append-only history\r\n    // does not re-inject stale pre-boundary edits after subsequent compactions.\r\n    // If boundary markers are malformed, slicing self-heals by falling back to\r\n    // full history instead of crashing or dropping all diffs.\r\n    const latestCompactionEpochMessages = sliceMessagesFromLatestCompactionBoundary(messages);\r\n    this.cachedFileDiffs = extractEditedFileDiffs(latestCompactionEpochMessages);\r\n\r\n    // Persist pending state before append so pre-compaction diffs survive crashes/restarts.\r\n    // Best-effort: compaction must not fail just because persistence fails.\r\n    await this.persistPendingStateBestEffort(this.cachedFileDiffs);\r\n\r\n    const nextCompactionEpoch = getNextCompactionEpoch(messages);\r\n    assert(Number.isInteger(nextCompactionEpoch), \"next compaction epoch must be an integer\");\r\n\r\n    const maxExistingHistorySequence = messages.reduce((maxSeq, message) => {\r\n      const sequence = message.metadata?.historySequence;\r\n      if (sequence === undefined) {\r\n        return maxSeq;\r\n      }\r\n\r\n      if (!isNonNegativeInteger(sequence)) {\r\n        // Self-healing read path: malformed persisted historySequence should not brick compaction.\r\n        log.warn(\r\n          \"Ignoring malformed historySequence while deriving compaction monotonicity bound\",\r\n          {\r\n            workspaceId: this.workspaceId,\r\n            messageId: message.id,\r\n            historySequence: sequence,\r\n          }\r\n        );\r\n        return maxSeq;\r\n      }\r\n\r\n      return Math.max(maxSeq, sequence);\r\n    }, -1);\r\n\r\n    // For idle compaction, preserve the original recency timestamp so the workspace\r\n    // doesn't appear \"recently used\" in the sidebar. Use the shared recency utility\r\n    // to ensure consistency with how the sidebar computes recency.\r\n    let timestamp = Date.now();\r\n    if (isIdleCompaction) {\r\n      const recency = computeRecencyFromMessages(messages);\r\n      if (recency !== null) {\r\n        timestamp = recency;\r\n      }\r\n    }\r\n\r\n    // Create summary message with metadata.\r\n    // We omit providerMetadata because it contains cacheCreationInputTokens from the\r\n    // pre-compaction context, which inflates context usage display.\r\n    // Note: We no longer store historicalUsage here. Cumulative costs are tracked in\r\n    // session-usage.json, which is updated on every stream-end. If that file is deleted\r\n    // or corrupted, pre-compaction costs are lost - this is acceptable since manual\r\n    // file deletion is out of scope for data recovery.\r\n    //\r\n    // The summary's muxMetadata stores the pending follow-up (if any) for crash-safe dispatch.\r\n    // After compaction, agentSession checks if the last message is a summary with pendingFollowUp\r\n    // and dispatches it. The user message persisted by that dispatch serves as proof of completion.\r\n    const summaryMuxMetadata: CompactionSummaryMetadata = {\r\n      type: \"compaction-summary\",\r\n      pendingFollowUp,\r\n    };\r\n\r\n    // StreamManager persists the final assistant message before stream-end.\r\n    // Prefer updating that streamed summary in-place so append-only mode keeps\r\n    // exactly one durable summary message per /compact cycle.\r\n    const persistedStreamSummary = this.findPersistedStreamSummaryMessage(\r\n      messages,\r\n      streamedSummaryMessageId\r\n    );\r\n    const persistedSummaryHistorySequence = persistedStreamSummary?.metadata?.historySequence;\r\n\r\n    const summaryMessage = createMuxMessage(\r\n      persistedStreamSummary?.id ?? createCompactionSummaryMessageId(),\r\n      \"assistant\",\r\n      summary,\r\n      {\r\n        // Do not spread persisted streamed metadata here. Those rows can contain\r\n        // pre-compaction usage/context provider fields that would inflate post-\r\n        // compaction cache/context token displays.\r\n        timestamp,\r\n        compacted: isIdleCompaction ? \"idle\" : \"user\",\r\n        compactionEpoch: nextCompactionEpoch,\r\n        compactionBoundary: true,\r\n        model: metadata.model,\r\n        usage: metadata.usage,\r\n        duration: metadata.duration,\r\n        systemMessageTokens: metadata.systemMessageTokens,\r\n        muxMetadata: summaryMuxMetadata,\r\n      }\r\n    );\r\n    if (persistedSummaryHistorySequence !== undefined) {\r\n      summaryMessage.metadata = {\r\n        ...(summaryMessage.metadata ?? {}),\r\n        historySequence: persistedSummaryHistorySequence,\r\n      };\r\n    }\r\n\r\n    assert(\r\n      summaryMessage.metadata?.compactionBoundary === true,\r\n      \"Compaction summary must be marked as a compaction boundary\"\r\n    );\r\n    assert(\r\n      summaryMessage.metadata?.compactionEpoch === nextCompactionEpoch,\r\n      \"Compaction summary must persist the computed compaction epoch\"\r\n    );\r\n    assert(\r\n      summaryMessage.metadata?.providerMetadata === undefined,\r\n      \"Compaction summary must not persist stale providerMetadata\"\r\n    );\r\n    assert(\r\n      summaryMessage.metadata?.contextProviderMetadata === undefined,\r\n      \"Compaction summary must not persist stale contextProviderMetadata\"\r\n    );\r\n\r\n    const persistenceResult = persistedStreamSummary\r\n      ? await this.historyService.updateHistory(this.workspaceId, summaryMessage)\r\n      : await this.historyService.appendToHistory(this.workspaceId, summaryMessage);\r\n    if (!persistenceResult.success) {\r\n      this.cachedFileDiffs = [];\r\n      await this.deletePersistedPendingStateBestEffort();\r\n      const operation = persistedStreamSummary ? \"update streamed summary\" : \"append summary\";\r\n      return Err(`Failed to ${operation}: ${persistenceResult.error}`);\r\n    }\r\n\r\n    const persistedSequence = summaryMessage.metadata?.historySequence;\r\n    assert(\r\n      isNonNegativeInteger(persistedSequence),\r\n      \"Compaction summary persistence must produce a non-negative historySequence\"\r\n    );\r\n    if (persistedStreamSummary) {\r\n      assert(\r\n        persistedSummaryHistorySequence !== undefined &&\r\n          persistedSequence === persistedSummaryHistorySequence,\r\n        \"Compaction summary update must preserve existing historySequence\"\r\n      );\r\n    } else if (maxExistingHistorySequence >= 0) {\r\n      assert(\r\n        persistedSequence > maxExistingHistorySequence,\r\n        \"Compaction summary historySequence must remain monotonic\"\r\n      );\r\n    }\r\n\r\n    // Set flag to trigger post-compaction attachment injection on next turn\r\n    this.postCompactionAttachmentsPending = true;\r\n\r\n    // Emit summary message to frontend (add type: \"message\" for discriminated union)\r\n    this.emitChatEvent({ ...summaryMessage, type: \"message\" });\r\n\r\n    return Ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Emit chat event through the session's emitter\r\n   */\r\n  private emitChatEvent(message: WorkspaceChatMessage): void {\r\n    this.emitter.emit(\"chat-event\", {\r\n      workspaceId: this.workspaceId,\r\n      message,\r\n    });\r\n  }\r\n}\r\n"]}