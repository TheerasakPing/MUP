{"version":3,"file":"bashExecutionService.js","sourceRoot":"","sources":["../../../src/node/services/bashExecutionService.ts"],"names":[],"mappings":";;;AAAA,iDAAsC;AAEtC,+BAA4B;AAC5B,yDAAyD;AA0BzD;;;;GAIG;AACH;IAG+B,OAAO;IAF5B,QAAQ,GAAG,KAAK,CAAC;IAEzB,YAA6B,OAAqB,EAAE;uBAAvB,OAAO;IAAiB,CAAC;IAEtD,CAAC,MAAM,CAAC,OAAO,CAAC,GAAS;QACvB,gEAAgE;QAChE,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,KAAK,SAAS,EAAE,CAAC;YACpD,OAAO;QACT,CAAC;QAED,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QAErB,IAAI,CAAC;YACH,oEAAoE;YACpE,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;QAC7C,CAAC;QAAC,MAAM,CAAC;YACP,8CAA8C;YAC9C,IAAI,CAAC;gBACH,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAC/B,CAAC;YAAC,MAAM,CAAC;gBACP,gCAAgC;YAClC,CAAC;QACH,CAAC;IAAA,CACF;IAED,IAAI,KAAK,GAAiB;QACxB,OAAO,IAAI,CAAC,OAAO,CAAC;IAAA,CACrB;CACF;;AAED;;;;;;;;;;;GAWG;AACH;IACE;;;OAGG;IACK,qBAAqB,CAAC,OAAgC,EAAqB;QACjF,OAAO;YACL,GAAG,OAAO,CAAC,GAAG;YACd,0CAA0C;YAC1C,GAAG,CAAC,OAAO,IAAI,EAAE,CAAC;YAClB,2DAA2D;YAC3D,0EAA0E;YAC1E,UAAU,EAAE,MAAM,EAAE,yCAAyC;YAC7D,mBAAmB,EAAE,MAAM,EAAE,mCAAmC;YAChE,MAAM,EAAE,MAAM,EAAE,wCAAwC;YACxD,MAAM,EAAE,MAAM,EAAE,6CAA6C;YAC7D,6CAA6C;YAC7C,yEAAyE;YACzE,qFAAqF;YACrF,mBAAmB,EAAE,GAAG,EAAE,kCAAkC;SAC7D,CAAC;IAAA,CACH;IAED;;;;;;;;;;OAUG;IACH,gBAAgB,CACd,MAAc,EACd,MAA2B,EAC3B,SAA6B,EACV;QACnB,SAAG,CAAC,KAAK,CAAC,wDAAwD,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC;QAChF,SAAG,CAAC,KAAK,CACP,iCAAiC,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAC/F,CAAC;QAEF,MAAM,QAAQ,GAAG,IAAA,sBAAW,GAAE,CAAC;QAC/B,MAAM,YAAY,GAAG,QAAQ,CAAC;QAC9B,MAAM,SAAS,GAAG,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QAEjC,MAAM,KAAK,GAAG,IAAA,qBAAK,EAAC,YAAY,EAAE,SAAS,EAAE;YAC3C,GAAG,EAAE,MAAM,CAAC,GAAG;YACf,GAAG,EAAE,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,OAAO,CAAC;YAC/C,KAAK,EAAE,CAAC,QAAQ,EAAE,MAAM,EAAE,MAAM,CAAC;YACjC,qEAAqE;YACrE,sEAAsE;YACtE,0CAA0C;YAC1C,QAAQ,EAAE,MAAM,CAAC,QAAQ,IAAI,IAAI;YACjC,2FAA2F;YAC3F,WAAW,EAAE,IAAI;SAClB,CAAC,CAAC;QAEH,SAAG,CAAC,KAAK,CAAC,kDAAkD,KAAK,CAAC,GAAG,IAAI,SAAS,EAAE,CAAC,CAAC;QAEtF,kDAAkD;QAClD,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,IAAI,MAAM,GAAG,EAAE,CAAC;QAEhB,MAAM,UAAU,GAAG,CAAC,GAAW,EAAE,QAAiB,EAAU,EAAE,CAAC;YAC7D,MAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;YACjC,wDAAwD;YACxD,MAAM,OAAO,GAAG,KAAK,CAAC,GAAG,EAAE,IAAI,EAAE,CAAC;YAClC,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;gBACzB,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC;oBAAE,SAAS;gBAChC,IAAI,QAAQ,EAAE,CAAC;oBACb,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBAC3B,CAAC;qBAAM,CAAC;oBACN,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBAC3B,CAAC;YACH,CAAC;YACD,OAAO,OAAO,CAAC;QAAA,CAChB,CAAC;QAEF,KAAK,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,EAAE,CAAC,KAAa,EAAE,EAAE,CAAC;YAC1C,MAAM,IAAI,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YACjC,MAAM,GAAG,UAAU,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QAAA,CACpC,CAAC,CAAC;QAEH,KAAK,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,EAAE,CAAC,KAAa,EAAE,EAAE,CAAC;YAC1C,MAAM,IAAI,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YACjC,MAAM,GAAG,UAAU,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QAAA,CACnC,CAAC,CAAC;QAEH,KAAK,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,IAAmB,EAAE,MAA6B,EAAE,EAAE,CAAC;YACxE,SAAG,CAAC,KAAK,CACP,kDAAkD,IAAI,IAAI,MAAM,YAAY,MAAM,IAAI,MAAM,EAAE,CAC/F,CAAC;YACF,oCAAoC;YACpC,IAAI,MAAM,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC7B,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YAC7B,CAAC;YACD,IAAI,MAAM,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC7B,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YAC7B,CAAC;YAED,0EAA0E;YAC1E,wDAAoD;YACpD,IAAI,QAAQ,GAAG,IAAI,IAAI,CAAC,CAAC;YACzB,IAAI,IAAI,KAAK,IAAI,IAAI,MAAM,EAAE,CAAC;gBAC5B,MAAM,aAAa,GAA2B;oBAC5C,MAAM,EAAE,CAAC;oBACT,MAAM,EAAE,CAAC;oBACT,OAAO,EAAE,CAAC;oBACV,OAAO,EAAE,CAAC;oBACV,OAAO,EAAE,CAAC;oBACV,OAAO,EAAE,EAAE;iBACZ,CAAC;gBACF,QAAQ,GAAG,GAAG,GAAG,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;YAChD,CAAC;YACD,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAAA,CAC5B,CAAC,CAAC;QAEH,KAAK,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,KAAY,EAAE,EAAE,CAAC;YAClC,SAAG,CAAC,KAAK,CAAC,sCAAsC,EAAE,KAAK,CAAC,CAAC;QAAA,CAC1D,CAAC,CAAC;QAEH,OAAO,IAAI,iBAAiB,CAAC,KAAK,CAAC,CAAC;IAAA,CACrC;CACF","sourcesContent":["import { spawn } from \"child_process\";\nimport type { ChildProcess } from \"child_process\";\nimport { log } from \"./log\";\nimport { getBashPath } from \"@/node/utils/main/bashPath\";\n\n/**\n * Configuration for bash execution\n */\nexport interface BashExecutionConfig {\n  /** Working directory for command execution */\n  cwd: string;\n  /** Environment secrets to inject (e.g., API keys) */\n  secrets?: Record<string, string>;\n  /** Whether to spawn as detached process group (default: true) */\n  detached?: boolean;\n}\n\n/**\n * Callbacks for streaming execution mode\n */\nexport interface StreamingCallbacks {\n  /** Called for each complete line from stdout */\n  onStdout: (line: string) => void;\n  /** Called for each complete line from stderr */\n  onStderr: (line: string) => void;\n  /** Called when process exits */\n  onExit: (exitCode: number) => void;\n}\n\n/**\n * Wraps a ChildProcess to make it disposable for use with `using` statements.\n * Always kills the entire process group with SIGKILL to prevent zombie processes.\n * SIGKILL cannot be caught or ignored, guaranteeing immediate cleanup.\n */\nexport class DisposableProcess implements Disposable {\n  private disposed = false;\n\n  constructor(private readonly process: ChildProcess) {}\n\n  [Symbol.dispose](): void {\n    // Prevent double-signalling if dispose is called multiple times\n    if (this.disposed || this.process.pid === undefined) {\n      return;\n    }\n\n    this.disposed = true;\n\n    try {\n      // Kill entire process group with SIGKILL - cannot be caught/ignored\n      process.kill(-this.process.pid, \"SIGKILL\");\n    } catch {\n      // Fallback: try killing just the main process\n      try {\n        this.process.kill(\"SIGKILL\");\n      } catch {\n        // Process already dead - ignore\n      }\n    }\n  }\n\n  get child(): ChildProcess {\n    return this.process;\n  }\n}\n\n/**\n * Centralized bash execution service.\n *\n * All workspace command execution goes through this service to:\n * - Maintain consistent environment setup across all bash execution\n * - Provide single abstraction point for future host migration (containers, remote, etc.)\n * - Eliminate duplication between init hooks and bash tool\n *\n * Provides two execution modes:\n * - Streaming: Line-by-line output callbacks (for init hooks, real-time feedback)\n * - Buffered: Collect all output, return at end (for bash tool, LLM consumption)\n */\nexport class BashExecutionService {\n  /**\n   * Create standardized bash environment.\n   * Prevents interactive prompts that would block execution.\n   */\n  private createBashEnvironment(secrets?: Record<string, string>): NodeJS.ProcessEnv {\n    return {\n      ...process.env,\n      // Inject secrets as environment variables\n      ...(secrets ?? {}),\n      // Prevent interactive editors from blocking bash execution\n      // Critical for git operations like rebase/commit that try to open editors\n      GIT_EDITOR: \"true\", // Git-specific editor (highest priority)\n      GIT_SEQUENCE_EDITOR: \"true\", // For interactive rebase sequences\n      EDITOR: \"true\", // General fallback for non-git commands\n      VISUAL: \"true\", // Another common editor environment variable\n      // Prevent git from prompting for credentials\n      // Critical for operations like fetch/pull that might try to authenticate\n      // Without this, git can hang waiting for user input if credentials aren't configured\n      GIT_TERMINAL_PROMPT: \"0\", // Disables git credential prompts\n    };\n  }\n\n  /**\n   * Execute bash command with streaming output.\n   *\n   * Output is emitted line-by-line through callbacks as it arrives.\n   * Used by init hooks for real-time progress feedback.\n   *\n   * @param script Bash script to execute\n   * @param config Execution configuration\n   * @param callbacks Output and exit callbacks\n   * @returns DisposableProcess that can be killed with `using` statement\n   */\n  executeStreaming(\n    script: string,\n    config: BashExecutionConfig,\n    callbacks: StreamingCallbacks\n  ): DisposableProcess {\n    log.debug(`BashExecutionService: Executing streaming command in ${config.cwd}`);\n    log.debug(\n      `BashExecutionService: Script: ${script.substring(0, 100)}${script.length > 100 ? \"...\" : \"\"}`\n    );\n\n    const bashPath = getBashPath();\n    const spawnCommand = bashPath;\n    const spawnArgs = [\"-c\", script];\n\n    const child = spawn(spawnCommand, spawnArgs, {\n      cwd: config.cwd,\n      env: this.createBashEnvironment(config.secrets),\n      stdio: [\"ignore\", \"pipe\", \"pipe\"],\n      // Spawn as detached process group leader to prevent zombie processes\n      // When bash spawns background processes, detached:true allows killing\n      // the entire group via process.kill(-pid)\n      detached: config.detached ?? true,\n      // Prevent console window from appearing on Windows (WSL bash spawns steal focus otherwise)\n      windowsHide: true,\n    });\n\n    log.debug(`BashExecutionService: Spawned process with PID ${child.pid ?? \"unknown\"}`);\n\n    // Line-by-line streaming with incremental buffers\n    let outBuf = \"\";\n    let errBuf = \"\";\n\n    const flushLines = (buf: string, isStderr: boolean): string => {\n      const lines = buf.split(/\\r?\\n/);\n      // Keep the last partial line in buffer; emit full lines\n      const partial = lines.pop() ?? \"\";\n      for (const line of lines) {\n        if (line.length === 0) continue;\n        if (isStderr) {\n          callbacks.onStderr(line);\n        } else {\n          callbacks.onStdout(line);\n        }\n      }\n      return partial;\n    };\n\n    child.stdout?.on(\"data\", (chunk: Buffer) => {\n      outBuf += chunk.toString(\"utf8\");\n      outBuf = flushLines(outBuf, false);\n    });\n\n    child.stderr?.on(\"data\", (chunk: Buffer) => {\n      errBuf += chunk.toString(\"utf8\");\n      errBuf = flushLines(errBuf, true);\n    });\n\n    child.on(\"close\", (code: number | null, signal: NodeJS.Signals | null) => {\n      log.debug(\n        `BashExecutionService: Process exited with code ${code ?? \"null\"}, signal ${signal ?? \"none\"}`\n      );\n      // Flush any remaining partial lines\n      if (outBuf.trim().length > 0) {\n        callbacks.onStdout(outBuf);\n      }\n      if (errBuf.trim().length > 0) {\n        callbacks.onStderr(errBuf);\n      }\n\n      // Convert signal to exit code using Unix convention (128 + signal number)\n      // Common signals: SIGTERM=15 → 143, SIGKILL=9 → 137\n      let exitCode = code ?? 0;\n      if (code === null && signal) {\n        const signalNumbers: Record<string, number> = {\n          SIGHUP: 1,\n          SIGINT: 2,\n          SIGQUIT: 3,\n          SIGABRT: 6,\n          SIGKILL: 9,\n          SIGTERM: 15,\n        };\n        exitCode = 128 + (signalNumbers[signal] ?? 1);\n      }\n      callbacks.onExit(exitCode);\n    });\n\n    child.on(\"error\", (error: Error) => {\n      log.error(`BashExecutionService: Process error:`, error);\n    });\n\n    return new DisposableProcess(child);\n  }\n}\n"]}