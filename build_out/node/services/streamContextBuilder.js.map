{"version":3,"file":"streamContextBuilder.js","sourceRoot":"","sources":["../../../src/node/services/streamContextBuilder.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;GAaG;;;;;;;;AAEH,mEAA2C;AAM3C,0DAAsE;AACtE,4DAA6D;AAC7D,2DAAsF;AACtF,uFAAuF;AACvF,0DAA4D;AAC5D,sGAMkE;AAClE,sFAA8F;AAC9F,gHAA6G;AAC7G,uFAAqF;AACrF,mDAAqD;AACrD,2DAAmE;AACnE,+BAA4B;AAwC5B;;;;;;;;;;GAUG;AACI,KAAK,gCACV,IAAkC,EACD;IACjC,MAAM,EACJ,OAAO,EACP,QAAQ,EACR,WAAW,EACX,aAAa,EACb,gBAAgB,EAChB,eAAe,EACf,kBAAkB,EAClB,4BAA4B,EAC5B,8BAA8B,EAC9B,SAAS,EACT,YAAY,EACZ,sBAAsB,GACvB,GAAG,IAAI,CAAC;IAET,MAAM,YAAY,GAAG,SAAG,CAAC,UAAU,CAAC,EAAE,WAAW,EAAE,aAAa,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC;IAEnF,kDAAkD;IAClD,yEAAyE;IACzE,IAAI,+BAA+B,GAAG,4BAA4B,CAAC;IACnE,MAAM,OAAO,GAAG,OAAO,CAAC,UAAU,EAAE,CAAC;IACrC,MAAM,YAAY,GAAG,IAAA,6BAAe,EAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;IAEnF,0DAA0D;IAC1D,MAAM,UAAU,GAAG,MAAM,IAAA,sBAAY,EAAC,OAAO,EAAE,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;IAEjG,MAAM,2BAA2B,GAAG,IAAA,8CAAuB,EAAC,sBAAsB,CAAC,CAAC;IAEpF,IAAI,aAAa,KAAK,MAAM,EAAE,CAAC;QAC7B,MAAM,mBAAmB,GAAG,IAAA,kCAAsB,EAAC,YAAY,EAAE,UAAU,CAAC,MAAM,CAAC,CAAC;QACpF,+BAA+B,GAAG,4BAA4B;YAC5D,CAAC,CAAC,GAAG,mBAAmB,OAAO,4BAA4B,EAAE;YAC7D,CAAC,CAAC,mBAAmB,CAAC;IAC1B,CAAC;SAAM,IAAI,UAAU,CAAC,MAAM,IAAI,UAAU,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;QAC1D,0FAA0F;QAC1F,oFAAoF;QACpF,wBAAwB;QACxB,EAAE;QACF,oFAAoF;QACpF,iFAAiF;QACjF,sFAAoF;QACpF,IAAI,CAAC,2BAA2B,EAAE,CAAC;YACjC,MAAM,YAAY,GAAG,IAAA,2BAAe,EAAC,YAAY,EAAE,UAAU,CAAC,MAAM,CAAC,CAAC;YACtE,IAAI,YAAY,EAAE,CAAC;gBACjB,+BAA+B,GAAG,+BAA+B;oBAC/D,CAAC,CAAC,GAAG,YAAY,OAAO,+BAA+B,EAAE;oBACzD,CAAC,CAAC,YAAY,CAAC;YACnB,CAAC;QACH,CAAC;aAAM,CAAC;YACN,YAAY,CAAC,KAAK,CAChB,gFAAgF,CACjF,CAAC;QACJ,CAAC;IACH,CAAC;IAED,IAAI,8BAA8B,EAAE,CAAC;QACnC,MAAM,kBAAkB,GACtB,4DAA4D,SAAS,IAAI;YACzE,uBAAuB,YAAY,CAAC,mBAAmB,0DAA0D,CAAC;QACpH,+BAA+B,GAAG,+BAA+B;YAC/D,CAAC,CAAC,GAAG,+BAA+B,OAAO,kBAAkB,EAAE;YAC/D,CAAC,CAAC,kBAAkB,CAAC;IACzB,CAAC;IAED,4EAA0E;IAC1E,mGAAmG;IACnG,IAAI,wBAA4C,CAAC;IACjD,MAAM,kBAAkB,GAAG,gBAAgB,KAAK,MAAM,IAAI,gBAAgB,KAAK,cAAc,CAAC;IAC9F,IAAI,kBAAkB,IAAI,CAAC,2BAA2B,EAAE,CAAC;QACvD,MAAM,oBAAoB,GAAG,CAAC,GAAG,sBAAsB,CAAC;aACrD,OAAO,EAAE;aACT,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,WAAW,CAAC,CAAC;QACvC,MAAM,WAAW,GAAG,oBAAoB,EAAE,QAAQ,EAAE,OAAO,CAAC;QAC5D,IAAI,WAAW,IAAI,UAAU,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;YAC7C,IAAI,mBAAmB,GAAG,KAAK,CAAC;YAChC,IAAI,WAAW,KAAK,gBAAgB,EAAE,CAAC;gBACrC,mBAAmB,GAAG,eAAe,CAAC;YACxC,CAAC;iBAAM,CAAC;gBACN,IAAI,CAAC;oBACH,MAAM,cAAc,GAAG,MAAM,IAAA,6CAAmB,EAC9C,OAAO,EACP,kBAAkB,EAClB,WAAW,CACZ,CAAC;oBACF,MAAM,SAAS,GAAG,MAAM,IAAA,2DAA4B,EAAC;wBACnD,OAAO;wBACP,aAAa,EAAE,kBAAkB;wBACjC,OAAO,EAAE,WAAW;wBACpB,eAAe,EAAE,cAAc;wBAC/B,WAAW;qBACZ,CAAC,CAAC;oBACH,mBAAmB,GAAG,IAAA,sCAAyB,EAAC,SAAS,CAAC,CAAC;gBAC7D,CAAC;gBAAC,OAAO,KAAK,EAAE,CAAC;oBACf,YAAY,CAAC,IAAI,CAAC,0DAA0D,EAAE;wBAC5E,WAAW;wBACX,KAAK,EAAE,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC;qBAC9D,CAAC,CAAC;gBACL,CAAC;YACH,CAAC;YAED,IAAI,mBAAmB,EAAE,CAAC;gBACxB,wBAAwB,GAAG,UAAU,CAAC,OAAO,CAAC;YAChD,CAAC;QACH,CAAC;IACH,CAAC;SAAM,IAAI,kBAAkB,IAAI,2BAA2B,EAAE,CAAC;QAC7D,YAAY,CAAC,KAAK,CAChB,oHAAoH,CACrH,CAAC;IACJ,CAAC;IAED,OAAO,EAAE,+BAA+B,EAAE,YAAY,EAAE,wBAAwB,EAAE,CAAC;AAAA,CACpF;AAoCD;;;;;;;;;;GAUG;AACI,KAAK,mCACV,IAAqC,EACD;IACpC,MAAM,EACJ,OAAO,EACP,QAAQ,EACR,aAAa,EACb,WAAW,EACX,eAAe,EACf,kBAAkB,EAClB,mBAAmB,EACnB,+BAA+B,EAC/B,WAAW,EACX,GAAG,EACH,UAAU,GACX,GAAG,IAAI,CAAC;IAET,MAAM,YAAY,GAAG,SAAG,CAAC,UAAU,CAAC,EAAE,WAAW,EAAE,aAAa,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC;IAEnF,sEAAsE;IACtE,qFAAqF;IACrF,MAAM,YAAY,GAAG,MAAM,IAAA,0CAAgB,EAAC,OAAO,EAAE,kBAAkB,EAAE,eAAe,CAAC,EAAE,CAAC,CAAC;IAE7F,IAAI,oBAAwC,CAAC;IAC7C,IAAI,mBAAmB,EAAE,CAAC;QACxB,IAAI,CAAC;YACH,MAAM,mBAAmB,GAAG,MAAM,IAAA,iDAAuB,EACvD,OAAO,EACP,kBAAkB,EAClB,eAAe,CAAC,EAAE,CACnB,CAAC;YACF,oBAAoB,GAAG,mBAAmB,CAAC,QAAQ,EAAE,aAAa,CAAC;QACrE,CAAC;QAAC,OAAO,KAAc,EAAE,CAAC;YACxB,YAAY,CAAC,KAAK,CAAC,gEAAgE,EAAE;gBACnF,OAAO,EAAE,eAAe,CAAC,EAAE;gBAC3B,KAAK,EAAE,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC;aAC9D,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAED,MAAM,iBAAiB,GACrB,mBAAmB,IAAI,oBAAoB;QACzC,CAAC,CAAC,GAAG,YAAY,OAAO,oBAAoB,EAAE;QAC9C,CAAC,CAAC,YAAY,CAAC;IAEnB,8FAA8F;IAC9F,EAAE;IACF,4FAA4F;IAC5F,oFAAoF;IACpF,IAAI,gBAAkF,CAAC;IACvF,IAAI,CAAC,mBAAmB,EAAE,CAAC;QACzB,gBAAgB,GAAG,MAAM,wCAAwC,CAAC;YAChE,OAAO;YACP,aAAa,EAAE,kBAAkB;YACjC,GAAG;SACJ,CAAC,CAAC;IACL,CAAC;IAED,yDAAyD;IACzD,IAAI,eAA4E,CAAC;IACjF,IAAI,CAAC;QACH,eAAe,GAAG,MAAM,IAAA,wCAAmB,EAAC,OAAO,EAAE,aAAa,CAAC,CAAC;IACtE,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,YAAY,CAAC,IAAI,CAAC,sDAAsD,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;IACvF,CAAC;IAED,+CAA+C;IAC/C,MAAM,aAAa,GAAG,MAAM,IAAA,kCAAkB,EAC5C,QAAQ,EACR,OAAO,EACP,aAAa,EACb,+BAA+B,EAC/B,WAAW,EACX,UAAU,EACV,EAAE,iBAAiB,EAAE,CACtB,CAAC;IAEF,gDAAgD;IAChD,MAAM,SAAS,GAAG,MAAM,IAAA,gCAAoB,EAAC,WAAW,CAAC,CAAC;IAC1D,MAAM,mBAAmB,GAAG,MAAM,SAAS,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC;IAEvE,OAAO;QACL,iBAAiB;QACjB,aAAa;QACb,mBAAmB;QACnB,gBAAgB;QAChB,eAAe;KAChB,CAAC;AAAA,CACH;AAED,8EAA8E;AAC9E,4BAA4B;AAC5B,8EAA8E;AAE9E;;;;;;;;;;;GAWG;AACI,KAAK,mDAAmD,IAK9D,EAAiE;IAChE,IAAA,gBAAM,EAAC,IAAI,EAAE,4DAA4D,CAAC,CAAC;IAC3E,IAAA,gBAAM,EAAC,IAAI,CAAC,OAAO,EAAE,+DAA+D,CAAC,CAAC;IACtF,IAAA,gBAAM,EACJ,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,EACnD,qEAAqE,CACtE,CAAC;IACF,IAAA,gBAAM,EAAC,IAAI,CAAC,GAAG,EAAE,2DAA2D,CAAC,CAAC;IAE9E,MAAM,UAAU,GAAG,MAAM,IAAA,kDAAwB,EAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,aAAa,EAAE;QAClF,KAAK,EAAE,IAAI,CAAC,KAAK;KAClB,CAAC,CAAC;IAEH,MAAM,QAAQ,GAAG,MAAM,OAAO,CAAC,GAAG,CAChC,UAAU,CAAC,GAAG,CAAC,KAAK,EAAE,UAAU,EAAE,EAAE,CAAC;QACnC,IAAI,CAAC;YACH,MAAM,mBAAmB,GAAG,MAAM,IAAA,iDAAuB,EACvD,IAAI,CAAC,OAAO,EACZ,IAAI,CAAC,aAAa,EAClB,UAAU,CAAC,EAAE,EACb,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,CACtB,CAAC;YAEF,MAAM,mBAAmB,GAAG,IAAA,4CAA0B,EAAC;gBACrD,GAAG,EAAE,IAAI,CAAC,GAAG;gBACb,OAAO,EAAE,UAAU,CAAC,EAAE;gBACtB,mBAAmB;aACpB,CAAC,CAAC;YAEH,IAAI,mBAAmB,EAAE,CAAC;gBACxB,OAAO,IAAI,CAAC;YACd,CAAC;YAED,OAAO;gBACL,GAAG,UAAU;gBACb,sFAAsF;gBACtF,wFAAwF;gBACxF,gBAAgB,EAAE,mBAAmB,CAAC,QAAQ,EAAE,QAAQ,IAAI,KAAK;aAClE,CAAC;QACJ,CAAC;QAAC,MAAM,CAAC;YACP,mFAAmF;YACnF,OAAO,UAAU,CAAC;QACpB,CAAC;IAAA,CACF,CAAC,CACH,CAAC;IAEF,OAAO,QAAQ,CAAC,MAAM,CAAC,CAAC,UAAU,EAAgD,EAAE,CAClF,OAAO,CAAC,UAAU,CAAC,CACpB,CAAC;AAAA,CACH","sourcesContent":["/**\r\n * Stream context builder: assembles plan instructions and system prompt for a stream.\r\n *\r\n * Extracted from `streamMessage()` to make these purely functional\r\n * preparation steps explicit and testable. Contains:\r\n * - Plan file reading, mode instructions, task nesting warnings\r\n * - Plan→exec handoff transition content\r\n * - Agent body resolution with inheritance + subagent prompt append\r\n * - Subagent discovery for tool descriptions\r\n * - Skill discovery for tool descriptions\r\n * - System message construction and token counting\r\n *\r\n * All functions are pure — no service dependencies (`this.*`).\r\n */\r\n\r\nimport assert from \"@/common/utils/assert\";\r\nimport type { MuxMessage } from \"@/common/types/message\";\r\nimport type { WorkspaceMetadata } from \"@/common/types/workspace\";\r\nimport type { ProjectsConfig } from \"@/common/types/project\";\r\nimport type { TaskSettings } from \"@/common/types/tasks\";\r\nimport type { Runtime } from \"@/node/runtime/Runtime\";\r\nimport { isPlanLikeInResolvedChain } from \"@/common/utils/agentTools\";\r\nimport { getPlanFilePath } from \"@/common/utils/planStorage\";\r\nimport { getPlanFileHint, getPlanModeInstruction } from \"@/common/utils/ui/modeUtils\";\r\nimport { hasStartHerePlanSummary } from \"@/common/utils/messages/startHerePlanSummary\";\r\nimport { readPlanFile } from \"@/node/utils/runtime/helpers\";\r\nimport {\r\n  readAgentDefinition,\r\n  resolveAgentBody,\r\n  resolveAgentFrontmatter,\r\n  discoverAgentDefinitions,\r\n  type AgentDefinitionsRoots,\r\n} from \"@/node/services/agentDefinitions/agentDefinitionsService\";\r\nimport { isAgentEffectivelyDisabled } from \"@/node/services/agentDefinitions/agentEnablement\";\r\nimport { resolveAgentInheritanceChain } from \"@/node/services/agentDefinitions/resolveAgentInheritanceChain\";\r\nimport { discoverAgentSkills } from \"@/node/services/agentSkills/agentSkillsService\";\r\nimport { buildSystemMessage } from \"./systemMessage\";\r\nimport { getTokenizerForModel } from \"@/node/utils/main/tokenizer\";\r\nimport { log } from \"./log\";\r\n\r\n// ---------------------------------------------------------------------------\r\n// Plan & Instructions Assembly\r\n// ---------------------------------------------------------------------------\r\n\r\n/** Options for building plan-aware additional instructions. */\r\nexport interface BuildPlanInstructionsOptions {\r\n  runtime: Runtime;\r\n  metadata: WorkspaceMetadata;\r\n  workspaceId: string;\r\n  workspacePath: string;\r\n  effectiveMode: \"plan\" | \"exec\" | \"compact\";\r\n  effectiveAgentId: string;\r\n  agentIsPlanLike: boolean;\r\n  agentDiscoveryPath: string;\r\n  /** Base additional instructions from the caller (may be undefined). */\r\n  additionalSystemInstructions: string | undefined;\r\n  shouldDisableTaskToolsForDepth: boolean;\r\n  taskDepth: number;\r\n  taskSettings: TaskSettings;\r\n  /**\r\n   * Message history that will be sent to the provider (after request-time slicing/filtering).\r\n   *\r\n   * Plan-context derivation must stay aligned with the request payload to avoid pre-boundary\r\n   * history (e.g., old Start Here summaries) suppressing required plan hints.\r\n   */\r\n  requestPayloadMessages: MuxMessage[];\r\n}\r\n\r\n/** Result of plan instructions assembly. */\r\nexport interface PlanInstructionsResult {\r\n  /** System instructions with plan-mode/nesting directives merged in. */\r\n  effectiveAdditionalInstructions: string | undefined;\r\n  /** Absolute path to the plan file (always computed, even if file doesn't exist). */\r\n  planFilePath: string;\r\n  /** Plan file content for plan→exec handoff injection (undefined if no handoff). */\r\n  planContentForTransition: string | undefined;\r\n}\r\n\r\n/**\r\n * Build plan-aware additional instructions and determine transition content.\r\n *\r\n * This handles:\r\n * 1. Reading the plan file (with legacy migration)\r\n * 2. Injecting plan-mode instructions when in plan mode\r\n * 3. Injecting plan-file hints in non-plan modes (unless Start Here already has it)\r\n * 4. Appending task-nesting-depth warnings\r\n * 5. Determining plan→exec handoff content by checking if the last assistant\r\n *    used a plan-like agent\r\n */\r\nexport async function buildPlanInstructions(\r\n  opts: BuildPlanInstructionsOptions\r\n): Promise<PlanInstructionsResult> {\r\n  const {\r\n    runtime,\r\n    metadata,\r\n    workspaceId,\r\n    effectiveMode,\r\n    effectiveAgentId,\r\n    agentIsPlanLike,\r\n    agentDiscoveryPath,\r\n    additionalSystemInstructions,\r\n    shouldDisableTaskToolsForDepth,\r\n    taskDepth,\r\n    taskSettings,\r\n    requestPayloadMessages,\r\n  } = opts;\r\n\r\n  const workspaceLog = log.withFields({ workspaceId, workspaceName: metadata.name });\r\n\r\n  // Construct plan mode instruction if in plan mode\r\n  // This is done backend-side because we have access to the plan file path\r\n  let effectiveAdditionalInstructions = additionalSystemInstructions;\r\n  const muxHome = runtime.getMuxHome();\r\n  const planFilePath = getPlanFilePath(metadata.name, metadata.projectName, muxHome);\r\n\r\n  // Read plan file (handles legacy migration transparently)\r\n  const planResult = await readPlanFile(runtime, metadata.name, metadata.projectName, workspaceId);\r\n\r\n  const chatHasStartHerePlanSummary = hasStartHerePlanSummary(requestPayloadMessages);\r\n\r\n  if (effectiveMode === \"plan\") {\r\n    const planModeInstruction = getPlanModeInstruction(planFilePath, planResult.exists);\r\n    effectiveAdditionalInstructions = additionalSystemInstructions\r\n      ? `${planModeInstruction}\\n\\n${additionalSystemInstructions}`\r\n      : planModeInstruction;\r\n  } else if (planResult.exists && planResult.content.trim()) {\r\n    // Users often use \"Replace all chat history\" after plan mode. In exec (or other non-plan)\r\n    // modes, the model can lose the plan file location because plan path injection only\r\n    // happens in plan mode.\r\n    //\r\n    // Exception: the ProposePlanToolCall \"Start Here\" flow already stores the full plan\r\n    // (and plan path) directly in chat history. In that case, prompting the model to\r\n    // re-open the plan file is redundant and often results in an extra \"read …KB\" step.\r\n    if (!chatHasStartHerePlanSummary) {\r\n      const planFileHint = getPlanFileHint(planFilePath, planResult.exists);\r\n      if (planFileHint) {\r\n        effectiveAdditionalInstructions = effectiveAdditionalInstructions\r\n          ? `${planFileHint}\\n\\n${effectiveAdditionalInstructions}`\r\n          : planFileHint;\r\n      }\r\n    } else {\r\n      workspaceLog.debug(\r\n        \"Skipping plan file hint: Start Here already includes the plan in chat history.\"\r\n      );\r\n    }\r\n  }\r\n\r\n  if (shouldDisableTaskToolsForDepth) {\r\n    const nestingInstruction =\r\n      `Task delegation is disabled in this workspace (taskDepth=${taskDepth}, ` +\r\n      `maxTaskNestingDepth=${taskSettings.maxTaskNestingDepth}). Do not call task/task_await/task_list/task_terminate.`;\r\n    effectiveAdditionalInstructions = effectiveAdditionalInstructions\r\n      ? `${effectiveAdditionalInstructions}\\n\\n${nestingInstruction}`\r\n      : nestingInstruction;\r\n  }\r\n\r\n  // Read plan content for agent transition (plan-like → exec/orchestrator).\r\n  // Only read if switching to the built-in exec/orchestrator agent and last assistant was plan-like.\r\n  let planContentForTransition: string | undefined;\r\n  const isPlanHandoffAgent = effectiveAgentId === \"exec\" || effectiveAgentId === \"orchestrator\";\r\n  if (isPlanHandoffAgent && !chatHasStartHerePlanSummary) {\r\n    const lastAssistantMessage = [...requestPayloadMessages]\r\n      .reverse()\r\n      .find((m) => m.role === \"assistant\");\r\n    const lastAgentId = lastAssistantMessage?.metadata?.agentId;\r\n    if (lastAgentId && planResult.content.trim()) {\r\n      let lastAgentIsPlanLike = false;\r\n      if (lastAgentId === effectiveAgentId) {\r\n        lastAgentIsPlanLike = agentIsPlanLike;\r\n      } else {\r\n        try {\r\n          const lastDefinition = await readAgentDefinition(\r\n            runtime,\r\n            agentDiscoveryPath,\r\n            lastAgentId\r\n          );\r\n          const lastChain = await resolveAgentInheritanceChain({\r\n            runtime,\r\n            workspacePath: agentDiscoveryPath,\r\n            agentId: lastAgentId,\r\n            agentDefinition: lastDefinition,\r\n            workspaceId,\r\n          });\r\n          lastAgentIsPlanLike = isPlanLikeInResolvedChain(lastChain);\r\n        } catch (error) {\r\n          workspaceLog.warn(\"Failed to resolve last agent definition for plan handoff\", {\r\n            lastAgentId,\r\n            error: error instanceof Error ? error.message : String(error),\r\n          });\r\n        }\r\n      }\r\n\r\n      if (lastAgentIsPlanLike) {\r\n        planContentForTransition = planResult.content;\r\n      }\r\n    }\r\n  } else if (isPlanHandoffAgent && chatHasStartHerePlanSummary) {\r\n    workspaceLog.debug(\r\n      \"Skipping plan content injection for plan handoff transition: Start Here already includes the plan in chat history.\"\r\n    );\r\n  }\r\n\r\n  return { effectiveAdditionalInstructions, planFilePath, planContentForTransition };\r\n}\r\n\r\n// ---------------------------------------------------------------------------\r\n// Agent System Prompt & System Message Assembly\r\n// ---------------------------------------------------------------------------\r\n\r\n/** Options for building the system message context. */\r\nexport interface BuildStreamSystemContextOptions {\r\n  runtime: Runtime;\r\n  metadata: WorkspaceMetadata;\r\n  workspacePath: string;\r\n  workspaceId: string;\r\n  /** Agent definition (may have fallen back to exec). Use `.id` for resolution. */\r\n  agentDefinition: { id: string };\r\n  agentDiscoveryPath: string;\r\n  isSubagentWorkspace: boolean;\r\n  effectiveAdditionalInstructions: string | undefined;\r\n  modelString: string;\r\n  cfg: ProjectsConfig;\r\n  mcpServers: Parameters<typeof buildSystemMessage>[5];\r\n}\r\n\r\n/** Result of system context assembly. */\r\nexport interface StreamSystemContextResult {\r\n  /** Resolved agent body (with inheritance + subagent append). */\r\n  agentSystemPrompt: string;\r\n  /** Full system message string. */\r\n  systemMessage: string;\r\n  /** Token count of the system message. */\r\n  systemMessageTokens: number;\r\n  /** Available subagent definitions for tool descriptions (undefined for subagent workspaces). */\r\n  agentDefinitions: Awaited<ReturnType<typeof discoverAgentDefinitions>> | undefined;\r\n  /** Available skills for tool descriptions. */\r\n  availableSkills: Awaited<ReturnType<typeof discoverAgentSkills>> | undefined;\r\n}\r\n\r\n/**\r\n * Build the agent system prompt, system message, and discover available agents/skills.\r\n *\r\n * This handles:\r\n * 1. Resolving the agent body with inheritance (prompt.append merges with base)\r\n * 2. Appending subagent.append_prompt for subagent workspaces\r\n * 3. Discovering available subagent definitions for task tool context\r\n * 4. Discovering available skills for tool descriptions\r\n * 5. Constructing the final system message\r\n * 6. Counting system message tokens\r\n */\r\nexport async function buildStreamSystemContext(\r\n  opts: BuildStreamSystemContextOptions\r\n): Promise<StreamSystemContextResult> {\r\n  const {\r\n    runtime,\r\n    metadata,\r\n    workspacePath,\r\n    workspaceId,\r\n    agentDefinition,\r\n    agentDiscoveryPath,\r\n    isSubagentWorkspace,\r\n    effectiveAdditionalInstructions,\r\n    modelString,\r\n    cfg,\r\n    mcpServers,\r\n  } = opts;\r\n\r\n  const workspaceLog = log.withFields({ workspaceId, workspaceName: metadata.name });\r\n\r\n  // Resolve the body with inheritance (prompt.append merges with base).\r\n  // Use agentDefinition.id (may have fallen back to exec) instead of effectiveAgentId.\r\n  const resolvedBody = await resolveAgentBody(runtime, agentDiscoveryPath, agentDefinition.id);\r\n\r\n  let subagentAppendPrompt: string | undefined;\r\n  if (isSubagentWorkspace) {\r\n    try {\r\n      const resolvedFrontmatter = await resolveAgentFrontmatter(\r\n        runtime,\r\n        agentDiscoveryPath,\r\n        agentDefinition.id\r\n      );\r\n      subagentAppendPrompt = resolvedFrontmatter.subagent?.append_prompt;\r\n    } catch (error: unknown) {\r\n      workspaceLog.debug(\"Failed to resolve agent frontmatter for subagent append_prompt\", {\r\n        agentId: agentDefinition.id,\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  const agentSystemPrompt =\r\n    isSubagentWorkspace && subagentAppendPrompt\r\n      ? `${resolvedBody}\\n\\n${subagentAppendPrompt}`\r\n      : resolvedBody;\r\n\r\n  // Discover available agent definitions for sub-agent context (only for top-level workspaces).\r\n  //\r\n  // NOTE: discoverAgentDefinitions returns disabled agents too, so Settings can surface them.\r\n  // For tool descriptions (task tool), filter to agents that are effectively enabled.\r\n  let agentDefinitions: Awaited<ReturnType<typeof discoverAgentDefinitions>> | undefined;\r\n  if (!isSubagentWorkspace) {\r\n    agentDefinitions = await discoverAvailableSubagentsForToolContext({\r\n      runtime,\r\n      workspacePath: agentDiscoveryPath,\r\n      cfg,\r\n    });\r\n  }\r\n\r\n  // Discover available skills for tool description context\r\n  let availableSkills: Awaited<ReturnType<typeof discoverAgentSkills>> | undefined;\r\n  try {\r\n    availableSkills = await discoverAgentSkills(runtime, workspacePath);\r\n  } catch (error) {\r\n    workspaceLog.warn(\"Failed to discover agent skills for tool description\", { error });\r\n  }\r\n\r\n  // Build system message from workspace metadata\r\n  const systemMessage = await buildSystemMessage(\r\n    metadata,\r\n    runtime,\r\n    workspacePath,\r\n    effectiveAdditionalInstructions,\r\n    modelString,\r\n    mcpServers,\r\n    { agentSystemPrompt }\r\n  );\r\n\r\n  // Count system message tokens for cost tracking\r\n  const tokenizer = await getTokenizerForModel(modelString);\r\n  const systemMessageTokens = await tokenizer.countTokens(systemMessage);\r\n\r\n  return {\r\n    agentSystemPrompt,\r\n    systemMessage,\r\n    systemMessageTokens,\r\n    agentDefinitions,\r\n    availableSkills,\r\n  };\r\n}\r\n\r\n// ---------------------------------------------------------------------------\r\n// Subagent Discovery Helper\r\n// ---------------------------------------------------------------------------\r\n\r\n/**\r\n * Discover agent definitions for tool description context.\r\n *\r\n * The task tool lists \"Available sub-agents\" by filtering on\r\n * AgentDefinitionDescriptor.subagentRunnable.\r\n *\r\n * NOTE: discoverAgentDefinitions() sets descriptor.subagentRunnable from the agent's *own*\r\n * frontmatter only, which means derived agents (e.g. `base: exec`) may incorrectly appear\r\n * non-runnable if they don't repeat `subagent.runnable: true`.\r\n *\r\n * Re-resolve frontmatter with inheritance (base-first) so subagent.runnable is inherited.\r\n */\r\nexport async function discoverAvailableSubagentsForToolContext(args: {\r\n  runtime: Parameters<typeof discoverAgentDefinitions>[0];\r\n  workspacePath: string;\r\n  cfg: ProjectsConfig;\r\n  roots?: AgentDefinitionsRoots;\r\n}): Promise<Awaited<ReturnType<typeof discoverAgentDefinitions>>> {\r\n  assert(args, \"discoverAvailableSubagentsForToolContext: args is required\");\r\n  assert(args.runtime, \"discoverAvailableSubagentsForToolContext: runtime is required\");\r\n  assert(\r\n    args.workspacePath && args.workspacePath.length > 0,\r\n    \"discoverAvailableSubagentsForToolContext: workspacePath is required\"\r\n  );\r\n  assert(args.cfg, \"discoverAvailableSubagentsForToolContext: cfg is required\");\r\n\r\n  const discovered = await discoverAgentDefinitions(args.runtime, args.workspacePath, {\r\n    roots: args.roots,\r\n  });\r\n\r\n  const resolved = await Promise.all(\r\n    discovered.map(async (descriptor) => {\r\n      try {\r\n        const resolvedFrontmatter = await resolveAgentFrontmatter(\r\n          args.runtime,\r\n          args.workspacePath,\r\n          descriptor.id,\r\n          { roots: args.roots }\r\n        );\r\n\r\n        const effectivelyDisabled = isAgentEffectivelyDisabled({\r\n          cfg: args.cfg,\r\n          agentId: descriptor.id,\r\n          resolvedFrontmatter,\r\n        });\r\n\r\n        if (effectivelyDisabled) {\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          ...descriptor,\r\n          // Important: descriptor.subagentRunnable comes from the agent's own frontmatter only.\r\n          // Re-resolve with inheritance so derived agents inherit runnable: true from their base.\r\n          subagentRunnable: resolvedFrontmatter.subagent?.runnable ?? false,\r\n        };\r\n      } catch {\r\n        // Best-effort: keep the descriptor if enablement or inheritance can't be resolved.\r\n        return descriptor;\r\n      }\r\n    })\r\n  );\r\n\r\n  return resolved.filter((descriptor): descriptor is NonNullable<typeof descriptor> =>\r\n    Boolean(descriptor)\r\n  );\r\n}\r\n"]}