{"version":3,"file":"streamContextBuilder.js","sourceRoot":"","sources":["../../../src/node/services/streamContextBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Stream context builder: assembles plan instructions and system prompt for a stream.\n *\n * Extracted from `streamMessage()` to make these purely functional\n * preparation steps explicit and testable. Contains:\n * - Plan file reading, mode instructions, task nesting warnings\n * - Plan→exec handoff transition content\n * - Agent body resolution with inheritance + subagent prompt append\n * - Subagent discovery for tool descriptions\n * - Skill discovery for tool descriptions\n * - System message construction and token counting\n *\n * All functions are pure — no service dependencies (`this.*`).\n */\n\nimport assert from \"@/common/utils/assert\";\nimport type { MuxMessage } from \"@/common/types/message\";\nimport type { WorkspaceMetadata } from \"@/common/types/workspace\";\nimport type { ProjectsConfig } from \"@/common/types/project\";\nimport type { TaskSettings } from \"@/common/types/tasks\";\nimport type { Runtime } from \"@/node/runtime/Runtime\";\nimport { isPlanLikeInResolvedChain } from \"@/common/utils/agentTools\";\nimport { getPlanFilePath } from \"@/common/utils/planStorage\";\nimport { getPlanFileHint, getPlanModeInstruction } from \"@/common/utils/ui/modeUtils\";\nimport { hasStartHerePlanSummary } from \"@/common/utils/messages/startHerePlanSummary\";\nimport { readPlanFile } from \"@/node/utils/runtime/helpers\";\nimport {\n  readAgentDefinition,\n  resolveAgentBody,\n  resolveAgentFrontmatter,\n  discoverAgentDefinitions,\n  type AgentDefinitionsRoots,\n} from \"@/node/services/agentDefinitions/agentDefinitionsService\";\nimport { isAgentEffectivelyDisabled } from \"@/node/services/agentDefinitions/agentEnablement\";\nimport { resolveAgentInheritanceChain } from \"@/node/services/agentDefinitions/resolveAgentInheritanceChain\";\nimport { discoverAgentSkills } from \"@/node/services/agentSkills/agentSkillsService\";\nimport { buildSystemMessage } from \"./systemMessage\";\nimport { getTokenizerForModel } from \"@/node/utils/main/tokenizer\";\nimport { log } from \"./log\";\n\n// ---------------------------------------------------------------------------\n// Plan & Instructions Assembly\n// ---------------------------------------------------------------------------\n\n/** Options for building plan-aware additional instructions. */\nexport interface BuildPlanInstructionsOptions {\n  runtime: Runtime;\n  metadata: WorkspaceMetadata;\n  workspaceId: string;\n  workspacePath: string;\n  effectiveMode: \"plan\" | \"exec\" | \"compact\";\n  effectiveAgentId: string;\n  agentIsPlanLike: boolean;\n  agentDiscoveryPath: string;\n  /** Base additional instructions from the caller (may be undefined). */\n  additionalSystemInstructions: string | undefined;\n  shouldDisableTaskToolsForDepth: boolean;\n  taskDepth: number;\n  taskSettings: TaskSettings;\n  /**\n   * Message history that will be sent to the provider (after request-time slicing/filtering).\n   *\n   * Plan-context derivation must stay aligned with the request payload to avoid pre-boundary\n   * history (e.g., old Start Here summaries) suppressing required plan hints.\n   */\n  requestPayloadMessages: MuxMessage[];\n}\n\n/** Result of plan instructions assembly. */\nexport interface PlanInstructionsResult {\n  /** System instructions with plan-mode/nesting directives merged in. */\n  effectiveAdditionalInstructions: string | undefined;\n  /** Absolute path to the plan file (always computed, even if file doesn't exist). */\n  planFilePath: string;\n  /** Plan file content for plan→exec handoff injection (undefined if no handoff). */\n  planContentForTransition: string | undefined;\n}\n\n/**\n * Build plan-aware additional instructions and determine transition content.\n *\n * This handles:\n * 1. Reading the plan file (with legacy migration)\n * 2. Injecting plan-mode instructions when in plan mode\n * 3. Injecting plan-file hints in non-plan modes (unless Start Here already has it)\n * 4. Appending task-nesting-depth warnings\n * 5. Determining plan→exec handoff content by checking if the last assistant\n *    used a plan-like agent\n */\nexport async function buildPlanInstructions(\n  opts: BuildPlanInstructionsOptions\n): Promise<PlanInstructionsResult> {\n  const {\n    runtime,\n    metadata,\n    workspaceId,\n    effectiveMode,\n    effectiveAgentId,\n    agentIsPlanLike,\n    agentDiscoveryPath,\n    additionalSystemInstructions,\n    shouldDisableTaskToolsForDepth,\n    taskDepth,\n    taskSettings,\n    requestPayloadMessages,\n  } = opts;\n\n  const workspaceLog = log.withFields({ workspaceId, workspaceName: metadata.name });\n\n  // Construct plan mode instruction if in plan mode\n  // This is done backend-side because we have access to the plan file path\n  let effectiveAdditionalInstructions = additionalSystemInstructions;\n  const muxHome = runtime.getMuxHome();\n  const planFilePath = getPlanFilePath(metadata.name, metadata.projectName, muxHome);\n\n  // Read plan file (handles legacy migration transparently)\n  const planResult = await readPlanFile(runtime, metadata.name, metadata.projectName, workspaceId);\n\n  const chatHasStartHerePlanSummary = hasStartHerePlanSummary(requestPayloadMessages);\n\n  if (effectiveMode === \"plan\") {\n    const planModeInstruction = getPlanModeInstruction(planFilePath, planResult.exists);\n    effectiveAdditionalInstructions = additionalSystemInstructions\n      ? `${planModeInstruction}\\n\\n${additionalSystemInstructions}`\n      : planModeInstruction;\n  } else if (planResult.exists && planResult.content.trim()) {\n    // Users often use \"Replace all chat history\" after plan mode. In exec (or other non-plan)\n    // modes, the model can lose the plan file location because plan path injection only\n    // happens in plan mode.\n    //\n    // Exception: the ProposePlanToolCall \"Start Here\" flow already stores the full plan\n    // (and plan path) directly in chat history. In that case, prompting the model to\n    // re-open the plan file is redundant and often results in an extra \"read …KB\" step.\n    if (!chatHasStartHerePlanSummary) {\n      const planFileHint = getPlanFileHint(planFilePath, planResult.exists);\n      if (planFileHint) {\n        effectiveAdditionalInstructions = effectiveAdditionalInstructions\n          ? `${planFileHint}\\n\\n${effectiveAdditionalInstructions}`\n          : planFileHint;\n      }\n    } else {\n      workspaceLog.debug(\n        \"Skipping plan file hint: Start Here already includes the plan in chat history.\"\n      );\n    }\n  }\n\n  if (shouldDisableTaskToolsForDepth) {\n    const nestingInstruction =\n      `Task delegation is disabled in this workspace (taskDepth=${taskDepth}, ` +\n      `maxTaskNestingDepth=${taskSettings.maxTaskNestingDepth}). Do not call task/task_await/task_list/task_terminate.`;\n    effectiveAdditionalInstructions = effectiveAdditionalInstructions\n      ? `${effectiveAdditionalInstructions}\\n\\n${nestingInstruction}`\n      : nestingInstruction;\n  }\n\n  // Read plan content for agent transition (plan-like → exec/orchestrator).\n  // Only read if switching to the built-in exec/orchestrator agent and last assistant was plan-like.\n  let planContentForTransition: string | undefined;\n  const isPlanHandoffAgent = effectiveAgentId === \"exec\" || effectiveAgentId === \"orchestrator\";\n  if (isPlanHandoffAgent && !chatHasStartHerePlanSummary) {\n    const lastAssistantMessage = [...requestPayloadMessages]\n      .reverse()\n      .find((m) => m.role === \"assistant\");\n    const lastAgentId = lastAssistantMessage?.metadata?.agentId;\n    if (lastAgentId && planResult.content.trim()) {\n      let lastAgentIsPlanLike = false;\n      if (lastAgentId === effectiveAgentId) {\n        lastAgentIsPlanLike = agentIsPlanLike;\n      } else {\n        try {\n          const lastDefinition = await readAgentDefinition(\n            runtime,\n            agentDiscoveryPath,\n            lastAgentId\n          );\n          const lastChain = await resolveAgentInheritanceChain({\n            runtime,\n            workspacePath: agentDiscoveryPath,\n            agentId: lastAgentId,\n            agentDefinition: lastDefinition,\n            workspaceId,\n          });\n          lastAgentIsPlanLike = isPlanLikeInResolvedChain(lastChain);\n        } catch (error) {\n          workspaceLog.warn(\"Failed to resolve last agent definition for plan handoff\", {\n            lastAgentId,\n            error: error instanceof Error ? error.message : String(error),\n          });\n        }\n      }\n\n      if (lastAgentIsPlanLike) {\n        planContentForTransition = planResult.content;\n      }\n    }\n  } else if (isPlanHandoffAgent && chatHasStartHerePlanSummary) {\n    workspaceLog.debug(\n      \"Skipping plan content injection for plan handoff transition: Start Here already includes the plan in chat history.\"\n    );\n  }\n\n  return { effectiveAdditionalInstructions, planFilePath, planContentForTransition };\n}\n\n// ---------------------------------------------------------------------------\n// Agent System Prompt & System Message Assembly\n// ---------------------------------------------------------------------------\n\n/** Options for building the system message context. */\nexport interface BuildStreamSystemContextOptions {\n  runtime: Runtime;\n  metadata: WorkspaceMetadata;\n  workspacePath: string;\n  workspaceId: string;\n  /** Agent definition (may have fallen back to exec). Use `.id` for resolution. */\n  agentDefinition: { id: string };\n  agentDiscoveryPath: string;\n  isSubagentWorkspace: boolean;\n  effectiveAdditionalInstructions: string | undefined;\n  modelString: string;\n  cfg: ProjectsConfig;\n  mcpServers: Parameters<typeof buildSystemMessage>[5];\n}\n\n/** Result of system context assembly. */\nexport interface StreamSystemContextResult {\n  /** Resolved agent body (with inheritance + subagent append). */\n  agentSystemPrompt: string;\n  /** Full system message string. */\n  systemMessage: string;\n  /** Token count of the system message. */\n  systemMessageTokens: number;\n  /** Available subagent definitions for tool descriptions (undefined for subagent workspaces). */\n  agentDefinitions: Awaited<ReturnType<typeof discoverAgentDefinitions>> | undefined;\n  /** Available skills for tool descriptions. */\n  availableSkills: Awaited<ReturnType<typeof discoverAgentSkills>> | undefined;\n}\n\n/**\n * Build the agent system prompt, system message, and discover available agents/skills.\n *\n * This handles:\n * 1. Resolving the agent body with inheritance (prompt.append merges with base)\n * 2. Appending subagent.append_prompt for subagent workspaces\n * 3. Discovering available subagent definitions for task tool context\n * 4. Discovering available skills for tool descriptions\n * 5. Constructing the final system message\n * 6. Counting system message tokens\n */\nexport async function buildStreamSystemContext(\n  opts: BuildStreamSystemContextOptions\n): Promise<StreamSystemContextResult> {\n  const {\n    runtime,\n    metadata,\n    workspacePath,\n    workspaceId,\n    agentDefinition,\n    agentDiscoveryPath,\n    isSubagentWorkspace,\n    effectiveAdditionalInstructions,\n    modelString,\n    cfg,\n    mcpServers,\n  } = opts;\n\n  const workspaceLog = log.withFields({ workspaceId, workspaceName: metadata.name });\n\n  // Resolve the body with inheritance (prompt.append merges with base).\n  // Use agentDefinition.id (may have fallen back to exec) instead of effectiveAgentId.\n  const resolvedBody = await resolveAgentBody(runtime, agentDiscoveryPath, agentDefinition.id);\n\n  let subagentAppendPrompt: string | undefined;\n  if (isSubagentWorkspace) {\n    try {\n      const resolvedFrontmatter = await resolveAgentFrontmatter(\n        runtime,\n        agentDiscoveryPath,\n        agentDefinition.id\n      );\n      subagentAppendPrompt = resolvedFrontmatter.subagent?.append_prompt;\n    } catch (error: unknown) {\n      workspaceLog.debug(\"Failed to resolve agent frontmatter for subagent append_prompt\", {\n        agentId: agentDefinition.id,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n\n  const agentSystemPrompt =\n    isSubagentWorkspace && subagentAppendPrompt\n      ? `${resolvedBody}\\n\\n${subagentAppendPrompt}`\n      : resolvedBody;\n\n  // Discover available agent definitions for sub-agent context (only for top-level workspaces).\n  //\n  // NOTE: discoverAgentDefinitions returns disabled agents too, so Settings can surface them.\n  // For tool descriptions (task tool), filter to agents that are effectively enabled.\n  let agentDefinitions: Awaited<ReturnType<typeof discoverAgentDefinitions>> | undefined;\n  if (!isSubagentWorkspace) {\n    agentDefinitions = await discoverAvailableSubagentsForToolContext({\n      runtime,\n      workspacePath: agentDiscoveryPath,\n      cfg,\n    });\n  }\n\n  // Discover available skills for tool description context\n  let availableSkills: Awaited<ReturnType<typeof discoverAgentSkills>> | undefined;\n  try {\n    availableSkills = await discoverAgentSkills(runtime, workspacePath);\n  } catch (error) {\n    workspaceLog.warn(\"Failed to discover agent skills for tool description\", { error });\n  }\n\n  // Build system message from workspace metadata\n  const systemMessage = await buildSystemMessage(\n    metadata,\n    runtime,\n    workspacePath,\n    effectiveAdditionalInstructions,\n    modelString,\n    mcpServers,\n    { agentSystemPrompt }\n  );\n\n  // Count system message tokens for cost tracking\n  const tokenizer = await getTokenizerForModel(modelString);\n  const systemMessageTokens = await tokenizer.countTokens(systemMessage);\n\n  return {\n    agentSystemPrompt,\n    systemMessage,\n    systemMessageTokens,\n    agentDefinitions,\n    availableSkills,\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Subagent Discovery Helper\n// ---------------------------------------------------------------------------\n\n/**\n * Discover agent definitions for tool description context.\n *\n * The task tool lists \"Available sub-agents\" by filtering on\n * AgentDefinitionDescriptor.subagentRunnable.\n *\n * NOTE: discoverAgentDefinitions() sets descriptor.subagentRunnable from the agent's *own*\n * frontmatter only, which means derived agents (e.g. `base: exec`) may incorrectly appear\n * non-runnable if they don't repeat `subagent.runnable: true`.\n *\n * Re-resolve frontmatter with inheritance (base-first) so subagent.runnable is inherited.\n */\nexport async function discoverAvailableSubagentsForToolContext(args: {\n  runtime: Parameters<typeof discoverAgentDefinitions>[0];\n  workspacePath: string;\n  cfg: ProjectsConfig;\n  roots?: AgentDefinitionsRoots;\n}): Promise<Awaited<ReturnType<typeof discoverAgentDefinitions>>> {\n  assert(args, \"discoverAvailableSubagentsForToolContext: args is required\");\n  assert(args.runtime, \"discoverAvailableSubagentsForToolContext: runtime is required\");\n  assert(\n    args.workspacePath && args.workspacePath.length > 0,\n    \"discoverAvailableSubagentsForToolContext: workspacePath is required\"\n  );\n  assert(args.cfg, \"discoverAvailableSubagentsForToolContext: cfg is required\");\n\n  const discovered = await discoverAgentDefinitions(args.runtime, args.workspacePath, {\n    roots: args.roots,\n  });\n\n  const resolved = await Promise.all(\n    discovered.map(async (descriptor) => {\n      try {\n        const resolvedFrontmatter = await resolveAgentFrontmatter(\n          args.runtime,\n          args.workspacePath,\n          descriptor.id,\n          { roots: args.roots }\n        );\n\n        const effectivelyDisabled = isAgentEffectivelyDisabled({\n          cfg: args.cfg,\n          agentId: descriptor.id,\n          resolvedFrontmatter,\n        });\n\n        if (effectivelyDisabled) {\n          return null;\n        }\n\n        return {\n          ...descriptor,\n          // Important: descriptor.subagentRunnable comes from the agent's own frontmatter only.\n          // Re-resolve with inheritance so derived agents inherit runnable: true from their base.\n          subagentRunnable: resolvedFrontmatter.subagent?.runnable ?? false,\n        };\n      } catch {\n        // Best-effort: keep the descriptor if enablement or inheritance can't be resolved.\n        return descriptor;\n      }\n    })\n  );\n\n  return resolved.filter((descriptor): descriptor is NonNullable<typeof descriptor> =>\n    Boolean(descriptor)\n  );\n}\n"]}