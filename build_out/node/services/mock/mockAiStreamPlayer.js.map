{"version":3,"file":"mockAiStreamPlayer.js","sourceRoot":"","sources":["../../../../src/node/services/mock/mockAiStreamPlayer.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from \"@/common/utils/assert\";\nimport type { MuxMessage } from \"@/common/types/message\";\nimport { createMuxMessage } from \"@/common/types/message\";\nimport type { HistoryService } from \"@/node/services/historyService\";\nimport type { Result } from \"@/common/types/result\";\nimport { Ok, Err } from \"@/common/types/result\";\nimport type { SendMessageError } from \"@/common/types/errors\";\nimport type { AIService } from \"@/node/services/aiService\";\nimport { createErrorEvent } from \"@/node/services/utils/sendMessageError\";\nimport { log } from \"@/node/services/log\";\nimport type {\n  MockAssistantEvent,\n  MockStreamErrorEvent,\n  MockStreamStartEvent,\n} from \"./mockAiEventTypes\";\nimport { MockAiRouter } from \"./mockAiRouter\";\nimport { buildMockStreamEventsFromReply } from \"./mockAiStreamAdapter\";\nimport type {\n  StreamStartEvent,\n  StreamDeltaEvent,\n  StreamEndEvent,\n  UsageDeltaEvent,\n} from \"@/common/types/stream\";\nimport type { ToolCallStartEvent, ToolCallEndEvent } from \"@/common/types/stream\";\nimport type { ReasoningDeltaEvent } from \"@/common/types/stream\";\nimport { getTokenizerForModel } from \"@/node/utils/main/tokenizer\";\nimport { KNOWN_MODELS } from \"@/common/constants/knownModels\";\n\nconst MOCK_TOKENIZER_MODEL = KNOWN_MODELS.GPT.id;\nconst TOKENIZE_TIMEOUT_MS = 150;\nlet tokenizerFallbackLogged = false;\nlet tokenizerUnavailableLogged = false;\n\nfunction approximateTokenCount(text: string): number {\n  const normalizedLength = text.trim().length;\n  if (normalizedLength === 0) {\n    return 0;\n  }\n  return Math.max(1, Math.ceil(normalizedLength / 4));\n}\n\nasync function tokenizeWithMockModel(text: string, context: string): Promise<number> {\n  assert(typeof text === \"string\", `Mock stream ${context} expects string input`);\n\n  // Prefer fast approximate token counting in mock mode.\n  // We only use the real tokenizer if it's available and responds quickly.\n  const approximateTokens = approximateTokenCount(text);\n\n  let fallbackUsed = false;\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  let tokenizerErrorMessage: string | undefined;\n\n  const fallbackPromise = new Promise<number>((resolve) => {\n    timeoutId = setTimeout(() => {\n      fallbackUsed = true;\n      resolve(approximateTokens);\n    }, TOKENIZE_TIMEOUT_MS);\n  });\n\n  const actualPromise = (async () => {\n    try {\n      const tokenizer = await getTokenizerForModel(MOCK_TOKENIZER_MODEL);\n      assert(\n        typeof tokenizer.encoding === \"string\" && tokenizer.encoding.length > 0,\n        `Tokenizer for ${MOCK_TOKENIZER_MODEL} must expose a non-empty encoding`\n      );\n      const tokens = await tokenizer.countTokens(text);\n      assert(\n        Number.isFinite(tokens) && tokens >= 0,\n        `Tokenizer for ${MOCK_TOKENIZER_MODEL} returned invalid token count`\n      );\n      return tokens;\n    } catch (error) {\n      tokenizerErrorMessage = error instanceof Error ? error.message : String(error);\n      return approximateTokens;\n    }\n  })();\n\n  const tokens = await Promise.race([actualPromise, fallbackPromise]);\n\n  if (timeoutId !== undefined) {\n    clearTimeout(timeoutId);\n  }\n\n  if (fallbackUsed && !tokenizerFallbackLogged) {\n    tokenizerFallbackLogged = true;\n    void actualPromise.then((resolvedTokens) => {\n      log.debug(\n        `[MockAiStreamPlayer] Tokenizer fallback used for ${context}; emitted ${approximateTokens}, background tokenizer returned ${resolvedTokens}`\n      );\n    });\n  }\n\n  if (tokenizerErrorMessage && !tokenizerUnavailableLogged) {\n    tokenizerUnavailableLogged = true;\n    log.debug(\n      `[MockAiStreamPlayer] Tokenizer unavailable for ${context}; using approximate (${tokenizerErrorMessage})`\n    );\n  }\n\n  assert(\n    Number.isFinite(tokens) && tokens >= 0,\n    `Token counting produced invalid count for ${context}`\n  );\n\n  return tokens;\n}\n\ninterface MockPlayerDeps {\n  aiService: AIService;\n  historyService: HistoryService;\n}\n\ninterface StreamStartGate {\n  promise: Promise<void>;\n  resolve: () => void;\n}\n\ninterface ActiveStream {\n  timers: Array<ReturnType<typeof setTimeout>>;\n  messageId: string;\n  eventQueue: Array<() => Promise<void>>;\n  isProcessing: boolean;\n  cancelled: boolean;\n}\n\nexport class MockAiStreamPlayer {\n  private readonly streamStartGates = new Map<string, StreamStartGate>();\n  private readonly releasedStreamStartGates = new Set<string>();\n  private readonly router = new MockAiRouter();\n  private readonly lastPromptByWorkspace = new Map<string, MuxMessage[]>();\n  private readonly lastModelByWorkspace = new Map<string, string>();\n  private readonly activeStreams = new Map<string, ActiveStream>();\n  private nextMockMessageId = 0;\n\n  constructor(private readonly deps: MockPlayerDeps) {}\n\n  debugGetLastPrompt(workspaceId: string): MuxMessage[] | null {\n    return this.lastPromptByWorkspace.get(workspaceId) ?? null;\n  }\n\n  debugGetLastModel(workspaceId: string): string | null {\n    return this.lastModelByWorkspace.get(workspaceId) ?? null;\n  }\n\n  private recordLastPrompt(workspaceId: string, messages: MuxMessage[]): void {\n    try {\n      const cloned =\n        typeof structuredClone === \"function\"\n          ? structuredClone(messages)\n          : (JSON.parse(JSON.stringify(messages)) as MuxMessage[]);\n      this.lastPromptByWorkspace.set(workspaceId, cloned);\n    } catch {\n      this.lastPromptByWorkspace.set(workspaceId, messages);\n    }\n  }\n\n  isStreaming(workspaceId: string): boolean {\n    return this.activeStreams.has(workspaceId);\n  }\n\n  releaseStreamStartGate(workspaceId: string): void {\n    const gate = this.streamStartGates.get(workspaceId);\n    if (!gate) {\n      this.releasedStreamStartGates.add(workspaceId);\n      return;\n    }\n    gate.resolve();\n  }\n\n  private getStreamStartGate(workspaceId: string): StreamStartGate {\n    const existing = this.streamStartGates.get(workspaceId);\n    if (existing) {\n      return existing;\n    }\n\n    let resolve!: () => void;\n    const promise = new Promise<void>((res) => {\n      resolve = res;\n    });\n    const gate = { promise, resolve };\n    this.streamStartGates.set(workspaceId, gate);\n    return gate;\n  }\n\n  private async waitForStreamStartGate(\n    workspaceId: string,\n    abortSignal?: AbortSignal\n  ): Promise<void> {\n    if (this.releasedStreamStartGates.delete(workspaceId)) {\n      return;\n    }\n\n    const gate = this.getStreamStartGate(workspaceId);\n    let resolved = false;\n\n    await new Promise<void>((resolve) => {\n      const finish = () => {\n        if (resolved) return;\n        resolved = true;\n        this.streamStartGates.delete(workspaceId);\n        if (abortSignal) {\n          abortSignal.removeEventListener(\"abort\", finish);\n        }\n        resolve();\n      };\n\n      void gate.promise.then(finish);\n\n      if (abortSignal) {\n        if (abortSignal.aborted) {\n          finish();\n          return;\n        }\n        abortSignal.addEventListener(\"abort\", finish, { once: true });\n      }\n    });\n  }\n  stop(workspaceId: string): void {\n    const active = this.activeStreams.get(workspaceId);\n    if (!active) return;\n\n    active.cancelled = true;\n\n    // Emit stream-abort event to mirror real streaming behavior\n    this.deps.aiService.emit(\"stream-abort\", {\n      type: \"stream-abort\",\n      workspaceId,\n      messageId: active.messageId,\n      reason: \"user_cancelled\",\n    });\n\n    this.cleanup(workspaceId);\n  }\n\n  async play(\n    messages: MuxMessage[],\n    workspaceId: string,\n    options?: {\n      model?: string;\n      abortSignal?: AbortSignal;\n    }\n  ): Promise<Result<void, SendMessageError>> {\n    const abortSignal = options?.abortSignal;\n    if (abortSignal?.aborted) {\n      return Ok(undefined);\n    }\n\n    const latest = messages[messages.length - 1];\n    if (!latest || latest.role !== \"user\") {\n      return Err({ type: \"unknown\", raw: \"Mock AI expected a user message\" });\n    }\n\n    const latestText = this.extractText(latest);\n\n    this.recordLastPrompt(workspaceId, messages);\n    // Always update last model to avoid stale state between requests\n    if (options?.model) {\n      this.lastModelByWorkspace.set(workspaceId, options.model);\n    } else {\n      this.lastModelByWorkspace.delete(workspaceId);\n    }\n    const reply = this.router.route({\n      messages,\n      latestUserMessage: latest,\n      latestUserText: latestText,\n    });\n\n    const messageId = `msg-mock-${this.nextMockMessageId++}`;\n    if (reply.waitForStreamStart) {\n      await this.waitForStreamStartGate(workspaceId, abortSignal);\n      if (abortSignal?.aborted) {\n        return Ok(undefined);\n      }\n    }\n\n    const events = buildMockStreamEventsFromReply(reply, {\n      messageId,\n      model: options?.model,\n    });\n\n    const streamStart = events.find(\n      (event): event is MockStreamStartEvent => event.kind === \"stream-start\"\n    );\n    if (!streamStart) {\n      return Err({ type: \"unknown\", raw: \"Mock AI turn missing stream-start\" });\n    }\n\n    const streamStartTimeoutMs = 5000;\n    const streamStartPromise = new Promise<void>((resolve) => {\n      let resolved = false;\n      // eslint-disable-next-line prefer-const -- assigned once but after cleanup() is defined\n      let timeoutId: ReturnType<typeof setTimeout>;\n      const onStreamStart = (event: StreamStartEvent) => {\n        if (event.workspaceId !== workspaceId || event.messageId !== messageId) {\n          return;\n        }\n        cleanup();\n      };\n      const cleanup = () => {\n        if (resolved) return;\n        resolved = true;\n        this.deps.aiService.off(\"stream-start\", onStreamStart as never);\n        clearTimeout(timeoutId);\n        resolve();\n      };\n\n      this.deps.aiService.on(\"stream-start\", onStreamStart as never);\n\n      if (abortSignal) {\n        if (abortSignal.aborted) {\n          cleanup();\n          return;\n        }\n        abortSignal.addEventListener(\"abort\", cleanup, { once: true });\n      }\n\n      timeoutId = setTimeout(cleanup, streamStartTimeoutMs);\n    });\n\n    let historySequence = this.computeNextHistorySequence(messages);\n\n    const assistantMessage = createMuxMessage(messageId, \"assistant\", \"\", {\n      timestamp: Date.now(),\n      model: streamStart.model,\n    });\n\n    if (abortSignal?.aborted) {\n      return Ok(undefined);\n    }\n\n    const appendResult = await this.deps.historyService.appendToHistory(\n      workspaceId,\n      assistantMessage\n    );\n    if (!appendResult.success) {\n      return Err({ type: \"unknown\", raw: appendResult.error });\n    }\n\n    if (abortSignal?.aborted) {\n      const deleteResult = await this.deps.historyService.deleteMessage(workspaceId, messageId);\n      if (!deleteResult.success) {\n        log.error(\n          `Failed to delete aborted mock assistant placeholder (${messageId}): ${deleteResult.error}`\n        );\n      }\n      return Ok(undefined);\n    }\n\n    historySequence = assistantMessage.metadata?.historySequence ?? historySequence;\n\n    // Cancel any existing stream before starting a new one\n    if (this.isStreaming(workspaceId)) {\n      this.stop(workspaceId);\n    }\n\n    this.scheduleEvents(workspaceId, events, messageId, historySequence);\n\n    await streamStartPromise;\n    if (abortSignal?.aborted) {\n      return Ok(undefined);\n    }\n\n    return Ok(undefined);\n  }\n\n  async replayStream(_workspaceId: string): Promise<void> {\n    // No-op for mock streams; events are deterministic and do not support mid-stream replay.\n  }\n\n  private scheduleEvents(\n    workspaceId: string,\n    events: MockAssistantEvent[],\n    messageId: string,\n    historySequence: number\n  ): void {\n    const timers: Array<ReturnType<typeof setTimeout>> = [];\n    this.activeStreams.set(workspaceId, {\n      timers,\n      messageId,\n      eventQueue: [],\n      isProcessing: false,\n      cancelled: false,\n    });\n\n    for (const event of events) {\n      const timer = setTimeout(() => {\n        this.enqueueEvent(workspaceId, messageId, () =>\n          this.dispatchEvent(workspaceId, event, messageId, historySequence)\n        );\n      }, event.delay);\n      timers.push(timer);\n    }\n  }\n\n  private enqueueEvent(workspaceId: string, messageId: string, handler: () => Promise<void>): void {\n    const active = this.activeStreams.get(workspaceId);\n    if (!active || active.cancelled || active.messageId !== messageId) return;\n\n    active.eventQueue.push(handler);\n    void this.processQueue(workspaceId);\n  }\n\n  private async processQueue(workspaceId: string): Promise<void> {\n    const active = this.activeStreams.get(workspaceId);\n    if (!active || active.isProcessing) return;\n\n    active.isProcessing = true;\n\n    while (active.eventQueue.length > 0) {\n      const handler = active.eventQueue.shift();\n      if (!handler) break;\n\n      try {\n        await handler();\n      } catch (error) {\n        log.error(`Event handler error for ${workspaceId}:`, error);\n      }\n    }\n\n    active.isProcessing = false;\n  }\n\n  private async dispatchEvent(\n    workspaceId: string,\n    event: MockAssistantEvent,\n    messageId: string,\n    historySequence: number\n  ): Promise<void> {\n    const active = this.activeStreams.get(workspaceId);\n    if (!active || active.cancelled || active.messageId !== messageId) {\n      return;\n    }\n\n    switch (event.kind) {\n      case \"stream-start\": {\n        const payload: StreamStartEvent = {\n          type: \"stream-start\",\n          workspaceId,\n          messageId,\n          model: event.model,\n          historySequence,\n          startTime: Date.now(),\n          ...(event.mode && { mode: event.mode }),\n        };\n        this.deps.aiService.emit(\"stream-start\", payload);\n        break;\n      }\n      case \"reasoning-delta\": {\n        // Mock streams use the same tokenization logic as real streams for consistency\n        const tokens = await tokenizeWithMockModel(event.text, \"reasoning-delta text\");\n        if (active.cancelled) return;\n        const payload: ReasoningDeltaEvent = {\n          type: \"reasoning-delta\",\n          workspaceId,\n          messageId,\n          delta: event.text,\n          tokens,\n          timestamp: Date.now(),\n        };\n        this.deps.aiService.emit(\"reasoning-delta\", payload);\n        break;\n      }\n      case \"tool-start\": {\n        // Mock streams use the same tokenization logic as real streams for consistency\n        const inputText = JSON.stringify(event.args);\n        const tokens = await tokenizeWithMockModel(inputText, \"tool-call args\");\n        if (active.cancelled) return;\n        const payload: ToolCallStartEvent = {\n          type: \"tool-call-start\",\n          workspaceId,\n          messageId,\n          toolCallId: event.toolCallId,\n          toolName: event.toolName,\n          args: event.args,\n          tokens,\n          timestamp: Date.now(),\n        };\n        this.deps.aiService.emit(\"tool-call-start\", payload);\n        break;\n      }\n      case \"usage-delta\": {\n        const payload: UsageDeltaEvent = {\n          type: \"usage-delta\",\n          workspaceId,\n          messageId,\n          usage: event.usage,\n          providerMetadata: event.providerMetadata,\n          cumulativeUsage: event.cumulativeUsage,\n          cumulativeProviderMetadata: event.cumulativeProviderMetadata,\n        };\n        this.deps.aiService.emit(\"usage-delta\", payload);\n        break;\n      }\n      case \"tool-end\": {\n        const payload: ToolCallEndEvent = {\n          type: \"tool-call-end\",\n          workspaceId,\n          messageId,\n          toolCallId: event.toolCallId,\n          toolName: event.toolName,\n          result: event.result,\n          timestamp: Date.now(),\n        };\n        this.deps.aiService.emit(\"tool-call-end\", payload);\n        break;\n      }\n      case \"stream-delta\": {\n        // Mock streams use the same tokenization logic as real streams for consistency\n        let tokens: number;\n        try {\n          tokens = await tokenizeWithMockModel(event.text, \"stream-delta text\");\n        } catch (error) {\n          log.error(\"tokenize failed for stream-delta\", error);\n          throw error;\n        }\n        const payload: StreamDeltaEvent = {\n          type: \"stream-delta\",\n          workspaceId,\n          messageId,\n          delta: event.text,\n          tokens,\n          timestamp: Date.now(),\n        };\n        this.deps.aiService.emit(\"stream-delta\", payload);\n        break;\n      }\n      case \"stream-error\": {\n        const payload: MockStreamErrorEvent = event;\n        this.deps.aiService.emit(\n          \"error\",\n          createErrorEvent(workspaceId, {\n            messageId,\n            error: payload.error,\n            errorType: payload.errorType,\n          })\n        );\n        this.cleanup(workspaceId);\n        break;\n      }\n      case \"stream-end\": {\n        const payload: StreamEndEvent = {\n          type: \"stream-end\",\n          workspaceId,\n          messageId,\n          metadata: {\n            model: event.metadata.model,\n            systemMessageTokens: event.metadata.systemMessageTokens,\n          },\n          parts: event.parts,\n        };\n\n        // Update history with completed message (mirrors real StreamManager behavior).\n        // The target message is always in the current epoch â€” use boundary-aware read.\n        const historyResult =\n          await this.deps.historyService.getHistoryFromLatestBoundary(workspaceId);\n        if (active.cancelled) return;\n        if (historyResult.success) {\n          const existingMessage = historyResult.data.find((msg) => msg.id === messageId);\n          if (existingMessage?.metadata?.historySequence !== undefined) {\n            const completedMessage: MuxMessage = {\n              id: messageId,\n              role: \"assistant\",\n              parts: event.parts,\n              metadata: {\n                ...existingMessage.metadata,\n                model: event.metadata.model,\n                systemMessageTokens: event.metadata.systemMessageTokens,\n              },\n            };\n            const updateResult = await this.deps.historyService.updateHistory(\n              workspaceId,\n              completedMessage\n            );\n\n            if (!updateResult.success) {\n              log.error(`Failed to update history for ${messageId}: ${updateResult.error}`);\n            }\n          }\n        }\n\n        if (active.cancelled) return;\n\n        this.deps.aiService.emit(\"stream-end\", payload);\n        this.cleanup(workspaceId);\n        break;\n      }\n    }\n  }\n\n  private cleanup(workspaceId: string): void {\n    const active = this.activeStreams.get(workspaceId);\n    if (!active) return;\n\n    active.cancelled = true;\n\n    // Clear all pending timers\n    for (const timer of active.timers) {\n      clearTimeout(timer);\n    }\n\n    // Clear event queue to prevent any pending events from processing\n    active.eventQueue = [];\n\n    this.activeStreams.delete(workspaceId);\n  }\n\n  private extractText(message: MuxMessage): string {\n    return message.parts\n      .filter((part) => \"text\" in part)\n      .map((part) => (part as { text: string }).text)\n      .join(\"\");\n  }\n\n  private computeNextHistorySequence(messages: MuxMessage[]): number {\n    let maxSequence = 0;\n    for (const message of messages) {\n      const seq = message.metadata?.historySequence;\n      if (typeof seq === \"number\" && seq > maxSequence) {\n        maxSequence = seq;\n      }\n    }\n    return maxSequence + 1;\n  }\n}\n"]}