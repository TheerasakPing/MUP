{"version":3,"file":"mockAiStreamPlayer.js","sourceRoot":"","sources":["../../../../src/node/services/mock/mockAiStreamPlayer.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from \"@/common/utils/assert\";\r\nimport type { MuxMessage } from \"@/common/types/message\";\r\nimport { createMuxMessage } from \"@/common/types/message\";\r\nimport type { HistoryService } from \"@/node/services/historyService\";\r\nimport type { Result } from \"@/common/types/result\";\r\nimport { Ok, Err } from \"@/common/types/result\";\r\nimport type { SendMessageError } from \"@/common/types/errors\";\r\nimport type { AIService } from \"@/node/services/aiService\";\r\nimport { createErrorEvent } from \"@/node/services/utils/sendMessageError\";\r\nimport { log } from \"@/node/services/log\";\r\nimport type {\r\n  MockAssistantEvent,\r\n  MockStreamErrorEvent,\r\n  MockStreamStartEvent,\r\n} from \"./mockAiEventTypes\";\r\nimport { MockAiRouter } from \"./mockAiRouter\";\r\nimport { buildMockStreamEventsFromReply } from \"./mockAiStreamAdapter\";\r\nimport type {\r\n  StreamStartEvent,\r\n  StreamDeltaEvent,\r\n  StreamEndEvent,\r\n  UsageDeltaEvent,\r\n} from \"@/common/types/stream\";\r\nimport type { ToolCallStartEvent, ToolCallEndEvent } from \"@/common/types/stream\";\r\nimport type { ReasoningDeltaEvent } from \"@/common/types/stream\";\r\nimport { getTokenizerForModel } from \"@/node/utils/main/tokenizer\";\r\nimport { KNOWN_MODELS } from \"@/common/constants/knownModels\";\r\n\r\nconst MOCK_TOKENIZER_MODEL = KNOWN_MODELS.GPT.id;\r\nconst TOKENIZE_TIMEOUT_MS = 150;\r\nlet tokenizerFallbackLogged = false;\r\nlet tokenizerUnavailableLogged = false;\r\n\r\nfunction approximateTokenCount(text: string): number {\r\n  const normalizedLength = text.trim().length;\r\n  if (normalizedLength === 0) {\r\n    return 0;\r\n  }\r\n  return Math.max(1, Math.ceil(normalizedLength / 4));\r\n}\r\n\r\nasync function tokenizeWithMockModel(text: string, context: string): Promise<number> {\r\n  assert(typeof text === \"string\", `Mock stream ${context} expects string input`);\r\n\r\n  // Prefer fast approximate token counting in mock mode.\r\n  // We only use the real tokenizer if it's available and responds quickly.\r\n  const approximateTokens = approximateTokenCount(text);\r\n\r\n  let fallbackUsed = false;\r\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\r\n  let tokenizerErrorMessage: string | undefined;\r\n\r\n  const fallbackPromise = new Promise<number>((resolve) => {\r\n    timeoutId = setTimeout(() => {\r\n      fallbackUsed = true;\r\n      resolve(approximateTokens);\r\n    }, TOKENIZE_TIMEOUT_MS);\r\n  });\r\n\r\n  const actualPromise = (async () => {\r\n    try {\r\n      const tokenizer = await getTokenizerForModel(MOCK_TOKENIZER_MODEL);\r\n      assert(\r\n        typeof tokenizer.encoding === \"string\" && tokenizer.encoding.length > 0,\r\n        `Tokenizer for ${MOCK_TOKENIZER_MODEL} must expose a non-empty encoding`\r\n      );\r\n      const tokens = await tokenizer.countTokens(text);\r\n      assert(\r\n        Number.isFinite(tokens) && tokens >= 0,\r\n        `Tokenizer for ${MOCK_TOKENIZER_MODEL} returned invalid token count`\r\n      );\r\n      return tokens;\r\n    } catch (error) {\r\n      tokenizerErrorMessage = error instanceof Error ? error.message : String(error);\r\n      return approximateTokens;\r\n    }\r\n  })();\r\n\r\n  const tokens = await Promise.race([actualPromise, fallbackPromise]);\r\n\r\n  if (timeoutId !== undefined) {\r\n    clearTimeout(timeoutId);\r\n  }\r\n\r\n  if (fallbackUsed && !tokenizerFallbackLogged) {\r\n    tokenizerFallbackLogged = true;\r\n    void actualPromise.then((resolvedTokens) => {\r\n      log.debug(\r\n        `[MockAiStreamPlayer] Tokenizer fallback used for ${context}; emitted ${approximateTokens}, background tokenizer returned ${resolvedTokens}`\r\n      );\r\n    });\r\n  }\r\n\r\n  if (tokenizerErrorMessage && !tokenizerUnavailableLogged) {\r\n    tokenizerUnavailableLogged = true;\r\n    log.debug(\r\n      `[MockAiStreamPlayer] Tokenizer unavailable for ${context}; using approximate (${tokenizerErrorMessage})`\r\n    );\r\n  }\r\n\r\n  assert(\r\n    Number.isFinite(tokens) && tokens >= 0,\r\n    `Token counting produced invalid count for ${context}`\r\n  );\r\n\r\n  return tokens;\r\n}\r\n\r\ninterface MockPlayerDeps {\r\n  aiService: AIService;\r\n  historyService: HistoryService;\r\n}\r\n\r\ninterface StreamStartGate {\r\n  promise: Promise<void>;\r\n  resolve: () => void;\r\n}\r\n\r\ninterface ActiveStream {\r\n  timers: Array<ReturnType<typeof setTimeout>>;\r\n  messageId: string;\r\n  eventQueue: Array<() => Promise<void>>;\r\n  isProcessing: boolean;\r\n  cancelled: boolean;\r\n}\r\n\r\nexport class MockAiStreamPlayer {\r\n  private readonly streamStartGates = new Map<string, StreamStartGate>();\r\n  private readonly releasedStreamStartGates = new Set<string>();\r\n  private readonly router = new MockAiRouter();\r\n  private readonly lastPromptByWorkspace = new Map<string, MuxMessage[]>();\r\n  private readonly lastModelByWorkspace = new Map<string, string>();\r\n  private readonly activeStreams = new Map<string, ActiveStream>();\r\n  private nextMockMessageId = 0;\r\n\r\n  constructor(private readonly deps: MockPlayerDeps) {}\r\n\r\n  debugGetLastPrompt(workspaceId: string): MuxMessage[] | null {\r\n    return this.lastPromptByWorkspace.get(workspaceId) ?? null;\r\n  }\r\n\r\n  debugGetLastModel(workspaceId: string): string | null {\r\n    return this.lastModelByWorkspace.get(workspaceId) ?? null;\r\n  }\r\n\r\n  private recordLastPrompt(workspaceId: string, messages: MuxMessage[]): void {\r\n    try {\r\n      const cloned =\r\n        typeof structuredClone === \"function\"\r\n          ? structuredClone(messages)\r\n          : (JSON.parse(JSON.stringify(messages)) as MuxMessage[]);\r\n      this.lastPromptByWorkspace.set(workspaceId, cloned);\r\n    } catch {\r\n      this.lastPromptByWorkspace.set(workspaceId, messages);\r\n    }\r\n  }\r\n\r\n  isStreaming(workspaceId: string): boolean {\r\n    return this.activeStreams.has(workspaceId);\r\n  }\r\n\r\n  releaseStreamStartGate(workspaceId: string): void {\r\n    const gate = this.streamStartGates.get(workspaceId);\r\n    if (!gate) {\r\n      this.releasedStreamStartGates.add(workspaceId);\r\n      return;\r\n    }\r\n    gate.resolve();\r\n  }\r\n\r\n  private getStreamStartGate(workspaceId: string): StreamStartGate {\r\n    const existing = this.streamStartGates.get(workspaceId);\r\n    if (existing) {\r\n      return existing;\r\n    }\r\n\r\n    let resolve!: () => void;\r\n    const promise = new Promise<void>((res) => {\r\n      resolve = res;\r\n    });\r\n    const gate = { promise, resolve };\r\n    this.streamStartGates.set(workspaceId, gate);\r\n    return gate;\r\n  }\r\n\r\n  private async waitForStreamStartGate(\r\n    workspaceId: string,\r\n    abortSignal?: AbortSignal\r\n  ): Promise<void> {\r\n    if (this.releasedStreamStartGates.delete(workspaceId)) {\r\n      return;\r\n    }\r\n\r\n    const gate = this.getStreamStartGate(workspaceId);\r\n    let resolved = false;\r\n\r\n    await new Promise<void>((resolve) => {\r\n      const finish = () => {\r\n        if (resolved) return;\r\n        resolved = true;\r\n        this.streamStartGates.delete(workspaceId);\r\n        if (abortSignal) {\r\n          abortSignal.removeEventListener(\"abort\", finish);\r\n        }\r\n        resolve();\r\n      };\r\n\r\n      void gate.promise.then(finish);\r\n\r\n      if (abortSignal) {\r\n        if (abortSignal.aborted) {\r\n          finish();\r\n          return;\r\n        }\r\n        abortSignal.addEventListener(\"abort\", finish, { once: true });\r\n      }\r\n    });\r\n  }\r\n  stop(workspaceId: string): void {\r\n    const active = this.activeStreams.get(workspaceId);\r\n    if (!active) return;\r\n\r\n    active.cancelled = true;\r\n\r\n    // Emit stream-abort event to mirror real streaming behavior\r\n    this.deps.aiService.emit(\"stream-abort\", {\r\n      type: \"stream-abort\",\r\n      workspaceId,\r\n      messageId: active.messageId,\r\n      reason: \"user_cancelled\",\r\n    });\r\n\r\n    this.cleanup(workspaceId);\r\n  }\r\n\r\n  async play(\r\n    messages: MuxMessage[],\r\n    workspaceId: string,\r\n    options?: {\r\n      model?: string;\r\n      abortSignal?: AbortSignal;\r\n    }\r\n  ): Promise<Result<void, SendMessageError>> {\r\n    const abortSignal = options?.abortSignal;\r\n    if (abortSignal?.aborted) {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    const latest = messages[messages.length - 1];\r\n    if (!latest || latest.role !== \"user\") {\r\n      return Err({ type: \"unknown\", raw: \"Mock AI expected a user message\" });\r\n    }\r\n\r\n    const latestText = this.extractText(latest);\r\n\r\n    this.recordLastPrompt(workspaceId, messages);\r\n    // Always update last model to avoid stale state between requests\r\n    if (options?.model) {\r\n      this.lastModelByWorkspace.set(workspaceId, options.model);\r\n    } else {\r\n      this.lastModelByWorkspace.delete(workspaceId);\r\n    }\r\n    const reply = this.router.route({\r\n      messages,\r\n      latestUserMessage: latest,\r\n      latestUserText: latestText,\r\n    });\r\n\r\n    const messageId = `msg-mock-${this.nextMockMessageId++}`;\r\n    if (reply.waitForStreamStart) {\r\n      await this.waitForStreamStartGate(workspaceId, abortSignal);\r\n      if (abortSignal?.aborted) {\r\n        return Ok(undefined);\r\n      }\r\n    }\r\n\r\n    const events = buildMockStreamEventsFromReply(reply, {\r\n      messageId,\r\n      model: options?.model,\r\n    });\r\n\r\n    const streamStart = events.find(\r\n      (event): event is MockStreamStartEvent => event.kind === \"stream-start\"\r\n    );\r\n    if (!streamStart) {\r\n      return Err({ type: \"unknown\", raw: \"Mock AI turn missing stream-start\" });\r\n    }\r\n\r\n    const streamStartTimeoutMs = 5000;\r\n    const streamStartPromise = new Promise<void>((resolve) => {\r\n      let resolved = false;\r\n      // eslint-disable-next-line prefer-const -- assigned once but after cleanup() is defined\r\n      let timeoutId: ReturnType<typeof setTimeout>;\r\n      const onStreamStart = (event: StreamStartEvent) => {\r\n        if (event.workspaceId !== workspaceId || event.messageId !== messageId) {\r\n          return;\r\n        }\r\n        cleanup();\r\n      };\r\n      const cleanup = () => {\r\n        if (resolved) return;\r\n        resolved = true;\r\n        this.deps.aiService.off(\"stream-start\", onStreamStart as never);\r\n        clearTimeout(timeoutId);\r\n        resolve();\r\n      };\r\n\r\n      this.deps.aiService.on(\"stream-start\", onStreamStart as never);\r\n\r\n      if (abortSignal) {\r\n        if (abortSignal.aborted) {\r\n          cleanup();\r\n          return;\r\n        }\r\n        abortSignal.addEventListener(\"abort\", cleanup, { once: true });\r\n      }\r\n\r\n      timeoutId = setTimeout(cleanup, streamStartTimeoutMs);\r\n    });\r\n\r\n    let historySequence = this.computeNextHistorySequence(messages);\r\n\r\n    const assistantMessage = createMuxMessage(messageId, \"assistant\", \"\", {\r\n      timestamp: Date.now(),\r\n      model: streamStart.model,\r\n    });\r\n\r\n    if (abortSignal?.aborted) {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    const appendResult = await this.deps.historyService.appendToHistory(\r\n      workspaceId,\r\n      assistantMessage\r\n    );\r\n    if (!appendResult.success) {\r\n      return Err({ type: \"unknown\", raw: appendResult.error });\r\n    }\r\n\r\n    if (abortSignal?.aborted) {\r\n      const deleteResult = await this.deps.historyService.deleteMessage(workspaceId, messageId);\r\n      if (!deleteResult.success) {\r\n        log.error(\r\n          `Failed to delete aborted mock assistant placeholder (${messageId}): ${deleteResult.error}`\r\n        );\r\n      }\r\n      return Ok(undefined);\r\n    }\r\n\r\n    historySequence = assistantMessage.metadata?.historySequence ?? historySequence;\r\n\r\n    // Cancel any existing stream before starting a new one\r\n    if (this.isStreaming(workspaceId)) {\r\n      this.stop(workspaceId);\r\n    }\r\n\r\n    this.scheduleEvents(workspaceId, events, messageId, historySequence);\r\n\r\n    await streamStartPromise;\r\n    if (abortSignal?.aborted) {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    return Ok(undefined);\r\n  }\r\n\r\n  async replayStream(_workspaceId: string): Promise<void> {\r\n    // No-op for mock streams; events are deterministic and do not support mid-stream replay.\r\n  }\r\n\r\n  private scheduleEvents(\r\n    workspaceId: string,\r\n    events: MockAssistantEvent[],\r\n    messageId: string,\r\n    historySequence: number\r\n  ): void {\r\n    const timers: Array<ReturnType<typeof setTimeout>> = [];\r\n    this.activeStreams.set(workspaceId, {\r\n      timers,\r\n      messageId,\r\n      eventQueue: [],\r\n      isProcessing: false,\r\n      cancelled: false,\r\n    });\r\n\r\n    for (const event of events) {\r\n      const timer = setTimeout(() => {\r\n        this.enqueueEvent(workspaceId, messageId, () =>\r\n          this.dispatchEvent(workspaceId, event, messageId, historySequence)\r\n        );\r\n      }, event.delay);\r\n      timers.push(timer);\r\n    }\r\n  }\r\n\r\n  private enqueueEvent(workspaceId: string, messageId: string, handler: () => Promise<void>): void {\r\n    const active = this.activeStreams.get(workspaceId);\r\n    if (!active || active.cancelled || active.messageId !== messageId) return;\r\n\r\n    active.eventQueue.push(handler);\r\n    void this.processQueue(workspaceId);\r\n  }\r\n\r\n  private async processQueue(workspaceId: string): Promise<void> {\r\n    const active = this.activeStreams.get(workspaceId);\r\n    if (!active || active.isProcessing) return;\r\n\r\n    active.isProcessing = true;\r\n\r\n    while (active.eventQueue.length > 0) {\r\n      const handler = active.eventQueue.shift();\r\n      if (!handler) break;\r\n\r\n      try {\r\n        await handler();\r\n      } catch (error) {\r\n        log.error(`Event handler error for ${workspaceId}:`, error);\r\n      }\r\n    }\r\n\r\n    active.isProcessing = false;\r\n  }\r\n\r\n  private async dispatchEvent(\r\n    workspaceId: string,\r\n    event: MockAssistantEvent,\r\n    messageId: string,\r\n    historySequence: number\r\n  ): Promise<void> {\r\n    const active = this.activeStreams.get(workspaceId);\r\n    if (!active || active.cancelled || active.messageId !== messageId) {\r\n      return;\r\n    }\r\n\r\n    switch (event.kind) {\r\n      case \"stream-start\": {\r\n        const payload: StreamStartEvent = {\r\n          type: \"stream-start\",\r\n          workspaceId,\r\n          messageId,\r\n          model: event.model,\r\n          historySequence,\r\n          startTime: Date.now(),\r\n          ...(event.mode && { mode: event.mode }),\r\n        };\r\n        this.deps.aiService.emit(\"stream-start\", payload);\r\n        break;\r\n      }\r\n      case \"reasoning-delta\": {\r\n        // Mock streams use the same tokenization logic as real streams for consistency\r\n        const tokens = await tokenizeWithMockModel(event.text, \"reasoning-delta text\");\r\n        if (active.cancelled) return;\r\n        const payload: ReasoningDeltaEvent = {\r\n          type: \"reasoning-delta\",\r\n          workspaceId,\r\n          messageId,\r\n          delta: event.text,\r\n          tokens,\r\n          timestamp: Date.now(),\r\n        };\r\n        this.deps.aiService.emit(\"reasoning-delta\", payload);\r\n        break;\r\n      }\r\n      case \"tool-start\": {\r\n        // Mock streams use the same tokenization logic as real streams for consistency\r\n        const inputText = JSON.stringify(event.args);\r\n        const tokens = await tokenizeWithMockModel(inputText, \"tool-call args\");\r\n        if (active.cancelled) return;\r\n        const payload: ToolCallStartEvent = {\r\n          type: \"tool-call-start\",\r\n          workspaceId,\r\n          messageId,\r\n          toolCallId: event.toolCallId,\r\n          toolName: event.toolName,\r\n          args: event.args,\r\n          tokens,\r\n          timestamp: Date.now(),\r\n        };\r\n        this.deps.aiService.emit(\"tool-call-start\", payload);\r\n        break;\r\n      }\r\n      case \"usage-delta\": {\r\n        const payload: UsageDeltaEvent = {\r\n          type: \"usage-delta\",\r\n          workspaceId,\r\n          messageId,\r\n          usage: event.usage,\r\n          providerMetadata: event.providerMetadata,\r\n          cumulativeUsage: event.cumulativeUsage,\r\n          cumulativeProviderMetadata: event.cumulativeProviderMetadata,\r\n        };\r\n        this.deps.aiService.emit(\"usage-delta\", payload);\r\n        break;\r\n      }\r\n      case \"tool-end\": {\r\n        const payload: ToolCallEndEvent = {\r\n          type: \"tool-call-end\",\r\n          workspaceId,\r\n          messageId,\r\n          toolCallId: event.toolCallId,\r\n          toolName: event.toolName,\r\n          result: event.result,\r\n          timestamp: Date.now(),\r\n        };\r\n        this.deps.aiService.emit(\"tool-call-end\", payload);\r\n        break;\r\n      }\r\n      case \"stream-delta\": {\r\n        // Mock streams use the same tokenization logic as real streams for consistency\r\n        let tokens: number;\r\n        try {\r\n          tokens = await tokenizeWithMockModel(event.text, \"stream-delta text\");\r\n        } catch (error) {\r\n          log.error(\"tokenize failed for stream-delta\", error);\r\n          throw error;\r\n        }\r\n        const payload: StreamDeltaEvent = {\r\n          type: \"stream-delta\",\r\n          workspaceId,\r\n          messageId,\r\n          delta: event.text,\r\n          tokens,\r\n          timestamp: Date.now(),\r\n        };\r\n        this.deps.aiService.emit(\"stream-delta\", payload);\r\n        break;\r\n      }\r\n      case \"stream-error\": {\r\n        const payload: MockStreamErrorEvent = event;\r\n        this.deps.aiService.emit(\r\n          \"error\",\r\n          createErrorEvent(workspaceId, {\r\n            messageId,\r\n            error: payload.error,\r\n            errorType: payload.errorType,\r\n          })\r\n        );\r\n        this.cleanup(workspaceId);\r\n        break;\r\n      }\r\n      case \"stream-end\": {\r\n        const payload: StreamEndEvent = {\r\n          type: \"stream-end\",\r\n          workspaceId,\r\n          messageId,\r\n          metadata: {\r\n            model: event.metadata.model,\r\n            systemMessageTokens: event.metadata.systemMessageTokens,\r\n          },\r\n          parts: event.parts,\r\n        };\r\n\r\n        // Update history with completed message (mirrors real StreamManager behavior).\r\n        // The target message is always in the current epoch â€” use boundary-aware read.\r\n        const historyResult =\r\n          await this.deps.historyService.getHistoryFromLatestBoundary(workspaceId);\r\n        if (active.cancelled) return;\r\n        if (historyResult.success) {\r\n          const existingMessage = historyResult.data.find((msg) => msg.id === messageId);\r\n          if (existingMessage?.metadata?.historySequence !== undefined) {\r\n            const completedMessage: MuxMessage = {\r\n              id: messageId,\r\n              role: \"assistant\",\r\n              parts: event.parts,\r\n              metadata: {\r\n                ...existingMessage.metadata,\r\n                model: event.metadata.model,\r\n                systemMessageTokens: event.metadata.systemMessageTokens,\r\n              },\r\n            };\r\n            const updateResult = await this.deps.historyService.updateHistory(\r\n              workspaceId,\r\n              completedMessage\r\n            );\r\n\r\n            if (!updateResult.success) {\r\n              log.error(`Failed to update history for ${messageId}: ${updateResult.error}`);\r\n            }\r\n          }\r\n        }\r\n\r\n        if (active.cancelled) return;\r\n\r\n        this.deps.aiService.emit(\"stream-end\", payload);\r\n        this.cleanup(workspaceId);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  private cleanup(workspaceId: string): void {\r\n    const active = this.activeStreams.get(workspaceId);\r\n    if (!active) return;\r\n\r\n    active.cancelled = true;\r\n\r\n    // Clear all pending timers\r\n    for (const timer of active.timers) {\r\n      clearTimeout(timer);\r\n    }\r\n\r\n    // Clear event queue to prevent any pending events from processing\r\n    active.eventQueue = [];\r\n\r\n    this.activeStreams.delete(workspaceId);\r\n  }\r\n\r\n  private extractText(message: MuxMessage): string {\r\n    return message.parts\r\n      .filter((part) => \"text\" in part)\r\n      .map((part) => (part as { text: string }).text)\r\n      .join(\"\");\r\n  }\r\n\r\n  private computeNextHistorySequence(messages: MuxMessage[]): number {\r\n    let maxSequence = 0;\r\n    for (const message of messages) {\r\n      const seq = message.metadata?.historySequence;\r\n      if (typeof seq === \"number\" && seq > maxSequence) {\r\n        maxSequence = seq;\r\n      }\r\n    }\r\n    return maxSequence + 1;\r\n  }\r\n}\r\n"]}