{"version":3,"file":"mockAiStreamPlayer.test.js","sourceRoot":"","sources":["../../../../src/node/services/mock/mockAiStreamPlayer.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, expect, test, beforeEach, afterEach, spyOn } from \"bun:test\";\nimport { EventEmitter } from \"events\";\nimport { MockAiStreamPlayer } from \"./mockAiStreamPlayer\";\nimport { createMuxMessage, type MuxMessage } from \"@/common/types/message\";\nimport { Ok } from \"@/common/types/result\";\nimport type { HistoryService } from \"@/node/services/historyService\";\nimport type { AIService } from \"@/node/services/aiService\";\nimport { createTestHistoryService } from \"../testHistoryService\";\n\nfunction readWorkspaceId(payload: unknown): string | undefined {\n  if (!payload || typeof payload !== \"object\") return undefined;\n  if (!(\"workspaceId\" in payload)) return undefined;\n\n  const workspaceId = (payload as { workspaceId?: unknown }).workspaceId;\n  return typeof workspaceId === \"string\" ? workspaceId : undefined;\n}\n\ndescribe(\"MockAiStreamPlayer\", () => {\n  let historyService: HistoryService;\n  let cleanup: () => Promise<void>;\n\n  beforeEach(async () => {\n    const testHistory = await createTestHistoryService();\n    historyService = testHistory.historyService;\n    cleanup = testHistory.cleanup;\n  });\n\n  afterEach(async () => {\n    await cleanup();\n  });\n\n  test(\"appends assistant placeholder even when router turn ends with stream error\", async () => {\n    const aiServiceStub = new EventEmitter();\n\n    const player = new MockAiStreamPlayer({\n      historyService,\n      aiService: aiServiceStub as unknown as AIService,\n    });\n\n    const workspaceId = \"workspace-1\";\n\n    const firstTurnUser = createMuxMessage(\n      \"user-1\",\n      \"user\",\n      \"[mock:list-languages] List 3 programming languages\",\n      {\n        timestamp: Date.now(),\n      }\n    );\n\n    const firstResult = await player.play([firstTurnUser], workspaceId);\n    expect(firstResult.success).toBe(true);\n    player.stop(workspaceId);\n\n    // Read back what was appended during the first turn\n    const historyResult = await historyService.getLastMessages(workspaceId, 100);\n    const historyBeforeSecondTurn = historyResult.success ? historyResult.data : [];\n\n    const secondTurnUser = createMuxMessage(\n      \"user-2\",\n      \"user\",\n      \"[mock:error:api] Trigger API error\",\n      {\n        timestamp: Date.now(),\n      }\n    );\n\n    const secondResult = await player.play(\n      [firstTurnUser, ...historyBeforeSecondTurn, secondTurnUser],\n      workspaceId\n    );\n    expect(secondResult.success).toBe(true);\n\n    // Read back all messages and check the assistant placeholders\n    const allResult = await historyService.getLastMessages(workspaceId, 100);\n    const allMessages = allResult.success ? allResult.data : [];\n    const assistantMessages = allMessages.filter((m) => m.role === \"assistant\");\n\n    expect(assistantMessages).toHaveLength(2);\n    const [firstAppend, secondAppend] = assistantMessages;\n\n    expect(firstAppend.id).not.toBe(secondAppend.id);\n\n    const firstSeq = firstAppend.metadata?.historySequence ?? -1;\n    const secondSeq = secondAppend.metadata?.historySequence ?? -1;\n    expect(secondSeq).toBe(firstSeq + 1);\n\n    player.stop(workspaceId);\n  });\n\n  test(\"removes assistant placeholder when aborted before stream scheduling\", async () => {\n    type AppendResult = Awaited<ReturnType<HistoryService[\"appendToHistory\"]>>;\n\n    // Control when appendToHistory resolves to test the abort race condition.\n    // The real service writes to disk immediately; we gate the returned promise\n    // so the player sees a pending append while we trigger abort.\n    let appendResolve!: (result: AppendResult) => void;\n    const appendGate = new Promise<AppendResult>((resolve) => {\n      appendResolve = resolve;\n    });\n\n    let appendedMessageResolve!: (msg: MuxMessage) => void;\n    const appendedMessage = new Promise<MuxMessage>((resolve) => {\n      appendedMessageResolve = resolve;\n    });\n\n    const originalAppend = historyService.appendToHistory.bind(historyService);\n    spyOn(historyService, \"appendToHistory\").mockImplementation(\n      async (wId: string, message: MuxMessage) => {\n        // Write to disk so deleteMessage can find it later\n        await originalAppend(wId, message);\n        appendedMessageResolve(message);\n        // Delay returning to the caller until the gate opens\n        return appendGate;\n      }\n    );\n\n    const aiServiceStub = new EventEmitter();\n\n    const player = new MockAiStreamPlayer({\n      historyService,\n      aiService: aiServiceStub as unknown as AIService,\n    });\n\n    const workspaceId = \"workspace-abort-startup\";\n\n    const userMessage = createMuxMessage(\n      \"user-1\",\n      \"user\",\n      \"[mock:list-languages] List 3 programming languages\",\n      {\n        timestamp: Date.now(),\n      }\n    );\n\n    const abortController = new AbortController();\n    const playPromise = player.play([userMessage], workspaceId, {\n      abortSignal: abortController.signal,\n    });\n\n    const assistantMsg = await appendedMessage;\n\n    appendResolve(Ok(undefined));\n    abortController.abort();\n\n    const result = await playPromise;\n    expect(result.success).toBe(true);\n\n    // Verify the placeholder was deleted from history\n    const storedResult = await historyService.getLastMessages(workspaceId, 100);\n    const storedMessages = storedResult.success ? storedResult.data : [];\n    expect(storedMessages.some((msg) => msg.id === assistantMsg.id)).toBe(false);\n  });\n\n  test(\"stop prevents queued stream events from emitting\", async () => {\n    const aiServiceStub = new EventEmitter();\n\n    const player = new MockAiStreamPlayer({\n      historyService,\n      aiService: aiServiceStub as unknown as AIService,\n    });\n\n    const workspaceId = \"workspace-2\";\n\n    let deltaCount = 0;\n    let abortCount = 0;\n    let stopped = false;\n\n    aiServiceStub.on(\"stream-abort\", (payload: unknown) => {\n      if (readWorkspaceId(payload) === workspaceId) {\n        abortCount += 1;\n      }\n    });\n\n    const firstDelta = new Promise<void>((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error(\"Timed out waiting for stream-delta\"));\n      }, 1000);\n\n      aiServiceStub.on(\"stream-delta\", (payload: unknown) => {\n        if (readWorkspaceId(payload) !== workspaceId) return;\n\n        deltaCount += 1;\n\n        if (!stopped) {\n          stopped = true;\n          clearTimeout(timeout);\n          player.stop(workspaceId);\n          resolve();\n        }\n      });\n    });\n\n    const forceTurnUser = createMuxMessage(\"user-force\", \"user\", \"[force] keep streaming\", {\n      timestamp: Date.now(),\n    });\n\n    const playResult = await player.play([forceTurnUser], workspaceId);\n    expect(playResult.success).toBe(true);\n\n    await firstDelta;\n\n    const deltasAtStop = deltaCount;\n\n    await new Promise((resolve) => setTimeout(resolve, 150));\n\n    expect(deltaCount).toBe(deltasAtStop);\n    expect(abortCount).toBe(1);\n  });\n});\n"]}