{"version":3,"file":"mockAiStreamAdapter.js","sourceRoot":"","sources":["../../../../src/node/services/mock/mockAiStreamAdapter.ts"],"names":[],"mappings":"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","sourcesContent":["import type { CompletedMessagePart } from \"@/common/types/stream\";\nimport type { MockAssistantEvent } from \"./mockAiEventTypes\";\nimport type { MockAiRouterReply } from \"./mockAiRouter\";\nimport { KNOWN_MODELS } from \"@/common/constants/knownModels\";\n\nconst DEFAULT_STREAM_CHUNK_CHARS = 24;\nconst DEFAULT_STREAM_CHUNK_DELAY_MS = 25;\n\nfunction chunkText(text: string, chunkChars: number): string[] {\n  if (text.length === 0) {\n    return [];\n  }\n\n  // Stream in word-ish chunks so tests can assert on meaningful substrings.\n  // (Fixed-width chunking can split tokens like \"README.md\" across boundaries.)\n  const chunks: string[] = [];\n\n  let cursor = 0;\n  while (cursor < text.length) {\n    const remaining = text.length - cursor;\n    if (remaining <= chunkChars) {\n      chunks.push(text.slice(cursor));\n      break;\n    }\n\n    const window = text.slice(cursor, cursor + chunkChars);\n    const lastNewline = window.lastIndexOf(\"\\n\");\n    const lastSpace = window.lastIndexOf(\" \");\n    const splitAt = Math.max(lastNewline, lastSpace);\n\n    if (splitAt <= 0) {\n      chunks.push(window);\n      cursor += chunkChars;\n      continue;\n    }\n\n    chunks.push(text.slice(cursor, cursor + splitAt + 1));\n    cursor += splitAt + 1;\n  }\n\n  return chunks;\n}\n\nexport interface BuildMockStreamEventsOptions {\n  messageId: string;\n  model?: string;\n  mode?: \"plan\" | \"exec\" | \"compact\";\n\n  /** Chunk size for stream-delta events. */\n  chunkChars?: number;\n  /** Delay between chunk emissions. */\n  chunkDelayMs?: number;\n}\n\n/**\n * Convert a high-level mock reply into low-level stream events.\n *\n * IMPORTANT: This is the ONLY place the mock router reply is translated into\n * stream semantics (stream-start/delta/end, usage-delta, etc).\n */\nexport function buildMockStreamEventsFromReply(\n  reply: MockAiRouterReply,\n  options: BuildMockStreamEventsOptions\n): MockAssistantEvent[] {\n  const model = options.model ?? KNOWN_MODELS.OPUS.id;\n  const mode = options.mode ?? reply.mode;\n\n  const chunkChars = options.chunkChars ?? DEFAULT_STREAM_CHUNK_CHARS;\n  const chunkDelayMs = options.chunkDelayMs ?? DEFAULT_STREAM_CHUNK_DELAY_MS;\n\n  const events: MockAssistantEvent[] = [];\n\n  events.push({\n    kind: \"stream-start\",\n    delay: 0,\n    messageId: options.messageId,\n    model,\n    ...(mode && { mode }),\n  });\n\n  let nextDelay = 5;\n\n  if (reply.usage) {\n    events.push({\n      kind: \"usage-delta\",\n      delay: nextDelay,\n      usage: reply.usage,\n      cumulativeUsage: reply.usage,\n    });\n    nextDelay += 5;\n  }\n\n  if (reply.reasoningDeltas && reply.reasoningDeltas.length > 0) {\n    for (const delta of reply.reasoningDeltas) {\n      events.push({\n        kind: \"reasoning-delta\",\n        delay: nextDelay,\n        text: delta,\n      });\n      nextDelay += 5;\n    }\n  }\n\n  if (reply.toolCalls && reply.toolCalls.length > 0) {\n    for (const toolCall of reply.toolCalls) {\n      events.push({\n        kind: \"tool-start\",\n        delay: nextDelay,\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        args: toolCall.args,\n      });\n      nextDelay += 5;\n\n      events.push({\n        kind: \"tool-end\",\n        delay: nextDelay,\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        result: toolCall.result,\n      });\n      nextDelay += 5;\n    }\n  }\n\n  const chunkBaseDelay = nextDelay + 5;\n\n  const chunks = chunkText(reply.assistantText, chunkChars);\n  for (const [index, chunk] of chunks.entries()) {\n    events.push({\n      kind: \"stream-delta\",\n      delay: chunkBaseDelay + index * chunkDelayMs,\n      text: chunk,\n    });\n  }\n\n  const terminalDelay = chunkBaseDelay + chunks.length * chunkDelayMs;\n\n  if (reply.error) {\n    events.push({\n      kind: \"stream-error\",\n      delay: terminalDelay,\n      error: reply.error.message,\n      errorType: reply.error.type,\n    });\n\n    return events;\n  }\n\n  const parts: CompletedMessagePart[] = [{ type: \"text\", text: reply.assistantText }];\n\n  events.push({\n    kind: \"stream-end\",\n    delay: terminalDelay,\n    metadata: {\n      model,\n      systemMessageTokens: 0,\n    },\n    parts,\n  });\n\n  return events;\n}\n"]}