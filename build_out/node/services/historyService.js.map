{"version":3,"file":"historyService.js","sourceRoot":"","sources":["../../../src/node/services/historyService.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAY,EAAE,wCAAoB;AAClC,MAAY,IAAI,iCAAa;AAC7B,0EAAgD;AAChD,8DAAiC;AAEjC,kDAAgD;AAChD,oDAIgC;AAEhC,oFAAiF;AACjF,+BAA4B;AAC5B,2DAAmE;AACnE,gEAA8D;AAC9D,6FAA0F;AAC1F,yDAA0E;AAC1E,mFAA+F;AAE/F,SAAS,iBAAiB,CAAC,KAAc,EAAmB;IAC1D,OAAO,CACL,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,KAAK,GAAG,CAAC,CAC5F,CAAC;AAAA,CACH;AAED,SAAS,oBAAoB,CAAC,KAAc,EAAmB;IAC7D,OAAO,CACL,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,CAAC,CAC7F,CAAC;AAAA,CACH;AAED,SAAS,yBAAyB,CAAC,KAAc,EAAmC;IAClF,OAAO,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,MAAM,IAAI,KAAK,KAAK,MAAM,CAAC;AAAA,CAC/D;AAED,SAAS,4BAA4B,CAAC,QAAiC,EAAW;IAChF,IAAI,QAAQ,EAAE,kBAAkB,KAAK,IAAI,EAAE,CAAC;QAC1C,OAAO,KAAK,CAAC;IACf,CAAC;IAED,wEAAwE;IACxE,IAAI,CAAC,yBAAyB,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE,CAAC;QACnD,OAAO,KAAK,CAAC;IACf,CAAC;IAED,OAAO,iBAAiB,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAC;AAAA,CACpD;AAED,SAAS,+BAA+B,CACtC,WAAmB,EACnB,eAA2B,EAC3B,eAA2B,EACE;IAC7B,MAAM,gBAAgB,GAAG,eAAe,CAAC,QAAQ,CAAC;IAClD,IAAI,gBAAgB,EAAE,kBAAkB,KAAK,IAAI,EAAE,CAAC;QAClD,OAAO,IAAI,CAAC;IACd,CAAC;IAED,IAAI,eAAe,CAAC,IAAI,KAAK,WAAW,EAAE,CAAC;QACzC,8EAA8E;QAC9E,SAAG,CAAC,IAAI,CAAC,wEAAwE,EAAE;YACjF,WAAW;YACX,SAAS,EAAE,eAAe,CAAC,EAAE;YAC7B,MAAM,EAAE,iDAAiD;SAC1D,CAAC,CAAC;QACH,OAAO,IAAI,CAAC;IACd,CAAC;IAED,IAAI,eAAe,CAAC,IAAI,KAAK,WAAW,EAAE,CAAC;QACzC,OAAO,IAAI,CAAC;IACd,CAAC;IAED,IAAI,CAAC,4BAA4B,CAAC,gBAAgB,CAAC,EAAE,CAAC;QACpD,gFAAgF;QAChF,SAAG,CAAC,IAAI,CAAC,wEAAwE,EAAE;YACjF,WAAW;YACX,SAAS,EAAE,eAAe,CAAC,EAAE;YAC7B,MAAM,EAAE,qEAAqE;SAC9E,CAAC,CAAC;QACH,OAAO,IAAI,CAAC;IACd,CAAC;IAED,IAAI,4BAA4B,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE,CAAC;QAC3D,OAAO,IAAI,CAAC;IACd,CAAC;IAED,MAAM,SAAS,GAAyB;QACtC,SAAS,EAAE,gBAAgB,CAAC,SAAS;QACrC,kBAAkB,EAAE,IAAI;QACxB,eAAe,EAAE,gBAAgB,CAAC,eAAe;KAClD,CAAC;IAEF,IACE,IAAA,qCAA2B,EAAC,gBAAgB,CAAC,WAAW,CAAC;QACzD,CAAC,IAAA,qCAA2B,EAAC,eAAe,CAAC,QAAQ,EAAE,WAAW,CAAC,EACnE,CAAC;QACD,SAAS,CAAC,WAAW,GAAG,gBAAgB,CAAC,WAAW,CAAC;IACvD,CAAC;IAED,OAAO,SAAS,CAAC;AAAA,CAClB;AACD;;;;;;;GAOG;AACH;IACmB,SAAS,GAAG,YAAY,CAAC;IAC1C,qDAAqD;IAC7C,gBAAgB,GAAG,IAAI,GAAG,EAAkB,CAAC;IACrD,gEAAgE;IAChE,kGAAgG;IAC/E,SAAS,GAAG,uCAAkB,CAAC;IAC/B,MAAM,CAAgC;IAEvD,YAAY,MAAqC,EAAE;QACjD,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IAAA,CACtB;IAEO,kBAAkB,CAAC,WAAmB,EAAU;QACtD,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,WAAW,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;IAAA,CAC1E;IAED,6KAA+E;IAC/E,iFAAiF;IACjF,gFAAgF;IAChF,+EAA+E;IAC/E,sCAAsC;IAEtC,2GAA2G;IACnG,MAAM,CAAU,uBAAuB,GAAG,GAAG,GAAG,IAAI,CAAC;IAC7D,0DAA0D;IAClD,MAAM,CAAU,eAAe,GAAG,2BAA2B,CAAC;IAEtE;;;;;;;;;;OAUG;IACK,KAAK,CAAC,0BAA0B,CAAC,WAAmB,EAAE,IAAI,GAAG,CAAC,EAA0B;QAC9F,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;QAEtD,IAAI,QAAgB,CAAC;QACrB,IAAI,CAAC;YACH,MAAM,IAAI,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACrC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,CAAC;QAAC,MAAM,CAAC;YACP,OAAO,IAAI,CAAC;QACd,CAAC;QACD,IAAI,QAAQ,KAAK,CAAC;YAAE,OAAO,IAAI,CAAC;QAEhC,MAAM,EAAE,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;QACxC,IAAI,CAAC;YACH,IAAI,OAAO,GAAG,QAAQ,CAAC;YACvB,8EAA8E;YAC9E,4EAA4E;YAC5E,+DAA+D;YAC/D,IAAI,cAAc,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACrC,IAAI,OAAO,GAAG,CAAC,CAAC;YAEhB,OAAO,OAAO,GAAG,CAAC,EAAE,CAAC;gBACnB,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,OAAO,GAAG,cAAc,CAAC,uBAAuB,CAAC,CAAC;gBAChF,MAAM,SAAS,GAAG,OAAO,GAAG,SAAS,CAAC;gBACtC,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;gBACzC,MAAM,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;gBAEjD,qFAAqF;gBACrF,+FAA+F;gBAC/F,MAAM,MAAM,GACV,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;gBAEnF,sEAAsE;gBACtE,6EAA6E;gBAC7E,2DAA2D;gBAC3D,MAAM,gBAAgB,GAAa,EAAE,CAAC;gBACtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBACvC,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;wBACvB,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC3B,CAAC;gBACH,CAAC;gBAED,IAAI,gBAAgB,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBAClC,0EAAwE;oBACxE,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;oBACrC,OAAO,GAAG,SAAS,CAAC;oBACpB,SAAS;gBACX,CAAC;gBAED,qEAAmE;gBACnE,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAEtE,qDAAqD;gBACrD,yDAAyD;gBACzD,KAAK,IAAI,EAAE,GAAG,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC;oBACzD,MAAM,SAAS,GAAG,gBAAgB,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;oBAC3C,MAAM,OAAO,GACX,EAAE,GAAG,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC;oBAC9E,IAAI,OAAO,IAAI,SAAS;wBAAE,SAAS,CAAC,aAAa;oBAEjD,MAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;oBACnE,IAAI,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,eAAe,CAAC,EAAE,CAAC;wBAClD,IAAI,CAAC;4BACH,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAe,CAAC;4BAC3C,IAAI,IAAA,sDAAiC,EAAC,GAAG,CAAC,EAAE,CAAC;gCAC3C,IAAI,OAAO,GAAG,IAAI,EAAE,CAAC;oCACnB,OAAO,EAAE,CAAC;gCACZ,CAAC;qCAAM,CAAC;oCACN,OAAO,SAAS,GAAG,SAAS,CAAC;gCAC/B,CAAC;4BACH,CAAC;wBACH,CAAC;wBAAC,MAAM,CAAC;4BACP,+CAA6C;wBAC/C,CAAC;oBACH,CAAC;gBACH,CAAC;gBAED,OAAO,GAAG,SAAS,CAAC;YACtB,CAAC;YAED,uDAAuD;YACvD,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC9B,MAAM,IAAI,GAAG,cAAc,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;gBAC9C,IAAI,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,eAAe,CAAC,EAAE,CAAC;oBAClD,IAAI,CAAC;wBACH,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAe,CAAC;wBAC3C,IAAI,IAAA,sDAAiC,EAAC,GAAG,CAAC,EAAE,CAAC;4BAC3C,IAAI,OAAO,GAAG,IAAI,EAAE,CAAC;gCACnB,oDAAoD;gCACpD,OAAO,IAAI,CAAC;4BACd,CAAC;4BACD,OAAO,CAAC,CAAC;wBACX,CAAC;oBACH,CAAC;oBAAC,MAAM,CAAC;wBACP,OAAO;oBACT,CAAC;gBACH,CAAC;YACH,CAAC;YAED,OAAO,IAAI,CAAC;QACd,CAAC;gBAAS,CAAC;YACT,MAAM,EAAE,CAAC,KAAK,EAAE,CAAC;QACnB,CAAC;IAAA,CACF;IAED;;;OAGG;IACK,KAAK,CAAC,qBAAqB,CACjC,WAAmB,EACnB,UAAkB,EACK;QACvB,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;QACtD,MAAM,IAAI,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACrC,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC;QACxC,IAAI,QAAQ,IAAI,CAAC;YAAE,OAAO,EAAE,CAAC;QAE7B,MAAM,EAAE,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;QACxC,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;YACtC,MAAM,EAAE,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;YAC/C,MAAM,KAAK,GAAG,MAAM;iBACjB,QAAQ,CAAC,OAAO,CAAC;iBACjB,KAAK,CAAC,IAAI,CAAC;iBACX,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;YAC3B,MAAM,QAAQ,GAAiB,EAAE,CAAC;YAClC,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;gBACzB,IAAI,CAAC;oBACH,QAAQ,CAAC,IAAI,CAAC,IAAA,mCAA0B,EAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAe,CAAC,CAAC,CAAC;gBAC5E,CAAC;gBAAC,MAAM,CAAC;oBACP,yEAAuE;gBACzE,CAAC;YACH,CAAC;YACD,OAAO,QAAQ,CAAC;QAClB,CAAC;gBAAS,CAAC;YACT,MAAM,EAAE,CAAC,KAAK,EAAE,CAAC;QACnB,CAAC;IAAA,CACF;IAED;;;;;;OAMG;IACK,KAAK,CAAC,gBAAgB,CAAC,WAAmB,EAAE,CAAS,EAAyB;QACpF,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;QAEtD,IAAI,QAAgB,CAAC;QACrB,IAAI,CAAC;YACH,MAAM,IAAI,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACrC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,CAAC;QAAC,MAAM,CAAC;YACP,OAAO,EAAE,CAAC;QACZ,CAAC;QACD,IAAI,QAAQ,KAAK,CAAC;YAAE,OAAO,EAAE,CAAC;QAE9B,MAAM,EAAE,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;QACxC,IAAI,CAAC;YACH,MAAM,SAAS,GAAiB,EAAE,CAAC;YACnC,IAAI,OAAO,GAAG,QAAQ,CAAC;YACvB,IAAI,cAAc,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAErC,OAAO,OAAO,GAAG,CAAC,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC3C,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,OAAO,GAAG,cAAc,CAAC,uBAAuB,CAAC,CAAC;gBAChF,MAAM,SAAS,GAAG,OAAO,GAAG,SAAS,CAAC;gBACtC,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;gBACzC,MAAM,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;gBAEjD,MAAM,MAAM,GACV,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;gBAEnF,MAAM,gBAAgB,GAAa,EAAE,CAAC;gBACtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBACvC,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;wBACvB,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC3B,CAAC;gBACH,CAAC;gBAED,IAAI,gBAAgB,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBAClC,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;oBACrC,OAAO,GAAG,SAAS,CAAC;oBACpB,SAAS;gBACX,CAAC;gBAED,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAEtE,gEAAgE;gBAChE,KAAK,IAAI,EAAE,GAAG,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC;oBACjF,MAAM,SAAS,GAAG,gBAAgB,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;oBAC3C,MAAM,OAAO,GACX,EAAE,GAAG,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC;oBAC9E,IAAI,OAAO,IAAI,SAAS;wBAAE,SAAS;oBAEnC,MAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC;oBAC1E,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC;wBAAE,SAAS;oBAChC,IAAI,CAAC;wBACH,SAAS,CAAC,IAAI,CAAC,IAAA,mCAA0B,EAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAe,CAAC,CAAC,CAAC;oBAC7E,CAAC;oBAAC,MAAM,CAAC;wBACP,uBAAuB;oBACzB,CAAC;gBACH,CAAC;gBAED,OAAO,GAAG,SAAS,CAAC;YACtB,CAAC;YAED,kDAAkD;YAClD,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACtD,MAAM,IAAI,GAAG,cAAc,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC;gBACrD,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBACpB,IAAI,CAAC;wBACH,SAAS,CAAC,IAAI,CAAC,IAAA,mCAA0B,EAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAe,CAAC,CAAC,CAAC;oBAC7E,CAAC;oBAAC,MAAM,CAAC;wBACP,OAAO;oBACT,CAAC;gBACH,CAAC;YACH,CAAC;YAED,yCAAyC;YACzC,SAAS,CAAC,OAAO,EAAE,CAAC;YACpB,OAAO,SAAS,CAAC;QACnB,CAAC;gBAAS,CAAC;YACT,MAAM,EAAE,CAAC,KAAK,EAAE,CAAC;QACnB,CAAC;IAAA,CACF;IAED;;;;OAIG;IACK,KAAK,CAAC,eAAe,CAAC,WAAmB,EAAyB;QACxE,IAAI,CAAC;YACH,MAAM,eAAe,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;YAC7D,MAAM,IAAI,GAAG,MAAM,EAAE,CAAC,QAAQ,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC;YACzD,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,GAAG,IAAI,GAAG,IAAI,EAAE,CAAC;gBAClC,SAAG,CAAC,IAAI,CAAC,uEAAqE,EAAE;oBAC9E,WAAW;oBACX,SAAS,EAAE,IAAI,CAAC,MAAM;iBACvB,CAAC,CAAC;YACL,CAAC;YACD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;YAC7D,MAAM,QAAQ,GAAiB,EAAE,CAAC;YAElC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACtC,IAAI,CAAC;oBACH,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAe,CAAC;oBACnD,QAAQ,CAAC,IAAI,CAAC,IAAA,mCAA0B,EAAC,OAAO,CAAC,CAAC,CAAC;gBACrD,CAAC;gBAAC,OAAO,UAAU,EAAE,CAAC;oBACpB,mDAAmD;oBACnD,SAAG,CAAC,IAAI,CACN,mCAAmC,CAAC,GAAG,CAAC,OAAO,WAAW,cAAc,EACxE,UAAU,YAAY,KAAK,CAAC,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,EACrE,iBAAiB,EACjB,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAClE,CAAC;gBACJ,CAAC;YACH,CAAC;YAED,OAAO,QAAQ,CAAC;QAClB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;gBACrF,OAAO,EAAE,CAAC,CAAC,iBAAiB;YAC9B,CAAC;YACD,MAAM,KAAK,CAAC,CAAC,6BAA6B;QAC5C,CAAC;IAAA,CACF;IAED,wIAA4E;IAC5E,gFAAgF;IAChF,6EAA6E;IAC7E,iCAAiC;IAEjC;;;;OAIG;IACK,KAAK,CAAC,cAAc,CAC1B,WAAmB,EACnB,OAA6E,EAC9D;QACf,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;QAEtD,IAAI,QAAgB,CAAC;QACrB,IAAI,CAAC;YACH,MAAM,IAAI,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACrC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;gBACrF,OAAO,CAAC,aAAa;YACvB,CAAC;YACD,MAAM,KAAK,CAAC;QACd,CAAC;QACD,IAAI,QAAQ,KAAK,CAAC;YAAE,OAAO;QAE3B,MAAM,EAAE,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;QACxC,IAAI,CAAC;YACH,IAAI,OAAO,GAAG,CAAC,CAAC;YAChB,kEAAkE;YAClE,6CAA6C;YAC7C,IAAI,cAAc,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAErC,OAAO,OAAO,GAAG,QAAQ,EAAE,CAAC;gBAC1B,MAAM,SAAS,GAAG,QAAQ,GAAG,OAAO,CAAC;gBACrC,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,uBAAuB,EAAE,SAAS,CAAC,CAAC;gBAC3E,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;gBACtC,MAAM,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;gBAC5C,OAAO,IAAI,MAAM,CAAC;gBAElB,MAAM,MAAM,GACV,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;gBAEnF,8EAA8E;gBAC9E,+DAA+D;gBAC/D,IAAI,WAAW,GAAG,CAAC,CAAC,CAAC;gBACrB,KAAK,IAAI,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;oBAC5C,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;wBACvB,WAAW,GAAG,CAAC,CAAC;wBAChB,MAAM;oBACR,CAAC;gBACH,CAAC;gBAED,IAAI,WAAW,KAAK,CAAC,CAAC,EAAE,CAAC;oBACvB,2DAAyD;oBACzD,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;oBACrC,SAAS;gBACX,CAAC;gBAED,+DAA+D;gBAC/D,MAAM,YAAY,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;gBACvE,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC;gBAE/D,MAAM,QAAQ,GAAiB,EAAE,CAAC;gBAClC,KAAK,MAAM,IAAI,IAAI,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC;oBAC5C,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;oBAC5B,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC;wBAAE,SAAS;oBACnC,IAAI,CAAC;wBACH,QAAQ,CAAC,IAAI,CAAC,IAAA,mCAA0B,EAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAe,CAAC,CAAC,CAAC;oBAC/E,CAAC;oBAAC,MAAM,CAAC;wBACP,yEAAuE;oBACzE,CAAC;gBACH,CAAC;gBAED,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBACxB,MAAM,cAAc,GAAG,MAAM,OAAO,CAAC,QAAQ,CAAC,CAAC;oBAC/C,IAAI,cAAc,KAAK,KAAK;wBAAE,OAAO;gBACvC,CAAC;YACH,CAAC;YAED,kEAAkE;YAClE,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC9B,MAAM,IAAI,GAAG,cAAc,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC;gBACrD,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBACpB,IAAI,CAAC;wBACH,MAAM,GAAG,GAAG,IAAA,mCAA0B,EAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAe,CAAC,CAAC;wBACvE,MAAM,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;oBACvB,CAAC;oBAAC,MAAM,CAAC;wBACP,sBAAsB;oBACxB,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC;gBAAS,CAAC;YACT,MAAM,EAAE,CAAC,KAAK,EAAE,CAAC;QACnB,CAAC;IAAA,CACF;IAED;;;;OAIG;IACK,KAAK,CAAC,eAAe,CAC3B,WAAmB,EACnB,OAA6E,EAC9D;QACf,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;QAEtD,IAAI,QAAgB,CAAC;QACrB,IAAI,CAAC;YACH,MAAM,IAAI,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACrC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;gBACrF,OAAO,CAAC,aAAa;YACvB,CAAC;YACD,MAAM,KAAK,CAAC;QACd,CAAC;QACD,IAAI,QAAQ,KAAK,CAAC;YAAE,OAAO;QAE3B,MAAM,EAAE,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;QACxC,IAAI,CAAC;YACH,IAAI,OAAO,GAAG,QAAQ,CAAC;YACvB,IAAI,cAAc,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAErC,OAAO,OAAO,GAAG,CAAC,EAAE,CAAC;gBACnB,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,OAAO,GAAG,cAAc,CAAC,uBAAuB,CAAC,CAAC;gBAChF,MAAM,SAAS,GAAG,OAAO,GAAG,SAAS,CAAC;gBACtC,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;gBACzC,MAAM,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;gBAEjD,MAAM,MAAM,GACV,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;gBAEnF,MAAM,gBAAgB,GAAa,EAAE,CAAC;gBACtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBACvC,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;wBACvB,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC3B,CAAC;gBACH,CAAC;gBAED,IAAI,gBAAgB,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBAClC,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;oBACrC,OAAO,GAAG,SAAS,CAAC;oBACpB,SAAS;gBACX,CAAC;gBAED,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAEtE,6EAA2E;gBAC3E,MAAM,QAAQ,GAAiB,EAAE,CAAC;gBAClC,KAAK,IAAI,EAAE,GAAG,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC;oBACzD,MAAM,SAAS,GAAG,gBAAgB,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;oBAC3C,MAAM,OAAO,GACX,EAAE,GAAG,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC;oBAC9E,IAAI,OAAO,IAAI,SAAS;wBAAE,SAAS;oBAEnC,MAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC;oBAC1E,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC;wBAAE,SAAS;oBAChC,IAAI,CAAC;wBACH,QAAQ,CAAC,IAAI,CAAC,IAAA,mCAA0B,EAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAe,CAAC,CAAC,CAAC;oBAC5E,CAAC;oBAAC,MAAM,CAAC;wBACP,uBAAuB;oBACzB,CAAC;gBACH,CAAC;gBAED,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBACxB,MAAM,cAAc,GAAG,MAAM,OAAO,CAAC,QAAQ,CAAC,CAAC;oBAC/C,IAAI,cAAc,KAAK,KAAK;wBAAE,OAAO;gBACvC,CAAC;gBAED,OAAO,GAAG,SAAS,CAAC;YACtB,CAAC;YAED,uDAAuD;YACvD,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC9B,MAAM,IAAI,GAAG,cAAc,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC;gBACrD,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBACpB,IAAI,CAAC;wBACH,MAAM,GAAG,GAAG,IAAA,mCAA0B,EAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAe,CAAC,CAAC;wBACvE,MAAM,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;oBACvB,CAAC;oBAAC,MAAM,CAAC;wBACP,sBAAsB;oBACxB,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC;gBAAS,CAAC;YACT,MAAM,EAAE,CAAC,KAAK,EAAE,CAAC;QACnB,CAAC;IAAA,CACF;IAED;;;;;;;;;;;;;OAaG;IACH,KAAK,CAAC,kBAAkB,CACtB,WAAmB,EACnB,SAAiC,EACjC,OAA6E,EACtD;QACvB,IAAI,CAAC;YACH,IAAI,SAAS,KAAK,SAAS,EAAE,CAAC;gBAC5B,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;YAClD,CAAC;iBAAM,CAAC;gBACN,MAAM,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;YACnD,CAAC;YACD,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;QACvB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACvE,OAAO,IAAA,YAAG,EAAC,8BAA8B,OAAO,EAAE,CAAC,CAAC;QACtD,CAAC;IAAA,CACF;IAED;;;;;;;;;;;OAWG;IACH,KAAK,CAAC,4BAA4B,CAAC,WAAmB,EAAE,IAAI,GAAG,CAAC,EAAiC;QAC/F,IAAI,CAAC;YACH,sEAAsE;YACtE,KAAK,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC/B,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,0BAA0B,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;gBACrE,IAAI,MAAM,KAAK,IAAI,EAAE,CAAC;oBACpB,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;oBACvE,OAAO,IAAA,WAAE,EAAC,QAAQ,CAAC,CAAC;gBACtB,CAAC;YACH,CAAC;YAED,kFAAgF;YAChF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;YACzD,OAAO,IAAA,WAAE,EAAC,QAAQ,CAAC,CAAC;QACtB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACvE,OAAO,IAAA,YAAG,EAAC,yCAAyC,OAAO,EAAE,CAAC,CAAC;QACjE,CAAC;IAAA,CACF;IAED;;;OAGG;IACH,KAAK,CAAC,eAAe,CAAC,WAAmB,EAAE,CAAS,EAAiC;QACnF,IAAI,CAAC;YACH,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;YAC7D,OAAO,IAAA,WAAE,EAAC,QAAQ,CAAC,CAAC;QACtB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACvE,OAAO,IAAA,YAAG,EAAC,uBAAuB,CAAC,cAAc,OAAO,EAAE,CAAC,CAAC;QAC9D,CAAC;IAAA,CACF;IAED;;;OAGG;IACH,KAAK,CAAC,UAAU,CAAC,WAAmB,EAAoB;QACtD,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;QACtD,IAAI,CAAC;YACH,MAAM,IAAI,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACrC,OAAO,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;QACvB,CAAC;QAAC,MAAM,CAAC;YACP,OAAO,KAAK,CAAC;QACf,CAAC;IAAA,CACF;IAED;;OAEG;IACK,KAAK,CAAC,sBAAsB,CAAC,WAAmB,EAAmB;QACzE,wCAAwC;QACxC,IAAI,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,CAAC;YAC3C,OAAO,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,CAAE,CAAC;QACjD,CAAC;QAED,6EAA2E;QAC3E,4EAA4E;QAC5E,2BAA2B;QAC3B,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;QAC9D,IAAI,UAAU,CAAC,OAAO,IAAI,UAAU,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACrD,MAAM,OAAO,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACnC,MAAM,MAAM,GAAG,OAAO,CAAC,QAAQ,EAAE,eAAe,CAAC;YACjD,IAAI,oBAAoB,CAAC,MAAM,CAAC,EAAE,CAAC;gBACjC,MAAM,UAAU,GAAG,MAAM,GAAG,CAAC,CAAC;gBAC9B,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;gBACnD,OAAO,UAAU,CAAC;YACpB,CAAC;YACD,wEAAsE;YACtE,8DAA8D;YAC9D,IAAI,SAAS,GAAG,CAAC,CAAC,CAAC;YACnB,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,UAAU,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC;gBACnF,KAAK,MAAM,GAAG,IAAI,KAAK,EAAE,CAAC;oBACxB,MAAM,GAAG,GAAG,GAAG,CAAC,QAAQ,EAAE,eAAe,CAAC;oBAC1C,IAAI,oBAAoB,CAAC,GAAG,CAAC,EAAE,CAAC;wBAC9B,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;wBACrC,wEAAsE;wBACtE,OAAO,KAAK,CAAC;oBACf,CAAC;gBACH,CAAC;YAAA,CACF,CAAC,CAAC;YACH,IAAI,UAAU,CAAC,OAAO,EAAE,CAAC;gBACvB,MAAM,UAAU,GAAG,SAAS,GAAG,CAAC,CAAC;gBACjC,IAAA,qBAAM,EACJ,oBAAoB,CAAC,UAAU,CAAC,EAChC,8DAA8D,CAC/D,CAAC;gBACF,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;gBACnD,OAAO,UAAU,CAAC;YACpB,CAAC;QACH,CAAC;QAED,+BAA+B;QAC/B,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;QAC1C,OAAO,CAAC,CAAC;IAAA,CACV;IAED;;;OAGG;IACK,KAAK,CAAC,wBAAwB,CACpC,WAAmB,EACnB,OAAmB,EACI;QACvB,IAAI,CAAC;YACH,MAAM,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC;YAC5D,MAAM,EAAE,CAAC,KAAK,CAAC,YAAY,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;YAClD,MAAM,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;YAEzD,oDAAoD;YACpD,MAAM,KAAK,GAAG,IAAI,KAAK,EAAE,CAAC,KAAK,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC;YAClF,SAAG,CAAC,KAAK,CACP,gCAAgC,WAAW,SAAS,OAAO,CAAC,IAAI,OAAO,OAAO,CAAC,EAAE,EAAE,CACpF,CAAC;YACF,SAAG,CAAC,KAAK,CAAC,iCAAiC,KAAK,EAAE,CAAC,CAAC;YAEpD,+CAA+C;YAC/C,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;gBACtB,wCAAwC;gBACxC,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,WAAW,CAAC,CAAC;gBAClE,IAAA,qBAAM,EACJ,oBAAoB,CAAC,UAAU,CAAC,EAChC,2DAA2D,CAC5D,CAAC;gBACF,OAAO,CAAC,QAAQ,GAAG;oBACjB,eAAe,EAAE,UAAU;iBAC5B,CAAC;gBACF,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,EAAE,UAAU,GAAG,CAAC,CAAC,CAAC;YACzD,CAAC;iBAAM,CAAC;gBACN,sEAAsE;gBACtE,MAAM,cAAc,GAAG,OAAO,CAAC,QAAQ,CAAC,eAAe,CAAC;gBACxD,IAAI,cAAc,KAAK,SAAS,EAAE,CAAC;oBACjC,IAAA,qBAAM,EACJ,oBAAoB,CAAC,cAAc,CAAC,EACpC,qFAAqF,CACtF,CAAC;oBAEF,yDAAyD;oBACzD,MAAM,cAAc,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;oBACnE,IAAA,qBAAM,EACJ,oBAAoB,CAAC,cAAc,CAAC,EACpC,6DAA6D,CAC9D,CAAC;oBACF,IAAI,cAAc,IAAI,cAAc,EAAE,CAAC;wBACrC,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,EAAE,cAAc,GAAG,CAAC,CAAC,CAAC;oBAC7D,CAAC;gBACH,CAAC;qBAAM,CAAC;oBACN,kDAAkD;oBAClD,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,WAAW,CAAC,CAAC;oBAClE,IAAA,qBAAM,EACJ,oBAAoB,CAAC,UAAU,CAAC,EAChC,2DAA2D,CAC5D,CAAC;oBACF,OAAO,CAAC,QAAQ,GAAG;wBACjB,GAAG,OAAO,CAAC,QAAQ;wBACnB,eAAe,EAAE,UAAU;qBAC5B,CAAC;oBACF,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,EAAE,UAAU,GAAG,CAAC,CAAC,CAAC;gBACzD,CAAC;YACH,CAAC;YAED,2CAA2C;YAC3C,MAAM,YAAY,GAAG;gBACnB,GAAG,OAAO;gBACV,WAAW;aACZ,CAAC;YAEF,sCAAsC;YACtC,SAAG,CAAC,KAAK,CACP,6CAA6C,OAAO,CAAC,QAAQ,CAAC,eAAe,IAAI,SAAS,SAAS,OAAO,CAAC,IAAI,EAAE,CAClH,CAAC;YAEF,MAAM,EAAE,CAAC,UAAU,CAAC,WAAW,EAAE,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,CAAC;YACtE,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;QACvB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACvE,OAAO,IAAA,YAAG,EAAC,gCAAgC,OAAO,EAAE,CAAC,CAAC;QACxD,CAAC;IAAA,CACF;IAED,KAAK,CAAC,eAAe,CAAC,WAAmB,EAAE,OAAmB,EAAyB;QACrF,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,WAAW,EAAE,KAAK,IAAI,EAAE,CAAC;YACtD,OAAO,IAAI,CAAC,wBAAwB,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;QAAA,CAC5D,CAAC,CAAC;IAAA,CACJ;IAED;;;OAGG;IACH,KAAK,CAAC,aAAa,CAAC,WAAmB,EAAE,OAAmB,EAAyB;QACnF,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,WAAW,EAAE,KAAK,IAAI,EAAE,CAAC;YACtD,IAAI,CAAC;gBACH,MAAM,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;gBAEzD,sEAAoE;gBACpE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;gBACzD,MAAM,cAAc,GAAG,OAAO,CAAC,QAAQ,EAAE,eAAe,CAAC;gBAEzD,IAAI,cAAc,KAAK,SAAS,EAAE,CAAC;oBACjC,OAAO,IAAA,YAAG,EAAC,+CAA+C,CAAC,CAAC;gBAC9D,CAAC;gBAED,IAAA,qBAAM,EACJ,oBAAoB,CAAC,cAAc,CAAC,EACpC,qEAAqE,CACtE,CAAC;gBAEF,6DAA6D;gBAC7D,IAAI,KAAK,GAAG,KAAK,CAAC;gBAClB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBACzC,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,eAAe,KAAK,cAAc,EAAE,CAAC;wBAC7D,MAAM,eAAe,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;wBACpC,IAAA,qBAAM,EAAC,eAAe,EAAE,0CAA0C,CAAC,CAAC;wBAEpE,uEAAuE;wBACvE,+EAA+E;wBAC/E,6EAA6E;wBAC7E,MAAM,2BAA2B,GAAG,+BAA+B,CACjE,WAAW,EACX,eAAe,EACf,OAAO,CACR,CAAC;wBAEF,wDAAwD;wBACxD,QAAQ,CAAC,CAAC,CAAC,GAAG;4BACZ,GAAG,OAAO;4BACV,QAAQ,EAAE;gCACR,GAAG,OAAO,CAAC,QAAQ;gCACnB,GAAG,CAAC,2BAA2B,IAAI,EAAE,CAAC;gCACtC,eAAe,EAAE,cAAc;6BAChC;yBACF,CAAC;wBACF,KAAK,GAAG,IAAI,CAAC;wBACb,MAAM;oBACR,CAAC;gBACH,CAAC;gBAED,IAAI,CAAC,KAAK,EAAE,CAAC;oBACX,OAAO,IAAA,YAAG,EAAC,yCAAyC,cAAc,EAAE,CAAC,CAAC;gBACxE,CAAC;gBAED,sBAAsB;gBACtB,MAAM,cAAc,GAAG,QAAQ;qBAC5B,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,GAAG,GAAG,EAAE,WAAW,EAAE,CAAC,GAAG,IAAI,CAAC;qBAC5D,IAAI,CAAC,EAAE,CAAC,CAAC;gBAEZ,4DAA4D;gBAC5D,MAAM,IAAA,2BAAe,EAAC,WAAW,EAAE,cAAc,CAAC,CAAC;gBACnD,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;YACvB,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACvE,OAAO,IAAA,YAAG,EAAC,6BAA6B,OAAO,EAAE,CAAC,CAAC;YACrD,CAAC;QAAA,CACF,CAAC,CAAC;IAAA,CACJ;IAED;;;;;OAKG;IACH,KAAK,CAAC,aAAa,CAAC,WAAmB,EAAE,SAAiB,EAAyB;QACjF,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,WAAW,EAAE,KAAK,IAAI,EAAE,CAAC;YACtD,IAAI,CAAC;gBACH,gDAAgD;gBAChD,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;gBACzD,MAAM,gBAAgB,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,KAAK,SAAS,CAAC,CAAC;gBAExE,IAAI,gBAAgB,CAAC,MAAM,KAAK,QAAQ,CAAC,MAAM,EAAE,CAAC;oBAChD,OAAO,IAAA,YAAG,EAAC,mBAAmB,SAAS,uBAAuB,CAAC,CAAC;gBAClE,CAAC;gBAED,MAAM,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;gBACzD,MAAM,cAAc,GAAG,gBAAgB;qBACpC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,GAAG,GAAG,EAAE,WAAW,EAAE,CAAC,GAAG,IAAI,CAAC;qBAC5D,IAAI,CAAC,EAAE,CAAC,CAAC;gBAEZ,4DAA4D;gBAC5D,MAAM,IAAA,2BAAe,EAAC,WAAW,EAAE,cAAc,CAAC,CAAC;gBAEnD,qFAAqF;gBACrF,wEAAwE;gBACxE,MAAM,MAAM,GAAG,gBAAgB,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC;oBACnD,MAAM,GAAG,GAAG,GAAG,CAAC,QAAQ,EAAE,eAAe,CAAC;oBAC1C,IAAI,GAAG,KAAK,SAAS,EAAE,CAAC;wBACtB,OAAO,GAAG,CAAC;oBACb,CAAC;oBAED,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,EAAE,CAAC;wBAC/B,SAAG,CAAC,IAAI,CACN,2FAA2F,EAC3F;4BACE,WAAW;4BACX,SAAS,EAAE,GAAG,CAAC,EAAE;4BACjB,eAAe,EAAE,GAAG;yBACrB,CACF,CAAC;wBACF,OAAO,GAAG,CAAC;oBACb,CAAC;oBAED,OAAO,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;gBAAA,CAC9B,EAAE,CAAC,CAAC,CAAC,CAAC;gBACP,MAAM,OAAO,GAAG,MAAM,GAAG,CAAC,CAAC;gBAC3B,IAAA,qBAAM,EACJ,oBAAoB,CAAC,OAAO,CAAC,EAC7B,2EAA2E,CAC5E,CAAC;gBACF,MAAM,cAAc,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;gBAC9D,IAAI,cAAc,KAAK,SAAS,IAAI,cAAc,GAAG,OAAO,EAAE,CAAC;oBAC7D,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;gBAClD,CAAC;gBAED,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;YACvB,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACvE,OAAO,IAAA,YAAG,EAAC,6BAA6B,OAAO,EAAE,CAAC,CAAC;YACrD,CAAC;QAAA,CACF,CAAC,CAAC;IAAA,CACJ;IAED;;;OAGG;IACH,KAAK,CAAC,oBAAoB,CAAC,WAAmB,EAAE,SAAiB,EAAyB;QACxF,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,WAAW,EAAE,KAAK,IAAI,EAAE,CAAC;YACtD,IAAI,CAAC;gBACH,gDAAgD;gBAChD,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;gBACzD,MAAM,YAAY,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,KAAK,SAAS,CAAC,CAAC;gBAEvE,IAAI,YAAY,KAAK,CAAC,CAAC,EAAE,CAAC;oBACxB,OAAO,IAAA,YAAG,EAAC,mBAAmB,SAAS,uBAAuB,CAAC,CAAC;gBAClE,CAAC;gBAED,+CAA+C;gBAC/C,MAAM,iBAAiB,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC;gBAE1D,mDAAmD;gBACnD,MAAM,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;gBACzD,MAAM,cAAc,GAAG,iBAAiB;qBACrC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,GAAG,GAAG,EAAE,WAAW,EAAE,CAAC,GAAG,IAAI,CAAC;qBAC5D,IAAI,CAAC,EAAE,CAAC,CAAC;gBAEZ,4DAA4D;gBAC5D,MAAM,IAAA,2BAAe,EAAC,WAAW,EAAE,cAAc,CAAC,CAAC;gBAEnD,+DAA+D;gBAC/D,2EAA2E;gBAC3E,MAAM,eAAe,GAAG,iBAAiB,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC;oBAC7D,MAAM,GAAG,GAAG,GAAG,CAAC,QAAQ,EAAE,eAAe,CAAC;oBAC1C,IAAI,GAAG,KAAK,SAAS,EAAE,CAAC;wBACtB,OAAO,GAAG,CAAC;oBACb,CAAC;oBAED,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,EAAE,CAAC;wBAC/B,SAAG,CAAC,IAAI,CACN,+FAA+F,EAC/F;4BACE,WAAW;4BACX,SAAS,EAAE,GAAG,CAAC,EAAE;4BACjB,eAAe,EAAE,GAAG;yBACrB,CACF,CAAC;wBACF,OAAO,GAAG,CAAC;oBACb,CAAC;oBAED,OAAO,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;gBAAA,CAC9B,EAAE,CAAC,CAAC,CAAC,CAAC;gBACP,MAAM,OAAO,GAAG,eAAe,GAAG,CAAC,CAAC;gBACpC,IAAA,qBAAM,EACJ,oBAAoB,CAAC,OAAO,CAAC,EAC7B,+EAA+E,CAChF,CAAC;gBACF,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;gBAEhD,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;YACvB,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACvE,OAAO,IAAA,YAAG,EAAC,+BAA+B,OAAO,EAAE,CAAC,CAAC;YACvD,CAAC;QAAA,CACF,CAAC,CAAC;IAAA,CACJ;IAED;;;;;OAKG;IACH,KAAK,CAAC,eAAe,CACnB,WAAmB,EACnB,UAAkB,EACiB;QACnC,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,WAAW,EAAE,KAAK,IAAI,EAAE,CAAC;YACtD,IAAI,CAAC;gBACH,MAAM,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;gBAEzD,kDAAkD;gBAClD,IAAI,UAAU,IAAI,GAAG,EAAE,CAAC;oBACtB,yDAAyD;oBACzD,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;oBACzD,MAAM,gBAAgB,GAAG,QAAQ;yBAC9B,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,QAAQ,EAAE,eAAe,CAAC;yBAC3C,MAAM,CAAC,CAAC,CAAC,EAAe,EAAE,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,CAAC;oBAEvD,IAAI,CAAC;wBACH,MAAM,EAAE,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;oBAC/B,CAAC;oBAAC,OAAO,KAAK,EAAE,CAAC;wBACf,uCAAuC;wBACvC,IACE,CAAC,CAAC,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,CAAC,EACnF,CAAC;4BACD,MAAM,KAAK,CAAC;wBACd,CAAC;oBACH,CAAC;oBAED,+CAA+C;oBAC/C,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;oBAC1C,OAAO,IAAA,WAAE,EAAC,gBAAgB,CAAC,CAAC;gBAC9B,CAAC;gBAED,gDAAgD;gBAChD,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;gBACzD,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBAC1B,OAAO,IAAA,WAAE,EAAC,EAAE,CAAC,CAAC,CAAC,sBAAsB;gBACvC,CAAC;gBAED,mDAAmD;gBACnD,MAAM,SAAS,GAAG,MAAM,IAAA,gCAAoB,EAAC,0BAAY,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;gBAErE,gCAAgC;gBAChC,gFAAgF;gBAChF,MAAM,aAAa,GAAmD,MAAM,OAAO,CAAC,GAAG,CACrF,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,CAAC;oBAC1B,MAAM,MAAM,GAAG,MAAM,SAAS,CAAC,WAAW,CAAC,IAAA,mDAAwB,EAAC,GAAG,CAAC,CAAC,CAAC;oBAC1E,OAAO,EAAE,OAAO,EAAE,GAAG,EAAE,MAAM,EAAE,CAAC;gBAAA,CACjC,CAAC,CACH,CAAC;gBAEF,8CAA8C;gBAC9C,MAAM,WAAW,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;gBAC1E,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,UAAU,CAAC,CAAC;gBAE5D,mEAAmE;gBACnE,IAAI,aAAa,GAAG,CAAC,CAAC;gBACtB,IAAI,WAAW,GAAG,CAAC,CAAC;gBACpB,KAAK,MAAM,EAAE,IAAI,aAAa,EAAE,CAAC;oBAC/B,IAAI,aAAa,IAAI,cAAc,EAAE,CAAC;wBACpC,MAAM;oBACR,CAAC;oBACD,aAAa,IAAI,EAAE,CAAC,MAAM,CAAC;oBAC3B,WAAW,EAAE,CAAC;gBAChB,CAAC;gBAED,gDAAgD;gBAChD,IAAI,WAAW,IAAI,QAAQ,CAAC,MAAM,EAAE,CAAC;oBACnC,IAAI,CAAC;wBACH,MAAM,EAAE,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;oBAC/B,CAAC;oBAAC,OAAO,KAAK,EAAE,CAAC;wBACf,gBAAgB;wBAChB,IACE,CAAC,CAAC,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,CAAC,EACnF,CAAC;4BACD,MAAM,KAAK,CAAC;wBACd,CAAC;oBACH,CAAC;oBACD,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;oBAC1C,MAAM,gBAAgB,GAAG,QAAQ;yBAC9B,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,QAAQ,EAAE,eAAe,CAAC;yBAC3C,MAAM,CAAC,CAAC,CAAC,EAAe,EAAE,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,CAAC;oBACvD,OAAO,IAAA,WAAE,EAAC,gBAAgB,CAAC,CAAC;gBAC9B,CAAC;gBAED,kCAAkC;gBAClC,MAAM,iBAAiB,GAAG,QAAQ,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;gBACtD,MAAM,eAAe,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC;gBACvD,MAAM,gBAAgB,GAAG,eAAe;qBACrC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,QAAQ,EAAE,eAAe,CAAC;qBAC3C,MAAM,CAAC,CAAC,CAAC,EAAe,EAAE,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,CAAC;gBAEvD,mDAAmD;gBACnD,MAAM,cAAc,GAAG,iBAAiB;qBACrC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,GAAG,GAAG,EAAE,WAAW,EAAE,CAAC,GAAG,IAAI,CAAC;qBAC5D,IAAI,CAAC,EAAE,CAAC,CAAC;gBAEZ,4DAA4D;gBAC5D,MAAM,IAAA,2BAAe,EAAC,WAAW,EAAE,cAAc,CAAC,CAAC;gBAEnD,yDAAyD;gBACzD,2EAA2E;gBAC3E,MAAM,eAAe,GAAG,iBAAiB,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC;oBAC7D,MAAM,GAAG,GAAG,GAAG,CAAC,QAAQ,EAAE,eAAe,CAAC;oBAC1C,IAAI,GAAG,KAAK,SAAS,EAAE,CAAC;wBACtB,OAAO,GAAG,CAAC;oBACb,CAAC;oBAED,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,EAAE,CAAC;wBAC/B,SAAG,CAAC,IAAI,CACN,oGAAoG,EACpG;4BACE,WAAW;4BACX,SAAS,EAAE,GAAG,CAAC,EAAE;4BACjB,eAAe,EAAE,GAAG;yBACrB,CACF,CAAC;wBACF,OAAO,GAAG,CAAC;oBACb,CAAC;oBAED,OAAO,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;gBAAA,CAC9B,EAAE,CAAC,CAAC,CAAC,CAAC;gBACP,MAAM,OAAO,GAAG,eAAe,GAAG,CAAC,CAAC;gBACpC,IAAA,qBAAM,EACJ,oBAAoB,CAAC,OAAO,CAAC,EAC7B,oFAAoF,CACrF,CAAC;gBACF,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;gBAEhD,OAAO,IAAA,WAAE,EAAC,gBAAgB,CAAC,CAAC;YAC9B,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACvE,OAAO,IAAA,YAAG,EAAC,+BAA+B,OAAO,EAAE,CAAC,CAAC;YACvD,CAAC;QAAA,CACF,CAAC,CAAC;IAAA,CACJ;IAED,KAAK,CAAC,YAAY,CAAC,WAAmB,EAAqC;QACzE,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC;QAC5D,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;YACpB,OAAO,IAAA,YAAG,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAC3B,CAAC;QACD,OAAO,IAAA,WAAE,EAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAAA,CACxB;IAED;;;;OAIG;IACH,KAAK,CAAC,kBAAkB,CAAC,cAAsB,EAAE,cAAsB,EAAyB;QAC9F,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,cAAc,EAAE,KAAK,IAAI,EAAE,CAAC;YACzD,IAAI,CAAC;gBACH,iFAAiF;gBACjF,iDAAiD;gBACjD,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,CAAC;gBAC5D,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBAC1B,yDAAyD;oBACzD,MAAM,UAAU,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;oBAClE,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,cAAc,EAAE,UAAU,CAAC,CAAC;oBACtD,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;oBAC7C,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;gBACvB,CAAC;gBAED,6CAA6C;gBAC7C,MAAM,cAAc,GAAG,IAAI,CAAC,kBAAkB,CAAC,cAAc,CAAC,CAAC;gBAC/D,MAAM,cAAc,GAAG,QAAQ;qBAC5B,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,GAAG,GAAG,EAAE,WAAW,EAAE,cAAc,EAAE,CAAC,GAAG,IAAI,CAAC;qBAC5E,IAAI,CAAC,EAAE,CAAC,CAAC;gBAEZ,4DAA4D;gBAC5D,MAAM,IAAA,2BAAe,EAAC,cAAc,EAAE,cAAc,CAAC,CAAC;gBAEtD,gDAAgD;gBAChD,MAAM,UAAU,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;gBAClE,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,cAAc,EAAE,UAAU,CAAC,CAAC;gBACtD,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;gBAE7C,SAAG,CAAC,KAAK,CACP,YAAY,QAAQ,CAAC,MAAM,kBAAkB,cAAc,OAAO,cAAc,EAAE,CACnF,CAAC;gBAEF,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;YACvB,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACvE,OAAO,IAAA,YAAG,EAAC,mCAAmC,OAAO,EAAE,CAAC,CAAC;YAC3D,CAAC;QAAA,CACF,CAAC,CAAC;IAAA,CACJ;CACF","sourcesContent":["import * as fs from \"fs/promises\";\r\nimport * as path from \"path\";\r\nimport writeFileAtomic from \"write-file-atomic\";\r\nimport assert from \"node:assert\";\r\nimport type { Result } from \"@/common/types/result\";\r\nimport { Ok, Err } from \"@/common/types/result\";\r\nimport {\r\n  isCompactionSummaryMetadata,\r\n  type MuxMessage,\r\n  type MuxMetadata,\r\n} from \"@/common/types/message\";\r\nimport type { Config } from \"@/node/config\";\r\nimport { workspaceFileLocks } from \"@/node/utils/concurrency/workspaceFileLocks\";\r\nimport { log } from \"./log\";\r\nimport { getTokenizerForModel } from \"@/node/utils/main/tokenizer\";\r\nimport { KNOWN_MODELS } from \"@/common/constants/knownModels\";\r\nimport { safeStringifyForCounting } from \"@/common/utils/tokens/safeStringifyForCounting\";\r\nimport { normalizeLegacyMuxMetadata } from \"@/node/utils/messages/legacy\";\r\nimport { isDurableCompactionBoundaryMarker } from \"@/common/utils/messages/compactionBoundary\";\r\n\r\nfunction isPositiveInteger(value: unknown): value is number {\r\n  return (\r\n    typeof value === \"number\" && Number.isFinite(value) && Number.isInteger(value) && value > 0\r\n  );\r\n}\r\n\r\nfunction isNonNegativeInteger(value: unknown): value is number {\r\n  return (\r\n    typeof value === \"number\" && Number.isFinite(value) && Number.isInteger(value) && value >= 0\r\n  );\r\n}\r\n\r\nfunction hasDurableCompactedMarker(value: unknown): value is true | \"user\" | \"idle\" {\r\n  return value === true || value === \"user\" || value === \"idle\";\r\n}\r\n\r\nfunction hasDurableCompactionBoundary(metadata: MuxMetadata | undefined): boolean {\r\n  if (metadata?.compactionBoundary !== true) {\r\n    return false;\r\n  }\r\n\r\n  // Self-healing read path: malformed boundary markers should be ignored.\r\n  if (!hasDurableCompactedMarker(metadata.compacted)) {\r\n    return false;\r\n  }\r\n\r\n  return isPositiveInteger(metadata.compactionEpoch);\r\n}\r\n\r\nfunction getCompactionMetadataToPreserve(\r\n  workspaceId: string,\r\n  existingMessage: MuxMessage,\r\n  incomingMessage: MuxMessage\r\n): Partial<MuxMetadata> | null {\r\n  const existingMetadata = existingMessage.metadata;\r\n  if (existingMetadata?.compactionBoundary !== true) {\r\n    return null;\r\n  }\r\n\r\n  if (existingMessage.role !== \"assistant\") {\r\n    // Self-healing read path: boundary metadata on non-assistant rows is invalid.\r\n    log.warn(\"Skipping malformed persisted compaction boundary during history update\", {\r\n      workspaceId,\r\n      messageId: existingMessage.id,\r\n      reason: \"compactionBoundary set on non-assistant message\",\r\n    });\r\n    return null;\r\n  }\r\n\r\n  if (incomingMessage.role !== \"assistant\") {\r\n    return null;\r\n  }\r\n\r\n  if (!hasDurableCompactionBoundary(existingMetadata)) {\r\n    // Self-healing read path: malformed boundary metadata should not be propagated.\r\n    log.warn(\"Skipping malformed persisted compaction boundary during history update\", {\r\n      workspaceId,\r\n      messageId: existingMessage.id,\r\n      reason: \"compactionBoundary missing valid compacted+compactionEpoch metadata\",\r\n    });\r\n    return null;\r\n  }\r\n\r\n  if (hasDurableCompactionBoundary(incomingMessage.metadata)) {\r\n    return null;\r\n  }\r\n\r\n  const preserved: Partial<MuxMetadata> = {\r\n    compacted: existingMetadata.compacted,\r\n    compactionBoundary: true,\r\n    compactionEpoch: existingMetadata.compactionEpoch,\r\n  };\r\n\r\n  if (\r\n    isCompactionSummaryMetadata(existingMetadata.muxMetadata) &&\r\n    !isCompactionSummaryMetadata(incomingMessage.metadata?.muxMetadata)\r\n  ) {\r\n    preserved.muxMetadata = existingMetadata.muxMetadata;\r\n  }\r\n\r\n  return preserved;\r\n}\r\n/**\r\n * HistoryService - Manages chat history persistence and sequence numbering\r\n *\r\n * Responsibilities:\r\n * - Read/write chat history to disk (JSONL format)\r\n * - Assign sequence numbers to messages (single source of truth)\r\n * - Track next sequence number per workspace\r\n */\r\nexport class HistoryService {\r\n  private readonly CHAT_FILE = \"chat.jsonl\";\r\n  // Track next sequence number per workspace in memory\r\n  private sequenceCounters = new Map<string, number>();\r\n  // Shared file operation lock across all workspace file services\r\n  // This prevents deadlocks when services call each other (e.g., PartialService → HistoryService)\r\n  private readonly fileLocks = workspaceFileLocks;\r\n  private readonly config: Pick<Config, \"getSessionDir\">;\r\n\r\n  constructor(config: Pick<Config, \"getSessionDir\">) {\r\n    this.config = config;\r\n  }\r\n\r\n  private getChatHistoryPath(workspaceId: string): string {\r\n    return path.join(this.config.getSessionDir(workspaceId), this.CHAT_FILE);\r\n  }\r\n\r\n  // ── Reverse-read infrastructure ─────────────────────────────────────────────\r\n  // Reads chat.jsonl from the tail to avoid O(total-history) parsing on hot paths.\r\n  // \\n (0x0A) never appears inside multi-byte UTF-8 sequences, so chunked reverse\r\n  // reading is byte-safe. JSON.stringify escapes prevent false positives for the\r\n  // needle inside user-content strings.\r\n\r\n  /** Size of each chunk when scanning the file in reverse (256KB covers typical post-compaction content). */\r\n  private static readonly REVERSE_READ_CHUNK_SIZE = 256 * 1024;\r\n  /** String-search needle for compaction boundary lines. */\r\n  private static readonly BOUNDARY_NEEDLE = '\"compactionBoundary\":true';\r\n\r\n  /**\r\n   * Scan chat.jsonl in reverse to find the byte offset of a durable compaction boundary.\r\n   * Returns `null` when no (matching) boundary exists.\r\n   *\r\n   * @param skip How many boundaries to skip before returning. 0 = last boundary,\r\n   *             1 = second-to-last (penultimate), etc.\r\n   *\r\n   * Byte offsets are computed from raw \\n positions in the buffer (not from decoded string\r\n   * lengths) so that chunk boundaries splitting multi-byte UTF-8 sequences don't corrupt\r\n   * the returned offset.\r\n   */\r\n  private async findLastBoundaryByteOffset(workspaceId: string, skip = 0): Promise<number | null> {\r\n    const filePath = this.getChatHistoryPath(workspaceId);\r\n\r\n    let fileSize: number;\r\n    try {\r\n      const stat = await fs.stat(filePath);\r\n      fileSize = stat.size;\r\n    } catch {\r\n      return null;\r\n    }\r\n    if (fileSize === 0) return null;\r\n\r\n    const fh = await fs.open(filePath, \"r\");\r\n    try {\r\n      let readEnd = fileSize;\r\n      // Raw bytes of the incomplete first line from the previous (rightward) chunk.\r\n      // Kept as Buffer (not string) so multi-byte chars split at chunk boundaries\r\n      // don't corrupt byte offsets via UTF-8 replacement characters.\r\n      let carryoverBytes = Buffer.alloc(0);\r\n      let skipped = 0;\r\n\r\n      while (readEnd > 0) {\r\n        const readStart = Math.max(0, readEnd - HistoryService.REVERSE_READ_CHUNK_SIZE);\r\n        const chunkSize = readEnd - readStart;\r\n        const rawChunk = Buffer.alloc(chunkSize);\r\n        await fh.read(rawChunk, 0, chunkSize, readStart);\r\n\r\n        // Combine with carryover (the start of a line whose tail was in the previous chunk).\r\n        // The combined buffer represents contiguous file bytes [readStart, readStart + buffer.length).\r\n        const buffer =\r\n          carryoverBytes.length > 0 ? Buffer.concat([rawChunk, carryoverBytes]) : rawChunk;\r\n\r\n        // Find \\n byte positions in the raw buffer for accurate byte offsets.\r\n        // 0x0A never appears inside multi-byte UTF-8 sequences, so this is byte-safe\r\n        // even when a chunk boundary splits a multibyte character.\r\n        const newlinePositions: number[] = [];\r\n        for (let b = 0; b < buffer.length; b++) {\r\n          if (buffer[b] === 0x0a) {\r\n            newlinePositions.push(b);\r\n          }\r\n        }\r\n\r\n        if (newlinePositions.length === 0) {\r\n          // No newlines — entire buffer is one partial line, carry it all forward\r\n          carryoverBytes = Buffer.from(buffer);\r\n          readEnd = readStart;\r\n          continue;\r\n        }\r\n\r\n        // Bytes before the first \\n are an incomplete line — carry forward\r\n        carryoverBytes = Buffer.from(buffer.subarray(0, newlinePositions[0]));\r\n\r\n        // Scan complete lines in reverse. Each line occupies\r\n        // [newlinePositions[nl] + 1, nextNewline) in the buffer.\r\n        for (let nl = newlinePositions.length - 1; nl >= 0; nl--) {\r\n          const lineStart = newlinePositions[nl] + 1;\r\n          const lineEnd =\r\n            nl < newlinePositions.length - 1 ? newlinePositions[nl + 1] : buffer.length;\r\n          if (lineEnd <= lineStart) continue; // empty line\r\n\r\n          const line = buffer.subarray(lineStart, lineEnd).toString(\"utf-8\");\r\n          if (line.includes(HistoryService.BOUNDARY_NEEDLE)) {\r\n            try {\r\n              const msg = JSON.parse(line) as MuxMessage;\r\n              if (isDurableCompactionBoundaryMarker(msg)) {\r\n                if (skipped < skip) {\r\n                  skipped++;\r\n                } else {\r\n                  return readStart + lineStart;\r\n                }\r\n              }\r\n            } catch {\r\n              // Malformed line — not a real boundary, skip\r\n            }\r\n          }\r\n        }\r\n\r\n        readEnd = readStart;\r\n      }\r\n\r\n      // Check the very first line (accumulated in carryover)\r\n      if (carryoverBytes.length > 0) {\r\n        const line = carryoverBytes.toString(\"utf-8\");\r\n        if (line.includes(HistoryService.BOUNDARY_NEEDLE)) {\r\n          try {\r\n            const msg = JSON.parse(line) as MuxMessage;\r\n            if (isDurableCompactionBoundaryMarker(msg)) {\r\n              if (skipped < skip) {\r\n                // Not enough boundaries in the file to satisfy skip\r\n                return null;\r\n              }\r\n              return 0;\r\n            }\r\n          } catch {\r\n            // skip\r\n          }\r\n        }\r\n      }\r\n\r\n      return null;\r\n    } finally {\r\n      await fh.close();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read and parse messages from a byte offset to the end of chat.jsonl.\r\n   * Self-healing: skips malformed JSON lines the same way readChatHistory does.\r\n   */\r\n  private async readHistoryFromOffset(\r\n    workspaceId: string,\r\n    byteOffset: number\r\n  ): Promise<MuxMessage[]> {\r\n    const filePath = this.getChatHistoryPath(workspaceId);\r\n    const stat = await fs.stat(filePath);\r\n    const tailSize = stat.size - byteOffset;\r\n    if (tailSize <= 0) return [];\r\n\r\n    const fh = await fs.open(filePath, \"r\");\r\n    try {\r\n      const buffer = Buffer.alloc(tailSize);\r\n      await fh.read(buffer, 0, tailSize, byteOffset);\r\n      const lines = buffer\r\n        .toString(\"utf-8\")\r\n        .split(\"\\n\")\r\n        .filter((l) => l.trim());\r\n      const messages: MuxMessage[] = [];\r\n      for (const line of lines) {\r\n        try {\r\n          messages.push(normalizeLegacyMuxMetadata(JSON.parse(line) as MuxMessage));\r\n        } catch {\r\n          // Skip malformed lines — same self-healing behavior as readChatHistory\r\n        }\r\n      }\r\n      return messages;\r\n    } finally {\r\n      await fh.close();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the last N messages from chat.jsonl by scanning the file in reverse.\r\n   * Much cheaper than a full read when only the tail is needed.\r\n   *\r\n   * Uses raw byte scanning for \\n positions (same approach as findLastBoundaryByteOffset)\r\n   * so that chunk boundaries splitting multi-byte UTF-8 sequences don't corrupt lines.\r\n   */\r\n  private async readLastMessages(workspaceId: string, n: number): Promise<MuxMessage[]> {\r\n    const filePath = this.getChatHistoryPath(workspaceId);\r\n\r\n    let fileSize: number;\r\n    try {\r\n      const stat = await fs.stat(filePath);\r\n      fileSize = stat.size;\r\n    } catch {\r\n      return [];\r\n    }\r\n    if (fileSize === 0) return [];\r\n\r\n    const fh = await fs.open(filePath, \"r\");\r\n    try {\r\n      const collected: MuxMessage[] = [];\r\n      let readEnd = fileSize;\r\n      let carryoverBytes = Buffer.alloc(0);\r\n\r\n      while (readEnd > 0 && collected.length < n) {\r\n        const readStart = Math.max(0, readEnd - HistoryService.REVERSE_READ_CHUNK_SIZE);\r\n        const chunkSize = readEnd - readStart;\r\n        const rawChunk = Buffer.alloc(chunkSize);\r\n        await fh.read(rawChunk, 0, chunkSize, readStart);\r\n\r\n        const buffer =\r\n          carryoverBytes.length > 0 ? Buffer.concat([rawChunk, carryoverBytes]) : rawChunk;\r\n\r\n        const newlinePositions: number[] = [];\r\n        for (let b = 0; b < buffer.length; b++) {\r\n          if (buffer[b] === 0x0a) {\r\n            newlinePositions.push(b);\r\n          }\r\n        }\r\n\r\n        if (newlinePositions.length === 0) {\r\n          carryoverBytes = Buffer.from(buffer);\r\n          readEnd = readStart;\r\n          continue;\r\n        }\r\n\r\n        carryoverBytes = Buffer.from(buffer.subarray(0, newlinePositions[0]));\r\n\r\n        // Parse complete lines in reverse, stopping once we have enough\r\n        for (let nl = newlinePositions.length - 1; nl >= 0 && collected.length < n; nl--) {\r\n          const lineStart = newlinePositions[nl] + 1;\r\n          const lineEnd =\r\n            nl < newlinePositions.length - 1 ? newlinePositions[nl + 1] : buffer.length;\r\n          if (lineEnd <= lineStart) continue;\r\n\r\n          const line = buffer.subarray(lineStart, lineEnd).toString(\"utf-8\").trim();\r\n          if (line.length === 0) continue;\r\n          try {\r\n            collected.push(normalizeLegacyMuxMetadata(JSON.parse(line) as MuxMessage));\r\n          } catch {\r\n            // Skip malformed lines\r\n          }\r\n        }\r\n\r\n        readEnd = readStart;\r\n      }\r\n\r\n      // Check the very first line if we still need more\r\n      if (collected.length < n && carryoverBytes.length > 0) {\r\n        const line = carryoverBytes.toString(\"utf-8\").trim();\r\n        if (line.length > 0) {\r\n          try {\r\n            collected.push(normalizeLegacyMuxMetadata(JSON.parse(line) as MuxMessage));\r\n          } catch {\r\n            // skip\r\n          }\r\n        }\r\n      }\r\n\r\n      // Reverse to restore chronological order\r\n      collected.reverse();\r\n      return collected;\r\n    } finally {\r\n      await fh.close();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read raw messages from chat.jsonl (does not include partial.json)\r\n   * Returns empty array if file doesn't exist\r\n   * Skips malformed JSON lines to prevent data loss from corruption\r\n   */\r\n  private async readChatHistory(workspaceId: string): Promise<MuxMessage[]> {\r\n    try {\r\n      const chatHistoryPath = this.getChatHistoryPath(workspaceId);\r\n      const data = await fs.readFile(chatHistoryPath, \"utf-8\");\r\n      if (data.length > 5 * 1024 * 1024) {\r\n        log.warn(\"chat.jsonl exceeds 5MB — full read may be slow, consider compaction\", {\r\n          workspaceId,\r\n          sizeBytes: data.length,\r\n        });\r\n      }\r\n      const lines = data.split(\"\\n\").filter((line) => line.trim());\r\n      const messages: MuxMessage[] = [];\r\n\r\n      for (let i = 0; i < lines.length; i++) {\r\n        try {\r\n          const message = JSON.parse(lines[i]) as MuxMessage;\r\n          messages.push(normalizeLegacyMuxMetadata(message));\r\n        } catch (parseError) {\r\n          // Skip malformed lines but log error for debugging\r\n          log.warn(\r\n            `Skipping malformed JSON at line ${i + 1} in ${workspaceId}/chat.jsonl:`,\r\n            parseError instanceof Error ? parseError.message : String(parseError),\r\n            \"\\nLine content:\",\r\n            lines[i].substring(0, 100) + (lines[i].length > 100 ? \"...\" : \"\")\r\n          );\r\n        }\r\n      }\r\n\r\n      return messages;\r\n    } catch (error) {\r\n      if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\r\n        return []; // No history yet\r\n      }\r\n      throw error; // Re-throw non-ENOENT errors\r\n    }\r\n  }\r\n\r\n  // ── Forward/backward iteration infrastructure ────────────────────────────\r\n  // Chunked iteration over chat.jsonl that yields messages to a visitor callback.\r\n  // Supports early exit (return false) and reduces memory pressure vs. loading\r\n  // the entire file into an array.\r\n\r\n  /**\r\n   * Read chat.jsonl from start to end in chunks, calling visitor with each\r\n   * batch of parsed messages. Uses raw byte scanning for \\n to handle\r\n   * multi-byte UTF-8 safely at chunk boundaries.\r\n   */\r\n  private async iterateForward(\r\n    workspaceId: string,\r\n    visitor: (messages: MuxMessage[]) => boolean | void | Promise<boolean | void>\r\n  ): Promise<void> {\r\n    const filePath = this.getChatHistoryPath(workspaceId);\r\n\r\n    let fileSize: number;\r\n    try {\r\n      const stat = await fs.stat(filePath);\r\n      fileSize = stat.size;\r\n    } catch (error) {\r\n      if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\r\n        return; // No history\r\n      }\r\n      throw error;\r\n    }\r\n    if (fileSize === 0) return;\r\n\r\n    const fh = await fs.open(filePath, \"r\");\r\n    try {\r\n      let readPos = 0;\r\n      // Incomplete last line from the previous chunk, kept as Buffer to\r\n      // preserve split multi-byte UTF-8 sequences.\r\n      let carryoverBytes = Buffer.alloc(0);\r\n\r\n      while (readPos < fileSize) {\r\n        const remaining = fileSize - readPos;\r\n        const toRead = Math.min(HistoryService.REVERSE_READ_CHUNK_SIZE, remaining);\r\n        const rawChunk = Buffer.alloc(toRead);\r\n        await fh.read(rawChunk, 0, toRead, readPos);\r\n        readPos += toRead;\r\n\r\n        const buffer =\r\n          carryoverBytes.length > 0 ? Buffer.concat([carryoverBytes, rawChunk]) : rawChunk;\r\n\r\n        // Find the last \\n to split complete lines from the trailing incomplete line.\r\n        // 0x0A is byte-safe (never inside multi-byte UTF-8 sequences).\r\n        let lastNewline = -1;\r\n        for (let b = buffer.length - 1; b >= 0; b--) {\r\n          if (buffer[b] === 0x0a) {\r\n            lastNewline = b;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (lastNewline === -1) {\r\n          // No newline in entire buffer — carry everything forward\r\n          carryoverBytes = Buffer.from(buffer);\r\n          continue;\r\n        }\r\n\r\n        // Decode only complete lines (up to and including the last \\n)\r\n        const completeText = buffer.subarray(0, lastNewline).toString(\"utf-8\");\r\n        carryoverBytes = Buffer.from(buffer.subarray(lastNewline + 1));\r\n\r\n        const messages: MuxMessage[] = [];\r\n        for (const line of completeText.split(\"\\n\")) {\r\n          const trimmed = line.trim();\r\n          if (trimmed.length === 0) continue;\r\n          try {\r\n            messages.push(normalizeLegacyMuxMetadata(JSON.parse(trimmed) as MuxMessage));\r\n          } catch {\r\n            // Skip malformed lines — same self-healing behavior as readChatHistory\r\n          }\r\n        }\r\n\r\n        if (messages.length > 0) {\r\n          const shouldContinue = await visitor(messages);\r\n          if (shouldContinue === false) return;\r\n        }\r\n      }\r\n\r\n      // Handle remaining carryover (last line without trailing newline)\r\n      if (carryoverBytes.length > 0) {\r\n        const line = carryoverBytes.toString(\"utf-8\").trim();\r\n        if (line.length > 0) {\r\n          try {\r\n            const msg = normalizeLegacyMuxMetadata(JSON.parse(line) as MuxMessage);\r\n            await visitor([msg]);\r\n          } catch {\r\n            // Skip malformed line\r\n          }\r\n        }\r\n      }\r\n    } finally {\r\n      await fh.close();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read chat.jsonl from end to start in chunks, calling visitor with each\r\n   * batch of parsed messages (newest first within each chunk). Uses the same\r\n   * raw-byte \\n scanning as findLastBoundaryByteOffset.\r\n   */\r\n  private async iterateBackward(\r\n    workspaceId: string,\r\n    visitor: (messages: MuxMessage[]) => boolean | void | Promise<boolean | void>\r\n  ): Promise<void> {\r\n    const filePath = this.getChatHistoryPath(workspaceId);\r\n\r\n    let fileSize: number;\r\n    try {\r\n      const stat = await fs.stat(filePath);\r\n      fileSize = stat.size;\r\n    } catch (error) {\r\n      if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\r\n        return; // No history\r\n      }\r\n      throw error;\r\n    }\r\n    if (fileSize === 0) return;\r\n\r\n    const fh = await fs.open(filePath, \"r\");\r\n    try {\r\n      let readEnd = fileSize;\r\n      let carryoverBytes = Buffer.alloc(0);\r\n\r\n      while (readEnd > 0) {\r\n        const readStart = Math.max(0, readEnd - HistoryService.REVERSE_READ_CHUNK_SIZE);\r\n        const chunkSize = readEnd - readStart;\r\n        const rawChunk = Buffer.alloc(chunkSize);\r\n        await fh.read(rawChunk, 0, chunkSize, readStart);\r\n\r\n        const buffer =\r\n          carryoverBytes.length > 0 ? Buffer.concat([rawChunk, carryoverBytes]) : rawChunk;\r\n\r\n        const newlinePositions: number[] = [];\r\n        for (let b = 0; b < buffer.length; b++) {\r\n          if (buffer[b] === 0x0a) {\r\n            newlinePositions.push(b);\r\n          }\r\n        }\r\n\r\n        if (newlinePositions.length === 0) {\r\n          carryoverBytes = Buffer.from(buffer);\r\n          readEnd = readStart;\r\n          continue;\r\n        }\r\n\r\n        carryoverBytes = Buffer.from(buffer.subarray(0, newlinePositions[0]));\r\n\r\n        // Parse complete lines in reverse (newest → oldest for backward iteration)\r\n        const messages: MuxMessage[] = [];\r\n        for (let nl = newlinePositions.length - 1; nl >= 0; nl--) {\r\n          const lineStart = newlinePositions[nl] + 1;\r\n          const lineEnd =\r\n            nl < newlinePositions.length - 1 ? newlinePositions[nl + 1] : buffer.length;\r\n          if (lineEnd <= lineStart) continue;\r\n\r\n          const line = buffer.subarray(lineStart, lineEnd).toString(\"utf-8\").trim();\r\n          if (line.length === 0) continue;\r\n          try {\r\n            messages.push(normalizeLegacyMuxMetadata(JSON.parse(line) as MuxMessage));\r\n          } catch {\r\n            // Skip malformed lines\r\n          }\r\n        }\r\n\r\n        if (messages.length > 0) {\r\n          const shouldContinue = await visitor(messages);\r\n          if (shouldContinue === false) return;\r\n        }\r\n\r\n        readEnd = readStart;\r\n      }\r\n\r\n      // Check the very first line (accumulated in carryover)\r\n      if (carryoverBytes.length > 0) {\r\n        const line = carryoverBytes.toString(\"utf-8\").trim();\r\n        if (line.length > 0) {\r\n          try {\r\n            const msg = normalizeLegacyMuxMetadata(JSON.parse(line) as MuxMessage);\r\n            await visitor([msg]);\r\n          } catch {\r\n            // Skip malformed line\r\n          }\r\n        }\r\n      }\r\n    } finally {\r\n      await fh.close();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Iterate over ALL messages in chat.jsonl — O(file-size) I/O + parse.\r\n   *\r\n   * ⚠️  Prefer targeted alternatives for hot paths:\r\n   *   - getHistoryFromLatestBoundary() — for provider-request assembly\r\n   *   - getLastMessages(n)            — when only the tail matters\r\n   *   - hasHistory()                  — for emptiness checks\r\n   *\r\n   * Yields chunks of parsed messages to the visitor callback. The visitor may\r\n   * return `false` to stop iteration early (e.g., after finding a target message).\r\n   *\r\n   * @param direction - 'forward' reads oldest→newest, 'backward' reads newest→oldest\r\n   * @param visitor - Called with each chunk of messages. Return false to stop early.\r\n   */\r\n  async iterateFullHistory(\r\n    workspaceId: string,\r\n    direction: \"forward\" | \"backward\",\r\n    visitor: (messages: MuxMessage[]) => boolean | void | Promise<boolean | void>\r\n  ): Promise<Result<void>> {\r\n    try {\r\n      if (direction === \"forward\") {\r\n        await this.iterateForward(workspaceId, visitor);\r\n      } else {\r\n        await this.iterateBackward(workspaceId, visitor);\r\n      }\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      return Err(`Failed to iterate history: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read messages from a compaction boundary onward.\r\n   * Falls back to full history if no boundary exists (new/uncompacted workspace).\r\n   *\r\n   * @param skip How many boundaries to skip (counting from the latest). 0 = read\r\n   *             from the latest boundary, 1 = from the penultimate, etc. When the\r\n   *             requested boundary doesn't exist, falls back to the next-available\r\n   *             boundary, then to full history.\r\n   *\r\n   * Prefer this over iterateFullHistory() for provider-request assembly and any path\r\n   * that only needs the active compaction epoch.\r\n   */\r\n  async getHistoryFromLatestBoundary(workspaceId: string, skip = 0): Promise<Result<MuxMessage[]>> {\r\n    try {\r\n      // Try the requested boundary, falling back to less-skipped boundaries\r\n      for (let s = skip; s >= 0; s--) {\r\n        const offset = await this.findLastBoundaryByteOffset(workspaceId, s);\r\n        if (offset !== null) {\r\n          const messages = await this.readHistoryFromOffset(workspaceId, offset);\r\n          return Ok(messages);\r\n        }\r\n      }\r\n\r\n      // No boundaries at all — workspace is uncompacted, full read is the only option\r\n      const messages = await this.readChatHistory(workspaceId);\r\n      return Ok(messages);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      return Err(`Failed to read history from boundary: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the last N messages from chat.jsonl by reading the file in reverse.\r\n   * Much cheaper than iterateFullHistory() when only the tail is needed.\r\n   */\r\n  async getLastMessages(workspaceId: string, n: number): Promise<Result<MuxMessage[]>> {\r\n    try {\r\n      const messages = await this.readLastMessages(workspaceId, n);\r\n      return Ok(messages);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      return Err(`Failed to read last ${n} messages: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a workspace has any chat history without parsing the file.\r\n   * Much cheaper than iterateFullHistory() when only an emptiness check is needed.\r\n   */\r\n  async hasHistory(workspaceId: string): Promise<boolean> {\r\n    const filePath = this.getChatHistoryPath(workspaceId);\r\n    try {\r\n      const stat = await fs.stat(filePath);\r\n      return stat.size > 0;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get or initialize the next history sequence number for a workspace\r\n   */\r\n  private async getNextHistorySequence(workspaceId: string): Promise<number> {\r\n    // Check if we already have it in memory\r\n    if (this.sequenceCounters.has(workspaceId)) {\r\n      return this.sequenceCounters.get(workspaceId)!;\r\n    }\r\n\r\n    // Initialize from history — sequence numbers are monotonically increasing,\r\n    // so the last message always holds the max. Use getLastMessages(1) to avoid\r\n    // reading the entire file.\r\n    const lastResult = await this.getLastMessages(workspaceId, 1);\r\n    if (lastResult.success && lastResult.data.length > 0) {\r\n      const lastMsg = lastResult.data[0];\r\n      const seqNum = lastMsg.metadata?.historySequence;\r\n      if (isNonNegativeInteger(seqNum)) {\r\n        const nextSeqNum = seqNum + 1;\r\n        this.sequenceCounters.set(workspaceId, nextSeqNum);\r\n        return nextSeqNum;\r\n      }\r\n      // Last message has no valid sequence — fall back to scanning backward\r\n      // through all messages to find the max (handles legacy data).\r\n      let maxSeqNum = -1;\r\n      const scanResult = await this.iterateFullHistory(workspaceId, \"backward\", (chunk) => {\r\n        for (const msg of chunk) {\r\n          const seq = msg.metadata?.historySequence;\r\n          if (isNonNegativeInteger(seq)) {\r\n            maxSeqNum = Math.max(maxSeqNum, seq);\r\n            // Found a valid sequence — it's the max since we're scanning backward\r\n            return false;\r\n          }\r\n        }\r\n      });\r\n      if (scanResult.success) {\r\n        const nextSeqNum = maxSeqNum + 1;\r\n        assert(\r\n          isNonNegativeInteger(nextSeqNum),\r\n          \"next history sequence counter must be a non-negative integer\"\r\n        );\r\n        this.sequenceCounters.set(workspaceId, nextSeqNum);\r\n        return nextSeqNum;\r\n      }\r\n    }\r\n\r\n    // No history yet, start from 0\r\n    this.sequenceCounters.set(workspaceId, 0);\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Internal helper for appending to history without acquiring lock\r\n   * Used by both appendToHistory and commitPartial to avoid deadlock\r\n   */\r\n  private async _appendToHistoryUnlocked(\r\n    workspaceId: string,\r\n    message: MuxMessage\r\n  ): Promise<Result<void>> {\r\n    try {\r\n      const workspaceDir = this.config.getSessionDir(workspaceId);\r\n      await fs.mkdir(workspaceDir, { recursive: true });\r\n      const historyPath = this.getChatHistoryPath(workspaceId);\r\n\r\n      // DEBUG: Log message append with caller stack trace\r\n      const stack = new Error().stack?.split(\"\\n\").slice(2, 6).join(\"\\n\") ?? \"no stack\";\r\n      log.debug(\r\n        `[HISTORY APPEND] workspaceId=${workspaceId} role=${message.role} id=${message.id}`\r\n      );\r\n      log.debug(`[HISTORY APPEND] Call stack:\\n${stack}`);\r\n\r\n      // Ensure message has a history sequence number\r\n      if (!message.metadata) {\r\n        // Create metadata with history sequence\r\n        const nextSeqNum = await this.getNextHistorySequence(workspaceId);\r\n        assert(\r\n          isNonNegativeInteger(nextSeqNum),\r\n          \"getNextHistorySequence must return a non-negative integer\"\r\n        );\r\n        message.metadata = {\r\n          historySequence: nextSeqNum,\r\n        };\r\n        this.sequenceCounters.set(workspaceId, nextSeqNum + 1);\r\n      } else {\r\n        // Message already has metadata, but may need historySequence assigned\r\n        const existingSeqNum = message.metadata.historySequence;\r\n        if (existingSeqNum !== undefined) {\r\n          assert(\r\n            isNonNegativeInteger(existingSeqNum),\r\n            \"appendToHistory requires historySequence to be a non-negative integer when provided\"\r\n          );\r\n\r\n          // Already has history sequence, update counter if needed\r\n          const currentCounter = this.sequenceCounters.get(workspaceId) ?? 0;\r\n          assert(\r\n            isNonNegativeInteger(currentCounter),\r\n            \"history sequence counter must remain a non-negative integer\"\r\n          );\r\n          if (existingSeqNum >= currentCounter) {\r\n            this.sequenceCounters.set(workspaceId, existingSeqNum + 1);\r\n          }\r\n        } else {\r\n          // Has metadata but no historySequence, assign one\r\n          const nextSeqNum = await this.getNextHistorySequence(workspaceId);\r\n          assert(\r\n            isNonNegativeInteger(nextSeqNum),\r\n            \"getNextHistorySequence must return a non-negative integer\"\r\n          );\r\n          message.metadata = {\r\n            ...message.metadata,\r\n            historySequence: nextSeqNum,\r\n          };\r\n          this.sequenceCounters.set(workspaceId, nextSeqNum + 1);\r\n        }\r\n      }\r\n\r\n      // Store the message with workspace context\r\n      const historyEntry = {\r\n        ...message,\r\n        workspaceId,\r\n      };\r\n\r\n      // DEBUG: Log assigned sequence number\r\n      log.debug(\r\n        `[HISTORY APPEND] Assigned historySequence=${message.metadata.historySequence ?? \"unknown\"} role=${message.role}`\r\n      );\r\n\r\n      await fs.appendFile(historyPath, JSON.stringify(historyEntry) + \"\\n\");\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      return Err(`Failed to append to history: ${message}`);\r\n    }\r\n  }\r\n\r\n  async appendToHistory(workspaceId: string, message: MuxMessage): Promise<Result<void>> {\r\n    return this.fileLocks.withLock(workspaceId, async () => {\r\n      return this._appendToHistoryUnlocked(workspaceId, message);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update an existing message in history by historySequence\r\n   * Reads entire history, replaces the matching message, and rewrites the file\r\n   */\r\n  async updateHistory(workspaceId: string, message: MuxMessage): Promise<Result<void>> {\r\n    return this.fileLocks.withLock(workspaceId, async () => {\r\n      try {\r\n        const historyPath = this.getChatHistoryPath(workspaceId);\r\n\r\n        // Read all messages — structural rewrite requires full file content\r\n        const messages = await this.readChatHistory(workspaceId);\r\n        const targetSequence = message.metadata?.historySequence;\r\n\r\n        if (targetSequence === undefined) {\r\n          return Err(\"Cannot update message without historySequence\");\r\n        }\r\n\r\n        assert(\r\n          isNonNegativeInteger(targetSequence),\r\n          \"updateHistory requires historySequence to be a non-negative integer\"\r\n        );\r\n\r\n        // Find and replace the message with matching historySequence\r\n        let found = false;\r\n        for (let i = 0; i < messages.length; i++) {\r\n          if (messages[i].metadata?.historySequence === targetSequence) {\r\n            const existingMessage = messages[i];\r\n            assert(existingMessage, \"updateHistory matched message must exist\");\r\n\r\n            // Preserve compaction boundary metadata during late in-place rewrites.\r\n            // Compaction may update an assistant row first, then a late stream rewrite can\r\n            // update that same historySequence and accidentally drop compaction markers.\r\n            const preservedCompactionMetadata = getCompactionMetadataToPreserve(\r\n              workspaceId,\r\n              existingMessage,\r\n              message\r\n            );\r\n\r\n            // Preserve the historySequence, update everything else.\r\n            messages[i] = {\r\n              ...message,\r\n              metadata: {\r\n                ...message.metadata,\r\n                ...(preservedCompactionMetadata ?? {}),\r\n                historySequence: targetSequence,\r\n              },\r\n            };\r\n            found = true;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (!found) {\r\n          return Err(`No message found with historySequence ${targetSequence}`);\r\n        }\r\n\r\n        // Rewrite entire file\r\n        const historyEntries = messages\r\n          .map((msg) => JSON.stringify({ ...msg, workspaceId }) + \"\\n\")\r\n          .join(\"\");\r\n\r\n        // Atomic write prevents corruption if app crashes mid-write\r\n        await writeFileAtomic(historyPath, historyEntries);\r\n        return Ok(undefined);\r\n      } catch (error) {\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        return Err(`Failed to update history: ${message}`);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Delete a single message by ID while preserving the rest of the history.\r\n   *\r\n   * This is safer than truncateAfterMessage for cleanup paths where subsequent\r\n   * messages may already have been appended.\r\n   */\r\n  async deleteMessage(workspaceId: string, messageId: string): Promise<Result<void>> {\r\n    return this.fileLocks.withLock(workspaceId, async () => {\r\n      try {\r\n        // Structural rewrite requires full file content\r\n        const messages = await this.readChatHistory(workspaceId);\r\n        const filteredMessages = messages.filter((msg) => msg.id !== messageId);\r\n\r\n        if (filteredMessages.length === messages.length) {\r\n          return Err(`Message with ID ${messageId} not found in history`);\r\n        }\r\n\r\n        const historyPath = this.getChatHistoryPath(workspaceId);\r\n        const historyEntries = filteredMessages\r\n          .map((msg) => JSON.stringify({ ...msg, workspaceId }) + \"\\n\")\r\n          .join(\"\");\r\n\r\n        // Atomic write prevents corruption if app crashes mid-write\r\n        await writeFileAtomic(historyPath, historyEntries);\r\n\r\n        // Keep the in-memory sequence counter monotonic. It's okay to reuse deleted sequence\r\n        // numbers on restart, but we must not regress within a running process.\r\n        const maxSeq = filteredMessages.reduce((max, msg) => {\r\n          const seq = msg.metadata?.historySequence;\r\n          if (seq === undefined) {\r\n            return max;\r\n          }\r\n\r\n          if (!isNonNegativeInteger(seq)) {\r\n            log.warn(\r\n              \"Ignoring malformed persisted historySequence while updating sequence counter after delete\",\r\n              {\r\n                workspaceId,\r\n                messageId: msg.id,\r\n                historySequence: seq,\r\n              }\r\n            );\r\n            return max;\r\n          }\r\n\r\n          return seq > max ? seq : max;\r\n        }, -1);\r\n        const nextSeq = maxSeq + 1;\r\n        assert(\r\n          isNonNegativeInteger(nextSeq),\r\n          \"next history sequence counter after delete must be a non-negative integer\"\r\n        );\r\n        const currentCounter = this.sequenceCounters.get(workspaceId);\r\n        if (currentCounter === undefined || currentCounter < nextSeq) {\r\n          this.sequenceCounters.set(workspaceId, nextSeq);\r\n        }\r\n\r\n        return Ok(undefined);\r\n      } catch (error) {\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        return Err(`Failed to delete message: ${message}`);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Truncate history after a specific message ID\r\n   * Removes the message with the given ID and all subsequent messages\r\n   */\r\n  async truncateAfterMessage(workspaceId: string, messageId: string): Promise<Result<void>> {\r\n    return this.fileLocks.withLock(workspaceId, async () => {\r\n      try {\r\n        // Structural rewrite requires full file content\r\n        const messages = await this.readChatHistory(workspaceId);\r\n        const messageIndex = messages.findIndex((msg) => msg.id === messageId);\r\n\r\n        if (messageIndex === -1) {\r\n          return Err(`Message with ID ${messageId} not found in history`);\r\n        }\r\n\r\n        // Keep only messages before the target message\r\n        const truncatedMessages = messages.slice(0, messageIndex);\r\n\r\n        // Rewrite the history file with truncated messages\r\n        const historyPath = this.getChatHistoryPath(workspaceId);\r\n        const historyEntries = truncatedMessages\r\n          .map((msg) => JSON.stringify({ ...msg, workspaceId }) + \"\\n\")\r\n          .join(\"\");\r\n\r\n        // Atomic write prevents corruption if app crashes mid-write\r\n        await writeFileAtomic(historyPath, historyEntries);\r\n\r\n        // Update sequence counter to continue from where we truncated.\r\n        // Self-healing read path: skip malformed persisted historySequence values.\r\n        const maxTruncatedSeq = truncatedMessages.reduce((max, msg) => {\r\n          const seq = msg.metadata?.historySequence;\r\n          if (seq === undefined) {\r\n            return max;\r\n          }\r\n\r\n          if (!isNonNegativeInteger(seq)) {\r\n            log.warn(\r\n              \"Ignoring malformed persisted historySequence while updating sequence counter after truncation\",\r\n              {\r\n                workspaceId,\r\n                messageId: msg.id,\r\n                historySequence: seq,\r\n              }\r\n            );\r\n            return max;\r\n          }\r\n\r\n          return seq > max ? seq : max;\r\n        }, -1);\r\n        const nextSeq = maxTruncatedSeq + 1;\r\n        assert(\r\n          isNonNegativeInteger(nextSeq),\r\n          \"next history sequence counter after truncation must be a non-negative integer\"\r\n        );\r\n        this.sequenceCounters.set(workspaceId, nextSeq);\r\n\r\n        return Ok(undefined);\r\n      } catch (error) {\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        return Err(`Failed to truncate history: ${message}`);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Truncate history by removing approximately the given percentage of tokens from the beginning\r\n   * @param workspaceId The workspace ID\r\n   * @param percentage Percentage to truncate (0.0 to 1.0). 1.0 = delete all\r\n   * @returns Result containing array of deleted historySequence numbers\r\n   */\r\n  async truncateHistory(\r\n    workspaceId: string,\r\n    percentage: number\r\n  ): Promise<Result<number[], string>> {\r\n    return this.fileLocks.withLock(workspaceId, async () => {\r\n      try {\r\n        const historyPath = this.getChatHistoryPath(workspaceId);\r\n\r\n        // Fast path: 100% truncation = delete entire file\r\n        if (percentage >= 1.0) {\r\n          // Need sequence numbers for return value before deleting\r\n          const messages = await this.readChatHistory(workspaceId);\r\n          const deletedSequences = messages\r\n            .map((msg) => msg.metadata?.historySequence)\r\n            .filter((s): s is number => isNonNegativeInteger(s));\r\n\r\n          try {\r\n            await fs.unlink(historyPath);\r\n          } catch (error) {\r\n            // Ignore ENOENT - file already deleted\r\n            if (\r\n              !(error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\")\r\n            ) {\r\n              throw error;\r\n            }\r\n          }\r\n\r\n          // Reset sequence counter when clearing history\r\n          this.sequenceCounters.set(workspaceId, 0);\r\n          return Ok(deletedSequences);\r\n        }\r\n\r\n        // Structural rewrite requires full file content\r\n        const messages = await this.readChatHistory(workspaceId);\r\n        if (messages.length === 0) {\r\n          return Ok([]); // Nothing to truncate\r\n        }\r\n\r\n        // Get tokenizer for counting (use a default model)\r\n        const tokenizer = await getTokenizerForModel(KNOWN_MODELS.SONNET.id);\r\n\r\n        // Count tokens for each message\r\n        // We stringify the entire message for simplicity - only relative weights matter\r\n        const messageTokens: Array<{ message: MuxMessage; tokens: number }> = await Promise.all(\r\n          messages.map(async (msg) => {\r\n            const tokens = await tokenizer.countTokens(safeStringifyForCounting(msg));\r\n            return { message: msg, tokens };\r\n          })\r\n        );\r\n\r\n        // Calculate total tokens and target to remove\r\n        const totalTokens = messageTokens.reduce((sum, mt) => sum + mt.tokens, 0);\r\n        const tokensToRemove = Math.floor(totalTokens * percentage);\r\n\r\n        // Remove messages from beginning until we've removed enough tokens\r\n        let tokensRemoved = 0;\r\n        let removeCount = 0;\r\n        for (const mt of messageTokens) {\r\n          if (tokensRemoved >= tokensToRemove) {\r\n            break;\r\n          }\r\n          tokensRemoved += mt.tokens;\r\n          removeCount++;\r\n        }\r\n\r\n        // If we're removing all messages, use fast path\r\n        if (removeCount >= messages.length) {\r\n          try {\r\n            await fs.unlink(historyPath);\r\n          } catch (error) {\r\n            // Ignore ENOENT\r\n            if (\r\n              !(error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\")\r\n            ) {\r\n              throw error;\r\n            }\r\n          }\r\n          this.sequenceCounters.set(workspaceId, 0);\r\n          const deletedSequences = messages\r\n            .map((msg) => msg.metadata?.historySequence)\r\n            .filter((s): s is number => isNonNegativeInteger(s));\r\n          return Ok(deletedSequences);\r\n        }\r\n\r\n        // Keep messages after removeCount\r\n        const remainingMessages = messages.slice(removeCount);\r\n        const deletedMessages = messages.slice(0, removeCount);\r\n        const deletedSequences = deletedMessages\r\n          .map((msg) => msg.metadata?.historySequence)\r\n          .filter((s): s is number => isNonNegativeInteger(s));\r\n\r\n        // Rewrite the history file with remaining messages\r\n        const historyEntries = remainingMessages\r\n          .map((msg) => JSON.stringify({ ...msg, workspaceId }) + \"\\n\")\r\n          .join(\"\");\r\n\r\n        // Atomic write prevents corruption if app crashes mid-write\r\n        await writeFileAtomic(historyPath, historyEntries);\r\n\r\n        // Update sequence counter to continue from where we are.\r\n        // Self-healing read path: skip malformed persisted historySequence values.\r\n        const maxRemainingSeq = remainingMessages.reduce((max, msg) => {\r\n          const seq = msg.metadata?.historySequence;\r\n          if (seq === undefined) {\r\n            return max;\r\n          }\r\n\r\n          if (!isNonNegativeInteger(seq)) {\r\n            log.warn(\r\n              \"Ignoring malformed persisted historySequence while updating sequence counter after truncateHistory\",\r\n              {\r\n                workspaceId,\r\n                messageId: msg.id,\r\n                historySequence: seq,\r\n              }\r\n            );\r\n            return max;\r\n          }\r\n\r\n          return seq > max ? seq : max;\r\n        }, -1);\r\n        const nextSeq = maxRemainingSeq + 1;\r\n        assert(\r\n          isNonNegativeInteger(nextSeq),\r\n          \"next history sequence counter after truncateHistory must be a non-negative integer\"\r\n        );\r\n        this.sequenceCounters.set(workspaceId, nextSeq);\r\n\r\n        return Ok(deletedSequences);\r\n      } catch (error) {\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        return Err(`Failed to truncate history: ${message}`);\r\n      }\r\n    });\r\n  }\r\n\r\n  async clearHistory(workspaceId: string): Promise<Result<number[], string>> {\r\n    const result = await this.truncateHistory(workspaceId, 1.0);\r\n    if (!result.success) {\r\n      return Err(result.error);\r\n    }\r\n    return Ok(result.data);\r\n  }\r\n\r\n  /**\r\n   * Migrate all messages in chat.jsonl to use a new workspace ID\r\n   * This is used during workspace rename to update the workspaceId field in all historical messages\r\n   * IMPORTANT: Should be called AFTER the session directory has been renamed\r\n   */\r\n  async migrateWorkspaceId(oldWorkspaceId: string, newWorkspaceId: string): Promise<Result<void>> {\r\n    return this.fileLocks.withLock(newWorkspaceId, async () => {\r\n      try {\r\n        // Read messages from the NEW workspace location (directory was already renamed).\r\n        // Structural rewrite requires full file content.\r\n        const messages = await this.readChatHistory(newWorkspaceId);\r\n        if (messages.length === 0) {\r\n          // No messages to migrate, just transfer sequence counter\r\n          const oldCounter = this.sequenceCounters.get(oldWorkspaceId) ?? 0;\r\n          this.sequenceCounters.set(newWorkspaceId, oldCounter);\r\n          this.sequenceCounters.delete(oldWorkspaceId);\r\n          return Ok(undefined);\r\n        }\r\n\r\n        // Rewrite all messages with new workspace ID\r\n        const newHistoryPath = this.getChatHistoryPath(newWorkspaceId);\r\n        const historyEntries = messages\r\n          .map((msg) => JSON.stringify({ ...msg, workspaceId: newWorkspaceId }) + \"\\n\")\r\n          .join(\"\");\r\n\r\n        // Atomic write prevents corruption if app crashes mid-write\r\n        await writeFileAtomic(newHistoryPath, historyEntries);\r\n\r\n        // Transfer sequence counter to new workspace ID\r\n        const oldCounter = this.sequenceCounters.get(oldWorkspaceId) ?? 0;\r\n        this.sequenceCounters.set(newWorkspaceId, oldCounter);\r\n        this.sequenceCounters.delete(oldWorkspaceId);\r\n\r\n        log.debug(\r\n          `Migrated ${messages.length} messages from ${oldWorkspaceId} to ${newWorkspaceId}`\r\n        );\r\n\r\n        return Ok(undefined);\r\n      } catch (error) {\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        return Err(`Failed to migrate workspace ID: ${message}`);\r\n      }\r\n    });\r\n  }\r\n}\r\n"]}