{"version":3,"file":"historyService.js","sourceRoot":"","sources":["../../../src/node/services/historyService.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport writeFileAtomic from \"write-file-atomic\";\nimport assert from \"node:assert\";\nimport type { Result } from \"@/common/types/result\";\nimport { Ok, Err } from \"@/common/types/result\";\nimport {\n  isCompactionSummaryMetadata,\n  type MuxMessage,\n  type MuxMetadata,\n} from \"@/common/types/message\";\nimport type { Config } from \"@/node/config\";\nimport { workspaceFileLocks } from \"@/node/utils/concurrency/workspaceFileLocks\";\nimport { log } from \"./log\";\nimport { getTokenizerForModel } from \"@/node/utils/main/tokenizer\";\nimport { KNOWN_MODELS } from \"@/common/constants/knownModels\";\nimport { safeStringifyForCounting } from \"@/common/utils/tokens/safeStringifyForCounting\";\nimport { normalizeLegacyMuxMetadata } from \"@/node/utils/messages/legacy\";\nimport { isDurableCompactionBoundaryMarker } from \"@/common/utils/messages/compactionBoundary\";\n\nfunction isPositiveInteger(value: unknown): value is number {\n  return (\n    typeof value === \"number\" && Number.isFinite(value) && Number.isInteger(value) && value > 0\n  );\n}\n\nfunction isNonNegativeInteger(value: unknown): value is number {\n  return (\n    typeof value === \"number\" && Number.isFinite(value) && Number.isInteger(value) && value >= 0\n  );\n}\n\nfunction hasDurableCompactedMarker(value: unknown): value is true | \"user\" | \"idle\" {\n  return value === true || value === \"user\" || value === \"idle\";\n}\n\nfunction hasDurableCompactionBoundary(metadata: MuxMetadata | undefined): boolean {\n  if (metadata?.compactionBoundary !== true) {\n    return false;\n  }\n\n  // Self-healing read path: malformed boundary markers should be ignored.\n  if (!hasDurableCompactedMarker(metadata.compacted)) {\n    return false;\n  }\n\n  return isPositiveInteger(metadata.compactionEpoch);\n}\n\nfunction getCompactionMetadataToPreserve(\n  workspaceId: string,\n  existingMessage: MuxMessage,\n  incomingMessage: MuxMessage\n): Partial<MuxMetadata> | null {\n  const existingMetadata = existingMessage.metadata;\n  if (existingMetadata?.compactionBoundary !== true) {\n    return null;\n  }\n\n  if (existingMessage.role !== \"assistant\") {\n    // Self-healing read path: boundary metadata on non-assistant rows is invalid.\n    log.warn(\"Skipping malformed persisted compaction boundary during history update\", {\n      workspaceId,\n      messageId: existingMessage.id,\n      reason: \"compactionBoundary set on non-assistant message\",\n    });\n    return null;\n  }\n\n  if (incomingMessage.role !== \"assistant\") {\n    return null;\n  }\n\n  if (!hasDurableCompactionBoundary(existingMetadata)) {\n    // Self-healing read path: malformed boundary metadata should not be propagated.\n    log.warn(\"Skipping malformed persisted compaction boundary during history update\", {\n      workspaceId,\n      messageId: existingMessage.id,\n      reason: \"compactionBoundary missing valid compacted+compactionEpoch metadata\",\n    });\n    return null;\n  }\n\n  if (hasDurableCompactionBoundary(incomingMessage.metadata)) {\n    return null;\n  }\n\n  const preserved: Partial<MuxMetadata> = {\n    compacted: existingMetadata.compacted,\n    compactionBoundary: true,\n    compactionEpoch: existingMetadata.compactionEpoch,\n  };\n\n  if (\n    isCompactionSummaryMetadata(existingMetadata.muxMetadata) &&\n    !isCompactionSummaryMetadata(incomingMessage.metadata?.muxMetadata)\n  ) {\n    preserved.muxMetadata = existingMetadata.muxMetadata;\n  }\n\n  return preserved;\n}\n/**\n * HistoryService - Manages chat history persistence and sequence numbering\n *\n * Responsibilities:\n * - Read/write chat history to disk (JSONL format)\n * - Assign sequence numbers to messages (single source of truth)\n * - Track next sequence number per workspace\n */\nexport class HistoryService {\n  private readonly CHAT_FILE = \"chat.jsonl\";\n  // Track next sequence number per workspace in memory\n  private sequenceCounters = new Map<string, number>();\n  // Shared file operation lock across all workspace file services\n  // This prevents deadlocks when services call each other (e.g., PartialService → HistoryService)\n  private readonly fileLocks = workspaceFileLocks;\n  private readonly config: Pick<Config, \"getSessionDir\">;\n\n  constructor(config: Pick<Config, \"getSessionDir\">) {\n    this.config = config;\n  }\n\n  private getChatHistoryPath(workspaceId: string): string {\n    return path.join(this.config.getSessionDir(workspaceId), this.CHAT_FILE);\n  }\n\n  // ── Reverse-read infrastructure ─────────────────────────────────────────────\n  // Reads chat.jsonl from the tail to avoid O(total-history) parsing on hot paths.\n  // \\n (0x0A) never appears inside multi-byte UTF-8 sequences, so chunked reverse\n  // reading is byte-safe. JSON.stringify escapes prevent false positives for the\n  // needle inside user-content strings.\n\n  /** Size of each chunk when scanning the file in reverse (256KB covers typical post-compaction content). */\n  private static readonly REVERSE_READ_CHUNK_SIZE = 256 * 1024;\n  /** String-search needle for compaction boundary lines. */\n  private static readonly BOUNDARY_NEEDLE = '\"compactionBoundary\":true';\n\n  /**\n   * Scan chat.jsonl in reverse to find the byte offset of a durable compaction boundary.\n   * Returns `null` when no (matching) boundary exists.\n   *\n   * @param skip How many boundaries to skip before returning. 0 = last boundary,\n   *             1 = second-to-last (penultimate), etc.\n   *\n   * Byte offsets are computed from raw \\n positions in the buffer (not from decoded string\n   * lengths) so that chunk boundaries splitting multi-byte UTF-8 sequences don't corrupt\n   * the returned offset.\n   */\n  private async findLastBoundaryByteOffset(workspaceId: string, skip = 0): Promise<number | null> {\n    const filePath = this.getChatHistoryPath(workspaceId);\n\n    let fileSize: number;\n    try {\n      const stat = await fs.stat(filePath);\n      fileSize = stat.size;\n    } catch {\n      return null;\n    }\n    if (fileSize === 0) return null;\n\n    const fh = await fs.open(filePath, \"r\");\n    try {\n      let readEnd = fileSize;\n      // Raw bytes of the incomplete first line from the previous (rightward) chunk.\n      // Kept as Buffer (not string) so multi-byte chars split at chunk boundaries\n      // don't corrupt byte offsets via UTF-8 replacement characters.\n      let carryoverBytes = Buffer.alloc(0);\n      let skipped = 0;\n\n      while (readEnd > 0) {\n        const readStart = Math.max(0, readEnd - HistoryService.REVERSE_READ_CHUNK_SIZE);\n        const chunkSize = readEnd - readStart;\n        const rawChunk = Buffer.alloc(chunkSize);\n        await fh.read(rawChunk, 0, chunkSize, readStart);\n\n        // Combine with carryover (the start of a line whose tail was in the previous chunk).\n        // The combined buffer represents contiguous file bytes [readStart, readStart + buffer.length).\n        const buffer =\n          carryoverBytes.length > 0 ? Buffer.concat([rawChunk, carryoverBytes]) : rawChunk;\n\n        // Find \\n byte positions in the raw buffer for accurate byte offsets.\n        // 0x0A never appears inside multi-byte UTF-8 sequences, so this is byte-safe\n        // even when a chunk boundary splits a multibyte character.\n        const newlinePositions: number[] = [];\n        for (let b = 0; b < buffer.length; b++) {\n          if (buffer[b] === 0x0a) {\n            newlinePositions.push(b);\n          }\n        }\n\n        if (newlinePositions.length === 0) {\n          // No newlines — entire buffer is one partial line, carry it all forward\n          carryoverBytes = Buffer.from(buffer);\n          readEnd = readStart;\n          continue;\n        }\n\n        // Bytes before the first \\n are an incomplete line — carry forward\n        carryoverBytes = Buffer.from(buffer.subarray(0, newlinePositions[0]));\n\n        // Scan complete lines in reverse. Each line occupies\n        // [newlinePositions[nl] + 1, nextNewline) in the buffer.\n        for (let nl = newlinePositions.length - 1; nl >= 0; nl--) {\n          const lineStart = newlinePositions[nl] + 1;\n          const lineEnd =\n            nl < newlinePositions.length - 1 ? newlinePositions[nl + 1] : buffer.length;\n          if (lineEnd <= lineStart) continue; // empty line\n\n          const line = buffer.subarray(lineStart, lineEnd).toString(\"utf-8\");\n          if (line.includes(HistoryService.BOUNDARY_NEEDLE)) {\n            try {\n              const msg = JSON.parse(line) as MuxMessage;\n              if (isDurableCompactionBoundaryMarker(msg)) {\n                if (skipped < skip) {\n                  skipped++;\n                } else {\n                  return readStart + lineStart;\n                }\n              }\n            } catch {\n              // Malformed line — not a real boundary, skip\n            }\n          }\n        }\n\n        readEnd = readStart;\n      }\n\n      // Check the very first line (accumulated in carryover)\n      if (carryoverBytes.length > 0) {\n        const line = carryoverBytes.toString(\"utf-8\");\n        if (line.includes(HistoryService.BOUNDARY_NEEDLE)) {\n          try {\n            const msg = JSON.parse(line) as MuxMessage;\n            if (isDurableCompactionBoundaryMarker(msg)) {\n              if (skipped < skip) {\n                // Not enough boundaries in the file to satisfy skip\n                return null;\n              }\n              return 0;\n            }\n          } catch {\n            // skip\n          }\n        }\n      }\n\n      return null;\n    } finally {\n      await fh.close();\n    }\n  }\n\n  /**\n   * Read and parse messages from a byte offset to the end of chat.jsonl.\n   * Self-healing: skips malformed JSON lines the same way readChatHistory does.\n   */\n  private async readHistoryFromOffset(\n    workspaceId: string,\n    byteOffset: number\n  ): Promise<MuxMessage[]> {\n    const filePath = this.getChatHistoryPath(workspaceId);\n    const stat = await fs.stat(filePath);\n    const tailSize = stat.size - byteOffset;\n    if (tailSize <= 0) return [];\n\n    const fh = await fs.open(filePath, \"r\");\n    try {\n      const buffer = Buffer.alloc(tailSize);\n      await fh.read(buffer, 0, tailSize, byteOffset);\n      const lines = buffer\n        .toString(\"utf-8\")\n        .split(\"\\n\")\n        .filter((l) => l.trim());\n      const messages: MuxMessage[] = [];\n      for (const line of lines) {\n        try {\n          messages.push(normalizeLegacyMuxMetadata(JSON.parse(line) as MuxMessage));\n        } catch {\n          // Skip malformed lines — same self-healing behavior as readChatHistory\n        }\n      }\n      return messages;\n    } finally {\n      await fh.close();\n    }\n  }\n\n  /**\n   * Read the last N messages from chat.jsonl by scanning the file in reverse.\n   * Much cheaper than a full read when only the tail is needed.\n   *\n   * Uses raw byte scanning for \\n positions (same approach as findLastBoundaryByteOffset)\n   * so that chunk boundaries splitting multi-byte UTF-8 sequences don't corrupt lines.\n   */\n  private async readLastMessages(workspaceId: string, n: number): Promise<MuxMessage[]> {\n    const filePath = this.getChatHistoryPath(workspaceId);\n\n    let fileSize: number;\n    try {\n      const stat = await fs.stat(filePath);\n      fileSize = stat.size;\n    } catch {\n      return [];\n    }\n    if (fileSize === 0) return [];\n\n    const fh = await fs.open(filePath, \"r\");\n    try {\n      const collected: MuxMessage[] = [];\n      let readEnd = fileSize;\n      let carryoverBytes = Buffer.alloc(0);\n\n      while (readEnd > 0 && collected.length < n) {\n        const readStart = Math.max(0, readEnd - HistoryService.REVERSE_READ_CHUNK_SIZE);\n        const chunkSize = readEnd - readStart;\n        const rawChunk = Buffer.alloc(chunkSize);\n        await fh.read(rawChunk, 0, chunkSize, readStart);\n\n        const buffer =\n          carryoverBytes.length > 0 ? Buffer.concat([rawChunk, carryoverBytes]) : rawChunk;\n\n        const newlinePositions: number[] = [];\n        for (let b = 0; b < buffer.length; b++) {\n          if (buffer[b] === 0x0a) {\n            newlinePositions.push(b);\n          }\n        }\n\n        if (newlinePositions.length === 0) {\n          carryoverBytes = Buffer.from(buffer);\n          readEnd = readStart;\n          continue;\n        }\n\n        carryoverBytes = Buffer.from(buffer.subarray(0, newlinePositions[0]));\n\n        // Parse complete lines in reverse, stopping once we have enough\n        for (let nl = newlinePositions.length - 1; nl >= 0 && collected.length < n; nl--) {\n          const lineStart = newlinePositions[nl] + 1;\n          const lineEnd =\n            nl < newlinePositions.length - 1 ? newlinePositions[nl + 1] : buffer.length;\n          if (lineEnd <= lineStart) continue;\n\n          const line = buffer.subarray(lineStart, lineEnd).toString(\"utf-8\").trim();\n          if (line.length === 0) continue;\n          try {\n            collected.push(normalizeLegacyMuxMetadata(JSON.parse(line) as MuxMessage));\n          } catch {\n            // Skip malformed lines\n          }\n        }\n\n        readEnd = readStart;\n      }\n\n      // Check the very first line if we still need more\n      if (collected.length < n && carryoverBytes.length > 0) {\n        const line = carryoverBytes.toString(\"utf-8\").trim();\n        if (line.length > 0) {\n          try {\n            collected.push(normalizeLegacyMuxMetadata(JSON.parse(line) as MuxMessage));\n          } catch {\n            // skip\n          }\n        }\n      }\n\n      // Reverse to restore chronological order\n      collected.reverse();\n      return collected;\n    } finally {\n      await fh.close();\n    }\n  }\n\n  /**\n   * Read raw messages from chat.jsonl (does not include partial.json)\n   * Returns empty array if file doesn't exist\n   * Skips malformed JSON lines to prevent data loss from corruption\n   */\n  private async readChatHistory(workspaceId: string): Promise<MuxMessage[]> {\n    try {\n      const chatHistoryPath = this.getChatHistoryPath(workspaceId);\n      const data = await fs.readFile(chatHistoryPath, \"utf-8\");\n      if (data.length > 5 * 1024 * 1024) {\n        log.warn(\"chat.jsonl exceeds 5MB — full read may be slow, consider compaction\", {\n          workspaceId,\n          sizeBytes: data.length,\n        });\n      }\n      const lines = data.split(\"\\n\").filter((line) => line.trim());\n      const messages: MuxMessage[] = [];\n\n      for (let i = 0; i < lines.length; i++) {\n        try {\n          const message = JSON.parse(lines[i]) as MuxMessage;\n          messages.push(normalizeLegacyMuxMetadata(message));\n        } catch (parseError) {\n          // Skip malformed lines but log error for debugging\n          log.warn(\n            `Skipping malformed JSON at line ${i + 1} in ${workspaceId}/chat.jsonl:`,\n            parseError instanceof Error ? parseError.message : String(parseError),\n            \"\\nLine content:\",\n            lines[i].substring(0, 100) + (lines[i].length > 100 ? \"...\" : \"\")\n          );\n        }\n      }\n\n      return messages;\n    } catch (error) {\n      if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\n        return []; // No history yet\n      }\n      throw error; // Re-throw non-ENOENT errors\n    }\n  }\n\n  // ── Forward/backward iteration infrastructure ────────────────────────────\n  // Chunked iteration over chat.jsonl that yields messages to a visitor callback.\n  // Supports early exit (return false) and reduces memory pressure vs. loading\n  // the entire file into an array.\n\n  /**\n   * Read chat.jsonl from start to end in chunks, calling visitor with each\n   * batch of parsed messages. Uses raw byte scanning for \\n to handle\n   * multi-byte UTF-8 safely at chunk boundaries.\n   */\n  private async iterateForward(\n    workspaceId: string,\n    visitor: (messages: MuxMessage[]) => boolean | void | Promise<boolean | void>\n  ): Promise<void> {\n    const filePath = this.getChatHistoryPath(workspaceId);\n\n    let fileSize: number;\n    try {\n      const stat = await fs.stat(filePath);\n      fileSize = stat.size;\n    } catch (error) {\n      if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\n        return; // No history\n      }\n      throw error;\n    }\n    if (fileSize === 0) return;\n\n    const fh = await fs.open(filePath, \"r\");\n    try {\n      let readPos = 0;\n      // Incomplete last line from the previous chunk, kept as Buffer to\n      // preserve split multi-byte UTF-8 sequences.\n      let carryoverBytes = Buffer.alloc(0);\n\n      while (readPos < fileSize) {\n        const remaining = fileSize - readPos;\n        const toRead = Math.min(HistoryService.REVERSE_READ_CHUNK_SIZE, remaining);\n        const rawChunk = Buffer.alloc(toRead);\n        await fh.read(rawChunk, 0, toRead, readPos);\n        readPos += toRead;\n\n        const buffer =\n          carryoverBytes.length > 0 ? Buffer.concat([carryoverBytes, rawChunk]) : rawChunk;\n\n        // Find the last \\n to split complete lines from the trailing incomplete line.\n        // 0x0A is byte-safe (never inside multi-byte UTF-8 sequences).\n        let lastNewline = -1;\n        for (let b = buffer.length - 1; b >= 0; b--) {\n          if (buffer[b] === 0x0a) {\n            lastNewline = b;\n            break;\n          }\n        }\n\n        if (lastNewline === -1) {\n          // No newline in entire buffer — carry everything forward\n          carryoverBytes = Buffer.from(buffer);\n          continue;\n        }\n\n        // Decode only complete lines (up to and including the last \\n)\n        const completeText = buffer.subarray(0, lastNewline).toString(\"utf-8\");\n        carryoverBytes = Buffer.from(buffer.subarray(lastNewline + 1));\n\n        const messages: MuxMessage[] = [];\n        for (const line of completeText.split(\"\\n\")) {\n          const trimmed = line.trim();\n          if (trimmed.length === 0) continue;\n          try {\n            messages.push(normalizeLegacyMuxMetadata(JSON.parse(trimmed) as MuxMessage));\n          } catch {\n            // Skip malformed lines — same self-healing behavior as readChatHistory\n          }\n        }\n\n        if (messages.length > 0) {\n          const shouldContinue = await visitor(messages);\n          if (shouldContinue === false) return;\n        }\n      }\n\n      // Handle remaining carryover (last line without trailing newline)\n      if (carryoverBytes.length > 0) {\n        const line = carryoverBytes.toString(\"utf-8\").trim();\n        if (line.length > 0) {\n          try {\n            const msg = normalizeLegacyMuxMetadata(JSON.parse(line) as MuxMessage);\n            await visitor([msg]);\n          } catch {\n            // Skip malformed line\n          }\n        }\n      }\n    } finally {\n      await fh.close();\n    }\n  }\n\n  /**\n   * Read chat.jsonl from end to start in chunks, calling visitor with each\n   * batch of parsed messages (newest first within each chunk). Uses the same\n   * raw-byte \\n scanning as findLastBoundaryByteOffset.\n   */\n  private async iterateBackward(\n    workspaceId: string,\n    visitor: (messages: MuxMessage[]) => boolean | void | Promise<boolean | void>\n  ): Promise<void> {\n    const filePath = this.getChatHistoryPath(workspaceId);\n\n    let fileSize: number;\n    try {\n      const stat = await fs.stat(filePath);\n      fileSize = stat.size;\n    } catch (error) {\n      if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\n        return; // No history\n      }\n      throw error;\n    }\n    if (fileSize === 0) return;\n\n    const fh = await fs.open(filePath, \"r\");\n    try {\n      let readEnd = fileSize;\n      let carryoverBytes = Buffer.alloc(0);\n\n      while (readEnd > 0) {\n        const readStart = Math.max(0, readEnd - HistoryService.REVERSE_READ_CHUNK_SIZE);\n        const chunkSize = readEnd - readStart;\n        const rawChunk = Buffer.alloc(chunkSize);\n        await fh.read(rawChunk, 0, chunkSize, readStart);\n\n        const buffer =\n          carryoverBytes.length > 0 ? Buffer.concat([rawChunk, carryoverBytes]) : rawChunk;\n\n        const newlinePositions: number[] = [];\n        for (let b = 0; b < buffer.length; b++) {\n          if (buffer[b] === 0x0a) {\n            newlinePositions.push(b);\n          }\n        }\n\n        if (newlinePositions.length === 0) {\n          carryoverBytes = Buffer.from(buffer);\n          readEnd = readStart;\n          continue;\n        }\n\n        carryoverBytes = Buffer.from(buffer.subarray(0, newlinePositions[0]));\n\n        // Parse complete lines in reverse (newest → oldest for backward iteration)\n        const messages: MuxMessage[] = [];\n        for (let nl = newlinePositions.length - 1; nl >= 0; nl--) {\n          const lineStart = newlinePositions[nl] + 1;\n          const lineEnd =\n            nl < newlinePositions.length - 1 ? newlinePositions[nl + 1] : buffer.length;\n          if (lineEnd <= lineStart) continue;\n\n          const line = buffer.subarray(lineStart, lineEnd).toString(\"utf-8\").trim();\n          if (line.length === 0) continue;\n          try {\n            messages.push(normalizeLegacyMuxMetadata(JSON.parse(line) as MuxMessage));\n          } catch {\n            // Skip malformed lines\n          }\n        }\n\n        if (messages.length > 0) {\n          const shouldContinue = await visitor(messages);\n          if (shouldContinue === false) return;\n        }\n\n        readEnd = readStart;\n      }\n\n      // Check the very first line (accumulated in carryover)\n      if (carryoverBytes.length > 0) {\n        const line = carryoverBytes.toString(\"utf-8\").trim();\n        if (line.length > 0) {\n          try {\n            const msg = normalizeLegacyMuxMetadata(JSON.parse(line) as MuxMessage);\n            await visitor([msg]);\n          } catch {\n            // Skip malformed line\n          }\n        }\n      }\n    } finally {\n      await fh.close();\n    }\n  }\n\n  /**\n   * Iterate over ALL messages in chat.jsonl — O(file-size) I/O + parse.\n   *\n   * ⚠️  Prefer targeted alternatives for hot paths:\n   *   - getHistoryFromLatestBoundary() — for provider-request assembly\n   *   - getLastMessages(n)            — when only the tail matters\n   *   - hasHistory()                  — for emptiness checks\n   *\n   * Yields chunks of parsed messages to the visitor callback. The visitor may\n   * return `false` to stop iteration early (e.g., after finding a target message).\n   *\n   * @param direction - 'forward' reads oldest→newest, 'backward' reads newest→oldest\n   * @param visitor - Called with each chunk of messages. Return false to stop early.\n   */\n  async iterateFullHistory(\n    workspaceId: string,\n    direction: \"forward\" | \"backward\",\n    visitor: (messages: MuxMessage[]) => boolean | void | Promise<boolean | void>\n  ): Promise<Result<void>> {\n    try {\n      if (direction === \"forward\") {\n        await this.iterateForward(workspaceId, visitor);\n      } else {\n        await this.iterateBackward(workspaceId, visitor);\n      }\n      return Ok(undefined);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return Err(`Failed to iterate history: ${message}`);\n    }\n  }\n\n  /**\n   * Read messages from a compaction boundary onward.\n   * Falls back to full history if no boundary exists (new/uncompacted workspace).\n   *\n   * @param skip How many boundaries to skip (counting from the latest). 0 = read\n   *             from the latest boundary, 1 = from the penultimate, etc. When the\n   *             requested boundary doesn't exist, falls back to the next-available\n   *             boundary, then to full history.\n   *\n   * Prefer this over iterateFullHistory() for provider-request assembly and any path\n   * that only needs the active compaction epoch.\n   */\n  async getHistoryFromLatestBoundary(workspaceId: string, skip = 0): Promise<Result<MuxMessage[]>> {\n    try {\n      // Try the requested boundary, falling back to less-skipped boundaries\n      for (let s = skip; s >= 0; s--) {\n        const offset = await this.findLastBoundaryByteOffset(workspaceId, s);\n        if (offset !== null) {\n          const messages = await this.readHistoryFromOffset(workspaceId, offset);\n          return Ok(messages);\n        }\n      }\n\n      // No boundaries at all — workspace is uncompacted, full read is the only option\n      const messages = await this.readChatHistory(workspaceId);\n      return Ok(messages);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return Err(`Failed to read history from boundary: ${message}`);\n    }\n  }\n\n  /**\n   * Read the last N messages from chat.jsonl by reading the file in reverse.\n   * Much cheaper than iterateFullHistory() when only the tail is needed.\n   */\n  async getLastMessages(workspaceId: string, n: number): Promise<Result<MuxMessage[]>> {\n    try {\n      const messages = await this.readLastMessages(workspaceId, n);\n      return Ok(messages);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return Err(`Failed to read last ${n} messages: ${message}`);\n    }\n  }\n\n  /**\n   * Check if a workspace has any chat history without parsing the file.\n   * Much cheaper than iterateFullHistory() when only an emptiness check is needed.\n   */\n  async hasHistory(workspaceId: string): Promise<boolean> {\n    const filePath = this.getChatHistoryPath(workspaceId);\n    try {\n      const stat = await fs.stat(filePath);\n      return stat.size > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get or initialize the next history sequence number for a workspace\n   */\n  private async getNextHistorySequence(workspaceId: string): Promise<number> {\n    // Check if we already have it in memory\n    if (this.sequenceCounters.has(workspaceId)) {\n      return this.sequenceCounters.get(workspaceId)!;\n    }\n\n    // Initialize from history — sequence numbers are monotonically increasing,\n    // so the last message always holds the max. Use getLastMessages(1) to avoid\n    // reading the entire file.\n    const lastResult = await this.getLastMessages(workspaceId, 1);\n    if (lastResult.success && lastResult.data.length > 0) {\n      const lastMsg = lastResult.data[0];\n      const seqNum = lastMsg.metadata?.historySequence;\n      if (isNonNegativeInteger(seqNum)) {\n        const nextSeqNum = seqNum + 1;\n        this.sequenceCounters.set(workspaceId, nextSeqNum);\n        return nextSeqNum;\n      }\n      // Last message has no valid sequence — fall back to scanning backward\n      // through all messages to find the max (handles legacy data).\n      let maxSeqNum = -1;\n      const scanResult = await this.iterateFullHistory(workspaceId, \"backward\", (chunk) => {\n        for (const msg of chunk) {\n          const seq = msg.metadata?.historySequence;\n          if (isNonNegativeInteger(seq)) {\n            maxSeqNum = Math.max(maxSeqNum, seq);\n            // Found a valid sequence — it's the max since we're scanning backward\n            return false;\n          }\n        }\n      });\n      if (scanResult.success) {\n        const nextSeqNum = maxSeqNum + 1;\n        assert(\n          isNonNegativeInteger(nextSeqNum),\n          \"next history sequence counter must be a non-negative integer\"\n        );\n        this.sequenceCounters.set(workspaceId, nextSeqNum);\n        return nextSeqNum;\n      }\n    }\n\n    // No history yet, start from 0\n    this.sequenceCounters.set(workspaceId, 0);\n    return 0;\n  }\n\n  /**\n   * Internal helper for appending to history without acquiring lock\n   * Used by both appendToHistory and commitPartial to avoid deadlock\n   */\n  private async _appendToHistoryUnlocked(\n    workspaceId: string,\n    message: MuxMessage\n  ): Promise<Result<void>> {\n    try {\n      const workspaceDir = this.config.getSessionDir(workspaceId);\n      await fs.mkdir(workspaceDir, { recursive: true });\n      const historyPath = this.getChatHistoryPath(workspaceId);\n\n      // DEBUG: Log message append with caller stack trace\n      const stack = new Error().stack?.split(\"\\n\").slice(2, 6).join(\"\\n\") ?? \"no stack\";\n      log.debug(\n        `[HISTORY APPEND] workspaceId=${workspaceId} role=${message.role} id=${message.id}`\n      );\n      log.debug(`[HISTORY APPEND] Call stack:\\n${stack}`);\n\n      // Ensure message has a history sequence number\n      if (!message.metadata) {\n        // Create metadata with history sequence\n        const nextSeqNum = await this.getNextHistorySequence(workspaceId);\n        assert(\n          isNonNegativeInteger(nextSeqNum),\n          \"getNextHistorySequence must return a non-negative integer\"\n        );\n        message.metadata = {\n          historySequence: nextSeqNum,\n        };\n        this.sequenceCounters.set(workspaceId, nextSeqNum + 1);\n      } else {\n        // Message already has metadata, but may need historySequence assigned\n        const existingSeqNum = message.metadata.historySequence;\n        if (existingSeqNum !== undefined) {\n          assert(\n            isNonNegativeInteger(existingSeqNum),\n            \"appendToHistory requires historySequence to be a non-negative integer when provided\"\n          );\n\n          // Already has history sequence, update counter if needed\n          const currentCounter = this.sequenceCounters.get(workspaceId) ?? 0;\n          assert(\n            isNonNegativeInteger(currentCounter),\n            \"history sequence counter must remain a non-negative integer\"\n          );\n          if (existingSeqNum >= currentCounter) {\n            this.sequenceCounters.set(workspaceId, existingSeqNum + 1);\n          }\n        } else {\n          // Has metadata but no historySequence, assign one\n          const nextSeqNum = await this.getNextHistorySequence(workspaceId);\n          assert(\n            isNonNegativeInteger(nextSeqNum),\n            \"getNextHistorySequence must return a non-negative integer\"\n          );\n          message.metadata = {\n            ...message.metadata,\n            historySequence: nextSeqNum,\n          };\n          this.sequenceCounters.set(workspaceId, nextSeqNum + 1);\n        }\n      }\n\n      // Store the message with workspace context\n      const historyEntry = {\n        ...message,\n        workspaceId,\n      };\n\n      // DEBUG: Log assigned sequence number\n      log.debug(\n        `[HISTORY APPEND] Assigned historySequence=${message.metadata.historySequence ?? \"unknown\"} role=${message.role}`\n      );\n\n      await fs.appendFile(historyPath, JSON.stringify(historyEntry) + \"\\n\");\n      return Ok(undefined);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return Err(`Failed to append to history: ${message}`);\n    }\n  }\n\n  async appendToHistory(workspaceId: string, message: MuxMessage): Promise<Result<void>> {\n    return this.fileLocks.withLock(workspaceId, async () => {\n      return this._appendToHistoryUnlocked(workspaceId, message);\n    });\n  }\n\n  /**\n   * Update an existing message in history by historySequence\n   * Reads entire history, replaces the matching message, and rewrites the file\n   */\n  async updateHistory(workspaceId: string, message: MuxMessage): Promise<Result<void>> {\n    return this.fileLocks.withLock(workspaceId, async () => {\n      try {\n        const historyPath = this.getChatHistoryPath(workspaceId);\n\n        // Read all messages — structural rewrite requires full file content\n        const messages = await this.readChatHistory(workspaceId);\n        const targetSequence = message.metadata?.historySequence;\n\n        if (targetSequence === undefined) {\n          return Err(\"Cannot update message without historySequence\");\n        }\n\n        assert(\n          isNonNegativeInteger(targetSequence),\n          \"updateHistory requires historySequence to be a non-negative integer\"\n        );\n\n        // Find and replace the message with matching historySequence\n        let found = false;\n        for (let i = 0; i < messages.length; i++) {\n          if (messages[i].metadata?.historySequence === targetSequence) {\n            const existingMessage = messages[i];\n            assert(existingMessage, \"updateHistory matched message must exist\");\n\n            // Preserve compaction boundary metadata during late in-place rewrites.\n            // Compaction may update an assistant row first, then a late stream rewrite can\n            // update that same historySequence and accidentally drop compaction markers.\n            const preservedCompactionMetadata = getCompactionMetadataToPreserve(\n              workspaceId,\n              existingMessage,\n              message\n            );\n\n            // Preserve the historySequence, update everything else.\n            messages[i] = {\n              ...message,\n              metadata: {\n                ...message.metadata,\n                ...(preservedCompactionMetadata ?? {}),\n                historySequence: targetSequence,\n              },\n            };\n            found = true;\n            break;\n          }\n        }\n\n        if (!found) {\n          return Err(`No message found with historySequence ${targetSequence}`);\n        }\n\n        // Rewrite entire file\n        const historyEntries = messages\n          .map((msg) => JSON.stringify({ ...msg, workspaceId }) + \"\\n\")\n          .join(\"\");\n\n        // Atomic write prevents corruption if app crashes mid-write\n        await writeFileAtomic(historyPath, historyEntries);\n        return Ok(undefined);\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        return Err(`Failed to update history: ${message}`);\n      }\n    });\n  }\n\n  /**\n   * Delete a single message by ID while preserving the rest of the history.\n   *\n   * This is safer than truncateAfterMessage for cleanup paths where subsequent\n   * messages may already have been appended.\n   */\n  async deleteMessage(workspaceId: string, messageId: string): Promise<Result<void>> {\n    return this.fileLocks.withLock(workspaceId, async () => {\n      try {\n        // Structural rewrite requires full file content\n        const messages = await this.readChatHistory(workspaceId);\n        const filteredMessages = messages.filter((msg) => msg.id !== messageId);\n\n        if (filteredMessages.length === messages.length) {\n          return Err(`Message with ID ${messageId} not found in history`);\n        }\n\n        const historyPath = this.getChatHistoryPath(workspaceId);\n        const historyEntries = filteredMessages\n          .map((msg) => JSON.stringify({ ...msg, workspaceId }) + \"\\n\")\n          .join(\"\");\n\n        // Atomic write prevents corruption if app crashes mid-write\n        await writeFileAtomic(historyPath, historyEntries);\n\n        // Keep the in-memory sequence counter monotonic. It's okay to reuse deleted sequence\n        // numbers on restart, but we must not regress within a running process.\n        const maxSeq = filteredMessages.reduce((max, msg) => {\n          const seq = msg.metadata?.historySequence;\n          if (seq === undefined) {\n            return max;\n          }\n\n          if (!isNonNegativeInteger(seq)) {\n            log.warn(\n              \"Ignoring malformed persisted historySequence while updating sequence counter after delete\",\n              {\n                workspaceId,\n                messageId: msg.id,\n                historySequence: seq,\n              }\n            );\n            return max;\n          }\n\n          return seq > max ? seq : max;\n        }, -1);\n        const nextSeq = maxSeq + 1;\n        assert(\n          isNonNegativeInteger(nextSeq),\n          \"next history sequence counter after delete must be a non-negative integer\"\n        );\n        const currentCounter = this.sequenceCounters.get(workspaceId);\n        if (currentCounter === undefined || currentCounter < nextSeq) {\n          this.sequenceCounters.set(workspaceId, nextSeq);\n        }\n\n        return Ok(undefined);\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        return Err(`Failed to delete message: ${message}`);\n      }\n    });\n  }\n\n  /**\n   * Truncate history after a specific message ID\n   * Removes the message with the given ID and all subsequent messages\n   */\n  async truncateAfterMessage(workspaceId: string, messageId: string): Promise<Result<void>> {\n    return this.fileLocks.withLock(workspaceId, async () => {\n      try {\n        // Structural rewrite requires full file content\n        const messages = await this.readChatHistory(workspaceId);\n        const messageIndex = messages.findIndex((msg) => msg.id === messageId);\n\n        if (messageIndex === -1) {\n          return Err(`Message with ID ${messageId} not found in history`);\n        }\n\n        // Keep only messages before the target message\n        const truncatedMessages = messages.slice(0, messageIndex);\n\n        // Rewrite the history file with truncated messages\n        const historyPath = this.getChatHistoryPath(workspaceId);\n        const historyEntries = truncatedMessages\n          .map((msg) => JSON.stringify({ ...msg, workspaceId }) + \"\\n\")\n          .join(\"\");\n\n        // Atomic write prevents corruption if app crashes mid-write\n        await writeFileAtomic(historyPath, historyEntries);\n\n        // Update sequence counter to continue from where we truncated.\n        // Self-healing read path: skip malformed persisted historySequence values.\n        const maxTruncatedSeq = truncatedMessages.reduce((max, msg) => {\n          const seq = msg.metadata?.historySequence;\n          if (seq === undefined) {\n            return max;\n          }\n\n          if (!isNonNegativeInteger(seq)) {\n            log.warn(\n              \"Ignoring malformed persisted historySequence while updating sequence counter after truncation\",\n              {\n                workspaceId,\n                messageId: msg.id,\n                historySequence: seq,\n              }\n            );\n            return max;\n          }\n\n          return seq > max ? seq : max;\n        }, -1);\n        const nextSeq = maxTruncatedSeq + 1;\n        assert(\n          isNonNegativeInteger(nextSeq),\n          \"next history sequence counter after truncation must be a non-negative integer\"\n        );\n        this.sequenceCounters.set(workspaceId, nextSeq);\n\n        return Ok(undefined);\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        return Err(`Failed to truncate history: ${message}`);\n      }\n    });\n  }\n\n  /**\n   * Truncate history by removing approximately the given percentage of tokens from the beginning\n   * @param workspaceId The workspace ID\n   * @param percentage Percentage to truncate (0.0 to 1.0). 1.0 = delete all\n   * @returns Result containing array of deleted historySequence numbers\n   */\n  async truncateHistory(\n    workspaceId: string,\n    percentage: number\n  ): Promise<Result<number[], string>> {\n    return this.fileLocks.withLock(workspaceId, async () => {\n      try {\n        const historyPath = this.getChatHistoryPath(workspaceId);\n\n        // Fast path: 100% truncation = delete entire file\n        if (percentage >= 1.0) {\n          // Need sequence numbers for return value before deleting\n          const messages = await this.readChatHistory(workspaceId);\n          const deletedSequences = messages\n            .map((msg) => msg.metadata?.historySequence)\n            .filter((s): s is number => isNonNegativeInteger(s));\n\n          try {\n            await fs.unlink(historyPath);\n          } catch (error) {\n            // Ignore ENOENT - file already deleted\n            if (\n              !(error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\")\n            ) {\n              throw error;\n            }\n          }\n\n          // Reset sequence counter when clearing history\n          this.sequenceCounters.set(workspaceId, 0);\n          return Ok(deletedSequences);\n        }\n\n        // Structural rewrite requires full file content\n        const messages = await this.readChatHistory(workspaceId);\n        if (messages.length === 0) {\n          return Ok([]); // Nothing to truncate\n        }\n\n        // Get tokenizer for counting (use a default model)\n        const tokenizer = await getTokenizerForModel(KNOWN_MODELS.SONNET.id);\n\n        // Count tokens for each message\n        // We stringify the entire message for simplicity - only relative weights matter\n        const messageTokens: Array<{ message: MuxMessage; tokens: number }> = await Promise.all(\n          messages.map(async (msg) => {\n            const tokens = await tokenizer.countTokens(safeStringifyForCounting(msg));\n            return { message: msg, tokens };\n          })\n        );\n\n        // Calculate total tokens and target to remove\n        const totalTokens = messageTokens.reduce((sum, mt) => sum + mt.tokens, 0);\n        const tokensToRemove = Math.floor(totalTokens * percentage);\n\n        // Remove messages from beginning until we've removed enough tokens\n        let tokensRemoved = 0;\n        let removeCount = 0;\n        for (const mt of messageTokens) {\n          if (tokensRemoved >= tokensToRemove) {\n            break;\n          }\n          tokensRemoved += mt.tokens;\n          removeCount++;\n        }\n\n        // If we're removing all messages, use fast path\n        if (removeCount >= messages.length) {\n          try {\n            await fs.unlink(historyPath);\n          } catch (error) {\n            // Ignore ENOENT\n            if (\n              !(error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\")\n            ) {\n              throw error;\n            }\n          }\n          this.sequenceCounters.set(workspaceId, 0);\n          const deletedSequences = messages\n            .map((msg) => msg.metadata?.historySequence)\n            .filter((s): s is number => isNonNegativeInteger(s));\n          return Ok(deletedSequences);\n        }\n\n        // Keep messages after removeCount\n        const remainingMessages = messages.slice(removeCount);\n        const deletedMessages = messages.slice(0, removeCount);\n        const deletedSequences = deletedMessages\n          .map((msg) => msg.metadata?.historySequence)\n          .filter((s): s is number => isNonNegativeInteger(s));\n\n        // Rewrite the history file with remaining messages\n        const historyEntries = remainingMessages\n          .map((msg) => JSON.stringify({ ...msg, workspaceId }) + \"\\n\")\n          .join(\"\");\n\n        // Atomic write prevents corruption if app crashes mid-write\n        await writeFileAtomic(historyPath, historyEntries);\n\n        // Update sequence counter to continue from where we are.\n        // Self-healing read path: skip malformed persisted historySequence values.\n        const maxRemainingSeq = remainingMessages.reduce((max, msg) => {\n          const seq = msg.metadata?.historySequence;\n          if (seq === undefined) {\n            return max;\n          }\n\n          if (!isNonNegativeInteger(seq)) {\n            log.warn(\n              \"Ignoring malformed persisted historySequence while updating sequence counter after truncateHistory\",\n              {\n                workspaceId,\n                messageId: msg.id,\n                historySequence: seq,\n              }\n            );\n            return max;\n          }\n\n          return seq > max ? seq : max;\n        }, -1);\n        const nextSeq = maxRemainingSeq + 1;\n        assert(\n          isNonNegativeInteger(nextSeq),\n          \"next history sequence counter after truncateHistory must be a non-negative integer\"\n        );\n        this.sequenceCounters.set(workspaceId, nextSeq);\n\n        return Ok(deletedSequences);\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        return Err(`Failed to truncate history: ${message}`);\n      }\n    });\n  }\n\n  async clearHistory(workspaceId: string): Promise<Result<number[], string>> {\n    const result = await this.truncateHistory(workspaceId, 1.0);\n    if (!result.success) {\n      return Err(result.error);\n    }\n    return Ok(result.data);\n  }\n\n  /**\n   * Migrate all messages in chat.jsonl to use a new workspace ID\n   * This is used during workspace rename to update the workspaceId field in all historical messages\n   * IMPORTANT: Should be called AFTER the session directory has been renamed\n   */\n  async migrateWorkspaceId(oldWorkspaceId: string, newWorkspaceId: string): Promise<Result<void>> {\n    return this.fileLocks.withLock(newWorkspaceId, async () => {\n      try {\n        // Read messages from the NEW workspace location (directory was already renamed).\n        // Structural rewrite requires full file content.\n        const messages = await this.readChatHistory(newWorkspaceId);\n        if (messages.length === 0) {\n          // No messages to migrate, just transfer sequence counter\n          const oldCounter = this.sequenceCounters.get(oldWorkspaceId) ?? 0;\n          this.sequenceCounters.set(newWorkspaceId, oldCounter);\n          this.sequenceCounters.delete(oldWorkspaceId);\n          return Ok(undefined);\n        }\n\n        // Rewrite all messages with new workspace ID\n        const newHistoryPath = this.getChatHistoryPath(newWorkspaceId);\n        const historyEntries = messages\n          .map((msg) => JSON.stringify({ ...msg, workspaceId: newWorkspaceId }) + \"\\n\")\n          .join(\"\");\n\n        // Atomic write prevents corruption if app crashes mid-write\n        await writeFileAtomic(newHistoryPath, historyEntries);\n\n        // Transfer sequence counter to new workspace ID\n        const oldCounter = this.sequenceCounters.get(oldWorkspaceId) ?? 0;\n        this.sequenceCounters.set(newWorkspaceId, oldCounter);\n        this.sequenceCounters.delete(oldWorkspaceId);\n\n        log.debug(\n          `Migrated ${messages.length} messages from ${oldWorkspaceId} to ${newWorkspaceId}`\n        );\n\n        return Ok(undefined);\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        return Err(`Failed to migrate workspace ID: ${message}`);\n      }\n    });\n  }\n}\n"]}