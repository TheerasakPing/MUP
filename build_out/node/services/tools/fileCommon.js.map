{"version":3,"file":"fileCommon.js","sourceRoot":"","sources":["../../../../src/node/services/tools/fileCommon.ts"],"names":[],"mappings":"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","sourcesContent":["import * as path from \"path\";\r\nimport assert from \"@/common/utils/assert\";\r\nimport { createPatch } from \"diff\";\r\nimport type { FileStat, Runtime } from \"@/node/runtime/Runtime\";\r\nimport { SSHRuntime } from \"@/node/runtime/SSHRuntime\";\r\nimport { expandTilde } from \"@/node/runtime/tildeExpansion\";\r\nimport type { ToolConfiguration } from \"@/common/utils/tools/tools\";\r\n\r\n/**\r\n * Maximum file size for file operations (1MB)\r\n * Files larger than this should be processed with system tools like grep, sed, etc.\r\n */\r\nexport const MAX_FILE_SIZE = 1024 * 1024; // 1MB\r\n\r\nexport interface PlanModeValidationError {\r\n  success: false;\r\n  error: string;\r\n}\r\n\r\n/**\r\n * Validate file path for plan mode restrictions.\r\n * Returns an error if:\r\n * - Editing plan file outside plan mode (read-only)\r\n * - Editing non-plan file in plan mode\r\n * - Path is outside cwd (for non-plan files)\r\n *\r\n * Returns null if validation passes.\r\n */\r\nexport async function validatePlanModeAccess(\r\n  filePath: string,\r\n  config: ToolConfiguration\r\n): Promise<PlanModeValidationError | null> {\r\n  // Plan file is always read-only outside the plan agent.\r\n  // This is especially important for SSH runtimes, where cwd validation is intentionally skipped.\r\n  if ((await isPlanFilePath(filePath, config)) && !config.planFileOnly) {\r\n    return {\r\n      success: false,\r\n      error: `Plan file is read-only outside the plan agent: ${filePath}`,\r\n    };\r\n  }\r\n\r\n  // Plan-agent restriction: only allow editing the plan file (and require exact string match).\r\n  if (config.planFileOnly && config.planFilePath) {\r\n    if (filePath !== config.planFilePath) {\r\n      if (await isPlanFilePath(filePath, config)) {\r\n        return {\r\n          success: false,\r\n          error: `In the plan agent, you must use the exact plan file path from the instructions: ${config.planFilePath} (attempted: ${filePath}; this resolves to the plan file but absolute/alternate paths are not allowed)`,\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: false,\r\n        error: `In the plan agent, only the plan file can be edited. You must use the exact plan file path: ${config.planFilePath} (attempted: ${filePath})`,\r\n      };\r\n    }\r\n    // Skip cwd validation for plan file - it may be outside workspace\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Compute a 6-character hexadecimal lease from file content.\r\n * The lease changes when file content is modified.\r\n * Uses a deterministic hash so leases are consistent across processes.\r\n */\r\n\r\n/**\r\n * Generate a unified diff between old and new content using jsdiff.\r\n * Uses createPatch with context of 3 lines.\r\n *\r\n * @param filePath - The file path being edited (used in diff header)\r\n * @param oldContent - The original file content\r\n * @param newContent - The modified file content\r\n * @returns Unified diff string\r\n */\r\nexport function generateDiff(filePath: string, oldContent: string, newContent: string): string {\r\n  return createPatch(filePath, oldContent, newContent, \"\", \"\", { context: 3 });\r\n}\r\n\r\n/**\r\n * Check if a file path is the configured plan file (any mode).\r\n * Uses runtime.resolvePath to properly expand tildes for comparison.\r\n *\r\n * Why mode-agnostic: the plan file is useful context in both plan + exec modes,\r\n * but should only be writable in plan mode.\r\n *\r\n * @param targetPath - The path being accessed (may contain ~ or be absolute)\r\n * @param config - Tool configuration containing planFilePath\r\n * @returns true if this is the configured plan file\r\n */\r\nexport async function isPlanFilePath(\r\n  targetPath: string,\r\n  config: ToolConfiguration\r\n): Promise<boolean> {\r\n  if (!config.planFilePath) {\r\n    return false;\r\n  }\r\n  // Resolve both paths to absolute form for proper comparison.\r\n  // This handles cases where one path uses ~ and the other is fully expanded.\r\n  const [resolvedTarget, resolvedPlan] = await Promise.all([\r\n    config.runtime.resolvePath(targetPath),\r\n    config.runtime.resolvePath(config.planFilePath),\r\n  ]);\r\n  return resolvedTarget === resolvedPlan;\r\n}\r\n\r\n/**\r\n * Validates that a file size is within the allowed limit.\r\n * Returns an error object if the file is too large, null if valid.\r\n *\r\n * @param stats - File stats from fs.stat()\r\n * @returns Error object if file is too large, null if valid\r\n */\r\nexport function validateFileSize(stats: FileStat): { error: string } | null {\r\n  if (stats.size > MAX_FILE_SIZE) {\r\n    const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);\r\n    const maxMB = (MAX_FILE_SIZE / (1024 * 1024)).toFixed(2);\r\n    return {\r\n      error: `File is too large (${sizeMB}MB). The maximum file size for file operations is ${maxMB}MB. Please use system tools like grep, sed, awk, or split the file into smaller chunks.`,\r\n    };\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Validates that a file path doesn't contain redundant workspace prefix.\r\n * If the path contains the cwd prefix, returns the corrected relative path and a warning.\r\n * This helps save tokens by encouraging relative paths.\r\n *\r\n * Works for both local and SSH runtimes by using runtime.normalizePath()\r\n * for consistent path handling across different runtime types.\r\n *\r\n * @param filePath - The file path to validate\r\n * @param cwd - The working directory\r\n * @param runtime - The runtime to use for path normalization\r\n * @returns Object with corrected path and warning if redundant prefix found, null if valid\r\n */\r\nexport function validateNoRedundantPrefix(\r\n  filePath: string,\r\n  cwd: string,\r\n  runtime: Runtime\r\n): { correctedPath: string; warning: string } | null {\r\n  // Only check absolute paths (start with /) - relative paths are fine\r\n  // This works for both local and SSH since both use Unix-style paths\r\n  if (!filePath.startsWith(\"/\")) {\r\n    return null;\r\n  }\r\n\r\n  // Use runtime's normalizePath to ensure consistent handling across local and SSH\r\n  // Normalize the cwd to get canonical form (removes trailing slashes, etc.)\r\n  const normalizedCwd = runtime.normalizePath(\".\", cwd);\r\n\r\n  // For absolute paths, we can't use normalizePath directly (it resolves relative paths)\r\n  // so just clean up trailing slashes manually\r\n  const normalizedPath = filePath.replace(/\\/+$/, \"\");\r\n  const cleanCwd = normalizedCwd.replace(/\\/+$/, \"\");\r\n\r\n  // Check if the absolute path starts with the cwd\r\n  // Use startsWith + check for path separator to avoid partial matches\r\n  // e.g., /workspace/project should match /workspace/project/src but not /workspace/project2\r\n  if (normalizedPath === cleanCwd || normalizedPath.startsWith(cleanCwd + \"/\")) {\r\n    // Calculate what the relative path would be\r\n    const relativePath =\r\n      normalizedPath === cleanCwd ? \".\" : normalizedPath.substring(cleanCwd.length + 1);\r\n    return {\r\n      correctedPath: relativePath,\r\n      warning: `Note: Using relative paths like '${relativePath}' instead of '${filePath}' saves tokens. The path has been auto-corrected for you.`,\r\n    };\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Validates that a file path is within the allowed working directory.\r\n * Returns an error object if the path is outside cwd (and any optional allowlisted roots),\r\n * null if valid.\r\n *\r\n * @param filePath - The file path to validate (can be relative or absolute)\r\n * @param cwd - The working directory that file operations are restricted to\r\n * @param runtime - The runtime (used to detect SSH - TODO: make path validation runtime-aware)\r\n * @param extraAllowedDirs - Additional absolute directories that are allowlisted for access.\r\n * @returns Error object if invalid, null if valid\r\n */\r\nexport function validatePathInCwd(\r\n  filePath: string,\r\n  cwd: string,\r\n  runtime: Runtime,\r\n  extraAllowedDirs: string[] = []\r\n): { error: string } | null {\r\n  // TODO: Make path validation runtime-aware instead of skipping for SSH.\r\n  // For now, skip local path validation for SSH runtimes since:\r\n  // 1. Node's path module doesn't understand remote paths (~/mux/branch)\r\n  // 2. The runtime's own file operations will fail on invalid paths anyway\r\n  if (runtime instanceof SSHRuntime) {\r\n    return null;\r\n  }\r\n\r\n  const trimmedExtraAllowedDirs = extraAllowedDirs\r\n    .map((dir) => dir.trim())\r\n    .filter((dir) => dir.length > 0);\r\n\r\n  // extraAllowedDirs are an internal allowlist (e.g., stream-scoped runtimeTempDir).\r\n  // For safety, require absolute paths so misconfiguration doesn't widen access.\r\n  for (const dir of trimmedExtraAllowedDirs) {\r\n    assert(path.isAbsolute(dir), `extraAllowedDir must be an absolute path: '${dir}'`);\r\n  }\r\n\r\n  // Expand tildes FIRST so we validate the actual destination path.\r\n  // Without this, ~/outside/file.ts would be treated as a relative path\r\n  // (path.isAbsolute('~/...') returns false) and incorrectly pass validation.\r\n  const expandedPath = expandTilde(filePath);\r\n  const filePathIsAbsolute = path.isAbsolute(expandedPath);\r\n\r\n  // Only allow extraAllowedDirs when the caller provides an absolute path.\r\n  // This prevents relative-path escapes (e.g., ../...) from bypassing cwd restrictions.\r\n\r\n  // Resolve the path (handles relative paths and normalizes)\r\n  const resolvedPath = filePathIsAbsolute\r\n    ? path.resolve(expandedPath)\r\n    : path.resolve(cwd, expandedPath);\r\n\r\n  const allowedRoots = [cwd, ...(filePathIsAbsolute ? trimmedExtraAllowedDirs : [])].map((dir) =>\r\n    path.resolve(dir)\r\n  );\r\n\r\n  // Check if resolved path is within any allowed root.\r\n  // Use path.relative to check if we need to go \"up\" from the root to reach the file.\r\n  const isWithinAllowedRoot = allowedRoots.some((root) => {\r\n    const relativePath = path.relative(root, resolvedPath);\r\n    return !relativePath.startsWith(\"..\") && !path.isAbsolute(relativePath);\r\n  });\r\n\r\n  if (!isWithinAllowedRoot) {\r\n    return {\r\n      error: `File operations are restricted to the workspace directory (${cwd}). The path '${filePath}' resolves outside this directory. If you need to modify files outside the workspace, please ask the user for permission first.`,\r\n    };\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Validates and auto-corrects redundant path prefixes in file paths.\r\n * Returns the corrected path and an optional warning message.\r\n *\r\n * This is a convenience wrapper around validateNoRedundantPrefix that handles\r\n * the common pattern of auto-correcting paths and returning warnings.\r\n *\r\n * @param filePath - The file path to validate (may be modified if redundant prefix found)\r\n * @param cwd - The working directory\r\n * @param runtime - The runtime to use for path normalization\r\n * @returns Object with correctedPath and optional warning\r\n */\r\nexport function validateAndCorrectPath(\r\n  filePath: string,\r\n  cwd: string,\r\n  runtime: Runtime\r\n): { correctedPath: string; warning?: string } {\r\n  const redundantPrefixValidation = validateNoRedundantPrefix(filePath, cwd, runtime);\r\n  if (redundantPrefixValidation) {\r\n    return {\r\n      correctedPath: redundantPrefixValidation.correctedPath,\r\n      warning: redundantPrefixValidation.warning,\r\n    };\r\n  }\r\n  return { correctedPath: filePath };\r\n}\r\n"]}