{"version":3,"file":"fileCommon.js","sourceRoot":"","sources":["../../../../src/node/services/tools/fileCommon.ts"],"names":[],"mappings":"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","sourcesContent":["import * as path from \"path\";\nimport assert from \"@/common/utils/assert\";\nimport { createPatch } from \"diff\";\nimport type { FileStat, Runtime } from \"@/node/runtime/Runtime\";\nimport { SSHRuntime } from \"@/node/runtime/SSHRuntime\";\nimport { expandTilde } from \"@/node/runtime/tildeExpansion\";\nimport type { ToolConfiguration } from \"@/common/utils/tools/tools\";\n\n/**\n * Maximum file size for file operations (1MB)\n * Files larger than this should be processed with system tools like grep, sed, etc.\n */\nexport const MAX_FILE_SIZE = 1024 * 1024; // 1MB\n\nexport interface PlanModeValidationError {\n  success: false;\n  error: string;\n}\n\n/**\n * Validate file path for plan mode restrictions.\n * Returns an error if:\n * - Editing plan file outside plan mode (read-only)\n * - Editing non-plan file in plan mode\n * - Path is outside cwd (for non-plan files)\n *\n * Returns null if validation passes.\n */\nexport async function validatePlanModeAccess(\n  filePath: string,\n  config: ToolConfiguration\n): Promise<PlanModeValidationError | null> {\n  // Plan file is always read-only outside the plan agent.\n  // This is especially important for SSH runtimes, where cwd validation is intentionally skipped.\n  if ((await isPlanFilePath(filePath, config)) && !config.planFileOnly) {\n    return {\n      success: false,\n      error: `Plan file is read-only outside the plan agent: ${filePath}`,\n    };\n  }\n\n  // Plan-agent restriction: only allow editing the plan file (and require exact string match).\n  if (config.planFileOnly && config.planFilePath) {\n    if (filePath !== config.planFilePath) {\n      if (await isPlanFilePath(filePath, config)) {\n        return {\n          success: false,\n          error: `In the plan agent, you must use the exact plan file path from the instructions: ${config.planFilePath} (attempted: ${filePath}; this resolves to the plan file but absolute/alternate paths are not allowed)`,\n        };\n      }\n\n      return {\n        success: false,\n        error: `In the plan agent, only the plan file can be edited. You must use the exact plan file path: ${config.planFilePath} (attempted: ${filePath})`,\n      };\n    }\n    // Skip cwd validation for plan file - it may be outside workspace\n  }\n\n  return null;\n}\n\n/**\n * Compute a 6-character hexadecimal lease from file content.\n * The lease changes when file content is modified.\n * Uses a deterministic hash so leases are consistent across processes.\n */\n\n/**\n * Generate a unified diff between old and new content using jsdiff.\n * Uses createPatch with context of 3 lines.\n *\n * @param filePath - The file path being edited (used in diff header)\n * @param oldContent - The original file content\n * @param newContent - The modified file content\n * @returns Unified diff string\n */\nexport function generateDiff(filePath: string, oldContent: string, newContent: string): string {\n  return createPatch(filePath, oldContent, newContent, \"\", \"\", { context: 3 });\n}\n\n/**\n * Check if a file path is the configured plan file (any mode).\n * Uses runtime.resolvePath to properly expand tildes for comparison.\n *\n * Why mode-agnostic: the plan file is useful context in both plan + exec modes,\n * but should only be writable in plan mode.\n *\n * @param targetPath - The path being accessed (may contain ~ or be absolute)\n * @param config - Tool configuration containing planFilePath\n * @returns true if this is the configured plan file\n */\nexport async function isPlanFilePath(\n  targetPath: string,\n  config: ToolConfiguration\n): Promise<boolean> {\n  if (!config.planFilePath) {\n    return false;\n  }\n  // Resolve both paths to absolute form for proper comparison.\n  // This handles cases where one path uses ~ and the other is fully expanded.\n  const [resolvedTarget, resolvedPlan] = await Promise.all([\n    config.runtime.resolvePath(targetPath),\n    config.runtime.resolvePath(config.planFilePath),\n  ]);\n  return resolvedTarget === resolvedPlan;\n}\n\n/**\n * Validates that a file size is within the allowed limit.\n * Returns an error object if the file is too large, null if valid.\n *\n * @param stats - File stats from fs.stat()\n * @returns Error object if file is too large, null if valid\n */\nexport function validateFileSize(stats: FileStat): { error: string } | null {\n  if (stats.size > MAX_FILE_SIZE) {\n    const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);\n    const maxMB = (MAX_FILE_SIZE / (1024 * 1024)).toFixed(2);\n    return {\n      error: `File is too large (${sizeMB}MB). The maximum file size for file operations is ${maxMB}MB. Please use system tools like grep, sed, awk, or split the file into smaller chunks.`,\n    };\n  }\n  return null;\n}\n\n/**\n * Validates that a file path doesn't contain redundant workspace prefix.\n * If the path contains the cwd prefix, returns the corrected relative path and a warning.\n * This helps save tokens by encouraging relative paths.\n *\n * Works for both local and SSH runtimes by using runtime.normalizePath()\n * for consistent path handling across different runtime types.\n *\n * @param filePath - The file path to validate\n * @param cwd - The working directory\n * @param runtime - The runtime to use for path normalization\n * @returns Object with corrected path and warning if redundant prefix found, null if valid\n */\nexport function validateNoRedundantPrefix(\n  filePath: string,\n  cwd: string,\n  runtime: Runtime\n): { correctedPath: string; warning: string } | null {\n  // Only check absolute paths (start with /) - relative paths are fine\n  // This works for both local and SSH since both use Unix-style paths\n  if (!filePath.startsWith(\"/\")) {\n    return null;\n  }\n\n  // Use runtime's normalizePath to ensure consistent handling across local and SSH\n  // Normalize the cwd to get canonical form (removes trailing slashes, etc.)\n  const normalizedCwd = runtime.normalizePath(\".\", cwd);\n\n  // For absolute paths, we can't use normalizePath directly (it resolves relative paths)\n  // so just clean up trailing slashes manually\n  const normalizedPath = filePath.replace(/\\/+$/, \"\");\n  const cleanCwd = normalizedCwd.replace(/\\/+$/, \"\");\n\n  // Check if the absolute path starts with the cwd\n  // Use startsWith + check for path separator to avoid partial matches\n  // e.g., /workspace/project should match /workspace/project/src but not /workspace/project2\n  if (normalizedPath === cleanCwd || normalizedPath.startsWith(cleanCwd + \"/\")) {\n    // Calculate what the relative path would be\n    const relativePath =\n      normalizedPath === cleanCwd ? \".\" : normalizedPath.substring(cleanCwd.length + 1);\n    return {\n      correctedPath: relativePath,\n      warning: `Note: Using relative paths like '${relativePath}' instead of '${filePath}' saves tokens. The path has been auto-corrected for you.`,\n    };\n  }\n\n  return null;\n}\n\n/**\n * Validates that a file path is within the allowed working directory.\n * Returns an error object if the path is outside cwd (and any optional allowlisted roots),\n * null if valid.\n *\n * @param filePath - The file path to validate (can be relative or absolute)\n * @param cwd - The working directory that file operations are restricted to\n * @param runtime - The runtime (used to detect SSH - TODO: make path validation runtime-aware)\n * @param extraAllowedDirs - Additional absolute directories that are allowlisted for access.\n * @returns Error object if invalid, null if valid\n */\nexport function validatePathInCwd(\n  filePath: string,\n  cwd: string,\n  runtime: Runtime,\n  extraAllowedDirs: string[] = []\n): { error: string } | null {\n  // TODO: Make path validation runtime-aware instead of skipping for SSH.\n  // For now, skip local path validation for SSH runtimes since:\n  // 1. Node's path module doesn't understand remote paths (~/mux/branch)\n  // 2. The runtime's own file operations will fail on invalid paths anyway\n  if (runtime instanceof SSHRuntime) {\n    return null;\n  }\n\n  const trimmedExtraAllowedDirs = extraAllowedDirs\n    .map((dir) => dir.trim())\n    .filter((dir) => dir.length > 0);\n\n  // extraAllowedDirs are an internal allowlist (e.g., stream-scoped runtimeTempDir).\n  // For safety, require absolute paths so misconfiguration doesn't widen access.\n  for (const dir of trimmedExtraAllowedDirs) {\n    assert(path.isAbsolute(dir), `extraAllowedDir must be an absolute path: '${dir}'`);\n  }\n\n  // Expand tildes FIRST so we validate the actual destination path.\n  // Without this, ~/outside/file.ts would be treated as a relative path\n  // (path.isAbsolute('~/...') returns false) and incorrectly pass validation.\n  const expandedPath = expandTilde(filePath);\n  const filePathIsAbsolute = path.isAbsolute(expandedPath);\n\n  // Only allow extraAllowedDirs when the caller provides an absolute path.\n  // This prevents relative-path escapes (e.g., ../...) from bypassing cwd restrictions.\n\n  // Resolve the path (handles relative paths and normalizes)\n  const resolvedPath = filePathIsAbsolute\n    ? path.resolve(expandedPath)\n    : path.resolve(cwd, expandedPath);\n\n  const allowedRoots = [cwd, ...(filePathIsAbsolute ? trimmedExtraAllowedDirs : [])].map((dir) =>\n    path.resolve(dir)\n  );\n\n  // Check if resolved path is within any allowed root.\n  // Use path.relative to check if we need to go \"up\" from the root to reach the file.\n  const isWithinAllowedRoot = allowedRoots.some((root) => {\n    const relativePath = path.relative(root, resolvedPath);\n    return !relativePath.startsWith(\"..\") && !path.isAbsolute(relativePath);\n  });\n\n  if (!isWithinAllowedRoot) {\n    return {\n      error: `File operations are restricted to the workspace directory (${cwd}). The path '${filePath}' resolves outside this directory. If you need to modify files outside the workspace, please ask the user for permission first.`,\n    };\n  }\n\n  return null;\n}\n\n/**\n * Validates and auto-corrects redundant path prefixes in file paths.\n * Returns the corrected path and an optional warning message.\n *\n * This is a convenience wrapper around validateNoRedundantPrefix that handles\n * the common pattern of auto-correcting paths and returning warnings.\n *\n * @param filePath - The file path to validate (may be modified if redundant prefix found)\n * @param cwd - The working directory\n * @param runtime - The runtime to use for path normalization\n * @returns Object with correctedPath and optional warning\n */\nexport function validateAndCorrectPath(\n  filePath: string,\n  cwd: string,\n  runtime: Runtime\n): { correctedPath: string; warning?: string } {\n  const redundantPrefixValidation = validateNoRedundantPrefix(filePath, cwd, runtime);\n  if (redundantPrefixValidation) {\n    return {\n      correctedPath: redundantPrefixValidation.correctedPath,\n      warning: redundantPrefixValidation.warning,\n    };\n  }\n  return { correctedPath: filePath };\n}\n"]}