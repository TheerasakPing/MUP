{"version":3,"file":"task.js","sourceRoot":"","sources":["../../../../src/node/services/tools/task.ts"],"names":[],"mappings":"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","sourcesContent":["import { tool } from \"ai\";\r\n\r\nimport { coerceThinkingLevel } from \"@/common/types/thinking\";\r\nimport type { ToolConfiguration, ToolFactory } from \"@/common/utils/tools/tools\";\r\nimport { TaskToolResultSchema, TOOL_DEFINITIONS } from \"@/common/utils/tools/toolDefinitions\";\r\nimport type { TaskCreatedEvent } from \"@/common/types/stream\";\r\nimport { log } from \"@/node/services/log\";\r\n\r\nimport { parseToolResult, requireTaskService, requireWorkspaceId } from \"./toolUtils\";\r\n\r\n/**\r\n * Build dynamic task tool description with available sub-agents.\r\n * Injects the list of available sub-agents directly into the tool description\r\n * so the model sees them adjacent to the tool call schema.\r\n */\r\nfunction buildTaskDescription(config: ToolConfiguration): string {\r\n  const baseDescription = TOOL_DEFINITIONS.task.description;\r\n  const subagents = config.availableSubagents?.filter((a) => a.subagentRunnable) ?? [];\r\n\r\n  if (subagents.length === 0) {\r\n    return baseDescription;\r\n  }\r\n\r\n  const subagentLines = subagents.map((agent) => {\r\n    const desc = agent.description ? `: ${agent.description}` : \"\";\r\n    return `- ${agent.id}${desc}`;\r\n  });\r\n\r\n  return `${baseDescription}\\n\\nAvailable sub-agents (use \\`agentId\\` parameter):\\n${subagentLines.join(\"\\n\")}`;\r\n}\r\n\r\nexport const createTaskTool: ToolFactory = (config: ToolConfiguration) => {\r\n  return tool({\r\n    description: buildTaskDescription(config),\r\n    inputSchema: TOOL_DEFINITIONS.task.schema,\r\n    execute: async (args, { abortSignal, toolCallId }): Promise<unknown> => {\r\n      // Defensive: tool() should have already validated args via inputSchema,\r\n      // but keep runtime validation here to preserve type-safety.\r\n      const parsedArgs = TOOL_DEFINITIONS.task.schema.safeParse(args);\r\n      if (!parsedArgs.success) {\r\n        const keys =\r\n          args && typeof args === \"object\" ? Object.keys(args as Record<string, unknown>) : [];\r\n        log.warn(\r\n          \"[task tool] Unexpected input validation failure (should have been caught by AI SDK)\",\r\n          {\r\n            issues: parsedArgs.error.issues,\r\n            keys,\r\n          }\r\n        );\r\n        throw new Error(`task tool input validation failed: ${parsedArgs.error.message}`);\r\n      }\r\n      const validatedArgs = parsedArgs.data;\r\n      if (abortSignal?.aborted) {\r\n        throw new Error(\"Interrupted\");\r\n      }\r\n\r\n      const { agentId, subagent_type, prompt, title, run_in_background } = validatedArgs;\r\n      const requestedAgentId =\r\n        typeof agentId === \"string\" && agentId.trim().length > 0 ? agentId : subagent_type;\r\n      if (!requestedAgentId || !prompt || !title) {\r\n        throw new Error(\"task tool input validation failed: expected agent task args\");\r\n      }\r\n\r\n      const workspaceId = requireWorkspaceId(config, \"task\");\r\n      const taskService = requireTaskService(config, \"task\");\r\n\r\n      // Nested task spawning is allowed and enforced via maxTaskNestingDepth in TaskService\r\n      // (and by tool policy at/over the depth limit).\r\n\r\n      // Plan agent is explicitly non-executing. Allow only read-only exploration tasks.\r\n      if (config.planFileOnly && requestedAgentId !== \"explore\") {\r\n        throw new Error('In the plan agent you may only spawn agentId: \"explore\" tasks.');\r\n      }\r\n\r\n      const modelString =\r\n        config.muxEnv && typeof config.muxEnv.MUX_MODEL_STRING === \"string\"\r\n          ? config.muxEnv.MUX_MODEL_STRING\r\n          : undefined;\r\n      const thinkingLevel = coerceThinkingLevel(config.muxEnv?.MUX_THINKING_LEVEL);\r\n\r\n      const created = await taskService.create({\r\n        parentWorkspaceId: workspaceId,\r\n        kind: \"agent\",\r\n        agentId: requestedAgentId,\r\n        // Legacy alias (persisted for older clients / on-disk compatibility).\r\n        agentType: requestedAgentId,\r\n        prompt,\r\n        title,\r\n        modelString,\r\n        thinkingLevel,\r\n        experiments: config.experiments,\r\n      });\r\n\r\n      if (!created.success) {\r\n        throw new Error(created.error);\r\n      }\r\n\r\n      const taskId = created.data.taskId;\r\n\r\n      // UI-only signal: expose the spawned taskId as soon as the workspace exists.\r\n      // This allows the frontend to show the taskId even when the task tool is running\r\n      // in foreground (run_in_background=false).\r\n      if (config.emitChatEvent && config.workspaceId && toolCallId) {\r\n        config.emitChatEvent({\r\n          type: \"task-created\",\r\n          workspaceId,\r\n          toolCallId,\r\n          taskId,\r\n          timestamp: Date.now(),\r\n        } satisfies TaskCreatedEvent);\r\n      }\r\n\r\n      if (run_in_background) {\r\n        return parseToolResult(\r\n          TaskToolResultSchema,\r\n          {\r\n            status: created.data.status,\r\n            taskId,\r\n            note: \"Task started in background. Use task_await to monitor progress.\",\r\n          },\r\n          \"task\"\r\n        );\r\n      }\r\n\r\n      try {\r\n        const report = await taskService.waitForAgentReport(taskId, {\r\n          abortSignal,\r\n          requestingWorkspaceId: workspaceId,\r\n        });\r\n\r\n        return parseToolResult(\r\n          TaskToolResultSchema,\r\n          {\r\n            status: \"completed\" as const,\r\n            taskId,\r\n            reportMarkdown: report.reportMarkdown,\r\n            title: report.title,\r\n            agentId: requestedAgentId,\r\n            agentType: requestedAgentId,\r\n          },\r\n          \"task\"\r\n        );\r\n      } catch (error: unknown) {\r\n        if (abortSignal?.aborted) {\r\n          throw new Error(\"Interrupted\");\r\n        }\r\n\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        if (message === \"Timed out waiting for agent_report\") {\r\n          const currentStatus = taskService.getAgentTaskStatus(taskId) ?? created.data.status;\r\n          const normalizedStatus = currentStatus === \"queued\" ? \"queued\" : \"running\";\r\n\r\n          return parseToolResult(\r\n            TaskToolResultSchema,\r\n            {\r\n              status: normalizedStatus,\r\n              taskId,\r\n              note: \"Task exceeded foreground wait limit and continues running in background. Use task_await to monitor progress.\",\r\n            },\r\n            \"task\"\r\n          );\r\n        }\r\n\r\n        throw error;\r\n      }\r\n    },\r\n  });\r\n};\r\n"]}