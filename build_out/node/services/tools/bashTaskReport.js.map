{"version":3,"file":"bashTaskReport.js","sourceRoot":"","sources":["../../../../src/node/services/tools/bashTaskReport.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from \"@/common/utils/assert\";\r\n\r\nfunction getMarkdownCodeFenceDelimiter(args: { output: string }): string {\r\n  assert(typeof args.output === \"string\", \"output must be a string\");\r\n\r\n  // Pick a fence longer than any run of backticks in the output so literal ``` lines\r\n  // can't terminate the block early (and lose the remaining output when re-parsing).\r\n  let longestBacktickRun = 0;\r\n  let currentRun = 0;\r\n  for (const char of args.output) {\r\n    if (char === \"`\") {\r\n      currentRun += 1;\r\n      continue;\r\n    }\r\n\r\n    if (currentRun > longestBacktickRun) {\r\n      longestBacktickRun = currentRun;\r\n    }\r\n    currentRun = 0;\r\n  }\r\n  if (currentRun > longestBacktickRun) {\r\n    longestBacktickRun = currentRun;\r\n  }\r\n\r\n  const fenceLength = Math.max(3, longestBacktickRun + 1);\r\n  return \"`\".repeat(fenceLength);\r\n}\r\nexport interface ParsedBashOutputReport {\r\n  processId: string;\r\n  status: string;\r\n  exitCode?: number;\r\n  output: string;\r\n}\r\n\r\nexport function formatBashOutputReport(args: {\r\n  processId: string;\r\n  status: string;\r\n  exitCode?: number;\r\n  output: string;\r\n}): string {\r\n  assert(typeof args.processId === \"string\" && args.processId.length > 0, \"processId required\");\r\n  assert(typeof args.status === \"string\" && args.status.length > 0, \"status required\");\r\n  assert(typeof args.output === \"string\", \"output must be a string\");\r\n\r\n  const lines: string[] = [];\r\n\r\n  lines.push(`### Bash task: ${args.processId}`);\r\n  lines.push(\"\");\r\n\r\n  lines.push(`status: ${args.status}`);\r\n  if (args.exitCode !== undefined) {\r\n    lines.push(`exitCode: ${args.exitCode}`);\r\n  }\r\n\r\n  if (args.output.trim().length > 0) {\r\n    const trimmedOutput = args.output.trimEnd();\r\n    const fence = getMarkdownCodeFenceDelimiter({ output: trimmedOutput });\r\n\r\n    lines.push(\"\");\r\n    lines.push(`${fence}text`);\r\n    lines.push(trimmedOutput);\r\n    lines.push(fence);\r\n  }\r\n\r\n  return lines.join(\"\\n\");\r\n}\r\n\r\nexport function tryParseBashOutputReport(\r\n  reportMarkdown: string\r\n): ParsedBashOutputReport | undefined {\r\n  if (typeof reportMarkdown !== \"string\") return undefined;\r\n\r\n  const lines = reportMarkdown.split(\"\\n\");\r\n  const header = lines[0] ?? \"\";\r\n  const headerPrefix = \"### Bash task:\";\r\n  if (!header.startsWith(headerPrefix)) {\r\n    return undefined;\r\n  }\r\n\r\n  const processId = header.slice(headerPrefix.length).trim();\r\n  if (!processId) {\r\n    return undefined;\r\n  }\r\n\r\n  // Parse fenced output block (optional).\r\n  const fenceStart = lines.findIndex((line) => /^`{3,}text\\s*$/.test(line.trimEnd()));\r\n\r\n  // Find status/exitCode lines. Keep this tolerant to extra blank lines.\r\n  // IMPORTANT: only scan the header section; the output block may contain literal\r\n  // \"status:\" / \"exitCode:\" lines that must not override the header.\r\n  const headerLines = fenceStart === -1 ? lines : lines.slice(0, fenceStart);\r\n\r\n  let status: string | undefined;\r\n  let exitCode: number | undefined;\r\n\r\n  for (const line of headerLines) {\r\n    if (status === undefined && line.startsWith(\"status:\")) {\r\n      status = line.slice(\"status:\".length).trim();\r\n      continue;\r\n    }\r\n\r\n    if (exitCode === undefined && line.startsWith(\"exitCode:\")) {\r\n      const parsed = Number.parseInt(line.slice(\"exitCode:\".length).trim(), 10);\r\n      if (Number.isFinite(parsed)) {\r\n        exitCode = parsed;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!status) {\r\n    return undefined;\r\n  }\r\n\r\n  let output = \"\";\r\n  if (fenceStart !== -1) {\r\n    const fenceLine = lines[fenceStart]?.trimEnd() ?? \"\";\r\n    const match = /^(`{3,})text\\s*$/.exec(fenceLine);\r\n    if (!match) {\r\n      return undefined;\r\n    }\r\n\r\n    const fence = match[1];\r\n\r\n    // We always append the closing fence at the end of the report. If the output contains\r\n    // literal fence lines (e.g. \"```\"), picking the *first* closing fence would truncate\r\n    // the parsed output and permanently drop data when we rewrite the report.\r\n    let fenceEnd = -1;\r\n    for (let index = lines.length - 1; index > fenceStart; index -= 1) {\r\n      if ((lines[index]?.trimEnd() ?? \"\") !== fence) {\r\n        continue;\r\n      }\r\n\r\n      const onlyBlankLinesAfterFence = lines\r\n        .slice(index + 1)\r\n        .every((line) => line.trim().length === 0);\r\n      if (onlyBlankLinesAfterFence) {\r\n        fenceEnd = index;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (fenceEnd === -1) {\r\n      fenceEnd = lines.findIndex((line, index) => index > fenceStart && line.trimEnd() === fence);\r\n    }\r\n\r\n    if (fenceEnd === -1) {\r\n      return undefined;\r\n    }\r\n\r\n    output = lines.slice(fenceStart + 1, fenceEnd).join(\"\\n\");\r\n  }\r\n\r\n  return { processId, status, exitCode, output };\r\n}\r\n"]}