{"version":3,"file":"bashTaskReport.js","sourceRoot":"","sources":["../../../../src/node/services/tools/bashTaskReport.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from \"@/common/utils/assert\";\n\nfunction getMarkdownCodeFenceDelimiter(args: { output: string }): string {\n  assert(typeof args.output === \"string\", \"output must be a string\");\n\n  // Pick a fence longer than any run of backticks in the output so literal ``` lines\n  // can't terminate the block early (and lose the remaining output when re-parsing).\n  let longestBacktickRun = 0;\n  let currentRun = 0;\n  for (const char of args.output) {\n    if (char === \"`\") {\n      currentRun += 1;\n      continue;\n    }\n\n    if (currentRun > longestBacktickRun) {\n      longestBacktickRun = currentRun;\n    }\n    currentRun = 0;\n  }\n  if (currentRun > longestBacktickRun) {\n    longestBacktickRun = currentRun;\n  }\n\n  const fenceLength = Math.max(3, longestBacktickRun + 1);\n  return \"`\".repeat(fenceLength);\n}\nexport interface ParsedBashOutputReport {\n  processId: string;\n  status: string;\n  exitCode?: number;\n  output: string;\n}\n\nexport function formatBashOutputReport(args: {\n  processId: string;\n  status: string;\n  exitCode?: number;\n  output: string;\n}): string {\n  assert(typeof args.processId === \"string\" && args.processId.length > 0, \"processId required\");\n  assert(typeof args.status === \"string\" && args.status.length > 0, \"status required\");\n  assert(typeof args.output === \"string\", \"output must be a string\");\n\n  const lines: string[] = [];\n\n  lines.push(`### Bash task: ${args.processId}`);\n  lines.push(\"\");\n\n  lines.push(`status: ${args.status}`);\n  if (args.exitCode !== undefined) {\n    lines.push(`exitCode: ${args.exitCode}`);\n  }\n\n  if (args.output.trim().length > 0) {\n    const trimmedOutput = args.output.trimEnd();\n    const fence = getMarkdownCodeFenceDelimiter({ output: trimmedOutput });\n\n    lines.push(\"\");\n    lines.push(`${fence}text`);\n    lines.push(trimmedOutput);\n    lines.push(fence);\n  }\n\n  return lines.join(\"\\n\");\n}\n\nexport function tryParseBashOutputReport(\n  reportMarkdown: string\n): ParsedBashOutputReport | undefined {\n  if (typeof reportMarkdown !== \"string\") return undefined;\n\n  const lines = reportMarkdown.split(\"\\n\");\n  const header = lines[0] ?? \"\";\n  const headerPrefix = \"### Bash task:\";\n  if (!header.startsWith(headerPrefix)) {\n    return undefined;\n  }\n\n  const processId = header.slice(headerPrefix.length).trim();\n  if (!processId) {\n    return undefined;\n  }\n\n  // Parse fenced output block (optional).\n  const fenceStart = lines.findIndex((line) => /^`{3,}text\\s*$/.test(line.trimEnd()));\n\n  // Find status/exitCode lines. Keep this tolerant to extra blank lines.\n  // IMPORTANT: only scan the header section; the output block may contain literal\n  // \"status:\" / \"exitCode:\" lines that must not override the header.\n  const headerLines = fenceStart === -1 ? lines : lines.slice(0, fenceStart);\n\n  let status: string | undefined;\n  let exitCode: number | undefined;\n\n  for (const line of headerLines) {\n    if (status === undefined && line.startsWith(\"status:\")) {\n      status = line.slice(\"status:\".length).trim();\n      continue;\n    }\n\n    if (exitCode === undefined && line.startsWith(\"exitCode:\")) {\n      const parsed = Number.parseInt(line.slice(\"exitCode:\".length).trim(), 10);\n      if (Number.isFinite(parsed)) {\n        exitCode = parsed;\n      }\n    }\n  }\n\n  if (!status) {\n    return undefined;\n  }\n\n  let output = \"\";\n  if (fenceStart !== -1) {\n    const fenceLine = lines[fenceStart]?.trimEnd() ?? \"\";\n    const match = /^(`{3,})text\\s*$/.exec(fenceLine);\n    if (!match) {\n      return undefined;\n    }\n\n    const fence = match[1];\n\n    // We always append the closing fence at the end of the report. If the output contains\n    // literal fence lines (e.g. \"```\"), picking the *first* closing fence would truncate\n    // the parsed output and permanently drop data when we rewrite the report.\n    let fenceEnd = -1;\n    for (let index = lines.length - 1; index > fenceStart; index -= 1) {\n      if ((lines[index]?.trimEnd() ?? \"\") !== fence) {\n        continue;\n      }\n\n      const onlyBlankLinesAfterFence = lines\n        .slice(index + 1)\n        .every((line) => line.trim().length === 0);\n      if (onlyBlankLinesAfterFence) {\n        fenceEnd = index;\n        break;\n      }\n    }\n\n    if (fenceEnd === -1) {\n      fenceEnd = lines.findIndex((line, index) => index > fenceStart && line.trimEnd() === fence);\n    }\n\n    if (fenceEnd === -1) {\n      return undefined;\n    }\n\n    output = lines.slice(fenceStart + 1, fenceEnd).join(\"\\n\");\n  }\n\n  return { processId, status, exitCode, output };\n}\n"]}