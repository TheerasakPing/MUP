{"version":3,"file":"bash_output.js","sourceRoot":"","sources":["../../../../src/node/services/tools/bash_output.ts"],"names":[],"mappings":";;;AAAA,2BAA0B;AAG1B,0EAAwE;AAExE;;;GAGG;AACI,MAAM,oBAAoB,GAAgB,CAAC,MAAyB,EAAE,EAAE,CAAC;IAC9E,OAAO,IAAA,SAAI,EAAC;QACV,WAAW,EAAE,kCAAgB,CAAC,WAAW,CAAC,WAAW;QACrD,WAAW,EAAE,kCAAgB,CAAC,WAAW,CAAC,MAAM;QAChD,OAAO,EAAE,KAAK,EACZ,EAAE,UAAU,EAAE,MAAM,EAAE,cAAc,EAAE,YAAY,EAAE,EACpD,EAAE,WAAW,EAAE,EACgB,EAAE,CAAC;YAClC,IAAI,CAAC,MAAM,CAAC,wBAAwB,EAAE,CAAC;gBACrC,OAAO;oBACL,OAAO,EAAE,KAAK;oBACd,KAAK,EAAE,0CAA0C;iBAClD,CAAC;YACJ,CAAC;YAED,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC;gBACxB,OAAO;oBACL,OAAO,EAAE,KAAK;oBACd,KAAK,EAAE,4BAA4B;iBACpC,CAAC;YACJ,CAAC;YAED,2CAA2C;YAC3C,MAAM,IAAI,GAAG,MAAM,MAAM,CAAC,wBAAwB,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;YAC1E,IAAI,IAAI,EAAE,WAAW,KAAK,MAAM,CAAC,WAAW,EAAE,CAAC;gBAC7C,OAAO;oBACL,OAAO,EAAE,KAAK;oBACd,KAAK,EAAE,sBAAsB,UAAU,0HAA0H;iBAClK,CAAC;YACJ,CAAC;YAED,4CAA4C;YAC5C,8DAA8D;YAC9D,OAAO,MAAM,MAAM,CAAC,wBAAwB,CAAC,SAAS,CACpD,UAAU,EACV,MAAM,IAAI,SAAS,EACnB,cAAc,IAAI,SAAS,EAC3B,YAAY,EACZ,WAAW,EACX,MAAM,CAAC,WAAW,CACnB,CAAC;QAAA,CACH;KACF,CAAC,CAAC;AAAA,CACJ,CAAC;AA3CW,QAAA,oBAAoB,GAApB,oBAAoB,CA2C/B","sourcesContent":["import { tool } from \"ai\";\r\nimport type { BashOutputToolResult } from \"@/common/types/tools\";\r\nimport type { ToolConfiguration, ToolFactory } from \"@/common/utils/tools/tools\";\r\nimport { TOOL_DEFINITIONS } from \"@/common/utils/tools/toolDefinitions\";\r\n\r\n/**\r\n * Tool for retrieving incremental output from background processes.\r\n * Mimics Claude Code's BashOutput tool - returns only new output since last check.\r\n */\r\nexport const createBashOutputTool: ToolFactory = (config: ToolConfiguration) => {\r\n  return tool({\r\n    description: TOOL_DEFINITIONS.bash_output.description,\r\n    inputSchema: TOOL_DEFINITIONS.bash_output.schema,\r\n    execute: async (\r\n      { process_id, filter, filter_exclude, timeout_secs },\r\n      { abortSignal }\r\n    ): Promise<BashOutputToolResult> => {\r\n      if (!config.backgroundProcessManager) {\r\n        return {\r\n          success: false,\r\n          error: \"Background process manager not available\",\r\n        };\r\n      }\r\n\r\n      if (!config.workspaceId) {\r\n        return {\r\n          success: false,\r\n          error: \"Workspace ID not available\",\r\n        };\r\n      }\r\n\r\n      // Verify process belongs to this workspace\r\n      const proc = await config.backgroundProcessManager.getProcess(process_id);\r\n      if (proc?.workspaceId !== config.workspaceId) {\r\n        return {\r\n          success: false,\r\n          error: `Process not found: ${process_id}. The process may have exited or the app was restarted. Do not retry - use bash_background_list to see active processes.`,\r\n        };\r\n      }\r\n\r\n      // Get incremental output with blocking wait\r\n      // Pass workspaceId so getOutput can check for queued messages\r\n      return await config.backgroundProcessManager.getOutput(\r\n        process_id,\r\n        filter ?? undefined,\r\n        filter_exclude ?? undefined,\r\n        timeout_secs,\r\n        abortSignal,\r\n        config.workspaceId\r\n      );\r\n    },\r\n  });\r\n};\r\n"]}