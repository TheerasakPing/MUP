{"version":3,"file":"code_execution.js","sourceRoot":"","sources":["../../../../src/node/services/tools/code_execution.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;;;;AAEH,2BAA0B;AAC1B,6BAAwB;AAExB,+DAA4D;AAI5D,uEAAiE;AACjE,qEAAsF;AAEtF,iBAAiB;AACjB,MAAM,oBAAoB,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC,OAAO;AACtD,MAAM,oBAAoB,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,YAAY;AACjD,MAAM,gBAAgB,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,SAAS;AAE3C;;GAEG;AACH,2BAAwC;IACtC,IAAA,8BAAc,GAAE,CAAC;AAAA,CAClB;AAED;;;;GAIG;AACI,KAAK,8BAA8B,KAA2B,EAAiB;IACpF,MAAM,UAAU,GAAG,IAAI,uBAAU,CAAC,KAAK,CAAC,CAAC;IACzC,MAAM,IAAA,iCAAiB,EAAC,UAAU,CAAC,kBAAkB,EAAE,CAAC,CAAC;AAAA,CAC1D;AAKD;;;;;;;;;GASG;AACI,KAAK,kCACV,cAAiC,EACjC,UAAsB,EACtB,eAAqD,EACtC;IACf,MAAM,eAAe,GAAG,UAAU,CAAC,kBAAkB,EAAE,CAAC;IAExD,qFAAqF;IACrF,MAAM,QAAQ,GAAG,MAAM,IAAA,iCAAiB,EAAC,eAAe,CAAC,CAAC;IAE1D,OAAO,IAAA,SAAI,EAAC;QACV,WAAW,EAAE;;;;;;EAMf,QAAQ;;;;;;;;;;sIAU4H;QAElI,WAAW,EAAE,OAAC,CAAC,MAAM,CAAC;YACpB,IAAI,EAAE,OAAC;iBACJ,MAAM,EAAE;iBACR,GAAG,CAAC,CAAC,CAAC;iBACN,QAAQ,CACP,4GAA0G,CAC3G;YACH,YAAY,EAAE,OAAC;iBACZ,MAAM,EAAE;iBACR,GAAG,EAAE;iBACL,QAAQ,EAAE;iBACV,OAAO,EAAE;iBACT,QAAQ,CACP,0DAA0D;gBACxD,+DAA+D,CAClE;SACJ,CAAC;QAEF,OAAO,EAAE,KAAK,EACZ,EAAE,IAAI,EAAE,YAAY,EAAE,EACtB,EAAE,WAAW,EAAE,UAAU,EAAE,EACE,EAAE,CAAC;YAChC,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAEjC,8FAA8F;YAC9F,MAAM,QAAQ,GAAG,MAAM,IAAA,4BAAW,EAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;YACnD,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;gBACpB,MAAM,aAAa,GAAG,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;oBAC/C,MAAM,QAAQ,GACZ,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,MAAM;wBAChB,CAAC,CAAC,UAAU,CAAC,CAAC,IAAI,SAAS,CAAC,CAAC,MAAM,GAAG;wBACtC,CAAC,CAAC,CAAC,CAAC,IAAI;4BACN,CAAC,CAAC,UAAU,CAAC,CAAC,IAAI,GAAG;4BACrB,CAAC,CAAC,EAAE,CAAC;oBACX,OAAO,KAAK,CAAC,CAAC,OAAO,GAAG,QAAQ,EAAE,CAAC;gBAAA,CACpC,CAAC,CAAC;gBACH,OAAO;oBACL,OAAO,EAAE,KAAK;oBACd,KAAK,EAAE,0BAA0B,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;oBAC3D,SAAS,EAAE,EAAE;oBACb,aAAa,EAAE,EAAE;oBACjB,WAAW,EAAE,IAAI,CAAC,GAAG,EAAE,GAAG,aAAa;iBACxC,CAAC;YACJ,CAAC;YAED,sCAAsC;YACtC,MAAM,OAAO,GAAG,MAAM,cAAc,CAAC,MAAM,EAAE,CAAC;YAE9C,IAAI,CAAC;gBACH,6CAA6C;gBAC7C,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,YAAY,IAAI,oBAAoB,EAAE,gBAAgB,CAAC,CAAC;gBACrF,OAAO,CAAC,SAAS,CAAC;oBAChB,WAAW,EAAE,oBAAoB;oBACjC,SAAS,EAAE,WAAW,GAAG,IAAI;iBAC9B,CAAC,CAAC;gBAEH,uCAAuC;gBACvC,gEAAgE;gBAChE,IAAI,eAAe,EAAE,CAAC;oBACpB,OAAO,CAAC,OAAO,CAAC,CAAC,KAAe,EAAE,EAAE,CAAC;wBACnC,eAAe,CAAC,EAAE,GAAG,KAAK,EAAE,gBAAgB,EAAE,UAAU,EAAE,CAAC,CAAC;oBAAA,CAC7D,CAAC,CAAC;gBACL,CAAC;gBAED,yEAAyE;gBACzE,UAAU,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;gBAE7B,kEAAkE;gBAClE,IAAI,WAAW,EAAE,CAAC;oBAChB,gDAAgD;oBAChD,IAAI,WAAW,CAAC,OAAO,EAAE,CAAC;wBACxB,OAAO,CAAC,KAAK,EAAE,CAAC;oBAClB,CAAC;yBAAM,CAAC;wBACN,WAAW,CAAC,gBAAgB,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;oBAC/E,CAAC;gBACH,CAAC;gBAED,mBAAmB;gBACnB,OAAO,MAAM,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAClC,CAAC;oBAAS,CAAC;gBACT,6BAA6B;gBAC7B,OAAO,CAAC,OAAO,EAAE,CAAC;YACpB,CAAC;QAAA,CACF;KACF,CAAC,CAAC;AAAA,CACJ","sourcesContent":["/**\n * Code Execution Tool for Programmatic Tool Calling (PTC)\n *\n * Executes JavaScript code in a sandboxed QuickJS environment with access to all\n * Mux tools via the `mux.*` namespace. Enables multi-tool workflows in a single\n * inference instead of multiple round-trips.\n */\n\nimport { tool } from \"ai\";\nimport { z } from \"zod\";\nimport type { Tool } from \"ai\";\nimport { ToolBridge } from \"@/node/services/ptc/toolBridge\";\nimport type { IJSRuntimeFactory } from \"@/node/services/ptc/runtime\";\nimport type { PTCEvent, PTCExecutionResult } from \"@/node/services/ptc/types\";\n\nimport { analyzeCode } from \"@/node/services/ptc/staticAnalysis\";\nimport { getCachedMuxTypes, clearTypeCache } from \"@/node/services/ptc/typeGenerator\";\n\n// Default limits\nconst DEFAULT_MEMORY_BYTES = 64 * 1024 * 1024; // 64MB\nconst DEFAULT_TIMEOUT_SECS = 5 * 60; // 5 minutes\nconst MAX_TIMEOUT_SECS = 60 * 60; // 1 hour\n\n/**\n * Clear all type caches. Call for test isolation or when tool schemas might have changed.\n */\nexport function clearTypeCaches(): void {\n  clearTypeCache();\n}\n\n/**\n * Pre-generate type definitions for the given tools.\n * Call during workspace initialization to avoid first-call latency.\n * Integration with workspace initialization is handled in Phase 6.\n */\nexport async function preGenerateMuxTypes(tools: Record<string, Tool>): Promise<void> {\n  const toolBridge = new ToolBridge(tools);\n  await getCachedMuxTypes(toolBridge.getBridgeableTools());\n}\n\n/** PTC event with parentToolCallId attached by code_execution */\nexport type PTCEventWithParent = PTCEvent & { parentToolCallId: string };\n\n/**\n * Create the code_execution tool.\n *\n * This function is async because it generates TypeScript type definitions\n * from the tool schemas, which requires async JSON Schema to TypeScript conversion.\n *\n * @param runtimeFactory Factory for creating QuickJS runtime instances\n * @param toolBridge Bridge containing tools to expose in sandbox\n * @param emitNestedEvent Callback for streaming nested tool events (includes parentToolCallId)\n */\nexport async function createCodeExecutionTool(\n  runtimeFactory: IJSRuntimeFactory,\n  toolBridge: ToolBridge,\n  emitNestedEvent?: (event: PTCEventWithParent) => void\n): Promise<Tool> {\n  const bridgeableTools = toolBridge.getBridgeableTools();\n\n  // Generate mux types for type validation and documentation (cached by tool set hash)\n  const muxTypes = await getCachedMuxTypes(bridgeableTools);\n\n  return tool({\n    description: `Execute sandboxed JavaScript to batch tools and transform outputs.\n\n**When to use:** Prefer this tool when making 2+ tool calls, especially when later calls depend on earlier results. Reduces round-trip latency.\n\n**Available tools (TypeScript definitions):**\n\\`\\`\\`typescript\n${muxTypes}\n\\`\\`\\`\n\n**Usage notes:**\n- \\`mux.*\\` functions are synchronous—do not use \\`await\\`\n- Use \\`return\\` to provide a final result to the model\n- Use \\`console.log/warn/error\\` for debugging - output is captured\n- Results are JSON-serialized; non-serializable values return \\`{ error: \"...\" }\\`\n- On failure, partial results (completed tool calls) are returned for debugging\n\n**Security:** The sandbox has no access to \\`require\\`, \\`import\\`, \\`process\\`, \\`fetch\\`, or filesystem outside of \\`mux.*\\` tools.`,\n\n    inputSchema: z.object({\n      code: z\n        .string()\n        .min(1)\n        .describe(\n          \"JavaScript code to execute. mux.* calls are synchronous—do not use await. Use 'return' for final result.\"\n        ),\n      timeout_secs: z\n        .number()\n        .int()\n        .positive()\n        .nullish()\n        .describe(\n          \"Execution timeout in seconds (default: 300, max: 3600). \" +\n            \"Increase when spawning subagents that may take 5-15+ minutes.\"\n        ),\n    }),\n\n    execute: async (\n      { code, timeout_secs },\n      { abortSignal, toolCallId }\n    ): Promise<PTCExecutionResult> => {\n      const execStartTime = Date.now();\n\n      // Static analysis before execution - catch syntax errors, forbidden patterns, and type errors\n      const analysis = await analyzeCode(code, muxTypes);\n      if (!analysis.valid) {\n        const errorMessages = analysis.errors.map((e) => {\n          const location =\n            e.line && e.column\n              ? ` (line ${e.line}, col ${e.column})`\n              : e.line\n                ? ` (line ${e.line})`\n                : \"\";\n          return `- ${e.message}${location}`;\n        });\n        return {\n          success: false,\n          error: `Code analysis failed:\\n${errorMessages.join(\"\\n\")}`,\n          toolCalls: [],\n          consoleOutput: [],\n          duration_ms: Date.now() - execStartTime,\n        };\n      }\n\n      // Create runtime with resource limits\n      const runtime = await runtimeFactory.create();\n\n      try {\n        // Set resource limits (clamp timeout to max)\n        const timeoutSecs = Math.min(timeout_secs ?? DEFAULT_TIMEOUT_SECS, MAX_TIMEOUT_SECS);\n        runtime.setLimits({\n          memoryBytes: DEFAULT_MEMORY_BYTES,\n          timeoutMs: timeoutSecs * 1000,\n        });\n\n        // Subscribe to events for UI streaming\n        // Wrap callback to include parentToolCallId from AI SDK context\n        if (emitNestedEvent) {\n          runtime.onEvent((event: PTCEvent) => {\n            emitNestedEvent({ ...event, parentToolCallId: toolCallId });\n          });\n        }\n\n        // Register tools - they'll use runtime.getAbortSignal() for cancellation\n        toolBridge.register(runtime);\n\n        // Handle abort signal - interrupt sandbox and cancel nested tools\n        if (abortSignal) {\n          // If already aborted, abort runtime immediately\n          if (abortSignal.aborted) {\n            runtime.abort();\n          } else {\n            abortSignal.addEventListener(\"abort\", () => runtime.abort(), { once: true });\n          }\n        }\n\n        // Execute the code\n        return await runtime.eval(code);\n      } finally {\n        // Clean up runtime resources\n        runtime.dispose();\n      }\n    },\n  });\n}\n"]}