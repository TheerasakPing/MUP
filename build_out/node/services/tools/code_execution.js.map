{"version":3,"file":"code_execution.js","sourceRoot":"","sources":["../../../../src/node/services/tools/code_execution.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Code Execution Tool for Programmatic Tool Calling (PTC)\r\n *\r\n * Executes JavaScript code in a sandboxed QuickJS environment with access to all\r\n * Mux tools via the `mux.*` namespace. Enables multi-tool workflows in a single\r\n * inference instead of multiple round-trips.\r\n */\r\n\r\nimport { tool } from \"ai\";\r\nimport { z } from \"zod\";\r\nimport type { Tool } from \"ai\";\r\nimport { ToolBridge } from \"@/node/services/ptc/toolBridge\";\r\nimport type { IJSRuntimeFactory } from \"@/node/services/ptc/runtime\";\r\nimport type { PTCEvent, PTCExecutionResult } from \"@/node/services/ptc/types\";\r\n\r\nimport { analyzeCode } from \"@/node/services/ptc/staticAnalysis\";\r\nimport { getCachedMuxTypes, clearTypeCache } from \"@/node/services/ptc/typeGenerator\";\r\n\r\n// Default limits\r\nconst DEFAULT_MEMORY_BYTES = 64 * 1024 * 1024; // 64MB\r\nconst DEFAULT_TIMEOUT_SECS = 5 * 60; // 5 minutes\r\nconst MAX_TIMEOUT_SECS = 60 * 60; // 1 hour\r\n\r\n/**\r\n * Clear all type caches. Call for test isolation or when tool schemas might have changed.\r\n */\r\nexport function clearTypeCaches(): void {\r\n  clearTypeCache();\r\n}\r\n\r\n/**\r\n * Pre-generate type definitions for the given tools.\r\n * Call during workspace initialization to avoid first-call latency.\r\n * Integration with workspace initialization is handled in Phase 6.\r\n */\r\nexport async function preGenerateMuxTypes(tools: Record<string, Tool>): Promise<void> {\r\n  const toolBridge = new ToolBridge(tools);\r\n  await getCachedMuxTypes(toolBridge.getBridgeableTools());\r\n}\r\n\r\n/** PTC event with parentToolCallId attached by code_execution */\r\nexport type PTCEventWithParent = PTCEvent & { parentToolCallId: string };\r\n\r\n/**\r\n * Create the code_execution tool.\r\n *\r\n * This function is async because it generates TypeScript type definitions\r\n * from the tool schemas, which requires async JSON Schema to TypeScript conversion.\r\n *\r\n * @param runtimeFactory Factory for creating QuickJS runtime instances\r\n * @param toolBridge Bridge containing tools to expose in sandbox\r\n * @param emitNestedEvent Callback for streaming nested tool events (includes parentToolCallId)\r\n */\r\nexport async function createCodeExecutionTool(\r\n  runtimeFactory: IJSRuntimeFactory,\r\n  toolBridge: ToolBridge,\r\n  emitNestedEvent?: (event: PTCEventWithParent) => void\r\n): Promise<Tool> {\r\n  const bridgeableTools = toolBridge.getBridgeableTools();\r\n\r\n  // Generate mux types for type validation and documentation (cached by tool set hash)\r\n  const muxTypes = await getCachedMuxTypes(bridgeableTools);\r\n\r\n  return tool({\r\n    description: `Execute sandboxed JavaScript to batch tools and transform outputs.\r\n\r\n**When to use:** Prefer this tool when making 2+ tool calls, especially when later calls depend on earlier results. Reduces round-trip latency.\r\n\r\n**Available tools (TypeScript definitions):**\r\n\\`\\`\\`typescript\r\n${muxTypes}\r\n\\`\\`\\`\r\n\r\n**Usage notes:**\r\n- \\`mux.*\\` functions are synchronous—do not use \\`await\\`\r\n- Use \\`return\\` to provide a final result to the model\r\n- Use \\`console.log/warn/error\\` for debugging - output is captured\r\n- Results are JSON-serialized; non-serializable values return \\`{ error: \"...\" }\\`\r\n- On failure, partial results (completed tool calls) are returned for debugging\r\n\r\n**Security:** The sandbox has no access to \\`require\\`, \\`import\\`, \\`process\\`, \\`fetch\\`, or filesystem outside of \\`mux.*\\` tools.`,\r\n\r\n    inputSchema: z.object({\r\n      code: z\r\n        .string()\r\n        .min(1)\r\n        .describe(\r\n          \"JavaScript code to execute. mux.* calls are synchronous—do not use await. Use 'return' for final result.\"\r\n        ),\r\n      timeout_secs: z\r\n        .number()\r\n        .int()\r\n        .positive()\r\n        .nullish()\r\n        .describe(\r\n          \"Execution timeout in seconds (default: 300, max: 3600). \" +\r\n            \"Increase when spawning subagents that may take 5-15+ minutes.\"\r\n        ),\r\n    }),\r\n\r\n    execute: async (\r\n      { code, timeout_secs },\r\n      { abortSignal, toolCallId }\r\n    ): Promise<PTCExecutionResult> => {\r\n      const execStartTime = Date.now();\r\n\r\n      // Static analysis before execution - catch syntax errors, forbidden patterns, and type errors\r\n      const analysis = await analyzeCode(code, muxTypes);\r\n      if (!analysis.valid) {\r\n        const errorMessages = analysis.errors.map((e) => {\r\n          const location =\r\n            e.line && e.column\r\n              ? ` (line ${e.line}, col ${e.column})`\r\n              : e.line\r\n                ? ` (line ${e.line})`\r\n                : \"\";\r\n          return `- ${e.message}${location}`;\r\n        });\r\n        return {\r\n          success: false,\r\n          error: `Code analysis failed:\\n${errorMessages.join(\"\\n\")}`,\r\n          toolCalls: [],\r\n          consoleOutput: [],\r\n          duration_ms: Date.now() - execStartTime,\r\n        };\r\n      }\r\n\r\n      // Create runtime with resource limits\r\n      const runtime = await runtimeFactory.create();\r\n\r\n      try {\r\n        // Set resource limits (clamp timeout to max)\r\n        const timeoutSecs = Math.min(timeout_secs ?? DEFAULT_TIMEOUT_SECS, MAX_TIMEOUT_SECS);\r\n        runtime.setLimits({\r\n          memoryBytes: DEFAULT_MEMORY_BYTES,\r\n          timeoutMs: timeoutSecs * 1000,\r\n        });\r\n\r\n        // Subscribe to events for UI streaming\r\n        // Wrap callback to include parentToolCallId from AI SDK context\r\n        if (emitNestedEvent) {\r\n          runtime.onEvent((event: PTCEvent) => {\r\n            emitNestedEvent({ ...event, parentToolCallId: toolCallId });\r\n          });\r\n        }\r\n\r\n        // Register tools - they'll use runtime.getAbortSignal() for cancellation\r\n        toolBridge.register(runtime);\r\n\r\n        // Handle abort signal - interrupt sandbox and cancel nested tools\r\n        if (abortSignal) {\r\n          // If already aborted, abort runtime immediately\r\n          if (abortSignal.aborted) {\r\n            runtime.abort();\r\n          } else {\r\n            abortSignal.addEventListener(\"abort\", () => runtime.abort(), { once: true });\r\n          }\r\n        }\r\n\r\n        // Execute the code\r\n        return await runtime.eval(code);\r\n      } finally {\r\n        // Clean up runtime resources\r\n        runtime.dispose();\r\n      }\r\n    },\r\n  });\r\n}\r\n"]}