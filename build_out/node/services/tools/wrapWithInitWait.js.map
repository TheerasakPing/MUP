{"version":3,"file":"wrapWithInitWait.js","sourceRoot":"","sources":["../../../../src/node/services/tools/wrapWithInitWait.ts"],"names":[],"mappings":";;;AAGA;;;;;;;;;;;;;GAaG;AACH,0BACE,IAAgC,EAChC,WAAmB,EACnB,gBAAkC,EACN;IAC5B,yEAAyE;IACzE,OAAO;QACL,GAAG,IAAI;QACP,OAAO,EAAE,KAAK,EAAE,IAAiB,EAAE,OAAO,EAAE,EAAE,CAAC;YAC7C,MAAM,WAAW,GACf,OAAO,IAAI,OAAO,OAAO,KAAK,QAAQ,IAAI,aAAa,IAAI,OAAO;gBAChE,CAAC,CAAE,OAAyC,CAAC,WAAW;gBACxD,CAAC,CAAC,SAAS,CAAC;YAEhB,sEAAsE;YACtE,+DAA+D;YAC/D,8FAA8F;YAC9F,MAAM,gBAAgB,CAAC,WAAW,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;YAE7D,6CAA6C;YAC7C,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;gBAClB,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;YAC5D,CAAC;YACD,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAAA,CACpC;KAC4B,CAAC;AAAA,CACjC","sourcesContent":["import type { Tool } from \"ai\";\r\nimport type { InitStateManager } from \"@/node/services/initStateManager\";\r\n\r\n/**\r\n * Wraps a tool to wait for workspace initialization before execution.\r\n *\r\n * This wrapper handles the cross-cutting concern of init state waiting,\r\n * keeping individual tools simple and focused on their core functionality.\r\n *\r\n * Only runtime-dependent tools (bash, file_read, file_edit_*) need this wrapper.\r\n * Non-runtime tools (propose_plan, todo, web_search) execute immediately.\r\n *\r\n * @param tool The tool to wrap (returned from a tool factory)\r\n * @param workspaceId Workspace ID for init state tracking\r\n * @param initStateManager Init state manager for waiting\r\n * @returns Wrapped tool that waits for init before executing\r\n */\r\nexport function wrapWithInitWait<TParameters, TResult>(\r\n  tool: Tool<TParameters, TResult>,\r\n  workspaceId: string,\r\n  initStateManager: InitStateManager\r\n): Tool<TParameters, TResult> {\r\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\r\n  return {\r\n    ...tool,\r\n    execute: async (args: TParameters, options) => {\r\n      const abortSignal =\r\n        options && typeof options === \"object\" && \"abortSignal\" in options\r\n          ? (options as { abortSignal?: AbortSignal }).abortSignal\r\n          : undefined;\r\n\r\n      // Wait for workspace initialization to complete (no-op if not needed)\r\n      // This never throws - tools proceed regardless of init outcome\r\n      // Forward abort signals so tool cancellation stays responsive during long provisioning waits.\r\n      await initStateManager.waitForInit(workspaceId, abortSignal);\r\n\r\n      // Execute the actual tool with all arguments\r\n      if (!tool.execute) {\r\n        throw new Error(\"Tool does not have an execute function\");\r\n      }\r\n      return tool.execute(args, options);\r\n    },\r\n  } as Tool<TParameters, TResult>;\r\n}\r\n"]}