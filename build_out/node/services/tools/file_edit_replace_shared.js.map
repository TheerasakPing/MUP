{"version":3,"file":"file_edit_replace_shared.js","sourceRoot":"","sources":["../../../../src/node/services/tools/file_edit_replace_shared.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;;;;AAEH,gDAO8B;AAE9B,+BAA8E;AA2B9E;;GAEG;AACH,6BACE,IAAuB,EACvB,eAAuB,EACL;IAClB,MAAM,YAAY,GAAG,IAAI,CAAC,aAAa,IAAI,CAAC,CAAC;IAE7C,MAAM,OAAO,GAAG,IAAA,mBAAa,EAAC,eAAe,CAAC,CAAC;IAC/C,MAAM,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC;IACvC,MAAM,gBAAgB,GAAG,IAAA,qBAAe,EAAC,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;IACnE,MAAM,gBAAgB,GAAG,IAAA,qBAAe,EAAC,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;IAEnE,6EAA6E;IAC7E,6DAA6D;IAC7D,IAAI,gBAAgB,GAAG,cAAc,CAAC;IACtC,IACE,CAAC,eAAe,CAAC,QAAQ,CAAC,gBAAgB,CAAC;QAC3C,gBAAgB,KAAK,cAAc;QACnC,eAAe,CAAC,QAAQ,CAAC,gBAAgB,CAAC,EAC1C,CAAC;QACD,gBAAgB,GAAG,gBAAgB,CAAC;IACtC,CAAC;IAED,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,gBAAgB,CAAC,EAAE,CAAC;QAChD,OAAO;YACL,OAAO,EAAE,KAAK;YACd,KAAK,EAAE,2EAA2E;YAClF,IAAI,EAAE,GAAG,+BAAuB,+CAA+C,kCAA0B,EAAE;SAC5G,CAAC;IACJ,CAAC;IAED,MAAM,KAAK,GAAG,eAAe,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;IACtD,MAAM,WAAW,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;IAErC,IAAI,YAAY,KAAK,CAAC,IAAI,WAAW,GAAG,CAAC,EAAE,CAAC;QAC1C,OAAO;YACL,OAAO,EAAE,KAAK;YACd,KAAK,EAAE,sBAAsB,WAAW,2FAA2F,WAAW,SAAS;YACvJ,IAAI,EAAE,GAAG,+BAAuB,2BAA2B,WAAW,oFAAoF,WAAW,8BAA8B;SACpM,CAAC;IACJ,CAAC;IAED,IAAI,YAAY,GAAG,WAAW,IAAI,YAAY,KAAK,CAAC,CAAC,EAAE,CAAC;QACtD,OAAO;YACL,OAAO,EAAE,KAAK;YACd,KAAK,EAAE,oBAAoB,YAAY,gCAAgC,WAAW,uBAAuB;YACzG,IAAI,EAAE,GAAG,+BAAuB,sBAAsB,YAAY,0CAA0C,WAAW,SAAS;SACjI,CAAC;IACJ,CAAC;IAED,IAAI,UAAkB,CAAC;IACvB,IAAI,YAAoB,CAAC;IAEzB,IAAI,YAAY,KAAK,CAAC,CAAC,EAAE,CAAC;QACxB,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAC1C,YAAY,GAAG,WAAW,CAAC;IAC7B,CAAC;SAAM,CAAC;QACN,IAAI,aAAa,GAAG,CAAC,CAAC;QACtB,IAAI,cAAc,GAAG,eAAe,CAAC;QAErC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,EAAE,CAAC,EAAE,EAAE,CAAC;YACtC,MAAM,KAAK,GAAG,cAAc,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC;YACvD,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE,CAAC;gBACjB,MAAM;YACR,CAAC;YAED,cAAc;gBACZ,cAAc,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC;oBAClC,gBAAgB;oBAChB,cAAc,CAAC,SAAS,CAAC,KAAK,GAAG,gBAAgB,CAAC,MAAM,CAAC,CAAC;YAC5D,aAAa,EAAE,CAAC;QAClB,CAAC;QAED,UAAU,GAAG,cAAc,CAAC;QAC5B,YAAY,GAAG,aAAa,CAAC;IAC/B,CAAC;IAED,OAAO;QACL,OAAO,EAAE,IAAI;QACb,UAAU;QACV,QAAQ,EAAE;YACR,aAAa,EAAE,YAAY;SAC5B;KACF,CAAC;AAAA,CACH;AAED;;GAEG;AACH,2BACE,IAAqB,EACrB,eAAuB,EACL;IAClB,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;IACvC,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;IAEnC,IAAI,IAAI,CAAC,UAAU,IAAI,CAAC,EAAE,CAAC;QACzB,OAAO;YACL,OAAO,EAAE,KAAK;YACd,KAAK,EAAE,qCAAqC,IAAI,CAAC,UAAU,IAAI;YAC/D,IAAI,EAAE,GAAG,+BAAuB,6BAA6B;SAC9D,CAAC;IACJ,CAAC;IAED,IAAI,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;QACpC,OAAO;YACL,OAAO,EAAE,KAAK;YACd,KAAK,EAAE,kDAAkD,IAAI,CAAC,UAAU,SAAS,IAAI,CAAC,QAAQ,IAAI;YAClG,IAAI,EAAE,GAAG,+BAAuB,sCAAsC;SACvE,CAAC;IACJ,CAAC;IAED,MAAM,OAAO,GAAG,IAAA,mBAAa,EAAC,eAAe,CAAC,CAAC;IAC/C,MAAM,KAAK,GAAG,IAAA,2BAAqB,EAAC,eAAe,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAEjE,IAAI,UAAU,IAAI,KAAK,CAAC,MAAM,EAAE,CAAC;QAC/B,OAAO;YACL,OAAO,EAAE,KAAK;YACd,KAAK,EAAE,cAAc,IAAI,CAAC,UAAU,iCAAiC,KAAK,CAAC,MAAM,IAAI;YACrF,IAAI,EAAE,GAAG,+BAAuB,iBAAiB,KAAK,CAAC,MAAM,WAAW,4BAAoB,EAAE;SAC/F,CAAC;IACJ,CAAC;IAED,MAAM,eAAe,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAC7D,MAAM,YAAY,GAAG,KAAK,CAAC,KAAK,CAAC,UAAU,EAAE,eAAe,GAAG,CAAC,CAAC,CAAC;IAElE,IAAI,IAAI,CAAC,cAAc,IAAI,CAAC,WAAW,CAAC,YAAY,EAAE,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC;QAC3E,OAAO;YACL,OAAO,EAAE,KAAK;YACd,KAAK,EAAE,oDAAoD,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,2BAA2B,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;YAC/I,IAAI,EAAE,GAAG,+BAAuB,qDAAqD,kCAA0B,EAAE;SAClH,CAAC;IACJ,CAAC;IAED,MAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;IAC1C,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC;IAC/C,MAAM,YAAY,GAAG,CAAC,GAAG,MAAM,EAAE,GAAG,IAAI,CAAC,SAAS,EAAE,GAAG,KAAK,CAAC,CAAC;IAC9D,MAAM,aAAa,GAAG,YAAY,CAAC,MAAM,CAAC;IAC1C,MAAM,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,YAAY,CAAC,MAAM,CAAC;IAE/D,OAAO;QACL,OAAO,EAAE,IAAI;QACb,UAAU,EAAE,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC;QACtC,QAAQ,EAAE;YACR,aAAa,EAAE,CAAC;YAChB,cAAc,EAAE,aAAa;YAC7B,UAAU,EAAE,UAAU;SACvB;KACF,CAAC;AAAA,CACH;AAED,SAAS,WAAW,CAAC,CAAW,EAAE,CAAW,EAAW;IACtD,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM;QAAE,OAAO,KAAK,CAAC;IACxC,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE,CAAC,KAAK,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;AAAA,CACtD","sourcesContent":["/**\n * Shared implementation for file edit replace tools\n *\n * These helpers are used by both string-based and line-based replace tools,\n * providing the core logic while keeping the tool definitions simple for AI providers.\n */\n\nimport {\n  EDIT_FAILED_NOTE_PREFIX,\n  NOTE_READ_FILE_FIRST_RETRY,\n  NOTE_READ_FILE_RETRY,\n  NOTE_READ_FILE_AGAIN_RETRY,\n  type FileEditReplaceStringToolArgs,\n  type FileEditReplaceLinesToolArgs,\n} from \"@/common/types/tools\";\n\nimport { convertNewlines, detectFileEol, normalizeNewlinesToLF } from \"./eol\";\n\ninterface OperationMetadata {\n  edits_applied: number;\n  lines_replaced?: number;\n  line_delta?: number;\n}\n\nexport interface OperationResult {\n  success: true;\n  newContent: string;\n  metadata: OperationMetadata;\n}\n\nexport interface OperationError {\n  success: false;\n  error: string;\n  note?: string; // Agent-only message (not displayed in UI)\n}\n\nexport type OperationOutcome = OperationResult | OperationError;\n\n// Re-export schema-derived types for backward compatibility.\n// Local code previously imported StringReplaceArgs / LineReplaceArgs from this module.\nexport type StringReplaceArgs = FileEditReplaceStringToolArgs;\nexport type LineReplaceArgs = FileEditReplaceLinesToolArgs;\n\n/**\n * Handle string-based replacement\n */\nexport function handleStringReplace(\n  args: StringReplaceArgs,\n  originalContent: string\n): OperationOutcome {\n  const replaceCount = args.replace_count ?? 1;\n\n  const fileEol = detectFileEol(originalContent);\n  const oldStringExact = args.old_string;\n  const oldStringCoerced = convertNewlines(args.old_string, fileEol);\n  const newStringCoerced = convertNewlines(args.new_string, fileEol);\n\n  // Prefer an exact match, but retry with normalized newline styles so Windows\n  // CRLF files can be edited using model-generated LF strings.\n  let oldStringToMatch = oldStringExact;\n  if (\n    !originalContent.includes(oldStringToMatch) &&\n    oldStringCoerced !== oldStringExact &&\n    originalContent.includes(oldStringCoerced)\n  ) {\n    oldStringToMatch = oldStringCoerced;\n  }\n\n  if (!originalContent.includes(oldStringToMatch)) {\n    return {\n      success: false,\n      error: \"old_string not found in file. The text to replace must exist in the file.\",\n      note: `${EDIT_FAILED_NOTE_PREFIX} The old_string does not exist in the file. ${NOTE_READ_FILE_FIRST_RETRY}`,\n    };\n  }\n\n  const parts = originalContent.split(oldStringToMatch);\n  const occurrences = parts.length - 1;\n\n  if (replaceCount === 1 && occurrences > 1) {\n    return {\n      success: false,\n      error: `old_string appears ${occurrences} times in the file. Either expand the context to make it unique or set replace_count to ${occurrences} or -1.`,\n      note: `${EDIT_FAILED_NOTE_PREFIX} The old_string matched ${occurrences} locations. Add more surrounding context to make it unique, or set replace_count=${occurrences} to replace all occurrences.`,\n    };\n  }\n\n  if (replaceCount > occurrences && replaceCount !== -1) {\n    return {\n      success: false,\n      error: `replace_count is ${replaceCount} but old_string only appears ${occurrences} time(s) in the file.`,\n      note: `${EDIT_FAILED_NOTE_PREFIX} The replace_count=${replaceCount} is too high. Retry with replace_count=${occurrences} or -1.`,\n    };\n  }\n\n  let newContent: string;\n  let editsApplied: number;\n\n  if (replaceCount === -1) {\n    newContent = parts.join(newStringCoerced);\n    editsApplied = occurrences;\n  } else {\n    let replacedCount = 0;\n    let currentContent = originalContent;\n\n    for (let i = 0; i < replaceCount; i++) {\n      const index = currentContent.indexOf(oldStringToMatch);\n      if (index === -1) {\n        break;\n      }\n\n      currentContent =\n        currentContent.substring(0, index) +\n        newStringCoerced +\n        currentContent.substring(index + oldStringToMatch.length);\n      replacedCount++;\n    }\n\n    newContent = currentContent;\n    editsApplied = replacedCount;\n  }\n\n  return {\n    success: true,\n    newContent,\n    metadata: {\n      edits_applied: editsApplied,\n    },\n  };\n}\n\n/**\n * Handle line-range replacement\n */\nexport function handleLineReplace(\n  args: LineReplaceArgs,\n  originalContent: string\n): OperationOutcome {\n  const startIndex = args.start_line - 1;\n  const endIndex = args.end_line - 1;\n\n  if (args.start_line <= 0) {\n    return {\n      success: false,\n      error: `start_line must be >= 1 (received ${args.start_line}).`,\n      note: `${EDIT_FAILED_NOTE_PREFIX} Line numbers must be >= 1.`,\n    };\n  }\n\n  if (args.end_line < args.start_line) {\n    return {\n      success: false,\n      error: `end_line must be >= start_line (received start ${args.start_line}, end ${args.end_line}).`,\n      note: `${EDIT_FAILED_NOTE_PREFIX} The end_line must be >= start_line.`,\n    };\n  }\n\n  const fileEol = detectFileEol(originalContent);\n  const lines = normalizeNewlinesToLF(originalContent).split(\"\\n\");\n\n  if (startIndex >= lines.length) {\n    return {\n      success: false,\n      error: `start_line ${args.start_line} exceeds current file length (${lines.length}).`,\n      note: `${EDIT_FAILED_NOTE_PREFIX} The file has ${lines.length} lines. ${NOTE_READ_FILE_RETRY}`,\n    };\n  }\n\n  const clampedEndIndex = Math.min(endIndex, lines.length - 1);\n  const currentRange = lines.slice(startIndex, clampedEndIndex + 1);\n\n  if (args.expected_lines && !arraysEqual(currentRange, args.expected_lines)) {\n    return {\n      success: false,\n      error: `expected_lines validation failed. Current lines [${currentRange.join(\"\\n\")}] differ from expected [${args.expected_lines.join(\"\\n\")}].`,\n      note: `${EDIT_FAILED_NOTE_PREFIX} The file content changed since you last read it. ${NOTE_READ_FILE_AGAIN_RETRY}`,\n    };\n  }\n\n  const before = lines.slice(0, startIndex);\n  const after = lines.slice(clampedEndIndex + 1);\n  const updatedLines = [...before, ...args.new_lines, ...after];\n  const linesReplaced = currentRange.length;\n  const totalDelta = args.new_lines.length - currentRange.length;\n\n  return {\n    success: true,\n    newContent: updatedLines.join(fileEol),\n    metadata: {\n      edits_applied: 1,\n      lines_replaced: linesReplaced,\n      line_delta: totalDelta,\n    },\n  };\n}\n\nfunction arraysEqual(a: string[], b: string[]): boolean {\n  if (a.length !== b.length) return false;\n  return a.every((value, index) => value === b[index]);\n}\n"]}