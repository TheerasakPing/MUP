{"version":3,"file":"withHooks.js","sourceRoot":"","sources":["../../../../src/node/services/tools/withHooks.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Higher-order function that wraps a tool with hook support.\r\n *\r\n * Hook priority (new → legacy):\r\n * - Pre-execution: tool_pre → tool_hook (if no tool_pre)\r\n * - Post-execution: tool_post → tool_hook (only if tool_hook was used for pre)\r\n *\r\n * New model (tool_pre/tool_post):\r\n * - tool_pre: runs before tool, exit 0 = allow, non-zero = block\r\n * - tool_post: runs after tool with result in MUX_TOOL_RESULT/MUX_TOOL_RESULT_PATH\r\n *\r\n * Legacy model (tool_hook): single hook with marker protocol (echo $MUX_EXEC)\r\n */\r\n\r\nimport type { Tool } from \"ai\";\r\nimport { cloneToolPreservingDescriptors } from \"@/common/utils/tools/cloneToolPreservingDescriptors\";\r\nimport type { Runtime } from \"@/node/runtime/Runtime\";\r\nimport type { WithHookOutput, MayHaveHookOutput } from \"@/common/types/tools\";\r\nimport {\r\n  getHookPath,\r\n  getPreHookPath,\r\n  getPostHookPath,\r\n  runWithHook,\r\n  runPreHook,\r\n  runPostHook,\r\n} from \"@/node/services/hooks\";\r\nimport { log } from \"@/node/services/log\";\r\n\r\nexport interface HookConfig {\r\n  /** Runtime for hook execution (local or SSH) */\r\n  runtime: Runtime;\r\n  /** Runtime temp dir for hook scratch files (paths in the runtime's context) */\r\n  runtimeTempDir: string;\r\n  /** Working directory where hooks are discovered */\r\n  cwd: string;\r\n  /** Workspace ID for hook context */\r\n  workspaceId: string;\r\n  /** Additional environment variables to pass to hooks */\r\n  env?: Record<string, string>;\r\n}\r\n\r\nconst HOOK_OUTPUT_MAX_CHARS = 64 * 1024;\r\n\r\nfunction truncateHookOutput(output: string): string {\r\n  if (output.length <= HOOK_OUTPUT_MAX_CHARS) {\r\n    return output;\r\n  }\r\n  return output.slice(0, HOOK_OUTPUT_MAX_CHARS) + \"\\n\\n[hook_output truncated]\";\r\n}\r\n\r\n/**\r\n * Wrap a tool to execute within hook context if hooks exist.\r\n *\r\n * Hook priority:\r\n * - Pre: tool_pre (new) → tool_hook (legacy)\r\n * - Post: tool_post (new) → tool_hook (only if used for pre)\r\n */\r\nexport function withHooks<TParameters, TResult>(\r\n  toolName: string,\r\n  tool: Tool<TParameters, TResult>,\r\n  config: HookConfig\r\n): Tool<TParameters, TResult> {\r\n  // Access the tool as a record to get its properties.\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  const toolRecord = tool as any as Record<string, unknown>;\r\n  const originalExecute = toolRecord.execute;\r\n\r\n  if (typeof originalExecute !== \"function\") {\r\n    return tool;\r\n  }\r\n\r\n  const executeFn = originalExecute as (\r\n    this: unknown,\r\n    args: TParameters,\r\n    options: unknown\r\n  ) => unknown;\r\n\r\n  // Avoid mutating cached tools in place (e.g. MCP tools cached per workspace).\r\n  // Repeated getToolsForModel() calls should not stack wrappers.\r\n  const wrappedTool = cloneToolPreservingDescriptors(tool) as Tool<TParameters, TResult>;\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  const wrappedToolRecord = wrappedTool as any as Record<string, unknown>;\r\n\r\n  wrappedToolRecord.execute = async (args: TParameters, options: unknown) => {\r\n    // Find hooks (checked per call - hooks can be added/removed dynamically)\r\n    const [preHookPath, postHookPath, legacyHookPath] = await Promise.all([\r\n      getPreHookPath(config.runtime, config.cwd),\r\n      getPostHookPath(config.runtime, config.cwd),\r\n      getHookPath(config.runtime, config.cwd),\r\n    ]);\r\n\r\n    // No hooks at all - execute tool directly\r\n    if (!preHookPath && !postHookPath && !legacyHookPath) {\r\n      return executeFn.call(tool, args, options) as TResult;\r\n    }\r\n\r\n    // Extract abort signal from tool options (if present)\r\n    const abortSignal =\r\n      options && typeof options === \"object\" && \"abortSignal\" in options\r\n        ? (options as { abortSignal?: AbortSignal }).abortSignal\r\n        : undefined;\r\n\r\n    const toolInput = JSON.stringify(args);\r\n    const hookContext = {\r\n      tool: toolName,\r\n      toolInput,\r\n      toolInputValue: args,\r\n      workspaceId: config.workspaceId,\r\n      projectDir: config.cwd,\r\n      runtimeTempDir: config.runtimeTempDir,\r\n      env: config.env,\r\n      abortSignal,\r\n    };\r\n\r\n    // Use new model (tool_pre/tool_post) if tool_pre exists\r\n    if (preHookPath) {\r\n      return executeWithNewHooks(\r\n        config.runtime,\r\n        preHookPath,\r\n        postHookPath,\r\n        hookContext,\r\n        toolName,\r\n        () => executeFn.call(tool, args, options) as TResult\r\n      );\r\n    }\r\n\r\n    // Fall back to legacy model (tool_hook) if it exists\r\n    if (legacyHookPath) {\r\n      return executeWithLegacyHook(\r\n        config.runtime,\r\n        legacyHookPath,\r\n        hookContext,\r\n        toolName,\r\n        () => executeFn.call(tool, args, options) as TResult\r\n      );\r\n    }\r\n\r\n    // Only post hook exists (no pre) - execute tool then run post\r\n    const result = (await executeFn.call(tool, args, options)) as TResult;\r\n    if (postHookPath) {\r\n      const postStart = Date.now();\r\n      const postResult = await runPostHook(config.runtime, postHookPath, hookContext, result);\r\n      const hookDurationMs = Date.now() - postStart;\r\n      if (postResult.output) {\r\n        return appendHookOutput(\r\n          result,\r\n          truncateHookOutput(postResult.output),\r\n          hookDurationMs,\r\n          postHookPath\r\n        ) as TResult;\r\n      }\r\n    }\r\n    return result;\r\n  };\r\n\r\n  return wrappedTool;\r\n}\r\n\r\n/** Execute tool with new pre/post hook model */\r\nasync function executeWithNewHooks<TResult>(\r\n  runtime: Runtime,\r\n  preHookPath: string,\r\n  postHookPath: string | null,\r\n  context: {\r\n    tool: string;\r\n    toolInput: string;\r\n    workspaceId: string;\r\n    projectDir: string;\r\n    runtimeTempDir?: string;\r\n    env?: Record<string, string>;\r\n    abortSignal?: AbortSignal;\r\n  },\r\n  toolName: string,\r\n  executeTool: () => TResult | Promise<TResult>\r\n): Promise<TResult> {\r\n  log.debug(\"[withHooks] Running tool with pre/post hooks\", {\r\n    toolName,\r\n    preHookPath,\r\n    postHookPath,\r\n  });\r\n\r\n  const hookStart = Date.now();\r\n\r\n  // Run pre-hook\r\n  const preResult = await runPreHook(runtime, preHookPath, context);\r\n\r\n  // Pre-hook blocked tool\r\n  if (!preResult.allowed) {\r\n    const output = truncateHookOutput(\r\n      preResult.output || `Tool blocked by pre-hook (exit ${preResult.exitCode})`\r\n    );\r\n    log.debug(\"[withHooks] Pre-hook blocked tool\", { toolName, output });\r\n    const errorResult: { error: string } = { error: output };\r\n    return errorResult as TResult;\r\n  }\r\n\r\n  // Execute tool\r\n  const result = await executeTool();\r\n\r\n  // Run post-hook if exists\r\n  if (postHookPath) {\r\n    const postResult = await runPostHook(runtime, postHookPath, context, result);\r\n    const hookDurationMs = Date.now() - hookStart;\r\n    let hookOutput = postResult.output;\r\n\r\n    if (!postResult.success && !hookOutput) {\r\n      hookOutput = `Post-hook failed (exit code ${postResult.exitCode})`;\r\n    }\r\n\r\n    if (hookOutput) {\r\n      hookOutput = truncateHookOutput(hookOutput);\r\n      log.debug(\"[withHooks] Post-hook produced output\", {\r\n        toolName,\r\n        success: postResult.success,\r\n        output: hookOutput,\r\n      });\r\n      return appendHookOutput(result, hookOutput, hookDurationMs, postHookPath) as TResult;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/** Execute tool with legacy tool_hook model */\r\nasync function executeWithLegacyHook<TResult>(\r\n  runtime: Runtime,\r\n  hookPath: string,\r\n  context: {\r\n    tool: string;\r\n    toolInput: string;\r\n    workspaceId: string;\r\n    projectDir: string;\r\n    runtimeTempDir?: string;\r\n    env?: Record<string, string>;\r\n    abortSignal?: AbortSignal;\r\n  },\r\n  toolName: string,\r\n  executeTool: () => TResult | Promise<TResult>\r\n): Promise<TResult> {\r\n  log.debug(\"[withHooks] Running tool with legacy hook\", { toolName, hookPath });\r\n\r\n  const hookStart = Date.now();\r\n  const { result, hook } = await runWithHook<TResult>(\r\n    runtime,\r\n    hookPath,\r\n    context,\r\n    () => Promise.resolve(executeTool()),\r\n    {\r\n      slowThresholdMs: 10000,\r\n      onSlowHook: (phase, elapsedMs) => {\r\n        const seconds = (elapsedMs / 1000).toFixed(1);\r\n        log.warn(`[withHooks] Slow ${phase}-hook for ${toolName}: ${seconds}s`);\r\n        console.warn(`⚠️  Slow tool hook (${phase}): ${toolName} took ${seconds}s`);\r\n      },\r\n    }\r\n  );\r\n  const hookDurationMs = Date.now() - hookStart;\r\n\r\n  // Hook blocked tool execution (exited before $MUX_EXEC)\r\n  if (!hook.toolExecuted) {\r\n    const blockOutput = truncateHookOutput(\r\n      [hook.stdoutBeforeExec, hook.stderr].filter(Boolean).join(\"\\n\").trim()\r\n    );\r\n    log.debug(\"[withHooks] Hook blocked tool execution\", { toolName, output: blockOutput });\r\n    const errorResult: { error: string } = {\r\n      error: blockOutput || \"Tool blocked by hook (exited before $MUX_EXEC)\",\r\n    };\r\n    return errorResult as TResult;\r\n  }\r\n\r\n  // Combine stdout and stderr for hook output\r\n  let hookOutput = [hook.stdout, hook.stderr].filter(Boolean).join(\"\\n\").trim();\r\n\r\n  if (!hook.success && !hookOutput) {\r\n    hookOutput = `Tool hook failed (exit code ${hook.exitCode})`;\r\n  }\r\n\r\n  if (hookOutput) {\r\n    hookOutput = truncateHookOutput(hookOutput);\r\n    log.debug(\"[withHooks] Hook produced output\", {\r\n      toolName,\r\n      success: hook.success,\r\n      output: hookOutput,\r\n    });\r\n    return appendHookOutput(result, hookOutput, hookDurationMs, hookPath) as TResult;\r\n  }\r\n\r\n  // Note: result could be TResult or AsyncIterable<TResult>\r\n  return result as TResult;\r\n}\r\n\r\n/** Check if a value is an AsyncIterable (streaming result) */\r\nfunction isAsyncIterable<T>(value: unknown): value is AsyncIterable<T> {\r\n  return (\r\n    typeof value === \"object\" &&\r\n    value !== null &&\r\n    Symbol.asyncIterator in value &&\r\n    typeof (value as Record<symbol, unknown>)[Symbol.asyncIterator] === \"function\"\r\n  );\r\n}\r\n\r\n/**\r\n * Append hook output to tool result.\r\n * This lets the LLM see hook feedback (errors, formatter notifications) alongside the tool result.\r\n *\r\n * Note: AsyncIterable (streaming) results are wrapped to preserve the iterator while attaching hook_output.\r\n */\r\nfunction appendHookOutput<T>(\r\n  result: T | AsyncIterable<T> | undefined,\r\n  output: string,\r\n  durationMs?: number,\r\n  hookPath?: string\r\n): MayHaveHookOutput<T> | AsyncIterable<T> {\r\n  if (result === undefined) {\r\n    const errorResult: WithHookOutput & { error: string } = {\r\n      error: output,\r\n      hook_output: output,\r\n      hook_duration_ms: durationMs,\r\n      hook_path: hookPath,\r\n    };\r\n    return errorResult as unknown as MayHaveHookOutput<T>;\r\n  }\r\n\r\n  // AsyncIterable (streaming) results: preserve streaming while attaching hook_output.\r\n  if (isAsyncIterable<T>(result)) {\r\n    const iterable = result;\r\n    const iteratorFn = iterable[Symbol.asyncIterator].bind(iterable);\r\n    const wrappedIterable: AsyncIterable<T> & WithHookOutput = {\r\n      hook_output: output,\r\n      hook_duration_ms: durationMs,\r\n      hook_path: hookPath,\r\n      [Symbol.asyncIterator]: iteratorFn,\r\n    };\r\n    return wrappedIterable;\r\n  }\r\n\r\n  // If result is an object, add hook_output field\r\n  if (typeof result === \"object\" && result !== null) {\r\n    const withOutput: MayHaveHookOutput<T> = {\r\n      ...(result as T),\r\n      hook_output: output,\r\n      hook_duration_ms: durationMs,\r\n      hook_path: hookPath,\r\n    };\r\n    return withOutput;\r\n  }\r\n\r\n  // For primitive results, wrap in object\r\n  const wrapped: { result: T } & WithHookOutput = {\r\n    result,\r\n    hook_output: output,\r\n    hook_duration_ms: durationMs,\r\n    hook_path: hookPath,\r\n  };\r\n  return wrapped as unknown as MayHaveHookOutput<T>;\r\n}\r\n"]}