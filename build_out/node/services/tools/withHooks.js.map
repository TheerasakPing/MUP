{"version":3,"file":"withHooks.js","sourceRoot":"","sources":["../../../../src/node/services/tools/withHooks.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Higher-order function that wraps a tool with hook support.\n *\n * Hook priority (new → legacy):\n * - Pre-execution: tool_pre → tool_hook (if no tool_pre)\n * - Post-execution: tool_post → tool_hook (only if tool_hook was used for pre)\n *\n * New model (tool_pre/tool_post):\n * - tool_pre: runs before tool, exit 0 = allow, non-zero = block\n * - tool_post: runs after tool with result in MUX_TOOL_RESULT/MUX_TOOL_RESULT_PATH\n *\n * Legacy model (tool_hook): single hook with marker protocol (echo $MUX_EXEC)\n */\n\nimport type { Tool } from \"ai\";\nimport { cloneToolPreservingDescriptors } from \"@/common/utils/tools/cloneToolPreservingDescriptors\";\nimport type { Runtime } from \"@/node/runtime/Runtime\";\nimport type { WithHookOutput, MayHaveHookOutput } from \"@/common/types/tools\";\nimport {\n  getHookPath,\n  getPreHookPath,\n  getPostHookPath,\n  runWithHook,\n  runPreHook,\n  runPostHook,\n} from \"@/node/services/hooks\";\nimport { log } from \"@/node/services/log\";\n\nexport interface HookConfig {\n  /** Runtime for hook execution (local or SSH) */\n  runtime: Runtime;\n  /** Runtime temp dir for hook scratch files (paths in the runtime's context) */\n  runtimeTempDir: string;\n  /** Working directory where hooks are discovered */\n  cwd: string;\n  /** Workspace ID for hook context */\n  workspaceId: string;\n  /** Additional environment variables to pass to hooks */\n  env?: Record<string, string>;\n}\n\nconst HOOK_OUTPUT_MAX_CHARS = 64 * 1024;\n\nfunction truncateHookOutput(output: string): string {\n  if (output.length <= HOOK_OUTPUT_MAX_CHARS) {\n    return output;\n  }\n  return output.slice(0, HOOK_OUTPUT_MAX_CHARS) + \"\\n\\n[hook_output truncated]\";\n}\n\n/**\n * Wrap a tool to execute within hook context if hooks exist.\n *\n * Hook priority:\n * - Pre: tool_pre (new) → tool_hook (legacy)\n * - Post: tool_post (new) → tool_hook (only if used for pre)\n */\nexport function withHooks<TParameters, TResult>(\n  toolName: string,\n  tool: Tool<TParameters, TResult>,\n  config: HookConfig\n): Tool<TParameters, TResult> {\n  // Access the tool as a record to get its properties.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const toolRecord = tool as any as Record<string, unknown>;\n  const originalExecute = toolRecord.execute;\n\n  if (typeof originalExecute !== \"function\") {\n    return tool;\n  }\n\n  const executeFn = originalExecute as (\n    this: unknown,\n    args: TParameters,\n    options: unknown\n  ) => unknown;\n\n  // Avoid mutating cached tools in place (e.g. MCP tools cached per workspace).\n  // Repeated getToolsForModel() calls should not stack wrappers.\n  const wrappedTool = cloneToolPreservingDescriptors(tool) as Tool<TParameters, TResult>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const wrappedToolRecord = wrappedTool as any as Record<string, unknown>;\n\n  wrappedToolRecord.execute = async (args: TParameters, options: unknown) => {\n    // Find hooks (checked per call - hooks can be added/removed dynamically)\n    const [preHookPath, postHookPath, legacyHookPath] = await Promise.all([\n      getPreHookPath(config.runtime, config.cwd),\n      getPostHookPath(config.runtime, config.cwd),\n      getHookPath(config.runtime, config.cwd),\n    ]);\n\n    // No hooks at all - execute tool directly\n    if (!preHookPath && !postHookPath && !legacyHookPath) {\n      return executeFn.call(tool, args, options) as TResult;\n    }\n\n    // Extract abort signal from tool options (if present)\n    const abortSignal =\n      options && typeof options === \"object\" && \"abortSignal\" in options\n        ? (options as { abortSignal?: AbortSignal }).abortSignal\n        : undefined;\n\n    const toolInput = JSON.stringify(args);\n    const hookContext = {\n      tool: toolName,\n      toolInput,\n      toolInputValue: args,\n      workspaceId: config.workspaceId,\n      projectDir: config.cwd,\n      runtimeTempDir: config.runtimeTempDir,\n      env: config.env,\n      abortSignal,\n    };\n\n    // Use new model (tool_pre/tool_post) if tool_pre exists\n    if (preHookPath) {\n      return executeWithNewHooks(\n        config.runtime,\n        preHookPath,\n        postHookPath,\n        hookContext,\n        toolName,\n        () => executeFn.call(tool, args, options) as TResult\n      );\n    }\n\n    // Fall back to legacy model (tool_hook) if it exists\n    if (legacyHookPath) {\n      return executeWithLegacyHook(\n        config.runtime,\n        legacyHookPath,\n        hookContext,\n        toolName,\n        () => executeFn.call(tool, args, options) as TResult\n      );\n    }\n\n    // Only post hook exists (no pre) - execute tool then run post\n    const result = (await executeFn.call(tool, args, options)) as TResult;\n    if (postHookPath) {\n      const postStart = Date.now();\n      const postResult = await runPostHook(config.runtime, postHookPath, hookContext, result);\n      const hookDurationMs = Date.now() - postStart;\n      if (postResult.output) {\n        return appendHookOutput(\n          result,\n          truncateHookOutput(postResult.output),\n          hookDurationMs,\n          postHookPath\n        ) as TResult;\n      }\n    }\n    return result;\n  };\n\n  return wrappedTool;\n}\n\n/** Execute tool with new pre/post hook model */\nasync function executeWithNewHooks<TResult>(\n  runtime: Runtime,\n  preHookPath: string,\n  postHookPath: string | null,\n  context: {\n    tool: string;\n    toolInput: string;\n    workspaceId: string;\n    projectDir: string;\n    runtimeTempDir?: string;\n    env?: Record<string, string>;\n    abortSignal?: AbortSignal;\n  },\n  toolName: string,\n  executeTool: () => TResult | Promise<TResult>\n): Promise<TResult> {\n  log.debug(\"[withHooks] Running tool with pre/post hooks\", {\n    toolName,\n    preHookPath,\n    postHookPath,\n  });\n\n  const hookStart = Date.now();\n\n  // Run pre-hook\n  const preResult = await runPreHook(runtime, preHookPath, context);\n\n  // Pre-hook blocked tool\n  if (!preResult.allowed) {\n    const output = truncateHookOutput(\n      preResult.output || `Tool blocked by pre-hook (exit ${preResult.exitCode})`\n    );\n    log.debug(\"[withHooks] Pre-hook blocked tool\", { toolName, output });\n    const errorResult: { error: string } = { error: output };\n    return errorResult as TResult;\n  }\n\n  // Execute tool\n  const result = await executeTool();\n\n  // Run post-hook if exists\n  if (postHookPath) {\n    const postResult = await runPostHook(runtime, postHookPath, context, result);\n    const hookDurationMs = Date.now() - hookStart;\n    let hookOutput = postResult.output;\n\n    if (!postResult.success && !hookOutput) {\n      hookOutput = `Post-hook failed (exit code ${postResult.exitCode})`;\n    }\n\n    if (hookOutput) {\n      hookOutput = truncateHookOutput(hookOutput);\n      log.debug(\"[withHooks] Post-hook produced output\", {\n        toolName,\n        success: postResult.success,\n        output: hookOutput,\n      });\n      return appendHookOutput(result, hookOutput, hookDurationMs, postHookPath) as TResult;\n    }\n  }\n\n  return result;\n}\n\n/** Execute tool with legacy tool_hook model */\nasync function executeWithLegacyHook<TResult>(\n  runtime: Runtime,\n  hookPath: string,\n  context: {\n    tool: string;\n    toolInput: string;\n    workspaceId: string;\n    projectDir: string;\n    runtimeTempDir?: string;\n    env?: Record<string, string>;\n    abortSignal?: AbortSignal;\n  },\n  toolName: string,\n  executeTool: () => TResult | Promise<TResult>\n): Promise<TResult> {\n  log.debug(\"[withHooks] Running tool with legacy hook\", { toolName, hookPath });\n\n  const hookStart = Date.now();\n  const { result, hook } = await runWithHook<TResult>(\n    runtime,\n    hookPath,\n    context,\n    () => Promise.resolve(executeTool()),\n    {\n      slowThresholdMs: 10000,\n      onSlowHook: (phase, elapsedMs) => {\n        const seconds = (elapsedMs / 1000).toFixed(1);\n        log.warn(`[withHooks] Slow ${phase}-hook for ${toolName}: ${seconds}s`);\n        console.warn(`⚠️  Slow tool hook (${phase}): ${toolName} took ${seconds}s`);\n      },\n    }\n  );\n  const hookDurationMs = Date.now() - hookStart;\n\n  // Hook blocked tool execution (exited before $MUX_EXEC)\n  if (!hook.toolExecuted) {\n    const blockOutput = truncateHookOutput(\n      [hook.stdoutBeforeExec, hook.stderr].filter(Boolean).join(\"\\n\").trim()\n    );\n    log.debug(\"[withHooks] Hook blocked tool execution\", { toolName, output: blockOutput });\n    const errorResult: { error: string } = {\n      error: blockOutput || \"Tool blocked by hook (exited before $MUX_EXEC)\",\n    };\n    return errorResult as TResult;\n  }\n\n  // Combine stdout and stderr for hook output\n  let hookOutput = [hook.stdout, hook.stderr].filter(Boolean).join(\"\\n\").trim();\n\n  if (!hook.success && !hookOutput) {\n    hookOutput = `Tool hook failed (exit code ${hook.exitCode})`;\n  }\n\n  if (hookOutput) {\n    hookOutput = truncateHookOutput(hookOutput);\n    log.debug(\"[withHooks] Hook produced output\", {\n      toolName,\n      success: hook.success,\n      output: hookOutput,\n    });\n    return appendHookOutput(result, hookOutput, hookDurationMs, hookPath) as TResult;\n  }\n\n  // Note: result could be TResult or AsyncIterable<TResult>\n  return result as TResult;\n}\n\n/** Check if a value is an AsyncIterable (streaming result) */\nfunction isAsyncIterable<T>(value: unknown): value is AsyncIterable<T> {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    Symbol.asyncIterator in value &&\n    typeof (value as Record<symbol, unknown>)[Symbol.asyncIterator] === \"function\"\n  );\n}\n\n/**\n * Append hook output to tool result.\n * This lets the LLM see hook feedback (errors, formatter notifications) alongside the tool result.\n *\n * Note: AsyncIterable (streaming) results are wrapped to preserve the iterator while attaching hook_output.\n */\nfunction appendHookOutput<T>(\n  result: T | AsyncIterable<T> | undefined,\n  output: string,\n  durationMs?: number,\n  hookPath?: string\n): MayHaveHookOutput<T> | AsyncIterable<T> {\n  if (result === undefined) {\n    const errorResult: WithHookOutput & { error: string } = {\n      error: output,\n      hook_output: output,\n      hook_duration_ms: durationMs,\n      hook_path: hookPath,\n    };\n    return errorResult as unknown as MayHaveHookOutput<T>;\n  }\n\n  // AsyncIterable (streaming) results: preserve streaming while attaching hook_output.\n  if (isAsyncIterable<T>(result)) {\n    const iterable = result;\n    const iteratorFn = iterable[Symbol.asyncIterator].bind(iterable);\n    const wrappedIterable: AsyncIterable<T> & WithHookOutput = {\n      hook_output: output,\n      hook_duration_ms: durationMs,\n      hook_path: hookPath,\n      [Symbol.asyncIterator]: iteratorFn,\n    };\n    return wrappedIterable;\n  }\n\n  // If result is an object, add hook_output field\n  if (typeof result === \"object\" && result !== null) {\n    const withOutput: MayHaveHookOutput<T> = {\n      ...(result as T),\n      hook_output: output,\n      hook_duration_ms: durationMs,\n      hook_path: hookPath,\n    };\n    return withOutput;\n  }\n\n  // For primitive results, wrap in object\n  const wrapped: { result: T } & WithHookOutput = {\n    result,\n    hook_output: output,\n    hook_duration_ms: durationMs,\n    hook_path: hookPath,\n  };\n  return wrapped as unknown as MayHaveHookOutput<T>;\n}\n"]}