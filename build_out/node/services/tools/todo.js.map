{"version":3,"file":"todo.js","sourceRoot":"","sources":["../../../../src/node/services/tools/todo.ts"],"names":[],"mappings":"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","sourcesContent":["import { tool } from \"ai\";\r\nimport * as fs from \"fs/promises\";\r\nimport * as path from \"path\";\r\nimport writeFileAtomic from \"write-file-atomic\";\r\nimport assert from \"@/common/utils/assert\";\r\nimport type { ToolFactory } from \"@/common/utils/tools/tools\";\r\nimport { TOOL_DEFINITIONS } from \"@/common/utils/tools/toolDefinitions\";\r\nimport type { TodoItem } from \"@/common/types/tools\";\r\nimport { MAX_TODOS } from \"@/common/constants/toolLimits\";\r\nimport { getTodoFilePath, readTodosForSessionDir } from \"@/node/services/todos/todoStorage\";\r\nimport { workspaceFileLocks } from \"@/node/utils/concurrency/workspaceFileLocks\";\r\n\r\n/**\r\n * Validate todo sequencing rules before persisting.\r\n * Enforces order: completed → in_progress → pending (top to bottom)\r\n * Enforces maximum count to encourage summarization.\r\n */\r\nfunction validateTodos(todos: TodoItem[]): void {\r\n  if (!Array.isArray(todos)) {\r\n    throw new Error(\"Invalid todos payload: expected an array\");\r\n  }\r\n\r\n  if (todos.length === 0) {\r\n    return;\r\n  }\r\n\r\n  // Enforce maximum TODO count\r\n  if (todos.length > MAX_TODOS) {\r\n    throw new Error(\r\n      `Too many TODOs (${todos.length}/${MAX_TODOS}). ` +\r\n        `Keep high precision at the center: ` +\r\n        `summarize old completed work (e.g., 'Setup phase (3 tasks)'), ` +\r\n        `keep recent completions detailed (1-2), ` +\r\n        `one in_progress, ` +\r\n        `immediate pending detailed (2-3), ` +\r\n        `and summarize far future work (e.g., 'Testing phase (4 items)').`\r\n    );\r\n  }\r\n\r\n  let phase: \"completed\" | \"in_progress\" | \"pending\" = \"completed\";\r\n  let inProgressCount = 0;\r\n\r\n  todos.forEach((todo, index) => {\r\n    const status = todo.status;\r\n\r\n    switch (status) {\r\n      case \"completed\": {\r\n        if (phase !== \"completed\") {\r\n          throw new Error(\r\n            `Invalid todo order at index ${index}: completed tasks must appear before in-progress or pending tasks`\r\n          );\r\n        }\r\n        // Stay in completed phase\r\n        break;\r\n      }\r\n      case \"in_progress\": {\r\n        if (phase === \"pending\") {\r\n          throw new Error(\r\n            `Invalid todo order at index ${index}: in-progress tasks must appear before pending tasks`\r\n          );\r\n        }\r\n        inProgressCount += 1;\r\n        if (inProgressCount > 1) {\r\n          throw new Error(\r\n            \"Invalid todo list: only one task can be marked as in_progress at a time\"\r\n          );\r\n        }\r\n        // Transition to in_progress phase (from completed or stay in in_progress)\r\n        phase = \"in_progress\";\r\n        break;\r\n      }\r\n      case \"pending\": {\r\n        // Transition to pending phase (from completed, in_progress, or stay in pending)\r\n        phase = \"pending\";\r\n        break;\r\n      }\r\n      default: {\r\n        throw new Error(`Invalid todo status at index ${index}: ${String(status)}`);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Write todos to the workspace session directory.\r\n */\r\nasync function writeTodos(\r\n  workspaceId: string,\r\n  workspaceSessionDir: string,\r\n  todos: TodoItem[]\r\n): Promise<void> {\r\n  validateTodos(todos);\r\n\r\n  await workspaceFileLocks.withLock(workspaceId, async () => {\r\n    const todoFile = getTodoFilePath(workspaceSessionDir);\r\n    await fs.mkdir(path.dirname(todoFile), { recursive: true });\r\n    await writeFileAtomic(todoFile, JSON.stringify(todos, null, 2));\r\n  });\r\n}\r\n\r\nasync function clearTodos(workspaceId: string, workspaceSessionDir: string): Promise<void> {\r\n  await workspaceFileLocks.withLock(workspaceId, async () => {\r\n    const todoFile = getTodoFilePath(workspaceSessionDir);\r\n    try {\r\n      await fs.unlink(todoFile);\r\n    } catch (error) {\r\n      if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\r\n        return;\r\n      }\r\n      throw error;\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Todo write tool factory\r\n * Creates a tool that allows the AI to create/update the todo list\r\n */\r\nexport const createTodoWriteTool: ToolFactory = (config) => {\r\n  return tool({\r\n    description: TOOL_DEFINITIONS.todo_write.description,\r\n    inputSchema: TOOL_DEFINITIONS.todo_write.schema,\r\n    execute: async ({ todos }) => {\r\n      assert(config.workspaceId, \"todo_write requires workspaceId\");\r\n      assert(config.workspaceSessionDir, \"todo_write requires workspaceSessionDir\");\r\n      await writeTodos(config.workspaceId, config.workspaceSessionDir, todos);\r\n      return {\r\n        success: true as const,\r\n        count: todos.length,\r\n      };\r\n    },\r\n  });\r\n};\r\n\r\n/**\r\n * Todo read tool factory\r\n * Creates a tool that allows the AI to read the current todo list\r\n */\r\nexport const createTodoReadTool: ToolFactory = (config) => {\r\n  return tool({\r\n    description: TOOL_DEFINITIONS.todo_read.description,\r\n    inputSchema: TOOL_DEFINITIONS.todo_read.schema,\r\n    execute: async () => {\r\n      assert(config.workspaceSessionDir, \"todo_read requires workspaceSessionDir\");\r\n      const todos = await readTodosForSessionDir(config.workspaceSessionDir);\r\n      return {\r\n        todos,\r\n      };\r\n    },\r\n  });\r\n};\r\n\r\n/**\r\n * Set todos for a workspace session directory (useful for testing)\r\n */\r\nexport async function setTodosForSessionDir(\r\n  workspaceId: string,\r\n  workspaceSessionDir: string,\r\n  todos: TodoItem[]\r\n): Promise<void> {\r\n  await writeTodos(workspaceId, workspaceSessionDir, todos);\r\n}\r\n\r\n/**\r\n * Get todos for a workspace session directory (useful for testing)\r\n */\r\nexport async function getTodosForSessionDir(workspaceSessionDir: string): Promise<TodoItem[]> {\r\n  return readTodosForSessionDir(workspaceSessionDir);\r\n}\r\n\r\n/**\r\n * Clear todos for a workspace session directory (useful for testing and cleanup)\r\n */\r\nexport async function clearTodosForSessionDir(\r\n  workspaceId: string,\r\n  workspaceSessionDir: string\r\n): Promise<void> {\r\n  await clearTodos(workspaceId, workspaceSessionDir);\r\n}\r\n"]}