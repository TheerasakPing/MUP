{"version":3,"file":"todo.js","sourceRoot":"","sources":["../../../../src/node/services/tools/todo.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,2BAA0B;AAC1B,MAAY,EAAE,wCAAoB;AAClC,MAAY,IAAI,iCAAa;AAC7B,0EAAgD;AAChD,mEAA2C;AAE3C,0EAAwE;AAExE,8DAA0D;AAC1D,mEAA4F;AAC5F,oFAAiF;AAEjF;;;;GAIG;AACH,SAAS,aAAa,CAAC,KAAiB,EAAQ;IAC9C,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;QAC1B,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;IAC9D,CAAC;IAED,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACvB,OAAO;IACT,CAAC;IAED,6BAA6B;IAC7B,IAAI,KAAK,CAAC,MAAM,GAAG,sBAAS,EAAE,CAAC;QAC7B,MAAM,IAAI,KAAK,CACb,mBAAmB,KAAK,CAAC,MAAM,IAAI,sBAAS,KAAK;YAC/C,qCAAqC;YACrC,gEAAgE;YAChE,0CAA0C;YAC1C,mBAAmB;YACnB,oCAAoC;YACpC,kEAAkE,CACrE,CAAC;IACJ,CAAC;IAED,IAAI,KAAK,GAA4C,WAAW,CAAC;IACjE,IAAI,eAAe,GAAG,CAAC,CAAC;IAExB,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;QAC7B,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAE3B,QAAQ,MAAM,EAAE,CAAC;YACf,KAAK,WAAW,EAAE,CAAC;gBACjB,IAAI,KAAK,KAAK,WAAW,EAAE,CAAC;oBAC1B,MAAM,IAAI,KAAK,CACb,+BAA+B,KAAK,mEAAmE,CACxG,CAAC;gBACJ,CAAC;gBACD,0BAA0B;gBAC1B,MAAM;YACR,CAAC;YACD,KAAK,aAAa,EAAE,CAAC;gBACnB,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;oBACxB,MAAM,IAAI,KAAK,CACb,+BAA+B,KAAK,sDAAsD,CAC3F,CAAC;gBACJ,CAAC;gBACD,eAAe,IAAI,CAAC,CAAC;gBACrB,IAAI,eAAe,GAAG,CAAC,EAAE,CAAC;oBACxB,MAAM,IAAI,KAAK,CACb,yEAAyE,CAC1E,CAAC;gBACJ,CAAC;gBACD,0EAA0E;gBAC1E,KAAK,GAAG,aAAa,CAAC;gBACtB,MAAM;YACR,CAAC;YACD,KAAK,SAAS,EAAE,CAAC;gBACf,gFAAgF;gBAChF,KAAK,GAAG,SAAS,CAAC;gBAClB,MAAM;YACR,CAAC;YACD,SAAS,CAAC;gBACR,MAAM,IAAI,KAAK,CAAC,gCAAgC,KAAK,KAAK,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YAC9E,CAAC;QACH,CAAC;IAAA,CACF,CAAC,CAAC;AAAA,CACJ;AAED;;GAEG;AACH,KAAK,UAAU,UAAU,CACvB,WAAmB,EACnB,mBAA2B,EAC3B,KAAiB,EACF;IACf,aAAa,CAAC,KAAK,CAAC,CAAC;IAErB,MAAM,uCAAkB,CAAC,QAAQ,CAAC,WAAW,EAAE,KAAK,IAAI,EAAE,CAAC;QACzD,MAAM,QAAQ,GAAG,IAAA,6BAAe,EAAC,mBAAmB,CAAC,CAAC;QACtD,MAAM,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;QAC5D,MAAM,IAAA,2BAAe,EAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;IAAA,CACjE,CAAC,CAAC;AAAA,CACJ;AAED,KAAK,UAAU,UAAU,CAAC,WAAmB,EAAE,mBAA2B,EAAiB;IACzF,MAAM,uCAAkB,CAAC,QAAQ,CAAC,WAAW,EAAE,KAAK,IAAI,EAAE,CAAC;QACzD,MAAM,QAAQ,GAAG,IAAA,6BAAe,EAAC,mBAAmB,CAAC,CAAC;QACtD,IAAI,CAAC;YACH,MAAM,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAC5B,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;gBACrF,OAAO;YACT,CAAC;YACD,MAAM,KAAK,CAAC;QACd,CAAC;IAAA,CACF,CAAC,CAAC;AAAA,CACJ;AAED;;;GAGG;AACI,MAAM,mBAAmB,GAAgB,CAAC,MAAM,EAAE,EAAE,CAAC;IAC1D,OAAO,IAAA,SAAI,EAAC;QACV,WAAW,EAAE,kCAAgB,CAAC,UAAU,CAAC,WAAW;QACpD,WAAW,EAAE,kCAAgB,CAAC,UAAU,CAAC,MAAM;QAC/C,OAAO,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC;YAC5B,IAAA,gBAAM,EAAC,MAAM,CAAC,WAAW,EAAE,iCAAiC,CAAC,CAAC;YAC9D,IAAA,gBAAM,EAAC,MAAM,CAAC,mBAAmB,EAAE,yCAAyC,CAAC,CAAC;YAC9E,MAAM,UAAU,CAAC,MAAM,CAAC,WAAW,EAAE,MAAM,CAAC,mBAAmB,EAAE,KAAK,CAAC,CAAC;YACxE,OAAO;gBACL,OAAO,EAAE,IAAa;gBACtB,KAAK,EAAE,KAAK,CAAC,MAAM;aACpB,CAAC;QAAA,CACH;KACF,CAAC,CAAC;AAAA,CACJ,CAAC;AAdW,QAAA,mBAAmB,GAAnB,mBAAmB,CAc9B;AAEF;;;GAGG;AACI,MAAM,kBAAkB,GAAgB,CAAC,MAAM,EAAE,EAAE,CAAC;IACzD,OAAO,IAAA,SAAI,EAAC;QACV,WAAW,EAAE,kCAAgB,CAAC,SAAS,CAAC,WAAW;QACnD,WAAW,EAAE,kCAAgB,CAAC,SAAS,CAAC,MAAM;QAC9C,OAAO,EAAE,KAAK,IAAI,EAAE,CAAC;YACnB,IAAA,gBAAM,EAAC,MAAM,CAAC,mBAAmB,EAAE,wCAAwC,CAAC,CAAC;YAC7E,MAAM,KAAK,GAAG,MAAM,IAAA,oCAAsB,EAAC,MAAM,CAAC,mBAAmB,CAAC,CAAC;YACvE,OAAO;gBACL,KAAK;aACN,CAAC;QAAA,CACH;KACF,CAAC,CAAC;AAAA,CACJ,CAAC;AAZW,QAAA,kBAAkB,GAAlB,kBAAkB,CAY7B;AAEF;;GAEG;AACI,KAAK,gCACV,WAAmB,EACnB,mBAA2B,EAC3B,KAAiB,EACF;IACf,MAAM,UAAU,CAAC,WAAW,EAAE,mBAAmB,EAAE,KAAK,CAAC,CAAC;AAAA,CAC3D;AAED;;GAEG;AACI,KAAK,gCAAgC,mBAA2B,EAAuB;IAC5F,OAAO,IAAA,oCAAsB,EAAC,mBAAmB,CAAC,CAAC;AAAA,CACpD;AAED;;GAEG;AACI,KAAK,kCACV,WAAmB,EACnB,mBAA2B,EACZ;IACf,MAAM,UAAU,CAAC,WAAW,EAAE,mBAAmB,CAAC,CAAC;AAAA,CACpD","sourcesContent":["import { tool } from \"ai\";\nimport * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport writeFileAtomic from \"write-file-atomic\";\nimport assert from \"@/common/utils/assert\";\nimport type { ToolFactory } from \"@/common/utils/tools/tools\";\nimport { TOOL_DEFINITIONS } from \"@/common/utils/tools/toolDefinitions\";\nimport type { TodoItem } from \"@/common/types/tools\";\nimport { MAX_TODOS } from \"@/common/constants/toolLimits\";\nimport { getTodoFilePath, readTodosForSessionDir } from \"@/node/services/todos/todoStorage\";\nimport { workspaceFileLocks } from \"@/node/utils/concurrency/workspaceFileLocks\";\n\n/**\n * Validate todo sequencing rules before persisting.\n * Enforces order: completed → in_progress → pending (top to bottom)\n * Enforces maximum count to encourage summarization.\n */\nfunction validateTodos(todos: TodoItem[]): void {\n  if (!Array.isArray(todos)) {\n    throw new Error(\"Invalid todos payload: expected an array\");\n  }\n\n  if (todos.length === 0) {\n    return;\n  }\n\n  // Enforce maximum TODO count\n  if (todos.length > MAX_TODOS) {\n    throw new Error(\n      `Too many TODOs (${todos.length}/${MAX_TODOS}). ` +\n        `Keep high precision at the center: ` +\n        `summarize old completed work (e.g., 'Setup phase (3 tasks)'), ` +\n        `keep recent completions detailed (1-2), ` +\n        `one in_progress, ` +\n        `immediate pending detailed (2-3), ` +\n        `and summarize far future work (e.g., 'Testing phase (4 items)').`\n    );\n  }\n\n  let phase: \"completed\" | \"in_progress\" | \"pending\" = \"completed\";\n  let inProgressCount = 0;\n\n  todos.forEach((todo, index) => {\n    const status = todo.status;\n\n    switch (status) {\n      case \"completed\": {\n        if (phase !== \"completed\") {\n          throw new Error(\n            `Invalid todo order at index ${index}: completed tasks must appear before in-progress or pending tasks`\n          );\n        }\n        // Stay in completed phase\n        break;\n      }\n      case \"in_progress\": {\n        if (phase === \"pending\") {\n          throw new Error(\n            `Invalid todo order at index ${index}: in-progress tasks must appear before pending tasks`\n          );\n        }\n        inProgressCount += 1;\n        if (inProgressCount > 1) {\n          throw new Error(\n            \"Invalid todo list: only one task can be marked as in_progress at a time\"\n          );\n        }\n        // Transition to in_progress phase (from completed or stay in in_progress)\n        phase = \"in_progress\";\n        break;\n      }\n      case \"pending\": {\n        // Transition to pending phase (from completed, in_progress, or stay in pending)\n        phase = \"pending\";\n        break;\n      }\n      default: {\n        throw new Error(`Invalid todo status at index ${index}: ${String(status)}`);\n      }\n    }\n  });\n}\n\n/**\n * Write todos to the workspace session directory.\n */\nasync function writeTodos(\n  workspaceId: string,\n  workspaceSessionDir: string,\n  todos: TodoItem[]\n): Promise<void> {\n  validateTodos(todos);\n\n  await workspaceFileLocks.withLock(workspaceId, async () => {\n    const todoFile = getTodoFilePath(workspaceSessionDir);\n    await fs.mkdir(path.dirname(todoFile), { recursive: true });\n    await writeFileAtomic(todoFile, JSON.stringify(todos, null, 2));\n  });\n}\n\nasync function clearTodos(workspaceId: string, workspaceSessionDir: string): Promise<void> {\n  await workspaceFileLocks.withLock(workspaceId, async () => {\n    const todoFile = getTodoFilePath(workspaceSessionDir);\n    try {\n      await fs.unlink(todoFile);\n    } catch (error) {\n      if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\n        return;\n      }\n      throw error;\n    }\n  });\n}\n\n/**\n * Todo write tool factory\n * Creates a tool that allows the AI to create/update the todo list\n */\nexport const createTodoWriteTool: ToolFactory = (config) => {\n  return tool({\n    description: TOOL_DEFINITIONS.todo_write.description,\n    inputSchema: TOOL_DEFINITIONS.todo_write.schema,\n    execute: async ({ todos }) => {\n      assert(config.workspaceId, \"todo_write requires workspaceId\");\n      assert(config.workspaceSessionDir, \"todo_write requires workspaceSessionDir\");\n      await writeTodos(config.workspaceId, config.workspaceSessionDir, todos);\n      return {\n        success: true as const,\n        count: todos.length,\n      };\n    },\n  });\n};\n\n/**\n * Todo read tool factory\n * Creates a tool that allows the AI to read the current todo list\n */\nexport const createTodoReadTool: ToolFactory = (config) => {\n  return tool({\n    description: TOOL_DEFINITIONS.todo_read.description,\n    inputSchema: TOOL_DEFINITIONS.todo_read.schema,\n    execute: async () => {\n      assert(config.workspaceSessionDir, \"todo_read requires workspaceSessionDir\");\n      const todos = await readTodosForSessionDir(config.workspaceSessionDir);\n      return {\n        todos,\n      };\n    },\n  });\n};\n\n/**\n * Set todos for a workspace session directory (useful for testing)\n */\nexport async function setTodosForSessionDir(\n  workspaceId: string,\n  workspaceSessionDir: string,\n  todos: TodoItem[]\n): Promise<void> {\n  await writeTodos(workspaceId, workspaceSessionDir, todos);\n}\n\n/**\n * Get todos for a workspace session directory (useful for testing)\n */\nexport async function getTodosForSessionDir(workspaceSessionDir: string): Promise<TodoItem[]> {\n  return readTodosForSessionDir(workspaceSessionDir);\n}\n\n/**\n * Clear todos for a workspace session directory (useful for testing and cleanup)\n */\nexport async function clearTodosForSessionDir(\n  workspaceId: string,\n  workspaceSessionDir: string\n): Promise<void> {\n  await clearTodos(workspaceId, workspaceSessionDir);\n}\n"]}