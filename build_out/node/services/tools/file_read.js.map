{"version":3,"file":"file_read.js","sourceRoot":"","sources":["../../../../src/node/services/tools/file_read.ts"],"names":[],"mappings":"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","sourcesContent":["import { tool } from \"ai\";\nimport type { FileReadToolResult } from \"@/common/types/tools\";\nimport type { ToolConfiguration, ToolFactory } from \"@/common/utils/tools/tools\";\nimport { TOOL_DEFINITIONS } from \"@/common/utils/tools/toolDefinitions\";\nimport { validateFileSize, validateAndCorrectPath } from \"./fileCommon\";\nimport { RuntimeError } from \"@/node/runtime/Runtime\";\nimport { readFileString } from \"@/node/utils/runtime/helpers\";\n\n/**\n * File read tool factory for AI assistant\n * Creates a tool that allows the AI to read file contents from the file system\n * @param config Required configuration including working directory\n */\nexport const createFileReadTool: ToolFactory = (config: ToolConfiguration) => {\n  return tool({\n    description: TOOL_DEFINITIONS.file_read.description,\n    inputSchema: TOOL_DEFINITIONS.file_read.schema,\n    execute: async (\n      { file_path, offset, limit },\n      { abortSignal: _abortSignal }\n    ): Promise<FileReadToolResult> => {\n      // Note: abortSignal available but not used - file reads are fast and complete quickly\n\n      let filePath = file_path;\n      try {\n        // Validate and auto-correct redundant path prefix\n        const { correctedPath: validatedPath, warning: pathWarning } = validateAndCorrectPath(\n          filePath,\n          config.cwd,\n          config.runtime\n        );\n        filePath = validatedPath;\n\n        // Use runtime's normalizePath method to resolve paths correctly for both local and SSH runtimes\n        const resolvedPath = config.runtime.normalizePath(filePath, config.cwd);\n\n        // Check if file exists using runtime\n        let fileStat;\n        try {\n          fileStat = await config.runtime.stat(resolvedPath);\n        } catch (err) {\n          if (err instanceof RuntimeError) {\n            return {\n              success: false,\n              error: err.message,\n            };\n          }\n          throw err;\n        }\n\n        if (fileStat.isDirectory) {\n          return {\n            success: false,\n            error: `Path is a directory, not a file: ${resolvedPath}`,\n          };\n        }\n\n        // Validate file size\n        const sizeValidation = validateFileSize(fileStat);\n        if (sizeValidation) {\n          return {\n            success: false,\n            error: sizeValidation.error,\n          };\n        }\n\n        // Read full file content using runtime helper\n        let fullContent: string;\n        try {\n          fullContent = await readFileString(config.runtime, resolvedPath);\n        } catch (err) {\n          if (err instanceof RuntimeError) {\n            return {\n              success: false,\n              error: err.message,\n            };\n          }\n          throw err;\n        }\n\n        const startLineNumber = offset ?? 1;\n\n        // Validate offset\n        if (offset != null && offset < 1) {\n          return {\n            success: false,\n            error: `Offset must be positive (got ${offset})`,\n          };\n        }\n\n        // Split content into lines for processing\n        // Handle empty file case: splitting \"\" by \"\\n\" gives [\"\"], but we want []\n        const lines = fullContent === \"\" ? [] : fullContent.split(\"\\n\");\n\n        // Validate offset\n        if (offset != null && offset > lines.length) {\n          return {\n            success: false,\n            error: `Offset ${offset} is beyond file length`,\n          };\n        }\n\n        const numberedLines: string[] = [];\n        let totalBytesAccumulated = 0;\n        const MAX_LINE_BYTES = 1024;\n        const MAX_LINES = 1000;\n        const MAX_TOTAL_BYTES = 16 * 1024; // 16KB\n\n        // Process lines with offset and limit\n        const startIdx = startLineNumber - 1; // Convert to 0-based index\n        const endIdx = limit != null ? startIdx + limit : lines.length;\n\n        for (let i = startIdx; i < Math.min(endIdx, lines.length); i++) {\n          const line = lines[i];\n          const lineNumber = i + 1;\n\n          // Truncate line if it exceeds max bytes\n          let processedLine = line;\n          const lineBytes = Buffer.byteLength(line, \"utf-8\");\n          if (lineBytes > MAX_LINE_BYTES) {\n            // Truncate to MAX_LINE_BYTES\n            processedLine = Buffer.from(line, \"utf-8\")\n              .subarray(0, MAX_LINE_BYTES)\n              .toString(\"utf-8\");\n            processedLine += \"... [truncated]\";\n          }\n\n          // Format line with number prefix\n          const numberedLine = `${lineNumber}\\t${processedLine}`;\n          const numberedLineBytes = Buffer.byteLength(numberedLine, \"utf-8\");\n\n          // Check if adding this line would exceed byte limit\n          if (totalBytesAccumulated + numberedLineBytes > MAX_TOTAL_BYTES) {\n            return {\n              success: false,\n              error: `Output would exceed ${MAX_TOTAL_BYTES} bytes. Please read less at a time using offset and limit parameters.`,\n            };\n          }\n\n          numberedLines.push(numberedLine);\n          totalBytesAccumulated += numberedLineBytes + 1; // +1 for newline\n\n          // Check if we've exceeded max lines\n          if (numberedLines.length > MAX_LINES) {\n            return {\n              success: false,\n              error: `Output would exceed ${MAX_LINES} lines. Please read less at a time using offset and limit parameters.`,\n            };\n          }\n        }\n\n        // Join lines with newlines\n        const content = numberedLines.join(\"\\n\");\n\n        // Return file info and content\n        return {\n          success: true,\n          file_size: fileStat.size,\n          modifiedTime: fileStat.modifiedTime.toISOString(),\n          lines_read: numberedLines.length,\n          content,\n          ...(pathWarning && { warning: pathWarning }),\n        };\n      } catch (error) {\n        // Handle specific errors\n        if (error && typeof error === \"object\" && \"code\" in error) {\n          if (error.code === \"ENOENT\") {\n            return {\n              success: false,\n              error: `File not found: ${filePath}`,\n            };\n          } else if (error.code === \"EACCES\") {\n            return {\n              success: false,\n              error: `Permission denied: ${filePath}`,\n            };\n          }\n        }\n\n        // Generic error\n        const message = error instanceof Error ? error.message : String(error);\n        return {\n          success: false,\n          error: `Failed to read file: ${message}`,\n        };\n      }\n    },\n  });\n};\n"]}