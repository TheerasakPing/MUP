{"version":3,"file":"file_read.js","sourceRoot":"","sources":["../../../../src/node/services/tools/file_read.ts"],"names":[],"mappings":"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","sourcesContent":["import { tool } from \"ai\";\r\nimport type { FileReadToolResult } from \"@/common/types/tools\";\r\nimport type { ToolConfiguration, ToolFactory } from \"@/common/utils/tools/tools\";\r\nimport { TOOL_DEFINITIONS } from \"@/common/utils/tools/toolDefinitions\";\r\nimport { validateFileSize, validateAndCorrectPath } from \"./fileCommon\";\r\nimport { RuntimeError } from \"@/node/runtime/Runtime\";\r\nimport { readFileString } from \"@/node/utils/runtime/helpers\";\r\n\r\n/**\r\n * File read tool factory for AI assistant\r\n * Creates a tool that allows the AI to read file contents from the file system\r\n * @param config Required configuration including working directory\r\n */\r\nexport const createFileReadTool: ToolFactory = (config: ToolConfiguration) => {\r\n  return tool({\r\n    description: TOOL_DEFINITIONS.file_read.description,\r\n    inputSchema: TOOL_DEFINITIONS.file_read.schema,\r\n    execute: async (\r\n      { file_path, offset, limit },\r\n      { abortSignal: _abortSignal }\r\n    ): Promise<FileReadToolResult> => {\r\n      // Note: abortSignal available but not used - file reads are fast and complete quickly\r\n\r\n      let filePath = file_path;\r\n      try {\r\n        // Validate and auto-correct redundant path prefix\r\n        const { correctedPath: validatedPath, warning: pathWarning } = validateAndCorrectPath(\r\n          filePath,\r\n          config.cwd,\r\n          config.runtime\r\n        );\r\n        filePath = validatedPath;\r\n\r\n        // Use runtime's normalizePath method to resolve paths correctly for both local and SSH runtimes\r\n        const resolvedPath = config.runtime.normalizePath(filePath, config.cwd);\r\n\r\n        // Check if file exists using runtime\r\n        let fileStat;\r\n        try {\r\n          fileStat = await config.runtime.stat(resolvedPath);\r\n        } catch (err) {\r\n          if (err instanceof RuntimeError) {\r\n            return {\r\n              success: false,\r\n              error: err.message,\r\n            };\r\n          }\r\n          throw err;\r\n        }\r\n\r\n        if (fileStat.isDirectory) {\r\n          return {\r\n            success: false,\r\n            error: `Path is a directory, not a file: ${resolvedPath}`,\r\n          };\r\n        }\r\n\r\n        // Validate file size\r\n        const sizeValidation = validateFileSize(fileStat);\r\n        if (sizeValidation) {\r\n          return {\r\n            success: false,\r\n            error: sizeValidation.error,\r\n          };\r\n        }\r\n\r\n        // Read full file content using runtime helper\r\n        let fullContent: string;\r\n        try {\r\n          fullContent = await readFileString(config.runtime, resolvedPath);\r\n        } catch (err) {\r\n          if (err instanceof RuntimeError) {\r\n            return {\r\n              success: false,\r\n              error: err.message,\r\n            };\r\n          }\r\n          throw err;\r\n        }\r\n\r\n        const startLineNumber = offset ?? 1;\r\n\r\n        // Validate offset\r\n        if (offset != null && offset < 1) {\r\n          return {\r\n            success: false,\r\n            error: `Offset must be positive (got ${offset})`,\r\n          };\r\n        }\r\n\r\n        // Split content into lines for processing\r\n        // Handle empty file case: splitting \"\" by \"\\n\" gives [\"\"], but we want []\r\n        const lines = fullContent === \"\" ? [] : fullContent.split(\"\\n\");\r\n\r\n        // Validate offset\r\n        if (offset != null && offset > lines.length) {\r\n          return {\r\n            success: false,\r\n            error: `Offset ${offset} is beyond file length`,\r\n          };\r\n        }\r\n\r\n        const numberedLines: string[] = [];\r\n        let totalBytesAccumulated = 0;\r\n        const MAX_LINE_BYTES = 1024;\r\n        const MAX_LINES = 1000;\r\n        const MAX_TOTAL_BYTES = 16 * 1024; // 16KB\r\n\r\n        // Process lines with offset and limit\r\n        const startIdx = startLineNumber - 1; // Convert to 0-based index\r\n        const endIdx = limit != null ? startIdx + limit : lines.length;\r\n\r\n        for (let i = startIdx; i < Math.min(endIdx, lines.length); i++) {\r\n          const line = lines[i];\r\n          const lineNumber = i + 1;\r\n\r\n          // Truncate line if it exceeds max bytes\r\n          let processedLine = line;\r\n          const lineBytes = Buffer.byteLength(line, \"utf-8\");\r\n          if (lineBytes > MAX_LINE_BYTES) {\r\n            // Truncate to MAX_LINE_BYTES\r\n            processedLine = Buffer.from(line, \"utf-8\")\r\n              .subarray(0, MAX_LINE_BYTES)\r\n              .toString(\"utf-8\");\r\n            processedLine += \"... [truncated]\";\r\n          }\r\n\r\n          // Format line with number prefix\r\n          const numberedLine = `${lineNumber}\\t${processedLine}`;\r\n          const numberedLineBytes = Buffer.byteLength(numberedLine, \"utf-8\");\r\n\r\n          // Check if adding this line would exceed byte limit\r\n          if (totalBytesAccumulated + numberedLineBytes > MAX_TOTAL_BYTES) {\r\n            return {\r\n              success: false,\r\n              error: `Output would exceed ${MAX_TOTAL_BYTES} bytes. Please read less at a time using offset and limit parameters.`,\r\n            };\r\n          }\r\n\r\n          numberedLines.push(numberedLine);\r\n          totalBytesAccumulated += numberedLineBytes + 1; // +1 for newline\r\n\r\n          // Check if we've exceeded max lines\r\n          if (numberedLines.length > MAX_LINES) {\r\n            return {\r\n              success: false,\r\n              error: `Output would exceed ${MAX_LINES} lines. Please read less at a time using offset and limit parameters.`,\r\n            };\r\n          }\r\n        }\r\n\r\n        // Join lines with newlines\r\n        const content = numberedLines.join(\"\\n\");\r\n\r\n        // Return file info and content\r\n        return {\r\n          success: true,\r\n          file_size: fileStat.size,\r\n          modifiedTime: fileStat.modifiedTime.toISOString(),\r\n          lines_read: numberedLines.length,\r\n          content,\r\n          ...(pathWarning && { warning: pathWarning }),\r\n        };\r\n      } catch (error) {\r\n        // Handle specific errors\r\n        if (error && typeof error === \"object\" && \"code\" in error) {\r\n          if (error.code === \"ENOENT\") {\r\n            return {\r\n              success: false,\r\n              error: `File not found: ${filePath}`,\r\n            };\r\n          } else if (error.code === \"EACCES\") {\r\n            return {\r\n              success: false,\r\n              error: `Permission denied: ${filePath}`,\r\n            };\r\n          }\r\n        }\r\n\r\n        // Generic error\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        return {\r\n          success: false,\r\n          error: `Failed to read file: ${message}`,\r\n        };\r\n      }\r\n    },\r\n  });\r\n};\r\n"]}