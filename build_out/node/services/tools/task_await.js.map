{"version":3,"file":"task_await.js","sourceRoot":"","sources":["../../../../src/node/services/tools/task_await.ts"],"names":[],"mappings":"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","sourcesContent":["import { tool } from \"ai\";\n\nimport type { ToolConfiguration, ToolFactory } from \"@/common/utils/tools/tools\";\nimport { readSubagentGitPatchArtifact } from \"@/node/services/subagentGitPatchArtifacts\";\nimport { TaskAwaitToolResultSchema, TOOL_DEFINITIONS } from \"@/common/utils/tools/toolDefinitions\";\n\nimport { fromBashTaskId, toBashTaskId } from \"./taskId\";\nimport { formatBashOutputReport } from \"./bashTaskReport\";\nimport {\n  dedupeStrings,\n  parseToolResult,\n  requireTaskService,\n  requireWorkspaceId,\n} from \"./toolUtils\";\n\nfunction coerceTimeoutMs(timeoutSecs: unknown): number | undefined {\n  if (typeof timeoutSecs !== \"number\" || !Number.isFinite(timeoutSecs)) return undefined;\n  if (timeoutSecs < 0) return undefined;\n  const timeoutMs = Math.floor(timeoutSecs * 1000);\n  return timeoutMs;\n}\n\nexport const createTaskAwaitTool: ToolFactory = (config: ToolConfiguration) => {\n  return tool({\n    description: TOOL_DEFINITIONS.task_await.description,\n    inputSchema: TOOL_DEFINITIONS.task_await.schema,\n    execute: async (args, { abortSignal }): Promise<unknown> => {\n      const workspaceId = requireWorkspaceId(config, \"task_await\");\n      const taskService = requireTaskService(config, \"task_await\");\n\n      const timeoutMs = coerceTimeoutMs(args.timeout_secs);\n      // Preserve the documented 600s default when the model sends null\n      // (Zod .default() only replaces undefined, not null).\n      const timeoutSecsForBash = args.timeout_secs ?? 600;\n\n      const requestedIds: string[] | null =\n        args.task_ids && args.task_ids.length > 0 ? args.task_ids : null;\n\n      let candidateTaskIds: string[] =\n        requestedIds ?? taskService.listActiveDescendantAgentTaskIds(workspaceId);\n\n      if (!requestedIds && config.backgroundProcessManager) {\n        const processes = await config.backgroundProcessManager.list();\n        const bashTaskIds: string[] = [];\n        for (const proc of processes) {\n          if (proc.status !== \"running\") continue;\n          const inScope =\n            proc.workspaceId === workspaceId ||\n            (await taskService.isDescendantAgentTask(workspaceId, proc.workspaceId));\n          if (!inScope) continue;\n          bashTaskIds.push(toBashTaskId(proc.id));\n        }\n\n        candidateTaskIds = [...candidateTaskIds, ...bashTaskIds];\n      }\n\n      const uniqueTaskIds = dedupeStrings(candidateTaskIds);\n\n      const agentTaskIds = uniqueTaskIds.filter((taskId) => !taskId.startsWith(\"bash:\"));\n      const bulkFilter = (\n        taskService as unknown as {\n          filterDescendantAgentTaskIds?: (\n            ancestorWorkspaceId: string,\n            taskIds: string[]\n          ) => Promise<string[]>;\n        }\n      ).filterDescendantAgentTaskIds;\n\n      // Read patch artifacts lazily (after waiting) to avoid stale results. Patch generation is\n      // started after `resolveWaiters` in `handleAgentReport`, so reading once up-front can miss\n      // artifacts that appear while we're awaiting reports.\n      const readGitFormatPatchArtifact = async (childTaskId: string) => {\n        if (!config.workspaceSessionDir) return null;\n        return await readSubagentGitPatchArtifact(config.workspaceSessionDir, childTaskId);\n      };\n\n      const descendantAgentTaskIds =\n        typeof bulkFilter === \"function\"\n          ? await bulkFilter.call(taskService, workspaceId, agentTaskIds)\n          : (\n              await Promise.all(\n                agentTaskIds.map(async (taskId) =>\n                  (await taskService.isDescendantAgentTask(workspaceId, taskId)) ? taskId : null\n                )\n              )\n            ).filter((taskId): taskId is string => typeof taskId === \"string\");\n\n      const descendantAgentTaskIdSet = new Set(descendantAgentTaskIds);\n\n      const results = await Promise.all(\n        uniqueTaskIds.map(async (taskId) => {\n          const maybeProcessId = fromBashTaskId(taskId);\n          if (taskId.startsWith(\"bash:\") && !maybeProcessId) {\n            return { status: \"error\" as const, taskId, error: \"Invalid bash taskId.\" };\n          }\n\n          if (maybeProcessId) {\n            if (!config.backgroundProcessManager) {\n              return {\n                status: \"error\" as const,\n                taskId,\n                error: \"Background process manager not available\",\n              };\n            }\n\n            const proc = await config.backgroundProcessManager.getProcess(maybeProcessId);\n            if (!proc) {\n              return { status: \"not_found\" as const, taskId };\n            }\n\n            const inScope =\n              proc.workspaceId === workspaceId ||\n              (await taskService.isDescendantAgentTask(workspaceId, proc.workspaceId));\n            if (!inScope) {\n              return { status: \"invalid_scope\" as const, taskId };\n            }\n\n            const outputResult = await config.backgroundProcessManager.getOutput(\n              maybeProcessId,\n              args.filter ?? undefined,\n              args.filter_exclude ?? undefined,\n              timeoutSecsForBash,\n              abortSignal,\n              workspaceId,\n              \"task_await\"\n            );\n\n            if (!outputResult.success) {\n              return { status: \"error\" as const, taskId, error: outputResult.error };\n            }\n\n            if (outputResult.status === \"running\" || outputResult.status === \"interrupted\") {\n              return {\n                status: \"running\" as const,\n                taskId,\n                output: outputResult.output,\n                elapsed_ms: outputResult.elapsed_ms,\n                note: outputResult.note,\n              };\n            }\n\n            return {\n              status: \"completed\" as const,\n              taskId,\n              title: proc.displayName ?? proc.id,\n              reportMarkdown: formatBashOutputReport({\n                processId: proc.id,\n                status: outputResult.status,\n                exitCode: outputResult.exitCode,\n                output: outputResult.output,\n              }),\n              elapsed_ms: outputResult.elapsed_ms,\n              exitCode: outputResult.exitCode,\n              note: outputResult.note,\n            };\n          }\n\n          if (!descendantAgentTaskIdSet.has(taskId)) {\n            return { status: \"invalid_scope\" as const, taskId };\n          }\n\n          // When timeout_secs=0 (or rounds down to 0ms), task_await should be non-blocking.\n          // `waitForAgentReport` asserts timeoutMs > 0, so handle 0 explicitly by returning the\n          // current task status instead of awaiting.\n          if (timeoutMs === 0) {\n            const status = taskService.getAgentTaskStatus(taskId);\n            if (status === \"queued\" || status === \"running\" || status === \"awaiting_report\") {\n              return { status, taskId };\n            }\n\n            // Best-effort: the task might already have a cached report (even if its workspace was\n            // cleaned up). Avoid blocking when it isn't available.\n            try {\n              const report = await taskService.waitForAgentReport(taskId, {\n                timeoutMs: 1,\n                abortSignal,\n                requestingWorkspaceId: workspaceId,\n              });\n\n              const gitFormatPatch = await readGitFormatPatchArtifact(taskId);\n              return {\n                status: \"completed\" as const,\n                taskId,\n                reportMarkdown: report.reportMarkdown,\n                title: report.title,\n                ...(gitFormatPatch ? { artifacts: { gitFormatPatch } } : {}),\n              };\n            } catch (error: unknown) {\n              const message = error instanceof Error ? error.message : String(error);\n              if (/not found/i.test(message)) {\n                return { status: \"not_found\" as const, taskId };\n              }\n              return { status: \"error\" as const, taskId, error: message };\n            }\n          }\n\n          try {\n            const report = await taskService.waitForAgentReport(taskId, {\n              timeoutMs,\n              abortSignal,\n              requestingWorkspaceId: workspaceId,\n            });\n\n            const gitFormatPatch = await readGitFormatPatchArtifact(taskId);\n            return {\n              status: \"completed\" as const,\n              taskId,\n              reportMarkdown: report.reportMarkdown,\n              title: report.title,\n              ...(gitFormatPatch ? { artifacts: { gitFormatPatch } } : {}),\n            };\n          } catch (error: unknown) {\n            if (abortSignal?.aborted) {\n              return { status: \"error\" as const, taskId, error: \"Interrupted\" };\n            }\n\n            const message = error instanceof Error ? error.message : String(error);\n            if (/not found/i.test(message)) {\n              return { status: \"not_found\" as const, taskId };\n            }\n            if (/timed out/i.test(message)) {\n              const status = taskService.getAgentTaskStatus(taskId);\n              if (status === \"queued\" || status === \"running\" || status === \"awaiting_report\") {\n                return { status, taskId };\n              }\n              if (!status) {\n                return { status: \"not_found\" as const, taskId };\n              }\n              return {\n                status: \"error\" as const,\n                taskId,\n                error: `Task status is '${status}' (not awaitable via task_await).`,\n              };\n            }\n            return { status: \"error\" as const, taskId, error: message };\n          }\n        })\n      );\n\n      return parseToolResult(TaskAwaitToolResultSchema, { results }, \"task_await\");\n    },\n  });\n};\n"]}