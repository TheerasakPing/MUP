{"version":3,"file":"task_await.js","sourceRoot":"","sources":["../../../../src/node/services/tools/task_await.ts"],"names":[],"mappings":";;;AAAA,2BAA0B;AAG1B,yFAAyF;AACzF,0EAAmG;AAEnG,qCAAwD;AACxD,qDAA0D;AAC1D,2CAKqB;AAErB,SAAS,eAAe,CAAC,WAAoB,EAAsB;IACjE,IAAI,OAAO,WAAW,KAAK,QAAQ,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC;QAAE,OAAO,SAAS,CAAC;IACvF,IAAI,WAAW,GAAG,CAAC;QAAE,OAAO,SAAS,CAAC;IACtC,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC,CAAC;IACjD,OAAO,SAAS,CAAC;AAAA,CAClB;AAEM,MAAM,mBAAmB,GAAgB,CAAC,MAAyB,EAAE,EAAE,CAAC;IAC7E,OAAO,IAAA,SAAI,EAAC;QACV,WAAW,EAAE,kCAAgB,CAAC,UAAU,CAAC,WAAW;QACpD,WAAW,EAAE,kCAAgB,CAAC,UAAU,CAAC,MAAM;QAC/C,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE,WAAW,EAAE,EAAoB,EAAE,CAAC;YAC1D,MAAM,WAAW,GAAG,IAAA,8BAAkB,EAAC,MAAM,EAAE,YAAY,CAAC,CAAC;YAC7D,MAAM,WAAW,GAAG,IAAA,8BAAkB,EAAC,MAAM,EAAE,YAAY,CAAC,CAAC;YAE7D,MAAM,SAAS,GAAG,eAAe,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YACrD,iEAAiE;YACjE,sDAAsD;YACtD,MAAM,kBAAkB,GAAG,IAAI,CAAC,YAAY,IAAI,GAAG,CAAC;YAEpD,MAAM,YAAY,GAChB,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC;YAEnE,IAAI,gBAAgB,GAClB,YAAY,IAAI,WAAW,CAAC,gCAAgC,CAAC,WAAW,CAAC,CAAC;YAE5E,IAAI,CAAC,YAAY,IAAI,MAAM,CAAC,wBAAwB,EAAE,CAAC;gBACrD,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,wBAAwB,CAAC,IAAI,EAAE,CAAC;gBAC/D,MAAM,WAAW,GAAa,EAAE,CAAC;gBACjC,KAAK,MAAM,IAAI,IAAI,SAAS,EAAE,CAAC;oBAC7B,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS;wBAAE,SAAS;oBACxC,MAAM,OAAO,GACX,IAAI,CAAC,WAAW,KAAK,WAAW;wBAChC,CAAC,MAAM,WAAW,CAAC,qBAAqB,CAAC,WAAW,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;oBAC3E,IAAI,CAAC,OAAO;wBAAE,SAAS;oBACvB,WAAW,CAAC,IAAI,CAAC,IAAA,qBAAY,EAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;gBAC1C,CAAC;gBAED,gBAAgB,GAAG,CAAC,GAAG,gBAAgB,EAAE,GAAG,WAAW,CAAC,CAAC;YAC3D,CAAC;YAED,MAAM,aAAa,GAAG,IAAA,yBAAa,EAAC,gBAAgB,CAAC,CAAC;YAEtD,MAAM,YAAY,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC;YACnF,MAAM,UAAU,GACd,WAMD,CAAC,4BAA4B,CAAC;YAE/B,0FAA0F;YAC1F,2FAA2F;YAC3F,sDAAsD;YACtD,MAAM,0BAA0B,GAAG,KAAK,EAAE,WAAmB,EAAE,EAAE,CAAC;gBAChE,IAAI,CAAC,MAAM,CAAC,mBAAmB;oBAAE,OAAO,IAAI,CAAC;gBAC7C,OAAO,MAAM,IAAA,wDAA4B,EAAC,MAAM,CAAC,mBAAmB,EAAE,WAAW,CAAC,CAAC;YAAA,CACpF,CAAC;YAEF,MAAM,sBAAsB,GAC1B,OAAO,UAAU,KAAK,UAAU;gBAC9B,CAAC,CAAC,MAAM,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,WAAW,EAAE,YAAY,CAAC;gBAC/D,CAAC,CAAC,CACE,MAAM,OAAO,CAAC,GAAG,CACf,YAAY,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,CAChC,CAAC,MAAM,WAAW,CAAC,qBAAqB,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAC/E,CACF,CACF,CAAC,MAAM,CAAC,CAAC,MAAM,EAAoB,EAAE,CAAC,OAAO,MAAM,KAAK,QAAQ,CAAC,CAAC;YAEzE,MAAM,wBAAwB,GAAG,IAAI,GAAG,CAAC,sBAAsB,CAAC,CAAC;YAEjE,MAAM,OAAO,GAAG,MAAM,OAAO,CAAC,GAAG,CAC/B,aAAa,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,CAAC;gBAClC,MAAM,cAAc,GAAG,IAAA,uBAAc,EAAC,MAAM,CAAC,CAAC;gBAC9C,IAAI,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC;oBAClD,OAAO,EAAE,MAAM,EAAE,OAAgB,EAAE,MAAM,EAAE,KAAK,EAAE,sBAAsB,EAAE,CAAC;gBAC7E,CAAC;gBAED,IAAI,cAAc,EAAE,CAAC;oBACnB,IAAI,CAAC,MAAM,CAAC,wBAAwB,EAAE,CAAC;wBACrC,OAAO;4BACL,MAAM,EAAE,OAAgB;4BACxB,MAAM;4BACN,KAAK,EAAE,0CAA0C;yBAClD,CAAC;oBACJ,CAAC;oBAED,MAAM,IAAI,GAAG,MAAM,MAAM,CAAC,wBAAwB,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC;oBAC9E,IAAI,CAAC,IAAI,EAAE,CAAC;wBACV,OAAO,EAAE,MAAM,EAAE,WAAoB,EAAE,MAAM,EAAE,CAAC;oBAClD,CAAC;oBAED,MAAM,OAAO,GACX,IAAI,CAAC,WAAW,KAAK,WAAW;wBAChC,CAAC,MAAM,WAAW,CAAC,qBAAqB,CAAC,WAAW,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;oBAC3E,IAAI,CAAC,OAAO,EAAE,CAAC;wBACb,OAAO,EAAE,MAAM,EAAE,eAAwB,EAAE,MAAM,EAAE,CAAC;oBACtD,CAAC;oBAED,MAAM,YAAY,GAAG,MAAM,MAAM,CAAC,wBAAwB,CAAC,SAAS,CAClE,cAAc,EACd,IAAI,CAAC,MAAM,IAAI,SAAS,EACxB,IAAI,CAAC,cAAc,IAAI,SAAS,EAChC,kBAAkB,EAClB,WAAW,EACX,WAAW,EACX,YAAY,CACb,CAAC;oBAEF,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;wBAC1B,OAAO,EAAE,MAAM,EAAE,OAAgB,EAAE,MAAM,EAAE,KAAK,EAAE,YAAY,CAAC,KAAK,EAAE,CAAC;oBACzE,CAAC;oBAED,IAAI,YAAY,CAAC,MAAM,KAAK,SAAS,IAAI,YAAY,CAAC,MAAM,KAAK,aAAa,EAAE,CAAC;wBAC/E,OAAO;4BACL,MAAM,EAAE,SAAkB;4BAC1B,MAAM;4BACN,MAAM,EAAE,YAAY,CAAC,MAAM;4BAC3B,UAAU,EAAE,YAAY,CAAC,UAAU;4BACnC,IAAI,EAAE,YAAY,CAAC,IAAI;yBACxB,CAAC;oBACJ,CAAC;oBAED,OAAO;wBACL,MAAM,EAAE,WAAoB;wBAC5B,MAAM;wBACN,KAAK,EAAE,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,EAAE;wBAClC,cAAc,EAAE,IAAA,uCAAsB,EAAC;4BACrC,SAAS,EAAE,IAAI,CAAC,EAAE;4BAClB,MAAM,EAAE,YAAY,CAAC,MAAM;4BAC3B,QAAQ,EAAE,YAAY,CAAC,QAAQ;4BAC/B,MAAM,EAAE,YAAY,CAAC,MAAM;yBAC5B,CAAC;wBACF,UAAU,EAAE,YAAY,CAAC,UAAU;wBACnC,QAAQ,EAAE,YAAY,CAAC,QAAQ;wBAC/B,IAAI,EAAE,YAAY,CAAC,IAAI;qBACxB,CAAC;gBACJ,CAAC;gBAED,IAAI,CAAC,wBAAwB,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC;oBAC1C,OAAO,EAAE,MAAM,EAAE,eAAwB,EAAE,MAAM,EAAE,CAAC;gBACtD,CAAC;gBAED,kFAAkF;gBAClF,sFAAsF;gBACtF,2CAA2C;gBAC3C,IAAI,SAAS,KAAK,CAAC,EAAE,CAAC;oBACpB,MAAM,MAAM,GAAG,WAAW,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC;oBACtD,IAAI,MAAM,KAAK,QAAQ,IAAI,MAAM,KAAK,SAAS,IAAI,MAAM,KAAK,iBAAiB,EAAE,CAAC;wBAChF,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC;oBAC5B,CAAC;oBAED,sFAAsF;oBACtF,uDAAuD;oBACvD,IAAI,CAAC;wBACH,MAAM,MAAM,GAAG,MAAM,WAAW,CAAC,kBAAkB,CAAC,MAAM,EAAE;4BAC1D,SAAS,EAAE,CAAC;4BACZ,WAAW;4BACX,qBAAqB,EAAE,WAAW;yBACnC,CAAC,CAAC;wBAEH,MAAM,cAAc,GAAG,MAAM,0BAA0B,CAAC,MAAM,CAAC,CAAC;wBAChE,OAAO;4BACL,MAAM,EAAE,WAAoB;4BAC5B,MAAM;4BACN,cAAc,EAAE,MAAM,CAAC,cAAc;4BACrC,KAAK,EAAE,MAAM,CAAC,KAAK;4BACnB,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,SAAS,EAAE,EAAE,cAAc,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;yBAC7D,CAAC;oBACJ,CAAC;oBAAC,OAAO,KAAc,EAAE,CAAC;wBACxB,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;wBACvE,IAAI,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC;4BAC/B,OAAO,EAAE,MAAM,EAAE,WAAoB,EAAE,MAAM,EAAE,CAAC;wBAClD,CAAC;wBACD,OAAO,EAAE,MAAM,EAAE,OAAgB,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC;oBAC9D,CAAC;gBACH,CAAC;gBAED,IAAI,CAAC;oBACH,MAAM,MAAM,GAAG,MAAM,WAAW,CAAC,kBAAkB,CAAC,MAAM,EAAE;wBAC1D,SAAS;wBACT,WAAW;wBACX,qBAAqB,EAAE,WAAW;qBACnC,CAAC,CAAC;oBAEH,MAAM,cAAc,GAAG,MAAM,0BAA0B,CAAC,MAAM,CAAC,CAAC;oBAChE,OAAO;wBACL,MAAM,EAAE,WAAoB;wBAC5B,MAAM;wBACN,cAAc,EAAE,MAAM,CAAC,cAAc;wBACrC,KAAK,EAAE,MAAM,CAAC,KAAK;wBACnB,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,SAAS,EAAE,EAAE,cAAc,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;qBAC7D,CAAC;gBACJ,CAAC;gBAAC,OAAO,KAAc,EAAE,CAAC;oBACxB,IAAI,WAAW,EAAE,OAAO,EAAE,CAAC;wBACzB,OAAO,EAAE,MAAM,EAAE,OAAgB,EAAE,MAAM,EAAE,KAAK,EAAE,aAAa,EAAE,CAAC;oBACpE,CAAC;oBAED,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;oBACvE,IAAI,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC;wBAC/B,OAAO,EAAE,MAAM,EAAE,WAAoB,EAAE,MAAM,EAAE,CAAC;oBAClD,CAAC;oBACD,IAAI,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC;wBAC/B,MAAM,MAAM,GAAG,WAAW,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC;wBACtD,IAAI,MAAM,KAAK,QAAQ,IAAI,MAAM,KAAK,SAAS,IAAI,MAAM,KAAK,iBAAiB,EAAE,CAAC;4BAChF,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC;wBAC5B,CAAC;wBACD,IAAI,CAAC,MAAM,EAAE,CAAC;4BACZ,OAAO,EAAE,MAAM,EAAE,WAAoB,EAAE,MAAM,EAAE,CAAC;wBAClD,CAAC;wBACD,OAAO;4BACL,MAAM,EAAE,OAAgB;4BACxB,MAAM;4BACN,KAAK,EAAE,mBAAmB,MAAM,mCAAmC;yBACpE,CAAC;oBACJ,CAAC;oBACD,OAAO,EAAE,MAAM,EAAE,OAAgB,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC;gBAC9D,CAAC;YAAA,CACF,CAAC,CACH,CAAC;YAEF,OAAO,IAAA,2BAAe,EAAC,2CAAyB,EAAE,EAAE,OAAO,EAAE,EAAE,YAAY,CAAC,CAAC;QAAA,CAC9E;KACF,CAAC,CAAC;AAAA,CACJ,CAAC;AA5NW,QAAA,mBAAmB,GAAnB,mBAAmB,CA4N9B","sourcesContent":["import { tool } from \"ai\";\r\n\r\nimport type { ToolConfiguration, ToolFactory } from \"@/common/utils/tools/tools\";\r\nimport { readSubagentGitPatchArtifact } from \"@/node/services/subagentGitPatchArtifacts\";\r\nimport { TaskAwaitToolResultSchema, TOOL_DEFINITIONS } from \"@/common/utils/tools/toolDefinitions\";\r\n\r\nimport { fromBashTaskId, toBashTaskId } from \"./taskId\";\r\nimport { formatBashOutputReport } from \"./bashTaskReport\";\r\nimport {\r\n  dedupeStrings,\r\n  parseToolResult,\r\n  requireTaskService,\r\n  requireWorkspaceId,\r\n} from \"./toolUtils\";\r\n\r\nfunction coerceTimeoutMs(timeoutSecs: unknown): number | undefined {\r\n  if (typeof timeoutSecs !== \"number\" || !Number.isFinite(timeoutSecs)) return undefined;\r\n  if (timeoutSecs < 0) return undefined;\r\n  const timeoutMs = Math.floor(timeoutSecs * 1000);\r\n  return timeoutMs;\r\n}\r\n\r\nexport const createTaskAwaitTool: ToolFactory = (config: ToolConfiguration) => {\r\n  return tool({\r\n    description: TOOL_DEFINITIONS.task_await.description,\r\n    inputSchema: TOOL_DEFINITIONS.task_await.schema,\r\n    execute: async (args, { abortSignal }): Promise<unknown> => {\r\n      const workspaceId = requireWorkspaceId(config, \"task_await\");\r\n      const taskService = requireTaskService(config, \"task_await\");\r\n\r\n      const timeoutMs = coerceTimeoutMs(args.timeout_secs);\r\n      // Preserve the documented 600s default when the model sends null\r\n      // (Zod .default() only replaces undefined, not null).\r\n      const timeoutSecsForBash = args.timeout_secs ?? 600;\r\n\r\n      const requestedIds: string[] | null =\r\n        args.task_ids && args.task_ids.length > 0 ? args.task_ids : null;\r\n\r\n      let candidateTaskIds: string[] =\r\n        requestedIds ?? taskService.listActiveDescendantAgentTaskIds(workspaceId);\r\n\r\n      if (!requestedIds && config.backgroundProcessManager) {\r\n        const processes = await config.backgroundProcessManager.list();\r\n        const bashTaskIds: string[] = [];\r\n        for (const proc of processes) {\r\n          if (proc.status !== \"running\") continue;\r\n          const inScope =\r\n            proc.workspaceId === workspaceId ||\r\n            (await taskService.isDescendantAgentTask(workspaceId, proc.workspaceId));\r\n          if (!inScope) continue;\r\n          bashTaskIds.push(toBashTaskId(proc.id));\r\n        }\r\n\r\n        candidateTaskIds = [...candidateTaskIds, ...bashTaskIds];\r\n      }\r\n\r\n      const uniqueTaskIds = dedupeStrings(candidateTaskIds);\r\n\r\n      const agentTaskIds = uniqueTaskIds.filter((taskId) => !taskId.startsWith(\"bash:\"));\r\n      const bulkFilter = (\r\n        taskService as unknown as {\r\n          filterDescendantAgentTaskIds?: (\r\n            ancestorWorkspaceId: string,\r\n            taskIds: string[]\r\n          ) => Promise<string[]>;\r\n        }\r\n      ).filterDescendantAgentTaskIds;\r\n\r\n      // Read patch artifacts lazily (after waiting) to avoid stale results. Patch generation is\r\n      // started after `resolveWaiters` in `handleAgentReport`, so reading once up-front can miss\r\n      // artifacts that appear while we're awaiting reports.\r\n      const readGitFormatPatchArtifact = async (childTaskId: string) => {\r\n        if (!config.workspaceSessionDir) return null;\r\n        return await readSubagentGitPatchArtifact(config.workspaceSessionDir, childTaskId);\r\n      };\r\n\r\n      const descendantAgentTaskIds =\r\n        typeof bulkFilter === \"function\"\r\n          ? await bulkFilter.call(taskService, workspaceId, agentTaskIds)\r\n          : (\r\n              await Promise.all(\r\n                agentTaskIds.map(async (taskId) =>\r\n                  (await taskService.isDescendantAgentTask(workspaceId, taskId)) ? taskId : null\r\n                )\r\n              )\r\n            ).filter((taskId): taskId is string => typeof taskId === \"string\");\r\n\r\n      const descendantAgentTaskIdSet = new Set(descendantAgentTaskIds);\r\n\r\n      const results = await Promise.all(\r\n        uniqueTaskIds.map(async (taskId) => {\r\n          const maybeProcessId = fromBashTaskId(taskId);\r\n          if (taskId.startsWith(\"bash:\") && !maybeProcessId) {\r\n            return { status: \"error\" as const, taskId, error: \"Invalid bash taskId.\" };\r\n          }\r\n\r\n          if (maybeProcessId) {\r\n            if (!config.backgroundProcessManager) {\r\n              return {\r\n                status: \"error\" as const,\r\n                taskId,\r\n                error: \"Background process manager not available\",\r\n              };\r\n            }\r\n\r\n            const proc = await config.backgroundProcessManager.getProcess(maybeProcessId);\r\n            if (!proc) {\r\n              return { status: \"not_found\" as const, taskId };\r\n            }\r\n\r\n            const inScope =\r\n              proc.workspaceId === workspaceId ||\r\n              (await taskService.isDescendantAgentTask(workspaceId, proc.workspaceId));\r\n            if (!inScope) {\r\n              return { status: \"invalid_scope\" as const, taskId };\r\n            }\r\n\r\n            const outputResult = await config.backgroundProcessManager.getOutput(\r\n              maybeProcessId,\r\n              args.filter ?? undefined,\r\n              args.filter_exclude ?? undefined,\r\n              timeoutSecsForBash,\r\n              abortSignal,\r\n              workspaceId,\r\n              \"task_await\"\r\n            );\r\n\r\n            if (!outputResult.success) {\r\n              return { status: \"error\" as const, taskId, error: outputResult.error };\r\n            }\r\n\r\n            if (outputResult.status === \"running\" || outputResult.status === \"interrupted\") {\r\n              return {\r\n                status: \"running\" as const,\r\n                taskId,\r\n                output: outputResult.output,\r\n                elapsed_ms: outputResult.elapsed_ms,\r\n                note: outputResult.note,\r\n              };\r\n            }\r\n\r\n            return {\r\n              status: \"completed\" as const,\r\n              taskId,\r\n              title: proc.displayName ?? proc.id,\r\n              reportMarkdown: formatBashOutputReport({\r\n                processId: proc.id,\r\n                status: outputResult.status,\r\n                exitCode: outputResult.exitCode,\r\n                output: outputResult.output,\r\n              }),\r\n              elapsed_ms: outputResult.elapsed_ms,\r\n              exitCode: outputResult.exitCode,\r\n              note: outputResult.note,\r\n            };\r\n          }\r\n\r\n          if (!descendantAgentTaskIdSet.has(taskId)) {\r\n            return { status: \"invalid_scope\" as const, taskId };\r\n          }\r\n\r\n          // When timeout_secs=0 (or rounds down to 0ms), task_await should be non-blocking.\r\n          // `waitForAgentReport` asserts timeoutMs > 0, so handle 0 explicitly by returning the\r\n          // current task status instead of awaiting.\r\n          if (timeoutMs === 0) {\r\n            const status = taskService.getAgentTaskStatus(taskId);\r\n            if (status === \"queued\" || status === \"running\" || status === \"awaiting_report\") {\r\n              return { status, taskId };\r\n            }\r\n\r\n            // Best-effort: the task might already have a cached report (even if its workspace was\r\n            // cleaned up). Avoid blocking when it isn't available.\r\n            try {\r\n              const report = await taskService.waitForAgentReport(taskId, {\r\n                timeoutMs: 1,\r\n                abortSignal,\r\n                requestingWorkspaceId: workspaceId,\r\n              });\r\n\r\n              const gitFormatPatch = await readGitFormatPatchArtifact(taskId);\r\n              return {\r\n                status: \"completed\" as const,\r\n                taskId,\r\n                reportMarkdown: report.reportMarkdown,\r\n                title: report.title,\r\n                ...(gitFormatPatch ? { artifacts: { gitFormatPatch } } : {}),\r\n              };\r\n            } catch (error: unknown) {\r\n              const message = error instanceof Error ? error.message : String(error);\r\n              if (/not found/i.test(message)) {\r\n                return { status: \"not_found\" as const, taskId };\r\n              }\r\n              return { status: \"error\" as const, taskId, error: message };\r\n            }\r\n          }\r\n\r\n          try {\r\n            const report = await taskService.waitForAgentReport(taskId, {\r\n              timeoutMs,\r\n              abortSignal,\r\n              requestingWorkspaceId: workspaceId,\r\n            });\r\n\r\n            const gitFormatPatch = await readGitFormatPatchArtifact(taskId);\r\n            return {\r\n              status: \"completed\" as const,\r\n              taskId,\r\n              reportMarkdown: report.reportMarkdown,\r\n              title: report.title,\r\n              ...(gitFormatPatch ? { artifacts: { gitFormatPatch } } : {}),\r\n            };\r\n          } catch (error: unknown) {\r\n            if (abortSignal?.aborted) {\r\n              return { status: \"error\" as const, taskId, error: \"Interrupted\" };\r\n            }\r\n\r\n            const message = error instanceof Error ? error.message : String(error);\r\n            if (/not found/i.test(message)) {\r\n              return { status: \"not_found\" as const, taskId };\r\n            }\r\n            if (/timed out/i.test(message)) {\r\n              const status = taskService.getAgentTaskStatus(taskId);\r\n              if (status === \"queued\" || status === \"running\" || status === \"awaiting_report\") {\r\n                return { status, taskId };\r\n              }\r\n              if (!status) {\r\n                return { status: \"not_found\" as const, taskId };\r\n              }\r\n              return {\r\n                status: \"error\" as const,\r\n                taskId,\r\n                error: `Task status is '${status}' (not awaitable via task_await).`,\r\n              };\r\n            }\r\n            return { status: \"error\" as const, taskId, error: message };\r\n          }\r\n        })\r\n      );\r\n\r\n      return parseToolResult(TaskAwaitToolResultSchema, { results }, \"task_await\");\r\n    },\r\n  });\r\n};\r\n"]}