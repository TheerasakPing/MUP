{"version":3,"file":"eol.js","sourceRoot":"","sources":["../../../../src/node/services/tools/eol.ts"],"names":[],"mappings":";;;;;AAEA;;;;;GAKG;AACH,+BAAsC,IAAY,EAAU;IAC1D,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AAAA,CACzD;AAED;;;;GAIG;AACH,uBAA8B,eAAuB,EAAW;IAC9D,OAAO,eAAe,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;AAAA,CACzD;AAED,yBAAgC,IAAY,EAAE,GAAY,EAAU;IAClE,OAAO,qBAAqB,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AAAA,CACxD","sourcesContent":["export type FileEol = \"\\n\" | \"\\r\\n\";\n\n/**\n * Normalize all newline styles to LF.\n *\n * This is intentionally conservative and scoped to file-edit tools where we want\n * to be resilient to Windows CRLF vs. model-generated LF mismatches.\n */\nexport function normalizeNewlinesToLF(text: string): string {\n  return text.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n}\n\n/**\n * Detect a file's newline style.\n *\n * We prefer CRLF if we see any CRLF sequences.\n */\nexport function detectFileEol(originalContent: string): FileEol {\n  return originalContent.includes(\"\\r\\n\") ? \"\\r\\n\" : \"\\n\";\n}\n\nexport function convertNewlines(text: string, eol: FileEol): string {\n  return normalizeNewlinesToLF(text).replace(/\\n/g, eol);\n}\n"]}