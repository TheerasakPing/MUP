{"version":3,"file":"eol.js","sourceRoot":"","sources":["../../../../src/node/services/tools/eol.ts"],"names":[],"mappings":";;;;;AAEA;;;;;GAKG;AACH,+BAAsC,IAAY,EAAU;IAC1D,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AAAA,CACzD;AAED;;;;GAIG;AACH,uBAA8B,eAAuB,EAAW;IAC9D,OAAO,eAAe,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;AAAA,CACzD;AAED,yBAAgC,IAAY,EAAE,GAAY,EAAU;IAClE,OAAO,qBAAqB,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AAAA,CACxD","sourcesContent":["export type FileEol = \"\\n\" | \"\\r\\n\";\r\n\r\n/**\r\n * Normalize all newline styles to LF.\r\n *\r\n * This is intentionally conservative and scoped to file-edit tools where we want\r\n * to be resilient to Windows CRLF vs. model-generated LF mismatches.\r\n */\r\nexport function normalizeNewlinesToLF(text: string): string {\r\n  return text.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\r\n}\r\n\r\n/**\r\n * Detect a file's newline style.\r\n *\r\n * We prefer CRLF if we see any CRLF sequences.\r\n */\r\nexport function detectFileEol(originalContent: string): FileEol {\r\n  return originalContent.includes(\"\\r\\n\") ? \"\\r\\n\" : \"\\n\";\r\n}\r\n\r\nexport function convertNewlines(text: string, eol: FileEol): string {\r\n  return normalizeNewlinesToLF(text).replace(/\\n/g, eol);\r\n}\r\n"]}