{"version":3,"file":"backgroundProcessExecutor.js","sourceRoot":"","sources":["../../../src/node/services/backgroundProcessExecutor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Unified executor for background bash processes.\n *\n * ALL bash commands are spawned through this executor with background-style\n * infrastructure (nohup, file output, exit code trap). This enables:\n *\n * 1. Uniform code path - one spawn mechanism for all bash commands\n * 2. Crash resilience - output always persisted to files\n * 3. Seamless fgâ†’bg transition - \"background this\" = \"stop waiting\"\n *\n * Uses runtime.tempDir() for runtime-agnostic temp directory resolution.\n * Works identically for local and SSH runtimes.\n */\n\nimport type { Runtime, BackgroundHandle, ExecStream } from \"@/node/runtime/Runtime\";\nimport * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport { log } from \"./log\";\nimport {\n  buildWrapperScript,\n  buildSpawnCommand,\n  parsePid,\n  parseExitCode,\n  buildTerminateCommand,\n  shellQuote,\n} from \"@/node/runtime/backgroundCommands\";\nimport { execBuffered, writeFileString } from \"@/node/utils/runtime/helpers\";\nimport { NON_INTERACTIVE_ENV_VARS } from \"@/common/constants/env\";\nimport { toPosixPath } from \"@/node/utils/paths\";\n\n/**\n * Quote a path for shell commands.\n * On Windows, first converts to POSIX format, then shell-quotes.\n * On Unix, just shell-quotes (handles spaces, special chars).\n */\nfunction quotePathForShell(p: string): string {\n  const posixPath = toPosixPath(p);\n  return shellQuote(posixPath);\n}\n\n/**\n * Safe fallback cwd for runtime.exec() calls that don't need a specific workspace cwd.\n *\n * NOTE: Local runtimes validate that cwd exists before spawning, so this must be a real directory.\n */\nconst FALLBACK_CWD = process.platform === \"win32\" ? (process.env.TEMP ?? \"C:\\\\\") : \"/tmp\";\n\n/** Helper to extract error message for logging */\nfunction errorMsg(error: unknown): string {\n  return error instanceof Error ? error.message : String(error);\n}\n\n/** Subdirectory under temp for background process output */\nexport const BG_OUTPUT_SUBDIR = \"mux-bashes\";\n\n/** Output filename for combined stdout/stderr */\nexport const OUTPUT_FILENAME = \"output.log\";\n\n/** Exit code filename */\nexport const EXIT_CODE_FILENAME = \"exit_code\";\n\n/**\n * Compute paths for a background process output directory.\n * @param bgOutputDir Base directory (e.g., /tmp/mux-bashes or ~/.mux/sessions)\n * @param workspaceId Workspace identifier\n * @param processId Process identifier\n */\nexport function computeOutputPaths(\n  bgOutputDir: string,\n  workspaceId: string,\n  processId: string\n): { outputDir: string; outputPath: string; exitCodePath: string } {\n  const outputDir = `${bgOutputDir}/${workspaceId}/${processId}`;\n  return {\n    outputDir,\n    outputPath: `${outputDir}/${OUTPUT_FILENAME}`,\n    exitCodePath: `${outputDir}/${EXIT_CODE_FILENAME}`,\n  };\n}\n\n/**\n * Options for spawning a process\n */\nexport interface SpawnOptions {\n  /** Working directory for command execution */\n  cwd: string;\n  /** Workspace ID for output directory organization */\n  workspaceId: string;\n  /** Process ID (e.g., \"bash_1\") - generated by BackgroundProcessManager */\n  processId: string;\n  /** Environment variables to inject */\n  env?: Record<string, string>;\n}\n\n/**\n * Result of spawning a process\n */\nexport type SpawnResult =\n  | { success: true; handle: BackgroundHandle; pid: number; outputDir: string }\n  | { success: false; error: string };\n\n/**\n * Spawn a background process using runtime.exec (works for both local and SSH).\n *\n * All processes get the same infrastructure:\n * - nohup/setsid for process isolation\n * - stdout/stderr merged into single output.log with 2>&1\n * - Exit code captured via bash trap\n *\n * Uses runtime.tempDir() for output directory, making the code runtime-agnostic.\n *\n * @param runtime Runtime to spawn on\n * @param script Script to execute\n * @param options Spawn options\n */\nexport async function spawnProcess(\n  runtime: Runtime,\n  script: string,\n  options: SpawnOptions\n): Promise<SpawnResult> {\n  log.debug(`BackgroundProcessExecutor.spawnProcess: Spawning in ${options.cwd}`);\n\n  // Get temp directory from runtime (absolute path, runtime-agnostic)\n  const tempDir = await runtime.tempDir();\n  const bgOutputDir = `${tempDir}/${BG_OUTPUT_SUBDIR}`;\n\n  // Use shell-safe quoting for paths (handles spaces, special chars)\n  const quotePath = quotePathForShell;\n\n  // Verify working directory exists\n  const cwdCheck = await execBuffered(runtime, `cd ${quotePath(options.cwd)}`, {\n    cwd: FALLBACK_CWD,\n    timeout: 10,\n  });\n  if (cwdCheck.exitCode !== 0) {\n    return { success: false, error: `Working directory does not exist: ${options.cwd}` };\n  }\n\n  // Compute output paths (unified output.log instead of separate stdout/stderr)\n  const { outputDir, outputPath, exitCodePath } = computeOutputPaths(\n    bgOutputDir,\n    options.workspaceId,\n    options.processId\n  );\n\n  // Create output directory and empty file\n  try {\n    await runtime.ensureDir(outputDir);\n    await writeFileString(runtime, outputPath, \"\");\n  } catch (error) {\n    return {\n      success: false,\n      error: `Failed to create output directory: ${errorMsg(error)}`,\n    };\n  }\n\n  // Build wrapper script (same for all runtimes now that paths are absolute)\n  // Note: buildWrapperScript handles quoting internally via shellQuote\n  const wrapperScript = buildWrapperScript({\n    exitCodePath,\n    cwd: options.cwd,\n    env: { ...options.env, ...NON_INTERACTIVE_ENV_VARS },\n    script,\n  });\n\n  const spawnCommand = buildSpawnCommand({\n    wrapperScript,\n    outputPath,\n    quotePath,\n  });\n\n  try {\n    // No timeout - the spawn command backgrounds the process and returns immediately\n    const result = await execBuffered(runtime, spawnCommand, {\n      cwd: FALLBACK_CWD,\n    });\n\n    if (result.exitCode !== 0) {\n      log.debug(`BackgroundProcessExecutor.spawnProcess: spawn command failed: ${result.stderr}`);\n      return {\n        success: false,\n        error: `Failed to spawn background process: ${result.stderr}`,\n      };\n    }\n\n    const pid = parsePid(result.stdout);\n    if (!pid) {\n      log.debug(`BackgroundProcessExecutor.spawnProcess: Invalid PID: ${result.stdout}`);\n      return {\n        success: false,\n        error: `Failed to get valid PID from spawn: ${result.stdout}`,\n      };\n    }\n\n    log.debug(`BackgroundProcessExecutor.spawnProcess: Spawned with PID ${pid}`);\n    const handle = new RuntimeBackgroundHandle(runtime, pid, outputDir, quotePath);\n    return { success: true, handle, pid, outputDir };\n  } catch (error) {\n    const errorMessage = errorMsg(error);\n    log.debug(`BackgroundProcessExecutor.spawnProcess: Error: ${errorMessage}`);\n    return {\n      success: false,\n      error: `Failed to spawn background process: ${errorMessage}`,\n    };\n  }\n}\n\n/**\n * Unified handle to a background process.\n * Uses runtime.exec for all operations, working identically for local and SSH.\n *\n * Output files (output.log, exit_code) are on the runtime's filesystem.\n * This handle provides lifecycle management via execBuffered commands.\n */\nclass RuntimeBackgroundHandle implements BackgroundHandle {\n  private terminated = false;\n\n  constructor(\n    private readonly runtime: Runtime,\n    private readonly pid: number,\n    public readonly outputDir: string,\n    private readonly quotePath: (p: string) => string\n  ) {}\n\n  /**\n   * Get the exit code from the exit_code file.\n   * Returns null if process is still running (file doesn't exist yet).\n   */\n  async getExitCode(): Promise<number | null> {\n    try {\n      const exitCodePath = this.quotePath(`${this.outputDir}/${EXIT_CODE_FILENAME}`);\n      const result = await execBuffered(\n        this.runtime,\n        `cat ${exitCodePath} 2>/dev/null || echo \"\"`,\n        { cwd: FALLBACK_CWD, timeout: 10 }\n      );\n      return parseExitCode(result.stdout);\n    } catch (error) {\n      log.debug(`RuntimeBackgroundHandle.getExitCode: Error: ${errorMsg(error)}`);\n      return null;\n    }\n  }\n\n  /**\n   * Terminate the process group.\n   * Sends SIGTERM to process group, waits briefly, then SIGKILL if still running.\n   */\n  async terminate(): Promise<void> {\n    if (this.terminated) return;\n\n    try {\n      const exitCodePath = `${this.outputDir}/${EXIT_CODE_FILENAME}`;\n      const terminateCmd = buildTerminateCommand(this.pid, exitCodePath, this.quotePath);\n      await execBuffered(this.runtime, terminateCmd, {\n        cwd: FALLBACK_CWD,\n        timeout: 15,\n      });\n      log.debug(`RuntimeBackgroundHandle: Terminated process group ${this.pid}`);\n    } catch (error) {\n      // Process may already be dead - that's fine\n      log.debug(`RuntimeBackgroundHandle.terminate: Error: ${errorMsg(error)}`);\n    }\n\n    this.terminated = true;\n  }\n\n  /**\n   * Clean up resources.\n   * No resources to clean - process runs independently via nohup.\n   */\n  async dispose(): Promise<void> {\n    // No resources to clean up\n  }\n\n  /**\n   * Write meta.json to the output directory.\n   */\n  async writeMeta(metaJson: string): Promise<void> {\n    try {\n      const metaPath = this.quotePath(`${this.outputDir}/meta.json`);\n      await execBuffered(this.runtime, `cat > ${metaPath} << 'METAEOF'\\n${metaJson}\\nMETAEOF`, {\n        cwd: FALLBACK_CWD,\n        timeout: 10,\n      });\n    } catch (error) {\n      log.debug(`RuntimeBackgroundHandle.writeMeta: Error: ${errorMsg(error)}`);\n    }\n  }\n\n  async getOutputFileSize(): Promise<number> {\n    try {\n      const filePath = this.quotePath(`${this.outputDir}/${OUTPUT_FILENAME}`);\n      const sizeResult = await execBuffered(\n        this.runtime,\n        `wc -c < ${filePath} 2>/dev/null || echo 0`,\n        { cwd: FALLBACK_CWD, timeout: 10 }\n      );\n\n      return parseInt(sizeResult.stdout.trim(), 10) || 0;\n    } catch (error) {\n      log.debug(`RuntimeBackgroundHandle.getOutputFileSize: Error: ${errorMsg(error)}`);\n      return 0;\n    }\n  }\n\n  /**\n   * Read output from output.log at the given byte offset.\n   * Uses tail -c to read from offset - works on both Linux and macOS.\n   */\n  async readOutput(offset: number): Promise<{ content: string; newOffset: number }> {\n    try {\n      const filePath = this.quotePath(`${this.outputDir}/${OUTPUT_FILENAME}`);\n      const fileSize = await this.getOutputFileSize();\n\n      if (offset >= fileSize) {\n        return { content: \"\", newOffset: offset };\n      }\n\n      // Read from offset to end of file using tail -c (faster than dd bs=1)\n      // tail -c +N means \"start at byte N\" (1-indexed)\n      const readResult = await execBuffered(\n        this.runtime,\n        `tail -c +${offset + 1} ${filePath} 2>/dev/null`,\n        { cwd: FALLBACK_CWD, timeout: 30 }\n      );\n\n      return {\n        content: readResult.stdout,\n        newOffset: offset + Buffer.byteLength(readResult.stdout),\n      };\n    } catch (error) {\n      log.debug(`RuntimeBackgroundHandle.readOutput: Error: ${errorMsg(error)}`);\n      return { content: \"\", newOffset: offset };\n    }\n  }\n}\n\n/**\n * Options for migrating a foreground process to background\n */\nexport interface MigrateOptions {\n  /** Working directory (for display in meta.json) */\n  cwd: string;\n  /** Workspace ID */\n  workspaceId: string;\n  /** Process ID (e.g., \"bash_1\") - generated by BackgroundProcessManager */\n  processId: string;\n  /** Original script being executed */\n  script: string;\n  /** Output already captured while running in foreground */\n  existingOutput: string[];\n  /** Human-readable name for the process */\n  displayName?: string;\n}\n\n/**\n * Result of migrating a foreground process\n */\nexport type MigrateResult =\n  | { success: true; handle: BackgroundHandle; outputDir: string }\n  | { success: false; error: string };\n\n/**\n * Migrate a foreground process to background tracking.\n *\n * This is called when user clicks \"Background\" on a running foreground process.\n * The process continues running, but we:\n * 1. Create output directory and write existing output\n * 2. Continue consuming streams and writing to unified output.log\n * 3. Track exit code when process completes\n * 4. Return a BackgroundHandle for the manager to track\n *\n * Note: Output files are written locally (not via runtime), so this works\n * for SSH runtime where streams are already being piped to the local machine.\n *\n * @param execStream The running process's streams\n * @param options Migration options\n * @param bgOutputDir Base directory for output files\n */\nexport async function migrateToBackground(\n  execStream: ExecStream,\n  options: MigrateOptions,\n  bgOutputDir: string\n): Promise<MigrateResult> {\n  // Use shared path computation (path.join for local filesystem)\n  const { outputDir, outputPath } = computeOutputPaths(\n    bgOutputDir,\n    options.workspaceId,\n    options.processId\n  );\n\n  try {\n    // Create output directory\n    await fs.mkdir(outputDir, { recursive: true });\n\n    // Write existing output to unified output.log\n    await fs.writeFile(outputPath, options.existingOutput.join(\"\\n\") + \"\\n\");\n\n    // Create handle that will continue writing to file\n    const handle = new MigratedBackgroundHandle(execStream, outputDir, outputPath);\n\n    // Start consuming remaining output in background\n    handle.startConsuming();\n\n    return { success: true, handle, outputDir };\n  } catch (error) {\n    const errorMessage = errorMsg(error);\n    log.debug(`migrateToBackground: Error: ${errorMessage}`);\n    return { success: false, error: `Failed to migrate process: ${errorMessage}` };\n  }\n}\n\n/**\n * Handle for a migrated foreground process.\n *\n * Unlike RuntimeBackgroundHandle which uses runtime.exec for file operations,\n * this handle uses local filesystem directly because the streams are already\n * being piped to the local machine (even for SSH runtime).\n *\n * Both stdout and stderr are written to a unified output.log file.\n */\nclass MigratedBackgroundHandle implements BackgroundHandle {\n  private exitCodeValue: number | null = null;\n  private consuming = false;\n  private outputFd: fs.FileHandle | null = null;\n\n  constructor(\n    private readonly execStream: ExecStream,\n    public readonly outputDir: string,\n    private readonly outputPath: string\n  ) {}\n\n  /**\n   * Start consuming remaining output from streams and writing to unified file.\n   * Called after handle is created to begin background file writing.\n   */\n  startConsuming(): void {\n    if (this.consuming) return;\n    this.consuming = true;\n\n    // Open output file once, consume both streams to it\n    void this.consumeStreams();\n\n    // Track exit code\n    void this.execStream.exitCode.then((code) => {\n      this.exitCodeValue = code;\n      // Write exit code to file\n      void this.writeExitCode(code);\n    });\n  }\n\n  /**\n   * Consume both stdout and stderr streams and append to unified output file.\n   */\n  private async consumeStreams(): Promise<void> {\n    try {\n      this.outputFd = await fs.open(this.outputPath, \"a\");\n\n      // Consume both streams concurrently, both writing to same file\n      await Promise.all([\n        this.consumeStream(this.execStream.stdout),\n        this.consumeStream(this.execStream.stderr),\n      ]);\n    } catch (error) {\n      log.debug(`MigratedBackgroundHandle.consumeStreams: ${errorMsg(error)}`);\n    } finally {\n      if (this.outputFd) {\n        await this.outputFd.close();\n        this.outputFd = null;\n      }\n    }\n  }\n\n  /**\n   * Consume a stream and append to the shared output file.\n   */\n  private async consumeStream(stream: ReadableStream<Uint8Array>): Promise<void> {\n    try {\n      const reader = stream.getReader();\n\n      try {\n        while (true) {\n          const { value, done } = await reader.read();\n          if (done) break;\n          if (value && this.outputFd) {\n            await this.outputFd.write(value);\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    } catch (error) {\n      // Stream may have been cancelled or process killed - that's fine\n      log.debug(`MigratedBackgroundHandle.consumeStream: ${errorMsg(error)}`);\n    }\n  }\n\n  /**\n   * Write exit code to file.\n   */\n  private async writeExitCode(code: number): Promise<void> {\n    try {\n      const exitCodePath = path.join(this.outputDir, EXIT_CODE_FILENAME);\n      await fs.writeFile(exitCodePath, String(code));\n    } catch (error) {\n      log.debug(`MigratedBackgroundHandle.writeExitCode: ${errorMsg(error)}`);\n    }\n  }\n\n  getExitCode(): Promise<number | null> {\n    return Promise.resolve(this.exitCodeValue);\n  }\n\n  async terminate(): Promise<void> {\n    // ExecStream doesn't expose a kill method directly\n    // Cancel the streams to stop reading (process continues but we stop tracking)\n    try {\n      await this.execStream.stdout.cancel();\n      await this.execStream.stderr.cancel();\n    } catch {\n      // Streams may already be closed\n    }\n  }\n\n  async dispose(): Promise<void> {\n    // Close any open file handles\n    await this.outputFd?.close().catch(() => {\n      /* ignore */\n    });\n  }\n\n  async getOutputFileSize(): Promise<number> {\n    try {\n      const stat = await fs.stat(this.outputPath);\n      return stat.size;\n    } catch (error) {\n      log.debug(`MigratedBackgroundHandle.getOutputFileSize: ${errorMsg(error)}`);\n      return 0;\n    }\n  }\n\n  async writeMeta(metaJson: string): Promise<void> {\n    try {\n      const metaPath = path.join(this.outputDir, \"meta.json\");\n      await fs.writeFile(metaPath, metaJson);\n    } catch (error) {\n      log.debug(`MigratedBackgroundHandle.writeMeta: ${errorMsg(error)}`);\n    }\n  }\n\n  async readOutput(offset: number): Promise<{ content: string; newOffset: number }> {\n    try {\n      const fileSize = await this.getOutputFileSize();\n\n      if (offset >= fileSize) {\n        return { content: \"\", newOffset: offset };\n      }\n\n      // Read from offset to end\n      const fd = await fs.open(this.outputPath, \"r\");\n      try {\n        const buffer = Buffer.alloc(fileSize - offset);\n        const { bytesRead } = await fd.read(buffer, 0, buffer.length, offset);\n        return {\n          content: buffer.slice(0, bytesRead).toString(\"utf-8\"),\n          newOffset: offset + bytesRead,\n        };\n      } finally {\n        await fd.close();\n      }\n    } catch (error) {\n      log.debug(`MigratedBackgroundHandle.readOutput: ${errorMsg(error)}`);\n      return { content: \"\", newOffset: offset };\n    }\n  }\n}\n"]}