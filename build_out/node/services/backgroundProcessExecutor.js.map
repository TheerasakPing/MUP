{"version":3,"file":"backgroundProcessExecutor.js","sourceRoot":"","sources":["../../../src/node/services/backgroundProcessExecutor.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGH,MAAY,EAAE,wCAAoB;AAClC,MAAY,IAAI,iCAAa;AAC7B,+BAA4B;AAC5B,0EAO2C;AAC3C,0DAA6E;AAC7E,gDAAkE;AAClE,8CAAiD;AAEjD;;;;GAIG;AACH,SAAS,iBAAiB,CAAC,CAAS,EAAU;IAC5C,MAAM,SAAS,GAAG,IAAA,mBAAW,EAAC,CAAC,CAAC,CAAC;IACjC,OAAO,IAAA,+BAAU,EAAC,SAAS,CAAC,CAAC;AAAA,CAC9B;AAED;;;;GAIG;AACH,MAAM,YAAY,GAAG,OAAO,CAAC,QAAQ,KAAK,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;AAE1F,kDAAkD;AAClD,SAAS,QAAQ,CAAC,KAAc,EAAU;IACxC,OAAO,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AAAA,CAC/D;AAED,4DAA4D;AAC/C,QAAA,gBAAgB,GAAG,YAAY,CAAC;AAE7C,iDAAiD;AACpC,QAAA,eAAe,GAAG,YAAY,CAAC;AAE5C,yBAAyB;AACZ,QAAA,kBAAkB,GAAG,WAAW,CAAC;AAE9C;;;;;GAKG;AACH,4BACE,WAAmB,EACnB,WAAmB,EACnB,SAAiB,EACgD;IACjE,MAAM,SAAS,GAAG,GAAG,WAAW,IAAI,WAAW,IAAI,SAAS,EAAE,CAAC;IAC/D,OAAO;QACL,SAAS;QACT,UAAU,EAAE,GAAG,SAAS,IAAI,QAAA,eAAe,EAAE;QAC7C,YAAY,EAAE,GAAG,SAAS,IAAI,QAAA,kBAAkB,EAAE;KACnD,CAAC;AAAA,CACH;AAuBD;;;;;;;;;;;;;GAaG;AACI,KAAK,uBACV,OAAgB,EAChB,MAAc,EACd,OAAqB,EACC;IACtB,SAAG,CAAC,KAAK,CAAC,uDAAuD,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;IAEhF,oEAAoE;IACpE,MAAM,OAAO,GAAG,MAAM,OAAO,CAAC,OAAO,EAAE,CAAC;IACxC,MAAM,WAAW,GAAG,GAAG,OAAO,IAAI,QAAA,gBAAgB,EAAE,CAAC;IAErD,mEAAmE;IACnE,MAAM,SAAS,GAAG,iBAAiB,CAAC;IAEpC,kCAAkC;IAClC,MAAM,QAAQ,GAAG,MAAM,IAAA,sBAAY,EAAC,OAAO,EAAE,MAAM,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,EAAE;QAC3E,GAAG,EAAE,YAAY;QACjB,OAAO,EAAE,EAAE;KACZ,CAAC,CAAC;IACH,IAAI,QAAQ,CAAC,QAAQ,KAAK,CAAC,EAAE,CAAC;QAC5B,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,qCAAqC,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC;IACvF,CAAC;IAED,8EAA8E;IAC9E,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,YAAY,EAAE,GAAG,kBAAkB,CAChE,WAAW,EACX,OAAO,CAAC,WAAW,EACnB,OAAO,CAAC,SAAS,CAClB,CAAC;IAEF,yCAAyC;IACzC,IAAI,CAAC;QACH,MAAM,OAAO,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;QACnC,MAAM,IAAA,yBAAe,EAAC,OAAO,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC;IACjD,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,OAAO;YACL,OAAO,EAAE,KAAK;YACd,KAAK,EAAE,sCAAsC,QAAQ,CAAC,KAAK,CAAC,EAAE;SAC/D,CAAC;IACJ,CAAC;IAED,2EAA2E;IAC3E,qEAAqE;IACrE,MAAM,aAAa,GAAG,IAAA,uCAAkB,EAAC;QACvC,YAAY;QACZ,GAAG,EAAE,OAAO,CAAC,GAAG;QAChB,GAAG,EAAE,EAAE,GAAG,OAAO,CAAC,GAAG,EAAE,GAAG,8BAAwB,EAAE;QACpD,MAAM;KACP,CAAC,CAAC;IAEH,MAAM,YAAY,GAAG,IAAA,sCAAiB,EAAC;QACrC,aAAa;QACb,UAAU;QACV,SAAS;KACV,CAAC,CAAC;IAEH,IAAI,CAAC;QACH,iFAAiF;QACjF,MAAM,MAAM,GAAG,MAAM,IAAA,sBAAY,EAAC,OAAO,EAAE,YAAY,EAAE;YACvD,GAAG,EAAE,YAAY;SAClB,CAAC,CAAC;QAEH,IAAI,MAAM,CAAC,QAAQ,KAAK,CAAC,EAAE,CAAC;YAC1B,SAAG,CAAC,KAAK,CAAC,iEAAiE,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;YAC5F,OAAO;gBACL,OAAO,EAAE,KAAK;gBACd,KAAK,EAAE,uCAAuC,MAAM,CAAC,MAAM,EAAE;aAC9D,CAAC;QACJ,CAAC;QAED,MAAM,GAAG,GAAG,IAAA,6BAAQ,EAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACpC,IAAI,CAAC,GAAG,EAAE,CAAC;YACT,SAAG,CAAC,KAAK,CAAC,wDAAwD,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;YACnF,OAAO;gBACL,OAAO,EAAE,KAAK;gBACd,KAAK,EAAE,uCAAuC,MAAM,CAAC,MAAM,EAAE;aAC9D,CAAC;QACJ,CAAC;QAED,SAAG,CAAC,KAAK,CAAC,4DAA4D,GAAG,EAAE,CAAC,CAAC;QAC7E,MAAM,MAAM,GAAG,IAAI,uBAAuB,CAAC,OAAO,EAAE,GAAG,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;QAC/E,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,EAAE,SAAS,EAAE,CAAC;IACnD,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,MAAM,YAAY,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;QACrC,SAAG,CAAC,KAAK,CAAC,kDAAkD,YAAY,EAAE,CAAC,CAAC;QAC5E,OAAO;YACL,OAAO,EAAE,KAAK;YACd,KAAK,EAAE,uCAAuC,YAAY,EAAE;SAC7D,CAAC;IACJ,CAAC;AAAA,CACF;AAED;;;;;;GAMG;AACH,MAAM,uBAAuB;IAIR,OAAO;IACP,GAAG;IACJ,SAAS;IACR,SAAS;IANpB,UAAU,GAAG,KAAK,CAAC;IAE3B,YACmB,OAAgB,EAChB,GAAW,EACZ,SAAiB,EAChB,SAAgC,EACjD;uBAJiB,OAAO;mBACP,GAAG;yBACJ,SAAS;yBACR,SAAS;IACzB,CAAC;IAEJ;;;OAGG;IACH,KAAK,CAAC,WAAW,GAA2B;QAC1C,IAAI,CAAC;YACH,MAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,SAAS,IAAI,QAAA,kBAAkB,EAAE,CAAC,CAAC;YAC/E,MAAM,MAAM,GAAG,MAAM,IAAA,sBAAY,EAC/B,IAAI,CAAC,OAAO,EACZ,OAAO,YAAY,yBAAyB,EAC5C,EAAE,GAAG,EAAE,YAAY,EAAE,OAAO,EAAE,EAAE,EAAE,CACnC,CAAC;YACF,OAAO,IAAA,kCAAa,EAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACtC,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,SAAG,CAAC,KAAK,CAAC,+CAA+C,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YAC5E,OAAO,IAAI,CAAC;QACd,CAAC;IAAA,CACF;IAED;;;OAGG;IACH,KAAK,CAAC,SAAS,GAAkB;QAC/B,IAAI,IAAI,CAAC,UAAU;YAAE,OAAO;QAE5B,IAAI,CAAC;YACH,MAAM,YAAY,GAAG,GAAG,IAAI,CAAC,SAAS,IAAI,QAAA,kBAAkB,EAAE,CAAC;YAC/D,MAAM,YAAY,GAAG,IAAA,0CAAqB,EAAC,IAAI,CAAC,GAAG,EAAE,YAAY,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;YACnF,MAAM,IAAA,sBAAY,EAAC,IAAI,CAAC,OAAO,EAAE,YAAY,EAAE;gBAC7C,GAAG,EAAE,YAAY;gBACjB,OAAO,EAAE,EAAE;aACZ,CAAC,CAAC;YACH,SAAG,CAAC,KAAK,CAAC,qDAAqD,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;QAC7E,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,4CAA4C;YAC5C,SAAG,CAAC,KAAK,CAAC,6CAA6C,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QAC5E,CAAC;QAED,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;IAAA,CACxB;IAED;;;OAGG;IACH,KAAK,CAAC,OAAO,GAAkB;QAC7B,2BAA2B;IADG,CAE/B;IAED;;OAEG;IACH,KAAK,CAAC,SAAS,CAAC,QAAgB,EAAiB;QAC/C,IAAI,CAAC;YACH,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,SAAS,YAAY,CAAC,CAAC;YAC/D,MAAM,IAAA,sBAAY,EAAC,IAAI,CAAC,OAAO,EAAE,SAAS,QAAQ,kBAAkB,QAAQ,WAAW,EAAE;gBACvF,GAAG,EAAE,YAAY;gBACjB,OAAO,EAAE,EAAE;aACZ,CAAC,CAAC;QACL,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,SAAG,CAAC,KAAK,CAAC,6CAA6C,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QAC5E,CAAC;IAAA,CACF;IAED,KAAK,CAAC,iBAAiB,GAAoB;QACzC,IAAI,CAAC;YACH,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,SAAS,IAAI,QAAA,eAAe,EAAE,CAAC,CAAC;YACxE,MAAM,UAAU,GAAG,MAAM,IAAA,sBAAY,EACnC,IAAI,CAAC,OAAO,EACZ,WAAW,QAAQ,wBAAwB,EAC3C,EAAE,GAAG,EAAE,YAAY,EAAE,OAAO,EAAE,EAAE,EAAE,CACnC,CAAC;YAEF,OAAO,QAAQ,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC;QACrD,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,SAAG,CAAC,KAAK,CAAC,qDAAqD,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YAClF,OAAO,CAAC,CAAC;QACX,CAAC;IAAA,CACF;IAED;;;OAGG;IACH,KAAK,CAAC,UAAU,CAAC,MAAc,EAAmD;QAChF,IAAI,CAAC;YACH,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,SAAS,IAAI,QAAA,eAAe,EAAE,CAAC,CAAC;YACxE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAEhD,IAAI,MAAM,IAAI,QAAQ,EAAE,CAAC;gBACvB,OAAO,EAAE,OAAO,EAAE,EAAE,EAAE,SAAS,EAAE,MAAM,EAAE,CAAC;YAC5C,CAAC;YAED,sEAAsE;YACtE,iDAAiD;YACjD,MAAM,UAAU,GAAG,MAAM,IAAA,sBAAY,EACnC,IAAI,CAAC,OAAO,EACZ,YAAY,MAAM,GAAG,CAAC,IAAI,QAAQ,cAAc,EAChD,EAAE,GAAG,EAAE,YAAY,EAAE,OAAO,EAAE,EAAE,EAAE,CACnC,CAAC;YAEF,OAAO;gBACL,OAAO,EAAE,UAAU,CAAC,MAAM;gBAC1B,SAAS,EAAE,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,UAAU,CAAC,MAAM,CAAC;aACzD,CAAC;QACJ,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,SAAG,CAAC,KAAK,CAAC,8CAA8C,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YAC3E,OAAO,EAAE,OAAO,EAAE,EAAE,EAAE,SAAS,EAAE,MAAM,EAAE,CAAC;QAC5C,CAAC;IAAA,CACF;CACF;AA2BD;;;;;;;;;;;;;;;;GAgBG;AACI,KAAK,8BACV,UAAsB,EACtB,OAAuB,EACvB,WAAmB,EACK;IACxB,+DAA+D;IAC/D,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,GAAG,kBAAkB,CAClD,WAAW,EACX,OAAO,CAAC,WAAW,EACnB,OAAO,CAAC,SAAS,CAClB,CAAC;IAEF,IAAI,CAAC;QACH,0BAA0B;QAC1B,MAAM,EAAE,CAAC,KAAK,CAAC,SAAS,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;QAE/C,8CAA8C;QAC9C,MAAM,EAAE,CAAC,SAAS,CAAC,UAAU,EAAE,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;QAEzE,mDAAmD;QACnD,MAAM,MAAM,GAAG,IAAI,wBAAwB,CAAC,UAAU,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;QAE/E,iDAAiD;QACjD,MAAM,CAAC,cAAc,EAAE,CAAC;QAExB,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,SAAS,EAAE,CAAC;IAC9C,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,MAAM,YAAY,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;QACrC,SAAG,CAAC,KAAK,CAAC,+BAA+B,YAAY,EAAE,CAAC,CAAC;QACzD,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,8BAA8B,YAAY,EAAE,EAAE,CAAC;IACjF,CAAC;AAAA,CACF;AAED;;;;;;;;GAQG;AACH,MAAM,wBAAwB;IAMT,UAAU;IACX,SAAS;IACR,UAAU;IAPrB,aAAa,GAAkB,IAAI,CAAC;IACpC,SAAS,GAAG,KAAK,CAAC;IAClB,QAAQ,GAAyB,IAAI,CAAC;IAE9C,YACmB,UAAsB,EACvB,SAAiB,EAChB,UAAkB,EACnC;0BAHiB,UAAU;yBACX,SAAS;0BACR,UAAU;IAC1B,CAAC;IAEJ;;;OAGG;IACH,cAAc,GAAS;QACrB,IAAI,IAAI,CAAC,SAAS;YAAE,OAAO;QAC3B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QAEtB,oDAAoD;QACpD,KAAK,IAAI,CAAC,cAAc,EAAE,CAAC;QAE3B,kBAAkB;QAClB,KAAK,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC;YAC3C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;YAC1B,0BAA0B;YAC1B,KAAK,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAAA,CAC/B,CAAC,CAAC;IAAA,CACJ;IAED;;OAEG;IACK,KAAK,CAAC,cAAc,GAAkB;QAC5C,IAAI,CAAC;YACH,IAAI,CAAC,QAAQ,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;YAEpD,+DAA+D;YAC/D,MAAM,OAAO,CAAC,GAAG,CAAC;gBAChB,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC;gBAC1C,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC;aAC3C,CAAC,CAAC;QACL,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,SAAG,CAAC,KAAK,CAAC,4CAA4C,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QAC3E,CAAC;gBAAS,CAAC;YACT,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAClB,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;gBAC5B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YACvB,CAAC;QACH,CAAC;IAAA,CACF;IAED;;OAEG;IACK,KAAK,CAAC,aAAa,CAAC,MAAkC,EAAiB;QAC7E,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;YAElC,IAAI,CAAC;gBACH,OAAO,IAAI,EAAE,CAAC;oBACZ,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,MAAM,MAAM,CAAC,IAAI,EAAE,CAAC;oBAC5C,IAAI,IAAI;wBAAE,MAAM;oBAChB,IAAI,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;wBAC3B,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;oBACnC,CAAC;gBACH,CAAC;YACH,CAAC;oBAAS,CAAC;gBACT,MAAM,CAAC,WAAW,EAAE,CAAC;YACvB,CAAC;QACH,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,iEAAiE;YACjE,SAAG,CAAC,KAAK,CAAC,2CAA2C,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QAC1E,CAAC;IAAA,CACF;IAED;;OAEG;IACK,KAAK,CAAC,aAAa,CAAC,IAAY,EAAiB;QACvD,IAAI,CAAC;YACH,MAAM,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,QAAA,kBAAkB,CAAC,CAAC;YACnE,MAAM,EAAE,CAAC,SAAS,CAAC,YAAY,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;QACjD,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,SAAG,CAAC,KAAK,CAAC,2CAA2C,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QAC1E,CAAC;IAAA,CACF;IAED,WAAW,GAA2B;QACpC,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;IAAA,CAC5C;IAED,KAAK,CAAC,SAAS,GAAkB;QAC/B,mDAAmD;QACnD,8EAA8E;QAC9E,IAAI,CAAC;YACH,MAAM,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;YACtC,MAAM,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;QACxC,CAAC;QAAC,MAAM,CAAC;YACP,gCAAgC;QAClC,CAAC;IAAA,CACF;IAED,KAAK,CAAC,OAAO,GAAkB;QAC7B,8BAA8B;QAC9B,MAAM,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;YACvC,YAAY;QAD4B,CAEzC,CAAC,CAAC;IAAA,CACJ;IAED,KAAK,CAAC,iBAAiB,GAAoB;QACzC,IAAI,CAAC;YACH,MAAM,IAAI,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAC5C,OAAO,IAAI,CAAC,IAAI,CAAC;QACnB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,SAAG,CAAC,KAAK,CAAC,+CAA+C,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YAC5E,OAAO,CAAC,CAAC;QACX,CAAC;IAAA,CACF;IAED,KAAK,CAAC,SAAS,CAAC,QAAgB,EAAiB;QAC/C,IAAI,CAAC;YACH,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;YACxD,MAAM,EAAE,CAAC,SAAS,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACzC,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,SAAG,CAAC,KAAK,CAAC,uCAAuC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QACtE,CAAC;IAAA,CACF;IAED,KAAK,CAAC,UAAU,CAAC,MAAc,EAAmD;QAChF,IAAI,CAAC;YACH,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAEhD,IAAI,MAAM,IAAI,QAAQ,EAAE,CAAC;gBACvB,OAAO,EAAE,OAAO,EAAE,EAAE,EAAE,SAAS,EAAE,MAAM,EAAE,CAAC;YAC5C,CAAC;YAED,0BAA0B;YAC1B,MAAM,EAAE,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;YAC/C,IAAI,CAAC;gBACH,MAAM,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,QAAQ,GAAG,MAAM,CAAC,CAAC;gBAC/C,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;gBACtE,OAAO;oBACL,OAAO,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC;oBACrD,SAAS,EAAE,MAAM,GAAG,SAAS;iBAC9B,CAAC;YACJ,CAAC;oBAAS,CAAC;gBACT,MAAM,EAAE,CAAC,KAAK,EAAE,CAAC;YACnB,CAAC;QACH,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,SAAG,CAAC,KAAK,CAAC,wCAAwC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YACrE,OAAO,EAAE,OAAO,EAAE,EAAE,EAAE,SAAS,EAAE,MAAM,EAAE,CAAC;QAC5C,CAAC;IAAA,CACF;CACF","sourcesContent":["/**\r\n * Unified executor for background bash processes.\r\n *\r\n * ALL bash commands are spawned through this executor with background-style\r\n * infrastructure (nohup, file output, exit code trap). This enables:\r\n *\r\n * 1. Uniform code path - one spawn mechanism for all bash commands\r\n * 2. Crash resilience - output always persisted to files\r\n * 3. Seamless fgâ†’bg transition - \"background this\" = \"stop waiting\"\r\n *\r\n * Uses runtime.tempDir() for runtime-agnostic temp directory resolution.\r\n * Works identically for local and SSH runtimes.\r\n */\r\n\r\nimport type { Runtime, BackgroundHandle, ExecStream } from \"@/node/runtime/Runtime\";\r\nimport * as fs from \"fs/promises\";\r\nimport * as path from \"path\";\r\nimport { log } from \"./log\";\r\nimport {\r\n  buildWrapperScript,\r\n  buildSpawnCommand,\r\n  parsePid,\r\n  parseExitCode,\r\n  buildTerminateCommand,\r\n  shellQuote,\r\n} from \"@/node/runtime/backgroundCommands\";\r\nimport { execBuffered, writeFileString } from \"@/node/utils/runtime/helpers\";\r\nimport { NON_INTERACTIVE_ENV_VARS } from \"@/common/constants/env\";\r\nimport { toPosixPath } from \"@/node/utils/paths\";\r\n\r\n/**\r\n * Quote a path for shell commands.\r\n * On Windows, first converts to POSIX format, then shell-quotes.\r\n * On Unix, just shell-quotes (handles spaces, special chars).\r\n */\r\nfunction quotePathForShell(p: string): string {\r\n  const posixPath = toPosixPath(p);\r\n  return shellQuote(posixPath);\r\n}\r\n\r\n/**\r\n * Safe fallback cwd for runtime.exec() calls that don't need a specific workspace cwd.\r\n *\r\n * NOTE: Local runtimes validate that cwd exists before spawning, so this must be a real directory.\r\n */\r\nconst FALLBACK_CWD = process.platform === \"win32\" ? (process.env.TEMP ?? \"C:\\\\\") : \"/tmp\";\r\n\r\n/** Helper to extract error message for logging */\r\nfunction errorMsg(error: unknown): string {\r\n  return error instanceof Error ? error.message : String(error);\r\n}\r\n\r\n/** Subdirectory under temp for background process output */\r\nexport const BG_OUTPUT_SUBDIR = \"mux-bashes\";\r\n\r\n/** Output filename for combined stdout/stderr */\r\nexport const OUTPUT_FILENAME = \"output.log\";\r\n\r\n/** Exit code filename */\r\nexport const EXIT_CODE_FILENAME = \"exit_code\";\r\n\r\n/**\r\n * Compute paths for a background process output directory.\r\n * @param bgOutputDir Base directory (e.g., /tmp/mux-bashes or ~/.mux/sessions)\r\n * @param workspaceId Workspace identifier\r\n * @param processId Process identifier\r\n */\r\nexport function computeOutputPaths(\r\n  bgOutputDir: string,\r\n  workspaceId: string,\r\n  processId: string\r\n): { outputDir: string; outputPath: string; exitCodePath: string } {\r\n  const outputDir = `${bgOutputDir}/${workspaceId}/${processId}`;\r\n  return {\r\n    outputDir,\r\n    outputPath: `${outputDir}/${OUTPUT_FILENAME}`,\r\n    exitCodePath: `${outputDir}/${EXIT_CODE_FILENAME}`,\r\n  };\r\n}\r\n\r\n/**\r\n * Options for spawning a process\r\n */\r\nexport interface SpawnOptions {\r\n  /** Working directory for command execution */\r\n  cwd: string;\r\n  /** Workspace ID for output directory organization */\r\n  workspaceId: string;\r\n  /** Process ID (e.g., \"bash_1\") - generated by BackgroundProcessManager */\r\n  processId: string;\r\n  /** Environment variables to inject */\r\n  env?: Record<string, string>;\r\n}\r\n\r\n/**\r\n * Result of spawning a process\r\n */\r\nexport type SpawnResult =\r\n  | { success: true; handle: BackgroundHandle; pid: number; outputDir: string }\r\n  | { success: false; error: string };\r\n\r\n/**\r\n * Spawn a background process using runtime.exec (works for both local and SSH).\r\n *\r\n * All processes get the same infrastructure:\r\n * - nohup/setsid for process isolation\r\n * - stdout/stderr merged into single output.log with 2>&1\r\n * - Exit code captured via bash trap\r\n *\r\n * Uses runtime.tempDir() for output directory, making the code runtime-agnostic.\r\n *\r\n * @param runtime Runtime to spawn on\r\n * @param script Script to execute\r\n * @param options Spawn options\r\n */\r\nexport async function spawnProcess(\r\n  runtime: Runtime,\r\n  script: string,\r\n  options: SpawnOptions\r\n): Promise<SpawnResult> {\r\n  log.debug(`BackgroundProcessExecutor.spawnProcess: Spawning in ${options.cwd}`);\r\n\r\n  // Get temp directory from runtime (absolute path, runtime-agnostic)\r\n  const tempDir = await runtime.tempDir();\r\n  const bgOutputDir = `${tempDir}/${BG_OUTPUT_SUBDIR}`;\r\n\r\n  // Use shell-safe quoting for paths (handles spaces, special chars)\r\n  const quotePath = quotePathForShell;\r\n\r\n  // Verify working directory exists\r\n  const cwdCheck = await execBuffered(runtime, `cd ${quotePath(options.cwd)}`, {\r\n    cwd: FALLBACK_CWD,\r\n    timeout: 10,\r\n  });\r\n  if (cwdCheck.exitCode !== 0) {\r\n    return { success: false, error: `Working directory does not exist: ${options.cwd}` };\r\n  }\r\n\r\n  // Compute output paths (unified output.log instead of separate stdout/stderr)\r\n  const { outputDir, outputPath, exitCodePath } = computeOutputPaths(\r\n    bgOutputDir,\r\n    options.workspaceId,\r\n    options.processId\r\n  );\r\n\r\n  // Create output directory and empty file\r\n  try {\r\n    await runtime.ensureDir(outputDir);\r\n    await writeFileString(runtime, outputPath, \"\");\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: `Failed to create output directory: ${errorMsg(error)}`,\r\n    };\r\n  }\r\n\r\n  // Build wrapper script (same for all runtimes now that paths are absolute)\r\n  // Note: buildWrapperScript handles quoting internally via shellQuote\r\n  const wrapperScript = buildWrapperScript({\r\n    exitCodePath,\r\n    cwd: options.cwd,\r\n    env: { ...options.env, ...NON_INTERACTIVE_ENV_VARS },\r\n    script,\r\n  });\r\n\r\n  const spawnCommand = buildSpawnCommand({\r\n    wrapperScript,\r\n    outputPath,\r\n    quotePath,\r\n  });\r\n\r\n  try {\r\n    // No timeout - the spawn command backgrounds the process and returns immediately\r\n    const result = await execBuffered(runtime, spawnCommand, {\r\n      cwd: FALLBACK_CWD,\r\n    });\r\n\r\n    if (result.exitCode !== 0) {\r\n      log.debug(`BackgroundProcessExecutor.spawnProcess: spawn command failed: ${result.stderr}`);\r\n      return {\r\n        success: false,\r\n        error: `Failed to spawn background process: ${result.stderr}`,\r\n      };\r\n    }\r\n\r\n    const pid = parsePid(result.stdout);\r\n    if (!pid) {\r\n      log.debug(`BackgroundProcessExecutor.spawnProcess: Invalid PID: ${result.stdout}`);\r\n      return {\r\n        success: false,\r\n        error: `Failed to get valid PID from spawn: ${result.stdout}`,\r\n      };\r\n    }\r\n\r\n    log.debug(`BackgroundProcessExecutor.spawnProcess: Spawned with PID ${pid}`);\r\n    const handle = new RuntimeBackgroundHandle(runtime, pid, outputDir, quotePath);\r\n    return { success: true, handle, pid, outputDir };\r\n  } catch (error) {\r\n    const errorMessage = errorMsg(error);\r\n    log.debug(`BackgroundProcessExecutor.spawnProcess: Error: ${errorMessage}`);\r\n    return {\r\n      success: false,\r\n      error: `Failed to spawn background process: ${errorMessage}`,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Unified handle to a background process.\r\n * Uses runtime.exec for all operations, working identically for local and SSH.\r\n *\r\n * Output files (output.log, exit_code) are on the runtime's filesystem.\r\n * This handle provides lifecycle management via execBuffered commands.\r\n */\r\nclass RuntimeBackgroundHandle implements BackgroundHandle {\r\n  private terminated = false;\r\n\r\n  constructor(\r\n    private readonly runtime: Runtime,\r\n    private readonly pid: number,\r\n    public readonly outputDir: string,\r\n    private readonly quotePath: (p: string) => string\r\n  ) {}\r\n\r\n  /**\r\n   * Get the exit code from the exit_code file.\r\n   * Returns null if process is still running (file doesn't exist yet).\r\n   */\r\n  async getExitCode(): Promise<number | null> {\r\n    try {\r\n      const exitCodePath = this.quotePath(`${this.outputDir}/${EXIT_CODE_FILENAME}`);\r\n      const result = await execBuffered(\r\n        this.runtime,\r\n        `cat ${exitCodePath} 2>/dev/null || echo \"\"`,\r\n        { cwd: FALLBACK_CWD, timeout: 10 }\r\n      );\r\n      return parseExitCode(result.stdout);\r\n    } catch (error) {\r\n      log.debug(`RuntimeBackgroundHandle.getExitCode: Error: ${errorMsg(error)}`);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Terminate the process group.\r\n   * Sends SIGTERM to process group, waits briefly, then SIGKILL if still running.\r\n   */\r\n  async terminate(): Promise<void> {\r\n    if (this.terminated) return;\r\n\r\n    try {\r\n      const exitCodePath = `${this.outputDir}/${EXIT_CODE_FILENAME}`;\r\n      const terminateCmd = buildTerminateCommand(this.pid, exitCodePath, this.quotePath);\r\n      await execBuffered(this.runtime, terminateCmd, {\r\n        cwd: FALLBACK_CWD,\r\n        timeout: 15,\r\n      });\r\n      log.debug(`RuntimeBackgroundHandle: Terminated process group ${this.pid}`);\r\n    } catch (error) {\r\n      // Process may already be dead - that's fine\r\n      log.debug(`RuntimeBackgroundHandle.terminate: Error: ${errorMsg(error)}`);\r\n    }\r\n\r\n    this.terminated = true;\r\n  }\r\n\r\n  /**\r\n   * Clean up resources.\r\n   * No resources to clean - process runs independently via nohup.\r\n   */\r\n  async dispose(): Promise<void> {\r\n    // No resources to clean up\r\n  }\r\n\r\n  /**\r\n   * Write meta.json to the output directory.\r\n   */\r\n  async writeMeta(metaJson: string): Promise<void> {\r\n    try {\r\n      const metaPath = this.quotePath(`${this.outputDir}/meta.json`);\r\n      await execBuffered(this.runtime, `cat > ${metaPath} << 'METAEOF'\\n${metaJson}\\nMETAEOF`, {\r\n        cwd: FALLBACK_CWD,\r\n        timeout: 10,\r\n      });\r\n    } catch (error) {\r\n      log.debug(`RuntimeBackgroundHandle.writeMeta: Error: ${errorMsg(error)}`);\r\n    }\r\n  }\r\n\r\n  async getOutputFileSize(): Promise<number> {\r\n    try {\r\n      const filePath = this.quotePath(`${this.outputDir}/${OUTPUT_FILENAME}`);\r\n      const sizeResult = await execBuffered(\r\n        this.runtime,\r\n        `wc -c < ${filePath} 2>/dev/null || echo 0`,\r\n        { cwd: FALLBACK_CWD, timeout: 10 }\r\n      );\r\n\r\n      return parseInt(sizeResult.stdout.trim(), 10) || 0;\r\n    } catch (error) {\r\n      log.debug(`RuntimeBackgroundHandle.getOutputFileSize: Error: ${errorMsg(error)}`);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read output from output.log at the given byte offset.\r\n   * Uses tail -c to read from offset - works on both Linux and macOS.\r\n   */\r\n  async readOutput(offset: number): Promise<{ content: string; newOffset: number }> {\r\n    try {\r\n      const filePath = this.quotePath(`${this.outputDir}/${OUTPUT_FILENAME}`);\r\n      const fileSize = await this.getOutputFileSize();\r\n\r\n      if (offset >= fileSize) {\r\n        return { content: \"\", newOffset: offset };\r\n      }\r\n\r\n      // Read from offset to end of file using tail -c (faster than dd bs=1)\r\n      // tail -c +N means \"start at byte N\" (1-indexed)\r\n      const readResult = await execBuffered(\r\n        this.runtime,\r\n        `tail -c +${offset + 1} ${filePath} 2>/dev/null`,\r\n        { cwd: FALLBACK_CWD, timeout: 30 }\r\n      );\r\n\r\n      return {\r\n        content: readResult.stdout,\r\n        newOffset: offset + Buffer.byteLength(readResult.stdout),\r\n      };\r\n    } catch (error) {\r\n      log.debug(`RuntimeBackgroundHandle.readOutput: Error: ${errorMsg(error)}`);\r\n      return { content: \"\", newOffset: offset };\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Options for migrating a foreground process to background\r\n */\r\nexport interface MigrateOptions {\r\n  /** Working directory (for display in meta.json) */\r\n  cwd: string;\r\n  /** Workspace ID */\r\n  workspaceId: string;\r\n  /** Process ID (e.g., \"bash_1\") - generated by BackgroundProcessManager */\r\n  processId: string;\r\n  /** Original script being executed */\r\n  script: string;\r\n  /** Output already captured while running in foreground */\r\n  existingOutput: string[];\r\n  /** Human-readable name for the process */\r\n  displayName?: string;\r\n}\r\n\r\n/**\r\n * Result of migrating a foreground process\r\n */\r\nexport type MigrateResult =\r\n  | { success: true; handle: BackgroundHandle; outputDir: string }\r\n  | { success: false; error: string };\r\n\r\n/**\r\n * Migrate a foreground process to background tracking.\r\n *\r\n * This is called when user clicks \"Background\" on a running foreground process.\r\n * The process continues running, but we:\r\n * 1. Create output directory and write existing output\r\n * 2. Continue consuming streams and writing to unified output.log\r\n * 3. Track exit code when process completes\r\n * 4. Return a BackgroundHandle for the manager to track\r\n *\r\n * Note: Output files are written locally (not via runtime), so this works\r\n * for SSH runtime where streams are already being piped to the local machine.\r\n *\r\n * @param execStream The running process's streams\r\n * @param options Migration options\r\n * @param bgOutputDir Base directory for output files\r\n */\r\nexport async function migrateToBackground(\r\n  execStream: ExecStream,\r\n  options: MigrateOptions,\r\n  bgOutputDir: string\r\n): Promise<MigrateResult> {\r\n  // Use shared path computation (path.join for local filesystem)\r\n  const { outputDir, outputPath } = computeOutputPaths(\r\n    bgOutputDir,\r\n    options.workspaceId,\r\n    options.processId\r\n  );\r\n\r\n  try {\r\n    // Create output directory\r\n    await fs.mkdir(outputDir, { recursive: true });\r\n\r\n    // Write existing output to unified output.log\r\n    await fs.writeFile(outputPath, options.existingOutput.join(\"\\n\") + \"\\n\");\r\n\r\n    // Create handle that will continue writing to file\r\n    const handle = new MigratedBackgroundHandle(execStream, outputDir, outputPath);\r\n\r\n    // Start consuming remaining output in background\r\n    handle.startConsuming();\r\n\r\n    return { success: true, handle, outputDir };\r\n  } catch (error) {\r\n    const errorMessage = errorMsg(error);\r\n    log.debug(`migrateToBackground: Error: ${errorMessage}`);\r\n    return { success: false, error: `Failed to migrate process: ${errorMessage}` };\r\n  }\r\n}\r\n\r\n/**\r\n * Handle for a migrated foreground process.\r\n *\r\n * Unlike RuntimeBackgroundHandle which uses runtime.exec for file operations,\r\n * this handle uses local filesystem directly because the streams are already\r\n * being piped to the local machine (even for SSH runtime).\r\n *\r\n * Both stdout and stderr are written to a unified output.log file.\r\n */\r\nclass MigratedBackgroundHandle implements BackgroundHandle {\r\n  private exitCodeValue: number | null = null;\r\n  private consuming = false;\r\n  private outputFd: fs.FileHandle | null = null;\r\n\r\n  constructor(\r\n    private readonly execStream: ExecStream,\r\n    public readonly outputDir: string,\r\n    private readonly outputPath: string\r\n  ) {}\r\n\r\n  /**\r\n   * Start consuming remaining output from streams and writing to unified file.\r\n   * Called after handle is created to begin background file writing.\r\n   */\r\n  startConsuming(): void {\r\n    if (this.consuming) return;\r\n    this.consuming = true;\r\n\r\n    // Open output file once, consume both streams to it\r\n    void this.consumeStreams();\r\n\r\n    // Track exit code\r\n    void this.execStream.exitCode.then((code) => {\r\n      this.exitCodeValue = code;\r\n      // Write exit code to file\r\n      void this.writeExitCode(code);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Consume both stdout and stderr streams and append to unified output file.\r\n   */\r\n  private async consumeStreams(): Promise<void> {\r\n    try {\r\n      this.outputFd = await fs.open(this.outputPath, \"a\");\r\n\r\n      // Consume both streams concurrently, both writing to same file\r\n      await Promise.all([\r\n        this.consumeStream(this.execStream.stdout),\r\n        this.consumeStream(this.execStream.stderr),\r\n      ]);\r\n    } catch (error) {\r\n      log.debug(`MigratedBackgroundHandle.consumeStreams: ${errorMsg(error)}`);\r\n    } finally {\r\n      if (this.outputFd) {\r\n        await this.outputFd.close();\r\n        this.outputFd = null;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Consume a stream and append to the shared output file.\r\n   */\r\n  private async consumeStream(stream: ReadableStream<Uint8Array>): Promise<void> {\r\n    try {\r\n      const reader = stream.getReader();\r\n\r\n      try {\r\n        while (true) {\r\n          const { value, done } = await reader.read();\r\n          if (done) break;\r\n          if (value && this.outputFd) {\r\n            await this.outputFd.write(value);\r\n          }\r\n        }\r\n      } finally {\r\n        reader.releaseLock();\r\n      }\r\n    } catch (error) {\r\n      // Stream may have been cancelled or process killed - that's fine\r\n      log.debug(`MigratedBackgroundHandle.consumeStream: ${errorMsg(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write exit code to file.\r\n   */\r\n  private async writeExitCode(code: number): Promise<void> {\r\n    try {\r\n      const exitCodePath = path.join(this.outputDir, EXIT_CODE_FILENAME);\r\n      await fs.writeFile(exitCodePath, String(code));\r\n    } catch (error) {\r\n      log.debug(`MigratedBackgroundHandle.writeExitCode: ${errorMsg(error)}`);\r\n    }\r\n  }\r\n\r\n  getExitCode(): Promise<number | null> {\r\n    return Promise.resolve(this.exitCodeValue);\r\n  }\r\n\r\n  async terminate(): Promise<void> {\r\n    // ExecStream doesn't expose a kill method directly\r\n    // Cancel the streams to stop reading (process continues but we stop tracking)\r\n    try {\r\n      await this.execStream.stdout.cancel();\r\n      await this.execStream.stderr.cancel();\r\n    } catch {\r\n      // Streams may already be closed\r\n    }\r\n  }\r\n\r\n  async dispose(): Promise<void> {\r\n    // Close any open file handles\r\n    await this.outputFd?.close().catch(() => {\r\n      /* ignore */\r\n    });\r\n  }\r\n\r\n  async getOutputFileSize(): Promise<number> {\r\n    try {\r\n      const stat = await fs.stat(this.outputPath);\r\n      return stat.size;\r\n    } catch (error) {\r\n      log.debug(`MigratedBackgroundHandle.getOutputFileSize: ${errorMsg(error)}`);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  async writeMeta(metaJson: string): Promise<void> {\r\n    try {\r\n      const metaPath = path.join(this.outputDir, \"meta.json\");\r\n      await fs.writeFile(metaPath, metaJson);\r\n    } catch (error) {\r\n      log.debug(`MigratedBackgroundHandle.writeMeta: ${errorMsg(error)}`);\r\n    }\r\n  }\r\n\r\n  async readOutput(offset: number): Promise<{ content: string; newOffset: number }> {\r\n    try {\r\n      const fileSize = await this.getOutputFileSize();\r\n\r\n      if (offset >= fileSize) {\r\n        return { content: \"\", newOffset: offset };\r\n      }\r\n\r\n      // Read from offset to end\r\n      const fd = await fs.open(this.outputPath, \"r\");\r\n      try {\r\n        const buffer = Buffer.alloc(fileSize - offset);\r\n        const { bytesRead } = await fd.read(buffer, 0, buffer.length, offset);\r\n        return {\r\n          content: buffer.slice(0, bytesRead).toString(\"utf-8\"),\r\n          newOffset: offset + bytesRead,\r\n        };\r\n      } finally {\r\n        await fd.close();\r\n      }\r\n    } catch (error) {\r\n      log.debug(`MigratedBackgroundHandle.readOutput: ${errorMsg(error)}`);\r\n      return { content: \"\", newOffset: offset };\r\n    }\r\n  }\r\n}\r\n"]}