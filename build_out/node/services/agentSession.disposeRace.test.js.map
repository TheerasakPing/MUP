{"version":3,"file":"agentSession.disposeRace.test.js","sourceRoot":"","sources":["../../../src/node/services/agentSession.disposeRace.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, expect, test, mock } from \"bun:test\";\r\nimport { AgentSession } from \"./agentSession\";\r\nimport type { Config } from \"@/node/config\";\r\nimport type { HistoryService } from \"./historyService\";\r\nimport type { PartialService } from \"./partialService\";\r\nimport type { AIService } from \"./aiService\";\r\nimport type { InitStateManager } from \"./initStateManager\";\r\nimport type { BackgroundProcessManager } from \"./backgroundProcessManager\";\r\nimport type { Result } from \"@/common/types/result\";\r\nimport { Ok } from \"@/common/types/result\";\r\nimport type { CostTrackingService } from \"./costTrackingService\";\r\n\r\nfunction createDeferred<T>(): {\r\n  promise: Promise<T>;\r\n  resolve: (value: T) => void;\r\n} {\r\n  let resolve!: (value: T) => void;\r\n  const promise = new Promise<T>((res) => {\r\n    resolve = res;\r\n  });\r\n  return { promise, resolve };\r\n}\r\n\r\ndescribe(\"AgentSession disposal race conditions\", () => {\r\n  test(\"does not crash if disposed while auto-sending a queued message\", async () => {\r\n    const aiHandlers = new Map<string, (...args: unknown[]) => void>();\r\n\r\n    const streamMessage = mock(() => Promise.resolve(Ok(undefined)));\r\n\r\n    const aiService: AIService = {\r\n      on(eventName: string | symbol, listener: (...args: unknown[]) => void) {\r\n        aiHandlers.set(String(eventName), listener);\r\n        return this;\r\n      },\r\n      off(_eventName: string | symbol, _listener: (...args: unknown[]) => void) {\r\n        return this;\r\n      },\r\n      stopStream: mock(() => Promise.resolve(Ok(undefined))),\r\n      isStreaming: mock(() => false),\r\n      streamMessage,\r\n    } as unknown as AIService;\r\n\r\n    // Justified mock: deferred promise is essential for testing the dispose-during-write race.\r\n    // A real HistoryService completes appendToHistory synchronously (sub-ms), so we can't\r\n    // reproduce the race window without controlling when the promise resolves.\r\n    const appendDeferred = createDeferred<Result<void>>();\r\n    const historyService: HistoryService = {\r\n      appendToHistory: mock(() => appendDeferred.promise),\r\n    } as unknown as HistoryService;\r\n\r\n    const initStateManager: InitStateManager = {\r\n      on(_eventName: string | symbol, _listener: (...args: unknown[]) => void) {\r\n        return this;\r\n      },\r\n      off(_eventName: string | symbol, _listener: (...args: unknown[]) => void) {\r\n        return this;\r\n      },\r\n    } as unknown as InitStateManager;\r\n\r\n    const backgroundProcessManager: BackgroundProcessManager = {\r\n      cleanup: mock(() => Promise.resolve()),\r\n      setMessageQueued: mock(() => undefined),\r\n    } as unknown as BackgroundProcessManager;\r\n\r\n    const config: Config = {\r\n      srcDir: \"/tmp\",\r\n      getSessionDir: mock(() => \"/tmp\"),\r\n    } as unknown as Config;\r\n    const partialService: PartialService = {} as unknown as PartialService;\r\n\r\n    const session = new AgentSession({\r\n      workspaceId: \"ws\",\r\n      config,\r\n      historyService,\r\n      partialService,\r\n      aiService,\r\n      initStateManager,\r\n      costTrackingService: {} as unknown as CostTrackingService,\r\n      backgroundProcessManager,\r\n    });\r\n\r\n    // Capture the fire-and-forget sendMessage() promise that sendQueuedMessages() creates.\r\n    const originalSendMessage = session.sendMessage.bind(session);\r\n    let inFlight: Promise<unknown> | undefined;\r\n    (session as unknown as { sendMessage: typeof originalSendMessage }).sendMessage = (\r\n      ...args: Parameters<typeof originalSendMessage>\r\n    ) => {\r\n      const promise = originalSendMessage(...args);\r\n      inFlight = promise;\r\n      return promise;\r\n    };\r\n\r\n    session.queueMessage(\"Queued message\", {\r\n      model: \"anthropic:claude-sonnet-4-5\",\r\n      agentId: \"exec\",\r\n    });\r\n    session.sendQueuedMessages();\r\n\r\n    expect(inFlight).toBeDefined();\r\n\r\n    // Dispose while sendMessage() is awaiting appendToHistory.\r\n    session.dispose();\r\n    appendDeferred.resolve(Ok(undefined));\r\n\r\n    const result = await (inFlight as Promise<Result<void>>);\r\n    expect(result.success).toBe(true);\r\n\r\n    // We should not attempt to stream once disposal has begun.\r\n    expect(streamMessage).toHaveBeenCalledTimes(0);\r\n\r\n    // Sanity: invoking a forwarded handler after dispose should be a no-op.\r\n    const streamStart = aiHandlers.get(\"stream-start\");\r\n    expect(() =>\r\n      streamStart?.({\r\n        type: \"stream-start\",\r\n        workspaceId: \"ws\",\r\n        messageId: \"m1\",\r\n        model: \"anthropic:claude-sonnet-4-5\",\r\n        historySequence: 1,\r\n        startTime: Date.now(),\r\n      })\r\n    ).not.toThrow();\r\n  });\r\n});\r\n"]}