{"version":3,"file":"agentSession.disposeRace.test.js","sourceRoot":"","sources":["../../../src/node/services/agentSession.disposeRace.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, expect, test, mock } from \"bun:test\";\nimport { AgentSession } from \"./agentSession\";\nimport type { Config } from \"@/node/config\";\nimport type { HistoryService } from \"./historyService\";\nimport type { PartialService } from \"./partialService\";\nimport type { AIService } from \"./aiService\";\nimport type { InitStateManager } from \"./initStateManager\";\nimport type { BackgroundProcessManager } from \"./backgroundProcessManager\";\nimport type { Result } from \"@/common/types/result\";\nimport { Ok } from \"@/common/types/result\";\nimport type { CostTrackingService } from \"./costTrackingService\";\n\nfunction createDeferred<T>(): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n} {\n  let resolve!: (value: T) => void;\n  const promise = new Promise<T>((res) => {\n    resolve = res;\n  });\n  return { promise, resolve };\n}\n\ndescribe(\"AgentSession disposal race conditions\", () => {\n  test(\"does not crash if disposed while auto-sending a queued message\", async () => {\n    const aiHandlers = new Map<string, (...args: unknown[]) => void>();\n\n    const streamMessage = mock(() => Promise.resolve(Ok(undefined)));\n\n    const aiService: AIService = {\n      on(eventName: string | symbol, listener: (...args: unknown[]) => void) {\n        aiHandlers.set(String(eventName), listener);\n        return this;\n      },\n      off(_eventName: string | symbol, _listener: (...args: unknown[]) => void) {\n        return this;\n      },\n      stopStream: mock(() => Promise.resolve(Ok(undefined))),\n      isStreaming: mock(() => false),\n      streamMessage,\n    } as unknown as AIService;\n\n    // Justified mock: deferred promise is essential for testing the dispose-during-write race.\n    // A real HistoryService completes appendToHistory synchronously (sub-ms), so we can't\n    // reproduce the race window without controlling when the promise resolves.\n    const appendDeferred = createDeferred<Result<void>>();\n    const historyService: HistoryService = {\n      appendToHistory: mock(() => appendDeferred.promise),\n    } as unknown as HistoryService;\n\n    const initStateManager: InitStateManager = {\n      on(_eventName: string | symbol, _listener: (...args: unknown[]) => void) {\n        return this;\n      },\n      off(_eventName: string | symbol, _listener: (...args: unknown[]) => void) {\n        return this;\n      },\n    } as unknown as InitStateManager;\n\n    const backgroundProcessManager: BackgroundProcessManager = {\n      cleanup: mock(() => Promise.resolve()),\n      setMessageQueued: mock(() => undefined),\n    } as unknown as BackgroundProcessManager;\n\n    const config: Config = {\n      srcDir: \"/tmp\",\n      getSessionDir: mock(() => \"/tmp\"),\n    } as unknown as Config;\n    const partialService: PartialService = {} as unknown as PartialService;\n\n    const session = new AgentSession({\n      workspaceId: \"ws\",\n      config,\n      historyService,\n      partialService,\n      aiService,\n      initStateManager,\n      costTrackingService: {} as unknown as CostTrackingService,\n      backgroundProcessManager,\n    });\n\n    // Capture the fire-and-forget sendMessage() promise that sendQueuedMessages() creates.\n    const originalSendMessage = session.sendMessage.bind(session);\n    let inFlight: Promise<unknown> | undefined;\n    (session as unknown as { sendMessage: typeof originalSendMessage }).sendMessage = (\n      ...args: Parameters<typeof originalSendMessage>\n    ) => {\n      const promise = originalSendMessage(...args);\n      inFlight = promise;\n      return promise;\n    };\n\n    session.queueMessage(\"Queued message\", {\n      model: \"anthropic:claude-sonnet-4-5\",\n      agentId: \"exec\",\n    });\n    session.sendQueuedMessages();\n\n    expect(inFlight).toBeDefined();\n\n    // Dispose while sendMessage() is awaiting appendToHistory.\n    session.dispose();\n    appendDeferred.resolve(Ok(undefined));\n\n    const result = await (inFlight as Promise<Result<void>>);\n    expect(result.success).toBe(true);\n\n    // We should not attempt to stream once disposal has begun.\n    expect(streamMessage).toHaveBeenCalledTimes(0);\n\n    // Sanity: invoking a forwarded handler after dispose should be a no-op.\n    const streamStart = aiHandlers.get(\"stream-start\");\n    expect(() =>\n      streamStart?.({\n        type: \"stream-start\",\n        workspaceId: \"ws\",\n        messageId: \"m1\",\n        model: \"anthropic:claude-sonnet-4-5\",\n        historySequence: 1,\n        startTime: Date.now(),\n      })\n    ).not.toThrow();\n  });\n});\n"]}