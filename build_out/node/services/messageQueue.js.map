{"version":3,"file":"messageQueue.js","sourceRoot":"","sources":["../../../src/node/services/messageQueue.ts"],"names":[],"mappings":"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","sourcesContent":["import type { FilePart, SendMessageOptions } from \"@/common/orpc/types\";\r\nimport type { ReviewNoteData } from \"@/common/types/review\";\r\n\r\n// Type guard for compaction request metadata (for display text)\r\ninterface CompactionMetadata {\r\n  type: \"compaction-request\";\r\n  rawCommand: string;\r\n}\r\n\r\n// Type guard for agent skill metadata (for display + batching constraints)\r\ninterface AgentSkillMetadata {\r\n  type: \"agent-skill\";\r\n  rawCommand: string;\r\n  skillName: string;\r\n  scope: \"project\" | \"global\" | \"built-in\";\r\n}\r\n\r\nfunction isAgentSkillMetadata(meta: unknown): meta is AgentSkillMetadata {\r\n  if (typeof meta !== \"object\" || meta === null) return false;\r\n  const obj = meta as Record<string, unknown>;\r\n  if (obj.type !== \"agent-skill\") return false;\r\n  if (typeof obj.rawCommand !== \"string\") return false;\r\n  if (typeof obj.skillName !== \"string\") return false;\r\n  if (obj.scope !== \"project\" && obj.scope !== \"global\" && obj.scope !== \"built-in\") return false;\r\n  return true;\r\n}\r\n\r\nfunction isCompactionMetadata(meta: unknown): meta is CompactionMetadata {\r\n  if (typeof meta !== \"object\" || meta === null) return false;\r\n  const obj = meta as Record<string, unknown>;\r\n  return obj.type === \"compaction-request\" && typeof obj.rawCommand === \"string\";\r\n}\r\n\r\n// Type guard for metadata with reviews\r\ninterface MetadataWithReviews {\r\n  reviews?: ReviewNoteData[];\r\n}\r\n\r\nfunction hasReviews(meta: unknown): meta is MetadataWithReviews {\r\n  if (typeof meta !== \"object\" || meta === null) return false;\r\n  const obj = meta as Record<string, unknown>;\r\n  return Array.isArray(obj.reviews);\r\n}\r\n\r\n/**\r\n * Queue for messages sent during active streaming.\r\n *\r\n * Stores:\r\n * - Message texts (accumulated)\r\n * - First muxMetadata (preserved - never overwritten by subsequent adds)\r\n * - Latest options (model, etc. - updated on each add)\r\n * - File parts (accumulated across all messages)\r\n *\r\n * IMPORTANT:\r\n * - Compaction requests must preserve their muxMetadata even when follow-up messages are queued.\r\n * - Agent-skill invocations cannot be batched with other messages; otherwise the skill metadata would\r\n *   “leak” onto later queued sends.\r\n *\r\n * Display logic:\r\n * - Single compaction request → shows rawCommand (/compact)\r\n * - Single agent-skill invocation → shows rawCommand (/{skill})\r\n * - Multiple messages → shows all actual message texts\r\n */\r\nexport class MessageQueue {\r\n  private messages: string[] = [];\r\n  private firstMuxMetadata?: unknown;\r\n  private latestOptions?: SendMessageOptions;\r\n  private accumulatedFileParts: FilePart[] = [];\r\n  private dedupeKeys: Set<string> = new Set<string>();\r\n\r\n  /**\r\n   * Check if the queue currently contains a compaction request.\r\n   */\r\n  hasCompactionRequest(): boolean {\r\n    return isCompactionMetadata(this.firstMuxMetadata);\r\n  }\r\n\r\n  /**\r\n   * Add a message to the queue.\r\n   * Preserves muxMetadata from first message, updates other options.\r\n   * Accumulates file parts.\r\n   *\r\n   * @throws Error if trying to add a compaction request when queue already has messages\r\n   */\r\n  add(message: string, options?: SendMessageOptions & { fileParts?: FilePart[] }): void {\r\n    this.addInternal(message, options);\r\n  }\r\n\r\n  /**\r\n   * Add a message to the queue once, keyed by dedupeKey.\r\n   * Returns true if the message was queued.\r\n   */\r\n  addOnce(\r\n    message: string,\r\n    options?: SendMessageOptions & { fileParts?: FilePart[] },\r\n    dedupeKey?: string\r\n  ): boolean {\r\n    if (dedupeKey !== undefined && this.dedupeKeys.has(dedupeKey)) {\r\n      return false;\r\n    }\r\n\r\n    const didAdd = this.addInternal(message, options);\r\n    if (didAdd && dedupeKey !== undefined) {\r\n      this.dedupeKeys.add(dedupeKey);\r\n    }\r\n    return didAdd;\r\n  }\r\n\r\n  private addInternal(\r\n    message: string,\r\n    options?: SendMessageOptions & { fileParts?: FilePart[] }\r\n  ): boolean {\r\n    const trimmedMessage = message.trim();\r\n    const hasFiles = options?.fileParts && options.fileParts.length > 0;\r\n\r\n    // Reject if both text and file parts are empty\r\n    if (trimmedMessage.length === 0 && !hasFiles) {\r\n      return false;\r\n    }\r\n\r\n    const incomingIsCompaction = isCompactionMetadata(options?.muxMetadata);\r\n    const incomingIsAgentSkill = isAgentSkillMetadata(options?.muxMetadata);\r\n    const queueHasMessages = !this.isEmpty();\r\n    const queueHasAgentSkill = isAgentSkillMetadata(this.firstMuxMetadata);\r\n\r\n    // Avoid leaking agent-skill metadata to later queued messages.\r\n    // A skill invocation must be sent alone (or the user should restore/edit the queued message).\r\n    if (queueHasAgentSkill) {\r\n      throw new Error(\r\n        \"Cannot queue additional messages: an agent skill invocation is already queued. \" +\r\n          \"Wait for the current stream to complete before sending another message.\"\r\n      );\r\n    }\r\n\r\n    // Cannot add compaction to a queue that already has messages\r\n    // (user should wait for those messages to send first)\r\n    if (incomingIsCompaction && queueHasMessages) {\r\n      throw new Error(\r\n        \"Cannot queue compaction request: queue already has messages. \" +\r\n          \"Wait for current stream to complete before compacting.\"\r\n      );\r\n    }\r\n\r\n    // Cannot batch agent-skill metadata with other messages (it would apply to the whole batch).\r\n    if (incomingIsAgentSkill && queueHasMessages) {\r\n      throw new Error(\r\n        \"Cannot queue agent skill invocation: queue already has messages. \" +\r\n          \"Wait for the current stream to complete before running a skill.\"\r\n      );\r\n    }\r\n\r\n    // Add text message if non-empty\r\n    if (trimmedMessage.length > 0) {\r\n      this.messages.push(trimmedMessage);\r\n    }\r\n\r\n    if (options) {\r\n      const { fileParts, ...restOptions } = options;\r\n\r\n      // Preserve first muxMetadata (see class docblock for rationale)\r\n      if (options.muxMetadata !== undefined && this.firstMuxMetadata === undefined) {\r\n        this.firstMuxMetadata = options.muxMetadata;\r\n      }\r\n      this.latestOptions = restOptions;\r\n\r\n      if (fileParts && fileParts.length > 0) {\r\n        this.accumulatedFileParts.push(...fileParts);\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get all queued message texts (for editing/restoration).\r\n   */\r\n  getMessages(): string[] {\r\n    return [...this.messages];\r\n  }\r\n\r\n  /**\r\n   * Get display text for queued messages.\r\n   * - Single compaction request shows rawCommand (/compact)\r\n   * - Single agent-skill invocation shows rawCommand (/{skill})\r\n   * - Multiple messages show all actual message texts\r\n   */\r\n  getDisplayText(): string {\r\n    // Only show rawCommand for single compaction request\r\n    if (this.messages.length === 1 && isCompactionMetadata(this.firstMuxMetadata)) {\r\n      return this.firstMuxMetadata.rawCommand;\r\n    }\r\n\r\n    // Only show rawCommand for a single agent-skill invocation.\r\n    // (Batching agent-skill with other messages is disallowed.)\r\n    if (this.messages.length <= 1 && isAgentSkillMetadata(this.firstMuxMetadata)) {\r\n      return this.firstMuxMetadata.rawCommand;\r\n    }\r\n\r\n    return this.messages.join(\"\\n\");\r\n  }\r\n\r\n  /**\r\n   * Get accumulated file parts for display.\r\n   */\r\n  getFileParts(): FilePart[] {\r\n    return [...this.accumulatedFileParts];\r\n  }\r\n\r\n  /**\r\n   * Get reviews from metadata for display.\r\n   */\r\n  getReviews(): ReviewNoteData[] | undefined {\r\n    if (hasReviews(this.firstMuxMetadata) && this.firstMuxMetadata.reviews?.length) {\r\n      return this.firstMuxMetadata.reviews;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Get combined message and options for sending.\r\n   */\r\n  produceMessage(): {\r\n    message: string;\r\n    options?: SendMessageOptions & { fileParts?: FilePart[] };\r\n  } {\r\n    const joinedMessages = this.messages.join(\"\\n\");\r\n    // First metadata takes precedence (preserves compaction + agent-skill invocations)\r\n    const muxMetadata =\r\n      this.firstMuxMetadata !== undefined\r\n        ? this.firstMuxMetadata\r\n        : (this.latestOptions?.muxMetadata as unknown);\r\n    const options = this.latestOptions\r\n      ? {\r\n          ...this.latestOptions,\r\n          muxMetadata,\r\n          fileParts: this.accumulatedFileParts.length > 0 ? this.accumulatedFileParts : undefined,\r\n        }\r\n      : undefined;\r\n\r\n    return { message: joinedMessages, options };\r\n  }\r\n\r\n  /**\r\n   * Clear all queued messages, options, and images.\r\n   */\r\n  clear(): void {\r\n    this.messages = [];\r\n    this.firstMuxMetadata = undefined;\r\n    this.latestOptions = undefined;\r\n    this.accumulatedFileParts = [];\r\n    this.dedupeKeys.clear();\r\n  }\r\n\r\n  /**\r\n   * Check if queue is empty (no messages AND no images).\r\n   */\r\n  isEmpty(): boolean {\r\n    return this.messages.length === 0 && this.accumulatedFileParts.length === 0;\r\n  }\r\n}\r\n"]}