{"version":3,"file":"messageQueue.js","sourceRoot":"","sources":["../../../src/node/services/messageQueue.ts"],"names":[],"mappings":"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","sourcesContent":["import type { FilePart, SendMessageOptions } from \"@/common/orpc/types\";\nimport type { ReviewNoteData } from \"@/common/types/review\";\n\n// Type guard for compaction request metadata (for display text)\ninterface CompactionMetadata {\n  type: \"compaction-request\";\n  rawCommand: string;\n}\n\n// Type guard for agent skill metadata (for display + batching constraints)\ninterface AgentSkillMetadata {\n  type: \"agent-skill\";\n  rawCommand: string;\n  skillName: string;\n  scope: \"project\" | \"global\" | \"built-in\";\n}\n\nfunction isAgentSkillMetadata(meta: unknown): meta is AgentSkillMetadata {\n  if (typeof meta !== \"object\" || meta === null) return false;\n  const obj = meta as Record<string, unknown>;\n  if (obj.type !== \"agent-skill\") return false;\n  if (typeof obj.rawCommand !== \"string\") return false;\n  if (typeof obj.skillName !== \"string\") return false;\n  if (obj.scope !== \"project\" && obj.scope !== \"global\" && obj.scope !== \"built-in\") return false;\n  return true;\n}\n\nfunction isCompactionMetadata(meta: unknown): meta is CompactionMetadata {\n  if (typeof meta !== \"object\" || meta === null) return false;\n  const obj = meta as Record<string, unknown>;\n  return obj.type === \"compaction-request\" && typeof obj.rawCommand === \"string\";\n}\n\n// Type guard for metadata with reviews\ninterface MetadataWithReviews {\n  reviews?: ReviewNoteData[];\n}\n\nfunction hasReviews(meta: unknown): meta is MetadataWithReviews {\n  if (typeof meta !== \"object\" || meta === null) return false;\n  const obj = meta as Record<string, unknown>;\n  return Array.isArray(obj.reviews);\n}\n\n/**\n * Queue for messages sent during active streaming.\n *\n * Stores:\n * - Message texts (accumulated)\n * - First muxMetadata (preserved - never overwritten by subsequent adds)\n * - Latest options (model, etc. - updated on each add)\n * - File parts (accumulated across all messages)\n *\n * IMPORTANT:\n * - Compaction requests must preserve their muxMetadata even when follow-up messages are queued.\n * - Agent-skill invocations cannot be batched with other messages; otherwise the skill metadata would\n *   “leak” onto later queued sends.\n *\n * Display logic:\n * - Single compaction request → shows rawCommand (/compact)\n * - Single agent-skill invocation → shows rawCommand (/{skill})\n * - Multiple messages → shows all actual message texts\n */\nexport class MessageQueue {\n  private messages: string[] = [];\n  private firstMuxMetadata?: unknown;\n  private latestOptions?: SendMessageOptions;\n  private accumulatedFileParts: FilePart[] = [];\n  private dedupeKeys: Set<string> = new Set<string>();\n\n  /**\n   * Check if the queue currently contains a compaction request.\n   */\n  hasCompactionRequest(): boolean {\n    return isCompactionMetadata(this.firstMuxMetadata);\n  }\n\n  /**\n   * Add a message to the queue.\n   * Preserves muxMetadata from first message, updates other options.\n   * Accumulates file parts.\n   *\n   * @throws Error if trying to add a compaction request when queue already has messages\n   */\n  add(message: string, options?: SendMessageOptions & { fileParts?: FilePart[] }): void {\n    this.addInternal(message, options);\n  }\n\n  /**\n   * Add a message to the queue once, keyed by dedupeKey.\n   * Returns true if the message was queued.\n   */\n  addOnce(\n    message: string,\n    options?: SendMessageOptions & { fileParts?: FilePart[] },\n    dedupeKey?: string\n  ): boolean {\n    if (dedupeKey !== undefined && this.dedupeKeys.has(dedupeKey)) {\n      return false;\n    }\n\n    const didAdd = this.addInternal(message, options);\n    if (didAdd && dedupeKey !== undefined) {\n      this.dedupeKeys.add(dedupeKey);\n    }\n    return didAdd;\n  }\n\n  private addInternal(\n    message: string,\n    options?: SendMessageOptions & { fileParts?: FilePart[] }\n  ): boolean {\n    const trimmedMessage = message.trim();\n    const hasFiles = options?.fileParts && options.fileParts.length > 0;\n\n    // Reject if both text and file parts are empty\n    if (trimmedMessage.length === 0 && !hasFiles) {\n      return false;\n    }\n\n    const incomingIsCompaction = isCompactionMetadata(options?.muxMetadata);\n    const incomingIsAgentSkill = isAgentSkillMetadata(options?.muxMetadata);\n    const queueHasMessages = !this.isEmpty();\n    const queueHasAgentSkill = isAgentSkillMetadata(this.firstMuxMetadata);\n\n    // Avoid leaking agent-skill metadata to later queued messages.\n    // A skill invocation must be sent alone (or the user should restore/edit the queued message).\n    if (queueHasAgentSkill) {\n      throw new Error(\n        \"Cannot queue additional messages: an agent skill invocation is already queued. \" +\n          \"Wait for the current stream to complete before sending another message.\"\n      );\n    }\n\n    // Cannot add compaction to a queue that already has messages\n    // (user should wait for those messages to send first)\n    if (incomingIsCompaction && queueHasMessages) {\n      throw new Error(\n        \"Cannot queue compaction request: queue already has messages. \" +\n          \"Wait for current stream to complete before compacting.\"\n      );\n    }\n\n    // Cannot batch agent-skill metadata with other messages (it would apply to the whole batch).\n    if (incomingIsAgentSkill && queueHasMessages) {\n      throw new Error(\n        \"Cannot queue agent skill invocation: queue already has messages. \" +\n          \"Wait for the current stream to complete before running a skill.\"\n      );\n    }\n\n    // Add text message if non-empty\n    if (trimmedMessage.length > 0) {\n      this.messages.push(trimmedMessage);\n    }\n\n    if (options) {\n      const { fileParts, ...restOptions } = options;\n\n      // Preserve first muxMetadata (see class docblock for rationale)\n      if (options.muxMetadata !== undefined && this.firstMuxMetadata === undefined) {\n        this.firstMuxMetadata = options.muxMetadata;\n      }\n      this.latestOptions = restOptions;\n\n      if (fileParts && fileParts.length > 0) {\n        this.accumulatedFileParts.push(...fileParts);\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Get all queued message texts (for editing/restoration).\n   */\n  getMessages(): string[] {\n    return [...this.messages];\n  }\n\n  /**\n   * Get display text for queued messages.\n   * - Single compaction request shows rawCommand (/compact)\n   * - Single agent-skill invocation shows rawCommand (/{skill})\n   * - Multiple messages show all actual message texts\n   */\n  getDisplayText(): string {\n    // Only show rawCommand for single compaction request\n    if (this.messages.length === 1 && isCompactionMetadata(this.firstMuxMetadata)) {\n      return this.firstMuxMetadata.rawCommand;\n    }\n\n    // Only show rawCommand for a single agent-skill invocation.\n    // (Batching agent-skill with other messages is disallowed.)\n    if (this.messages.length <= 1 && isAgentSkillMetadata(this.firstMuxMetadata)) {\n      return this.firstMuxMetadata.rawCommand;\n    }\n\n    return this.messages.join(\"\\n\");\n  }\n\n  /**\n   * Get accumulated file parts for display.\n   */\n  getFileParts(): FilePart[] {\n    return [...this.accumulatedFileParts];\n  }\n\n  /**\n   * Get reviews from metadata for display.\n   */\n  getReviews(): ReviewNoteData[] | undefined {\n    if (hasReviews(this.firstMuxMetadata) && this.firstMuxMetadata.reviews?.length) {\n      return this.firstMuxMetadata.reviews;\n    }\n    return undefined;\n  }\n\n  /**\n   * Get combined message and options for sending.\n   */\n  produceMessage(): {\n    message: string;\n    options?: SendMessageOptions & { fileParts?: FilePart[] };\n  } {\n    const joinedMessages = this.messages.join(\"\\n\");\n    // First metadata takes precedence (preserves compaction + agent-skill invocations)\n    const muxMetadata =\n      this.firstMuxMetadata !== undefined\n        ? this.firstMuxMetadata\n        : (this.latestOptions?.muxMetadata as unknown);\n    const options = this.latestOptions\n      ? {\n          ...this.latestOptions,\n          muxMetadata,\n          fileParts: this.accumulatedFileParts.length > 0 ? this.accumulatedFileParts : undefined,\n        }\n      : undefined;\n\n    return { message: joinedMessages, options };\n  }\n\n  /**\n   * Clear all queued messages, options, and images.\n   */\n  clear(): void {\n    this.messages = [];\n    this.firstMuxMetadata = undefined;\n    this.latestOptions = undefined;\n    this.accumulatedFileParts = [];\n    this.dedupeKeys.clear();\n  }\n\n  /**\n   * Check if queue is empty (no messages AND no images).\n   */\n  isEmpty(): boolean {\n    return this.messages.length === 0 && this.accumulatedFileParts.length === 0;\n  }\n}\n"]}