{"version":3,"file":"toolBridge.js","sourceRoot":"","sources":["../../../../src/node/services/ptc/toolBridge.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Tool Bridge for PTC\r\n *\r\n * Bridges Mux tools into the QuickJS sandbox, making them callable via `mux.*` namespace.\r\n * Handles argument validation via Zod schemas and result serialization.\r\n */\r\n\r\nimport type { Tool } from \"ai\";\r\nimport type { z } from \"zod\";\r\nimport type { IJSRuntime } from \"./runtime\";\r\n\r\n/** Tools excluded from sandbox - UI-specific or would cause recursion */\r\nconst EXCLUDED_TOOLS = new Set([\r\n  \"code_execution\", // Prevent recursive sandbox creation\r\n  \"ask_user_question\", // Requires UI interaction\r\n  \"propose_plan\", // Mode-specific, call directly\r\n  \"todo_write\", // UI-specific\r\n  \"todo_read\", // UI-specific\r\n  \"status_set\", // UI-specific\r\n  \"agent_report\", // Must be top-level for taskService to read args from history\r\n]);\r\n\r\n/**\r\n * Bridge that exposes Mux tools in the QuickJS sandbox under `mux.*` namespace.\r\n */\r\nexport class ToolBridge {\r\n  private readonly bridgeableTools: Map<string, Tool>;\r\n  private readonly nonBridgeableTools: Map<string, Tool>;\r\n\r\n  constructor(tools: Record<string, Tool>) {\r\n    this.bridgeableTools = new Map();\r\n    this.nonBridgeableTools = new Map();\r\n\r\n    for (const [name, tool] of Object.entries(tools)) {\r\n      // code_execution is the tool that uses the bridge, not a candidate for bridging\r\n      if (name === \"code_execution\") continue;\r\n\r\n      const isBridgeable = !EXCLUDED_TOOLS.has(name) && this.hasExecute(tool);\r\n      if (isBridgeable) {\r\n        this.bridgeableTools.set(name, tool);\r\n      } else {\r\n        this.nonBridgeableTools.set(name, tool);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Get list of tools that will be exposed in sandbox */\r\n  getBridgeableToolNames(): string[] {\r\n    return Array.from(this.bridgeableTools.keys());\r\n  }\r\n\r\n  /** Get the bridgeable tools as a Record */\r\n  getBridgeableTools(): Record<string, Tool> {\r\n    return Object.fromEntries(this.bridgeableTools.entries());\r\n  }\r\n\r\n  /**\r\n   * Get tools that cannot be bridged into the sandbox.\r\n   * These are tools that either:\r\n   * - Are explicitly excluded (UI-specific, mode-specific)\r\n   * - Don't have an execute function (provider-native like web_search)\r\n   *\r\n   * In exclusive PTC mode, these should still be available to the model directly.\r\n   */\r\n  getNonBridgeableTools(): Record<string, Tool> {\r\n    return Object.fromEntries(this.nonBridgeableTools.entries());\r\n  }\r\n\r\n  /**\r\n   * Register all bridgeable tools on the runtime under `mux` namespace.\r\n   *\r\n   * Tools receive the runtime's abort signal, which is aborted when:\r\n   * - The sandbox timeout is exceeded\r\n   * - runtime.abort() is called (e.g., from the parent's abort signal)\r\n   *\r\n   * This ensures nested tool calls are cancelled when the sandbox times out,\r\n   * not just when the parent stream is cancelled.\r\n   */\r\n  register(runtime: IJSRuntime): void {\r\n    const muxObj: Record<string, (...args: unknown[]) => Promise<unknown>> = {};\r\n\r\n    for (const [name, tool] of this.bridgeableTools) {\r\n      // Capture tool for closure\r\n      const boundTool = tool;\r\n      const toolName = name;\r\n\r\n      muxObj[name] = async (args: unknown) => {\r\n        // Get the runtime's abort signal - this is aborted on timeout or manual abort\r\n        const abortSignal = runtime.getAbortSignal();\r\n\r\n        // Check if already aborted before executing\r\n        if (abortSignal?.aborted) {\r\n          throw new Error(\"Execution aborted\");\r\n        }\r\n\r\n        // Validate args against tool's Zod schema\r\n        const validatedArgs = this.validateArgs(toolName, boundTool, args);\r\n\r\n        // Execute tool with full options (toolCallId and messages are required by type\r\n        // but not used by most tools - generate synthetic values for sandbox context)\r\n        const result: unknown = await boundTool.execute!(validatedArgs, {\r\n          abortSignal,\r\n          toolCallId: `ptc-${toolName}-${Date.now()}`,\r\n          messages: [],\r\n        });\r\n\r\n        // Ensure result is JSON-serializable\r\n        return this.serializeResult(result);\r\n      };\r\n    }\r\n\r\n    runtime.registerObject(\"mux\", muxObj);\r\n  }\r\n\r\n  private hasExecute(tool: Tool): tool is Tool & { execute: NonNullable<Tool[\"execute\"]> } {\r\n    return typeof tool.execute === \"function\";\r\n  }\r\n\r\n  private validateArgs(toolName: string, tool: Tool, args: unknown): unknown {\r\n    // Access the tool's Zod schema - AI SDK tools use 'inputSchema', some use 'parameters'\r\n    const toolRecord = tool as { inputSchema?: z.ZodType; parameters?: z.ZodType };\r\n    const schema = toolRecord.inputSchema ?? toolRecord.parameters;\r\n    if (!schema) return args;\r\n\r\n    const result = schema.safeParse(args);\r\n    if (!result.success) {\r\n      const issues = result.error.issues.map((i) => `${i.path.join(\".\")}: ${i.message}`).join(\"; \");\r\n      throw new Error(`Invalid arguments for ${toolName}: ${issues}`);\r\n    }\r\n    return result.data;\r\n  }\r\n\r\n  private serializeResult(result: unknown): unknown {\r\n    try {\r\n      // Round-trip through JSON to ensure QuickJS can handle the value\r\n      return JSON.parse(JSON.stringify(result));\r\n    } catch {\r\n      return { error: \"Result not JSON-serializable\" };\r\n    }\r\n  }\r\n}\r\n"]}