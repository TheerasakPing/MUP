{"version":3,"file":"typeValidator.test.js","sourceRoot":"","sources":["../../../../src/node/services/ptc/typeValidator.test.ts"],"names":[],"mappings":";;AAAA,uCAA6D;AAC7D,6BAAwB;AAExB,mDAAgD;AAChD,mDAAmD;AAEnD;;GAEG;AACH,SAAS,cAAc,CAAC,MAAiB,EAAQ;IAC/C,OAAO;QACL,WAAW,EAAE,WAAW;QACxB,WAAW,EAAE,MAAM;QACnB,OAAO,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;KAC/B,CAAC;AAAA,CACtB;AAED,IAAA,mBAAQ,EAAC,eAAe,EAAE,GAAG,EAAE,CAAC;IAC9B,IAAI,QAAgB,CAAC;IAErB,oCAAoC;IACpC,IAAA,oBAAS,EAAC,KAAK,IAAI,EAAE,CAAC;QACpB,MAAM,KAAK,GAAG;YACZ,SAAS,EAAE,cAAc,CACvB,OAAC,CAAC,MAAM,CAAC;gBACP,QAAQ,EAAE,OAAC,CAAC,MAAM,EAAE;gBACpB,MAAM,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;gBAC7B,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;aAC7B,CAAC,CACH;YACD,IAAI,EAAE,cAAc,CAClB,OAAC,CAAC,MAAM,CAAC;gBACP,MAAM,EAAE,OAAC,CAAC,MAAM,EAAE;gBAClB,YAAY,EAAE,OAAC,CAAC,MAAM,EAAE;gBACxB,iBAAiB,EAAE,OAAC,CAAC,OAAO,EAAE;gBAC9B,YAAY,EAAE,OAAC,CAAC,MAAM,EAAE;aACzB,CAAC,CACH;SACF,CAAC;QACF,QAAQ,GAAG,MAAM,IAAA,gCAAgB,EAAC,KAAK,CAAC,CAAC;IAAA,CAC1C,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,gDAAgD,EAAE,GAAG,EAAE,CAAC;QAC3D,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChC,IAAA,iBAAM,EAAC,MAAM,CAAC,MAAM,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;IAAA,CACvC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,wCAAwC,EAAE,GAAG,EAAE,CAAC;QACnD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;KAED,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,6BAA6B,EAAE,GAAG,EAAE,CAAC;QACxC,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;KAED,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,qEAAqE;QACrE,IAAA,iBAAM,EACJ,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CACxF,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACd,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,mCAAmC,EAAE,GAAG,EAAE,CAAC;QAC9C,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;KAED,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,yCAAyC;QACzC,IAAA,iBAAM,EAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;IAAA,CACjD,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,iCAAiC,EAAE,GAAG,EAAE,CAAC;QAC5C,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;KAED,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,IAAA,iBAAM,EACJ,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CACxF,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACd,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,mCAAmC,EAAE,GAAG,EAAE,CAAC;QAC9C,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;KAED,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,IAAA,iBAAM,EAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACtF,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,sCAAsC,EAAE,GAAG,EAAE,CAAC;QACjD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;qCAE+B,EAC/B,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,qDAAqD;QACrD,MAAM,aAAa,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC;QACtE,IAAA,iBAAM,EAAC,aAAa,CAAC,CAAC,WAAW,EAAE,CAAC;QACpC,IAAA,iBAAM,EAAC,aAAc,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAAA,CACrC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,wCAAwC,EAAE,GAAG,EAAE,CAAC;QACnD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAAC,sCAAsC,EAAE,QAAQ,CAAC,CAAC;QAC/E,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,MAAM,aAAa,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC;QACtE,IAAA,iBAAM,EAAC,aAAa,CAAC,CAAC,WAAW,EAAE,CAAC;QACpC,IAAA,iBAAM,EAAC,aAAc,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAAA,CACrC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,gEAAgE,EAAE,GAAG,EAAE,CAAC;QAC3E,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;kCAI4B,EAC5B,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,MAAM,aAAa,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC;QACtE,IAAA,iBAAM,EAAC,aAAa,CAAC,CAAC,WAAW,EAAE,CAAC;QACpC,IAAA,iBAAM,EAAC,aAAc,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAAA,CACrC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,uCAAuC,EAAE,GAAG,EAAE,CAAC;QAClD,kDAAkD;QAClD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAAC,sCAAsC,EAAE,QAAQ,CAAC,CAAC;QAC/E,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,MAAM,aAAa,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,KAAK,SAAS,CAAC,CAAC;QACxE,IAAA,iBAAM,EAAC,aAAa,CAAC,CAAC,WAAW,EAAE,CAAC;QACpC,IAAA,iBAAM,EAAC,aAAc,CAAC,MAAM,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;IAAA,CAClD,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,qEAAqE,EAAE,GAAG,EAAE,CAAC;QAChF,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;KAID,EACC,QAAQ,CACT,CAAC;QACF,0EAA0E;QAC1E,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,+BAA+B,EAAE,GAAG,EAAE,CAAC;QAC1C,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;KAID,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,oDAAoD,EAAE,GAAG,EAAE,CAAC;QAC/D,gEAAgE;QAChE,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;KAKD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,8BAA8B,EAAE,GAAG,EAAE,CAAC;QACzC,wDAAwD;QACxD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;KAED,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,IAAA,iBAAM,EAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CAChF,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,kDAAkD,EAAE,GAAG,EAAE,CAAC;QAC7D,6DAA6D;QAC7D,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;KAID,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,IAAA,iBAAM,EAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CAC5E,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,mDAAmD,EAAE,GAAG,EAAE,CAAC;QAC9D,4DAA4D;QAC5D,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,IAAA,iBAAM,EAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CAC1E,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,2CAA2C,EAAE,GAAG,EAAE,CAAC;QACtD,yDAAyD;QACzD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,IAAA,iBAAM,EAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CAC3E,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,4CAA4C,EAAE,GAAG,EAAE,CAAC;QACvD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,IAAA,iBAAM,EAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CAC1E,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,wCAAwC,EAAE,GAAG,EAAE,CAAC;QACnD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;;KAMD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,kDAAkD,EAAE,GAAG,EAAE,CAAC;QAC7D,wDAAwD;QACxD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,IAAA,iBAAM,EAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CAC3E,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,iDAAiD,EAAE,GAAG,EAAE,CAAC;QAC5D,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;;KAMD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,sEAAsE,EAAE,GAAG,EAAE,CAAC;QACjF,0DAA0D;QAC1D,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;;;KAOD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,qDAAqD,EAAE,GAAG,EAAE,CAAC;QAChE,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;;;KAOD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,iCAAiC,EAAE,GAAG,EAAE,CAAC;QAC5C,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;KAED,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,IAAA,iBAAM,EAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;IAAA,CACjD,CAAC,CAAC;IAEH,6EAA6E;IAC7E,uEAAuE;IACvE,6EAA6E;IAE7E,IAAA,eAAI,EAAC,sCAAsC,EAAE,GAAG,EAAE,CAAC;QACjD,uDAAuD;QACvD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;KAKD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,yCAAyC,EAAE,GAAG,EAAE,CAAC;QACpD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;KAID,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,0CAA0C,EAAE,GAAG,EAAE,CAAC;QACrD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;;;KAOD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,mCAAmC,EAAE,GAAG,EAAE,CAAC;QAC9C,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;;KAMD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,6EAA6E;IAC7E,yDAAyD;IACzD,6EAA6E;IAE7E,IAAA,eAAI,EAAC,oCAAoC,EAAE,GAAG,EAAE,CAAC;QAC/C,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;KAID,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,0CAA0C,EAAE,GAAG,EAAE,CAAC;QACrD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;KAID,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,iCAAiC,EAAE,GAAG,EAAE,CAAC;QAC5C,gEAAgE;QAChE,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,wBAAwB,EAAE,GAAG,EAAE,CAAC;QACnC,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,kCAAkC,EAAE,GAAG,EAAE,CAAC;QAC7C,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;;KAMD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,6EAA6E;IAC7E,mEAAmE;IACnE,yEAAuE;IACvE,6EAA6E;IAE7E,IAAA,eAAI,EAAC,+CAA+C,EAAE,GAAG,EAAE,CAAC;QAC1D,iEAAiE;QACjE,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;KAKD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,8BAA8B,EAAE,GAAG,EAAE,CAAC;QACzC,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;KAKD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,+BAA+B,EAAE,GAAG,EAAE,CAAC;QAC1C,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;KAID,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,8BAA8B,EAAE,GAAG,EAAE,CAAC;QACzC,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;KAKD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,oCAAoC,EAAE,GAAG,EAAE,CAAC;QAC/C,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;KAID,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,uCAAuC,EAAE,GAAG,EAAE,CAAC;QAClD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;KAID,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,yCAAyC,EAAE,GAAG,EAAE,CAAC;QACpD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,wCAAwC,EAAE,GAAG,EAAE,CAAC;QACnD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,6EAA6E;IAC7E,iEAAiE;IACjE,6EAA6E;IAE7E,IAAA,eAAI,EAAC,8CAA8C,EAAE,GAAG,EAAE,CAAC;QACzD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,6CAA6C,EAAE,GAAG,EAAE,CAAC;QACxD,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,kDAAkD,EAAE,GAAG,EAAE,CAAC;QAC7D,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,gDAAgD,EAAE,GAAG,EAAE,CAAC;QAC3D,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,6EAA6E;IAC7E,8BAA8B;IAC9B,6EAA6E;IAE7E,IAAA,eAAI,EAAC,iDAAiD,EAAE,GAAG,EAAE,CAAC;QAC5D,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;KAKD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,6BAA6B,EAAE,GAAG,EAAE,CAAC;QACxC,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;KAKD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,6EAA6E;IAC7E,wCAAwC;IACxC,6EAA6E;IAE7E,IAAA,eAAI,EAAC,oDAAoD,EAAE,GAAG,EAAE,CAAC;QAC/D,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;;KAMD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,kCAAkC,EAAE,GAAG,EAAE,CAAC;QAC7C,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,mDAAmD,EAAE,GAAG,EAAE,CAAC;QAC9D,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,gCAAgC,EAAE,GAAG,EAAE,CAAC;QAC3C,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;KAGD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,4DAA4D,EAAE,GAAG,EAAE,CAAC;QACvE,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;;KAMD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,6EAA6E;IAC7E,wDAAwD;IACxD,6EAA6E;IAE7E,IAAA,eAAI,EAAC,iDAAiD,EAAE,GAAG,EAAE,CAAC;QAC5D,oEAAoE;QACpE,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;;;KAOD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;IAEH,IAAA,eAAI,EAAC,iDAAiD,EAAE,GAAG,EAAE,CAAC;QAC5D,4EAA4E;QAC5E,0EAA0E;QAC1E,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;;;KAOD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjC,IAAA,iBAAM,EACJ,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,mCAAmC,CAAC,CAAC,CAC3F,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACb,IAAA,iBAAM,EACJ,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,mCAAmC,CAAC,CAAC,CAC3F,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAAA,CACf,CAAC,CAAC;IACH,IAAA,eAAI,EAAC,yCAAyC,EAAE,GAAG,EAAE,CAAC;QACpD,oEAAoE;QACpE,MAAM,MAAM,GAAG,IAAA,6BAAa,EAC1B;;;;;KAKD,EACC,QAAQ,CACT,CAAC;QACF,IAAA,iBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC,CAAC,CAAC;AAAA,CACJ,CAAC,CAAC","sourcesContent":["import { describe, test, expect, beforeAll } from \"bun:test\";\nimport { z } from \"zod\";\nimport type { Tool } from \"ai\";\nimport { validateTypes } from \"./typeValidator\";\nimport { generateMuxTypes } from \"./typeGenerator\";\n\n/**\n * Create a mock tool with the given schema.\n */\nfunction createMockTool(schema: z.ZodType): Tool {\n  return {\n    description: \"Mock tool\",\n    inputSchema: schema,\n    execute: () => Promise.resolve({ success: true }),\n  } as unknown as Tool;\n}\n\ndescribe(\"validateTypes\", () => {\n  let muxTypes: string;\n\n  // Generate types once for all tests\n  beforeAll(async () => {\n    const tools = {\n      file_read: createMockTool(\n        z.object({\n          filePath: z.string(),\n          offset: z.number().optional(),\n          limit: z.number().optional(),\n        })\n      ),\n      bash: createMockTool(\n        z.object({\n          script: z.string(),\n          timeout_secs: z.number(),\n          run_in_background: z.boolean(),\n          display_name: z.string(),\n        })\n      ),\n    };\n    muxTypes = await generateMuxTypes(tools);\n  });\n\n  test(\"accepts valid code with correct property names\", () => {\n    const result = validateTypes(\n      `\n      const content = mux.file_read({ filePath: \"test.txt\" });\n      return content.success;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n    expect(result.errors).toHaveLength(0);\n  });\n\n  test(\"accepts code using optional properties\", () => {\n    const result = validateTypes(\n      `\n      mux.file_read({ filePath: \"test.txt\", offset: 10, limit: 50 });\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"catches wrong property name\", () => {\n    const result = validateTypes(\n      `\n      mux.file_read({ path: \"test.txt\" });\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(false);\n    // Error should mention 'path' doesn't exist or 'filePath' is missing\n    expect(\n      result.errors.some((e) => e.message.includes(\"path\") || e.message.includes(\"filePath\"))\n    ).toBe(true);\n  });\n\n  test(\"catches missing required property\", () => {\n    const result = validateTypes(\n      `\n      mux.bash({ script: \"ls\" });\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(false);\n    // Should error on missing required props\n    expect(result.errors.length).toBeGreaterThan(0);\n  });\n\n  test(\"catches wrong type for property\", () => {\n    const result = validateTypes(\n      `\n      mux.file_read({ filePath: 123 });\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(false);\n    expect(\n      result.errors.some((e) => e.message.includes(\"number\") || e.message.includes(\"string\"))\n    ).toBe(true);\n  });\n\n  test(\"catches calling non-existent tool\", () => {\n    const result = validateTypes(\n      `\n      mux.nonexistent_tool({ foo: \"bar\" });\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(false);\n    expect(result.errors.some((e) => e.message.includes(\"nonexistent_tool\"))).toBe(true);\n  });\n\n  test(\"returns line numbers for type errors\", () => {\n    const result = validateTypes(\n      `const x = 1;\nconst y = 2;\nmux.file_read({ path: \"test.txt\" });`,\n      muxTypes\n    );\n    expect(result.valid).toBe(false);\n    // Error should be on line 3 (the mux.file_read call)\n    const errorWithLine = result.errors.find((e) => e.line !== undefined);\n    expect(errorWithLine).toBeDefined();\n    expect(errorWithLine!.line).toBe(3);\n  });\n\n  test(\"returns line 1 for error on first line\", () => {\n    const result = validateTypes(`mux.file_read({ path: \"test.txt\" });`, muxTypes);\n    expect(result.valid).toBe(false);\n    const errorWithLine = result.errors.find((e) => e.line !== undefined);\n    expect(errorWithLine).toBeDefined();\n    expect(errorWithLine!.line).toBe(1);\n  });\n\n  test(\"returns correct line for error on last line of multi-line code\", () => {\n    const result = validateTypes(\n      `const a = 1;\nconst b = 2;\nconst c = 3;\nconst d = 4;\nmux.file_read({ path: \"wrong\" });`,\n      muxTypes\n    );\n    expect(result.valid).toBe(false);\n    const errorWithLine = result.errors.find((e) => e.line !== undefined);\n    expect(errorWithLine).toBeDefined();\n    expect(errorWithLine!.line).toBe(5);\n  });\n\n  test(\"returns column number for type errors\", () => {\n    // Column should point to the problematic property\n    const result = validateTypes(`mux.file_read({ path: \"test.txt\" });`, muxTypes);\n    expect(result.valid).toBe(false);\n    const errorWithLine = result.errors.find((e) => e.column !== undefined);\n    expect(errorWithLine).toBeDefined();\n    expect(errorWithLine!.column).toBeGreaterThan(0);\n  });\n\n  test(\"allows dynamic property access (no strict checking on unknown keys)\", () => {\n    const result = validateTypes(\n      `\n      const result = mux.file_read({ filePath: \"test.txt\" });\n      const key = \"content\";\n      console.log(result[key]);\n    `,\n      muxTypes\n    );\n    // This should pass - we don't enforce strict property checking on results\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows console.log/warn/error\", () => {\n    const result = validateTypes(\n      `\n      console.log(\"hello\");\n      console.warn(\"warning\");\n      console.error(\"error\");\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows dynamic properties on empty object literals\", () => {\n    // Claude frequently uses this pattern to collate parallel reads\n    const result = validateTypes(\n      `\n      const results = {};\n      results.file1 = mux.file_read({ filePath: \"a.txt\" });\n      results.file2 = mux.file_read({ filePath: \"b.txt\" });\n      return results;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"still catches mux tool typos\", () => {\n    // Must not filter errors for typos on the mux namespace\n    const result = validateTypes(\n      `\n      mux.file_reade({ filePath: \"test.txt\" });\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(false);\n    expect(result.errors.some((e) => e.message.includes(\"file_reade\"))).toBe(true);\n  });\n\n  test(\"catches reads from empty object literals (typos)\", () => {\n    // Reads from {} should still error - only writes are allowed\n    const result = validateTypes(\n      `\n      const results = {};\n      results.file1 = mux.file_read({ filePath: \"a.txt\" });\n      return results.filee1;  // typo: should be file1\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(false);\n    expect(result.errors.some((e) => e.message.includes(\"filee1\"))).toBe(true);\n  });\n\n  test(\"catches empty object properties used in tool args\", () => {\n    // Using unset properties from {} in tool calls should error\n    const result = validateTypes(\n      `\n      const config = {};\n      mux.file_read({ filePath: config.path });  // config.path doesn't exist\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(false);\n    expect(result.errors.some((e) => e.message.includes(\"path\"))).toBe(true);\n  });\n\n  test(\"catches empty object reads in expressions\", () => {\n    // Reading from {} in any expression context should error\n    const result = validateTypes(\n      `\n      const obj = {};\n      const x = obj.value + 1;  // obj.value doesn't exist\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(false);\n    expect(result.errors.some((e) => e.message.includes(\"value\"))).toBe(true);\n  });\n\n  test(\"catches empty object reads in conditionals\", () => {\n    const result = validateTypes(\n      `\n      const obj = {};\n      if (obj.flag) { console.log(\"yes\"); }  // obj.flag doesn't exist\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(false);\n    expect(result.errors.some((e) => e.message.includes(\"flag\"))).toBe(true);\n  });\n\n  test(\"allows multiple writes to empty object\", () => {\n    const result = validateTypes(\n      `\n      const data = {};\n      data.a = 1;\n      data.b = 2;\n      data.c = mux.file_read({ filePath: \"test.txt\" });\n      data.d = \"string\";\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"catches compound assignment on empty object (+=)\", () => {\n    // Compound assignments read then write, so should error\n    const result = validateTypes(\n      `\n      const obj = {};\n      obj.count += 1;  // reads obj.count first\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(false);\n    expect(result.errors.some((e) => e.message.includes(\"count\"))).toBe(true);\n  });\n\n  test(\"accepts ES2021+ features (replaceAll, at, etc.)\", () => {\n    const result = validateTypes(\n      `\n      const str = \"a-b-c\".replaceAll(\"-\", \"_\");\n      const arr = [1, 2, 3];\n      const last = arr.at(-1);\n      const hasA = Object.hasOwn({ a: 1 }, \"a\");\n      return { str, last, hasA };\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows discriminated union narrowing with negation (!result.success)\", () => {\n    // This is the idiomatic pattern for handling Result types\n    const result = validateTypes(\n      `\n      const result = mux.file_read({ filePath: \"test.txt\" });\n      if (!result.success) {\n        console.log(result.error);  // Should be allowed after narrowing\n        return { error: result.error };\n      }\n      return { content: result.content };\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows discriminated union narrowing with === false\", () => {\n    const result = validateTypes(\n      `\n      const result = mux.file_read({ filePath: \"test.txt\" });\n      if (result.success === false) {\n        console.log(result.error);\n        return null;\n      }\n      return result.content;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"catches syntax error gracefully\", () => {\n    const result = validateTypes(\n      `\n      mux.file_read({ filePath: \"test.txt\" // missing closing brace\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(false);\n    expect(result.errors.length).toBeGreaterThan(0);\n  });\n\n  // ==========================================================================\n  // Empty array push/unshift patterns (regression tests for never[] fix)\n  // ==========================================================================\n\n  test(\"allows empty array with push pattern\", () => {\n    // Claude frequently collects results in an empty array\n    const result = validateTypes(\n      `\n      const results = [];\n      results.push(mux.file_read({ filePath: \"a.txt\" }));\n      results.push(mux.file_read({ filePath: \"b.txt\" }));\n      return results;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows empty array with unshift pattern\", () => {\n    const result = validateTypes(\n      `\n      const results = [];\n      results.unshift(mux.file_read({ filePath: \"a.txt\" }));\n      return results;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows empty array with push inside loop\", () => {\n    const result = validateTypes(\n      `\n      const files = [\"a.txt\", \"b.txt\"];\n      const results = [];\n      for (const f of files) {\n        results.push(mux.file_read({ filePath: f }));\n      }\n      return results;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows push with primitive values\", () => {\n    const result = validateTypes(\n      `\n      const arr = [];\n      arr.push(1);\n      arr.push(\"hello\");\n      arr.push({ foo: \"bar\" });\n      return arr;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  // ==========================================================================\n  // Patterns that must continue to work (regression tests)\n  // ==========================================================================\n\n  test(\"allows untyped function parameters\", () => {\n    const result = validateTypes(\n      `\n      function process(x) { return x.success; }\n      const r = mux.file_read({ filePath: \"test.txt\" });\n      return process(r);\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows untyped arrow function parameters\", () => {\n    const result = validateTypes(\n      `\n      const process = (x) => x.success;\n      const r = mux.file_read({ filePath: \"test.txt\" });\n      return process(r);\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows destructuring parameters\", () => {\n    // Test that untyped destructuring params work (no TS7031 error)\n    const result = validateTypes(\n      `\n      function processArgs({ a, b }) { return a + b; }\n      return processArgs({ a: 1, b: 2 });\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows rest parameters\", () => {\n    const result = validateTypes(\n      `\n      function all(...args) { return args.length; }\n      return all(1, 2, 3);\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows callbacks on typed arrays\", () => {\n    const result = validateTypes(\n      `\n      const nums = [1, 2, 3];\n      const doubled = nums.map(x => x * 2);\n      const evens = nums.filter(x => x % 2 === 0);\n      nums.forEach(x => console.log(x));\n      return { doubled, evens };\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  // ==========================================================================\n  // Empty array operations beyond push/unshift (preprocessing tests)\n  // These patterns require the preprocessing approach ([] â†’ [] as any[])\n  // ==========================================================================\n\n  test(\"allows map on empty array that gets populated\", () => {\n    // Preprocessing transforms [] to [] as any[], so operations work\n    const result = validateTypes(\n      `\n      const results = [];\n      results.push(mux.file_read({ filePath: \"a.txt\" }));\n      results.push(mux.file_read({ filePath: \"b.txt\" }));\n      return results.map(r => r.success);\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows filter on empty array\", () => {\n    const result = validateTypes(\n      `\n      const results = [];\n      results.push(mux.file_read({ filePath: \"a.txt\" }));\n      results.push(mux.file_read({ filePath: \"b.txt\" }));\n      return results.filter(r => r.success);\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows forEach on empty array\", () => {\n    const result = validateTypes(\n      `\n      const results = [];\n      results.push(mux.file_read({ filePath: \"a.txt\" }));\n      results.forEach(r => console.log(r.success));\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows spread of empty array\", () => {\n    const result = validateTypes(\n      `\n      const arr = [];\n      arr.push(1);\n      const copy = [...arr];\n      return copy;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows index access on empty array\", () => {\n    const result = validateTypes(\n      `\n      const arr = [];\n      arr.push(\"hello\");\n      return arr[0];\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows empty array in object property\", () => {\n    const result = validateTypes(\n      `\n      const obj = { items: [] };\n      obj.items.push(1);\n      return obj;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows empty array as function argument\", () => {\n    const result = validateTypes(\n      `\n      function process(arr) { return arr.length; }\n      return process([]);\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"allows empty array in return statement\", () => {\n    const result = validateTypes(\n      `\n      function empty() { return []; }\n      return empty();\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  // ==========================================================================\n  // Empty array literal access patterns (parenthesized assertions)\n  // ==========================================================================\n\n  test(\"handles member access on empty array literal\", () => {\n    const result = validateTypes(\n      `\n      const mapped = [].map((x) => x);\n      return mapped;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"handles index access on empty array literal\", () => {\n    const result = validateTypes(\n      `\n      const first = [][0];\n      return first;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"handles optional chaining on empty array literal\", () => {\n    const result = validateTypes(\n      `\n      const length = []?.length;\n      return length;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"handles property access on empty array literal\", () => {\n    const result = validateTypes(\n      `\n      const length = [].length;\n      return length;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  // ==========================================================================\n  // Multiple arrays and nesting\n  // ==========================================================================\n\n  test(\"handles multiple empty arrays in same statement\", () => {\n    const result = validateTypes(\n      `\n      const a = [], b = [];\n      a.push(1);\n      b.push(\"hello\");\n      return { a, b };\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"handles nested empty arrays\", () => {\n    const result = validateTypes(\n      `\n      const matrix = [];\n      matrix.push([]);\n      matrix[0].push(1);\n      return matrix;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  // ==========================================================================\n  // Logical expressions with empty arrays\n  // ==========================================================================\n\n  test(\"still fixes empty arrays in logical OR expressions\", () => {\n    const result = validateTypes(\n      `\n      const condition = Math.random() > 0.5;\n      const maybe = condition ? [] : null;\n      const nums = maybe || [1];\n      nums.push(2);\n      return nums;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"preserves typeof on empty arrays\", () => {\n    const result = validateTypes(\n      `\n      const t = typeof [];\n      return t.toUpperCase();\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"preserves unary numeric operators on empty arrays\", () => {\n    const result = validateTypes(\n      `\n      const value = +[];\n      return value;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"preserves void on empty arrays\", () => {\n    const result = validateTypes(\n      `\n      const value = void [];\n      return value;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"still fixes empty arrays in nullish coalescing expressions\", () => {\n    const result = validateTypes(\n      `\n      const condition = Math.random() > 0.5;\n      const maybe = condition ? [] : undefined;\n      const nums = maybe ?? [1];\n      nums.push(2);\n      return nums;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  // ==========================================================================\n  // Destructuring patterns (valid JS that must not break)\n  // ==========================================================================\n\n  test(\"handles empty array destructuring in for-of LHS\", () => {\n    // for-of allows destructuring patterns directly in the loop header.\n    const result = validateTypes(\n      `\n      const items = [[1], [2]];\n      let count = 0;\n      for ([] of items) {\n        count += 1;\n      }\n      return count;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n\n  test(\"handles empty array destructuring in for-in LHS\", () => {\n    // for-in does not allow destructuring patterns in TypeScript, but the error\n    // should remain about the pattern (not a rewritten `as any[]` assertion).\n    const result = validateTypes(\n      `\n      const obj = { a: 1, b: 2 };\n      let count = 0;\n      for ([] in obj) {\n        count += 1;\n      }\n      return count;\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(false);\n    expect(\n      result.errors.some((error) => error.message.includes(\"cannot be a destructuring pattern\"))\n    ).toBe(true);\n    expect(\n      result.errors.some((error) => error.message.includes('must be of type \"string\" or \"any\"'))\n    ).toBe(false);\n  });\n  test(\"handles destructuring assignment on LHS\", () => {\n    // ([] = foo) should not become ([] as any[] = foo) which is invalid\n    const result = validateTypes(\n      `\n      let foo = [1, 2, 3];\n      let a, b;\n      ([a, b] = foo);\n      return [a, b];\n    `,\n      muxTypes\n    );\n    expect(result.valid).toBe(true);\n  });\n});\n"]}