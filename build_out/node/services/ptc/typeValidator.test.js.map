{"version":3,"file":"typeValidator.test.js","sourceRoot":"","sources":["../../../../src/node/services/ptc/typeValidator.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, test, expect, beforeAll } from \"bun:test\";\r\nimport { z } from \"zod\";\r\nimport type { Tool } from \"ai\";\r\nimport { validateTypes } from \"./typeValidator\";\r\nimport { generateMuxTypes } from \"./typeGenerator\";\r\n\r\n/**\r\n * Create a mock tool with the given schema.\r\n */\r\nfunction createMockTool(schema: z.ZodType): Tool {\r\n  return {\r\n    description: \"Mock tool\",\r\n    inputSchema: schema,\r\n    execute: () => Promise.resolve({ success: true }),\r\n  } as unknown as Tool;\r\n}\r\n\r\ndescribe(\"validateTypes\", () => {\r\n  let muxTypes: string;\r\n\r\n  // Generate types once for all tests\r\n  beforeAll(async () => {\r\n    const tools = {\r\n      file_read: createMockTool(\r\n        z.object({\r\n          filePath: z.string(),\r\n          offset: z.number().optional(),\r\n          limit: z.number().optional(),\r\n        })\r\n      ),\r\n      bash: createMockTool(\r\n        z.object({\r\n          script: z.string(),\r\n          timeout_secs: z.number(),\r\n          run_in_background: z.boolean(),\r\n          display_name: z.string(),\r\n        })\r\n      ),\r\n    };\r\n    muxTypes = await generateMuxTypes(tools);\r\n  });\r\n\r\n  test(\"accepts valid code with correct property names\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const content = mux.file_read({ filePath: \"test.txt\" });\r\n      return content.success;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n    expect(result.errors).toHaveLength(0);\r\n  });\r\n\r\n  test(\"accepts code using optional properties\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      mux.file_read({ filePath: \"test.txt\", offset: 10, limit: 50 });\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"catches wrong property name\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      mux.file_read({ path: \"test.txt\" });\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(false);\r\n    // Error should mention 'path' doesn't exist or 'filePath' is missing\r\n    expect(\r\n      result.errors.some((e) => e.message.includes(\"path\") || e.message.includes(\"filePath\"))\r\n    ).toBe(true);\r\n  });\r\n\r\n  test(\"catches missing required property\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      mux.bash({ script: \"ls\" });\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(false);\r\n    // Should error on missing required props\r\n    expect(result.errors.length).toBeGreaterThan(0);\r\n  });\r\n\r\n  test(\"catches wrong type for property\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      mux.file_read({ filePath: 123 });\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(false);\r\n    expect(\r\n      result.errors.some((e) => e.message.includes(\"number\") || e.message.includes(\"string\"))\r\n    ).toBe(true);\r\n  });\r\n\r\n  test(\"catches calling non-existent tool\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      mux.nonexistent_tool({ foo: \"bar\" });\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(false);\r\n    expect(result.errors.some((e) => e.message.includes(\"nonexistent_tool\"))).toBe(true);\r\n  });\r\n\r\n  test(\"returns line numbers for type errors\", () => {\r\n    const result = validateTypes(\r\n      `const x = 1;\r\nconst y = 2;\r\nmux.file_read({ path: \"test.txt\" });`,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(false);\r\n    // Error should be on line 3 (the mux.file_read call)\r\n    const errorWithLine = result.errors.find((e) => e.line !== undefined);\r\n    expect(errorWithLine).toBeDefined();\r\n    expect(errorWithLine!.line).toBe(3);\r\n  });\r\n\r\n  test(\"returns line 1 for error on first line\", () => {\r\n    const result = validateTypes(`mux.file_read({ path: \"test.txt\" });`, muxTypes);\r\n    expect(result.valid).toBe(false);\r\n    const errorWithLine = result.errors.find((e) => e.line !== undefined);\r\n    expect(errorWithLine).toBeDefined();\r\n    expect(errorWithLine!.line).toBe(1);\r\n  });\r\n\r\n  test(\"returns correct line for error on last line of multi-line code\", () => {\r\n    const result = validateTypes(\r\n      `const a = 1;\r\nconst b = 2;\r\nconst c = 3;\r\nconst d = 4;\r\nmux.file_read({ path: \"wrong\" });`,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(false);\r\n    const errorWithLine = result.errors.find((e) => e.line !== undefined);\r\n    expect(errorWithLine).toBeDefined();\r\n    expect(errorWithLine!.line).toBe(5);\r\n  });\r\n\r\n  test(\"returns column number for type errors\", () => {\r\n    // Column should point to the problematic property\r\n    const result = validateTypes(`mux.file_read({ path: \"test.txt\" });`, muxTypes);\r\n    expect(result.valid).toBe(false);\r\n    const errorWithLine = result.errors.find((e) => e.column !== undefined);\r\n    expect(errorWithLine).toBeDefined();\r\n    expect(errorWithLine!.column).toBeGreaterThan(0);\r\n  });\r\n\r\n  test(\"allows dynamic property access (no strict checking on unknown keys)\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const result = mux.file_read({ filePath: \"test.txt\" });\r\n      const key = \"content\";\r\n      console.log(result[key]);\r\n    `,\r\n      muxTypes\r\n    );\r\n    // This should pass - we don't enforce strict property checking on results\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows console.log/warn/error\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      console.log(\"hello\");\r\n      console.warn(\"warning\");\r\n      console.error(\"error\");\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows dynamic properties on empty object literals\", () => {\r\n    // Claude frequently uses this pattern to collate parallel reads\r\n    const result = validateTypes(\r\n      `\r\n      const results = {};\r\n      results.file1 = mux.file_read({ filePath: \"a.txt\" });\r\n      results.file2 = mux.file_read({ filePath: \"b.txt\" });\r\n      return results;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"still catches mux tool typos\", () => {\r\n    // Must not filter errors for typos on the mux namespace\r\n    const result = validateTypes(\r\n      `\r\n      mux.file_reade({ filePath: \"test.txt\" });\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(false);\r\n    expect(result.errors.some((e) => e.message.includes(\"file_reade\"))).toBe(true);\r\n  });\r\n\r\n  test(\"catches reads from empty object literals (typos)\", () => {\r\n    // Reads from {} should still error - only writes are allowed\r\n    const result = validateTypes(\r\n      `\r\n      const results = {};\r\n      results.file1 = mux.file_read({ filePath: \"a.txt\" });\r\n      return results.filee1;  // typo: should be file1\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(false);\r\n    expect(result.errors.some((e) => e.message.includes(\"filee1\"))).toBe(true);\r\n  });\r\n\r\n  test(\"catches empty object properties used in tool args\", () => {\r\n    // Using unset properties from {} in tool calls should error\r\n    const result = validateTypes(\r\n      `\r\n      const config = {};\r\n      mux.file_read({ filePath: config.path });  // config.path doesn't exist\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(false);\r\n    expect(result.errors.some((e) => e.message.includes(\"path\"))).toBe(true);\r\n  });\r\n\r\n  test(\"catches empty object reads in expressions\", () => {\r\n    // Reading from {} in any expression context should error\r\n    const result = validateTypes(\r\n      `\r\n      const obj = {};\r\n      const x = obj.value + 1;  // obj.value doesn't exist\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(false);\r\n    expect(result.errors.some((e) => e.message.includes(\"value\"))).toBe(true);\r\n  });\r\n\r\n  test(\"catches empty object reads in conditionals\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const obj = {};\r\n      if (obj.flag) { console.log(\"yes\"); }  // obj.flag doesn't exist\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(false);\r\n    expect(result.errors.some((e) => e.message.includes(\"flag\"))).toBe(true);\r\n  });\r\n\r\n  test(\"allows multiple writes to empty object\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const data = {};\r\n      data.a = 1;\r\n      data.b = 2;\r\n      data.c = mux.file_read({ filePath: \"test.txt\" });\r\n      data.d = \"string\";\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"catches compound assignment on empty object (+=)\", () => {\r\n    // Compound assignments read then write, so should error\r\n    const result = validateTypes(\r\n      `\r\n      const obj = {};\r\n      obj.count += 1;  // reads obj.count first\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(false);\r\n    expect(result.errors.some((e) => e.message.includes(\"count\"))).toBe(true);\r\n  });\r\n\r\n  test(\"accepts ES2021+ features (replaceAll, at, etc.)\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const str = \"a-b-c\".replaceAll(\"-\", \"_\");\r\n      const arr = [1, 2, 3];\r\n      const last = arr.at(-1);\r\n      const hasA = Object.hasOwn({ a: 1 }, \"a\");\r\n      return { str, last, hasA };\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows discriminated union narrowing with negation (!result.success)\", () => {\r\n    // This is the idiomatic pattern for handling Result types\r\n    const result = validateTypes(\r\n      `\r\n      const result = mux.file_read({ filePath: \"test.txt\" });\r\n      if (!result.success) {\r\n        console.log(result.error);  // Should be allowed after narrowing\r\n        return { error: result.error };\r\n      }\r\n      return { content: result.content };\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows discriminated union narrowing with === false\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const result = mux.file_read({ filePath: \"test.txt\" });\r\n      if (result.success === false) {\r\n        console.log(result.error);\r\n        return null;\r\n      }\r\n      return result.content;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"catches syntax error gracefully\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      mux.file_read({ filePath: \"test.txt\" // missing closing brace\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(false);\r\n    expect(result.errors.length).toBeGreaterThan(0);\r\n  });\r\n\r\n  // ==========================================================================\r\n  // Empty array push/unshift patterns (regression tests for never[] fix)\r\n  // ==========================================================================\r\n\r\n  test(\"allows empty array with push pattern\", () => {\r\n    // Claude frequently collects results in an empty array\r\n    const result = validateTypes(\r\n      `\r\n      const results = [];\r\n      results.push(mux.file_read({ filePath: \"a.txt\" }));\r\n      results.push(mux.file_read({ filePath: \"b.txt\" }));\r\n      return results;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows empty array with unshift pattern\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const results = [];\r\n      results.unshift(mux.file_read({ filePath: \"a.txt\" }));\r\n      return results;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows empty array with push inside loop\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const files = [\"a.txt\", \"b.txt\"];\r\n      const results = [];\r\n      for (const f of files) {\r\n        results.push(mux.file_read({ filePath: f }));\r\n      }\r\n      return results;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows push with primitive values\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const arr = [];\r\n      arr.push(1);\r\n      arr.push(\"hello\");\r\n      arr.push({ foo: \"bar\" });\r\n      return arr;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  // ==========================================================================\r\n  // Patterns that must continue to work (regression tests)\r\n  // ==========================================================================\r\n\r\n  test(\"allows untyped function parameters\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      function process(x) { return x.success; }\r\n      const r = mux.file_read({ filePath: \"test.txt\" });\r\n      return process(r);\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows untyped arrow function parameters\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const process = (x) => x.success;\r\n      const r = mux.file_read({ filePath: \"test.txt\" });\r\n      return process(r);\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows destructuring parameters\", () => {\r\n    // Test that untyped destructuring params work (no TS7031 error)\r\n    const result = validateTypes(\r\n      `\r\n      function processArgs({ a, b }) { return a + b; }\r\n      return processArgs({ a: 1, b: 2 });\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows rest parameters\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      function all(...args) { return args.length; }\r\n      return all(1, 2, 3);\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows callbacks on typed arrays\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const nums = [1, 2, 3];\r\n      const doubled = nums.map(x => x * 2);\r\n      const evens = nums.filter(x => x % 2 === 0);\r\n      nums.forEach(x => console.log(x));\r\n      return { doubled, evens };\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  // ==========================================================================\r\n  // Empty array operations beyond push/unshift (preprocessing tests)\r\n  // These patterns require the preprocessing approach ([] â†’ [] as any[])\r\n  // ==========================================================================\r\n\r\n  test(\"allows map on empty array that gets populated\", () => {\r\n    // Preprocessing transforms [] to [] as any[], so operations work\r\n    const result = validateTypes(\r\n      `\r\n      const results = [];\r\n      results.push(mux.file_read({ filePath: \"a.txt\" }));\r\n      results.push(mux.file_read({ filePath: \"b.txt\" }));\r\n      return results.map(r => r.success);\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows filter on empty array\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const results = [];\r\n      results.push(mux.file_read({ filePath: \"a.txt\" }));\r\n      results.push(mux.file_read({ filePath: \"b.txt\" }));\r\n      return results.filter(r => r.success);\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows forEach on empty array\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const results = [];\r\n      results.push(mux.file_read({ filePath: \"a.txt\" }));\r\n      results.forEach(r => console.log(r.success));\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows spread of empty array\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const arr = [];\r\n      arr.push(1);\r\n      const copy = [...arr];\r\n      return copy;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows index access on empty array\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const arr = [];\r\n      arr.push(\"hello\");\r\n      return arr[0];\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows empty array in object property\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const obj = { items: [] };\r\n      obj.items.push(1);\r\n      return obj;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows empty array as function argument\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      function process(arr) { return arr.length; }\r\n      return process([]);\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"allows empty array in return statement\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      function empty() { return []; }\r\n      return empty();\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  // ==========================================================================\r\n  // Empty array literal access patterns (parenthesized assertions)\r\n  // ==========================================================================\r\n\r\n  test(\"handles member access on empty array literal\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const mapped = [].map((x) => x);\r\n      return mapped;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"handles index access on empty array literal\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const first = [][0];\r\n      return first;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"handles optional chaining on empty array literal\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const length = []?.length;\r\n      return length;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"handles property access on empty array literal\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const length = [].length;\r\n      return length;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  // ==========================================================================\r\n  // Multiple arrays and nesting\r\n  // ==========================================================================\r\n\r\n  test(\"handles multiple empty arrays in same statement\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const a = [], b = [];\r\n      a.push(1);\r\n      b.push(\"hello\");\r\n      return { a, b };\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"handles nested empty arrays\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const matrix = [];\r\n      matrix.push([]);\r\n      matrix[0].push(1);\r\n      return matrix;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  // ==========================================================================\r\n  // Logical expressions with empty arrays\r\n  // ==========================================================================\r\n\r\n  test(\"still fixes empty arrays in logical OR expressions\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const condition = Math.random() > 0.5;\r\n      const maybe = condition ? [] : null;\r\n      const nums = maybe || [1];\r\n      nums.push(2);\r\n      return nums;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"preserves typeof on empty arrays\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const t = typeof [];\r\n      return t.toUpperCase();\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"preserves unary numeric operators on empty arrays\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const value = +[];\r\n      return value;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"preserves void on empty arrays\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const value = void [];\r\n      return value;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"still fixes empty arrays in nullish coalescing expressions\", () => {\r\n    const result = validateTypes(\r\n      `\r\n      const condition = Math.random() > 0.5;\r\n      const maybe = condition ? [] : undefined;\r\n      const nums = maybe ?? [1];\r\n      nums.push(2);\r\n      return nums;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  // ==========================================================================\r\n  // Destructuring patterns (valid JS that must not break)\r\n  // ==========================================================================\r\n\r\n  test(\"handles empty array destructuring in for-of LHS\", () => {\r\n    // for-of allows destructuring patterns directly in the loop header.\r\n    const result = validateTypes(\r\n      `\r\n      const items = [[1], [2]];\r\n      let count = 0;\r\n      for ([] of items) {\r\n        count += 1;\r\n      }\r\n      return count;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  test(\"handles empty array destructuring in for-in LHS\", () => {\r\n    // for-in does not allow destructuring patterns in TypeScript, but the error\r\n    // should remain about the pattern (not a rewritten `as any[]` assertion).\r\n    const result = validateTypes(\r\n      `\r\n      const obj = { a: 1, b: 2 };\r\n      let count = 0;\r\n      for ([] in obj) {\r\n        count += 1;\r\n      }\r\n      return count;\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(false);\r\n    expect(\r\n      result.errors.some((error) => error.message.includes(\"cannot be a destructuring pattern\"))\r\n    ).toBe(true);\r\n    expect(\r\n      result.errors.some((error) => error.message.includes('must be of type \"string\" or \"any\"'))\r\n    ).toBe(false);\r\n  });\r\n  test(\"handles destructuring assignment on LHS\", () => {\r\n    // ([] = foo) should not become ([] as any[] = foo) which is invalid\r\n    const result = validateTypes(\r\n      `\r\n      let foo = [1, 2, 3];\r\n      let a, b;\r\n      ([a, b] = foo);\r\n      return [a, b];\r\n    `,\r\n      muxTypes\r\n    );\r\n    expect(result.valid).toBe(true);\r\n  });\r\n});\r\n"]}