{"version":3,"file":"typeValidator.js","sourceRoot":"","sources":["../../../../src/node/services/ptc/typeValidator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * TypeScript Type Validator for PTC\n *\n * Validates agent-generated JavaScript code against generated type definitions.\n * Catches type errors before execution:\n * - Wrong property names\n * - Missing required arguments\n * - Wrong types for arguments\n * - Calling non-existent tools\n */\n\n/* eslint-disable local/no-sync-fs-methods -- TypeScript's CompilerHost API requires synchronous file operations */\nimport fs from \"fs\";\nimport path from \"path\";\nimport ts from \"typescript\";\n\n/**\n * In production builds, lib files are copied to dist/typescript-lib/ with .d.ts.txt extension\n * because electron-builder ignores .d.ts files by default (hardcoded, cannot override):\n * https://github.com/electron-userland/electron-builder/issues/5064\n *\n * These constants are computed once at module load time.\n */\nconst BUNDLED_LIB_DIR = path.resolve(__dirname, \"../../../typescript-lib\");\nconst IS_PRODUCTION = fs.existsSync(path.join(BUNDLED_LIB_DIR, \"lib.es2023.d.ts.txt\"));\nconst LIB_DIR = IS_PRODUCTION\n  ? BUNDLED_LIB_DIR\n  : path.dirname(require.resolve(\"typescript/lib/lib.d.ts\"));\n\nexport const WRAPPER_PREFIX = \"function __agent__() {\\n\";\nconst MUX_TYPES_FILE = \"mux.d.ts\";\nconst ROOT_FILE_NAMES = [\"agent.ts\", MUX_TYPES_FILE];\n\n// Cache lib and mux type SourceFiles across validations to avoid re-parsing.\nconst libSourceFileCache = new Map<string, ts.SourceFile>();\nconst muxSourceFileCache = new Map<string, ts.SourceFile>();\n\nfunction wrapAgentCode(code: string): string {\n  return `${WRAPPER_PREFIX}${code}\\n}\\n`;\n}\n\nconst getLibCacheKey = (fileName: string, languageVersion: ts.ScriptTarget): string =>\n  `${languageVersion}:${fileName}`;\n\nfunction getCachedLibSourceFile(\n  fileName: string,\n  languageVersion: ts.ScriptTarget,\n  readFile: () => string | undefined\n): ts.SourceFile | undefined {\n  const key = getLibCacheKey(fileName, languageVersion);\n  const cached = libSourceFileCache.get(key);\n  if (cached) return cached;\n\n  const contents = readFile();\n  if (!contents) return undefined;\n\n  const sourceFile = ts.createSourceFile(fileName, contents, languageVersion, true);\n  libSourceFileCache.set(key, sourceFile);\n  return sourceFile;\n}\n\nfunction getCachedMuxSourceFile(muxTypes: string, languageVersion: ts.ScriptTarget): ts.SourceFile {\n  const key = `${languageVersion}:${muxTypes}`;\n  const cached = muxSourceFileCache.get(key);\n  if (cached) return cached;\n\n  const sourceFile = ts.createSourceFile(MUX_TYPES_FILE, muxTypes, languageVersion, true);\n  muxSourceFileCache.set(key, sourceFile);\n  return sourceFile;\n}\n/** Resolve lib file path, accounting for .d.ts rename in production */\nconst resolveLibPath = (fileName: string): string => {\n  const libFileName = path.basename(fileName);\n  const actualName = IS_PRODUCTION ? toProductionLibName(libFileName) : libFileName;\n  return path.join(LIB_DIR, actualName);\n};\n\nfunction createProgramForCode(\n  wrappedCode: string,\n  muxTypes: string,\n  compilerOptions: ts.CompilerOptions\n): {\n  program: ts.Program;\n  host: ts.CompilerHost;\n  getSourceFile: () => ts.SourceFile;\n  setSourceFile: (newWrappedCode: string) => void;\n} {\n  const scriptTarget = compilerOptions.target ?? ts.ScriptTarget.ES2020;\n  let sourceFile = ts.createSourceFile(\"agent.ts\", wrappedCode, scriptTarget, true);\n  const muxSourceFile = getCachedMuxSourceFile(muxTypes, scriptTarget);\n  const setSourceFile = (newWrappedCode: string) => {\n    sourceFile = ts.createSourceFile(\"agent.ts\", newWrappedCode, scriptTarget, true);\n  };\n  const host = ts.createCompilerHost(compilerOptions);\n\n  // Override to read lib files from our bundled directory\n  host.getDefaultLibLocation = () => LIB_DIR;\n  host.getDefaultLibFileName = (options) => path.join(LIB_DIR, ts.getDefaultLibFileName(options));\n\n  const originalGetSourceFile = host.getSourceFile.bind(host);\n  const originalFileExists = host.fileExists.bind(host);\n  const originalReadFile = host.readFile.bind(host);\n\n  host.getSourceFile = (fileName, languageVersionOrOptions, onError, shouldCreateNewSourceFile) => {\n    // languageVersionOrOptions can be ScriptTarget or CreateSourceFileOptions\n    const target =\n      typeof languageVersionOrOptions === \"number\" ? languageVersionOrOptions : scriptTarget;\n    if (fileName === \"agent.ts\") return sourceFile;\n    if (fileName === MUX_TYPES_FILE) return muxSourceFile;\n\n    const isLibFile = fileName.includes(\"lib.\") && fileName.endsWith(\".d.ts\");\n    if (isLibFile) {\n      const cached = getCachedLibSourceFile(fileName, target, () => {\n        if (IS_PRODUCTION) {\n          const libPath = resolveLibPath(fileName);\n          return fs.existsSync(libPath) ? fs.readFileSync(libPath, \"utf-8\") : undefined;\n        }\n        return originalReadFile(fileName) ?? undefined;\n      });\n      if (cached) return cached;\n    }\n\n    return originalGetSourceFile(\n      fileName,\n      languageVersionOrOptions,\n      onError,\n      shouldCreateNewSourceFile\n    );\n  };\n  host.fileExists = (fileName) => {\n    if (fileName === \"agent.ts\" || fileName === MUX_TYPES_FILE) return true;\n    // In production, check bundled lib directory for lib files\n    if (IS_PRODUCTION && fileName.includes(\"lib.\") && fileName.endsWith(\".d.ts\")) {\n      return fs.existsSync(resolveLibPath(fileName));\n    }\n    return originalFileExists(fileName);\n  };\n  host.readFile = (fileName) => {\n    if (fileName === MUX_TYPES_FILE) return muxTypes;\n    // In production, read lib files from bundled directory\n    if (IS_PRODUCTION && fileName.includes(\"lib.\") && fileName.endsWith(\".d.ts\")) {\n      const libPath = resolveLibPath(fileName);\n      if (fs.existsSync(libPath)) {\n        return fs.readFileSync(libPath, \"utf-8\");\n      }\n    }\n    return originalReadFile(fileName);\n  };\n\n  const program = ts.createProgram(ROOT_FILE_NAMES, compilerOptions, host);\n  return { program, host, getSourceFile: () => sourceFile, setSourceFile };\n}\n\n/** Convert lib filename for production: lib.X.d.ts → lib.X.d.ts.txt */\nfunction toProductionLibName(fileName: string): string {\n  return fileName + \".txt\";\n}\n\nexport interface TypeValidationError {\n  message: string;\n  line?: number;\n  column?: number;\n}\n\nexport interface TypeValidationResult {\n  valid: boolean;\n  errors: TypeValidationError[];\n  sourceFile?: ts.SourceFile;\n}\n\n/**\n * Validate JavaScript code against mux type definitions using TypeScript.\n *\n * @param code - JavaScript code to validate\n * @param muxTypes - Generated `.d.ts` content from generateMuxTypes()\n * @returns Validation result with errors if any\n */\n\n/**\n * Check if a TS2339 diagnostic is for a property WRITE on an empty object literal.\n * Returns true only for patterns like `results.foo = x` where `results` is typed as `{}`.\n * Returns false for reads like `return results.foo` or `fn(results.foo)`.\n */\nfunction isEmptyObjectWriteError(d: ts.Diagnostic, sourceFile: ts.SourceFile): boolean {\n  if (d.code !== 2339 || d.start === undefined) return false;\n  const message = ts.flattenDiagnosticMessageText(d.messageText, \"\");\n  if (!message.includes(\"on type '{}'\")) return false;\n\n  // Find the node at the error position and walk up to find context\n  const token = findTokenAtPosition(sourceFile, d.start);\n  if (!token) return false;\n\n  // Walk up to find PropertyAccessExpression containing this token\n  let propAccess: ts.PropertyAccessExpression | undefined;\n  let node: ts.Node = token;\n  while (node.parent) {\n    if (ts.isPropertyAccessExpression(node.parent)) {\n      propAccess = node.parent;\n      break;\n    }\n    node = node.parent;\n  }\n  if (!propAccess) return false;\n\n  // Check if this PropertyAccessExpression is on the left side of an assignment\n  const parent = propAccess.parent;\n  if (\n    ts.isBinaryExpression(parent) &&\n    parent.operatorToken.kind === ts.SyntaxKind.EqualsToken &&\n    parent.left === propAccess\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/** Find the innermost token at a position in the source file */\nfunction findTokenAtPosition(sourceFile: ts.SourceFile, position: number): ts.Node | undefined {\n  function find(node: ts.Node): ts.Node | undefined {\n    if (position < node.getStart(sourceFile) || position >= node.getEnd()) {\n      return undefined;\n    }\n    // Try to find a more specific child\n    const child = ts.forEachChild(node, find);\n    return child ?? node;\n  }\n  return find(sourceFile);\n}\n\n/** Returns true if the type resolves to a non-tuple never[] (including unions). */\nfunction isNeverArrayType(type: ts.Type, checker: ts.TypeChecker): boolean {\n  const nonNullable = checker.getNonNullableType(type);\n\n  if (nonNullable.isUnion()) {\n    return nonNullable.types.every((member) => isNeverArrayType(member, checker));\n  }\n\n  if (checker.isTupleType(nonNullable)) {\n    return false;\n  }\n\n  if (!checker.isArrayType(nonNullable)) {\n    return false;\n  }\n\n  const elementType = checker.getIndexTypeOfType(nonNullable, ts.IndexKind.Number);\n  return elementType !== undefined && (elementType.flags & ts.TypeFlags.Never) !== 0;\n}\n/**\n * Check if an empty array literal is in a position where adding `as any[]` would be invalid.\n * If true, we should NOT add `as any[]`.\n *\n * Note: We only check valid JavaScript patterns here. TypeScript-specific syntax\n * (type annotations, `as` expressions, etc.) cannot reach QuickJS execution, so\n * handling them here would be dead code.\n */\nfunction hasInvalidAssertionContext(node: ts.ArrayLiteralExpression): boolean {\n  const parent = node.parent;\n\n  // Skip: `const [] = x` (destructuring pattern - array is on LHS)\n  if (ts.isArrayBindingPattern(parent)) return true;\n\n  // Skip: `([] = foo)` (destructuring assignment - array on LHS of =)\n  // Adding `as any[]` here would produce invalid syntax: `([] as any[] = foo)`\n  if (\n    ts.isBinaryExpression(parent) &&\n    parent.operatorToken.kind === ts.SyntaxKind.EqualsToken &&\n    parent.left === node\n  ) {\n    return true;\n  }\n\n  // Skip: `for ([] of items)` / `for ([] in obj)` (array literal as loop LHS)\n  // Adding `as any[]` here would produce invalid syntax in the loop header.\n  if ((ts.isForOfStatement(parent) || ts.isForInStatement(parent)) && parent.initializer === node) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getNeverArrayLiteralStarts(\n  code: string,\n  sourceFile: ts.SourceFile,\n  checker: ts.TypeChecker\n): Set<number> {\n  const codeStart = WRAPPER_PREFIX.length;\n  const codeEnd = codeStart + code.length;\n  const starts = new Set<number>();\n\n  function visit(node: ts.Node) {\n    if (ts.isArrayLiteralExpression(node) && node.elements.length === 0) {\n      const start = node.getStart(sourceFile);\n      if (start >= codeStart && node.end <= codeEnd) {\n        const contextualType = checker.getContextualType(node);\n        const type = contextualType ?? checker.getTypeAtLocation(node);\n        if (isNeverArrayType(type, checker)) {\n          starts.add(start - codeStart);\n        }\n      }\n    }\n    ts.forEachChild(node, visit);\n  }\n\n  visit(sourceFile);\n  return starts;\n}\n\n/**\n * Preprocess agent code to add type assertions to empty array literals.\n *\n * TypeScript infers `[]` as `never[]` when `strictNullChecks: true` and `noImplicitAny: false`.\n * This is documented behavior (GitHub issues #36987, #13140, #50505, #51979).\n * The TypeScript team recommends using type assertions: `[] as any[]`.\n *\n * This function transforms `[]` → `[] as any[]` for untyped empty arrays, enabling\n * all array operations (push, map, forEach, etc.) to work without type errors.\n */\nfunction preprocessEmptyArrays(code: string, neverArrayStarts: Set<number>): string {\n  if (neverArrayStarts.size === 0) {\n    return code;\n  }\n\n  const sourceFile = ts.createSourceFile(\"temp.ts\", code, ts.ScriptTarget.Latest, true);\n  const edits: Array<{ pos: number; text: string }> = [];\n\n  function visit(node: ts.Node) {\n    if (ts.isArrayLiteralExpression(node) && node.elements.length === 0) {\n      const start = node.getStart(sourceFile);\n      if (neverArrayStarts.has(start) && !hasInvalidAssertionContext(node)) {\n        const parent = node.parent;\n        // `as` binds looser than unary operators, so wrap to keep the assertion on the literal.\n        const needsParens =\n          ts.isPropertyAccessExpression(parent) ||\n          ts.isPropertyAccessChain(parent) ||\n          ts.isElementAccessExpression(parent) ||\n          ts.isElementAccessChain(parent) ||\n          (ts.isCallExpression(parent) && parent.expression === node) ||\n          (ts.isCallChain(parent) && parent.expression === node) ||\n          ts.isPrefixUnaryExpression(parent) ||\n          ts.isPostfixUnaryExpression(parent) ||\n          ts.isTypeOfExpression(parent) ||\n          ts.isVoidExpression(parent) ||\n          ts.isDeleteExpression(parent) ||\n          ts.isAwaitExpression(parent) ||\n          ts.isYieldExpression(parent);\n\n        if (needsParens) {\n          edits.push({ pos: node.getStart(sourceFile), text: \"(\" });\n          edits.push({ pos: node.end, text: \" as any[])\" });\n        } else {\n          edits.push({ pos: node.end, text: \" as any[]\" });\n        }\n      }\n    }\n    ts.forEachChild(node, visit);\n  }\n\n  visit(sourceFile);\n\n  // Apply edits in reverse order to preserve positions\n  let result = code;\n  for (const edit of edits.sort((a, b) => b.pos - a.pos)) {\n    result = result.slice(0, edit.pos) + edit.text + result.slice(edit.pos);\n  }\n  return result;\n}\n\nexport function validateTypes(code: string, muxTypes: string): TypeValidationResult {\n  const compilerOptions: ts.CompilerOptions = {\n    noEmit: true,\n    strict: false, // Don't require explicit types on everything\n    strictNullChecks: true, // Enable discriminated union narrowing (e.g., `if (!result.success) { result.error }`)\n    noImplicitAny: false, // Allow any types\n    skipLibCheck: true,\n    target: ts.ScriptTarget.ES2020,\n    module: ts.ModuleKind.ESNext,\n    // ES2023 needed for Array.at(), findLast(), toSorted(), Object.hasOwn(), String.replaceAll()\n    // QuickJS 0.31+ supports these features at runtime\n    lib: [\"lib.es2023.d.ts\"],\n  };\n\n  // Preprocess empty arrays to avoid never[] inference without overriding contextual typing.\n  const originalWrappedCode = wrapAgentCode(code);\n  const {\n    program: originalProgram,\n    host,\n    getSourceFile,\n    setSourceFile,\n  } = createProgramForCode(originalWrappedCode, muxTypes, compilerOptions);\n  const originalSourceFile = getSourceFile();\n  const neverArrayStarts = getNeverArrayLiteralStarts(\n    code,\n    originalSourceFile,\n    originalProgram.getTypeChecker()\n  );\n  const preprocessedCode = preprocessEmptyArrays(code, neverArrayStarts);\n\n  // Wrap code in function to allow return statements (matches runtime behavior)\n  // Note: We don't use async because Asyncify makes mux.* calls appear synchronous\n  // Types live in a separate virtual file so error line numbers match agent code directly.\n  const wrappedCode = wrapAgentCode(preprocessedCode);\n\n  let program = originalProgram;\n  if (wrappedCode !== originalWrappedCode) {\n    setSourceFile(wrappedCode);\n    program = ts.createProgram(ROOT_FILE_NAMES, compilerOptions, host, originalProgram);\n  }\n\n  const sourceFile = program.getSourceFile(\"agent.ts\") ?? getSourceFile();\n  const diagnostics = ts.getPreEmitDiagnostics(program);\n\n  // Filter to errors in our code only (not lib files)\n  // Also filter console redeclaration warning (our minimal console conflicts with lib.dom)\n  const errors: TypeValidationError[] = diagnostics\n    .filter((d) => d.category === ts.DiagnosticCategory.Error)\n    .filter((d) => !d.file || d.file.fileName === \"agent.ts\")\n    .filter((d) => !ts.flattenDiagnosticMessageText(d.messageText, \"\").includes(\"console\"))\n    // Allow dynamic property WRITES on empty object literals - Claude frequently uses\n    // `const results = {}; results.foo = mux.file_read(...)` to collate parallel reads.\n    // Only suppress when the property access is on the LEFT side of an assignment.\n    // Reads like `return results.typo` must still error.\n    .filter((d) => !isEmptyObjectWriteError(d, sourceFile))\n    .map((d) => {\n      const message = ts.flattenDiagnosticMessageText(d.messageText, \" \");\n      // Extract line number if available\n      if (d.file && d.start !== undefined) {\n        const { line, character } = d.file.getLineAndCharacterOfPosition(d.start);\n        // TS line is 0-indexed. Wrapper adds 1 line before agent code, so:\n        // TS line 0 = wrapper, TS line 1 = agent line 1, TS line 2 = agent line 2, etc.\n        // This means TS 0-indexed line number equals agent 1-indexed line number.\n        // Only report if within agent code bounds (filter out wrapper and muxTypes)\n        const agentCodeLines = code.split(\"\\n\").length;\n        if (line >= 1 && line <= agentCodeLines) {\n          return { message, line, column: character + 1 };\n        }\n      }\n      return { message };\n    });\n\n  return { valid: errors.length === 0, errors, sourceFile: originalSourceFile };\n}\n"]}