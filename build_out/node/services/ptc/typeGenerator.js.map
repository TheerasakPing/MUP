{"version":3,"file":"typeGenerator.js","sourceRoot":"","sources":["../../../../src/node/services/ptc/typeGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Type Generator for PTC\r\n *\r\n * Generates `.d.ts` TypeScript declarations from tool schemas.\r\n * Used to:\r\n * 1. Inform the model about available tools and their signatures\r\n * 2. Validate agent code with TypeScript before QuickJS execution\r\n *\r\n * Input types are generated from Zod schemas via JSON Schema conversion.\r\n * Result types are generated from Zod schemas in toolDefinitions.ts (single source of truth).\r\n */\r\n\r\nimport { createHash } from \"crypto\";\r\nimport { z } from \"zod\";\r\nimport { compile } from \"json-schema-to-typescript\";\r\nimport type { Tool } from \"ai\";\r\nimport { RESULT_SCHEMAS, type BridgeableToolName } from \"@/common/utils/tools/toolDefinitions\";\r\n\r\n/**\r\n * MCP result type - protocol-defined, same for all MCP tools.\r\n */\r\nconst MCP_RESULT_TYPE = `type MCPCallToolResult = {\r\n  content: Array<\r\n    | { type: \"text\"; text: string }\r\n    | { type: \"image\"; data: string; mimeType: string }\r\n    | { type: \"resource\"; resource: { uri: string; text?: string; blob?: string } }\r\n  >;\r\n  isError?: boolean;\r\n};`;\r\n\r\n// ============================================================================\r\n// Caching\r\n// ============================================================================\r\n\r\n/**\r\n * Unified cache structure for all type generation artifacts.\r\n */\r\ninterface TypeCache {\r\n  /** Full generated .d.ts content, keyed by tool set hash */\r\n  fullTypes: Map<string, string>;\r\n  /** Individual result type strings, keyed by tool name */\r\n  resultTypes: Map<string, string>;\r\n}\r\n\r\nconst cache: TypeCache = {\r\n  fullTypes: new Map(),\r\n  resultTypes: new Map(),\r\n};\r\n\r\n/**\r\n * Clear all type caches. Call for test isolation or when tool schemas might have changed.\r\n */\r\nexport function clearTypeCache(): void {\r\n  cache.fullTypes.clear();\r\n  cache.resultTypes.clear();\r\n}\r\n\r\n/**\r\n * Hash tool definitions (names, schemas, descriptions) to detect when tools change.\r\n * This ensures cache invalidation when schemas are updated, not just when tool names change.\r\n */\r\nfunction hashToolDefinitions(tools: Record<string, Tool>): string {\r\n  const sortedNames = Object.keys(tools).sort();\r\n  const toolData = sortedNames.map((name) => {\r\n    const tool = tools[name];\r\n    return {\r\n      name,\r\n      schema: getInputJsonSchema(tool),\r\n      description: tool.description ?? \"\",\r\n    };\r\n  });\r\n  return createHash(\"md5\").update(JSON.stringify(toolData)).digest(\"hex\");\r\n}\r\n\r\n/**\r\n * Get cached mux types or generate new ones if tool definitions changed.\r\n */\r\nexport async function getCachedMuxTypes(tools: Record<string, Tool>): Promise<string> {\r\n  const hash = hashToolDefinitions(tools);\r\n  const cached = cache.fullTypes.get(hash);\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n\r\n  const types = await generateMuxTypes(tools);\r\n  cache.fullTypes.set(hash, types);\r\n  return types;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Convert snake_case or kebab-case to PascalCase.\r\n */\r\nfunction pascalCase(str: string): string {\r\n  return str\r\n    .split(/[_-]/)\r\n    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))\r\n    .join(\"\");\r\n}\r\n\r\n/**\r\n * Indent each line of a string.\r\n */\r\nfunction indent(str: string, spaces: number): string {\r\n  const pad = \" \".repeat(spaces);\r\n  return str\r\n    .split(\"\\n\")\r\n    .map((line) => (line.trim() ? pad + line : line))\r\n    .join(\"\\n\");\r\n}\r\n\r\n/**\r\n * Extract JSON Schema from a tool, handling both Zod schemas and raw JSON Schema.\r\n */\r\nfunction getInputJsonSchema(tool: Tool): object {\r\n  const toolRecord = tool as { inputSchema?: unknown; parameters?: unknown };\r\n  const schema = toolRecord.inputSchema ?? toolRecord.parameters;\r\n\r\n  if (!schema) {\r\n    return { type: \"object\", properties: {}, required: [] };\r\n  }\r\n\r\n  // Check if it's a Zod schema (has _def property)\r\n  if (typeof schema === \"object\" && \"_def\" in schema) {\r\n    return z.toJSONSchema(schema as z.ZodType);\r\n  }\r\n\r\n  // Already JSON Schema\r\n  return schema as object;\r\n}\r\n\r\n/**\r\n * Get result type string for a built-in tool.\r\n * Uses Zod schema → JSON Schema → TypeScript string pipeline.\r\n * Results are cached by tool name.\r\n *\r\n * @returns TypeScript type string or null if no schema exists\r\n */\r\nasync function getResultTypeString(toolName: string): Promise<string | null> {\r\n  // Check cache first\r\n  if (cache.resultTypes.has(toolName)) {\r\n    return cache.resultTypes.get(toolName)!;\r\n  }\r\n\r\n  // Check if this is a bridgeable tool with a known result schema\r\n  if (!(toolName in RESULT_SCHEMAS)) {\r\n    return null;\r\n  }\r\n  const schema = RESULT_SCHEMAS[toolName as BridgeableToolName];\r\n\r\n  // Convert Zod → JSON Schema → TypeScript\r\n  const jsonSchema = z.toJSONSchema(schema);\r\n  const tsOutput = await compile(\r\n    jsonSchema as Parameters<typeof compile>[0],\r\n    `${pascalCase(toolName)}Result`,\r\n    {\r\n      bannerComment: \"\",\r\n      ignoreMinAndMaxItems: true,\r\n    }\r\n  );\r\n\r\n  // Extract just the type definition body (after \"export type X = \")\r\n  // The compile output looks like: \"export type FooResult = { ... } | { ... };\"\r\n  // Use regex to match the declaration pattern, avoiding false matches on `=` in type body\r\n  const typeBodyRegex = /^export\\s+type\\s+\\w+\\s*=\\s*([\\s\\S]+?);?\\s*$/;\r\n  const match = typeBodyRegex.exec(tsOutput);\r\n  if (!match) return null;\r\n\r\n  const result = match[1].trim();\r\n\r\n  if (result) {\r\n    cache.resultTypes.set(toolName, result);\r\n  }\r\n  return result;\r\n}\r\n\r\n// ============================================================================\r\n// Main Generator\r\n// ============================================================================\r\n\r\n/**\r\n * Generate TypeScript declaration file content for all bridgeable tools.\r\n *\r\n * @param tools Record of tool name to Tool, already filtered to bridgeable tools only\r\n * @returns `.d.ts` content as a string\r\n */\r\nexport async function generateMuxTypes(tools: Record<string, Tool>): Promise<string> {\r\n  const lines: string[] = [\"declare namespace mux {\"];\r\n  let mcpToolsPresent = false;\r\n\r\n  // Sort tool names for deterministic output\r\n  const sortedNames = Object.keys(tools).sort();\r\n\r\n  for (const name of sortedNames) {\r\n    const tool = tools[name];\r\n    const isMcp = name.startsWith(\"mcp__\");\r\n\r\n    // Generate arg interface from JSON Schema\r\n    const inputSchema = getInputJsonSchema(tool);\r\n    const argsTypeName = `${pascalCase(name)}Args`;\r\n\r\n    try {\r\n      const argInterface = await compile(\r\n        inputSchema as Parameters<typeof compile>[0],\r\n        argsTypeName,\r\n        {\r\n          bannerComment: \"\",\r\n          ignoreMinAndMaxItems: true, // Clean Type[] instead of verbose tuple unions\r\n        }\r\n      );\r\n      // Strip \"export \" prefix and add to output\r\n      const stripped = argInterface.replace(/^export /gm, \"\");\r\n      lines.push(indent(stripped.trim(), 2));\r\n    } catch {\r\n      // Fallback for schemas that can't be compiled\r\n      lines.push(`  interface ${argsTypeName} { [key: string]: unknown; }`);\r\n    }\r\n\r\n    // Add JSDoc comment with tool description (first line only)\r\n    const description = tool.description ?? \"\";\r\n    if (description) {\r\n      const firstLine = description.split(\"\\n\")[0].trim();\r\n      if (firstLine) {\r\n        lines.push(`  /** ${firstLine} */`);\r\n      }\r\n    }\r\n\r\n    // Add function declaration with appropriate result type\r\n    // Note: Asyncify makes async host functions appear synchronous to QuickJS,\r\n    // so we declare them as returning T directly, not Promise<T>\r\n    if (isMcp) {\r\n      mcpToolsPresent = true;\r\n      lines.push(`  function ${name}(args: ${argsTypeName}): MCPCallToolResult;`);\r\n    } else {\r\n      const resultType = await getResultTypeString(name);\r\n      if (resultType) {\r\n        const resultTypeName = `${pascalCase(name)}Result`;\r\n        lines.push(`  type ${resultTypeName} = ${resultType};`);\r\n        lines.push(`  function ${name}(args: ${argsTypeName}): ${resultTypeName};`);\r\n      } else {\r\n        // Unknown tool - return unknown\r\n        lines.push(`  function ${name}(args: ${argsTypeName}): unknown;`);\r\n      }\r\n    }\r\n\r\n    lines.push(\"\"); // Blank line between tools\r\n  }\r\n\r\n  // Add MCP result type if any MCP tools are present\r\n  if (mcpToolsPresent) {\r\n    lines.push(indent(MCP_RESULT_TYPE, 2));\r\n    lines.push(\"\");\r\n  }\r\n\r\n  lines.push(\"}\");\r\n  lines.push(\"\");\r\n\r\n  // Add console global declaration\r\n  lines.push(\r\n    \"declare var console: { log(...args: unknown[]): void; warn(...args: unknown[]): void; error(...args: unknown[]): void };\"\r\n  );\r\n  lines.push(\"\");\r\n\r\n  return lines.join(\"\\n\");\r\n}\r\n"]}