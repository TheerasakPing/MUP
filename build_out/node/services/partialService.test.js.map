{"version":3,"file":"partialService.test.js","sourceRoot":"","sources":["../../../src/node/services/partialService.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/unbound-method */\nimport { describe, test, expect, beforeEach, afterEach, mock, spyOn } from \"bun:test\";\nimport { PartialService } from \"./partialService\";\nimport type { HistoryService } from \"./historyService\";\nimport type { Config } from \"@/node/config\";\nimport { createMuxMessage, type MuxMessage } from \"@/common/types/message\";\nimport { Ok } from \"@/common/types/result\";\nimport { createTestHistoryService } from \"./testHistoryService\";\nimport * as fs from \"fs/promises\";\nimport * as path from \"path\";\n\ndescribe(\"PartialService - Error Recovery\", () => {\n  let partialService: PartialService;\n  let config: Config;\n  let historyService: HistoryService;\n  let cleanup: () => Promise<void>;\n\n  beforeEach(async () => {\n    ({ config, historyService, cleanup } = await createTestHistoryService());\n    partialService = new PartialService(config, historyService);\n  });\n\n  afterEach(async () => {\n    await cleanup();\n  });\n\n  test(\"commitToHistory should strip error metadata and commit parts from errored partial\", async () => {\n    const workspaceId = \"test-workspace\";\n    const erroredPartial: MuxMessage = {\n      id: \"msg-1\",\n      role: \"assistant\",\n      metadata: {\n        historySequence: 1,\n        timestamp: Date.now(),\n        model: \"test-model\",\n        partial: true,\n        error: \"Stream error occurred\",\n        errorType: \"network\",\n      },\n      parts: [\n        { type: \"text\", text: \"Hello, I was processing when\" },\n        { type: \"text\", text: \" the error occurred\" },\n      ],\n    };\n\n    // Mock readPartial to return errored partial\n    partialService.readPartial = mock(() => Promise.resolve(erroredPartial));\n\n    // Mock deletePartial\n    partialService.deletePartial = mock(() => Promise.resolve(Ok(undefined)));\n\n    // Spy on historyService methods to verify calls\n    const appendSpy = spyOn(historyService, \"appendToHistory\");\n\n    // Call commitToHistory\n    const result = await partialService.commitToHistory(workspaceId);\n\n    // Should succeed\n    expect(result.success).toBe(true);\n\n    // Should have called appendToHistory with cleaned metadata (no error/errorType)\n    expect(appendSpy).toHaveBeenCalledTimes(1);\n    const appendedMessage = appendSpy.mock.calls[0][1];\n\n    expect(appendedMessage.id).toBe(\"msg-1\");\n    expect(appendedMessage.parts).toEqual(erroredPartial.parts);\n    expect(appendedMessage.metadata?.error).toBeUndefined();\n    expect(appendedMessage.metadata?.errorType).toBeUndefined();\n    expect(appendedMessage.metadata?.historySequence).toBe(1);\n\n    // Should have deleted the partial after committing\n    const deletePartial = partialService.deletePartial as ReturnType<typeof mock>;\n    expect(deletePartial).toHaveBeenCalledWith(workspaceId);\n  });\n\n  test(\"commitToHistory should update existing placeholder when errored partial has more parts\", async () => {\n    const workspaceId = \"test-workspace\";\n    const erroredPartial: MuxMessage = {\n      id: \"msg-1\",\n      role: \"assistant\",\n      metadata: {\n        historySequence: 1,\n        timestamp: Date.now(),\n        model: \"test-model\",\n        partial: true,\n        error: \"Stream error occurred\",\n        errorType: \"network\",\n      },\n      parts: [\n        { type: \"text\", text: \"Accumulated content before error\" },\n        {\n          type: \"dynamic-tool\",\n          toolCallId: \"call-1\",\n          toolName: \"bash\",\n          state: \"input-available\",\n          input: { script: \"echo test\", timeout_secs: 10, display_name: \"Test\" },\n        },\n      ],\n    };\n\n    const existingPlaceholder: MuxMessage = {\n      id: \"msg-1\",\n      role: \"assistant\",\n      metadata: {\n        historySequence: 1,\n        timestamp: Date.now(),\n        model: \"test-model\",\n        partial: true,\n      },\n      parts: [], // Empty placeholder\n    };\n\n    // Mock readPartial to return errored partial\n    partialService.readPartial = mock(() => Promise.resolve(erroredPartial));\n\n    // Mock deletePartial\n    partialService.deletePartial = mock(() => Promise.resolve(Ok(undefined)));\n\n    // Seed existing placeholder into history so getHistoryFromLatestBoundary finds it\n    await historyService.appendToHistory(workspaceId, existingPlaceholder);\n\n    // Spy on historyService methods AFTER seeding to verify only commitToHistory calls\n    const appendSpy = spyOn(historyService, \"appendToHistory\");\n    const updateSpy = spyOn(historyService, \"updateHistory\");\n\n    // Call commitToHistory\n    const result = await partialService.commitToHistory(workspaceId);\n\n    // Should succeed\n    expect(result.success).toBe(true);\n\n    // Should have called updateHistory (not append) with cleaned metadata\n    expect(updateSpy).toHaveBeenCalledTimes(1);\n    expect(appendSpy).not.toHaveBeenCalled();\n\n    const updatedMessage = updateSpy.mock.calls[0][1];\n\n    expect(updatedMessage.parts).toEqual(erroredPartial.parts);\n    expect(updatedMessage.metadata?.error).toBeUndefined();\n    expect(updatedMessage.metadata?.errorType).toBeUndefined();\n\n    // Should have deleted the partial after updating\n    const deletePartial = partialService.deletePartial as ReturnType<typeof mock>;\n    expect(deletePartial).toHaveBeenCalledWith(workspaceId);\n  });\n\n  test(\"commitToHistory should skip tool-only incomplete partials\", async () => {\n    const workspaceId = \"test-workspace\";\n    const toolOnlyPartial: MuxMessage = {\n      id: \"msg-1\",\n      role: \"assistant\",\n      metadata: {\n        historySequence: 1,\n        timestamp: Date.now(),\n        model: \"test-model\",\n        partial: true,\n        error: \"Stream interrupted\",\n        errorType: \"network\",\n      },\n      parts: [\n        {\n          type: \"dynamic-tool\",\n          toolCallId: \"call-1\",\n          toolName: \"bash\",\n          state: \"input-available\",\n          input: { script: \"echo test\", timeout_secs: 10, display_name: \"Test\" },\n        },\n      ],\n    };\n\n    partialService.readPartial = mock(() => Promise.resolve(toolOnlyPartial));\n    partialService.deletePartial = mock(() => Promise.resolve(Ok(undefined)));\n\n    // Spy on historyService methods to verify calls\n    const appendSpy = spyOn(historyService, \"appendToHistory\");\n    const updateSpy = spyOn(historyService, \"updateHistory\");\n\n    const result = await partialService.commitToHistory(workspaceId);\n    expect(result.success).toBe(true);\n\n    expect(appendSpy).not.toHaveBeenCalled();\n    expect(updateSpy).not.toHaveBeenCalled();\n\n    const deletePartial = partialService.deletePartial as ReturnType<typeof mock>;\n    expect(deletePartial).toHaveBeenCalledWith(workspaceId);\n  });\n  test(\"commitToHistory should skip empty errored partial\", async () => {\n    const workspaceId = \"test-workspace\";\n    const emptyErrorPartial: MuxMessage = {\n      id: \"msg-1\",\n      role: \"assistant\",\n      metadata: {\n        historySequence: 1,\n        timestamp: Date.now(),\n        model: \"test-model\",\n        partial: true,\n        error: \"Network error\",\n        errorType: \"network\",\n      },\n      parts: [], // Empty - no content accumulated before error\n    };\n\n    // Mock readPartial to return empty errored partial\n    partialService.readPartial = mock(() => Promise.resolve(emptyErrorPartial));\n\n    // Mock deletePartial\n    partialService.deletePartial = mock(() => Promise.resolve(Ok(undefined)));\n\n    // Spy on historyService methods to verify calls\n    const appendSpy = spyOn(historyService, \"appendToHistory\");\n\n    // Call commitToHistory\n    const result = await partialService.commitToHistory(workspaceId);\n\n    // Should succeed\n    expect(result.success).toBe(true);\n\n    // Should NOT call appendToHistory for empty message (no value to preserve)\n    expect(appendSpy).not.toHaveBeenCalled();\n\n    // Should still delete the partial (cleanup)\n    const deletePartial = partialService.deletePartial as ReturnType<typeof mock>;\n    expect(deletePartial).toHaveBeenCalledWith(workspaceId);\n  });\n});\n\ndescribe(\"PartialService - Legacy compatibility\", () => {\n  let config: Config;\n  let partialService: PartialService;\n  let cleanup: () => Promise<void>;\n\n  beforeEach(async () => {\n    let historyService: HistoryService;\n    ({ config, historyService, cleanup } = await createTestHistoryService());\n    partialService = new PartialService(config, historyService);\n  });\n\n  afterEach(async () => {\n    await cleanup();\n  });\n\n  test(\"readPartial upgrades legacy cmuxMetadata\", async () => {\n    const workspaceId = \"legacy-ws\";\n    const workspaceDir = config.getSessionDir(workspaceId);\n    await fs.mkdir(workspaceDir, { recursive: true });\n\n    const partialMessage = createMuxMessage(\"partial-1\", \"assistant\", \"legacy\", {\n      historySequence: 0,\n    });\n    (partialMessage.metadata as Record<string, unknown>).cmuxMetadata = { type: \"normal\" };\n\n    const partialPath = path.join(workspaceDir, \"partial.json\");\n    await fs.writeFile(partialPath, JSON.stringify(partialMessage));\n\n    const result = await partialService.readPartial(workspaceId);\n    expect(result?.metadata?.muxMetadata?.type).toBe(\"normal\");\n  });\n});\n"]}