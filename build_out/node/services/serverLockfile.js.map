{"version":3,"file":"serverLockfile.js","sourceRoot":"","sources":["../../../src/node/services/serverLockfile.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs/promises\";\r\nimport * as path from \"path\";\r\nimport { z } from \"zod\";\r\n\r\nexport const ServerLockDataSchema = z.object({\r\n  pid: z.number(),\r\n  /** Base URL for HTTP API (e.g., \"http://localhost:3000\" or \"https://my.box.com/mux\") */\r\n  baseUrl: z.url(),\r\n  token: z.string(),\r\n  startedAt: z.string(),\r\n  /** Bind host/interface the server is listening on (e.g. \"127.0.0.1\" or \"0.0.0.0\") */\r\n  bindHost: z.string().optional(),\r\n  /** The port the server is listening on */\r\n  port: z.number().int().min(0).max(65535).optional(),\r\n  /** Additional base URLs that are reachable from other devices (LAN/VPN) */\r\n  networkBaseUrls: z.array(z.url()).optional(),\r\n});\r\n\r\nexport type ServerLockData = z.infer<typeof ServerLockDataSchema>;\r\n\r\n/**\r\n * Manages the server lockfile at ~/.mux/server.lock\r\n *\r\n * The lockfile enables CLI tools to discover a running mux server\r\n * (either Electron app or standalone mux server) and connect to it.\r\n */\r\nexport class ServerLockfile {\r\n  private readonly lockPath: string;\r\n\r\n  constructor(muxHome: string) {\r\n    this.lockPath = path.join(muxHome, \"server.lock\");\r\n  }\r\n\r\n  /**\r\n   * Acquire the lockfile with the given baseUrl and token.\r\n   * Writes atomically with 0600 permissions (owner read/write only).\r\n   */\r\n  async acquire(\r\n    baseUrl: string,\r\n    token: string,\r\n    extra?: {\r\n      bindHost?: string;\r\n      port?: number;\r\n      networkBaseUrls?: string[];\r\n    }\r\n  ): Promise<void> {\r\n    const bindHost = extra?.bindHost?.trim() ? extra.bindHost.trim() : undefined;\r\n    const port =\r\n      typeof extra?.port === \"number\" &&\r\n      Number.isInteger(extra.port) &&\r\n      extra.port >= 0 &&\r\n      extra.port <= 65535\r\n        ? extra.port\r\n        : undefined;\r\n\r\n    const data: ServerLockData = {\r\n      pid: process.pid,\r\n      baseUrl,\r\n      token,\r\n      startedAt: new Date().toISOString(),\r\n      bindHost,\r\n      port,\r\n      networkBaseUrls: extra?.networkBaseUrls?.length ? extra.networkBaseUrls : undefined,\r\n    };\r\n\r\n    // Ensure directory exists\r\n    const dir = path.dirname(this.lockPath);\r\n    try {\r\n      await fs.access(dir);\r\n    } catch {\r\n      await fs.mkdir(dir, { recursive: true });\r\n    }\r\n\r\n    // Write atomically by writing to temp file then renaming\r\n    const tempPath = `${this.lockPath}.${process.pid}.tmp`;\r\n    await fs.writeFile(tempPath, JSON.stringify(data, null, 2), {\r\n      mode: 0o600, // Owner read/write only\r\n    });\r\n    await fs.rename(tempPath, this.lockPath);\r\n  }\r\n\r\n  /**\r\n   * Read the lockfile and validate it.\r\n   * Returns null if the lockfile doesn't exist or is stale (dead PID).\r\n   */\r\n  async read(): Promise<ServerLockData | null> {\r\n    try {\r\n      await fs.access(this.lockPath);\r\n      const content = await fs.readFile(this.lockPath, \"utf-8\");\r\n      const data = ServerLockDataSchema.parse(JSON.parse(content));\r\n\r\n      // Validate PID is still alive\r\n      if (!this.isProcessAlive(data.pid)) {\r\n        // Clean up stale lockfile\r\n        await this.release();\r\n        return null;\r\n      }\r\n\r\n      return data;\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Release the lockfile by deleting it.\r\n   */\r\n  async release(): Promise<void> {\r\n    try {\r\n      await fs.unlink(this.lockPath);\r\n    } catch {\r\n      // Ignore cleanup errors (file may not exist)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a process with the given PID is still running.\r\n   * Uses signal 0 which tests existence without actually sending a signal.\r\n   */\r\n  private isProcessAlive(pid: number): boolean {\r\n    try {\r\n      process.kill(pid, 0);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the path to the lockfile (for testing/debugging).\r\n   */\r\n  getLockPath(): string {\r\n    return this.lockPath;\r\n  }\r\n}\r\n"]}