{"version":3,"file":"serverLockfile.js","sourceRoot":"","sources":["../../../src/node/services/serverLockfile.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport { z } from \"zod\";\n\nexport const ServerLockDataSchema = z.object({\n  pid: z.number(),\n  /** Base URL for HTTP API (e.g., \"http://localhost:3000\" or \"https://my.box.com/mux\") */\n  baseUrl: z.url(),\n  token: z.string(),\n  startedAt: z.string(),\n  /** Bind host/interface the server is listening on (e.g. \"127.0.0.1\" or \"0.0.0.0\") */\n  bindHost: z.string().optional(),\n  /** The port the server is listening on */\n  port: z.number().int().min(0).max(65535).optional(),\n  /** Additional base URLs that are reachable from other devices (LAN/VPN) */\n  networkBaseUrls: z.array(z.url()).optional(),\n});\n\nexport type ServerLockData = z.infer<typeof ServerLockDataSchema>;\n\n/**\n * Manages the server lockfile at ~/.mux/server.lock\n *\n * The lockfile enables CLI tools to discover a running mux server\n * (either Electron app or standalone mux server) and connect to it.\n */\nexport class ServerLockfile {\n  private readonly lockPath: string;\n\n  constructor(muxHome: string) {\n    this.lockPath = path.join(muxHome, \"server.lock\");\n  }\n\n  /**\n   * Acquire the lockfile with the given baseUrl and token.\n   * Writes atomically with 0600 permissions (owner read/write only).\n   */\n  async acquire(\n    baseUrl: string,\n    token: string,\n    extra?: {\n      bindHost?: string;\n      port?: number;\n      networkBaseUrls?: string[];\n    }\n  ): Promise<void> {\n    const bindHost = extra?.bindHost?.trim() ? extra.bindHost.trim() : undefined;\n    const port =\n      typeof extra?.port === \"number\" &&\n      Number.isInteger(extra.port) &&\n      extra.port >= 0 &&\n      extra.port <= 65535\n        ? extra.port\n        : undefined;\n\n    const data: ServerLockData = {\n      pid: process.pid,\n      baseUrl,\n      token,\n      startedAt: new Date().toISOString(),\n      bindHost,\n      port,\n      networkBaseUrls: extra?.networkBaseUrls?.length ? extra.networkBaseUrls : undefined,\n    };\n\n    // Ensure directory exists\n    const dir = path.dirname(this.lockPath);\n    try {\n      await fs.access(dir);\n    } catch {\n      await fs.mkdir(dir, { recursive: true });\n    }\n\n    // Write atomically by writing to temp file then renaming\n    const tempPath = `${this.lockPath}.${process.pid}.tmp`;\n    await fs.writeFile(tempPath, JSON.stringify(data, null, 2), {\n      mode: 0o600, // Owner read/write only\n    });\n    await fs.rename(tempPath, this.lockPath);\n  }\n\n  /**\n   * Read the lockfile and validate it.\n   * Returns null if the lockfile doesn't exist or is stale (dead PID).\n   */\n  async read(): Promise<ServerLockData | null> {\n    try {\n      await fs.access(this.lockPath);\n      const content = await fs.readFile(this.lockPath, \"utf-8\");\n      const data = ServerLockDataSchema.parse(JSON.parse(content));\n\n      // Validate PID is still alive\n      if (!this.isProcessAlive(data.pid)) {\n        // Clean up stale lockfile\n        await this.release();\n        return null;\n      }\n\n      return data;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Release the lockfile by deleting it.\n   */\n  async release(): Promise<void> {\n    try {\n      await fs.unlink(this.lockPath);\n    } catch {\n      // Ignore cleanup errors (file may not exist)\n    }\n  }\n\n  /**\n   * Check if a process with the given PID is still running.\n   * Uses signal 0 which tests existence without actually sending a signal.\n   */\n  private isProcessAlive(pid: number): boolean {\n    try {\n      process.kill(pid, 0);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get the path to the lockfile (for testing/debugging).\n   */\n  getLockPath(): string {\n    return this.lockPath;\n  }\n}\n"]}