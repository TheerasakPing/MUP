{"version":3,"file":"workspaceTitleGenerator.js","sourceRoot":"","sources":["../../../src/node/services/workspaceTitleGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["import { NoObjectGeneratedError, streamText, Output } from \"ai\";\nimport { z } from \"zod\";\nimport type { AIService } from \"./aiService\";\nimport { log } from \"./log\";\nimport type { Result } from \"@/common/types/result\";\nimport { Ok, Err } from \"@/common/types/result\";\nimport type { SendMessageError } from \"@/common/types/errors\";\nimport crypto from \"crypto\";\n\n/** Schema for AI-generated workspace identity (area name + descriptive title) */\nconst workspaceIdentitySchema = z.object({\n  name: z\n    .string()\n    .regex(/^[a-z0-9-]+$/)\n    .min(2)\n    .max(20)\n    .describe(\n      \"Codebase area (1-2 words, max 15 chars): lowercase, hyphens only, e.g. 'sidebar', 'auth', 'config'\"\n    ),\n  title: z\n    .string()\n    .min(5)\n    .max(60)\n    .describe(\"Human-readable title (2-5 words): verb-noun format like 'Fix plan mode'\"),\n});\n\nexport interface WorkspaceIdentity {\n  /** Codebase area with 4-char suffix (e.g., \"sidebar-a1b2\", \"auth-k3m9\") */\n  name: string;\n  /** Human-readable title (e.g., \"Fix plan mode over SSH\") */\n  title: string;\n}\n\n// Crockford Base32 alphabet (excludes I, L, O, U to avoid confusion)\nconst CROCKFORD_ALPHABET = \"0123456789abcdefghjkmnpqrstvwxyz\";\n\n/**\n * Generate a 4-character random suffix using Crockford Base32.\n * Uses 20 bits of randomness (4 chars × 5 bits each).\n */\nfunction generateNameSuffix(): string {\n  const bytes = crypto.randomBytes(3); // 24 bits, we'll use 20\n  const value = (bytes[0] << 12) | (bytes[1] << 4) | (bytes[2] >> 4);\n  return (\n    CROCKFORD_ALPHABET[(value >> 15) & 0x1f] +\n    CROCKFORD_ALPHABET[(value >> 10) & 0x1f] +\n    CROCKFORD_ALPHABET[(value >> 5) & 0x1f] +\n    CROCKFORD_ALPHABET[value & 0x1f]\n  );\n}\n\nexport interface GenerateWorkspaceIdentityResult extends WorkspaceIdentity {\n  /** The model that successfully generated the identity */\n  modelUsed: string;\n}\n\n/**\n * Generate workspace identity (name + title) using AI.\n * Tries candidates in order, retrying on API errors (invalid keys, quota, etc.).\n *\n * - name: Codebase area with 4-char suffix (e.g., \"sidebar-a1b2\")\n * - title: Human-readable description (e.g., \"Fix plan mode over SSH\")\n */\nexport async function generateWorkspaceIdentity(\n  message: string,\n  candidates: string[],\n  aiService: AIService\n): Promise<Result<GenerateWorkspaceIdentityResult, SendMessageError>> {\n  if (candidates.length === 0) {\n    return Err({ type: \"unknown\", raw: \"No model candidates provided for name generation\" });\n  }\n\n  // Try up to 3 candidates\n  const maxAttempts = Math.min(candidates.length, 3);\n\n  // Track the last API error to return if all candidates fail\n  let lastApiError: string | undefined;\n\n  for (let i = 0; i < maxAttempts; i++) {\n    const modelString = candidates[i];\n\n    const modelResult = await aiService.createModel(modelString);\n    if (!modelResult.success) {\n      // No credentials for this model, try next\n      log.debug(`Name generation: skipping ${modelString} (${modelResult.error.type})`);\n      continue;\n    }\n\n    try {\n      // Use streamText instead of generateText: the Codex OAuth endpoint\n      // (chatgpt.com/backend-api/codex/responses) requires stream:true in the\n      // request body and rejects non-streaming requests with 400.  streamText\n      // sets stream:true automatically, while generateText does not.\n      const stream = streamText({\n        model: modelResult.data,\n        output: Output.object({ schema: workspaceIdentitySchema }),\n        prompt: `Generate a workspace name and title for this development task:\n\n\"${message}\"\n\nRequirements:\n- name: The area of the codebase being worked on (1-2 words, max 15 chars, git-safe: lowercase, hyphens only). Random bytes will be appended for uniqueness, so focus on the area not the specific task. Examples: \"sidebar\", \"auth\", \"config\", \"api\"\n- title: A 2-5 word description in verb-noun format. Examples: \"Fix plan mode\", \"Add user authentication\", \"Refactor sidebar layout\"`,\n      });\n\n      // Awaiting .output triggers full stream consumption and JSON parsing.\n      // If the model returned conversational text instead of JSON, this throws\n      // NoObjectGeneratedError — caught below with a text fallback parser.\n      const output = await stream.output;\n\n      const suffix = generateNameSuffix();\n      const sanitizedName = sanitizeBranchName(output.name, 20);\n      const nameWithSuffix = `${sanitizedName}-${suffix}`;\n\n      return Ok({\n        name: nameWithSuffix,\n        title: output.title.trim(),\n        modelUsed: modelString,\n      });\n    } catch (error) {\n      // Some models ignore the structured output instruction and return\n      // conversational text (e.g. \"**name:** `testing`\\n**title:** `Improve test coverage`\").\n      // NoObjectGeneratedError carries the raw .text — try to extract name/title\n      // from it before giving up on this candidate.\n      if (NoObjectGeneratedError.isInstance(error) && error.text) {\n        const textFallback = extractIdentityFromText(error.text);\n        if (textFallback) {\n          log.info(\n            `Name generation: structured output failed for ${modelString}, recovered from text fallback`\n          );\n          const suffix = generateNameSuffix();\n          const sanitizedName = sanitizeBranchName(textFallback.name, 20);\n          const nameWithSuffix = `${sanitizedName}-${suffix}`;\n          return Ok({\n            name: nameWithSuffix,\n            title: textFallback.title,\n            modelUsed: modelString,\n          });\n        }\n      }\n\n      // API error (invalid key, quota, network, etc.) - try next candidate\n      lastApiError = error instanceof Error ? error.message : String(error);\n      log.warn(`Name generation failed with ${modelString}, trying next candidate`, {\n        error: lastApiError,\n      });\n      continue;\n    }\n  }\n\n  // Return the last API error if available (more actionable than generic message)\n  const errorMessage = lastApiError\n    ? `Name generation failed: ${lastApiError}`\n    : \"Name generation failed - no working model found\";\n  return Err({ type: \"unknown\", raw: errorMessage });\n}\n\n/**\n * Fallback: extract name/title from conversational model text when structured\n * JSON output parsing fails. Handles common patterns like:\n *   **name:** `testing`          or  \"name\": \"testing\"\n *   **title:** `Improve tests`   or  \"title\": \"Improve tests\"\n *\n * Returns null if either field cannot be reliably extracted.\n */\nexport function extractIdentityFromText(text: string): { name: string; title: string } | null {\n  // Try JSON extraction first (model may have embedded JSON in prose)\n  const jsonMatch = /\\{[^}]*\"name\"\\s*:\\s*\"([^\"]+)\"[^}]*\"title\"\\s*:\\s*\"([^\"]+)\"[^}]*\\}/.exec(text);\n  if (jsonMatch) {\n    return validateExtracted(jsonMatch[1], jsonMatch[2]);\n  }\n  // Also try reverse field order in JSON\n  const jsonMatchReverse = /\\{[^}]*\"title\"\\s*:\\s*\"([^\"]+)\"[^}]*\"name\"\\s*:\\s*\"([^\"]+)\"[^}]*\\}/.exec(\n    text\n  );\n  if (jsonMatchReverse) {\n    return validateExtracted(jsonMatchReverse[2], jsonMatchReverse[1]);\n  }\n\n  // Try markdown/prose patterns: **name:** `value` or name: \"value\"\n  // In bold markdown the colon sits inside the stars: **name:**\n  const nameMatch =\n    /\\*?\\*?name:\\*?\\*?\\s*`([^`]+)`/i.exec(text) ?? /\\bname:\\s*\"([^\"]+)\"/i.exec(text);\n  const titleMatch =\n    /\\*?\\*?title:\\*?\\*?\\s*`([^`]+)`/i.exec(text) ?? /\\btitle:\\s*\"([^\"]+)\"/i.exec(text);\n\n  if (nameMatch && titleMatch) {\n    return validateExtracted(nameMatch[1], titleMatch[1]);\n  }\n\n  return null;\n}\n\n/** Validate extracted values against the same constraints as the schema. */\nfunction validateExtracted(\n  rawName: string,\n  rawTitle: string\n): { name: string; title: string } | null {\n  const name = rawName\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"-\")\n    .replace(/^-+|-+$/g, \"\")\n    .replace(/-+/g, \"-\");\n  const title = rawTitle.trim();\n\n  if (name.length < 2 || name.length > 20) return null;\n  if (title.length < 5 || title.length > 60) return null;\n\n  return { name, title };\n}\n\n/**\n * Sanitize a string to be git-safe: lowercase, hyphens only, no leading/trailing hyphens.\n */\nfunction sanitizeBranchName(name: string, maxLength: number): string {\n  return name\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"-\")\n    .replace(/^-+|-+$/g, \"\")\n    .replace(/-+/g, \"-\")\n    .substring(0, maxLength);\n}\n"]}