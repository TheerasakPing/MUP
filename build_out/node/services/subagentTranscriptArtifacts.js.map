{"version":3,"file":"subagentTranscriptArtifacts.js","sourceRoot":"","sources":["../../../src/node/services/subagentTranscriptArtifacts.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fsPromises from \"fs/promises\";\r\nimport * as path from \"node:path\";\r\n\r\nimport writeFileAtomic from \"write-file-atomic\";\r\n\r\nimport type { ThinkingLevel } from \"@/common/types/thinking\";\r\n\r\nimport { log } from \"@/node/services/log\";\r\nimport { workspaceFileLocks } from \"@/node/utils/concurrency/workspaceFileLocks\";\r\n\r\nexport interface SubagentTranscriptArtifactsFile {\r\n  version: 1;\r\n  artifactsByChildTaskId: Record<string, SubagentTranscriptArtifactIndexEntry>;\r\n}\r\n\r\nexport interface SubagentTranscriptArtifactIndexEntry {\r\n  childTaskId: string;\r\n  /** Immediate parent in the agent-task tree (matches WorkspaceConfigEntry.parentWorkspaceId). */\r\n  parentWorkspaceId: string;\r\n  createdAtMs: number;\r\n  updatedAtMs: number;\r\n  /** Task-level model string used when running the sub-agent (optional for legacy entries). */\r\n  model?: string;\r\n  /** Task-level thinking/reasoning level used when running the sub-agent (optional for legacy entries). */\r\n  thinkingLevel?: ThinkingLevel;\r\n  /** Absolute path to the archived chat.jsonl file on disk (if present). */\r\n  chatPath?: string;\r\n  /** Absolute path to the archived partial.json file on disk (if present). */\r\n  partialPath?: string;\r\n}\r\n\r\nconst SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION = 1 as const;\r\n\r\nconst SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_NAME = \"subagent-transcripts.json\";\r\nconst SUBAGENT_TRANSCRIPTS_DIR_NAME = \"subagent-transcripts\";\r\nconst SUBAGENT_TRANSCRIPT_CHAT_FILE_NAME = \"chat.jsonl\";\r\nconst SUBAGENT_TRANSCRIPT_PARTIAL_FILE_NAME = \"partial.json\";\r\n\r\nexport function getSubagentTranscriptArtifactsFilePath(workspaceSessionDir: string): string {\r\n  return path.join(workspaceSessionDir, SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_NAME);\r\n}\r\n\r\nexport function getSubagentTranscriptChatPath(\r\n  workspaceSessionDir: string,\r\n  childTaskId: string\r\n): string {\r\n  return path.join(\r\n    workspaceSessionDir,\r\n    SUBAGENT_TRANSCRIPTS_DIR_NAME,\r\n    childTaskId,\r\n    SUBAGENT_TRANSCRIPT_CHAT_FILE_NAME\r\n  );\r\n}\r\n\r\nexport function getSubagentTranscriptPartialPath(\r\n  workspaceSessionDir: string,\r\n  childTaskId: string\r\n): string {\r\n  return path.join(\r\n    workspaceSessionDir,\r\n    SUBAGENT_TRANSCRIPTS_DIR_NAME,\r\n    childTaskId,\r\n    SUBAGENT_TRANSCRIPT_PARTIAL_FILE_NAME\r\n  );\r\n}\r\n\r\nexport async function readSubagentTranscriptArtifactsFile(\r\n  workspaceSessionDir: string\r\n): Promise<SubagentTranscriptArtifactsFile> {\r\n  try {\r\n    const filePath = getSubagentTranscriptArtifactsFilePath(workspaceSessionDir);\r\n    const raw = await fsPromises.readFile(filePath, \"utf-8\");\r\n    const parsed = JSON.parse(raw) as unknown;\r\n\r\n    if (!parsed || typeof parsed !== \"object\") {\r\n      return { version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION, artifactsByChildTaskId: {} };\r\n    }\r\n\r\n    const obj = parsed as {\r\n      version?: unknown;\r\n      artifactsByChildTaskId?: unknown;\r\n    };\r\n\r\n    if (obj.version !== SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION) {\r\n      // Unknown version; treat as empty.\r\n      return { version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION, artifactsByChildTaskId: {} };\r\n    }\r\n\r\n    if (!obj.artifactsByChildTaskId || typeof obj.artifactsByChildTaskId !== \"object\") {\r\n      return { version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION, artifactsByChildTaskId: {} };\r\n    }\r\n\r\n    return {\r\n      version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION,\r\n      artifactsByChildTaskId: obj.artifactsByChildTaskId as Record<\r\n        string,\r\n        SubagentTranscriptArtifactIndexEntry\r\n      >,\r\n    };\r\n  } catch (error) {\r\n    if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\r\n      return { version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION, artifactsByChildTaskId: {} };\r\n    }\r\n\r\n    log.error(\"Failed to read subagent transcript artifacts file\", { error });\r\n    return { version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION, artifactsByChildTaskId: {} };\r\n  }\r\n}\r\n\r\nexport async function updateSubagentTranscriptArtifactsFile(params: {\r\n  /** Workspace id that owns the session dir we're writing into (used for file locking). */\r\n  workspaceId: string;\r\n  workspaceSessionDir: string;\r\n  update: (file: SubagentTranscriptArtifactsFile) => void;\r\n}): Promise<SubagentTranscriptArtifactsFile> {\r\n  return workspaceFileLocks.withLock(params.workspaceId, async () => {\r\n    const file = await readSubagentTranscriptArtifactsFile(params.workspaceSessionDir);\r\n    params.update(file);\r\n\r\n    try {\r\n      await fsPromises.mkdir(params.workspaceSessionDir, { recursive: true });\r\n      const filePath = getSubagentTranscriptArtifactsFilePath(params.workspaceSessionDir);\r\n      await writeFileAtomic(filePath, JSON.stringify(file, null, 2));\r\n    } catch (error) {\r\n      log.error(\"Failed to write subagent transcript artifacts file\", { error });\r\n    }\r\n\r\n    return file;\r\n  });\r\n}\r\n\r\nexport async function upsertSubagentTranscriptArtifactIndexEntry(params: {\r\n  /** Workspace id that owns the session dir we're writing into (used for file locking). */\r\n  workspaceId: string;\r\n  workspaceSessionDir: string;\r\n  childTaskId: string;\r\n  updater: (\r\n    existing: SubagentTranscriptArtifactIndexEntry | null\r\n  ) => SubagentTranscriptArtifactIndexEntry;\r\n}): Promise<SubagentTranscriptArtifactIndexEntry> {\r\n  let updated: SubagentTranscriptArtifactIndexEntry | null = null;\r\n\r\n  await updateSubagentTranscriptArtifactsFile({\r\n    workspaceId: params.workspaceId,\r\n    workspaceSessionDir: params.workspaceSessionDir,\r\n    update: (file) => {\r\n      const existing = file.artifactsByChildTaskId[params.childTaskId] ?? null;\r\n      updated = params.updater(existing);\r\n      file.artifactsByChildTaskId[params.childTaskId] = updated;\r\n    },\r\n  });\r\n\r\n  if (!updated) {\r\n    throw new Error(\"upsertSubagentTranscriptArtifactIndexEntry: updater returned no entry\");\r\n  }\r\n\r\n  return updated;\r\n}\r\n"]}