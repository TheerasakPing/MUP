{"version":3,"file":"subagentTranscriptArtifacts.js","sourceRoot":"","sources":["../../../src/node/services/subagentTranscriptArtifacts.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAY,UAAU,wCAAoB;AAC1C,MAAY,IAAI,sCAAkB;AAElC,0EAAgD;AAIhD,6CAA0C;AAC1C,oFAAiF;AAuBjF,MAAM,0CAA0C,GAAG,CAAU,CAAC;AAE9D,MAAM,uCAAuC,GAAG,2BAA2B,CAAC;AAC5E,MAAM,6BAA6B,GAAG,sBAAsB,CAAC;AAC7D,MAAM,kCAAkC,GAAG,YAAY,CAAC;AACxD,MAAM,qCAAqC,GAAG,cAAc,CAAC;AAE7D,gDAAuD,mBAA2B,EAAU;IAC1F,OAAO,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE,uCAAuC,CAAC,CAAC;AAAA,CAChF;AAED,uCACE,mBAA2B,EAC3B,WAAmB,EACX;IACR,OAAO,IAAI,CAAC,IAAI,CACd,mBAAmB,EACnB,6BAA6B,EAC7B,WAAW,EACX,kCAAkC,CACnC,CAAC;AAAA,CACH;AAED,0CACE,mBAA2B,EAC3B,WAAmB,EACX;IACR,OAAO,IAAI,CAAC,IAAI,CACd,mBAAmB,EACnB,6BAA6B,EAC7B,WAAW,EACX,qCAAqC,CACtC,CAAC;AAAA,CACH;AAEM,KAAK,8CACV,mBAA2B,EACe;IAC1C,IAAI,CAAC;QACH,MAAM,QAAQ,GAAG,sCAAsC,CAAC,mBAAmB,CAAC,CAAC;QAC7E,MAAM,GAAG,GAAG,MAAM,UAAU,CAAC,QAAQ,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QACzD,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAY,CAAC;QAE1C,IAAI,CAAC,MAAM,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE,CAAC;YAC1C,OAAO,EAAE,OAAO,EAAE,0CAA0C,EAAE,sBAAsB,EAAE,EAAE,EAAE,CAAC;QAC7F,CAAC;QAED,MAAM,GAAG,GAAG,MAGX,CAAC;QAEF,IAAI,GAAG,CAAC,OAAO,KAAK,0CAA0C,EAAE,CAAC;YAC/D,mCAAmC;YACnC,OAAO,EAAE,OAAO,EAAE,0CAA0C,EAAE,sBAAsB,EAAE,EAAE,EAAE,CAAC;QAC7F,CAAC;QAED,IAAI,CAAC,GAAG,CAAC,sBAAsB,IAAI,OAAO,GAAG,CAAC,sBAAsB,KAAK,QAAQ,EAAE,CAAC;YAClF,OAAO,EAAE,OAAO,EAAE,0CAA0C,EAAE,sBAAsB,EAAE,EAAE,EAAE,CAAC;QAC7F,CAAC;QAED,OAAO;YACL,OAAO,EAAE,0CAA0C;YACnD,sBAAsB,EAAE,GAAG,CAAC,sBAG3B;SACF,CAAC;IACJ,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,IAAI,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;YACrF,OAAO,EAAE,OAAO,EAAE,0CAA0C,EAAE,sBAAsB,EAAE,EAAE,EAAE,CAAC;QAC7F,CAAC;QAED,SAAG,CAAC,KAAK,CAAC,mDAAmD,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;QAC1E,OAAO,EAAE,OAAO,EAAE,0CAA0C,EAAE,sBAAsB,EAAE,EAAE,EAAE,CAAC;IAC7F,CAAC;AAAA,CACF;AAEM,KAAK,gDAAgD,MAK3D,EAA4C;IAC3C,OAAO,uCAAkB,CAAC,QAAQ,CAAC,MAAM,CAAC,WAAW,EAAE,KAAK,IAAI,EAAE,CAAC;QACjE,MAAM,IAAI,GAAG,MAAM,mCAAmC,CAAC,MAAM,CAAC,mBAAmB,CAAC,CAAC;QACnF,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAEpB,IAAI,CAAC;YACH,MAAM,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,mBAAmB,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;YACxE,MAAM,QAAQ,GAAG,sCAAsC,CAAC,MAAM,CAAC,mBAAmB,CAAC,CAAC;YACpF,MAAM,IAAA,2BAAe,EAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;QACjE,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,SAAG,CAAC,KAAK,CAAC,oDAAoD,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;QAC7E,CAAC;QAED,OAAO,IAAI,CAAC;IAAA,CACb,CAAC,CAAC;AAAA,CACJ;AAEM,KAAK,qDAAqD,MAQhE,EAAiD;IAChD,IAAI,OAAO,GAAgD,IAAI,CAAC;IAEhE,MAAM,qCAAqC,CAAC;QAC1C,WAAW,EAAE,MAAM,CAAC,WAAW;QAC/B,mBAAmB,EAAE,MAAM,CAAC,mBAAmB;QAC/C,MAAM,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC;YAChB,MAAM,QAAQ,GAAG,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,IAAI,CAAC;YACzE,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;YACnC,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,WAAW,CAAC,GAAG,OAAO,CAAC;QAAA,CAC3D;KACF,CAAC,CAAC;IAEH,IAAI,CAAC,OAAO,EAAE,CAAC;QACb,MAAM,IAAI,KAAK,CAAC,uEAAuE,CAAC,CAAC;IAC3F,CAAC;IAED,OAAO,OAAO,CAAC;AAAA,CAChB","sourcesContent":["import * as fsPromises from \"fs/promises\";\nimport * as path from \"node:path\";\n\nimport writeFileAtomic from \"write-file-atomic\";\n\nimport type { ThinkingLevel } from \"@/common/types/thinking\";\n\nimport { log } from \"@/node/services/log\";\nimport { workspaceFileLocks } from \"@/node/utils/concurrency/workspaceFileLocks\";\n\nexport interface SubagentTranscriptArtifactsFile {\n  version: 1;\n  artifactsByChildTaskId: Record<string, SubagentTranscriptArtifactIndexEntry>;\n}\n\nexport interface SubagentTranscriptArtifactIndexEntry {\n  childTaskId: string;\n  /** Immediate parent in the agent-task tree (matches WorkspaceConfigEntry.parentWorkspaceId). */\n  parentWorkspaceId: string;\n  createdAtMs: number;\n  updatedAtMs: number;\n  /** Task-level model string used when running the sub-agent (optional for legacy entries). */\n  model?: string;\n  /** Task-level thinking/reasoning level used when running the sub-agent (optional for legacy entries). */\n  thinkingLevel?: ThinkingLevel;\n  /** Absolute path to the archived chat.jsonl file on disk (if present). */\n  chatPath?: string;\n  /** Absolute path to the archived partial.json file on disk (if present). */\n  partialPath?: string;\n}\n\nconst SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION = 1 as const;\n\nconst SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_NAME = \"subagent-transcripts.json\";\nconst SUBAGENT_TRANSCRIPTS_DIR_NAME = \"subagent-transcripts\";\nconst SUBAGENT_TRANSCRIPT_CHAT_FILE_NAME = \"chat.jsonl\";\nconst SUBAGENT_TRANSCRIPT_PARTIAL_FILE_NAME = \"partial.json\";\n\nexport function getSubagentTranscriptArtifactsFilePath(workspaceSessionDir: string): string {\n  return path.join(workspaceSessionDir, SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_NAME);\n}\n\nexport function getSubagentTranscriptChatPath(\n  workspaceSessionDir: string,\n  childTaskId: string\n): string {\n  return path.join(\n    workspaceSessionDir,\n    SUBAGENT_TRANSCRIPTS_DIR_NAME,\n    childTaskId,\n    SUBAGENT_TRANSCRIPT_CHAT_FILE_NAME\n  );\n}\n\nexport function getSubagentTranscriptPartialPath(\n  workspaceSessionDir: string,\n  childTaskId: string\n): string {\n  return path.join(\n    workspaceSessionDir,\n    SUBAGENT_TRANSCRIPTS_DIR_NAME,\n    childTaskId,\n    SUBAGENT_TRANSCRIPT_PARTIAL_FILE_NAME\n  );\n}\n\nexport async function readSubagentTranscriptArtifactsFile(\n  workspaceSessionDir: string\n): Promise<SubagentTranscriptArtifactsFile> {\n  try {\n    const filePath = getSubagentTranscriptArtifactsFilePath(workspaceSessionDir);\n    const raw = await fsPromises.readFile(filePath, \"utf-8\");\n    const parsed = JSON.parse(raw) as unknown;\n\n    if (!parsed || typeof parsed !== \"object\") {\n      return { version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION, artifactsByChildTaskId: {} };\n    }\n\n    const obj = parsed as {\n      version?: unknown;\n      artifactsByChildTaskId?: unknown;\n    };\n\n    if (obj.version !== SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION) {\n      // Unknown version; treat as empty.\n      return { version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION, artifactsByChildTaskId: {} };\n    }\n\n    if (!obj.artifactsByChildTaskId || typeof obj.artifactsByChildTaskId !== \"object\") {\n      return { version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION, artifactsByChildTaskId: {} };\n    }\n\n    return {\n      version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION,\n      artifactsByChildTaskId: obj.artifactsByChildTaskId as Record<\n        string,\n        SubagentTranscriptArtifactIndexEntry\n      >,\n    };\n  } catch (error) {\n    if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\n      return { version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION, artifactsByChildTaskId: {} };\n    }\n\n    log.error(\"Failed to read subagent transcript artifacts file\", { error });\n    return { version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION, artifactsByChildTaskId: {} };\n  }\n}\n\nexport async function updateSubagentTranscriptArtifactsFile(params: {\n  /** Workspace id that owns the session dir we're writing into (used for file locking). */\n  workspaceId: string;\n  workspaceSessionDir: string;\n  update: (file: SubagentTranscriptArtifactsFile) => void;\n}): Promise<SubagentTranscriptArtifactsFile> {\n  return workspaceFileLocks.withLock(params.workspaceId, async () => {\n    const file = await readSubagentTranscriptArtifactsFile(params.workspaceSessionDir);\n    params.update(file);\n\n    try {\n      await fsPromises.mkdir(params.workspaceSessionDir, { recursive: true });\n      const filePath = getSubagentTranscriptArtifactsFilePath(params.workspaceSessionDir);\n      await writeFileAtomic(filePath, JSON.stringify(file, null, 2));\n    } catch (error) {\n      log.error(\"Failed to write subagent transcript artifacts file\", { error });\n    }\n\n    return file;\n  });\n}\n\nexport async function upsertSubagentTranscriptArtifactIndexEntry(params: {\n  /** Workspace id that owns the session dir we're writing into (used for file locking). */\n  workspaceId: string;\n  workspaceSessionDir: string;\n  childTaskId: string;\n  updater: (\n    existing: SubagentTranscriptArtifactIndexEntry | null\n  ) => SubagentTranscriptArtifactIndexEntry;\n}): Promise<SubagentTranscriptArtifactIndexEntry> {\n  let updated: SubagentTranscriptArtifactIndexEntry | null = null;\n\n  await updateSubagentTranscriptArtifactsFile({\n    workspaceId: params.workspaceId,\n    workspaceSessionDir: params.workspaceSessionDir,\n    update: (file) => {\n      const existing = file.artifactsByChildTaskId[params.childTaskId] ?? null;\n      updated = params.updater(existing);\n      file.artifactsByChildTaskId[params.childTaskId] = updated;\n    },\n  });\n\n  if (!updated) {\n    throw new Error(\"upsertSubagentTranscriptArtifactIndexEntry: updater returned no entry\");\n  }\n\n  return updated;\n}\n"]}