{"version":3,"file":"partialService.js","sourceRoot":"","sources":["../../../src/node/services/partialService.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport writeFileAtomic from \"write-file-atomic\";\nimport type { Result } from \"@/common/types/result\";\nimport { Ok, Err } from \"@/common/types/result\";\nimport type { MuxMessage } from \"@/common/types/message\";\nimport type { Config } from \"@/node/config\";\nimport type { HistoryService } from \"./historyService\";\nimport { workspaceFileLocks } from \"@/node/utils/concurrency/workspaceFileLocks\";\nimport { normalizeLegacyMuxMetadata } from \"@/node/utils/messages/legacy\";\nimport { log } from \"@/node/services/log\";\n\n/**\n * PartialService - Manages partial message persistence for interrupted streams\n *\n * Responsibilities:\n * - Read/write/delete partial.json for all workspaces\n * - Commit partial messages to history when appropriate\n * - Encapsulate partial message lifecycle logic\n * - Synchronize file operations per workspace using MutexMap\n *\n * Separation of Concerns:\n * - PartialService owns partial.json\n * - HistoryService owns chat.jsonl\n * - StreamManager only interacts with PartialService\n * - AIService orchestrates both services\n *\n * This is a singleton service that manages partials for all workspaces.\n */\nexport class PartialService {\n  private readonly PARTIAL_FILE = \"partial.json\";\n  private readonly historyService: HistoryService;\n  // Shared file operation lock across all workspace file services\n  // This prevents deadlocks when services call each other (e.g., PartialService → HistoryService)\n  private readonly fileLocks = workspaceFileLocks;\n  private readonly config: Config;\n\n  constructor(config: Config, historyService: HistoryService) {\n    this.config = config;\n    this.historyService = historyService;\n  }\n\n  private getPartialPath(workspaceId: string): string {\n    return path.join(this.config.getSessionDir(workspaceId), this.PARTIAL_FILE);\n  }\n\n  /**\n   * Read the partial message for a workspace, if it exists\n   */\n  async readPartial(workspaceId: string): Promise<MuxMessage | null> {\n    try {\n      const partialPath = this.getPartialPath(workspaceId);\n      const data = await fs.readFile(partialPath, \"utf-8\");\n      const message = JSON.parse(data) as MuxMessage;\n      return normalizeLegacyMuxMetadata(message);\n    } catch (error) {\n      if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\n        return null; // No partial exists\n      }\n      // Log other errors but don't fail\n      log.error(\"Error reading partial:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Write a partial message to disk (with file locking per workspace)\n   */\n  async writePartial(workspaceId: string, message: MuxMessage): Promise<Result<void>> {\n    return this.fileLocks.withLock(workspaceId, async () => {\n      try {\n        const workspaceDir = this.config.getSessionDir(workspaceId);\n        await fs.mkdir(workspaceDir, { recursive: true });\n        const partialPath = this.getPartialPath(workspaceId);\n\n        // Ensure message has partial flag\n        const partialMessage = {\n          ...message,\n          metadata: {\n            ...message.metadata,\n            partial: true,\n          },\n        };\n\n        // Atomic write: writes to temp file then renames, preventing corruption\n        // if app crashes mid-write (prevents \"Unexpected end of JSON input\" on read)\n        await writeFileAtomic(partialPath, JSON.stringify(partialMessage, null, 2));\n        return Ok(undefined);\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        return Err(`Failed to write partial: ${message}`);\n      }\n    });\n  }\n\n  /**\n   * Delete the partial message file for a workspace (with file locking)\n   */\n  async deletePartial(workspaceId: string): Promise<Result<void>> {\n    return this.fileLocks.withLock(workspaceId, async () => {\n      try {\n        const partialPath = this.getPartialPath(workspaceId);\n        await fs.unlink(partialPath);\n        return Ok(undefined);\n      } catch (error) {\n        if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\n          return Ok(undefined); // Already deleted\n        }\n        const message = error instanceof Error ? error.message : String(error);\n        return Err(`Failed to delete partial: ${message}`);\n      }\n    });\n  }\n\n  /**\n   * Commit any existing partial message to chat.jsonl and delete partial.json.\n   * This is idempotent - if the partial has already been finalized in history,\n   * it won't be committed again (preventing double-commits).\n   * After committing (or if already finalized), partial.json is deleted.\n   *\n   * Smart commit logic:\n   * - If no message with this sequence exists in history: APPEND\n   * - If message exists but partial has more parts: UPDATE in place\n   * - Otherwise: skip commit (already finalized)\n   */\n  async commitToHistory(workspaceId: string): Promise<Result<void>> {\n    try {\n      let partial = await this.readPartial(workspaceId);\n      if (!partial) {\n        return Ok(undefined); // No partial to commit\n      }\n\n      // Strip error metadata if present, but commit the accumulated parts\n      // Error metadata is transient (UI-only), accumulated parts are persisted\n      // This ensures resumptions don't lose progress from failed streams\n      if (partial.metadata?.error) {\n        const { error, errorType, ...cleanMetadata } = partial.metadata;\n        partial = { ...partial, metadata: cleanMetadata };\n      }\n\n      const partialSeq = partial.metadata?.historySequence;\n      if (partialSeq === undefined) {\n        return Err(\"Partial message has no historySequence\");\n      }\n\n      // Check if this partial has already been finalized in chat.jsonl.\n      // A partial with MORE parts than what's in history means it's newer and should be committed\n      // (placeholder has empty parts, interrupted stream has accumulated parts).\n      // Only the current compaction epoch matters — partial messages are always recent.\n      const historyResult = await this.historyService.getHistoryFromLatestBoundary(workspaceId);\n      if (!historyResult.success) {\n        return Err(`Failed to read history: ${historyResult.error}`);\n      }\n\n      const existingMessages = historyResult.data;\n\n      const hasCommitWorthyParts = (partial.parts ?? []).some((part) => {\n        if (part.type === \"text\") {\n          return part.text.trim().length > 0;\n        }\n\n        if (part.type === \"reasoning\") {\n          // Reasoning may be needed for provider-specific replay (e.g., Extended Thinking).\n          // It is real content and safe to persist.\n          return part.text.trim().length > 0;\n        }\n\n        if (part.type === \"file\") {\n          return true;\n        }\n\n        if (part.type === \"dynamic-tool\") {\n          // Incomplete tool calls (input-available) are dropped when converting messages\n          // for provider requests (ignoreIncompleteToolCalls: true). Persisting a tool-only\n          // partial can brick future requests after a crash.\n          return part.state === \"output-available\";\n        }\n\n        return false;\n      });\n      const existingMessage = existingMessages.find(\n        (msg) => msg.metadata?.historySequence === partialSeq\n      );\n\n      const shouldCommit =\n        (!existingMessage || // No message with this sequence yet\n          (partial.parts?.length ?? 0) > (existingMessage.parts?.length ?? 0)) && // Partial has more parts\n        hasCommitWorthyParts; // Don't commit tool-only incomplete placeholders\n\n      if (shouldCommit) {\n        if (existingMessage) {\n          // Message exists (placeholder) - UPDATE it in place to avoid duplicates\n          const updateResult = await this.historyService.updateHistory(workspaceId, partial);\n          if (!updateResult.success) {\n            return updateResult;\n          }\n        } else {\n          // No message with this sequence - APPEND to history\n          const appendResult = await this.historyService.appendToHistory(workspaceId, partial);\n          if (!appendResult.success) {\n            return appendResult;\n          }\n        }\n      }\n\n      // Delete partial.json after successful commit (or if already finalized)\n      return await this.deletePartial(workspaceId);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return Err(`Failed to commit partial: ${message}`);\n    }\n  }\n}\n"]}