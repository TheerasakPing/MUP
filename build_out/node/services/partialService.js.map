{"version":3,"file":"partialService.js","sourceRoot":"","sources":["../../../src/node/services/partialService.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAY,EAAE,wCAAoB;AAClC,MAAY,IAAI,iCAAa;AAC7B,0EAAgD;AAEhD,kDAAgD;AAIhD,oFAAiF;AACjF,yDAA0E;AAC1E,6CAA0C;AAE1C;;;;;;;;;;;;;;;;GAgBG;AACH;IACmB,YAAY,GAAG,cAAc,CAAC;IAC9B,cAAc,CAAiB;IAChD,gEAAgE;IAChE,kGAAgG;IAC/E,SAAS,GAAG,uCAAkB,CAAC;IAC/B,MAAM,CAAS;IAEhC,YAAY,MAAc,EAAE,cAA8B,EAAE;QAC1D,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;IAAA,CACtC;IAEO,cAAc,CAAC,WAAmB,EAAU;QAClD,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,WAAW,CAAC,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;IAAA,CAC7E;IAED;;OAEG;IACH,KAAK,CAAC,WAAW,CAAC,WAAmB,EAA8B;QACjE,IAAI,CAAC;YACH,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;YACrD,MAAM,IAAI,GAAG,MAAM,EAAE,CAAC,QAAQ,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;YACrD,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAe,CAAC;YAC/C,OAAO,IAAA,mCAA0B,EAAC,OAAO,CAAC,CAAC;QAC7C,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;gBACrF,OAAO,IAAI,CAAC,CAAC,oBAAoB;YACnC,CAAC;YACD,kCAAkC;YAClC,SAAG,CAAC,KAAK,CAAC,wBAAwB,EAAE,KAAK,CAAC,CAAC;YAC3C,OAAO,IAAI,CAAC;QACd,CAAC;IAAA,CACF;IAED;;OAEG;IACH,KAAK,CAAC,YAAY,CAAC,WAAmB,EAAE,OAAmB,EAAyB;QAClF,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,WAAW,EAAE,KAAK,IAAI,EAAE,CAAC;YACtD,IAAI,CAAC;gBACH,MAAM,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC;gBAC5D,MAAM,EAAE,CAAC,KAAK,CAAC,YAAY,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;gBAClD,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;gBAErD,kCAAkC;gBAClC,MAAM,cAAc,GAAG;oBACrB,GAAG,OAAO;oBACV,QAAQ,EAAE;wBACR,GAAG,OAAO,CAAC,QAAQ;wBACnB,OAAO,EAAE,IAAI;qBACd;iBACF,CAAC;gBAEF,wEAAwE;gBACxE,6EAA6E;gBAC7E,MAAM,IAAA,2BAAe,EAAC,WAAW,EAAE,IAAI,CAAC,SAAS,CAAC,cAAc,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;gBAC5E,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;YACvB,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACvE,OAAO,IAAA,YAAG,EAAC,4BAA4B,OAAO,EAAE,CAAC,CAAC;YACpD,CAAC;QAAA,CACF,CAAC,CAAC;IAAA,CACJ;IAED;;OAEG;IACH,KAAK,CAAC,aAAa,CAAC,WAAmB,EAAyB;QAC9D,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,WAAW,EAAE,KAAK,IAAI,EAAE,CAAC;YACtD,IAAI,CAAC;gBACH,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;gBACrD,MAAM,EAAE,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;gBAC7B,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;YACvB,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,IAAI,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;oBACrF,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC,CAAC,kBAAkB;gBAC1C,CAAC;gBACD,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACvE,OAAO,IAAA,YAAG,EAAC,6BAA6B,OAAO,EAAE,CAAC,CAAC;YACrD,CAAC;QAAA,CACF,CAAC,CAAC;IAAA,CACJ;IAED;;;;;;;;;;OAUG;IACH,KAAK,CAAC,eAAe,CAAC,WAAmB,EAAyB;QAChE,IAAI,CAAC;YACH,IAAI,OAAO,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;YAClD,IAAI,CAAC,OAAO,EAAE,CAAC;gBACb,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC,CAAC,uBAAuB;YAC/C,CAAC;YAED,oEAAoE;YACpE,yEAAyE;YACzE,mEAAmE;YACnE,IAAI,OAAO,CAAC,QAAQ,EAAE,KAAK,EAAE,CAAC;gBAC5B,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,GAAG,aAAa,EAAE,GAAG,OAAO,CAAC,QAAQ,CAAC;gBAChE,OAAO,GAAG,EAAE,GAAG,OAAO,EAAE,QAAQ,EAAE,aAAa,EAAE,CAAC;YACpD,CAAC;YAED,MAAM,UAAU,GAAG,OAAO,CAAC,QAAQ,EAAE,eAAe,CAAC;YACrD,IAAI,UAAU,KAAK,SAAS,EAAE,CAAC;gBAC7B,OAAO,IAAA,YAAG,EAAC,wCAAwC,CAAC,CAAC;YACvD,CAAC;YAED,kEAAkE;YAClE,4FAA4F;YAC5F,2EAA2E;YAC3E,oFAAkF;YAClF,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,4BAA4B,CAAC,WAAW,CAAC,CAAC;YAC1F,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,CAAC;gBAC3B,OAAO,IAAA,YAAG,EAAC,2BAA2B,aAAa,CAAC,KAAK,EAAE,CAAC,CAAC;YAC/D,CAAC;YAED,MAAM,gBAAgB,GAAG,aAAa,CAAC,IAAI,CAAC;YAE5C,MAAM,oBAAoB,GAAG,CAAC,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC;gBAChE,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM,EAAE,CAAC;oBACzB,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC;gBACrC,CAAC;gBAED,IAAI,IAAI,CAAC,IAAI,KAAK,WAAW,EAAE,CAAC;oBAC9B,kFAAkF;oBAClF,0CAA0C;oBAC1C,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC;gBACrC,CAAC;gBAED,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM,EAAE,CAAC;oBACzB,OAAO,IAAI,CAAC;gBACd,CAAC;gBAED,IAAI,IAAI,CAAC,IAAI,KAAK,cAAc,EAAE,CAAC;oBACjC,+EAA+E;oBAC/E,kFAAkF;oBAClF,mDAAmD;oBACnD,OAAO,IAAI,CAAC,KAAK,KAAK,kBAAkB,CAAC;gBAC3C,CAAC;gBAED,OAAO,KAAK,CAAC;YAAA,CACd,CAAC,CAAC;YACH,MAAM,eAAe,GAAG,gBAAgB,CAAC,IAAI,CAC3C,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,QAAQ,EAAE,eAAe,KAAK,UAAU,CACtD,CAAC;YAEF,MAAM,YAAY,GAChB,CAAC,CAAC,eAAe,IAAI,oCAAoC;gBACvD,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,IAAI,CAAC,CAAC,GAAG,CAAC,eAAe,CAAC,KAAK,EAAE,MAAM,IAAI,CAAC,CAAC,CAAC,IAAI,yBAAyB;gBACnG,oBAAoB,CAAC,CAAC,iDAAiD;YAEzE,IAAI,YAAY,EAAE,CAAC;gBACjB,IAAI,eAAe,EAAE,CAAC;oBACpB,wEAAwE;oBACxE,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;oBACnF,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;wBAC1B,OAAO,YAAY,CAAC;oBACtB,CAAC;gBACH,CAAC;qBAAM,CAAC;oBACN,oDAAoD;oBACpD,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;oBACrF,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;wBAC1B,OAAO,YAAY,CAAC;oBACtB,CAAC;gBACH,CAAC;YACH,CAAC;YAED,wEAAwE;YACxE,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC;QAC/C,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACvE,OAAO,IAAA,YAAG,EAAC,6BAA6B,OAAO,EAAE,CAAC,CAAC;QACrD,CAAC;IAAA,CACF;CACF","sourcesContent":["import * as fs from \"fs/promises\";\r\nimport * as path from \"path\";\r\nimport writeFileAtomic from \"write-file-atomic\";\r\nimport type { Result } from \"@/common/types/result\";\r\nimport { Ok, Err } from \"@/common/types/result\";\r\nimport type { MuxMessage } from \"@/common/types/message\";\r\nimport type { Config } from \"@/node/config\";\r\nimport type { HistoryService } from \"./historyService\";\r\nimport { workspaceFileLocks } from \"@/node/utils/concurrency/workspaceFileLocks\";\r\nimport { normalizeLegacyMuxMetadata } from \"@/node/utils/messages/legacy\";\r\nimport { log } from \"@/node/services/log\";\r\n\r\n/**\r\n * PartialService - Manages partial message persistence for interrupted streams\r\n *\r\n * Responsibilities:\r\n * - Read/write/delete partial.json for all workspaces\r\n * - Commit partial messages to history when appropriate\r\n * - Encapsulate partial message lifecycle logic\r\n * - Synchronize file operations per workspace using MutexMap\r\n *\r\n * Separation of Concerns:\r\n * - PartialService owns partial.json\r\n * - HistoryService owns chat.jsonl\r\n * - StreamManager only interacts with PartialService\r\n * - AIService orchestrates both services\r\n *\r\n * This is a singleton service that manages partials for all workspaces.\r\n */\r\nexport class PartialService {\r\n  private readonly PARTIAL_FILE = \"partial.json\";\r\n  private readonly historyService: HistoryService;\r\n  // Shared file operation lock across all workspace file services\r\n  // This prevents deadlocks when services call each other (e.g., PartialService → HistoryService)\r\n  private readonly fileLocks = workspaceFileLocks;\r\n  private readonly config: Config;\r\n\r\n  constructor(config: Config, historyService: HistoryService) {\r\n    this.config = config;\r\n    this.historyService = historyService;\r\n  }\r\n\r\n  private getPartialPath(workspaceId: string): string {\r\n    return path.join(this.config.getSessionDir(workspaceId), this.PARTIAL_FILE);\r\n  }\r\n\r\n  /**\r\n   * Read the partial message for a workspace, if it exists\r\n   */\r\n  async readPartial(workspaceId: string): Promise<MuxMessage | null> {\r\n    try {\r\n      const partialPath = this.getPartialPath(workspaceId);\r\n      const data = await fs.readFile(partialPath, \"utf-8\");\r\n      const message = JSON.parse(data) as MuxMessage;\r\n      return normalizeLegacyMuxMetadata(message);\r\n    } catch (error) {\r\n      if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\r\n        return null; // No partial exists\r\n      }\r\n      // Log other errors but don't fail\r\n      log.error(\"Error reading partial:\", error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write a partial message to disk (with file locking per workspace)\r\n   */\r\n  async writePartial(workspaceId: string, message: MuxMessage): Promise<Result<void>> {\r\n    return this.fileLocks.withLock(workspaceId, async () => {\r\n      try {\r\n        const workspaceDir = this.config.getSessionDir(workspaceId);\r\n        await fs.mkdir(workspaceDir, { recursive: true });\r\n        const partialPath = this.getPartialPath(workspaceId);\r\n\r\n        // Ensure message has partial flag\r\n        const partialMessage = {\r\n          ...message,\r\n          metadata: {\r\n            ...message.metadata,\r\n            partial: true,\r\n          },\r\n        };\r\n\r\n        // Atomic write: writes to temp file then renames, preventing corruption\r\n        // if app crashes mid-write (prevents \"Unexpected end of JSON input\" on read)\r\n        await writeFileAtomic(partialPath, JSON.stringify(partialMessage, null, 2));\r\n        return Ok(undefined);\r\n      } catch (error) {\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        return Err(`Failed to write partial: ${message}`);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Delete the partial message file for a workspace (with file locking)\r\n   */\r\n  async deletePartial(workspaceId: string): Promise<Result<void>> {\r\n    return this.fileLocks.withLock(workspaceId, async () => {\r\n      try {\r\n        const partialPath = this.getPartialPath(workspaceId);\r\n        await fs.unlink(partialPath);\r\n        return Ok(undefined);\r\n      } catch (error) {\r\n        if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\r\n          return Ok(undefined); // Already deleted\r\n        }\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        return Err(`Failed to delete partial: ${message}`);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Commit any existing partial message to chat.jsonl and delete partial.json.\r\n   * This is idempotent - if the partial has already been finalized in history,\r\n   * it won't be committed again (preventing double-commits).\r\n   * After committing (or if already finalized), partial.json is deleted.\r\n   *\r\n   * Smart commit logic:\r\n   * - If no message with this sequence exists in history: APPEND\r\n   * - If message exists but partial has more parts: UPDATE in place\r\n   * - Otherwise: skip commit (already finalized)\r\n   */\r\n  async commitToHistory(workspaceId: string): Promise<Result<void>> {\r\n    try {\r\n      let partial = await this.readPartial(workspaceId);\r\n      if (!partial) {\r\n        return Ok(undefined); // No partial to commit\r\n      }\r\n\r\n      // Strip error metadata if present, but commit the accumulated parts\r\n      // Error metadata is transient (UI-only), accumulated parts are persisted\r\n      // This ensures resumptions don't lose progress from failed streams\r\n      if (partial.metadata?.error) {\r\n        const { error, errorType, ...cleanMetadata } = partial.metadata;\r\n        partial = { ...partial, metadata: cleanMetadata };\r\n      }\r\n\r\n      const partialSeq = partial.metadata?.historySequence;\r\n      if (partialSeq === undefined) {\r\n        return Err(\"Partial message has no historySequence\");\r\n      }\r\n\r\n      // Check if this partial has already been finalized in chat.jsonl.\r\n      // A partial with MORE parts than what's in history means it's newer and should be committed\r\n      // (placeholder has empty parts, interrupted stream has accumulated parts).\r\n      // Only the current compaction epoch matters — partial messages are always recent.\r\n      const historyResult = await this.historyService.getHistoryFromLatestBoundary(workspaceId);\r\n      if (!historyResult.success) {\r\n        return Err(`Failed to read history: ${historyResult.error}`);\r\n      }\r\n\r\n      const existingMessages = historyResult.data;\r\n\r\n      const hasCommitWorthyParts = (partial.parts ?? []).some((part) => {\r\n        if (part.type === \"text\") {\r\n          return part.text.trim().length > 0;\r\n        }\r\n\r\n        if (part.type === \"reasoning\") {\r\n          // Reasoning may be needed for provider-specific replay (e.g., Extended Thinking).\r\n          // It is real content and safe to persist.\r\n          return part.text.trim().length > 0;\r\n        }\r\n\r\n        if (part.type === \"file\") {\r\n          return true;\r\n        }\r\n\r\n        if (part.type === \"dynamic-tool\") {\r\n          // Incomplete tool calls (input-available) are dropped when converting messages\r\n          // for provider requests (ignoreIncompleteToolCalls: true). Persisting a tool-only\r\n          // partial can brick future requests after a crash.\r\n          return part.state === \"output-available\";\r\n        }\r\n\r\n        return false;\r\n      });\r\n      const existingMessage = existingMessages.find(\r\n        (msg) => msg.metadata?.historySequence === partialSeq\r\n      );\r\n\r\n      const shouldCommit =\r\n        (!existingMessage || // No message with this sequence yet\r\n          (partial.parts?.length ?? 0) > (existingMessage.parts?.length ?? 0)) && // Partial has more parts\r\n        hasCommitWorthyParts; // Don't commit tool-only incomplete placeholders\r\n\r\n      if (shouldCommit) {\r\n        if (existingMessage) {\r\n          // Message exists (placeholder) - UPDATE it in place to avoid duplicates\r\n          const updateResult = await this.historyService.updateHistory(workspaceId, partial);\r\n          if (!updateResult.success) {\r\n            return updateResult;\r\n          }\r\n        } else {\r\n          // No message with this sequence - APPEND to history\r\n          const appendResult = await this.historyService.appendToHistory(workspaceId, partial);\r\n          if (!appendResult.success) {\r\n            return appendResult;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Delete partial.json after successful commit (or if already finalized)\r\n      return await this.deletePartial(workspaceId);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      return Err(`Failed to commit partial: ${message}`);\r\n    }\r\n  }\r\n}\r\n"]}