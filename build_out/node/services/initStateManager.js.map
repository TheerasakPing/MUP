{"version":3,"file":"initStateManager.js","sourceRoot":"","sources":["../../../src/node/services/initStateManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from \"events\";\r\nimport type { Config } from \"@/node/config\";\r\nimport { EventStore } from \"@/node/utils/eventStore\";\r\nimport type { WorkspaceInitEvent } from \"@/common/orpc/types\";\r\nimport { log } from \"@/node/services/log\";\r\nimport { INIT_HOOK_MAX_LINES } from \"@/common/constants/toolLimits\";\r\n\r\n/**\r\n * Output line with timestamp for replay timing.\r\n */\r\nexport interface TimedLine {\r\n  line: string;\r\n  isError: boolean; // true if from stderr\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * Persisted state for init hooks.\r\n * Stored in ~/.mux/sessions/{workspaceId}/init-status.json\r\n */\r\nexport interface InitStatus {\r\n  status: \"running\" | \"success\" | \"error\";\r\n  /** Phase of initialization (optional for backwards compat with persisted data). */\r\n  phase?: \"runtime_setup\" | \"init_hook\";\r\n  hookPath: string;\r\n  startTime: number;\r\n  /** Timestamp when init hook started (used for timeout calculations). */\r\n  hookStartTime?: number;\r\n  lines: TimedLine[];\r\n  exitCode: number | null;\r\n  endTime: number | null; // When init-end event occurred\r\n  /** Number of lines dropped from middle when output exceeded INIT_HOOK_MAX_LINES */\r\n  truncatedLines?: number;\r\n}\r\n\r\n/**\r\n * In-memory state for active init hooks.\r\n * Currently identical to InitStatus, but kept separate for future extension.\r\n */\r\ntype InitHookState = InitStatus;\r\n\r\n/**\r\n * InitStateManager - Manages init hook lifecycle with persistence and replay.\r\n *\r\n * Uses EventStore abstraction for state management:\r\n * - In-memory Map for active init hooks (via EventStore)\r\n * - Disk persistence to init-status.json for replay across page reloads\r\n * - EventEmitter for streaming events to AgentSession\r\n * - Permanent storage (never auto-deleted, unlike stream partials)\r\n *\r\n * Key differences from StreamManager:\r\n * - Simpler state machine (running â†’ success/error, no abort)\r\n * - No throttling (init hooks emit discrete lines, not streaming tokens)\r\n * - Permanent persistence (init logs kept forever as workspace metadata)\r\n *\r\n * Lifecycle:\r\n * 1. startInit() - Create in-memory state, emit init-start, create completion promise\r\n * 2. appendOutput() - Accumulate lines, emit init-output\r\n * 3. endInit() - Finalize state, write to disk, emit init-end, resolve promise\r\n * 4. State remains in memory until cleared or process restart\r\n * 5. replayInit() - Re-emit events from in-memory or disk state (via EventStore)\r\n *\r\n * Waiting: Tools use waitForInit() which returns a promise that resolves when\r\n * init completes. This promise is stored in initPromises map and resolved by\r\n * endInit(). No event listeners needed, eliminating race conditions.\r\n */\r\nexport class InitStateManager extends EventEmitter {\r\n  private readonly store: EventStore<InitHookState, WorkspaceInitEvent & { workspaceId: string }>;\r\n\r\n  /**\r\n   * Promise-based completion tracking for running inits.\r\n   * Each running init has a promise that resolves when endInit() is called.\r\n   * Multiple tools can await the same promise without race conditions.\r\n   */\r\n  private readonly initPromises = new Map<\r\n    string,\r\n    {\r\n      promise: Promise<void>;\r\n      resolve: () => void;\r\n      reject: (error: Error) => void;\r\n      hookPhasePromise: Promise<void>;\r\n      resolveHookPhase: () => void;\r\n    }\r\n  >();\r\n\r\n  constructor(config: Config) {\r\n    super();\r\n    this.store = new EventStore(\r\n      config,\r\n      \"init-status.json\",\r\n      (state) => this.serializeInitEvents(state),\r\n      (event) => this.emit(event.type, event),\r\n      \"InitStateManager\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Serialize InitHookState into array of events for replay.\r\n   * Used by EventStore.replay() to reconstruct the event stream.\r\n   */\r\n  private serializeInitEvents(\r\n    state: InitHookState & { workspaceId?: string }\r\n  ): Array<WorkspaceInitEvent & { workspaceId: string }> {\r\n    const events: Array<WorkspaceInitEvent & { workspaceId: string }> = [];\r\n    const workspaceId = state.workspaceId ?? \"unknown\";\r\n\r\n    // Emit init-start\r\n    events.push({\r\n      type: \"init-start\",\r\n      workspaceId,\r\n      hookPath: state.hookPath,\r\n      timestamp: state.startTime,\r\n    });\r\n\r\n    // Emit init-output for each accumulated line with original timestamps\r\n    // Defensive: state.lines could be undefined from old persisted data\r\n    let lines = state.lines ?? [];\r\n    let truncatedLines = state.truncatedLines ?? 0;\r\n\r\n    // Truncate old persisted data that exceeded the limit (backwards compat)\r\n    if (lines.length > INIT_HOOK_MAX_LINES) {\r\n      const excessLines = lines.length - INIT_HOOK_MAX_LINES;\r\n      lines = lines.slice(-INIT_HOOK_MAX_LINES); // Keep tail\r\n      truncatedLines += excessLines;\r\n      log.info(\r\n        `[InitStateManager] Truncated ${excessLines} lines from old persisted data for ${workspaceId}`\r\n      );\r\n    }\r\n\r\n    for (const timedLine of lines) {\r\n      // Skip malformed entries (missing required fields)\r\n      if (typeof timedLine.line !== \"string\" || typeof timedLine.timestamp !== \"number\") {\r\n        log.warn(`[InitStateManager] Skipping malformed init-output:`, timedLine);\r\n        continue;\r\n      }\r\n      events.push({\r\n        type: \"init-output\",\r\n        workspaceId,\r\n        line: timedLine.line,\r\n        isError: timedLine.isError,\r\n        timestamp: timedLine.timestamp, // Use original timestamp for replay\r\n      });\r\n    }\r\n\r\n    // Emit init-end (only if completed)\r\n    if (state.exitCode !== null) {\r\n      events.push({\r\n        type: \"init-end\",\r\n        workspaceId,\r\n        exitCode: state.exitCode,\r\n        timestamp: state.endTime ?? state.startTime,\r\n        // Include truncation info so frontend can show indicator\r\n        ...(truncatedLines ? { truncatedLines } : {}),\r\n      });\r\n    }\r\n\r\n    return events;\r\n  }\r\n\r\n  /**\r\n   * Start tracking a new init hook execution.\r\n   * Creates in-memory state, completion promise, and emits init-start event.\r\n   */\r\n  startInit(workspaceId: string, hookPath: string): void {\r\n    const startTime = Date.now();\r\n\r\n    const state: InitHookState = {\r\n      status: \"running\",\r\n      phase: \"runtime_setup\",\r\n      hookPath,\r\n      startTime,\r\n      lines: [],\r\n      exitCode: null,\r\n      endTime: null,\r\n    };\r\n\r\n    this.store.setState(workspaceId, state);\r\n\r\n    // Create completion promise for this init\r\n    // This allows multiple tools to await the same init without event listeners\r\n    let resolve: () => void;\r\n    let reject: (error: Error) => void;\r\n    let resolveHookPhase: () => void;\r\n    const promise = new Promise<void>((res, rej) => {\r\n      resolve = res;\r\n      reject = rej;\r\n    });\r\n    // Prevent unhandled rejections if a workspace is deleted before any waiters attach.\r\n    promise.catch(() => undefined);\r\n    const hookPhasePromise = new Promise<void>((res) => {\r\n      resolveHookPhase = res;\r\n    });\r\n\r\n    this.initPromises.set(workspaceId, {\r\n      promise,\r\n      resolve: resolve!,\r\n      reject: reject!,\r\n      hookPhasePromise,\r\n      resolveHookPhase: resolveHookPhase!,\r\n    });\r\n\r\n    log.debug(`Init hook started for workspace ${workspaceId}: ${hookPath}`);\r\n\r\n    // Emit init-start event\r\n    this.emit(\"init-start\", {\r\n      type: \"init-start\",\r\n      workspaceId,\r\n      hookPath,\r\n      timestamp: startTime,\r\n    } satisfies WorkspaceInitEvent & { workspaceId: string });\r\n  }\r\n\r\n  /**\r\n   * Signal that the .mux/init hook is starting.\r\n   * This marks the transition from runtime provisioning to hook execution so\r\n   * waitForInit() can start the 5-minute timeout at the right time.\r\n   */\r\n  enterHookPhase(workspaceId: string): void {\r\n    const state = this.store.getState(workspaceId);\r\n    if (state?.status !== \"running\") {\r\n      return;\r\n    }\r\n\r\n    if ((state.phase ?? \"runtime_setup\") === \"init_hook\") {\r\n      return;\r\n    }\r\n\r\n    state.phase = \"init_hook\";\r\n    state.hookStartTime = Date.now();\r\n\r\n    const promiseEntry = this.initPromises.get(workspaceId);\r\n    promiseEntry?.resolveHookPhase();\r\n  }\r\n\r\n  /**\r\n   * Append output line from init hook.\r\n   * Accumulates in state (with truncation for long output) and emits init-output event.\r\n   *\r\n   * Truncation strategy: Keep only the most recent INIT_HOOK_MAX_LINES lines (tail).\r\n   * Older lines are dropped to prevent OOM with large rsync/build output.\r\n   */\r\n  appendOutput(workspaceId: string, line: string, isError: boolean): void {\r\n    const state = this.store.getState(workspaceId);\r\n\r\n    if (!state) {\r\n      log.error(`appendOutput called for workspace ${workspaceId} with no active init state`);\r\n      return;\r\n    }\r\n\r\n    const timestamp = Date.now();\r\n    const timedLine: TimedLine = { line, isError, timestamp };\r\n\r\n    // Truncation: keep only the most recent MAX_LINES\r\n    if (state.lines.length >= INIT_HOOK_MAX_LINES) {\r\n      state.lines.shift(); // Drop oldest line\r\n      state.truncatedLines = (state.truncatedLines ?? 0) + 1;\r\n    }\r\n    state.lines.push(timedLine);\r\n\r\n    // Emit init-output event (always emit for live streaming, even if truncated from storage)\r\n    this.emit(\"init-output\", {\r\n      type: \"init-output\",\r\n      workspaceId,\r\n      line,\r\n      isError,\r\n      timestamp,\r\n    } satisfies WorkspaceInitEvent & { workspaceId: string });\r\n  }\r\n\r\n  /**\r\n   * Finalize init hook execution.\r\n   * Updates state, persists to disk, emits init-end event, and resolves completion promise.\r\n   *\r\n   * IMPORTANT: We persist BEFORE updating in-memory exitCode to prevent a race condition\r\n   * where replay() sees exitCode !== null but the file doesn't exist yet. This ensures\r\n   * the invariant: if init-end is visible (live or replay), the file MUST exist.\r\n   */\r\n  async endInit(workspaceId: string, exitCode: number): Promise<void> {\r\n    const state = this.store.getState(workspaceId);\r\n\r\n    if (!state) {\r\n      log.error(`endInit called for workspace ${workspaceId} with no active init state`);\r\n      return;\r\n    }\r\n\r\n    const endTime = Date.now();\r\n    const finalStatus = exitCode === 0 ? \"success\" : \"error\";\r\n\r\n    // Create complete state for persistence (don't mutate in-memory state yet)\r\n    const stateToPerist: InitHookState = {\r\n      ...state,\r\n      status: finalStatus,\r\n      exitCode,\r\n      endTime,\r\n    };\r\n\r\n    // Persist FIRST - ensures file exists before in-memory state shows completion\r\n    await this.store.persist(workspaceId, stateToPerist, {\r\n      // If WorkspaceService.remove() cleared init state, do not recreate ~/.mux/sessions/<id>/\r\n      shouldWrite: () => this.store.hasState(workspaceId),\r\n    });\r\n\r\n    // NOW update in-memory state (replay will now see file exists)\r\n    state.status = finalStatus;\r\n    state.exitCode = exitCode;\r\n    state.endTime = endTime;\r\n\r\n    log.info(\r\n      `Init hook ${state.status} for workspace ${workspaceId} (exit code ${exitCode}, duration ${endTime - state.startTime}ms)`\r\n    );\r\n\r\n    // Emit init-end event\r\n    this.emit(\"init-end\", {\r\n      type: \"init-end\",\r\n      workspaceId,\r\n      exitCode,\r\n      timestamp: endTime,\r\n      // Include truncation info so frontend can show indicator\r\n      ...(state.truncatedLines ? { truncatedLines: state.truncatedLines } : {}),\r\n    } satisfies WorkspaceInitEvent & { workspaceId: string });\r\n\r\n    // Resolve completion promise for waiting tools\r\n    const promiseEntry = this.initPromises.get(workspaceId);\r\n    if (promiseEntry) {\r\n      promiseEntry.resolve();\r\n      this.initPromises.delete(workspaceId);\r\n    }\r\n\r\n    // Keep state in memory for replay (unlike streams which delete immediately)\r\n  }\r\n\r\n  /**\r\n   * Get current in-memory init state for a workspace.\r\n   * Returns undefined if no init state exists.\r\n   */\r\n  getInitState(workspaceId: string): InitHookState | undefined {\r\n    return this.store.getState(workspaceId);\r\n  }\r\n\r\n  /**\r\n   * Read persisted init status from disk.\r\n   * Returns null if no status file exists.\r\n   */\r\n  async readInitStatus(workspaceId: string): Promise<InitStatus | null> {\r\n    return this.store.readPersisted(workspaceId);\r\n  }\r\n\r\n  /**\r\n   * Replay init events for a workspace.\r\n   * Delegates to EventStore.replay() which:\r\n   * 1. Checks in-memory state first, then falls back to disk\r\n   * 2. Serializes state into events via serializeInitEvents()\r\n   * 3. Emits events (init-start, init-output*, init-end)\r\n   *\r\n   * This is called during AgentSession.emitHistoricalEvents() to ensure\r\n   * init state is visible after page reloads.\r\n   */\r\n  async replayInit(workspaceId: string): Promise<void> {\r\n    // Pass workspaceId as context for serialization\r\n    await this.store.replay(workspaceId, { workspaceId });\r\n  }\r\n\r\n  /**\r\n   * Delete persisted init status from disk.\r\n   * Useful for testing or manual cleanup.\r\n   * Does NOT clear in-memory state (for active replay).\r\n   */\r\n  async deleteInitStatus(workspaceId: string): Promise<void> {\r\n    await this.store.deletePersisted(workspaceId);\r\n  }\r\n\r\n  /**\r\n   * Clear in-memory state for a workspace.\r\n   * Useful for testing or cleanup after workspace deletion.\r\n   * Does NOT delete disk file (use deleteInitStatus for that).\r\n   *\r\n   * Also cancels any running init promises to prevent orphaned waiters.\r\n   */\r\n  clearInMemoryState(workspaceId: string): void {\r\n    this.store.deleteState(workspaceId);\r\n\r\n    // Cancel any running init promise for this workspace\r\n    const promiseEntry = this.initPromises.get(workspaceId);\r\n    if (promiseEntry) {\r\n      promiseEntry.reject(new Error(`Workspace ${workspaceId} was deleted`));\r\n      promiseEntry.resolveHookPhase();\r\n      this.initPromises.delete(workspaceId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Wait for workspace initialization to complete.\r\n   * Used by tools (bash, file_*) to ensure files are ready before executing.\r\n   *\r\n   * Behavior:\r\n   * - No init state: Returns immediately (init not needed or backwards compat)\r\n   * - Init succeeded/failed: Returns immediately (tools proceed regardless of init outcome)\r\n   * - Init running: waits for runtime provisioning to reach the hook phase (no timeout),\r\n   *   then waits up to 5 minutes from hook start before proceeding anyway.\r\n   * - If abortSignal is provided, resolves early when aborted.\r\n   * - If the workspace is deleted during init, resolves early when state is cleared.\r\n   *\r\n   * This method NEVER throws - tools should always proceed. If init fails or times out,\r\n   * the tool will either succeed (if init wasn't critical) or fail with its own error\r\n   * (e.g., file not found). This provides better error messages than blocking on init.\r\n   *\r\n   * Promise-based approach eliminates race conditions:\r\n   * - Multiple tools share the same promise (no duplicate listeners)\r\n   * - No event cleanup needed (promise auto-resolves once)\r\n   * - Timeout races handled by Promise.race()\r\n   *\r\n   * @param workspaceId Workspace ID to wait for\r\n   * @param abortSignal Optional signal to abort the wait early\r\n   */\r\n  async waitForInit(workspaceId: string, abortSignal?: AbortSignal): Promise<void> {\r\n    const state = this.getInitState(workspaceId);\r\n\r\n    // No init state - proceed immediately (backwards compat or init not needed)\r\n    if (!state) {\r\n      return;\r\n    }\r\n\r\n    // Init already completed (success or failure) - proceed immediately\r\n    // Tools should work regardless of init outcome\r\n    if (state.status !== \"running\") {\r\n      return;\r\n    }\r\n\r\n    // Early exit if already aborted\r\n    if (abortSignal?.aborted) {\r\n      return;\r\n    }\r\n\r\n    // Init is running - wait for completion promise with timeout\r\n    const promiseEntry = this.initPromises.get(workspaceId);\r\n\r\n    if (!promiseEntry) {\r\n      // State says running but no promise exists (shouldn't happen, but handle gracefully)\r\n      log.error(`Init state is running for ${workspaceId} but no promise found, proceeding`);\r\n      return;\r\n    }\r\n\r\n    const INIT_HOOK_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes\r\n\r\n    // Track cleanup handlers\r\n    let timeoutId: NodeJS.Timeout | undefined;\r\n    let abortHandler: (() => void) | undefined;\r\n\r\n    try {\r\n      const abortPromise = new Promise<void>((resolve) => {\r\n        if (!abortSignal) return; // Never resolves if no signal\r\n        if (abortSignal.aborted) {\r\n          resolve();\r\n          return;\r\n        }\r\n        abortHandler = () => resolve();\r\n        abortSignal.addEventListener(\"abort\", abortHandler, { once: true });\r\n      });\r\n\r\n      // Intentional: provisioning (Coder/devcontainer/etc.) can be long-running, so we\r\n      // avoid timeouts until .mux/init begins. The wait is still interruptible via\r\n      // abortSignal or workspace deletion (clearInMemoryState).\r\n      const phase = state.phase ?? \"runtime_setup\";\r\n      if (phase === \"runtime_setup\") {\r\n        const first = await Promise.race([\r\n          promiseEntry.promise.then(() => \"complete\"),\r\n          promiseEntry.hookPhasePromise.then(() => \"hook\"),\r\n          abortPromise.then(() => \"abort\"),\r\n        ]);\r\n        if (first !== \"hook\") {\r\n          return;\r\n        }\r\n      }\r\n\r\n      const hookStart = state.hookStartTime ?? state.startTime;\r\n      const elapsed = Date.now() - hookStart;\r\n      const remaining = Math.max(0, INIT_HOOK_TIMEOUT_MS - elapsed);\r\n\r\n      const timeoutPromise = new Promise<void>((resolve) => {\r\n        timeoutId = setTimeout(() => {\r\n          log.error(\r\n            `Init timeout for ${workspaceId} after 5 minutes - tools will proceed anyway. ` +\r\n              `Init will continue in background.`\r\n          );\r\n          resolve();\r\n        }, remaining);\r\n        // Don't keep Node alive just for this timeout (allows tests to exit)\r\n        timeoutId.unref();\r\n      });\r\n\r\n      // Race between completion, timeout, and abort\r\n      await Promise.race([promiseEntry.promise, timeoutPromise, abortPromise]);\r\n    } catch (error) {\r\n      // Init promise was rejected (e.g., workspace deleted)\r\n      // Log and proceed anyway - let the tool fail with its own error if needed\r\n      const errorMsg = error instanceof Error ? error.message : String(error);\r\n      log.error(`Init wait interrupted for ${workspaceId}: ${errorMsg} - proceeding anyway`);\r\n    } finally {\r\n      // Clean up timeout to prevent spurious error logs\r\n      if (timeoutId) clearTimeout(timeoutId);\r\n      // Clean up abort listener to prevent memory leak\r\n      if (abortHandler && abortSignal) {\r\n        abortSignal.removeEventListener(\"abort\", abortHandler);\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}