{"version":3,"file":"initStateManager.js","sourceRoot":"","sources":["../../../src/node/services/initStateManager.ts"],"names":[],"mappings":";;;AAAA,mCAAsC;AAEtC,wDAAqD;AAErD,6CAA0C;AAC1C,8DAAoE;AAoCpE;;;;;;;;;;;;;;;;;;;;;;;;GAwBG;AACH,sBAA8B,SAAQ,qBAAY;IAC/B,KAAK,CAA0E;IAEhG;;;;OAIG;IACc,YAAY,GAAG,IAAI,GAAG,EASpC,CAAC;IAEJ,YAAY,MAAc,EAAE;QAC1B,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,KAAK,GAAG,IAAI,uBAAU,CACzB,MAAM,EACN,kBAAkB,EAClB,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAC1C,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,EACvC,kBAAkB,CACnB,CAAC;IAAA,CACH;IAED;;;OAGG;IACK,mBAAmB,CACzB,KAA+C,EACM;QACrD,MAAM,MAAM,GAAwD,EAAE,CAAC;QACvE,MAAM,WAAW,GAAG,KAAK,CAAC,WAAW,IAAI,SAAS,CAAC;QAEnD,kBAAkB;QAClB,MAAM,CAAC,IAAI,CAAC;YACV,IAAI,EAAE,YAAY;YAClB,WAAW;YACX,QAAQ,EAAE,KAAK,CAAC,QAAQ;YACxB,SAAS,EAAE,KAAK,CAAC,SAAS;SAC3B,CAAC,CAAC;QAEH,sEAAsE;QACtE,oEAAoE;QACpE,IAAI,KAAK,GAAG,KAAK,CAAC,KAAK,IAAI,EAAE,CAAC;QAC9B,IAAI,cAAc,GAAG,KAAK,CAAC,cAAc,IAAI,CAAC,CAAC;QAE/C,yEAAyE;QACzE,IAAI,KAAK,CAAC,MAAM,GAAG,gCAAmB,EAAE,CAAC;YACvC,MAAM,WAAW,GAAG,KAAK,CAAC,MAAM,GAAG,gCAAmB,CAAC;YACvD,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,gCAAmB,CAAC,CAAC,CAAC,YAAY;YACvD,cAAc,IAAI,WAAW,CAAC;YAC9B,SAAG,CAAC,IAAI,CACN,gCAAgC,WAAW,sCAAsC,WAAW,EAAE,CAC/F,CAAC;QACJ,CAAC;QAED,KAAK,MAAM,SAAS,IAAI,KAAK,EAAE,CAAC;YAC9B,mDAAmD;YACnD,IAAI,OAAO,SAAS,CAAC,IAAI,KAAK,QAAQ,IAAI,OAAO,SAAS,CAAC,SAAS,KAAK,QAAQ,EAAE,CAAC;gBAClF,SAAG,CAAC,IAAI,CAAC,oDAAoD,EAAE,SAAS,CAAC,CAAC;gBAC1E,SAAS;YACX,CAAC;YACD,MAAM,CAAC,IAAI,CAAC;gBACV,IAAI,EAAE,aAAa;gBACnB,WAAW;gBACX,IAAI,EAAE,SAAS,CAAC,IAAI;gBACpB,OAAO,EAAE,SAAS,CAAC,OAAO;gBAC1B,SAAS,EAAE,SAAS,CAAC,SAAS,EAAE,oCAAoC;aACrE,CAAC,CAAC;QACL,CAAC;QAED,oCAAoC;QACpC,IAAI,KAAK,CAAC,QAAQ,KAAK,IAAI,EAAE,CAAC;YAC5B,MAAM,CAAC,IAAI,CAAC;gBACV,IAAI,EAAE,UAAU;gBAChB,WAAW;gBACX,QAAQ,EAAE,KAAK,CAAC,QAAQ;gBACxB,SAAS,EAAE,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,SAAS;gBAC3C,yDAAyD;gBACzD,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,cAAc,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;aAC9C,CAAC,CAAC;QACL,CAAC;QAED,OAAO,MAAM,CAAC;IAAA,CACf;IAED;;;OAGG;IACH,SAAS,CAAC,WAAmB,EAAE,QAAgB,EAAQ;QACrD,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAE7B,MAAM,KAAK,GAAkB;YAC3B,MAAM,EAAE,SAAS;YACjB,KAAK,EAAE,eAAe;YACtB,QAAQ;YACR,SAAS;YACT,KAAK,EAAE,EAAE;YACT,QAAQ,EAAE,IAAI;YACd,OAAO,EAAE,IAAI;SACd,CAAC;QAEF,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;QAExC,0CAA0C;QAC1C,4EAA4E;QAC5E,IAAI,OAAmB,CAAC;QACxB,IAAI,MAA8B,CAAC;QACnC,IAAI,gBAA4B,CAAC;QACjC,MAAM,OAAO,GAAG,IAAI,OAAO,CAAO,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC;YAC9C,OAAO,GAAG,GAAG,CAAC;YACd,MAAM,GAAG,GAAG,CAAC;QAAA,CACd,CAAC,CAAC;QACH,oFAAoF;QACpF,OAAO,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC;QAC/B,MAAM,gBAAgB,GAAG,IAAI,OAAO,CAAO,CAAC,GAAG,EAAE,EAAE,CAAC;YAClD,gBAAgB,GAAG,GAAG,CAAC;QAAA,CACxB,CAAC,CAAC;QAEH,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,WAAW,EAAE;YACjC,OAAO;YACP,OAAO,EAAE,OAAQ;YACjB,MAAM,EAAE,MAAO;YACf,gBAAgB;YAChB,gBAAgB,EAAE,gBAAiB;SACpC,CAAC,CAAC;QAEH,SAAG,CAAC,KAAK,CAAC,mCAAmC,WAAW,KAAK,QAAQ,EAAE,CAAC,CAAC;QAEzE,wBAAwB;QACxB,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;YACtB,IAAI,EAAE,YAAY;YAClB,WAAW;YACX,QAAQ;YACR,SAAS,EAAE,SAAS;SACkC,CAAC,CAAC;IAAA,CAC3D;IAED;;;;OAIG;IACH,cAAc,CAAC,WAAmB,EAAQ;QACxC,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;QAC/C,IAAI,KAAK,EAAE,MAAM,KAAK,SAAS,EAAE,CAAC;YAChC,OAAO;QACT,CAAC;QAED,IAAI,CAAC,KAAK,CAAC,KAAK,IAAI,eAAe,CAAC,KAAK,WAAW,EAAE,CAAC;YACrD,OAAO;QACT,CAAC;QAED,KAAK,CAAC,KAAK,GAAG,WAAW,CAAC;QAC1B,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAEjC,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QACxD,YAAY,EAAE,gBAAgB,EAAE,CAAC;IAAA,CAClC;IAED;;;;;;OAMG;IACH,YAAY,CAAC,WAAmB,EAAE,IAAY,EAAE,OAAgB,EAAQ;QACtE,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;QAE/C,IAAI,CAAC,KAAK,EAAE,CAAC;YACX,SAAG,CAAC,KAAK,CAAC,qCAAqC,WAAW,4BAA4B,CAAC,CAAC;YACxF,OAAO;QACT,CAAC;QAED,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC7B,MAAM,SAAS,GAAc,EAAE,IAAI,EAAE,OAAO,EAAE,SAAS,EAAE,CAAC;QAE1D,kDAAkD;QAClD,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,IAAI,gCAAmB,EAAE,CAAC;YAC9C,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC,mBAAmB;YACxC,KAAK,CAAC,cAAc,GAAG,CAAC,KAAK,CAAC,cAAc,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QACzD,CAAC;QACD,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAE5B,0FAA0F;QAC1F,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;YACvB,IAAI,EAAE,aAAa;YACnB,WAAW;YACX,IAAI;YACJ,OAAO;YACP,SAAS;SAC6C,CAAC,CAAC;IAAA,CAC3D;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,OAAO,CAAC,WAAmB,EAAE,QAAgB,EAAiB;QAClE,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;QAE/C,IAAI,CAAC,KAAK,EAAE,CAAC;YACX,SAAG,CAAC,KAAK,CAAC,gCAAgC,WAAW,4BAA4B,CAAC,CAAC;YACnF,OAAO;QACT,CAAC;QAED,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC3B,MAAM,WAAW,GAAG,QAAQ,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,OAAO,CAAC;QAEzD,2EAA2E;QAC3E,MAAM,aAAa,GAAkB;YACnC,GAAG,KAAK;YACR,MAAM,EAAE,WAAW;YACnB,QAAQ;YACR,OAAO;SACR,CAAC;QAEF,8EAA8E;QAC9E,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,EAAE,aAAa,EAAE;YACnD,yFAAyF;YACzF,WAAW,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC;SACpD,CAAC,CAAC;QAEH,+DAA+D;QAC/D,KAAK,CAAC,MAAM,GAAG,WAAW,CAAC;QAC3B,KAAK,CAAC,QAAQ,GAAG,QAAQ,CAAC;QAC1B,KAAK,CAAC,OAAO,GAAG,OAAO,CAAC;QAExB,SAAG,CAAC,IAAI,CACN,aAAa,KAAK,CAAC,MAAM,kBAAkB,WAAW,eAAe,QAAQ,cAAc,OAAO,GAAG,KAAK,CAAC,SAAS,KAAK,CAC1H,CAAC;QAEF,sBAAsB;QACtB,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YACpB,IAAI,EAAE,UAAU;YAChB,WAAW;YACX,QAAQ;YACR,SAAS,EAAE,OAAO;YAClB,yDAAyD;YACzD,GAAG,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,cAAc,EAAE,KAAK,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;SACnB,CAAC,CAAC;QAE1D,+CAA+C;QAC/C,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QACxD,IAAI,YAAY,EAAE,CAAC;YACjB,YAAY,CAAC,OAAO,EAAE,CAAC;YACvB,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;QACxC,CAAC;QAED,4EAA4E;IAF3E,CAGF;IAED;;;OAGG;IACH,YAAY,CAAC,WAAmB,EAA6B;QAC3D,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;IAAA,CACzC;IAED;;;OAGG;IACH,KAAK,CAAC,cAAc,CAAC,WAAmB,EAA8B;QACpE,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC;IAAA,CAC9C;IAED;;;;;;;;;OASG;IACH,KAAK,CAAC,UAAU,CAAC,WAAmB,EAAiB;QACnD,gDAAgD;QAChD,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,WAAW,EAAE,EAAE,WAAW,EAAE,CAAC,CAAC;IAAA,CACvD;IAED;;;;OAIG;IACH,KAAK,CAAC,gBAAgB,CAAC,WAAmB,EAAiB;QACzD,MAAM,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;IAAA,CAC/C;IAED;;;;;;OAMG;IACH,kBAAkB,CAAC,WAAmB,EAAQ;QAC5C,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;QAEpC,qDAAqD;QACrD,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QACxD,IAAI,YAAY,EAAE,CAAC;YACjB,YAAY,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,aAAa,WAAW,cAAc,CAAC,CAAC,CAAC;YACvE,YAAY,CAAC,gBAAgB,EAAE,CAAC;YAChC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;QACxC,CAAC;IAAA,CACF;IAED;;;;;;;;;;;;;;;;;;;;;;;OAuBG;IACH,KAAK,CAAC,WAAW,CAAC,WAAmB,EAAE,WAAyB,EAAiB;QAC/E,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;QAE7C,4EAA4E;QAC5E,IAAI,CAAC,KAAK,EAAE,CAAC;YACX,OAAO;QACT,CAAC;QAED,oEAAoE;QACpE,+CAA+C;QAC/C,IAAI,KAAK,CAAC,MAAM,KAAK,SAAS,EAAE,CAAC;YAC/B,OAAO;QACT,CAAC;QAED,gCAAgC;QAChC,IAAI,WAAW,EAAE,OAAO,EAAE,CAAC;YACzB,OAAO;QACT,CAAC;QAED,6DAA6D;QAC7D,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAExD,IAAI,CAAC,YAAY,EAAE,CAAC;YAClB,qFAAqF;YACrF,SAAG,CAAC,KAAK,CAAC,6BAA6B,WAAW,mCAAmC,CAAC,CAAC;YACvF,OAAO;QACT,CAAC;QAED,MAAM,oBAAoB,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC,YAAY;QAExD,yBAAyB;QACzB,IAAI,SAAqC,CAAC;QAC1C,IAAI,YAAsC,CAAC;QAE3C,IAAI,CAAC;YACH,MAAM,YAAY,GAAG,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE,CAAC;gBAClD,IAAI,CAAC,WAAW;oBAAE,OAAO,CAAC,8BAA8B;gBACxD,IAAI,WAAW,CAAC,OAAO,EAAE,CAAC;oBACxB,OAAO,EAAE,CAAC;oBACV,OAAO;gBACT,CAAC;gBACD,YAAY,GAAG,GAAG,EAAE,CAAC,OAAO,EAAE,CAAC;gBAC/B,WAAW,CAAC,gBAAgB,CAAC,OAAO,EAAE,YAAY,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;YAAA,CACrE,CAAC,CAAC;YAEH,iFAAiF;YACjF,6EAA6E;YAC7E,0DAA0D;YAC1D,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,IAAI,eAAe,CAAC;YAC7C,IAAI,KAAK,KAAK,eAAe,EAAE,CAAC;gBAC9B,MAAM,KAAK,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC;oBAC/B,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC;oBAC3C,YAAY,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC;oBAChD,YAAY,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC;iBACjC,CAAC,CAAC;gBACH,IAAI,KAAK,KAAK,MAAM,EAAE,CAAC;oBACrB,OAAO;gBACT,CAAC;YACH,CAAC;YAED,MAAM,SAAS,GAAG,KAAK,CAAC,aAAa,IAAI,KAAK,CAAC,SAAS,CAAC;YACzD,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC;YACvC,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,oBAAoB,GAAG,OAAO,CAAC,CAAC;YAE9D,MAAM,cAAc,GAAG,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE,CAAC;gBACpD,SAAS,GAAG,UAAU,CAAC,GAAG,EAAE,CAAC;oBAC3B,SAAG,CAAC,KAAK,CACP,oBAAoB,WAAW,gDAAgD;wBAC7E,mCAAmC,CACtC,CAAC;oBACF,OAAO,EAAE,CAAC;gBAAA,CACX,EAAE,SAAS,CAAC,CAAC;gBACd,qEAAqE;gBACrE,SAAS,CAAC,KAAK,EAAE,CAAC;YAAA,CACnB,CAAC,CAAC;YAEH,8CAA8C;YAC9C,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,YAAY,CAAC,OAAO,EAAE,cAAc,EAAE,YAAY,CAAC,CAAC,CAAC;QAC3E,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,sDAAsD;YACtD,0EAA0E;YAC1E,MAAM,QAAQ,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACxE,SAAG,CAAC,KAAK,CAAC,6BAA6B,WAAW,KAAK,QAAQ,sBAAsB,CAAC,CAAC;QACzF,CAAC;gBAAS,CAAC;YACT,kDAAkD;YAClD,IAAI,SAAS;gBAAE,YAAY,CAAC,SAAS,CAAC,CAAC;YACvC,iDAAiD;YACjD,IAAI,YAAY,IAAI,WAAW,EAAE,CAAC;gBAChC,WAAW,CAAC,mBAAmB,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;YACzD,CAAC;QACH,CAAC;IAAA,CACF;CACF","sourcesContent":["import { EventEmitter } from \"events\";\nimport type { Config } from \"@/node/config\";\nimport { EventStore } from \"@/node/utils/eventStore\";\nimport type { WorkspaceInitEvent } from \"@/common/orpc/types\";\nimport { log } from \"@/node/services/log\";\nimport { INIT_HOOK_MAX_LINES } from \"@/common/constants/toolLimits\";\n\n/**\n * Output line with timestamp for replay timing.\n */\nexport interface TimedLine {\n  line: string;\n  isError: boolean; // true if from stderr\n  timestamp: number;\n}\n\n/**\n * Persisted state for init hooks.\n * Stored in ~/.mux/sessions/{workspaceId}/init-status.json\n */\nexport interface InitStatus {\n  status: \"running\" | \"success\" | \"error\";\n  /** Phase of initialization (optional for backwards compat with persisted data). */\n  phase?: \"runtime_setup\" | \"init_hook\";\n  hookPath: string;\n  startTime: number;\n  /** Timestamp when init hook started (used for timeout calculations). */\n  hookStartTime?: number;\n  lines: TimedLine[];\n  exitCode: number | null;\n  endTime: number | null; // When init-end event occurred\n  /** Number of lines dropped from middle when output exceeded INIT_HOOK_MAX_LINES */\n  truncatedLines?: number;\n}\n\n/**\n * In-memory state for active init hooks.\n * Currently identical to InitStatus, but kept separate for future extension.\n */\ntype InitHookState = InitStatus;\n\n/**\n * InitStateManager - Manages init hook lifecycle with persistence and replay.\n *\n * Uses EventStore abstraction for state management:\n * - In-memory Map for active init hooks (via EventStore)\n * - Disk persistence to init-status.json for replay across page reloads\n * - EventEmitter for streaming events to AgentSession\n * - Permanent storage (never auto-deleted, unlike stream partials)\n *\n * Key differences from StreamManager:\n * - Simpler state machine (running â†’ success/error, no abort)\n * - No throttling (init hooks emit discrete lines, not streaming tokens)\n * - Permanent persistence (init logs kept forever as workspace metadata)\n *\n * Lifecycle:\n * 1. startInit() - Create in-memory state, emit init-start, create completion promise\n * 2. appendOutput() - Accumulate lines, emit init-output\n * 3. endInit() - Finalize state, write to disk, emit init-end, resolve promise\n * 4. State remains in memory until cleared or process restart\n * 5. replayInit() - Re-emit events from in-memory or disk state (via EventStore)\n *\n * Waiting: Tools use waitForInit() which returns a promise that resolves when\n * init completes. This promise is stored in initPromises map and resolved by\n * endInit(). No event listeners needed, eliminating race conditions.\n */\nexport class InitStateManager extends EventEmitter {\n  private readonly store: EventStore<InitHookState, WorkspaceInitEvent & { workspaceId: string }>;\n\n  /**\n   * Promise-based completion tracking for running inits.\n   * Each running init has a promise that resolves when endInit() is called.\n   * Multiple tools can await the same promise without race conditions.\n   */\n  private readonly initPromises = new Map<\n    string,\n    {\n      promise: Promise<void>;\n      resolve: () => void;\n      reject: (error: Error) => void;\n      hookPhasePromise: Promise<void>;\n      resolveHookPhase: () => void;\n    }\n  >();\n\n  constructor(config: Config) {\n    super();\n    this.store = new EventStore(\n      config,\n      \"init-status.json\",\n      (state) => this.serializeInitEvents(state),\n      (event) => this.emit(event.type, event),\n      \"InitStateManager\"\n    );\n  }\n\n  /**\n   * Serialize InitHookState into array of events for replay.\n   * Used by EventStore.replay() to reconstruct the event stream.\n   */\n  private serializeInitEvents(\n    state: InitHookState & { workspaceId?: string }\n  ): Array<WorkspaceInitEvent & { workspaceId: string }> {\n    const events: Array<WorkspaceInitEvent & { workspaceId: string }> = [];\n    const workspaceId = state.workspaceId ?? \"unknown\";\n\n    // Emit init-start\n    events.push({\n      type: \"init-start\",\n      workspaceId,\n      hookPath: state.hookPath,\n      timestamp: state.startTime,\n    });\n\n    // Emit init-output for each accumulated line with original timestamps\n    // Defensive: state.lines could be undefined from old persisted data\n    let lines = state.lines ?? [];\n    let truncatedLines = state.truncatedLines ?? 0;\n\n    // Truncate old persisted data that exceeded the limit (backwards compat)\n    if (lines.length > INIT_HOOK_MAX_LINES) {\n      const excessLines = lines.length - INIT_HOOK_MAX_LINES;\n      lines = lines.slice(-INIT_HOOK_MAX_LINES); // Keep tail\n      truncatedLines += excessLines;\n      log.info(\n        `[InitStateManager] Truncated ${excessLines} lines from old persisted data for ${workspaceId}`\n      );\n    }\n\n    for (const timedLine of lines) {\n      // Skip malformed entries (missing required fields)\n      if (typeof timedLine.line !== \"string\" || typeof timedLine.timestamp !== \"number\") {\n        log.warn(`[InitStateManager] Skipping malformed init-output:`, timedLine);\n        continue;\n      }\n      events.push({\n        type: \"init-output\",\n        workspaceId,\n        line: timedLine.line,\n        isError: timedLine.isError,\n        timestamp: timedLine.timestamp, // Use original timestamp for replay\n      });\n    }\n\n    // Emit init-end (only if completed)\n    if (state.exitCode !== null) {\n      events.push({\n        type: \"init-end\",\n        workspaceId,\n        exitCode: state.exitCode,\n        timestamp: state.endTime ?? state.startTime,\n        // Include truncation info so frontend can show indicator\n        ...(truncatedLines ? { truncatedLines } : {}),\n      });\n    }\n\n    return events;\n  }\n\n  /**\n   * Start tracking a new init hook execution.\n   * Creates in-memory state, completion promise, and emits init-start event.\n   */\n  startInit(workspaceId: string, hookPath: string): void {\n    const startTime = Date.now();\n\n    const state: InitHookState = {\n      status: \"running\",\n      phase: \"runtime_setup\",\n      hookPath,\n      startTime,\n      lines: [],\n      exitCode: null,\n      endTime: null,\n    };\n\n    this.store.setState(workspaceId, state);\n\n    // Create completion promise for this init\n    // This allows multiple tools to await the same init without event listeners\n    let resolve: () => void;\n    let reject: (error: Error) => void;\n    let resolveHookPhase: () => void;\n    const promise = new Promise<void>((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    // Prevent unhandled rejections if a workspace is deleted before any waiters attach.\n    promise.catch(() => undefined);\n    const hookPhasePromise = new Promise<void>((res) => {\n      resolveHookPhase = res;\n    });\n\n    this.initPromises.set(workspaceId, {\n      promise,\n      resolve: resolve!,\n      reject: reject!,\n      hookPhasePromise,\n      resolveHookPhase: resolveHookPhase!,\n    });\n\n    log.debug(`Init hook started for workspace ${workspaceId}: ${hookPath}`);\n\n    // Emit init-start event\n    this.emit(\"init-start\", {\n      type: \"init-start\",\n      workspaceId,\n      hookPath,\n      timestamp: startTime,\n    } satisfies WorkspaceInitEvent & { workspaceId: string });\n  }\n\n  /**\n   * Signal that the .mux/init hook is starting.\n   * This marks the transition from runtime provisioning to hook execution so\n   * waitForInit() can start the 5-minute timeout at the right time.\n   */\n  enterHookPhase(workspaceId: string): void {\n    const state = this.store.getState(workspaceId);\n    if (state?.status !== \"running\") {\n      return;\n    }\n\n    if ((state.phase ?? \"runtime_setup\") === \"init_hook\") {\n      return;\n    }\n\n    state.phase = \"init_hook\";\n    state.hookStartTime = Date.now();\n\n    const promiseEntry = this.initPromises.get(workspaceId);\n    promiseEntry?.resolveHookPhase();\n  }\n\n  /**\n   * Append output line from init hook.\n   * Accumulates in state (with truncation for long output) and emits init-output event.\n   *\n   * Truncation strategy: Keep only the most recent INIT_HOOK_MAX_LINES lines (tail).\n   * Older lines are dropped to prevent OOM with large rsync/build output.\n   */\n  appendOutput(workspaceId: string, line: string, isError: boolean): void {\n    const state = this.store.getState(workspaceId);\n\n    if (!state) {\n      log.error(`appendOutput called for workspace ${workspaceId} with no active init state`);\n      return;\n    }\n\n    const timestamp = Date.now();\n    const timedLine: TimedLine = { line, isError, timestamp };\n\n    // Truncation: keep only the most recent MAX_LINES\n    if (state.lines.length >= INIT_HOOK_MAX_LINES) {\n      state.lines.shift(); // Drop oldest line\n      state.truncatedLines = (state.truncatedLines ?? 0) + 1;\n    }\n    state.lines.push(timedLine);\n\n    // Emit init-output event (always emit for live streaming, even if truncated from storage)\n    this.emit(\"init-output\", {\n      type: \"init-output\",\n      workspaceId,\n      line,\n      isError,\n      timestamp,\n    } satisfies WorkspaceInitEvent & { workspaceId: string });\n  }\n\n  /**\n   * Finalize init hook execution.\n   * Updates state, persists to disk, emits init-end event, and resolves completion promise.\n   *\n   * IMPORTANT: We persist BEFORE updating in-memory exitCode to prevent a race condition\n   * where replay() sees exitCode !== null but the file doesn't exist yet. This ensures\n   * the invariant: if init-end is visible (live or replay), the file MUST exist.\n   */\n  async endInit(workspaceId: string, exitCode: number): Promise<void> {\n    const state = this.store.getState(workspaceId);\n\n    if (!state) {\n      log.error(`endInit called for workspace ${workspaceId} with no active init state`);\n      return;\n    }\n\n    const endTime = Date.now();\n    const finalStatus = exitCode === 0 ? \"success\" : \"error\";\n\n    // Create complete state for persistence (don't mutate in-memory state yet)\n    const stateToPerist: InitHookState = {\n      ...state,\n      status: finalStatus,\n      exitCode,\n      endTime,\n    };\n\n    // Persist FIRST - ensures file exists before in-memory state shows completion\n    await this.store.persist(workspaceId, stateToPerist, {\n      // If WorkspaceService.remove() cleared init state, do not recreate ~/.mux/sessions/<id>/\n      shouldWrite: () => this.store.hasState(workspaceId),\n    });\n\n    // NOW update in-memory state (replay will now see file exists)\n    state.status = finalStatus;\n    state.exitCode = exitCode;\n    state.endTime = endTime;\n\n    log.info(\n      `Init hook ${state.status} for workspace ${workspaceId} (exit code ${exitCode}, duration ${endTime - state.startTime}ms)`\n    );\n\n    // Emit init-end event\n    this.emit(\"init-end\", {\n      type: \"init-end\",\n      workspaceId,\n      exitCode,\n      timestamp: endTime,\n      // Include truncation info so frontend can show indicator\n      ...(state.truncatedLines ? { truncatedLines: state.truncatedLines } : {}),\n    } satisfies WorkspaceInitEvent & { workspaceId: string });\n\n    // Resolve completion promise for waiting tools\n    const promiseEntry = this.initPromises.get(workspaceId);\n    if (promiseEntry) {\n      promiseEntry.resolve();\n      this.initPromises.delete(workspaceId);\n    }\n\n    // Keep state in memory for replay (unlike streams which delete immediately)\n  }\n\n  /**\n   * Get current in-memory init state for a workspace.\n   * Returns undefined if no init state exists.\n   */\n  getInitState(workspaceId: string): InitHookState | undefined {\n    return this.store.getState(workspaceId);\n  }\n\n  /**\n   * Read persisted init status from disk.\n   * Returns null if no status file exists.\n   */\n  async readInitStatus(workspaceId: string): Promise<InitStatus | null> {\n    return this.store.readPersisted(workspaceId);\n  }\n\n  /**\n   * Replay init events for a workspace.\n   * Delegates to EventStore.replay() which:\n   * 1. Checks in-memory state first, then falls back to disk\n   * 2. Serializes state into events via serializeInitEvents()\n   * 3. Emits events (init-start, init-output*, init-end)\n   *\n   * This is called during AgentSession.emitHistoricalEvents() to ensure\n   * init state is visible after page reloads.\n   */\n  async replayInit(workspaceId: string): Promise<void> {\n    // Pass workspaceId as context for serialization\n    await this.store.replay(workspaceId, { workspaceId });\n  }\n\n  /**\n   * Delete persisted init status from disk.\n   * Useful for testing or manual cleanup.\n   * Does NOT clear in-memory state (for active replay).\n   */\n  async deleteInitStatus(workspaceId: string): Promise<void> {\n    await this.store.deletePersisted(workspaceId);\n  }\n\n  /**\n   * Clear in-memory state for a workspace.\n   * Useful for testing or cleanup after workspace deletion.\n   * Does NOT delete disk file (use deleteInitStatus for that).\n   *\n   * Also cancels any running init promises to prevent orphaned waiters.\n   */\n  clearInMemoryState(workspaceId: string): void {\n    this.store.deleteState(workspaceId);\n\n    // Cancel any running init promise for this workspace\n    const promiseEntry = this.initPromises.get(workspaceId);\n    if (promiseEntry) {\n      promiseEntry.reject(new Error(`Workspace ${workspaceId} was deleted`));\n      promiseEntry.resolveHookPhase();\n      this.initPromises.delete(workspaceId);\n    }\n  }\n\n  /**\n   * Wait for workspace initialization to complete.\n   * Used by tools (bash, file_*) to ensure files are ready before executing.\n   *\n   * Behavior:\n   * - No init state: Returns immediately (init not needed or backwards compat)\n   * - Init succeeded/failed: Returns immediately (tools proceed regardless of init outcome)\n   * - Init running: waits for runtime provisioning to reach the hook phase (no timeout),\n   *   then waits up to 5 minutes from hook start before proceeding anyway.\n   * - If abortSignal is provided, resolves early when aborted.\n   * - If the workspace is deleted during init, resolves early when state is cleared.\n   *\n   * This method NEVER throws - tools should always proceed. If init fails or times out,\n   * the tool will either succeed (if init wasn't critical) or fail with its own error\n   * (e.g., file not found). This provides better error messages than blocking on init.\n   *\n   * Promise-based approach eliminates race conditions:\n   * - Multiple tools share the same promise (no duplicate listeners)\n   * - No event cleanup needed (promise auto-resolves once)\n   * - Timeout races handled by Promise.race()\n   *\n   * @param workspaceId Workspace ID to wait for\n   * @param abortSignal Optional signal to abort the wait early\n   */\n  async waitForInit(workspaceId: string, abortSignal?: AbortSignal): Promise<void> {\n    const state = this.getInitState(workspaceId);\n\n    // No init state - proceed immediately (backwards compat or init not needed)\n    if (!state) {\n      return;\n    }\n\n    // Init already completed (success or failure) - proceed immediately\n    // Tools should work regardless of init outcome\n    if (state.status !== \"running\") {\n      return;\n    }\n\n    // Early exit if already aborted\n    if (abortSignal?.aborted) {\n      return;\n    }\n\n    // Init is running - wait for completion promise with timeout\n    const promiseEntry = this.initPromises.get(workspaceId);\n\n    if (!promiseEntry) {\n      // State says running but no promise exists (shouldn't happen, but handle gracefully)\n      log.error(`Init state is running for ${workspaceId} but no promise found, proceeding`);\n      return;\n    }\n\n    const INIT_HOOK_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes\n\n    // Track cleanup handlers\n    let timeoutId: NodeJS.Timeout | undefined;\n    let abortHandler: (() => void) | undefined;\n\n    try {\n      const abortPromise = new Promise<void>((resolve) => {\n        if (!abortSignal) return; // Never resolves if no signal\n        if (abortSignal.aborted) {\n          resolve();\n          return;\n        }\n        abortHandler = () => resolve();\n        abortSignal.addEventListener(\"abort\", abortHandler, { once: true });\n      });\n\n      // Intentional: provisioning (Coder/devcontainer/etc.) can be long-running, so we\n      // avoid timeouts until .mux/init begins. The wait is still interruptible via\n      // abortSignal or workspace deletion (clearInMemoryState).\n      const phase = state.phase ?? \"runtime_setup\";\n      if (phase === \"runtime_setup\") {\n        const first = await Promise.race([\n          promiseEntry.promise.then(() => \"complete\"),\n          promiseEntry.hookPhasePromise.then(() => \"hook\"),\n          abortPromise.then(() => \"abort\"),\n        ]);\n        if (first !== \"hook\") {\n          return;\n        }\n      }\n\n      const hookStart = state.hookStartTime ?? state.startTime;\n      const elapsed = Date.now() - hookStart;\n      const remaining = Math.max(0, INIT_HOOK_TIMEOUT_MS - elapsed);\n\n      const timeoutPromise = new Promise<void>((resolve) => {\n        timeoutId = setTimeout(() => {\n          log.error(\n            `Init timeout for ${workspaceId} after 5 minutes - tools will proceed anyway. ` +\n              `Init will continue in background.`\n          );\n          resolve();\n        }, remaining);\n        // Don't keep Node alive just for this timeout (allows tests to exit)\n        timeoutId.unref();\n      });\n\n      // Race between completion, timeout, and abort\n      await Promise.race([promiseEntry.promise, timeoutPromise, abortPromise]);\n    } catch (error) {\n      // Init promise was rejected (e.g., workspace deleted)\n      // Log and proceed anyway - let the tool fail with its own error if needed\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      log.error(`Init wait interrupted for ${workspaceId}: ${errorMsg} - proceeding anyway`);\n    } finally {\n      // Clean up timeout to prevent spurious error logs\n      if (timeoutId) clearTimeout(timeoutId);\n      // Clean up abort listener to prevent memory leak\n      if (abortHandler && abortSignal) {\n        abortSignal.removeEventListener(\"abort\", abortHandler);\n      }\n    }\n  }\n}\n"]}