{"version":3,"file":"messagePipeline.js","sourceRoot":"","sources":["../../../src/node/services/messagePipeline.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Message pipeline: transforms MuxMessages into provider-ready ModelMessages.\n *\n * This module extracts the message preparation pipeline from `streamMessage()`,\n * making the sequential transform steps explicit and testable.\n *\n * The pipeline is purely functional — it has no service dependencies (`this.*`).\n * All contextual data is passed via the options object.\n */\n\nimport { convertToModelMessages, type ModelMessage } from \"ai\";\nimport { applyToolOutputRedaction } from \"@/browser/utils/messages/applyToolOutputRedaction\";\nimport { sanitizeToolInputs } from \"@/browser/utils/messages/sanitizeToolInput\";\nimport { inlineSvgAsTextForProvider } from \"@/node/utils/messages/inlineSvgAsTextForProvider\";\nimport { extractToolMediaAsUserMessages } from \"@/node/utils/messages/extractToolMediaAsUserMessages\";\nimport { sanitizeAnthropicPdfFilenames } from \"@/node/utils/messages/sanitizeAnthropicDocumentFilename\";\nimport type { MuxMessage } from \"@/common/types/message\";\nimport type { EditedFileAttachment } from \"@/node/services/agentSession\";\nimport type { PostCompactionAttachment } from \"@/common/types/attachment\";\nimport type { ThinkingLevel } from \"@/common/types/thinking\";\nimport type { Runtime } from \"@/node/runtime/Runtime\";\nimport { injectFileAtMentions } from \"./fileAtMentions\";\nimport {\n  transformModelMessages,\n  validateAnthropicCompliance,\n  injectAgentTransition,\n  injectFileChangeNotifications,\n  injectPostCompactionAttachments,\n} from \"@/browser/utils/messages/modelMessageTransform\";\nimport { applyCacheControl } from \"@/common/utils/ai/cacheStrategy\";\nimport { log } from \"./log\";\n\n/** Options for the full message preparation pipeline. */\nexport interface PrepareMessagesOptions {\n  /** Pre-filtered messages (with interrupted-sentinel already added). */\n  messagesWithSentinel: MuxMessage[];\n  /** Active agent ID for transition injection. */\n  effectiveAgentId: string;\n  /** Tool names for mode-transition sentinel detection. */\n  toolNamesForSentinel: string[];\n  /** Plan content for plan→exec handoff injection. */\n  planContentForTransition?: string;\n  /** Plan file path for transition context. */\n  planFilePath?: string;\n  /** File-change attachments for notification injection. */\n  changedFileAttachments?: EditedFileAttachment[];\n  /** Post-compaction attachments (plan file, edited files). */\n  postCompactionAttachments?: PostCompactionAttachment[] | null;\n  /** Runtime for file I/O (used by @file mention injection). */\n  runtime: Runtime;\n  /** Workspace path for file resolution. */\n  workspacePath: string;\n  /** Abort signal for async operations. */\n  abortSignal: AbortSignal;\n  /** Canonical provider name for provider-specific transforms. */\n  providerForMessages: string;\n  /** Thinking level for provider-specific behavior. */\n  effectiveThinkingLevel: ThinkingLevel;\n  /** Full model string (used for cache control). */\n  modelString: string;\n  /** Workspace ID (used only for debug logging). */\n  workspaceId: string;\n}\n\n/**\n * Run the full message preparation pipeline.\n *\n * Transforms pre-filtered `MuxMessage[]` into provider-ready `ModelMessage[]` by:\n * 1. Injecting agent-transition context (plan→exec handoff)\n * 2. Injecting file-change notifications\n * 3. Injecting post-compaction attachments\n * 4. Expanding @file mentions into synthetic user messages\n * 5. Redacting heavy tool outputs\n * 6. Sanitizing tool inputs\n * 7. Inlining SVG attachments as text\n * 8. Sanitizing PDF filenames for Anthropic\n * 9. Extracting tool-result media as user message attachments\n * 10. Converting to Vercel AI SDK ModelMessage format\n * 11. Self-healing: filtering empty/whitespace assistant messages\n * 12. Applying provider-specific message transforms\n * 13. Applying cache control headers\n * 14. Validating Anthropic compliance (logs warnings only)\n */\nexport async function prepareMessagesForProvider(\n  opts: PrepareMessagesOptions\n): Promise<ModelMessage[]> {\n  const {\n    messagesWithSentinel,\n    effectiveAgentId,\n    toolNamesForSentinel,\n    planContentForTransition,\n    planFilePath,\n    changedFileAttachments,\n    postCompactionAttachments,\n    runtime,\n    workspacePath,\n    abortSignal,\n    providerForMessages,\n    effectiveThinkingLevel,\n    modelString,\n    workspaceId,\n  } = opts;\n\n  // --- MuxMessage-level transforms ---\n\n  // Inject agent transition context with plan content (for plan→exec handoff)\n  const messagesWithAgentContext = injectAgentTransition(\n    messagesWithSentinel,\n    effectiveAgentId,\n    toolNamesForSentinel,\n    planContentForTransition,\n    planContentForTransition ? planFilePath : undefined\n  );\n\n  // Inject file change notifications as user messages (preserves system message cache)\n  const messagesWithFileChanges = injectFileChangeNotifications(\n    messagesWithAgentContext,\n    changedFileAttachments\n  );\n\n  // Inject post-compaction attachments (plan file, edited files) after compaction summary\n  const messagesWithPostCompaction = injectPostCompactionAttachments(\n    messagesWithFileChanges,\n    postCompactionAttachments\n  );\n\n  // Expand @file mentions (e.g. @src/foo.ts#L1-20) into in-memory synthetic user messages.\n  // Keeps chat history clean while giving the model immediate file context.\n  const messagesWithFileAtMentions = await injectFileAtMentions(messagesWithPostCompaction, {\n    runtime,\n    workspacePath,\n    abortSignal,\n  });\n\n  // Apply centralized tool-output redaction BEFORE converting to provider ModelMessages.\n  // Keeps the persisted/UI history intact while trimming heavy fields for the request.\n  const redactedForProvider = applyToolOutputRedaction(messagesWithFileAtMentions);\n  log.debug_obj(`${workspaceId}/2a_redacted_messages.json`, redactedForProvider);\n\n  // Sanitize tool inputs to ensure they are valid objects (not strings or arrays).\n  // Fixes cases where corrupted data in history has malformed tool inputs\n  // that would cause API errors like \"Input should be a valid dictionary\".\n  const sanitizedMessages = sanitizeToolInputs(redactedForProvider);\n  log.debug_obj(`${workspaceId}/2b_sanitized_messages.json`, sanitizedMessages);\n\n  // Inline SVG user attachments as text (providers generally don't accept image/svg+xml).\n  // Request-only — does not mutate persisted history.\n  const messagesWithInlinedSvg = inlineSvgAsTextForProvider(sanitizedMessages);\n\n  // Sanitize PDF filenames for Anthropic (request-only, preserves original in UI/history).\n  // Anthropic rejects document names containing periods, underscores, etc.\n  const messagesWithSanitizedPdf =\n    providerForMessages === \"anthropic\"\n      ? sanitizeAnthropicPdfFilenames(messagesWithInlinedSvg)\n      : messagesWithInlinedSvg;\n\n  // Rewrite MCP tool-result images (base64) to small text placeholders + file parts.\n  // Prevents providers from treating large base64 payloads as text/JSON context.\n  const messagesWithToolMediaExtracted = extractToolMediaAsUserMessages(messagesWithSanitizedPdf);\n\n  // --- Convert to ModelMessage format ---\n\n  // Type assertion needed because MuxMessage has custom tool parts for interrupted tools\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument\n  const rawModelMessages = await convertToModelMessages(messagesWithToolMediaExtracted as any, {\n    // Drop unfinished tool calls (input-streaming/input-available) so downstream\n    // transforms only see tool calls that actually produced outputs.\n    ignoreIncompleteToolCalls: true,\n  });\n\n  // --- ModelMessage-level transforms ---\n\n  const modelMessages = sanitizeAssistantModelMessages(rawModelMessages, workspaceId);\n\n  log.debug_obj(`${workspaceId}/2_model_messages.json`, modelMessages);\n\n  // Apply ModelMessage transforms based on provider requirements\n  const transformedMessages = transformModelMessages(modelMessages, providerForMessages, {\n    anthropicThinkingEnabled:\n      providerForMessages === \"anthropic\" && effectiveThinkingLevel !== \"off\",\n  });\n\n  // Apply cache control for Anthropic models AFTER transformation\n  const finalMessages = applyCacheControl(transformedMessages, modelString);\n\n  log.debug_obj(`${workspaceId}/3_final_messages.json`, finalMessages);\n\n  // Validate the messages meet Anthropic requirements (Anthropic only)\n  if (providerForMessages === \"anthropic\") {\n    const validation = validateAnthropicCompliance(finalMessages);\n    if (!validation.valid) {\n      log.error(`Anthropic compliance validation failed: ${validation.error ?? \"unknown error\"}`);\n      // Continue anyway, as the API might be more lenient\n    }\n  }\n\n  return finalMessages;\n}\n\n/**\n * Self-healing: filter empty or whitespace-only assistant model messages.\n *\n * The SDK's `ignoreIncompleteToolCalls` can drop all parts from a message,\n * leaving an assistant with an empty content array. The API rejects these with\n * \"all messages must have non-empty content except for the optional final\n * assistant message\".\n *\n * Anthropic also rejects text content blocks that contain only whitespace\n * (e.g. \"\\n\\n\"). This can happen after an interrupted stream where we\n * persisted a whitespace-only text delta (often the first text after thinking).\n *\n * Kept provider-agnostic and request-only (does not mutate persisted history).\n */\nexport function sanitizeAssistantModelMessages(\n  messages: ModelMessage[],\n  workspaceId?: string\n): ModelMessage[] {\n  const result = messages.flatMap<ModelMessage>((msg): ModelMessage[] => {\n    if (msg.role !== \"assistant\") {\n      return [msg];\n    }\n\n    if (typeof msg.content === \"string\") {\n      return msg.content.trim().length > 0 ? [msg] : [];\n    }\n\n    if (!Array.isArray(msg.content)) {\n      return [];\n    }\n\n    const filteredContent = msg.content.filter(\n      (part) => part.type !== \"text\" || part.text.trim().length > 0\n    );\n\n    if (filteredContent.length === 0) {\n      return [];\n    }\n\n    // Avoid mutating the original message (which can be reused in debug logging).\n    if (filteredContent.length === msg.content.length) {\n      return [msg];\n    }\n\n    return [{ ...msg, content: filteredContent }];\n  });\n\n  if (result.length < messages.length) {\n    log.debug(\n      `Self-healing: Filtered ${messages.length - result.length} empty ModelMessage(s)${workspaceId ? ` [${workspaceId}]` : \"\"}`\n    );\n  }\n\n  return result;\n}\n"]}