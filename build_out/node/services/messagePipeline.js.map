{"version":3,"file":"messagePipeline.js","sourceRoot":"","sources":["../../../src/node/services/messagePipeline.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Message pipeline: transforms MuxMessages into provider-ready ModelMessages.\r\n *\r\n * This module extracts the message preparation pipeline from `streamMessage()`,\r\n * making the sequential transform steps explicit and testable.\r\n *\r\n * The pipeline is purely functional — it has no service dependencies (`this.*`).\r\n * All contextual data is passed via the options object.\r\n */\r\n\r\nimport { convertToModelMessages, type ModelMessage } from \"ai\";\r\nimport { applyToolOutputRedaction } from \"@/browser/utils/messages/applyToolOutputRedaction\";\r\nimport { sanitizeToolInputs } from \"@/browser/utils/messages/sanitizeToolInput\";\r\nimport { inlineSvgAsTextForProvider } from \"@/node/utils/messages/inlineSvgAsTextForProvider\";\r\nimport { extractToolMediaAsUserMessages } from \"@/node/utils/messages/extractToolMediaAsUserMessages\";\r\nimport { sanitizeAnthropicPdfFilenames } from \"@/node/utils/messages/sanitizeAnthropicDocumentFilename\";\r\nimport type { MuxMessage } from \"@/common/types/message\";\r\nimport type { EditedFileAttachment } from \"@/node/services/agentSession\";\r\nimport type { PostCompactionAttachment } from \"@/common/types/attachment\";\r\nimport type { ThinkingLevel } from \"@/common/types/thinking\";\r\nimport type { Runtime } from \"@/node/runtime/Runtime\";\r\nimport { injectFileAtMentions } from \"./fileAtMentions\";\r\nimport {\r\n  transformModelMessages,\r\n  validateAnthropicCompliance,\r\n  injectAgentTransition,\r\n  injectFileChangeNotifications,\r\n  injectPostCompactionAttachments,\r\n} from \"@/browser/utils/messages/modelMessageTransform\";\r\nimport { applyCacheControl } from \"@/common/utils/ai/cacheStrategy\";\r\nimport { log } from \"./log\";\r\n\r\n/** Options for the full message preparation pipeline. */\r\nexport interface PrepareMessagesOptions {\r\n  /** Pre-filtered messages (with interrupted-sentinel already added). */\r\n  messagesWithSentinel: MuxMessage[];\r\n  /** Active agent ID for transition injection. */\r\n  effectiveAgentId: string;\r\n  /** Tool names for mode-transition sentinel detection. */\r\n  toolNamesForSentinel: string[];\r\n  /** Plan content for plan→exec handoff injection. */\r\n  planContentForTransition?: string;\r\n  /** Plan file path for transition context. */\r\n  planFilePath?: string;\r\n  /** File-change attachments for notification injection. */\r\n  changedFileAttachments?: EditedFileAttachment[];\r\n  /** Post-compaction attachments (plan file, edited files). */\r\n  postCompactionAttachments?: PostCompactionAttachment[] | null;\r\n  /** Runtime for file I/O (used by @file mention injection). */\r\n  runtime: Runtime;\r\n  /** Workspace path for file resolution. */\r\n  workspacePath: string;\r\n  /** Abort signal for async operations. */\r\n  abortSignal: AbortSignal;\r\n  /** Canonical provider name for provider-specific transforms. */\r\n  providerForMessages: string;\r\n  /** Thinking level for provider-specific behavior. */\r\n  effectiveThinkingLevel: ThinkingLevel;\r\n  /** Full model string (used for cache control). */\r\n  modelString: string;\r\n  /** Workspace ID (used only for debug logging). */\r\n  workspaceId: string;\r\n}\r\n\r\n/**\r\n * Run the full message preparation pipeline.\r\n *\r\n * Transforms pre-filtered `MuxMessage[]` into provider-ready `ModelMessage[]` by:\r\n * 1. Injecting agent-transition context (plan→exec handoff)\r\n * 2. Injecting file-change notifications\r\n * 3. Injecting post-compaction attachments\r\n * 4. Expanding @file mentions into synthetic user messages\r\n * 5. Redacting heavy tool outputs\r\n * 6. Sanitizing tool inputs\r\n * 7. Inlining SVG attachments as text\r\n * 8. Sanitizing PDF filenames for Anthropic\r\n * 9. Extracting tool-result media as user message attachments\r\n * 10. Converting to Vercel AI SDK ModelMessage format\r\n * 11. Self-healing: filtering empty/whitespace assistant messages\r\n * 12. Applying provider-specific message transforms\r\n * 13. Applying cache control headers\r\n * 14. Validating Anthropic compliance (logs warnings only)\r\n */\r\nexport async function prepareMessagesForProvider(\r\n  opts: PrepareMessagesOptions\r\n): Promise<ModelMessage[]> {\r\n  const {\r\n    messagesWithSentinel,\r\n    effectiveAgentId,\r\n    toolNamesForSentinel,\r\n    planContentForTransition,\r\n    planFilePath,\r\n    changedFileAttachments,\r\n    postCompactionAttachments,\r\n    runtime,\r\n    workspacePath,\r\n    abortSignal,\r\n    providerForMessages,\r\n    effectiveThinkingLevel,\r\n    modelString,\r\n    workspaceId,\r\n  } = opts;\r\n\r\n  // --- MuxMessage-level transforms ---\r\n\r\n  // Inject agent transition context with plan content (for plan→exec handoff)\r\n  const messagesWithAgentContext = injectAgentTransition(\r\n    messagesWithSentinel,\r\n    effectiveAgentId,\r\n    toolNamesForSentinel,\r\n    planContentForTransition,\r\n    planContentForTransition ? planFilePath : undefined\r\n  );\r\n\r\n  // Inject file change notifications as user messages (preserves system message cache)\r\n  const messagesWithFileChanges = injectFileChangeNotifications(\r\n    messagesWithAgentContext,\r\n    changedFileAttachments\r\n  );\r\n\r\n  // Inject post-compaction attachments (plan file, edited files) after compaction summary\r\n  const messagesWithPostCompaction = injectPostCompactionAttachments(\r\n    messagesWithFileChanges,\r\n    postCompactionAttachments\r\n  );\r\n\r\n  // Expand @file mentions (e.g. @src/foo.ts#L1-20) into in-memory synthetic user messages.\r\n  // Keeps chat history clean while giving the model immediate file context.\r\n  const messagesWithFileAtMentions = await injectFileAtMentions(messagesWithPostCompaction, {\r\n    runtime,\r\n    workspacePath,\r\n    abortSignal,\r\n  });\r\n\r\n  // Apply centralized tool-output redaction BEFORE converting to provider ModelMessages.\r\n  // Keeps the persisted/UI history intact while trimming heavy fields for the request.\r\n  const redactedForProvider = applyToolOutputRedaction(messagesWithFileAtMentions);\r\n  log.debug_obj(`${workspaceId}/2a_redacted_messages.json`, redactedForProvider);\r\n\r\n  // Sanitize tool inputs to ensure they are valid objects (not strings or arrays).\r\n  // Fixes cases where corrupted data in history has malformed tool inputs\r\n  // that would cause API errors like \"Input should be a valid dictionary\".\r\n  const sanitizedMessages = sanitizeToolInputs(redactedForProvider);\r\n  log.debug_obj(`${workspaceId}/2b_sanitized_messages.json`, sanitizedMessages);\r\n\r\n  // Inline SVG user attachments as text (providers generally don't accept image/svg+xml).\r\n  // Request-only — does not mutate persisted history.\r\n  const messagesWithInlinedSvg = inlineSvgAsTextForProvider(sanitizedMessages);\r\n\r\n  // Sanitize PDF filenames for Anthropic (request-only, preserves original in UI/history).\r\n  // Anthropic rejects document names containing periods, underscores, etc.\r\n  const messagesWithSanitizedPdf =\r\n    providerForMessages === \"anthropic\"\r\n      ? sanitizeAnthropicPdfFilenames(messagesWithInlinedSvg)\r\n      : messagesWithInlinedSvg;\r\n\r\n  // Rewrite MCP tool-result images (base64) to small text placeholders + file parts.\r\n  // Prevents providers from treating large base64 payloads as text/JSON context.\r\n  const messagesWithToolMediaExtracted = extractToolMediaAsUserMessages(messagesWithSanitizedPdf);\r\n\r\n  // --- Convert to ModelMessage format ---\r\n\r\n  // Type assertion needed because MuxMessage has custom tool parts for interrupted tools\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument\r\n  const rawModelMessages = await convertToModelMessages(messagesWithToolMediaExtracted as any, {\r\n    // Drop unfinished tool calls (input-streaming/input-available) so downstream\r\n    // transforms only see tool calls that actually produced outputs.\r\n    ignoreIncompleteToolCalls: true,\r\n  });\r\n\r\n  // --- ModelMessage-level transforms ---\r\n\r\n  const modelMessages = sanitizeAssistantModelMessages(rawModelMessages, workspaceId);\r\n\r\n  log.debug_obj(`${workspaceId}/2_model_messages.json`, modelMessages);\r\n\r\n  // Apply ModelMessage transforms based on provider requirements\r\n  const transformedMessages = transformModelMessages(modelMessages, providerForMessages, {\r\n    anthropicThinkingEnabled:\r\n      providerForMessages === \"anthropic\" && effectiveThinkingLevel !== \"off\",\r\n  });\r\n\r\n  // Apply cache control for Anthropic models AFTER transformation\r\n  const finalMessages = applyCacheControl(transformedMessages, modelString);\r\n\r\n  log.debug_obj(`${workspaceId}/3_final_messages.json`, finalMessages);\r\n\r\n  // Validate the messages meet Anthropic requirements (Anthropic only)\r\n  if (providerForMessages === \"anthropic\") {\r\n    const validation = validateAnthropicCompliance(finalMessages);\r\n    if (!validation.valid) {\r\n      log.error(`Anthropic compliance validation failed: ${validation.error ?? \"unknown error\"}`);\r\n      // Continue anyway, as the API might be more lenient\r\n    }\r\n  }\r\n\r\n  return finalMessages;\r\n}\r\n\r\n/**\r\n * Self-healing: filter empty or whitespace-only assistant model messages.\r\n *\r\n * The SDK's `ignoreIncompleteToolCalls` can drop all parts from a message,\r\n * leaving an assistant with an empty content array. The API rejects these with\r\n * \"all messages must have non-empty content except for the optional final\r\n * assistant message\".\r\n *\r\n * Anthropic also rejects text content blocks that contain only whitespace\r\n * (e.g. \"\\n\\n\"). This can happen after an interrupted stream where we\r\n * persisted a whitespace-only text delta (often the first text after thinking).\r\n *\r\n * Kept provider-agnostic and request-only (does not mutate persisted history).\r\n */\r\nexport function sanitizeAssistantModelMessages(\r\n  messages: ModelMessage[],\r\n  workspaceId?: string\r\n): ModelMessage[] {\r\n  const result = messages.flatMap<ModelMessage>((msg): ModelMessage[] => {\r\n    if (msg.role !== \"assistant\") {\r\n      return [msg];\r\n    }\r\n\r\n    if (typeof msg.content === \"string\") {\r\n      return msg.content.trim().length > 0 ? [msg] : [];\r\n    }\r\n\r\n    if (!Array.isArray(msg.content)) {\r\n      return [];\r\n    }\r\n\r\n    const filteredContent = msg.content.filter(\r\n      (part) => part.type !== \"text\" || part.text.trim().length > 0\r\n    );\r\n\r\n    if (filteredContent.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    // Avoid mutating the original message (which can be reused in debug logging).\r\n    if (filteredContent.length === msg.content.length) {\r\n      return [msg];\r\n    }\r\n\r\n    return [{ ...msg, content: filteredContent }];\r\n  });\r\n\r\n  if (result.length < messages.length) {\r\n    log.debug(\r\n      `Self-healing: Filtered ${messages.length - result.length} empty ModelMessage(s)${workspaceId ? ` [${workspaceId}]` : \"\"}`\r\n    );\r\n  }\r\n\r\n  return result;\r\n}\r\n"]}