{"version":3,"file":"toolAssembly.js","sourceRoot":"","sources":["../../../src/node/services/toolAssembly.ts"],"names":[],"mappings":";AAAA;;;;;;;;;GASG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIH,gEAAmF;AAQnF,+BAA4B;AAI5B,oDAAoF;AAiBpF,IAAI,UAAU,GAAsB,IAAI,CAAC;AAEzC,KAAK,UAAU,aAAa,GAAwB;IAClD,IAAI,UAAU;QAAE,OAAO,UAAU,CAAC;IAElC;8EAC0E;IAC1E,MAAM,CAAC,aAAa,EAAE,OAAO,EAAE,UAAU,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;0DACtD,sCAAsC;0DACtC,oCAAoC;0DACpC,gCAAgC;KACxC,CAAC,CAAC;IACH,wCAAwC;IAExC,UAAU,GAAG;QACX,uBAAuB,EAAE,aAAa,CAAC,uBAAuB;QAC9D,qBAAqB,EAAE,OAAO,CAAC,qBAAqB;QACpD,UAAU,EAAE,UAAU,CAAC,UAAU;QACjC,cAAc,EAAE,IAAI;KACrB,CAAC;IACF,OAAO,UAAU,CAAC;AAAA,CACnB;AAuBD;;;;;;;;;;;GAWG;AACI,KAAK,wCACV,IAA0C,EACX;IAC/B,MAAM,EAAE,QAAQ,EAAE,UAAU,EAAE,mBAAmB,EAAE,WAAW,EAAE,mBAAmB,EAAE,GAAG,IAAI,CAAC;IAE7F,sEAAsE;IACtE,wFAAwF;IACxF,MAAM,iBAAiB,GAAG,UAAU,CAAC,CAAC,CAAC,EAAE,GAAG,QAAQ,EAAE,GAAG,UAAU,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC;IAEjF,gFAA8E;IAC9E,uEAAuE;IACvE,iEAAiE;IACjE,MAAM,mBAAmB,GAAG,IAAA,4BAAe,EAAC,iBAAiB,EAAE,mBAAmB,CAAC,CAAC;IAEpF,sEAAoE;IACpE,IAAI,aAAa,GAAG,mBAAmB,CAAC;IACxC,IAAI,WAAW,EAAE,uBAAuB,IAAI,WAAW,EAAE,gCAAgC,EAAE,CAAC;QAC1F,IAAI,CAAC;YACH,0DAA0D;YAC1D,MAAM,GAAG,GAAG,MAAM,aAAa,EAAE,CAAC;YAElC,+EAA6E;YAC7E,MAAM,UAAU,GAAG,IAAI,GAAG,CAAC,UAAU,CAAC,mBAAmB,CAAC,CAAC;YAE3D,+DAA+D;YAC/D,GAAG,CAAC,cAAc,KAAlB,GAAG,CAAC,cAAc,GAAK,IAAI,GAAG,CAAC,qBAAqB,EAAE,EAAC;YAEvD,MAAM,iBAAiB,GAAG,MAAM,GAAG,CAAC,uBAAuB,CACzD,GAAG,CAAC,cAAc,EAClB,UAAU,EACV,mBAAmB,CACpB,CAAC;YAEF,IAAI,WAAW,EAAE,gCAAgC,EAAE,CAAC;gBAClD,mFAAiF;gBACjF,gFAAgF;gBAChF,qFAAqF;gBACrF,MAAM,aAAa,GAAG,UAAU,CAAC,qBAAqB,EAAE,CAAC;gBACzD,aAAa,GAAG,EAAE,GAAG,aAAa,EAAE,cAAc,EAAE,iBAAiB,EAAE,CAAC;YAC1E,CAAC;iBAAM,CAAC;gBACN,iFAAiF;gBACjF,6EAA6E;gBAC7E,aAAa,GAAG,IAAA,4BAAe,EAC7B,EAAE,GAAG,mBAAmB,EAAE,cAAc,EAAE,iBAAiB,EAAE,EAC7D,mBAAmB,CACpB,CAAC;YACJ,CAAC;QACH,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,2DAA2D;YAC3D,SAAG,CAAC,KAAK,CAAC,kEAAkE,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;QAC3F,CAAC;IACH,CAAC;IAED,OAAO,aAAa,CAAC;AAAA,CACtB;AAED,8EAA8E;AAC9E,gBAAgB;AAChB,8EAA8E;AAE9E,2EAA2E;AAC3E,iCAAwC,IAWvC,EAAQ;IACP,MAAM,EACJ,gBAAgB,EAChB,QAAQ,EACR,QAAQ,EACR,KAAK,EACL,kBAAkB,EAClB,WAAW,EACX,WAAW,EACX,gBAAgB,EAChB,QAAQ,EACR,mBAAmB,GACpB,GAAG,IAAI,CAAC;IAET,MAAM,iBAAiB,GACrB,QAAQ;QACP;YACC,kBAAkB,EAAE,CAAC;YACrB,kBAAkB,EAAE,CAAC;YACrB,iBAAiB,EAAE,CAAC;YACpB,iBAAiB,EAAE,CAAC;YACpB,QAAQ,EAAE,KAAK;YACf,OAAO,EAAE,KAAK;YACd,MAAM,EAAE,KAAK;YACb,aAAa,EAAE,MAAM;SACO,CAAC;IAEjC,MAAM,YAAY,GAAG,IAAI,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,IAAI,EAAE,CAAC,CAAC,CAAC;IAC1D,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACrC,MAAM,YAAY,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC;IAC/E,MAAM,cAAc,GAAG,SAAS,CAAC,MAAM,CAAC;IACxC,MAAM,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,cAAc,GAAG,YAAY,CAAC,CAAC;IAEpE,gBAAgB,EAAE,OAAO,CAAC;QACxB,KAAK,EAAE,sBAAsB;QAC7B,UAAU,EAAE;YACV,WAAW;YACX,KAAK,EAAE,WAAW;YAClB,OAAO,EAAE,gBAAgB;YACzB,WAAW,EAAE,IAAA,kCAA0B,EAAC,QAAQ,CAAC,aAAa,CAAC;YAE/D,wBAAwB,EAAE,iBAAiB,CAAC,kBAAkB;YAC9D,wBAAwB,EAAE,iBAAiB,CAAC,kBAAkB;YAC9D,uBAAuB,EAAE,iBAAiB,CAAC,iBAAiB;YAE5D,cAAc,EAAE,YAAY;YAC5B,gBAAgB,EAAE,cAAc;YAChC,kBAAkB,EAAE,gBAAgB;YAEpC,kBAAkB,EAAE,iBAAiB,CAAC,aAAa;YACnD,YAAY,EAAE,iBAAiB,CAAC,OAAO;YACvC,WAAW,EAAE,iBAAiB,CAAC,MAAM;YACrC,aAAa,EAAE,iBAAiB,CAAC,QAAQ;YACzC,uBAAuB,EAAE,iBAAiB,CAAC,iBAAiB;YAC5D,wBAAwB,EAAE,IAAA,oBAAY,EAAC,kBAAkB,CAAC;SAC3D;KACF,CAAC,CAAC;IAEH,SAAG,CAAC,IAAI,CAAC,6CAA6C,EAAE;QACtD,WAAW;QACX,KAAK,EAAE,WAAW;QAClB,SAAS,EAAE,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;QAC7B,aAAa,EAAE,OAAO,CAAC,mBAAmB,CAAC;KAC5C,CAAC,CAAC;AAAA,CACJ","sourcesContent":["/**\n * Tool assembly: applies tool policy and PTC (Programmatic Tool Calling) experiments.\n *\n * Extracted from `streamMessage()` to isolate the tool policy + PTC experiment\n * concerns (including lazy-loading of heavy PTC dependencies: typescript,\n * prettier, QuickJS WASM).\n *\n * The function takes pre-assembled tools from `getToolsForModel()` and returns\n * the final tool set after policy filtering and PTC wrapping.\n */\n\nimport type { Tool } from \"ai\";\n\nimport { applyToolPolicy, type ToolPolicy } from \"@/common/utils/tools/toolPolicy\";\n// PTC types only — modules lazy-loaded to avoid loading typescript/prettier at startup\nimport type {\n  PTCEventWithParent,\n  createCodeExecutionTool as CreateCodeExecutionToolFn,\n} from \"@/node/services/tools/code_execution\";\nimport type { QuickJSRuntimeFactory } from \"@/node/services/ptc/quickjsRuntime\";\nimport type { ToolBridge } from \"@/node/services/ptc/toolBridge\";\nimport { log } from \"./log\";\nimport type { MCPWorkspaceStats } from \"@/node/services/mcpServerManager\";\nimport type { TelemetryService } from \"@/node/services/telemetryService\";\nimport type { WorkspaceMetadata } from \"@/common/types/workspace\";\nimport { getRuntimeTypeForTelemetry, roundToBase2 } from \"@/common/telemetry/utils\";\n\n// ---------------------------------------------------------------------------\n// PTC Lazy-Loading Singleton\n// ---------------------------------------------------------------------------\n\n// Lazy-loaded PTC modules (only loaded when experiment is enabled).\n// This avoids loading typescript/prettier at startup which causes issues:\n// - Integration tests fail without --experimental-vm-modules (prettier uses dynamic imports)\n// - Smoke tests fail if typescript isn't in production bundle\n// Dynamic imports are justified: PTC pulls in ~10MB of dependencies that would slow startup.\ninterface PTCModules {\n  createCodeExecutionTool: typeof CreateCodeExecutionToolFn;\n  QuickJSRuntimeFactory: typeof QuickJSRuntimeFactory;\n  ToolBridge: typeof ToolBridge;\n  runtimeFactory: QuickJSRuntimeFactory | null;\n}\nlet ptcModules: PTCModules | null = null;\n\nasync function getPTCModules(): Promise<PTCModules> {\n  if (ptcModules) return ptcModules;\n\n  /* eslint-disable no-restricted-syntax -- Dynamic imports required here to avoid loading\n     ~10MB of typescript/prettier/quickjs at startup (causes CI failures) */\n  const [codeExecution, quickjs, toolBridge] = await Promise.all([\n    import(\"@/node/services/tools/code_execution\"),\n    import(\"@/node/services/ptc/quickjsRuntime\"),\n    import(\"@/node/services/ptc/toolBridge\"),\n  ]);\n  /* eslint-enable no-restricted-syntax */\n\n  ptcModules = {\n    createCodeExecutionTool: codeExecution.createCodeExecutionTool,\n    QuickJSRuntimeFactory: quickjs.QuickJSRuntimeFactory,\n    ToolBridge: toolBridge.ToolBridge,\n    runtimeFactory: null,\n  };\n  return ptcModules;\n}\n\n// ---------------------------------------------------------------------------\n// Tool Policy + PTC Application\n// ---------------------------------------------------------------------------\n\n/** Options for applying tool policy and PTC experiments. */\nexport interface ApplyToolPolicyAndExperimentsOptions {\n  /** Tools from `getToolsForModel()` (before policy or PTC). */\n  allTools: Record<string, Tool>;\n  /** CLI-injected extra tools (bypass policy since they're runtime-provided). */\n  extraTools?: Record<string, Tool>;\n  /** Composed tool policy (agent → caller → system workspace). */\n  effectiveToolPolicy: ToolPolicy | undefined;\n  /** PTC experiment flags. */\n  experiments?: {\n    programmaticToolCalling?: boolean;\n    programmaticToolCallingExclusive?: boolean;\n  };\n  /** Callback to forward nested PTC tool events to the stream. */\n  emitNestedToolEvent: (event: PTCEventWithParent) => void;\n}\n\n/**\n * Apply tool policy, then wrap with PTC code_execution if experiments are enabled.\n *\n * Steps:\n * 1. Merge extra tools (CLI tools bypass policy — injected by runtime, not user)\n * 2. Apply tool policy (agent → caller → system workspace deny/enable rules)\n * 3. If PTC experiment is enabled, lazy-load PTC and create code_execution tool:\n *    - Supplement mode: adds code_execution alongside existing tools\n *    - Exclusive mode: replaces bridgeable tools with code_execution only\n *\n * @returns The final tool set ready for the AI model.\n */\nexport async function applyToolPolicyAndExperiments(\n  opts: ApplyToolPolicyAndExperimentsOptions\n): Promise<Record<string, Tool>> {\n  const { allTools, extraTools, effectiveToolPolicy, experiments, emitNestedToolEvent } = opts;\n\n  // Merge in extra tools (e.g., CLI-specific tools like set_exit_code).\n  // These bypass policy filtering since they're injected by the runtime, not user config.\n  const allToolsWithExtra = extraTools ? { ...allTools, ...extraTools } : allTools;\n\n  // Apply tool policy FIRST — this must happen before PTC to ensure the sandbox\n  // respects allow/deny filters. The policy-filtered tools are passed to\n  // ToolBridge so the mux.* API only exposes policy-allowed tools.\n  const policyFilteredTools = applyToolPolicy(allToolsWithExtra, effectiveToolPolicy);\n\n  // Handle PTC experiments — add or replace tools with code_execution\n  let toolsForModel = policyFilteredTools;\n  if (experiments?.programmaticToolCalling || experiments?.programmaticToolCallingExclusive) {\n    try {\n      // Lazy-load PTC modules only when experiments are enabled\n      const ptc = await getPTCModules();\n\n      // ToolBridge uses policy-filtered tools — sandbox only exposes allowed tools\n      const toolBridge = new ptc.ToolBridge(policyFilteredTools);\n\n      // Singleton runtime factory (WASM module is expensive to load)\n      ptc.runtimeFactory ??= new ptc.QuickJSRuntimeFactory();\n\n      const codeExecutionTool = await ptc.createCodeExecutionTool(\n        ptc.runtimeFactory,\n        toolBridge,\n        emitNestedToolEvent\n      );\n\n      if (experiments?.programmaticToolCallingExclusive) {\n        // Exclusive mode: code_execution is mandatory — it's the only way to use bridged\n        // tools. The experiment flag is the opt-in; policy cannot disable it here since\n        // that would leave no way to access tools. nonBridgeable is already policy-filtered.\n        const nonBridgeable = toolBridge.getNonBridgeableTools();\n        toolsForModel = { ...nonBridgeable, code_execution: codeExecutionTool };\n      } else {\n        // Supplement mode: add code_execution, then apply policy to determine final set.\n        // This correctly handles all policy combinations (require, enable, disable).\n        toolsForModel = applyToolPolicy(\n          { ...policyFilteredTools, code_execution: codeExecutionTool },\n          effectiveToolPolicy\n        );\n      }\n    } catch (error) {\n      // Fall back to policy-filtered tools if PTC creation fails\n      log.error(\"Failed to create code_execution tool, falling back to base tools\", { error });\n    }\n  }\n\n  return toolsForModel;\n}\n\n// ---------------------------------------------------------------------------\n// MCP Telemetry\n// ---------------------------------------------------------------------------\n\n/** Capture MCP tool configuration telemetry and log the final tool set. */\nexport function captureMcpToolTelemetry(opts: {\n  telemetryService?: TelemetryService;\n  mcpStats: MCPWorkspaceStats | undefined;\n  mcpTools: Record<string, Tool> | undefined;\n  tools: Record<string, Tool>;\n  mcpSetupDurationMs: number;\n  workspaceId: string;\n  modelString: string;\n  effectiveAgentId: string;\n  metadata: WorkspaceMetadata;\n  effectiveToolPolicy: ToolPolicy | undefined;\n}): void {\n  const {\n    telemetryService,\n    mcpStats,\n    mcpTools,\n    tools,\n    mcpSetupDurationMs,\n    workspaceId,\n    modelString,\n    effectiveAgentId,\n    metadata,\n    effectiveToolPolicy,\n  } = opts;\n\n  const effectiveMcpStats: MCPWorkspaceStats =\n    mcpStats ??\n    ({\n      enabledServerCount: 0,\n      startedServerCount: 0,\n      failedServerCount: 0,\n      autoFallbackCount: 0,\n      hasStdio: false,\n      hasHttp: false,\n      hasSse: false,\n      transportMode: \"none\",\n    } satisfies MCPWorkspaceStats);\n\n  const mcpToolNames = new Set(Object.keys(mcpTools ?? {}));\n  const toolNames = Object.keys(tools);\n  const mcpToolCount = toolNames.filter((name) => mcpToolNames.has(name)).length;\n  const totalToolCount = toolNames.length;\n  const builtinToolCount = Math.max(0, totalToolCount - mcpToolCount);\n\n  telemetryService?.capture({\n    event: \"mcp_context_injected\",\n    properties: {\n      workspaceId,\n      model: modelString,\n      agentId: effectiveAgentId,\n      runtimeType: getRuntimeTypeForTelemetry(metadata.runtimeConfig),\n\n      mcp_server_enabled_count: effectiveMcpStats.enabledServerCount,\n      mcp_server_started_count: effectiveMcpStats.startedServerCount,\n      mcp_server_failed_count: effectiveMcpStats.failedServerCount,\n\n      mcp_tool_count: mcpToolCount,\n      total_tool_count: totalToolCount,\n      builtin_tool_count: builtinToolCount,\n\n      mcp_transport_mode: effectiveMcpStats.transportMode,\n      mcp_has_http: effectiveMcpStats.hasHttp,\n      mcp_has_sse: effectiveMcpStats.hasSse,\n      mcp_has_stdio: effectiveMcpStats.hasStdio,\n      mcp_auto_fallback_count: effectiveMcpStats.autoFallbackCount,\n      mcp_setup_duration_ms_b2: roundToBase2(mcpSetupDurationMs),\n    },\n  });\n\n  log.info(\"AIService.streamMessage: tool configuration\", {\n    workspaceId,\n    model: modelString,\n    toolNames: Object.keys(tools),\n    hasToolPolicy: Boolean(effectiveToolPolicy),\n  });\n}\n"]}