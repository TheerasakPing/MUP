{"version":3,"file":"toolAssembly.js","sourceRoot":"","sources":["../../../src/node/services/toolAssembly.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Tool assembly: applies tool policy and PTC (Programmatic Tool Calling) experiments.\r\n *\r\n * Extracted from `streamMessage()` to isolate the tool policy + PTC experiment\r\n * concerns (including lazy-loading of heavy PTC dependencies: typescript,\r\n * prettier, QuickJS WASM).\r\n *\r\n * The function takes pre-assembled tools from `getToolsForModel()` and returns\r\n * the final tool set after policy filtering and PTC wrapping.\r\n */\r\n\r\nimport type { Tool } from \"ai\";\r\n\r\nimport { applyToolPolicy, type ToolPolicy } from \"@/common/utils/tools/toolPolicy\";\r\n// PTC types only — modules lazy-loaded to avoid loading typescript/prettier at startup\r\nimport type {\r\n  PTCEventWithParent,\r\n  createCodeExecutionTool as CreateCodeExecutionToolFn,\r\n} from \"@/node/services/tools/code_execution\";\r\nimport type { QuickJSRuntimeFactory } from \"@/node/services/ptc/quickjsRuntime\";\r\nimport type { ToolBridge } from \"@/node/services/ptc/toolBridge\";\r\nimport { log } from \"./log\";\r\nimport type { MCPWorkspaceStats } from \"@/node/services/mcpServerManager\";\r\nimport type { TelemetryService } from \"@/node/services/telemetryService\";\r\nimport type { WorkspaceMetadata } from \"@/common/types/workspace\";\r\nimport { getRuntimeTypeForTelemetry, roundToBase2 } from \"@/common/telemetry/utils\";\r\n\r\n// ---------------------------------------------------------------------------\r\n// PTC Lazy-Loading Singleton\r\n// ---------------------------------------------------------------------------\r\n\r\n// Lazy-loaded PTC modules (only loaded when experiment is enabled).\r\n// This avoids loading typescript/prettier at startup which causes issues:\r\n// - Integration tests fail without --experimental-vm-modules (prettier uses dynamic imports)\r\n// - Smoke tests fail if typescript isn't in production bundle\r\n// Dynamic imports are justified: PTC pulls in ~10MB of dependencies that would slow startup.\r\ninterface PTCModules {\r\n  createCodeExecutionTool: typeof CreateCodeExecutionToolFn;\r\n  QuickJSRuntimeFactory: typeof QuickJSRuntimeFactory;\r\n  ToolBridge: typeof ToolBridge;\r\n  runtimeFactory: QuickJSRuntimeFactory | null;\r\n}\r\nlet ptcModules: PTCModules | null = null;\r\n\r\nasync function getPTCModules(): Promise<PTCModules> {\r\n  if (ptcModules) return ptcModules;\r\n\r\n  /* eslint-disable no-restricted-syntax -- Dynamic imports required here to avoid loading\r\n     ~10MB of typescript/prettier/quickjs at startup (causes CI failures) */\r\n  const [codeExecution, quickjs, toolBridge] = await Promise.all([\r\n    import(\"@/node/services/tools/code_execution\"),\r\n    import(\"@/node/services/ptc/quickjsRuntime\"),\r\n    import(\"@/node/services/ptc/toolBridge\"),\r\n  ]);\r\n  /* eslint-enable no-restricted-syntax */\r\n\r\n  ptcModules = {\r\n    createCodeExecutionTool: codeExecution.createCodeExecutionTool,\r\n    QuickJSRuntimeFactory: quickjs.QuickJSRuntimeFactory,\r\n    ToolBridge: toolBridge.ToolBridge,\r\n    runtimeFactory: null,\r\n  };\r\n  return ptcModules;\r\n}\r\n\r\n// ---------------------------------------------------------------------------\r\n// Tool Policy + PTC Application\r\n// ---------------------------------------------------------------------------\r\n\r\n/** Options for applying tool policy and PTC experiments. */\r\nexport interface ApplyToolPolicyAndExperimentsOptions {\r\n  /** Tools from `getToolsForModel()` (before policy or PTC). */\r\n  allTools: Record<string, Tool>;\r\n  /** CLI-injected extra tools (bypass policy since they're runtime-provided). */\r\n  extraTools?: Record<string, Tool>;\r\n  /** Composed tool policy (agent → caller → system workspace). */\r\n  effectiveToolPolicy: ToolPolicy | undefined;\r\n  /** PTC experiment flags. */\r\n  experiments?: {\r\n    programmaticToolCalling?: boolean;\r\n    programmaticToolCallingExclusive?: boolean;\r\n  };\r\n  /** Callback to forward nested PTC tool events to the stream. */\r\n  emitNestedToolEvent: (event: PTCEventWithParent) => void;\r\n}\r\n\r\n/**\r\n * Apply tool policy, then wrap with PTC code_execution if experiments are enabled.\r\n *\r\n * Steps:\r\n * 1. Merge extra tools (CLI tools bypass policy — injected by runtime, not user)\r\n * 2. Apply tool policy (agent → caller → system workspace deny/enable rules)\r\n * 3. If PTC experiment is enabled, lazy-load PTC and create code_execution tool:\r\n *    - Supplement mode: adds code_execution alongside existing tools\r\n *    - Exclusive mode: replaces bridgeable tools with code_execution only\r\n *\r\n * @returns The final tool set ready for the AI model.\r\n */\r\nexport async function applyToolPolicyAndExperiments(\r\n  opts: ApplyToolPolicyAndExperimentsOptions\r\n): Promise<Record<string, Tool>> {\r\n  const { allTools, extraTools, effectiveToolPolicy, experiments, emitNestedToolEvent } = opts;\r\n\r\n  // Merge in extra tools (e.g., CLI-specific tools like set_exit_code).\r\n  // These bypass policy filtering since they're injected by the runtime, not user config.\r\n  const allToolsWithExtra = extraTools ? { ...allTools, ...extraTools } : allTools;\r\n\r\n  // Apply tool policy FIRST — this must happen before PTC to ensure the sandbox\r\n  // respects allow/deny filters. The policy-filtered tools are passed to\r\n  // ToolBridge so the mux.* API only exposes policy-allowed tools.\r\n  const policyFilteredTools = applyToolPolicy(allToolsWithExtra, effectiveToolPolicy);\r\n\r\n  // Handle PTC experiments — add or replace tools with code_execution\r\n  let toolsForModel = policyFilteredTools;\r\n  if (experiments?.programmaticToolCalling || experiments?.programmaticToolCallingExclusive) {\r\n    try {\r\n      // Lazy-load PTC modules only when experiments are enabled\r\n      const ptc = await getPTCModules();\r\n\r\n      // ToolBridge uses policy-filtered tools — sandbox only exposes allowed tools\r\n      const toolBridge = new ptc.ToolBridge(policyFilteredTools);\r\n\r\n      // Singleton runtime factory (WASM module is expensive to load)\r\n      ptc.runtimeFactory ??= new ptc.QuickJSRuntimeFactory();\r\n\r\n      const codeExecutionTool = await ptc.createCodeExecutionTool(\r\n        ptc.runtimeFactory,\r\n        toolBridge,\r\n        emitNestedToolEvent\r\n      );\r\n\r\n      if (experiments?.programmaticToolCallingExclusive) {\r\n        // Exclusive mode: code_execution is mandatory — it's the only way to use bridged\r\n        // tools. The experiment flag is the opt-in; policy cannot disable it here since\r\n        // that would leave no way to access tools. nonBridgeable is already policy-filtered.\r\n        const nonBridgeable = toolBridge.getNonBridgeableTools();\r\n        toolsForModel = { ...nonBridgeable, code_execution: codeExecutionTool };\r\n      } else {\r\n        // Supplement mode: add code_execution, then apply policy to determine final set.\r\n        // This correctly handles all policy combinations (require, enable, disable).\r\n        toolsForModel = applyToolPolicy(\r\n          { ...policyFilteredTools, code_execution: codeExecutionTool },\r\n          effectiveToolPolicy\r\n        );\r\n      }\r\n    } catch (error) {\r\n      // Fall back to policy-filtered tools if PTC creation fails\r\n      log.error(\"Failed to create code_execution tool, falling back to base tools\", { error });\r\n    }\r\n  }\r\n\r\n  return toolsForModel;\r\n}\r\n\r\n// ---------------------------------------------------------------------------\r\n// MCP Telemetry\r\n// ---------------------------------------------------------------------------\r\n\r\n/** Capture MCP tool configuration telemetry and log the final tool set. */\r\nexport function captureMcpToolTelemetry(opts: {\r\n  telemetryService?: TelemetryService;\r\n  mcpStats: MCPWorkspaceStats | undefined;\r\n  mcpTools: Record<string, Tool> | undefined;\r\n  tools: Record<string, Tool>;\r\n  mcpSetupDurationMs: number;\r\n  workspaceId: string;\r\n  modelString: string;\r\n  effectiveAgentId: string;\r\n  metadata: WorkspaceMetadata;\r\n  effectiveToolPolicy: ToolPolicy | undefined;\r\n}): void {\r\n  const {\r\n    telemetryService,\r\n    mcpStats,\r\n    mcpTools,\r\n    tools,\r\n    mcpSetupDurationMs,\r\n    workspaceId,\r\n    modelString,\r\n    effectiveAgentId,\r\n    metadata,\r\n    effectiveToolPolicy,\r\n  } = opts;\r\n\r\n  const effectiveMcpStats: MCPWorkspaceStats =\r\n    mcpStats ??\r\n    ({\r\n      enabledServerCount: 0,\r\n      startedServerCount: 0,\r\n      failedServerCount: 0,\r\n      autoFallbackCount: 0,\r\n      hasStdio: false,\r\n      hasHttp: false,\r\n      hasSse: false,\r\n      transportMode: \"none\",\r\n    } satisfies MCPWorkspaceStats);\r\n\r\n  const mcpToolNames = new Set(Object.keys(mcpTools ?? {}));\r\n  const toolNames = Object.keys(tools);\r\n  const mcpToolCount = toolNames.filter((name) => mcpToolNames.has(name)).length;\r\n  const totalToolCount = toolNames.length;\r\n  const builtinToolCount = Math.max(0, totalToolCount - mcpToolCount);\r\n\r\n  telemetryService?.capture({\r\n    event: \"mcp_context_injected\",\r\n    properties: {\r\n      workspaceId,\r\n      model: modelString,\r\n      agentId: effectiveAgentId,\r\n      runtimeType: getRuntimeTypeForTelemetry(metadata.runtimeConfig),\r\n\r\n      mcp_server_enabled_count: effectiveMcpStats.enabledServerCount,\r\n      mcp_server_started_count: effectiveMcpStats.startedServerCount,\r\n      mcp_server_failed_count: effectiveMcpStats.failedServerCount,\r\n\r\n      mcp_tool_count: mcpToolCount,\r\n      total_tool_count: totalToolCount,\r\n      builtin_tool_count: builtinToolCount,\r\n\r\n      mcp_transport_mode: effectiveMcpStats.transportMode,\r\n      mcp_has_http: effectiveMcpStats.hasHttp,\r\n      mcp_has_sse: effectiveMcpStats.hasSse,\r\n      mcp_has_stdio: effectiveMcpStats.hasStdio,\r\n      mcp_auto_fallback_count: effectiveMcpStats.autoFallbackCount,\r\n      mcp_setup_duration_ms_b2: roundToBase2(mcpSetupDurationMs),\r\n    },\r\n  });\r\n\r\n  log.info(\"AIService.streamMessage: tool configuration\", {\r\n    workspaceId,\r\n    model: modelString,\r\n    toolNames: Object.keys(tools),\r\n    hasToolPolicy: Boolean(effectiveToolPolicy),\r\n  });\r\n}\r\n"]}