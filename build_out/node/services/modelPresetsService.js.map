{"version":3,"file":"modelPresetsService.js","sourceRoot":"","sources":["../../../src/node/services/modelPresetsService.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs/promises\";\r\nimport * as path from \"path\";\r\nimport * as crypto from \"crypto\";\r\nimport writeFileAtomic from \"write-file-atomic\";\r\nimport type { Config } from \"@/node/config\";\r\nimport type { CustomModelMetadata } from \"@/common/orpc/schemas/api\";\r\nimport type { Result } from \"@/common/types/result\";\r\nimport { log } from \"./log\";\r\n\r\n// --- Data Model ---\r\n\r\nexport interface PresetModelEntry {\r\n    provider: string;\r\n    modelId: string;\r\n    metadata?: CustomModelMetadata;\r\n}\r\n\r\nexport interface ModelPreset {\r\n    id: string;\r\n    name: string;\r\n    description?: string;\r\n    createdAt: number;\r\n    updatedAt: number;\r\n    models: PresetModelEntry[];\r\n}\r\n\r\ninterface ModelPresetsFile {\r\n    version: 1;\r\n    presets: ModelPreset[];\r\n}\r\n\r\nconst EMPTY_FILE: ModelPresetsFile = { version: 1, presets: [] };\r\n\r\n/**\r\n * Service for managing model presets.\r\n *\r\n * Presets let users snapshot their model configurations and restore them later.\r\n * Data is stored in `~/.mux/model-presets.json` using atomic writes.\r\n */\r\nexport class ModelPresetsService {\r\n    private readonly PRESETS_FILE = \"model-presets.json\";\r\n    private readonly config: Config;\r\n\r\n    constructor(config: Config) {\r\n        this.config = config;\r\n    }\r\n\r\n    private getFilePath(): string {\r\n        return path.join(this.config.rootDir, this.PRESETS_FILE);\r\n    }\r\n\r\n    private async readFile(): Promise<ModelPresetsFile> {\r\n        try {\r\n            const data = await fs.readFile(this.getFilePath(), \"utf-8\");\r\n            return JSON.parse(data) as ModelPresetsFile;\r\n        } catch (error) {\r\n            if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\r\n                return { ...EMPTY_FILE };\r\n            }\r\n            log.warn(\"[ModelPresetsService] Error reading presets file\", { error });\r\n            return { ...EMPTY_FILE };\r\n        }\r\n    }\r\n\r\n    private async writeFile(data: ModelPresetsFile): Promise<void> {\r\n        const filePath = this.getFilePath();\r\n        await fs.mkdir(path.dirname(filePath), { recursive: true });\r\n        await writeFileAtomic(filePath, JSON.stringify(data, null, 2));\r\n    }\r\n\r\n    /** List all saved presets. */\r\n    async listPresets(): Promise<ModelPreset[]> {\r\n        const file = await this.readFile();\r\n        return file.presets;\r\n    }\r\n\r\n    /** Save a new preset from the provided models. */\r\n    async savePreset(\r\n        name: string,\r\n        models: PresetModelEntry[],\r\n        description?: string\r\n    ): Promise<ModelPreset> {\r\n        const file = await this.readFile();\r\n        const now = Date.now();\r\n        const preset: ModelPreset = {\r\n            id: crypto.randomUUID(),\r\n            name,\r\n            description,\r\n            createdAt: now,\r\n            updatedAt: now,\r\n            models,\r\n        };\r\n        file.presets.push(preset);\r\n        await this.writeFile(file);\r\n        return preset;\r\n    }\r\n\r\n    /** Get a single preset by ID. */\r\n    async getPreset(id: string): Promise<ModelPreset | undefined> {\r\n        const file = await this.readFile();\r\n        return file.presets.find((p) => p.id === id);\r\n    }\r\n\r\n    /** Delete a preset by ID. Returns success/error result. */\r\n    async deletePreset(id: string): Promise<Result<void, string>> {\r\n        const file = await this.readFile();\r\n        const index = file.presets.findIndex((p) => p.id === id);\r\n        if (index === -1) {\r\n            return { success: false, error: `Preset not found: ${id}` };\r\n        }\r\n        file.presets.splice(index, 1);\r\n        await this.writeFile(file);\r\n        return { success: true, data: undefined };\r\n    }\r\n\r\n    /** Update an existing preset. */\r\n    async updatePreset(\r\n        id: string,\r\n        updates: { name?: string; description?: string; models?: PresetModelEntry[] }\r\n    ): Promise<Result<ModelPreset, string>> {\r\n        const file = await this.readFile();\r\n        const preset = file.presets.find((p) => p.id === id);\r\n        if (!preset) {\r\n            return { success: false, error: `Preset not found: ${id}` };\r\n        }\r\n        if (updates.name !== undefined) preset.name = updates.name;\r\n        if (updates.description !== undefined) preset.description = updates.description;\r\n        if (updates.models !== undefined) preset.models = updates.models;\r\n        preset.updatedAt = Date.now();\r\n        await this.writeFile(file);\r\n        return { success: true, data: preset };\r\n    }\r\n\r\n    /**\r\n     * Export presets as a portable JSON string.\r\n     * If ids are provided, only those presets are exported; otherwise all.\r\n     */\r\n    async exportPresets(ids?: string[]): Promise<string> {\r\n        const file = await this.readFile();\r\n        const presets = ids ? file.presets.filter((p) => ids.includes(p.id)) : file.presets;\r\n        const exportData = { version: 1 as const, presets };\r\n        return JSON.stringify(exportData, null, 2);\r\n    }\r\n\r\n    /**\r\n     * Import presets from a JSON string. Validates structure before importing.\r\n     * Imported presets get new IDs to avoid collisions.\r\n     */\r\n    async importPresets(json: string): Promise<Result<ModelPreset[], string>> {\r\n        let parsed: unknown;\r\n        try {\r\n            parsed = JSON.parse(json);\r\n        } catch {\r\n            return { success: false, error: \"Invalid JSON\" };\r\n        }\r\n\r\n        if (!parsed || typeof parsed !== \"object\") {\r\n            return { success: false, error: \"Expected an object with presets array\" };\r\n        }\r\n\r\n        const obj = parsed as Record<string, unknown>;\r\n        if (!Array.isArray(obj.presets)) {\r\n            return { success: false, error: \"Missing or invalid 'presets' array\" };\r\n        }\r\n\r\n        const file = await this.readFile();\r\n        const imported: ModelPreset[] = [];\r\n        const now = Date.now();\r\n\r\n        for (const raw of obj.presets) {\r\n            if (!raw || typeof raw !== \"object\") continue;\r\n            const p = raw as Record<string, unknown>;\r\n\r\n            if (typeof p.name !== \"string\" || !Array.isArray(p.models)) {\r\n                continue; // skip malformed entries\r\n            }\r\n\r\n            const models: PresetModelEntry[] = [];\r\n            for (const m of p.models as unknown[]) {\r\n                if (!m || typeof m !== \"object\") continue;\r\n                const model = m as Record<string, unknown>;\r\n                if (typeof model.provider !== \"string\" || typeof model.modelId !== \"string\") continue;\r\n                models.push({\r\n                    provider: model.provider,\r\n                    modelId: model.modelId,\r\n                    metadata: model.metadata as CustomModelMetadata | undefined,\r\n                });\r\n            }\r\n\r\n            const preset: ModelPreset = {\r\n                id: crypto.randomUUID(), // new ID to avoid collision\r\n                name: p.name as string,\r\n                description: typeof p.description === \"string\" ? p.description : undefined,\r\n                createdAt: now,\r\n                updatedAt: now,\r\n                models,\r\n            };\r\n            file.presets.push(preset);\r\n            imported.push(preset);\r\n        }\r\n\r\n        if (imported.length === 0) {\r\n            return { success: false, error: \"No valid presets found in import data\" };\r\n        }\r\n\r\n        await this.writeFile(file);\r\n        return { success: true, data: imported };\r\n    }\r\n}\r\n"]}