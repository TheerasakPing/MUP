{"version":3,"file":"attachmentService.js","sourceRoot":"","sources":["../../../src/node/services/attachmentService.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  PostCompactionAttachment,\n  PlanFileReferenceAttachment,\n  EditedFilesReferenceAttachment,\n} from \"@/common/types/attachment\";\nimport { getPlanFilePath, getLegacyPlanFilePath } from \"@/common/utils/planStorage\";\nimport type { FileEditDiff } from \"@/common/utils/messages/extractEditedFiles\";\nimport type { Runtime } from \"@/node/runtime/Runtime\";\nimport { readFileString } from \"@/node/utils/runtime/helpers\";\nimport { expandTilde } from \"@/node/runtime/tildeExpansion\";\nimport { MAX_POST_COMPACTION_PLAN_CHARS } from \"@/common/constants/attachments\";\n\nconst TRUNCATED_PLAN_NOTE = \"\\n\\n...(truncated)\\n\";\n\nfunction truncatePlanContent(planContent: string): string {\n  if (planContent.length <= MAX_POST_COMPACTION_PLAN_CHARS) {\n    return planContent;\n  }\n\n  const sliceLength = Math.max(0, MAX_POST_COMPACTION_PLAN_CHARS - TRUNCATED_PLAN_NOTE.length);\n  return `${planContent.slice(0, sliceLength)}${TRUNCATED_PLAN_NOTE}`;\n}\n\n/**\n * Service for generating post-compaction attachments.\n * These attachments preserve context that would otherwise be lost after compaction.\n */\nexport class AttachmentService {\n  /**\n   * Generate a plan file reference attachment if the plan file exists.\n   * Mode-agnostic: plan context is valuable in both plan and exec modes.\n   * Falls back to legacy plan path if new path doesn't exist.\n   */\n  static async generatePlanFileReference(\n    workspaceName: string,\n    projectName: string,\n    workspaceId: string,\n    runtime: Runtime\n  ): Promise<PlanFileReferenceAttachment | null> {\n    const muxHome = runtime.getMuxHome();\n    const planFilePath = getPlanFilePath(workspaceName, projectName, muxHome);\n    // Legacy paths only used for non-Docker runtimes (Docker has no legacy files)\n    const legacyPlanPath = getLegacyPlanFilePath(workspaceId);\n\n    // Try new path first\n    try {\n      const planContent = await readFileString(runtime, planFilePath);\n      if (planContent) {\n        return {\n          type: \"plan_file_reference\",\n          planFilePath,\n          planContent: truncatePlanContent(planContent),\n        };\n      }\n    } catch {\n      // Plan file doesn't exist at new path, try legacy\n    }\n\n    // Fall back to legacy path\n    try {\n      const planContent = await readFileString(runtime, legacyPlanPath);\n      if (planContent) {\n        return {\n          type: \"plan_file_reference\",\n          planFilePath: legacyPlanPath,\n          planContent: truncatePlanContent(planContent),\n        };\n      }\n    } catch {\n      // Plan file doesn't exist at legacy path either\n    }\n\n    return null;\n  }\n\n  /**\n   * Generate an edited files reference attachment from extracted file diffs.\n   * Excludes the plan file (which is handled separately).\n   * @param planPathsToFilter - Array of plan file paths to filter (both tilde and expanded)\n   */\n  static generateEditedFilesAttachment(\n    fileDiffs: FileEditDiff[],\n    planPathsToFilter: string[] = []\n  ): EditedFilesReferenceAttachment | null {\n    // Build set of paths to filter (includes both tilde and expanded versions)\n    const pathsToFilter = new Set<string>();\n    for (const p of planPathsToFilter) {\n      pathsToFilter.add(p);\n      pathsToFilter.add(expandTilde(p));\n    }\n\n    const files = fileDiffs\n      .filter((f) => !pathsToFilter.has(f.path))\n      .map((f) => ({\n        path: f.path,\n        diff: f.diff,\n        truncated: f.truncated,\n      }));\n\n    if (files.length === 0) {\n      return null;\n    }\n\n    return {\n      type: \"edited_files_reference\",\n      files,\n    };\n  }\n\n  /**\n   * Generate all post-compaction attachments.\n   * Returns empty array if no attachments are needed.\n   * @param excludedItems - Set of item IDs to exclude (\"plan\" or \"file:<path>\")\n   */\n  static async generatePostCompactionAttachments(\n    workspaceName: string,\n    projectName: string,\n    workspaceId: string,\n    fileDiffs: FileEditDiff[],\n    runtime: Runtime,\n    excludedItems: Set<string> = new Set<string>()\n  ): Promise<PostCompactionAttachment[]> {\n    const attachments: PostCompactionAttachment[] = [];\n    const muxHome = runtime.getMuxHome();\n    const planFilePath = getPlanFilePath(workspaceName, projectName, muxHome);\n    const legacyPlanPath = getLegacyPlanFilePath(workspaceId);\n\n    // Plan file reference (skip if excluded)\n    let planRef: PlanFileReferenceAttachment | null = null;\n    if (!excludedItems.has(\"plan\")) {\n      planRef = await this.generatePlanFileReference(\n        workspaceName,\n        projectName,\n        workspaceId,\n        runtime\n      );\n      if (planRef) {\n        attachments.push(planRef);\n      }\n    }\n\n    // Filter out excluded files\n    const filteredDiffs = fileDiffs.filter((f) => !excludedItems.has(`file:${f.path}`));\n\n    // Edited files reference - always filter out both new and legacy plan paths\n    // to prevent plan file from appearing in the file diffs list\n    const editedFilesRef = this.generateEditedFilesAttachment(filteredDiffs, [\n      planFilePath,\n      legacyPlanPath,\n    ]);\n    if (editedFilesRef) {\n      attachments.push(editedFilesRef);\n    }\n\n    return attachments;\n  }\n}\n"]}