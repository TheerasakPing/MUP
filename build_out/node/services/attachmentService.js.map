{"version":3,"file":"attachmentService.js","sourceRoot":"","sources":["../../../src/node/services/attachmentService.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\r\n  PostCompactionAttachment,\r\n  PlanFileReferenceAttachment,\r\n  EditedFilesReferenceAttachment,\r\n} from \"@/common/types/attachment\";\r\nimport { getPlanFilePath, getLegacyPlanFilePath } from \"@/common/utils/planStorage\";\r\nimport type { FileEditDiff } from \"@/common/utils/messages/extractEditedFiles\";\r\nimport type { Runtime } from \"@/node/runtime/Runtime\";\r\nimport { readFileString } from \"@/node/utils/runtime/helpers\";\r\nimport { expandTilde } from \"@/node/runtime/tildeExpansion\";\r\nimport { MAX_POST_COMPACTION_PLAN_CHARS } from \"@/common/constants/attachments\";\r\n\r\nconst TRUNCATED_PLAN_NOTE = \"\\n\\n...(truncated)\\n\";\r\n\r\nfunction truncatePlanContent(planContent: string): string {\r\n  if (planContent.length <= MAX_POST_COMPACTION_PLAN_CHARS) {\r\n    return planContent;\r\n  }\r\n\r\n  const sliceLength = Math.max(0, MAX_POST_COMPACTION_PLAN_CHARS - TRUNCATED_PLAN_NOTE.length);\r\n  return `${planContent.slice(0, sliceLength)}${TRUNCATED_PLAN_NOTE}`;\r\n}\r\n\r\n/**\r\n * Service for generating post-compaction attachments.\r\n * These attachments preserve context that would otherwise be lost after compaction.\r\n */\r\nexport class AttachmentService {\r\n  /**\r\n   * Generate a plan file reference attachment if the plan file exists.\r\n   * Mode-agnostic: plan context is valuable in both plan and exec modes.\r\n   * Falls back to legacy plan path if new path doesn't exist.\r\n   */\r\n  static async generatePlanFileReference(\r\n    workspaceName: string,\r\n    projectName: string,\r\n    workspaceId: string,\r\n    runtime: Runtime\r\n  ): Promise<PlanFileReferenceAttachment | null> {\r\n    const muxHome = runtime.getMuxHome();\r\n    const planFilePath = getPlanFilePath(workspaceName, projectName, muxHome);\r\n    // Legacy paths only used for non-Docker runtimes (Docker has no legacy files)\r\n    const legacyPlanPath = getLegacyPlanFilePath(workspaceId);\r\n\r\n    // Try new path first\r\n    try {\r\n      const planContent = await readFileString(runtime, planFilePath);\r\n      if (planContent) {\r\n        return {\r\n          type: \"plan_file_reference\",\r\n          planFilePath,\r\n          planContent: truncatePlanContent(planContent),\r\n        };\r\n      }\r\n    } catch {\r\n      // Plan file doesn't exist at new path, try legacy\r\n    }\r\n\r\n    // Fall back to legacy path\r\n    try {\r\n      const planContent = await readFileString(runtime, legacyPlanPath);\r\n      if (planContent) {\r\n        return {\r\n          type: \"plan_file_reference\",\r\n          planFilePath: legacyPlanPath,\r\n          planContent: truncatePlanContent(planContent),\r\n        };\r\n      }\r\n    } catch {\r\n      // Plan file doesn't exist at legacy path either\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Generate an edited files reference attachment from extracted file diffs.\r\n   * Excludes the plan file (which is handled separately).\r\n   * @param planPathsToFilter - Array of plan file paths to filter (both tilde and expanded)\r\n   */\r\n  static generateEditedFilesAttachment(\r\n    fileDiffs: FileEditDiff[],\r\n    planPathsToFilter: string[] = []\r\n  ): EditedFilesReferenceAttachment | null {\r\n    // Build set of paths to filter (includes both tilde and expanded versions)\r\n    const pathsToFilter = new Set<string>();\r\n    for (const p of planPathsToFilter) {\r\n      pathsToFilter.add(p);\r\n      pathsToFilter.add(expandTilde(p));\r\n    }\r\n\r\n    const files = fileDiffs\r\n      .filter((f) => !pathsToFilter.has(f.path))\r\n      .map((f) => ({\r\n        path: f.path,\r\n        diff: f.diff,\r\n        truncated: f.truncated,\r\n      }));\r\n\r\n    if (files.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      type: \"edited_files_reference\",\r\n      files,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate all post-compaction attachments.\r\n   * Returns empty array if no attachments are needed.\r\n   * @param excludedItems - Set of item IDs to exclude (\"plan\" or \"file:<path>\")\r\n   */\r\n  static async generatePostCompactionAttachments(\r\n    workspaceName: string,\r\n    projectName: string,\r\n    workspaceId: string,\r\n    fileDiffs: FileEditDiff[],\r\n    runtime: Runtime,\r\n    excludedItems: Set<string> = new Set<string>()\r\n  ): Promise<PostCompactionAttachment[]> {\r\n    const attachments: PostCompactionAttachment[] = [];\r\n    const muxHome = runtime.getMuxHome();\r\n    const planFilePath = getPlanFilePath(workspaceName, projectName, muxHome);\r\n    const legacyPlanPath = getLegacyPlanFilePath(workspaceId);\r\n\r\n    // Plan file reference (skip if excluded)\r\n    let planRef: PlanFileReferenceAttachment | null = null;\r\n    if (!excludedItems.has(\"plan\")) {\r\n      planRef = await this.generatePlanFileReference(\r\n        workspaceName,\r\n        projectName,\r\n        workspaceId,\r\n        runtime\r\n      );\r\n      if (planRef) {\r\n        attachments.push(planRef);\r\n      }\r\n    }\r\n\r\n    // Filter out excluded files\r\n    const filteredDiffs = fileDiffs.filter((f) => !excludedItems.has(`file:${f.path}`));\r\n\r\n    // Edited files reference - always filter out both new and legacy plan paths\r\n    // to prevent plan file from appearing in the file diffs list\r\n    const editedFilesRef = this.generateEditedFilesAttachment(filteredDiffs, [\r\n      planFilePath,\r\n      legacyPlanPath,\r\n    ]);\r\n    if (editedFilesRef) {\r\n      attachments.push(editedFilesRef);\r\n    }\r\n\r\n    return attachments;\r\n  }\r\n}\r\n"]}