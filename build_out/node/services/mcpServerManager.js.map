{"version":3,"file":"mcpServerManager.js","sourceRoot":"","sources":["../../../src/node/services/mcpServerManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { createMCPClient, type OAuthClientProvider } from \"@ai-sdk/mcp\";\r\nimport type { Tool } from \"ai\";\r\nimport { log } from \"@/node/services/log\";\r\nimport { MCPStdioTransport } from \"@/node/services/mcpStdioTransport\";\r\nimport type {\r\n  BearerChallenge,\r\n  MCPHeaderValue,\r\n  MCPServerInfo,\r\n  MCPServerMap,\r\n  MCPServerTransport,\r\n  MCPTestResult,\r\n  WorkspaceMCPOverrides,\r\n} from \"@/common/types/mcp\";\r\nimport type { Runtime } from \"@/node/runtime/Runtime\";\r\nimport type { PolicyService } from \"@/node/services/policyService\";\r\nimport type { MCPConfigService } from \"@/node/services/mcpConfigService\";\r\nimport { parseBearerWwwAuthenticate, type McpOauthService } from \"@/node/services/mcpOauthService\";\r\nimport { createRuntime } from \"@/node/runtime/runtimeFactory\";\r\nimport { transformMCPResult, type MCPCallToolResult } from \"@/node/services/mcpResultTransform\";\r\nimport { buildMcpToolName } from \"@/common/utils/tools/mcpToolName\";\r\n\r\nconst TEST_TIMEOUT_MS = 10_000;\r\nconst IDLE_TIMEOUT_MS = 10 * 60 * 1000; // 10 minutes\r\nconst IDLE_CHECK_INTERVAL_MS = 60 * 1000; // Check every minute\r\n\r\n/**\r\n * Wrap MCP tools to transform their results to AI SDK format.\r\n * This ensures image content is properly converted to media type.\r\n */\r\nfunction wrapMCPTools(tools: Record<string, Tool>, onActivity?: () => void): Record<string, Tool> {\r\n  const wrapped: Record<string, Tool> = {};\r\n  for (const [name, tool] of Object.entries(tools)) {\r\n    // Only wrap tools that have an execute function\r\n    if (!tool.execute) {\r\n      wrapped[name] = tool;\r\n      continue;\r\n    }\r\n\r\n    const originalExecute = tool.execute;\r\n    wrapped[name] = {\r\n      ...tool,\r\n      execute: async (args: Parameters<typeof originalExecute>[0], options) => {\r\n        // Mark the MCP server set as active *before* execution, so failed tool\r\n        // calls (including closed-client races) still count as activity.\r\n        onActivity?.();\r\n\r\n        const result: unknown = await originalExecute(args, options);\r\n        return transformMCPResult(result as MCPCallToolResult);\r\n      },\r\n    };\r\n  }\r\n  return wrapped;\r\n}\r\n\r\ntype ResolvedHeaders = Record<string, string> | undefined;\r\n\r\ntype ResolvedTransport = \"stdio\" | \"http\" | \"sse\";\r\n\r\nfunction resolveHeaders(\r\n  headers: Record<string, MCPHeaderValue> | undefined,\r\n  projectSecrets: Record<string, string> | undefined\r\n): { headers: ResolvedHeaders; usesSecretHeaders: boolean } {\r\n  if (!headers) {\r\n    return { headers: undefined, usesSecretHeaders: false };\r\n  }\r\n\r\n  const resolved: Record<string, string> = {};\r\n  let usesSecretHeaders = false;\r\n\r\n  for (const [key, value] of Object.entries(headers)) {\r\n    if (typeof value === \"string\") {\r\n      resolved[key] = value;\r\n      continue;\r\n    }\r\n\r\n    usesSecretHeaders = true;\r\n    const secretKey = value.secret;\r\n    const secretValue = projectSecrets?.[secretKey];\r\n    if (typeof secretValue !== \"string\") {\r\n      throw new Error(`Missing project secret: ${secretKey}`);\r\n    }\r\n    resolved[key] = secretValue;\r\n  }\r\n\r\n  return { headers: resolved, usesSecretHeaders };\r\n}\r\n\r\nfunction extractHttpStatusCode(error: unknown): number | null {\r\n  if (!error || typeof error !== \"object\") {\r\n    return null;\r\n  }\r\n\r\n  const obj = error as Record<string, unknown>;\r\n\r\n  // A few common shapes across fetch libraries / AI SDK.\r\n  const statusCode = obj.statusCode;\r\n  if (typeof statusCode === \"number\") {\r\n    return statusCode;\r\n  }\r\n\r\n  const status = obj.status;\r\n  if (typeof status === \"number\") {\r\n    return status;\r\n  }\r\n\r\n  const response = obj.response;\r\n  if (response && typeof response === \"object\") {\r\n    const responseStatus = (response as Record<string, unknown>).status;\r\n    if (typeof responseStatus === \"number\") {\r\n      return responseStatus;\r\n    }\r\n  }\r\n\r\n  const cause = obj.cause;\r\n  if (cause && typeof cause === \"object\") {\r\n    const causeStatus = (cause as Record<string, unknown>).statusCode;\r\n    if (typeof causeStatus === \"number\") {\r\n      return causeStatus;\r\n    }\r\n  }\r\n\r\n  // Best-effort fallback on message contents.\r\n  const message = obj.message;\r\n  if (typeof message === \"string\") {\r\n    const re = /\\b(400|401|403|404|405)\\b/;\r\n    const match = re.exec(message);\r\n    if (match) {\r\n      return Number(match[1]);\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction shouldAutoFallbackToSse(error: unknown): boolean {\r\n  const status = extractHttpStatusCode(error);\r\n  return status === 400 || status === 404 || status === 405;\r\n}\r\n\r\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\r\n  return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\r\n}\r\n\r\nfunction hasHeaderGetter(value: unknown): value is { get: (name: string) => unknown } {\r\n  return (\r\n    value !== null &&\r\n    typeof value === \"object\" &&\r\n    \"get\" in value &&\r\n    typeof (value as { get: unknown }).get === \"function\"\r\n  );\r\n}\r\n\r\nfunction extractHeaderValue(headers: unknown, name: string): string | null {\r\n  if (!headers) {\r\n    return null;\r\n  }\r\n\r\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers) {\r\n    return headers.get(name);\r\n  }\r\n\r\n  if (hasHeaderGetter(headers)) {\r\n    const value = headers.get(name);\r\n    return typeof value === \"string\" ? value : null;\r\n  }\r\n\r\n  if (isPlainObject(headers)) {\r\n    const target = name.toLowerCase();\r\n    for (const [key, value] of Object.entries(headers)) {\r\n      if (key.toLowerCase() !== target) {\r\n        continue;\r\n      }\r\n\r\n      if (typeof value === \"string\") {\r\n        return value;\r\n      }\r\n\r\n      if (Array.isArray(value) && value.every((v) => typeof v === \"string\")) {\r\n        return value.join(\", \");\r\n      }\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction extractWwwAuthenticateHeader(error: unknown): string | null {\r\n  if (!isPlainObject(error)) {\r\n    return null;\r\n  }\r\n\r\n  const direct =\r\n    extractHeaderValue(error.responseHeaders, \"www-authenticate\") ??\r\n    extractHeaderValue(error.headers, \"www-authenticate\");\r\n\r\n  if (direct) {\r\n    return direct;\r\n  }\r\n\r\n  const response = error.response;\r\n  if (isPlainObject(response)) {\r\n    const fromResponse = extractHeaderValue(response.headers, \"www-authenticate\");\r\n    if (fromResponse) {\r\n      return fromResponse;\r\n    }\r\n  }\r\n\r\n  const data = error.data;\r\n  if (isPlainObject(data)) {\r\n    const fromData =\r\n      extractHeaderValue(data.responseHeaders, \"www-authenticate\") ??\r\n      extractHeaderValue(data.headers, \"www-authenticate\");\r\n\r\n    if (fromData) {\r\n      return fromData;\r\n    }\r\n  }\r\n\r\n  const cause = error.cause;\r\n  if (cause) {\r\n    return extractWwwAuthenticateHeader(cause);\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nasync function probeWwwAuthenticateHeader(url: string): Promise<string | null> {\r\n  const abortController = new AbortController();\r\n  const timeout = setTimeout(() => abortController.abort(), 3_000);\r\n\r\n  try {\r\n    const response = await fetch(url, {\r\n      method: \"GET\",\r\n      headers: {\r\n        Accept: \"text/event-stream\",\r\n      },\r\n      redirect: \"manual\",\r\n      signal: abortController.signal,\r\n    });\r\n\r\n    return response.headers.get(\"www-authenticate\");\r\n  } catch {\r\n    return null;\r\n  } finally {\r\n    clearTimeout(timeout);\r\n  }\r\n}\r\n\r\nasync function extractBearerOauthChallenge(options: {\r\n  error: unknown;\r\n  serverUrl: string | null;\r\n}): Promise<BearerChallenge | null> {\r\n  const status = extractHttpStatusCode(options.error);\r\n  if (status !== 401 && status !== 403) {\r\n    return null;\r\n  }\r\n\r\n  let header = extractWwwAuthenticateHeader(options.error);\r\n  if (!header && options.serverUrl) {\r\n    header = await probeWwwAuthenticateHeader(options.serverUrl);\r\n  }\r\n\r\n  if (!header) {\r\n    return null;\r\n  }\r\n\r\n  const challenge = parseBearerWwwAuthenticate(header);\r\n  if (!challenge) {\r\n    return null;\r\n  }\r\n\r\n  return {\r\n    scope: challenge.scope,\r\n    resourceMetadataUrl: challenge.resourceMetadataUrl?.toString(),\r\n  };\r\n}\r\n\r\nexport type { MCPTestResult } from \"@/common/types/mcp\";\r\n\r\n/**\r\n * Run a test connection to an MCP server.\r\n * Connects, fetches tools, then closes.\r\n */\r\nasync function runServerTest(\r\n  server:\r\n    | { transport: \"stdio\"; command: string }\r\n    | {\r\n        transport: \"http\" | \"sse\" | \"auto\";\r\n        url: string;\r\n        headers?: ResolvedHeaders;\r\n        authProvider?: OAuthClientProvider;\r\n      },\r\n  projectPath: string,\r\n  logContext: string\r\n): Promise<MCPTestResult> {\r\n  const timeoutPromise = new Promise<MCPTestResult>((resolve) =>\r\n    setTimeout(() => resolve({ success: false, error: \"Connection timed out\" }), TEST_TIMEOUT_MS)\r\n  );\r\n\r\n  const testPromise = (async (): Promise<MCPTestResult> => {\r\n    let stdioTransport: MCPStdioTransport | null = null;\r\n    let client: Awaited<ReturnType<typeof createMCPClient>> | null = null;\r\n\r\n    try {\r\n      if (server.transport === \"stdio\") {\r\n        const runtime = createRuntime({ type: \"local\", srcBaseDir: projectPath });\r\n        log.debug(`[MCP] Testing ${logContext}`, { transport: \"stdio\" });\r\n\r\n        const execStream = await runtime.exec(server.command, {\r\n          cwd: projectPath,\r\n          timeout: TEST_TIMEOUT_MS / 1000,\r\n        });\r\n\r\n        stdioTransport = new MCPStdioTransport(execStream);\r\n        await stdioTransport.start();\r\n        client = await createMCPClient({ transport: stdioTransport });\r\n      } else {\r\n        log.debug(`[MCP] Testing ${logContext}`, { transport: server.transport });\r\n\r\n        const transportBase = {\r\n          url: server.url,\r\n          headers: server.headers,\r\n          ...(server.authProvider ? { authProvider: server.authProvider } : {}),\r\n        };\r\n\r\n        const tryHttp = async () =>\r\n          createMCPClient({\r\n            transport: {\r\n              type: \"http\",\r\n              ...transportBase,\r\n            },\r\n          });\r\n\r\n        const trySse = async () =>\r\n          createMCPClient({\r\n            transport: {\r\n              type: \"sse\",\r\n              ...transportBase,\r\n            },\r\n          });\r\n\r\n        if (server.transport === \"http\") {\r\n          client = await tryHttp();\r\n        } else if (server.transport === \"sse\") {\r\n          client = await trySse();\r\n        } else {\r\n          // auto\r\n          try {\r\n            client = await tryHttp();\r\n          } catch (error) {\r\n            if (!shouldAutoFallbackToSse(error)) {\r\n              throw error;\r\n            }\r\n            log.debug(`[MCP] ${logContext} auto-fallback httpâ†’sse`, {\r\n              status: extractHttpStatusCode(error),\r\n            });\r\n            client = await trySse();\r\n          }\r\n        }\r\n      }\r\n\r\n      const tools = await client.tools();\r\n      const toolNames = Object.keys(tools);\r\n\r\n      await client.close();\r\n      client = null;\r\n\r\n      if (stdioTransport) {\r\n        await stdioTransport.close();\r\n        stdioTransport = null;\r\n      }\r\n\r\n      log.info(`[MCP] ${logContext} test successful`, { toolCount: toolNames.length });\r\n      return { success: true, tools: toolNames };\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      log.warn(`[MCP] ${logContext} test failed`, { error: message });\r\n\r\n      if (client) {\r\n        try {\r\n          await client.close();\r\n        } catch {\r\n          // ignore cleanup errors\r\n        }\r\n      }\r\n\r\n      if (stdioTransport) {\r\n        try {\r\n          await stdioTransport.close();\r\n        } catch {\r\n          // ignore cleanup errors\r\n        }\r\n      }\r\n\r\n      const oauthChallenge = await extractBearerOauthChallenge({\r\n        error,\r\n        serverUrl: server.transport === \"stdio\" ? null : server.url,\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        error: message,\r\n        ...(oauthChallenge ? { oauthChallenge } : {}),\r\n      };\r\n    }\r\n  })();\r\n\r\n  return Promise.race([testPromise, timeoutPromise]);\r\n}\r\n\r\ninterface MCPServerInstance {\r\n  name: string;\r\n  /** Resolved transport actually used (auto may fall back to sse). */\r\n  resolvedTransport: ResolvedTransport;\r\n  autoFallbackUsed: boolean;\r\n  tools: Record<string, Tool>;\r\n  /** True once the underlying MCP client/transport has been closed. */\r\n  isClosed: boolean;\r\n  close: () => Promise<void>;\r\n}\r\n\r\nexport type MCPTransportMode = \"none\" | \"stdio_only\" | \"http_only\" | \"sse_only\" | \"mixed\";\r\n\r\nexport interface MCPWorkspaceStats {\r\n  enabledServerCount: number;\r\n  startedServerCount: number;\r\n  failedServerCount: number;\r\n  autoFallbackCount: number;\r\n\r\n  hasStdio: boolean;\r\n  hasHttp: boolean;\r\n  hasSse: boolean;\r\n  transportMode: MCPTransportMode;\r\n}\r\n\r\nexport interface MCPToolsForWorkspaceResult {\r\n  tools: Record<string, Tool>;\r\n  stats: MCPWorkspaceStats;\r\n}\r\ninterface WorkspaceServers {\r\n  configSignature: string;\r\n  instances: Map<string, MCPServerInstance>;\r\n  stats: MCPWorkspaceStats;\r\n  lastActivity: number;\r\n}\r\n\r\nexport interface MCPServerManagerOptions {\r\n  /** Inline stdio servers to use (merged with config file servers by default) */\r\n  inlineServers?: Record<string, string>;\r\n  /** If true, ignore config file servers and use only inline servers */\r\n  ignoreConfigFile?: boolean;\r\n}\r\n\r\nexport class MCPServerManager {\r\n  private readonly workspaceServers = new Map<string, WorkspaceServers>();\r\n  private readonly workspaceLeases = new Map<string, number>();\r\n  private readonly idleCheckInterval: ReturnType<typeof setInterval>;\r\n  private inlineServers: Record<string, string> = {};\r\n  private readonly policyService: PolicyService | null;\r\n  private mcpOauthService: McpOauthService | null = null;\r\n  private ignoreConfigFile = false;\r\n\r\n  setMcpOauthService(service: McpOauthService): void {\r\n    this.mcpOauthService = service;\r\n  }\r\n  constructor(\r\n    private readonly configService: MCPConfigService,\r\n    options?: MCPServerManagerOptions,\r\n    policyService?: PolicyService\r\n  ) {\r\n    this.policyService = policyService ?? null;\r\n    this.idleCheckInterval = setInterval(() => this.cleanupIdleServers(), IDLE_CHECK_INTERVAL_MS);\r\n    this.idleCheckInterval.unref?.();\r\n    if (options?.inlineServers) {\r\n      this.inlineServers = options.inlineServers;\r\n    }\r\n    if (options?.ignoreConfigFile) {\r\n      this.ignoreConfigFile = options.ignoreConfigFile;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop the idle cleanup interval. Call when shutting down.\r\n   */\r\n  dispose(): void {\r\n    clearInterval(this.idleCheckInterval);\r\n  }\r\n\r\n  private getLeaseCount(workspaceId: string): number {\r\n    return this.workspaceLeases.get(workspaceId) ?? 0;\r\n  }\r\n\r\n  /**\r\n   * Mark a workspace's MCP servers as actively in-use.\r\n   *\r\n   * This prevents idle cleanup from shutting down MCP clients while a stream is\r\n   * still running (which can otherwise surface as \"Attempted to send a request\r\n   * from a closed client\").\r\n   */\r\n  acquireLease(workspaceId: string): void {\r\n    const current = this.workspaceLeases.get(workspaceId) ?? 0;\r\n    this.workspaceLeases.set(workspaceId, current + 1);\r\n    this.markActivity(workspaceId);\r\n  }\r\n\r\n  /**\r\n   * Release a previously-acquired lease.\r\n   */\r\n  releaseLease(workspaceId: string): void {\r\n    const current = this.workspaceLeases.get(workspaceId) ?? 0;\r\n    if (current <= 0) {\r\n      log.debug(\"[MCP] releaseLease called without an active lease\", { workspaceId });\r\n      return;\r\n    }\r\n\r\n    if (current === 1) {\r\n      this.workspaceLeases.delete(workspaceId);\r\n      return;\r\n    }\r\n\r\n    this.workspaceLeases.set(workspaceId, current - 1);\r\n  }\r\n\r\n  private markActivity(workspaceId: string): void {\r\n    const entry = this.workspaceServers.get(workspaceId);\r\n    if (!entry) {\r\n      return;\r\n    }\r\n    entry.lastActivity = Date.now();\r\n  }\r\n\r\n  private cleanupIdleServers(): void {\r\n    const now = Date.now();\r\n    for (const [workspaceId, entry] of this.workspaceServers) {\r\n      if (entry.instances.size === 0) continue;\r\n\r\n      // Never tear down a workspace's MCP servers while a stream is running.\r\n      if (this.getLeaseCount(workspaceId) > 0) {\r\n        continue;\r\n      }\r\n\r\n      const idleMs = now - entry.lastActivity;\r\n      if (idleMs >= IDLE_TIMEOUT_MS) {\r\n        log.info(\"[MCP] Stopping idle servers\", {\r\n          workspaceId,\r\n          idleMinutes: Math.round(idleMs / 60_000),\r\n        });\r\n        void this.stopServers(workspaceId);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all servers from config (both enabled and disabled) + inline servers.\r\n   * Returns full MCPServerInfo to preserve disabled state.\r\n   */\r\n  private async getAllServers(projectPath: string): Promise<Record<string, MCPServerInfo>> {\r\n    const configServers = this.ignoreConfigFile\r\n      ? {}\r\n      : await this.configService.listServers(projectPath);\r\n    // Inline servers override config file servers (always enabled)\r\n    const inlineAsInfo: Record<string, MCPServerInfo> = {};\r\n    for (const [name, command] of Object.entries(this.inlineServers)) {\r\n      inlineAsInfo[name] = { transport: \"stdio\", command, disabled: false };\r\n    }\r\n    return { ...configServers, ...inlineAsInfo };\r\n  }\r\n\r\n  /**\r\n   * List configured MCP servers for a project (name -> command).\r\n   * Used to show server info in the system prompt.\r\n   *\r\n   * Applies both project-level disabled state and workspace-level overrides:\r\n   * - Project disabled + workspace enabled => enabled\r\n   * - Project enabled + workspace disabled => disabled\r\n   * - No workspace override => use project state\r\n   *\r\n   * @param projectPath - Project path to get servers for\r\n   * @param overrides - Optional workspace-level overrides\r\n   */\r\n  async listServers(projectPath: string, overrides?: WorkspaceMCPOverrides): Promise<MCPServerMap> {\r\n    const allServers = await this.getAllServers(projectPath);\r\n    const enabled = this.applyServerOverrides(allServers, overrides);\r\n    return this.filterServersByPolicy(enabled);\r\n  }\r\n\r\n  /**\r\n   * Filter servers based on the effective policy (e.g. disallow stdio/remote).\r\n   */\r\n  private filterServersByPolicy(servers: MCPServerMap): MCPServerMap {\r\n    if (!this.policyService?.isEnforced()) {\r\n      return servers;\r\n    }\r\n\r\n    const filtered: MCPServerMap = {};\r\n    for (const [name, info] of Object.entries(servers)) {\r\n      if (this.policyService.isMcpTransportAllowed(info.transport)) {\r\n        filtered[name] = info;\r\n      }\r\n    }\r\n\r\n    return filtered;\r\n  }\r\n\r\n  /**\r\n   * Apply workspace MCP overrides to determine final server enabled state.\r\n   *\r\n   * Logic:\r\n   * - If server is in enabledServers: enabled (overrides project disabled)\r\n   * - If server is in disabledServers: disabled (overrides project enabled)\r\n   * - Otherwise: use project-level disabled state\r\n   */\r\n  private applyServerOverrides(\r\n    servers: Record<string, MCPServerInfo>,\r\n    overrides?: WorkspaceMCPOverrides\r\n  ): MCPServerMap {\r\n    const enabledSet = new Set(overrides?.enabledServers ?? []);\r\n    const disabledSet = new Set(overrides?.disabledServers ?? []);\r\n\r\n    const result: MCPServerMap = {};\r\n    for (const [name, info] of Object.entries(servers)) {\r\n      // Workspace overrides take precedence\r\n      if (enabledSet.has(name)) {\r\n        // Explicitly enabled at workspace level (overrides project disabled)\r\n        result[name] = { ...info, disabled: false };\r\n        continue;\r\n      }\r\n\r\n      if (disabledSet.has(name)) {\r\n        // Explicitly disabled at workspace level - skip\r\n        continue;\r\n      }\r\n\r\n      if (!info.disabled) {\r\n        // Enabled at project level, no workspace override\r\n        result[name] = info;\r\n      }\r\n      // If disabled at project level with no workspace override, skip\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Apply tool allowlists to filter tools from a server.\r\n   * Project-level allowlist is applied first, then workspace-level (intersection).\r\n   *\r\n   * @param serverName - Name of the MCP server (used for allowlist lookup)\r\n   * @param tools - Record of tool name -> Tool (NOT namespaced)\r\n   * @param projectAllowlist - Optional project-level tool allowlist (from .mux/mcp.jsonc)\r\n   * @param workspaceOverrides - Optional workspace MCP overrides containing toolAllowlist\r\n   * @returns Filtered tools record\r\n   */\r\n  private applyToolAllowlist(\r\n    serverName: string,\r\n    tools: Record<string, Tool>,\r\n    projectAllowlist?: string[],\r\n    workspaceOverrides?: WorkspaceMCPOverrides\r\n  ): Record<string, Tool> {\r\n    const workspaceAllowlist = workspaceOverrides?.toolAllowlist?.[serverName];\r\n\r\n    // Determine effective allowlist:\r\n    // - If both exist: intersection (workspace restricts further)\r\n    // - If only project: use project\r\n    // - If only workspace: use workspace\r\n    // - If neither: no filtering\r\n    let effectiveAllowlist: Set<string> | null = null;\r\n\r\n    if (projectAllowlist && projectAllowlist.length > 0 && workspaceAllowlist) {\r\n      // Intersection of both allowlists\r\n      const projectSet = new Set(projectAllowlist);\r\n      effectiveAllowlist = new Set(workspaceAllowlist.filter((t) => projectSet.has(t)));\r\n    } else if (projectAllowlist && projectAllowlist.length > 0) {\r\n      effectiveAllowlist = new Set(projectAllowlist);\r\n    } else if (workspaceAllowlist) {\r\n      effectiveAllowlist = new Set(workspaceAllowlist);\r\n    }\r\n\r\n    if (!effectiveAllowlist) {\r\n      // No allowlist => return all tools\r\n      return tools;\r\n    }\r\n\r\n    // Filter to only allowed tools\r\n    const filtered: Record<string, Tool> = {};\r\n    for (const [name, tool] of Object.entries(tools)) {\r\n      if (effectiveAllowlist.has(name)) {\r\n        filtered[name] = tool;\r\n      }\r\n    }\r\n\r\n    log.debug(\"[MCP] Applied tool allowlist\", {\r\n      serverName,\r\n      projectAllowlist,\r\n      workspaceAllowlist,\r\n      effectiveCount: effectiveAllowlist.size,\r\n      originalCount: Object.keys(tools).length,\r\n      filteredCount: Object.keys(filtered).length,\r\n    });\r\n\r\n    return filtered;\r\n  }\r\n\r\n  async getToolsForWorkspace(options: {\r\n    workspaceId: string;\r\n    projectPath: string;\r\n    runtime: Runtime;\r\n    workspacePath: string;\r\n    /** Per-workspace MCP overrides (disabled servers, tool allowlists) */\r\n    overrides?: WorkspaceMCPOverrides;\r\n    /** Project secrets, used for resolving {secret: \"KEY\"} header references. */\r\n    projectSecrets?: Record<string, string>;\r\n  }): Promise<MCPToolsForWorkspaceResult> {\r\n    const { workspaceId, projectPath, runtime, workspacePath, overrides, projectSecrets } = options;\r\n\r\n    // Fetch full server info for project-level allowlists and server filtering\r\n    const fullServerInfo = await this.getAllServers(projectPath);\r\n\r\n    // Apply server-level overrides (enabled/disabled) before caching\r\n    const enabledServers = this.filterServersByPolicy(\r\n      this.applyServerOverrides(fullServerInfo, overrides)\r\n    );\r\n    const enabledEntries = Object.entries(enabledServers).sort(([a], [b]) => a.localeCompare(b));\r\n\r\n    // Signature is based on *start config* only (not tool allowlists), so changing allowlists\r\n    // does not force a server restart.\r\n    const signatureEntries: Record<string, unknown> = {};\r\n    for (const [name, info] of enabledEntries) {\r\n      if (info.transport === \"stdio\") {\r\n        signatureEntries[name] = { transport: \"stdio\", command: info.command };\r\n        continue;\r\n      }\r\n\r\n      // OAuth status affects whether we can attach authProvider during server start.\r\n      // Include this (redacted) information in the signature so we retry starting\r\n      // remote servers after a user logs in/out.\r\n      let hasOauthTokens = false;\r\n      if (this.mcpOauthService) {\r\n        try {\r\n          hasOauthTokens = await this.mcpOauthService.hasAuthTokens({\r\n            serverUrl: info.url,\r\n          });\r\n        } catch (error) {\r\n          log.debug(\"[MCP] Failed to resolve MCP OAuth status\", { name, error });\r\n        }\r\n      }\r\n\r\n      try {\r\n        const { headers } = resolveHeaders(info.headers, projectSecrets);\r\n        signatureEntries[name] = {\r\n          transport: info.transport,\r\n          url: info.url,\r\n          headers,\r\n          hasOauthTokens,\r\n        };\r\n      } catch {\r\n        // Missing secrets or invalid header config. Keep signature stable but avoid leaking details.\r\n        signatureEntries[name] = {\r\n          transport: info.transport,\r\n          url: info.url,\r\n          headers: null,\r\n          hasOauthTokens,\r\n        };\r\n      }\r\n    }\r\n\r\n    const signature = JSON.stringify(signatureEntries);\r\n\r\n    const existing = this.workspaceServers.get(workspaceId);\r\n    const leaseCount = this.getLeaseCount(workspaceId);\r\n\r\n    const hasClosedInstance =\r\n      existing && [...existing.instances.values()].some((instance) => instance.isClosed);\r\n\r\n    if (existing?.configSignature === signature && !hasClosedInstance) {\r\n      existing.lastActivity = Date.now();\r\n      log.debug(\"[MCP] Using cached servers\", {\r\n        workspaceId,\r\n        serverCount: enabledEntries.length,\r\n      });\r\n\r\n      return {\r\n        tools: this.collectTools(existing.instances, fullServerInfo, overrides),\r\n        stats: existing.stats,\r\n      };\r\n    }\r\n\r\n    // If a stream is actively running, avoid closing MCP clients out from under it.\r\n    //\r\n    // Note: AIService may fetch tools before StreamManager interrupts an existing stream,\r\n    // so closing servers here can hand out tool objects backed by a client that's about to close.\r\n    if (existing && leaseCount > 0) {\r\n      existing.lastActivity = Date.now();\r\n\r\n      if (hasClosedInstance) {\r\n        // One or more server instances died while another stream was still active.\r\n        //\r\n        // Critical: do NOT stop all servers here, or we'd close healthy clients that the\r\n        // in-flight stream may still be using.\r\n        const closedServerNames = [...existing.instances.values()]\r\n          .filter((instance) => instance.isClosed)\r\n          .map((instance) => instance.name);\r\n\r\n        log.info(\"[MCP] Restarting closed server instances while stream is active\", {\r\n          workspaceId,\r\n          closedServerNames,\r\n        });\r\n\r\n        const serversToRestart: MCPServerMap = {};\r\n        for (const serverName of closedServerNames) {\r\n          const info = enabledServers[serverName];\r\n          if (info) {\r\n            serversToRestart[serverName] = info;\r\n          }\r\n        }\r\n\r\n        // Remove closed instances first so we don't hand out tools backed by a dead client.\r\n        for (const serverName of closedServerNames) {\r\n          const instance = existing.instances.get(serverName);\r\n          if (!instance) {\r\n            continue;\r\n          }\r\n\r\n          existing.instances.delete(serverName);\r\n\r\n          try {\r\n            await instance.close();\r\n          } catch (error) {\r\n            log.debug(\"[MCP] Error closing dead instance\", { workspaceId, serverName, error });\r\n          }\r\n        }\r\n\r\n        const restartedInstances = await this.startServers(\r\n          serversToRestart,\r\n          runtime,\r\n          projectPath,\r\n          workspacePath,\r\n          projectSecrets,\r\n          () => this.markActivity(workspaceId)\r\n        );\r\n\r\n        for (const [serverName, instance] of restartedInstances) {\r\n          existing.instances.set(serverName, instance);\r\n        }\r\n      }\r\n\r\n      log.info(\"[MCP] Deferring MCP server restart while stream is active\", {\r\n        workspaceId,\r\n      });\r\n\r\n      // Even while deferring restarts, ensure new tool lists reflect the latest enabled/disabled\r\n      // server set. We cannot revoke tools already captured by an in-flight stream, but we\r\n      // can avoid exposing tools from newly-disabled servers to the next stream.\r\n      const instancesForTools = new Map(\r\n        [...existing.instances].filter(([serverName]) => enabledServers[serverName] !== undefined)\r\n      );\r\n\r\n      return {\r\n        tools: this.collectTools(instancesForTools, fullServerInfo, overrides),\r\n        stats: existing.stats,\r\n      };\r\n    }\r\n\r\n    // Config changed, instance closed, or not started yet -> restart\r\n    if (enabledEntries.length > 0) {\r\n      log.info(\"[MCP] Starting servers\", {\r\n        workspaceId,\r\n        servers: enabledEntries.map(([name]) => name),\r\n      });\r\n    }\r\n\r\n    if (existing && hasClosedInstance) {\r\n      log.info(\"[MCP] Restarting servers due to closed client\", { workspaceId });\r\n    }\r\n\r\n    await this.stopServers(workspaceId);\r\n\r\n    const instances = await this.startServers(\r\n      enabledServers,\r\n      runtime,\r\n      projectPath,\r\n      workspacePath,\r\n      projectSecrets,\r\n      () => this.markActivity(workspaceId)\r\n    );\r\n\r\n    const resolvedTransports = new Set<ResolvedTransport>();\r\n    for (const instance of instances.values()) {\r\n      resolvedTransports.add(instance.resolvedTransport);\r\n    }\r\n\r\n    const hasStdio = resolvedTransports.has(\"stdio\");\r\n    const hasHttp = resolvedTransports.has(\"http\");\r\n    const hasSse = resolvedTransports.has(\"sse\");\r\n\r\n    const transportMode: MCPTransportMode =\r\n      instances.size === 0\r\n        ? \"none\"\r\n        : resolvedTransports.size === 1 && hasStdio\r\n          ? \"stdio_only\"\r\n          : resolvedTransports.size === 1 && hasHttp\r\n            ? \"http_only\"\r\n            : resolvedTransports.size === 1 && hasSse\r\n              ? \"sse_only\"\r\n              : \"mixed\";\r\n\r\n    const stats: MCPWorkspaceStats = {\r\n      enabledServerCount: enabledEntries.length,\r\n      startedServerCount: instances.size,\r\n      failedServerCount: Math.max(0, enabledEntries.length - instances.size),\r\n      autoFallbackCount: [...instances.values()].filter((i) => i.autoFallbackUsed).length,\r\n      hasStdio,\r\n      hasHttp,\r\n      hasSse,\r\n      transportMode,\r\n    };\r\n\r\n    this.workspaceServers.set(workspaceId, {\r\n      configSignature: signature,\r\n      instances,\r\n      stats,\r\n      lastActivity: Date.now(),\r\n    });\r\n\r\n    return {\r\n      tools: this.collectTools(instances, fullServerInfo, overrides),\r\n      stats,\r\n    };\r\n  }\r\n\r\n  async stopServers(workspaceId: string): Promise<void> {\r\n    const entry = this.workspaceServers.get(workspaceId);\r\n    if (!entry) return;\r\n\r\n    // Remove from cache immediately so callers can't re-use tools backed by a\r\n    // client that is in the middle of closing.\r\n    this.workspaceServers.delete(workspaceId);\r\n\r\n    for (const instance of entry.instances.values()) {\r\n      try {\r\n        await instance.close();\r\n      } catch (error) {\r\n        log.warn(\"Failed to stop MCP server\", { error, name: instance.name });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test an MCP server.\r\n   *\r\n   * Provide either:\r\n   * - `name` to test a configured server by looking up its config, OR\r\n   * - `command` to test an arbitrary stdio command, OR\r\n   * - `url`+`transport` to test an arbitrary HTTP/SSE endpoint.\r\n   */\r\n  async test(options: {\r\n    projectPath: string;\r\n    name?: string;\r\n    command?: string;\r\n    transport?: MCPServerTransport;\r\n    url?: string;\r\n    headers?: Record<string, MCPHeaderValue>;\r\n    projectSecrets?: Record<string, string>;\r\n  }): Promise<MCPTestResult> {\r\n    const isTransportAllowed = (t: MCPServerTransport): boolean => {\r\n      return !this.policyService?.isEnforced() || this.policyService.isMcpTransportAllowed(t);\r\n    };\r\n    const { projectPath, name, command, transport, url, headers, projectSecrets } = options;\r\n    const trimmedName = name?.trim();\r\n\r\n    if (trimmedName && !command?.trim() && !url?.trim()) {\r\n      const servers = await this.configService.listServers(projectPath);\r\n      const server = servers[trimmedName];\r\n      if (!server) {\r\n        return { success: false, error: `Server \"${trimmedName}\" not found in configuration` };\r\n      }\r\n\r\n      if (!isTransportAllowed(server.transport)) {\r\n        return { success: false, error: \"MCP transport is disabled by policy\" };\r\n      }\r\n\r\n      if (server.transport === \"stdio\") {\r\n        return runServerTest(\r\n          { transport: \"stdio\", command: server.command },\r\n          projectPath,\r\n          `server \"${trimmedName}\"`\r\n        );\r\n      }\r\n\r\n      try {\r\n        const resolved = resolveHeaders(server.headers, projectSecrets);\r\n\r\n        const authProvider = await this.mcpOauthService?.getAuthProviderForServer({\r\n          serverName: trimmedName,\r\n          serverUrl: server.url,\r\n        });\r\n\r\n        return runServerTest(\r\n          {\r\n            transport: server.transport,\r\n            url: server.url,\r\n            headers: resolved.headers,\r\n            ...(authProvider ? { authProvider } : {}),\r\n          },\r\n          projectPath,\r\n          `server \"${trimmedName}\"`\r\n        );\r\n      } catch (error) {\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        return { success: false, error: message };\r\n      }\r\n    }\r\n\r\n    if (command?.trim()) {\r\n      if (!isTransportAllowed(\"stdio\")) {\r\n        return { success: false, error: \"MCP transport is disabled by policy\" };\r\n      }\r\n      return runServerTest({ transport: \"stdio\", command }, projectPath, \"command\");\r\n    }\r\n\r\n    if (url?.trim()) {\r\n      const serverUrl = url.trim();\r\n\r\n      if (transport !== \"http\" && transport !== \"sse\" && transport !== \"auto\") {\r\n        return { success: false, error: \"transport must be http|sse|auto when testing by url\" };\r\n      }\r\n\r\n      if (!isTransportAllowed(transport)) {\r\n        return { success: false, error: \"MCP transport is disabled by policy\" };\r\n      }\r\n\r\n      try {\r\n        const resolved = resolveHeaders(headers, projectSecrets);\r\n\r\n        const authProvider = trimmedName\r\n          ? await this.mcpOauthService?.getAuthProviderForServer({\r\n              serverName: trimmedName,\r\n              serverUrl,\r\n            })\r\n          : undefined;\r\n        return runServerTest(\r\n          {\r\n            transport,\r\n            url: serverUrl,\r\n            headers: resolved.headers,\r\n            ...(authProvider ? { authProvider } : {}),\r\n          },\r\n          projectPath,\r\n          trimmedName ? `server \"${trimmedName}\" (url)` : \"url\"\r\n        );\r\n      } catch (error) {\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        return { success: false, error: message };\r\n      }\r\n    }\r\n\r\n    return { success: false, error: \"Either name, command, or url is required\" };\r\n  }\r\n\r\n  /**\r\n   * Collect tools from all server instances, applying tool allowlists.\r\n   *\r\n   * @param instances - Map of server instances\r\n   * @param serverInfo - Project-level server info (for project-level tool allowlists)\r\n   * @param workspaceOverrides - Optional workspace MCP overrides for tool allowlists\r\n   * @returns Aggregated tools record with provider-safe namespaced names\r\n   */\r\n  private collectTools(\r\n    instances: Map<string, MCPServerInstance>,\r\n    serverInfo: Record<string, MCPServerInfo>,\r\n    workspaceOverrides?: WorkspaceMCPOverrides\r\n  ): Record<string, Tool> {\r\n    const aggregated: Record<string, Tool> = {};\r\n    const usedNames = new Set<string>();\r\n\r\n    // Sort for determinism so collision handling yields stable tool keys.\r\n    const sortedInstances = [...instances.values()].sort((a, b) => a.name.localeCompare(b.name));\r\n\r\n    for (const instance of sortedInstances) {\r\n      // Get project-level allowlist for this server\r\n      const projectAllowlist = serverInfo[instance.name]?.toolAllowlist;\r\n      // Apply tool allowlist filtering (project-level + workspace-level)\r\n      const filteredTools = this.applyToolAllowlist(\r\n        instance.name,\r\n        instance.tools,\r\n        projectAllowlist,\r\n        workspaceOverrides\r\n      );\r\n\r\n      const sortedTools = Object.entries(filteredTools).sort(([a], [b]) => a.localeCompare(b));\r\n\r\n      for (const [toolName, tool] of sortedTools) {\r\n        const originalName = `${instance.name}_${toolName}`;\r\n\r\n        // Namespace tools with server name to prevent collisions.\r\n        //\r\n        // Important: provider SDKs can validate tool names strictly (regex + 64-char max).\r\n        // User-configured MCP server names may contain spaces or other invalid characters,\r\n        // so we normalize keys here instead of forcing a config migration.\r\n        const result = buildMcpToolName({\r\n          serverName: instance.name,\r\n          toolName,\r\n          usedNames,\r\n        });\r\n\r\n        if (!result) {\r\n          log.error(\"[MCP] Failed to build provider-safe tool name\", {\r\n            serverName: instance.name,\r\n            toolName,\r\n          });\r\n          continue;\r\n        }\r\n\r\n        if (result.wasSuffixed) {\r\n          log.warn(\"[MCP] Normalized MCP tool name required hash suffix\", {\r\n            serverName: instance.name,\r\n            toolName,\r\n            originalName,\r\n            normalizedName: result.toolName,\r\n            baseName: result.baseName,\r\n          });\r\n        } else if (result.toolName !== originalName) {\r\n          log.debug(\"[MCP] Normalized MCP tool name\", {\r\n            serverName: instance.name,\r\n            toolName,\r\n            originalName,\r\n            normalizedName: result.toolName,\r\n          });\r\n        }\r\n\r\n        aggregated[result.toolName] = tool;\r\n      }\r\n    }\r\n\r\n    return aggregated;\r\n  }\r\n\r\n  private async startServers(\r\n    servers: MCPServerMap,\r\n    runtime: Runtime,\r\n    projectPath: string,\r\n    workspacePath: string,\r\n    projectSecrets: Record<string, string> | undefined,\r\n    onActivity: () => void\r\n  ): Promise<Map<string, MCPServerInstance>> {\r\n    const result = new Map<string, MCPServerInstance>();\r\n    const entries = Object.entries(servers);\r\n\r\n    for (const [name, info] of entries) {\r\n      try {\r\n        const instance = await this.startSingleServer(\r\n          name,\r\n          info,\r\n          runtime,\r\n          projectPath,\r\n          workspacePath,\r\n          projectSecrets,\r\n          onActivity\r\n        );\r\n        if (instance) {\r\n          result.set(name, instance);\r\n        }\r\n      } catch (error) {\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        log.error(\"Failed to start MCP server\", { name, error: message });\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private async startSingleServer(\r\n    name: string,\r\n    info: MCPServerInfo,\r\n    runtime: Runtime,\r\n    _projectPath: string,\r\n    workspacePath: string,\r\n    projectSecrets: Record<string, string> | undefined,\r\n    onActivity: () => void\r\n  ): Promise<MCPServerInstance | null> {\r\n    if (info.transport === \"stdio\") {\r\n      log.debug(\"[MCP] Spawning stdio server\", { name });\r\n      const execStream = await runtime.exec(info.command, {\r\n        cwd: workspacePath,\r\n        timeout: 60 * 60 * 24, // 24 hours\r\n      });\r\n\r\n      const transport = new MCPStdioTransport(execStream);\r\n\r\n      const instanceRef: { current: MCPServerInstance | null } = { current: null };\r\n      let transportClosed = false;\r\n      const markClosed = () => {\r\n        if (transportClosed) {\r\n          return;\r\n        }\r\n        transportClosed = true;\r\n        if (instanceRef.current) {\r\n          instanceRef.current.isClosed = true;\r\n        }\r\n      };\r\n\r\n      transport.onclose = markClosed;\r\n\r\n      transport.onerror = (error) => {\r\n        log.error(\"[MCP] Transport error\", { name, error });\r\n      };\r\n\r\n      await transport.start();\r\n      const client = await createMCPClient({ transport });\r\n      const rawTools = await client.tools();\r\n      const tools = wrapMCPTools(rawTools as unknown as Record<string, Tool>, onActivity);\r\n\r\n      log.info(\"[MCP] Server ready\", {\r\n        name,\r\n        transport: \"stdio\",\r\n        toolCount: Object.keys(tools).length,\r\n      });\r\n\r\n      const instance: MCPServerInstance = {\r\n        name,\r\n        resolvedTransport: \"stdio\",\r\n        autoFallbackUsed: false,\r\n        tools,\r\n        isClosed: transportClosed,\r\n        close: async () => {\r\n          // Mark closed first to prevent any new tool calls from being treated as\r\n          // valid by higher-level caching logic.\r\n          markClosed();\r\n\r\n          try {\r\n            await client.close();\r\n          } catch (error) {\r\n            log.debug(\"[MCP] Error closing client\", { name, error });\r\n          }\r\n          try {\r\n            await transport.close();\r\n          } catch (error) {\r\n            log.debug(\"[MCP] Error closing transport\", { name, error });\r\n          }\r\n        },\r\n      };\r\n\r\n      instanceRef.current = instance;\r\n      return instance;\r\n    }\r\n\r\n    const { headers } = resolveHeaders(info.headers, projectSecrets);\r\n\r\n    // Only attach authProvider when we have stored OAuth tokens for this server.\r\n    // Passing an authProvider with no tokens can trigger user-interactive auth flows\r\n    // on background MCP calls (undesirable).\r\n    const authProvider = await this.mcpOauthService?.getAuthProviderForServer({\r\n      serverName: name,\r\n      serverUrl: info.url,\r\n    });\r\n\r\n    const transportBase = {\r\n      url: info.url,\r\n      headers,\r\n      ...(authProvider ? { authProvider } : {}),\r\n    };\r\n\r\n    const tryHttp = async () =>\r\n      createMCPClient({\r\n        transport: {\r\n          type: \"http\",\r\n          ...transportBase,\r\n        },\r\n      });\r\n\r\n    const trySse = async () =>\r\n      createMCPClient({\r\n        transport: {\r\n          type: \"sse\",\r\n          ...transportBase,\r\n        },\r\n      });\r\n\r\n    let client: Awaited<ReturnType<typeof createMCPClient>>;\r\n    let resolvedTransport: ResolvedTransport;\r\n    let autoFallbackUsed = false;\r\n\r\n    if (info.transport === \"http\") {\r\n      resolvedTransport = \"http\";\r\n      client = await tryHttp();\r\n    } else if (info.transport === \"sse\") {\r\n      resolvedTransport = \"sse\";\r\n      client = await trySse();\r\n    } else {\r\n      // auto\r\n      try {\r\n        resolvedTransport = \"http\";\r\n        client = await tryHttp();\r\n      } catch (error) {\r\n        if (!shouldAutoFallbackToSse(error)) {\r\n          throw error;\r\n        }\r\n        autoFallbackUsed = true;\r\n        resolvedTransport = \"sse\";\r\n        log.debug(\"[MCP] Auto-fallback httpâ†’sse\", { name, status: extractHttpStatusCode(error) });\r\n        client = await trySse();\r\n      }\r\n    }\r\n\r\n    let clientClosed = false;\r\n\r\n    const rawTools = await client.tools();\r\n    const tools = wrapMCPTools(rawTools as unknown as Record<string, Tool>, onActivity);\r\n\r\n    log.info(\"[MCP] Server ready\", {\r\n      name,\r\n      transport: resolvedTransport,\r\n      toolCount: Object.keys(tools).length,\r\n      autoFallbackUsed,\r\n    });\r\n\r\n    const instance: MCPServerInstance = {\r\n      name,\r\n      resolvedTransport,\r\n      autoFallbackUsed,\r\n      tools,\r\n      isClosed: clientClosed,\r\n      close: async () => {\r\n        // Mark closed first to prevent any new tool calls from being treated as\r\n        // valid by higher-level caching logic.\r\n        if (!clientClosed) {\r\n          clientClosed = true;\r\n          instance.isClosed = true;\r\n        }\r\n\r\n        try {\r\n          await client.close();\r\n        } catch (error) {\r\n          log.debug(\"[MCP] Error closing client\", { name, error });\r\n        }\r\n      },\r\n    };\r\n\r\n    return instance;\r\n  }\r\n}\r\n"]}