{"version":3,"file":"mcpServerManager.js","sourceRoot":"","sources":["../../../src/node/services/mcpServerManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { createMCPClient, type OAuthClientProvider } from \"@ai-sdk/mcp\";\nimport type { Tool } from \"ai\";\nimport { log } from \"@/node/services/log\";\nimport { MCPStdioTransport } from \"@/node/services/mcpStdioTransport\";\nimport type {\n  BearerChallenge,\n  MCPHeaderValue,\n  MCPServerInfo,\n  MCPServerMap,\n  MCPServerTransport,\n  MCPTestResult,\n  WorkspaceMCPOverrides,\n} from \"@/common/types/mcp\";\nimport type { Runtime } from \"@/node/runtime/Runtime\";\nimport type { PolicyService } from \"@/node/services/policyService\";\nimport type { MCPConfigService } from \"@/node/services/mcpConfigService\";\nimport { parseBearerWwwAuthenticate, type McpOauthService } from \"@/node/services/mcpOauthService\";\nimport { createRuntime } from \"@/node/runtime/runtimeFactory\";\nimport { transformMCPResult, type MCPCallToolResult } from \"@/node/services/mcpResultTransform\";\nimport { buildMcpToolName } from \"@/common/utils/tools/mcpToolName\";\n\nconst TEST_TIMEOUT_MS = 10_000;\nconst IDLE_TIMEOUT_MS = 10 * 60 * 1000; // 10 minutes\nconst IDLE_CHECK_INTERVAL_MS = 60 * 1000; // Check every minute\n\n/**\n * Wrap MCP tools to transform their results to AI SDK format.\n * This ensures image content is properly converted to media type.\n */\nfunction wrapMCPTools(tools: Record<string, Tool>, onActivity?: () => void): Record<string, Tool> {\n  const wrapped: Record<string, Tool> = {};\n  for (const [name, tool] of Object.entries(tools)) {\n    // Only wrap tools that have an execute function\n    if (!tool.execute) {\n      wrapped[name] = tool;\n      continue;\n    }\n\n    const originalExecute = tool.execute;\n    wrapped[name] = {\n      ...tool,\n      execute: async (args: Parameters<typeof originalExecute>[0], options) => {\n        // Mark the MCP server set as active *before* execution, so failed tool\n        // calls (including closed-client races) still count as activity.\n        onActivity?.();\n\n        const result: unknown = await originalExecute(args, options);\n        return transformMCPResult(result as MCPCallToolResult);\n      },\n    };\n  }\n  return wrapped;\n}\n\ntype ResolvedHeaders = Record<string, string> | undefined;\n\ntype ResolvedTransport = \"stdio\" | \"http\" | \"sse\";\n\nfunction resolveHeaders(\n  headers: Record<string, MCPHeaderValue> | undefined,\n  projectSecrets: Record<string, string> | undefined\n): { headers: ResolvedHeaders; usesSecretHeaders: boolean } {\n  if (!headers) {\n    return { headers: undefined, usesSecretHeaders: false };\n  }\n\n  const resolved: Record<string, string> = {};\n  let usesSecretHeaders = false;\n\n  for (const [key, value] of Object.entries(headers)) {\n    if (typeof value === \"string\") {\n      resolved[key] = value;\n      continue;\n    }\n\n    usesSecretHeaders = true;\n    const secretKey = value.secret;\n    const secretValue = projectSecrets?.[secretKey];\n    if (typeof secretValue !== \"string\") {\n      throw new Error(`Missing project secret: ${secretKey}`);\n    }\n    resolved[key] = secretValue;\n  }\n\n  return { headers: resolved, usesSecretHeaders };\n}\n\nfunction extractHttpStatusCode(error: unknown): number | null {\n  if (!error || typeof error !== \"object\") {\n    return null;\n  }\n\n  const obj = error as Record<string, unknown>;\n\n  // A few common shapes across fetch libraries / AI SDK.\n  const statusCode = obj.statusCode;\n  if (typeof statusCode === \"number\") {\n    return statusCode;\n  }\n\n  const status = obj.status;\n  if (typeof status === \"number\") {\n    return status;\n  }\n\n  const response = obj.response;\n  if (response && typeof response === \"object\") {\n    const responseStatus = (response as Record<string, unknown>).status;\n    if (typeof responseStatus === \"number\") {\n      return responseStatus;\n    }\n  }\n\n  const cause = obj.cause;\n  if (cause && typeof cause === \"object\") {\n    const causeStatus = (cause as Record<string, unknown>).statusCode;\n    if (typeof causeStatus === \"number\") {\n      return causeStatus;\n    }\n  }\n\n  // Best-effort fallback on message contents.\n  const message = obj.message;\n  if (typeof message === \"string\") {\n    const re = /\\b(400|401|403|404|405)\\b/;\n    const match = re.exec(message);\n    if (match) {\n      return Number(match[1]);\n    }\n  }\n\n  return null;\n}\n\nfunction shouldAutoFallbackToSse(error: unknown): boolean {\n  const status = extractHttpStatusCode(error);\n  return status === 400 || status === 404 || status === 405;\n}\n\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\n  return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\n\nfunction hasHeaderGetter(value: unknown): value is { get: (name: string) => unknown } {\n  return (\n    value !== null &&\n    typeof value === \"object\" &&\n    \"get\" in value &&\n    typeof (value as { get: unknown }).get === \"function\"\n  );\n}\n\nfunction extractHeaderValue(headers: unknown, name: string): string | null {\n  if (!headers) {\n    return null;\n  }\n\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers) {\n    return headers.get(name);\n  }\n\n  if (hasHeaderGetter(headers)) {\n    const value = headers.get(name);\n    return typeof value === \"string\" ? value : null;\n  }\n\n  if (isPlainObject(headers)) {\n    const target = name.toLowerCase();\n    for (const [key, value] of Object.entries(headers)) {\n      if (key.toLowerCase() !== target) {\n        continue;\n      }\n\n      if (typeof value === \"string\") {\n        return value;\n      }\n\n      if (Array.isArray(value) && value.every((v) => typeof v === \"string\")) {\n        return value.join(\", \");\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction extractWwwAuthenticateHeader(error: unknown): string | null {\n  if (!isPlainObject(error)) {\n    return null;\n  }\n\n  const direct =\n    extractHeaderValue(error.responseHeaders, \"www-authenticate\") ??\n    extractHeaderValue(error.headers, \"www-authenticate\");\n\n  if (direct) {\n    return direct;\n  }\n\n  const response = error.response;\n  if (isPlainObject(response)) {\n    const fromResponse = extractHeaderValue(response.headers, \"www-authenticate\");\n    if (fromResponse) {\n      return fromResponse;\n    }\n  }\n\n  const data = error.data;\n  if (isPlainObject(data)) {\n    const fromData =\n      extractHeaderValue(data.responseHeaders, \"www-authenticate\") ??\n      extractHeaderValue(data.headers, \"www-authenticate\");\n\n    if (fromData) {\n      return fromData;\n    }\n  }\n\n  const cause = error.cause;\n  if (cause) {\n    return extractWwwAuthenticateHeader(cause);\n  }\n\n  return null;\n}\n\nasync function probeWwwAuthenticateHeader(url: string): Promise<string | null> {\n  const abortController = new AbortController();\n  const timeout = setTimeout(() => abortController.abort(), 3_000);\n\n  try {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: {\n        Accept: \"text/event-stream\",\n      },\n      redirect: \"manual\",\n      signal: abortController.signal,\n    });\n\n    return response.headers.get(\"www-authenticate\");\n  } catch {\n    return null;\n  } finally {\n    clearTimeout(timeout);\n  }\n}\n\nasync function extractBearerOauthChallenge(options: {\n  error: unknown;\n  serverUrl: string | null;\n}): Promise<BearerChallenge | null> {\n  const status = extractHttpStatusCode(options.error);\n  if (status !== 401 && status !== 403) {\n    return null;\n  }\n\n  let header = extractWwwAuthenticateHeader(options.error);\n  if (!header && options.serverUrl) {\n    header = await probeWwwAuthenticateHeader(options.serverUrl);\n  }\n\n  if (!header) {\n    return null;\n  }\n\n  const challenge = parseBearerWwwAuthenticate(header);\n  if (!challenge) {\n    return null;\n  }\n\n  return {\n    scope: challenge.scope,\n    resourceMetadataUrl: challenge.resourceMetadataUrl?.toString(),\n  };\n}\n\nexport type { MCPTestResult } from \"@/common/types/mcp\";\n\n/**\n * Run a test connection to an MCP server.\n * Connects, fetches tools, then closes.\n */\nasync function runServerTest(\n  server:\n    | { transport: \"stdio\"; command: string }\n    | {\n        transport: \"http\" | \"sse\" | \"auto\";\n        url: string;\n        headers?: ResolvedHeaders;\n        authProvider?: OAuthClientProvider;\n      },\n  projectPath: string,\n  logContext: string\n): Promise<MCPTestResult> {\n  const timeoutPromise = new Promise<MCPTestResult>((resolve) =>\n    setTimeout(() => resolve({ success: false, error: \"Connection timed out\" }), TEST_TIMEOUT_MS)\n  );\n\n  const testPromise = (async (): Promise<MCPTestResult> => {\n    let stdioTransport: MCPStdioTransport | null = null;\n    let client: Awaited<ReturnType<typeof createMCPClient>> | null = null;\n\n    try {\n      if (server.transport === \"stdio\") {\n        const runtime = createRuntime({ type: \"local\", srcBaseDir: projectPath });\n        log.debug(`[MCP] Testing ${logContext}`, { transport: \"stdio\" });\n\n        const execStream = await runtime.exec(server.command, {\n          cwd: projectPath,\n          timeout: TEST_TIMEOUT_MS / 1000,\n        });\n\n        stdioTransport = new MCPStdioTransport(execStream);\n        await stdioTransport.start();\n        client = await createMCPClient({ transport: stdioTransport });\n      } else {\n        log.debug(`[MCP] Testing ${logContext}`, { transport: server.transport });\n\n        const transportBase = {\n          url: server.url,\n          headers: server.headers,\n          ...(server.authProvider ? { authProvider: server.authProvider } : {}),\n        };\n\n        const tryHttp = async () =>\n          createMCPClient({\n            transport: {\n              type: \"http\",\n              ...transportBase,\n            },\n          });\n\n        const trySse = async () =>\n          createMCPClient({\n            transport: {\n              type: \"sse\",\n              ...transportBase,\n            },\n          });\n\n        if (server.transport === \"http\") {\n          client = await tryHttp();\n        } else if (server.transport === \"sse\") {\n          client = await trySse();\n        } else {\n          // auto\n          try {\n            client = await tryHttp();\n          } catch (error) {\n            if (!shouldAutoFallbackToSse(error)) {\n              throw error;\n            }\n            log.debug(`[MCP] ${logContext} auto-fallback httpâ†’sse`, {\n              status: extractHttpStatusCode(error),\n            });\n            client = await trySse();\n          }\n        }\n      }\n\n      const tools = await client.tools();\n      const toolNames = Object.keys(tools);\n\n      await client.close();\n      client = null;\n\n      if (stdioTransport) {\n        await stdioTransport.close();\n        stdioTransport = null;\n      }\n\n      log.info(`[MCP] ${logContext} test successful`, { toolCount: toolNames.length });\n      return { success: true, tools: toolNames };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      log.warn(`[MCP] ${logContext} test failed`, { error: message });\n\n      if (client) {\n        try {\n          await client.close();\n        } catch {\n          // ignore cleanup errors\n        }\n      }\n\n      if (stdioTransport) {\n        try {\n          await stdioTransport.close();\n        } catch {\n          // ignore cleanup errors\n        }\n      }\n\n      const oauthChallenge = await extractBearerOauthChallenge({\n        error,\n        serverUrl: server.transport === \"stdio\" ? null : server.url,\n      });\n\n      return {\n        success: false,\n        error: message,\n        ...(oauthChallenge ? { oauthChallenge } : {}),\n      };\n    }\n  })();\n\n  return Promise.race([testPromise, timeoutPromise]);\n}\n\ninterface MCPServerInstance {\n  name: string;\n  /** Resolved transport actually used (auto may fall back to sse). */\n  resolvedTransport: ResolvedTransport;\n  autoFallbackUsed: boolean;\n  tools: Record<string, Tool>;\n  /** True once the underlying MCP client/transport has been closed. */\n  isClosed: boolean;\n  close: () => Promise<void>;\n}\n\nexport type MCPTransportMode = \"none\" | \"stdio_only\" | \"http_only\" | \"sse_only\" | \"mixed\";\n\nexport interface MCPWorkspaceStats {\n  enabledServerCount: number;\n  startedServerCount: number;\n  failedServerCount: number;\n  autoFallbackCount: number;\n\n  hasStdio: boolean;\n  hasHttp: boolean;\n  hasSse: boolean;\n  transportMode: MCPTransportMode;\n}\n\nexport interface MCPToolsForWorkspaceResult {\n  tools: Record<string, Tool>;\n  stats: MCPWorkspaceStats;\n}\ninterface WorkspaceServers {\n  configSignature: string;\n  instances: Map<string, MCPServerInstance>;\n  stats: MCPWorkspaceStats;\n  lastActivity: number;\n}\n\nexport interface MCPServerManagerOptions {\n  /** Inline stdio servers to use (merged with config file servers by default) */\n  inlineServers?: Record<string, string>;\n  /** If true, ignore config file servers and use only inline servers */\n  ignoreConfigFile?: boolean;\n}\n\nexport class MCPServerManager {\n  private readonly workspaceServers = new Map<string, WorkspaceServers>();\n  private readonly workspaceLeases = new Map<string, number>();\n  private readonly idleCheckInterval: ReturnType<typeof setInterval>;\n  private inlineServers: Record<string, string> = {};\n  private readonly policyService: PolicyService | null;\n  private mcpOauthService: McpOauthService | null = null;\n  private ignoreConfigFile = false;\n\n  setMcpOauthService(service: McpOauthService): void {\n    this.mcpOauthService = service;\n  }\n  constructor(\n    private readonly configService: MCPConfigService,\n    options?: MCPServerManagerOptions,\n    policyService?: PolicyService\n  ) {\n    this.policyService = policyService ?? null;\n    this.idleCheckInterval = setInterval(() => this.cleanupIdleServers(), IDLE_CHECK_INTERVAL_MS);\n    this.idleCheckInterval.unref?.();\n    if (options?.inlineServers) {\n      this.inlineServers = options.inlineServers;\n    }\n    if (options?.ignoreConfigFile) {\n      this.ignoreConfigFile = options.ignoreConfigFile;\n    }\n  }\n\n  /**\n   * Stop the idle cleanup interval. Call when shutting down.\n   */\n  dispose(): void {\n    clearInterval(this.idleCheckInterval);\n  }\n\n  private getLeaseCount(workspaceId: string): number {\n    return this.workspaceLeases.get(workspaceId) ?? 0;\n  }\n\n  /**\n   * Mark a workspace's MCP servers as actively in-use.\n   *\n   * This prevents idle cleanup from shutting down MCP clients while a stream is\n   * still running (which can otherwise surface as \"Attempted to send a request\n   * from a closed client\").\n   */\n  acquireLease(workspaceId: string): void {\n    const current = this.workspaceLeases.get(workspaceId) ?? 0;\n    this.workspaceLeases.set(workspaceId, current + 1);\n    this.markActivity(workspaceId);\n  }\n\n  /**\n   * Release a previously-acquired lease.\n   */\n  releaseLease(workspaceId: string): void {\n    const current = this.workspaceLeases.get(workspaceId) ?? 0;\n    if (current <= 0) {\n      log.debug(\"[MCP] releaseLease called without an active lease\", { workspaceId });\n      return;\n    }\n\n    if (current === 1) {\n      this.workspaceLeases.delete(workspaceId);\n      return;\n    }\n\n    this.workspaceLeases.set(workspaceId, current - 1);\n  }\n\n  private markActivity(workspaceId: string): void {\n    const entry = this.workspaceServers.get(workspaceId);\n    if (!entry) {\n      return;\n    }\n    entry.lastActivity = Date.now();\n  }\n\n  private cleanupIdleServers(): void {\n    const now = Date.now();\n    for (const [workspaceId, entry] of this.workspaceServers) {\n      if (entry.instances.size === 0) continue;\n\n      // Never tear down a workspace's MCP servers while a stream is running.\n      if (this.getLeaseCount(workspaceId) > 0) {\n        continue;\n      }\n\n      const idleMs = now - entry.lastActivity;\n      if (idleMs >= IDLE_TIMEOUT_MS) {\n        log.info(\"[MCP] Stopping idle servers\", {\n          workspaceId,\n          idleMinutes: Math.round(idleMs / 60_000),\n        });\n        void this.stopServers(workspaceId);\n      }\n    }\n  }\n\n  /**\n   * Get all servers from config (both enabled and disabled) + inline servers.\n   * Returns full MCPServerInfo to preserve disabled state.\n   */\n  private async getAllServers(projectPath: string): Promise<Record<string, MCPServerInfo>> {\n    const configServers = this.ignoreConfigFile\n      ? {}\n      : await this.configService.listServers(projectPath);\n    // Inline servers override config file servers (always enabled)\n    const inlineAsInfo: Record<string, MCPServerInfo> = {};\n    for (const [name, command] of Object.entries(this.inlineServers)) {\n      inlineAsInfo[name] = { transport: \"stdio\", command, disabled: false };\n    }\n    return { ...configServers, ...inlineAsInfo };\n  }\n\n  /**\n   * List configured MCP servers for a project (name -> command).\n   * Used to show server info in the system prompt.\n   *\n   * Applies both project-level disabled state and workspace-level overrides:\n   * - Project disabled + workspace enabled => enabled\n   * - Project enabled + workspace disabled => disabled\n   * - No workspace override => use project state\n   *\n   * @param projectPath - Project path to get servers for\n   * @param overrides - Optional workspace-level overrides\n   */\n  async listServers(projectPath: string, overrides?: WorkspaceMCPOverrides): Promise<MCPServerMap> {\n    const allServers = await this.getAllServers(projectPath);\n    const enabled = this.applyServerOverrides(allServers, overrides);\n    return this.filterServersByPolicy(enabled);\n  }\n\n  /**\n   * Filter servers based on the effective policy (e.g. disallow stdio/remote).\n   */\n  private filterServersByPolicy(servers: MCPServerMap): MCPServerMap {\n    if (!this.policyService?.isEnforced()) {\n      return servers;\n    }\n\n    const filtered: MCPServerMap = {};\n    for (const [name, info] of Object.entries(servers)) {\n      if (this.policyService.isMcpTransportAllowed(info.transport)) {\n        filtered[name] = info;\n      }\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Apply workspace MCP overrides to determine final server enabled state.\n   *\n   * Logic:\n   * - If server is in enabledServers: enabled (overrides project disabled)\n   * - If server is in disabledServers: disabled (overrides project enabled)\n   * - Otherwise: use project-level disabled state\n   */\n  private applyServerOverrides(\n    servers: Record<string, MCPServerInfo>,\n    overrides?: WorkspaceMCPOverrides\n  ): MCPServerMap {\n    const enabledSet = new Set(overrides?.enabledServers ?? []);\n    const disabledSet = new Set(overrides?.disabledServers ?? []);\n\n    const result: MCPServerMap = {};\n    for (const [name, info] of Object.entries(servers)) {\n      // Workspace overrides take precedence\n      if (enabledSet.has(name)) {\n        // Explicitly enabled at workspace level (overrides project disabled)\n        result[name] = { ...info, disabled: false };\n        continue;\n      }\n\n      if (disabledSet.has(name)) {\n        // Explicitly disabled at workspace level - skip\n        continue;\n      }\n\n      if (!info.disabled) {\n        // Enabled at project level, no workspace override\n        result[name] = info;\n      }\n      // If disabled at project level with no workspace override, skip\n    }\n\n    return result;\n  }\n\n  /**\n   * Apply tool allowlists to filter tools from a server.\n   * Project-level allowlist is applied first, then workspace-level (intersection).\n   *\n   * @param serverName - Name of the MCP server (used for allowlist lookup)\n   * @param tools - Record of tool name -> Tool (NOT namespaced)\n   * @param projectAllowlist - Optional project-level tool allowlist (from .mux/mcp.jsonc)\n   * @param workspaceOverrides - Optional workspace MCP overrides containing toolAllowlist\n   * @returns Filtered tools record\n   */\n  private applyToolAllowlist(\n    serverName: string,\n    tools: Record<string, Tool>,\n    projectAllowlist?: string[],\n    workspaceOverrides?: WorkspaceMCPOverrides\n  ): Record<string, Tool> {\n    const workspaceAllowlist = workspaceOverrides?.toolAllowlist?.[serverName];\n\n    // Determine effective allowlist:\n    // - If both exist: intersection (workspace restricts further)\n    // - If only project: use project\n    // - If only workspace: use workspace\n    // - If neither: no filtering\n    let effectiveAllowlist: Set<string> | null = null;\n\n    if (projectAllowlist && projectAllowlist.length > 0 && workspaceAllowlist) {\n      // Intersection of both allowlists\n      const projectSet = new Set(projectAllowlist);\n      effectiveAllowlist = new Set(workspaceAllowlist.filter((t) => projectSet.has(t)));\n    } else if (projectAllowlist && projectAllowlist.length > 0) {\n      effectiveAllowlist = new Set(projectAllowlist);\n    } else if (workspaceAllowlist) {\n      effectiveAllowlist = new Set(workspaceAllowlist);\n    }\n\n    if (!effectiveAllowlist) {\n      // No allowlist => return all tools\n      return tools;\n    }\n\n    // Filter to only allowed tools\n    const filtered: Record<string, Tool> = {};\n    for (const [name, tool] of Object.entries(tools)) {\n      if (effectiveAllowlist.has(name)) {\n        filtered[name] = tool;\n      }\n    }\n\n    log.debug(\"[MCP] Applied tool allowlist\", {\n      serverName,\n      projectAllowlist,\n      workspaceAllowlist,\n      effectiveCount: effectiveAllowlist.size,\n      originalCount: Object.keys(tools).length,\n      filteredCount: Object.keys(filtered).length,\n    });\n\n    return filtered;\n  }\n\n  async getToolsForWorkspace(options: {\n    workspaceId: string;\n    projectPath: string;\n    runtime: Runtime;\n    workspacePath: string;\n    /** Per-workspace MCP overrides (disabled servers, tool allowlists) */\n    overrides?: WorkspaceMCPOverrides;\n    /** Project secrets, used for resolving {secret: \"KEY\"} header references. */\n    projectSecrets?: Record<string, string>;\n  }): Promise<MCPToolsForWorkspaceResult> {\n    const { workspaceId, projectPath, runtime, workspacePath, overrides, projectSecrets } = options;\n\n    // Fetch full server info for project-level allowlists and server filtering\n    const fullServerInfo = await this.getAllServers(projectPath);\n\n    // Apply server-level overrides (enabled/disabled) before caching\n    const enabledServers = this.filterServersByPolicy(\n      this.applyServerOverrides(fullServerInfo, overrides)\n    );\n    const enabledEntries = Object.entries(enabledServers).sort(([a], [b]) => a.localeCompare(b));\n\n    // Signature is based on *start config* only (not tool allowlists), so changing allowlists\n    // does not force a server restart.\n    const signatureEntries: Record<string, unknown> = {};\n    for (const [name, info] of enabledEntries) {\n      if (info.transport === \"stdio\") {\n        signatureEntries[name] = { transport: \"stdio\", command: info.command };\n        continue;\n      }\n\n      // OAuth status affects whether we can attach authProvider during server start.\n      // Include this (redacted) information in the signature so we retry starting\n      // remote servers after a user logs in/out.\n      let hasOauthTokens = false;\n      if (this.mcpOauthService) {\n        try {\n          hasOauthTokens = await this.mcpOauthService.hasAuthTokens({\n            serverUrl: info.url,\n          });\n        } catch (error) {\n          log.debug(\"[MCP] Failed to resolve MCP OAuth status\", { name, error });\n        }\n      }\n\n      try {\n        const { headers } = resolveHeaders(info.headers, projectSecrets);\n        signatureEntries[name] = {\n          transport: info.transport,\n          url: info.url,\n          headers,\n          hasOauthTokens,\n        };\n      } catch {\n        // Missing secrets or invalid header config. Keep signature stable but avoid leaking details.\n        signatureEntries[name] = {\n          transport: info.transport,\n          url: info.url,\n          headers: null,\n          hasOauthTokens,\n        };\n      }\n    }\n\n    const signature = JSON.stringify(signatureEntries);\n\n    const existing = this.workspaceServers.get(workspaceId);\n    const leaseCount = this.getLeaseCount(workspaceId);\n\n    const hasClosedInstance =\n      existing && [...existing.instances.values()].some((instance) => instance.isClosed);\n\n    if (existing?.configSignature === signature && !hasClosedInstance) {\n      existing.lastActivity = Date.now();\n      log.debug(\"[MCP] Using cached servers\", {\n        workspaceId,\n        serverCount: enabledEntries.length,\n      });\n\n      return {\n        tools: this.collectTools(existing.instances, fullServerInfo, overrides),\n        stats: existing.stats,\n      };\n    }\n\n    // If a stream is actively running, avoid closing MCP clients out from under it.\n    //\n    // Note: AIService may fetch tools before StreamManager interrupts an existing stream,\n    // so closing servers here can hand out tool objects backed by a client that's about to close.\n    if (existing && leaseCount > 0) {\n      existing.lastActivity = Date.now();\n\n      if (hasClosedInstance) {\n        // One or more server instances died while another stream was still active.\n        //\n        // Critical: do NOT stop all servers here, or we'd close healthy clients that the\n        // in-flight stream may still be using.\n        const closedServerNames = [...existing.instances.values()]\n          .filter((instance) => instance.isClosed)\n          .map((instance) => instance.name);\n\n        log.info(\"[MCP] Restarting closed server instances while stream is active\", {\n          workspaceId,\n          closedServerNames,\n        });\n\n        const serversToRestart: MCPServerMap = {};\n        for (const serverName of closedServerNames) {\n          const info = enabledServers[serverName];\n          if (info) {\n            serversToRestart[serverName] = info;\n          }\n        }\n\n        // Remove closed instances first so we don't hand out tools backed by a dead client.\n        for (const serverName of closedServerNames) {\n          const instance = existing.instances.get(serverName);\n          if (!instance) {\n            continue;\n          }\n\n          existing.instances.delete(serverName);\n\n          try {\n            await instance.close();\n          } catch (error) {\n            log.debug(\"[MCP] Error closing dead instance\", { workspaceId, serverName, error });\n          }\n        }\n\n        const restartedInstances = await this.startServers(\n          serversToRestart,\n          runtime,\n          projectPath,\n          workspacePath,\n          projectSecrets,\n          () => this.markActivity(workspaceId)\n        );\n\n        for (const [serverName, instance] of restartedInstances) {\n          existing.instances.set(serverName, instance);\n        }\n      }\n\n      log.info(\"[MCP] Deferring MCP server restart while stream is active\", {\n        workspaceId,\n      });\n\n      // Even while deferring restarts, ensure new tool lists reflect the latest enabled/disabled\n      // server set. We cannot revoke tools already captured by an in-flight stream, but we\n      // can avoid exposing tools from newly-disabled servers to the next stream.\n      const instancesForTools = new Map(\n        [...existing.instances].filter(([serverName]) => enabledServers[serverName] !== undefined)\n      );\n\n      return {\n        tools: this.collectTools(instancesForTools, fullServerInfo, overrides),\n        stats: existing.stats,\n      };\n    }\n\n    // Config changed, instance closed, or not started yet -> restart\n    if (enabledEntries.length > 0) {\n      log.info(\"[MCP] Starting servers\", {\n        workspaceId,\n        servers: enabledEntries.map(([name]) => name),\n      });\n    }\n\n    if (existing && hasClosedInstance) {\n      log.info(\"[MCP] Restarting servers due to closed client\", { workspaceId });\n    }\n\n    await this.stopServers(workspaceId);\n\n    const instances = await this.startServers(\n      enabledServers,\n      runtime,\n      projectPath,\n      workspacePath,\n      projectSecrets,\n      () => this.markActivity(workspaceId)\n    );\n\n    const resolvedTransports = new Set<ResolvedTransport>();\n    for (const instance of instances.values()) {\n      resolvedTransports.add(instance.resolvedTransport);\n    }\n\n    const hasStdio = resolvedTransports.has(\"stdio\");\n    const hasHttp = resolvedTransports.has(\"http\");\n    const hasSse = resolvedTransports.has(\"sse\");\n\n    const transportMode: MCPTransportMode =\n      instances.size === 0\n        ? \"none\"\n        : resolvedTransports.size === 1 && hasStdio\n          ? \"stdio_only\"\n          : resolvedTransports.size === 1 && hasHttp\n            ? \"http_only\"\n            : resolvedTransports.size === 1 && hasSse\n              ? \"sse_only\"\n              : \"mixed\";\n\n    const stats: MCPWorkspaceStats = {\n      enabledServerCount: enabledEntries.length,\n      startedServerCount: instances.size,\n      failedServerCount: Math.max(0, enabledEntries.length - instances.size),\n      autoFallbackCount: [...instances.values()].filter((i) => i.autoFallbackUsed).length,\n      hasStdio,\n      hasHttp,\n      hasSse,\n      transportMode,\n    };\n\n    this.workspaceServers.set(workspaceId, {\n      configSignature: signature,\n      instances,\n      stats,\n      lastActivity: Date.now(),\n    });\n\n    return {\n      tools: this.collectTools(instances, fullServerInfo, overrides),\n      stats,\n    };\n  }\n\n  async stopServers(workspaceId: string): Promise<void> {\n    const entry = this.workspaceServers.get(workspaceId);\n    if (!entry) return;\n\n    // Remove from cache immediately so callers can't re-use tools backed by a\n    // client that is in the middle of closing.\n    this.workspaceServers.delete(workspaceId);\n\n    for (const instance of entry.instances.values()) {\n      try {\n        await instance.close();\n      } catch (error) {\n        log.warn(\"Failed to stop MCP server\", { error, name: instance.name });\n      }\n    }\n  }\n\n  /**\n   * Test an MCP server.\n   *\n   * Provide either:\n   * - `name` to test a configured server by looking up its config, OR\n   * - `command` to test an arbitrary stdio command, OR\n   * - `url`+`transport` to test an arbitrary HTTP/SSE endpoint.\n   */\n  async test(options: {\n    projectPath: string;\n    name?: string;\n    command?: string;\n    transport?: MCPServerTransport;\n    url?: string;\n    headers?: Record<string, MCPHeaderValue>;\n    projectSecrets?: Record<string, string>;\n  }): Promise<MCPTestResult> {\n    const isTransportAllowed = (t: MCPServerTransport): boolean => {\n      return !this.policyService?.isEnforced() || this.policyService.isMcpTransportAllowed(t);\n    };\n    const { projectPath, name, command, transport, url, headers, projectSecrets } = options;\n    const trimmedName = name?.trim();\n\n    if (trimmedName && !command?.trim() && !url?.trim()) {\n      const servers = await this.configService.listServers(projectPath);\n      const server = servers[trimmedName];\n      if (!server) {\n        return { success: false, error: `Server \"${trimmedName}\" not found in configuration` };\n      }\n\n      if (!isTransportAllowed(server.transport)) {\n        return { success: false, error: \"MCP transport is disabled by policy\" };\n      }\n\n      if (server.transport === \"stdio\") {\n        return runServerTest(\n          { transport: \"stdio\", command: server.command },\n          projectPath,\n          `server \"${trimmedName}\"`\n        );\n      }\n\n      try {\n        const resolved = resolveHeaders(server.headers, projectSecrets);\n\n        const authProvider = await this.mcpOauthService?.getAuthProviderForServer({\n          serverName: trimmedName,\n          serverUrl: server.url,\n        });\n\n        return runServerTest(\n          {\n            transport: server.transport,\n            url: server.url,\n            headers: resolved.headers,\n            ...(authProvider ? { authProvider } : {}),\n          },\n          projectPath,\n          `server \"${trimmedName}\"`\n        );\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        return { success: false, error: message };\n      }\n    }\n\n    if (command?.trim()) {\n      if (!isTransportAllowed(\"stdio\")) {\n        return { success: false, error: \"MCP transport is disabled by policy\" };\n      }\n      return runServerTest({ transport: \"stdio\", command }, projectPath, \"command\");\n    }\n\n    if (url?.trim()) {\n      const serverUrl = url.trim();\n\n      if (transport !== \"http\" && transport !== \"sse\" && transport !== \"auto\") {\n        return { success: false, error: \"transport must be http|sse|auto when testing by url\" };\n      }\n\n      if (!isTransportAllowed(transport)) {\n        return { success: false, error: \"MCP transport is disabled by policy\" };\n      }\n\n      try {\n        const resolved = resolveHeaders(headers, projectSecrets);\n\n        const authProvider = trimmedName\n          ? await this.mcpOauthService?.getAuthProviderForServer({\n              serverName: trimmedName,\n              serverUrl,\n            })\n          : undefined;\n        return runServerTest(\n          {\n            transport,\n            url: serverUrl,\n            headers: resolved.headers,\n            ...(authProvider ? { authProvider } : {}),\n          },\n          projectPath,\n          trimmedName ? `server \"${trimmedName}\" (url)` : \"url\"\n        );\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        return { success: false, error: message };\n      }\n    }\n\n    return { success: false, error: \"Either name, command, or url is required\" };\n  }\n\n  /**\n   * Collect tools from all server instances, applying tool allowlists.\n   *\n   * @param instances - Map of server instances\n   * @param serverInfo - Project-level server info (for project-level tool allowlists)\n   * @param workspaceOverrides - Optional workspace MCP overrides for tool allowlists\n   * @returns Aggregated tools record with provider-safe namespaced names\n   */\n  private collectTools(\n    instances: Map<string, MCPServerInstance>,\n    serverInfo: Record<string, MCPServerInfo>,\n    workspaceOverrides?: WorkspaceMCPOverrides\n  ): Record<string, Tool> {\n    const aggregated: Record<string, Tool> = {};\n    const usedNames = new Set<string>();\n\n    // Sort for determinism so collision handling yields stable tool keys.\n    const sortedInstances = [...instances.values()].sort((a, b) => a.name.localeCompare(b.name));\n\n    for (const instance of sortedInstances) {\n      // Get project-level allowlist for this server\n      const projectAllowlist = serverInfo[instance.name]?.toolAllowlist;\n      // Apply tool allowlist filtering (project-level + workspace-level)\n      const filteredTools = this.applyToolAllowlist(\n        instance.name,\n        instance.tools,\n        projectAllowlist,\n        workspaceOverrides\n      );\n\n      const sortedTools = Object.entries(filteredTools).sort(([a], [b]) => a.localeCompare(b));\n\n      for (const [toolName, tool] of sortedTools) {\n        const originalName = `${instance.name}_${toolName}`;\n\n        // Namespace tools with server name to prevent collisions.\n        //\n        // Important: provider SDKs can validate tool names strictly (regex + 64-char max).\n        // User-configured MCP server names may contain spaces or other invalid characters,\n        // so we normalize keys here instead of forcing a config migration.\n        const result = buildMcpToolName({\n          serverName: instance.name,\n          toolName,\n          usedNames,\n        });\n\n        if (!result) {\n          log.error(\"[MCP] Failed to build provider-safe tool name\", {\n            serverName: instance.name,\n            toolName,\n          });\n          continue;\n        }\n\n        if (result.wasSuffixed) {\n          log.warn(\"[MCP] Normalized MCP tool name required hash suffix\", {\n            serverName: instance.name,\n            toolName,\n            originalName,\n            normalizedName: result.toolName,\n            baseName: result.baseName,\n          });\n        } else if (result.toolName !== originalName) {\n          log.debug(\"[MCP] Normalized MCP tool name\", {\n            serverName: instance.name,\n            toolName,\n            originalName,\n            normalizedName: result.toolName,\n          });\n        }\n\n        aggregated[result.toolName] = tool;\n      }\n    }\n\n    return aggregated;\n  }\n\n  private async startServers(\n    servers: MCPServerMap,\n    runtime: Runtime,\n    projectPath: string,\n    workspacePath: string,\n    projectSecrets: Record<string, string> | undefined,\n    onActivity: () => void\n  ): Promise<Map<string, MCPServerInstance>> {\n    const result = new Map<string, MCPServerInstance>();\n    const entries = Object.entries(servers);\n\n    for (const [name, info] of entries) {\n      try {\n        const instance = await this.startSingleServer(\n          name,\n          info,\n          runtime,\n          projectPath,\n          workspacePath,\n          projectSecrets,\n          onActivity\n        );\n        if (instance) {\n          result.set(name, instance);\n        }\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        log.error(\"Failed to start MCP server\", { name, error: message });\n      }\n    }\n\n    return result;\n  }\n\n  private async startSingleServer(\n    name: string,\n    info: MCPServerInfo,\n    runtime: Runtime,\n    _projectPath: string,\n    workspacePath: string,\n    projectSecrets: Record<string, string> | undefined,\n    onActivity: () => void\n  ): Promise<MCPServerInstance | null> {\n    if (info.transport === \"stdio\") {\n      log.debug(\"[MCP] Spawning stdio server\", { name });\n      const execStream = await runtime.exec(info.command, {\n        cwd: workspacePath,\n        timeout: 60 * 60 * 24, // 24 hours\n      });\n\n      const transport = new MCPStdioTransport(execStream);\n\n      const instanceRef: { current: MCPServerInstance | null } = { current: null };\n      let transportClosed = false;\n      const markClosed = () => {\n        if (transportClosed) {\n          return;\n        }\n        transportClosed = true;\n        if (instanceRef.current) {\n          instanceRef.current.isClosed = true;\n        }\n      };\n\n      transport.onclose = markClosed;\n\n      transport.onerror = (error) => {\n        log.error(\"[MCP] Transport error\", { name, error });\n      };\n\n      await transport.start();\n      const client = await createMCPClient({ transport });\n      const rawTools = await client.tools();\n      const tools = wrapMCPTools(rawTools as unknown as Record<string, Tool>, onActivity);\n\n      log.info(\"[MCP] Server ready\", {\n        name,\n        transport: \"stdio\",\n        toolCount: Object.keys(tools).length,\n      });\n\n      const instance: MCPServerInstance = {\n        name,\n        resolvedTransport: \"stdio\",\n        autoFallbackUsed: false,\n        tools,\n        isClosed: transportClosed,\n        close: async () => {\n          // Mark closed first to prevent any new tool calls from being treated as\n          // valid by higher-level caching logic.\n          markClosed();\n\n          try {\n            await client.close();\n          } catch (error) {\n            log.debug(\"[MCP] Error closing client\", { name, error });\n          }\n          try {\n            await transport.close();\n          } catch (error) {\n            log.debug(\"[MCP] Error closing transport\", { name, error });\n          }\n        },\n      };\n\n      instanceRef.current = instance;\n      return instance;\n    }\n\n    const { headers } = resolveHeaders(info.headers, projectSecrets);\n\n    // Only attach authProvider when we have stored OAuth tokens for this server.\n    // Passing an authProvider with no tokens can trigger user-interactive auth flows\n    // on background MCP calls (undesirable).\n    const authProvider = await this.mcpOauthService?.getAuthProviderForServer({\n      serverName: name,\n      serverUrl: info.url,\n    });\n\n    const transportBase = {\n      url: info.url,\n      headers,\n      ...(authProvider ? { authProvider } : {}),\n    };\n\n    const tryHttp = async () =>\n      createMCPClient({\n        transport: {\n          type: \"http\",\n          ...transportBase,\n        },\n      });\n\n    const trySse = async () =>\n      createMCPClient({\n        transport: {\n          type: \"sse\",\n          ...transportBase,\n        },\n      });\n\n    let client: Awaited<ReturnType<typeof createMCPClient>>;\n    let resolvedTransport: ResolvedTransport;\n    let autoFallbackUsed = false;\n\n    if (info.transport === \"http\") {\n      resolvedTransport = \"http\";\n      client = await tryHttp();\n    } else if (info.transport === \"sse\") {\n      resolvedTransport = \"sse\";\n      client = await trySse();\n    } else {\n      // auto\n      try {\n        resolvedTransport = \"http\";\n        client = await tryHttp();\n      } catch (error) {\n        if (!shouldAutoFallbackToSse(error)) {\n          throw error;\n        }\n        autoFallbackUsed = true;\n        resolvedTransport = \"sse\";\n        log.debug(\"[MCP] Auto-fallback httpâ†’sse\", { name, status: extractHttpStatusCode(error) });\n        client = await trySse();\n      }\n    }\n\n    let clientClosed = false;\n\n    const rawTools = await client.tools();\n    const tools = wrapMCPTools(rawTools as unknown as Record<string, Tool>, onActivity);\n\n    log.info(\"[MCP] Server ready\", {\n      name,\n      transport: resolvedTransport,\n      toolCount: Object.keys(tools).length,\n      autoFallbackUsed,\n    });\n\n    const instance: MCPServerInstance = {\n      name,\n      resolvedTransport,\n      autoFallbackUsed,\n      tools,\n      isClosed: clientClosed,\n      close: async () => {\n        // Mark closed first to prevent any new tool calls from being treated as\n        // valid by higher-level caching logic.\n        if (!clientClosed) {\n          clientClosed = true;\n          instance.isClosed = true;\n        }\n\n        try {\n          await client.close();\n        } catch (error) {\n          log.debug(\"[MCP] Error closing client\", { name, error });\n        }\n      },\n    };\n\n    return instance;\n  }\n}\n"]}