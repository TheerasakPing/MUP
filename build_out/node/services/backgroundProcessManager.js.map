{"version":3,"file":"backgroundProcessManager.js","sourceRoot":"","sources":["../../../src/node/services/backgroundProcessManager.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Runtime, BackgroundHandle } from \"@/node/runtime/Runtime\";\nimport { spawnProcess } from \"./backgroundProcessExecutor\";\nimport assert from \"@/common/utils/assert\";\nimport { getErrorMessage } from \"@/common/utils/errors\";\nimport { log } from \"./log\";\nimport { AsyncMutex } from \"@/node/utils/concurrency/asyncMutex\";\n\nconst DEFAULT_BACKGROUND_BASH_TAIL_BYTES = 64_000;\nconst MAX_BACKGROUND_BASH_TAIL_BYTES = 1_000_000;\n\nexport function computeTailStartOffset(fileSizeBytes: number, tailBytes: number): number {\n  assert(\n    Number.isFinite(fileSizeBytes) && fileSizeBytes >= 0,\n    `computeTailStartOffset expected fileSizeBytes >= 0 (got ${fileSizeBytes})`\n  );\n  assert(\n    Number.isFinite(tailBytes) && tailBytes > 0,\n    `computeTailStartOffset expected tailBytes > 0 (got ${tailBytes})`\n  );\n\n  return Math.max(0, fileSizeBytes - tailBytes);\n}\n\nimport { EventEmitter } from \"events\";\n\n/**\n * Metadata written to meta.json for bookkeeping\n */\nexport interface BackgroundProcessMeta {\n  id: string;\n  pid: number;\n  script: string;\n  startTime: number;\n  status: \"running\" | \"exited\" | \"killed\" | \"failed\";\n  exitCode?: number;\n  exitTime?: number;\n  displayName?: string;\n}\n\n/**\n * Represents a background process with file-based output.\n * All per-process state is consolidated here so cleanup is automatic when\n * the process is removed from the processes map.\n */\nexport interface BackgroundProcess {\n  id: string; // Process ID (display_name from the bash tool call)\n  pid: number; // OS process ID\n  workspaceId: string; // Owning workspace\n  outputDir: string; // Directory containing stdout.log, stderr.log, meta.json\n  script: string; // Original command\n  startTime: number; // Timestamp when started\n  exitCode?: number; // Undefined if still running\n  exitTime?: number; // Timestamp when exited (undefined if running)\n  status: \"running\" | \"exited\" | \"killed\" | \"failed\";\n  handle: BackgroundHandle; // For process interaction\n  displayName?: string; // Human-readable name (e.g., \"Dev Server\")\n  /** True if this process is being waited on (foreground mode) */\n  isForeground: boolean;\n  /** Tracks read position for incremental output retrieval */\n  outputBytesRead: number;\n  /** Mutex to serialize getOutput() calls (prevents race condition when\n   * parallel tool calls read from same offset before position is updated) */\n  outputLock: AsyncMutex;\n  /** Tracks how many times getOutput() has been called (for polling detection) */\n  getOutputCallCount: number;\n  /** Buffer for incomplete lines (no trailing newline) from previous read */\n  incompleteLineBuffer: string;\n}\n\n/**\n * Represents a foreground process that can be sent to background.\n * These are processes started via runtime.exec() (not nohup) that we track\n * so users can click \"Background\" to stop waiting for them.\n */\nexport interface ForegroundProcess {\n  /** Workspace ID */\n  workspaceId: string;\n  /** Tool call ID that started this process (for UI to match) */\n  toolCallId: string;\n  /** Script being executed */\n  script: string;\n  /** Display name for the process (used as ID if sent to background) */\n  displayName: string;\n  /** Callback to invoke when user requests backgrounding */\n  onBackground: () => void;\n  /** Current accumulated output (for saving to files on background) */\n  output: string[];\n}\n\n/**\n * Manages bash processes for workspaces.\n *\n * ALL bash commands are spawned through this manager with background-style\n * infrastructure (nohup, file output, exit code trap). This enables:\n * - Uniform code path for all bash commands\n * - Crash resilience (output always persisted to files)\n * - Seamless fg→bg transition via sendToBackground()\n *\n * Supports incremental output retrieval via getOutput().\n */\n/**\n * Event types emitted by BackgroundProcessManager.\n * The 'change' event is emitted whenever the state changes for a workspace.\n */\nexport interface BackgroundProcessManagerEvents {\n  change: [workspaceId: string];\n}\n\nexport class BackgroundProcessManager extends EventEmitter<BackgroundProcessManagerEvents> {\n  // NOTE: This map is in-memory only. Background processes use nohup/setsid so they\n  // could survive app restarts, but we kill all tracked processes on shutdown via\n  // dispose(). Rehydrating from meta.json on startup is out of scope for now.\n  // All per-process state (read position, output lock) is stored in BackgroundProcess\n  // so cleanup is automatic when the process is removed from this map.\n  private processes = new Map<string, BackgroundProcess>();\n\n  // Base directory for process output files\n  private readonly bgOutputDir: string;\n  // Tracks foreground processes (started via runtime.exec) that can be backgrounded\n  // Key is toolCallId to support multiple parallel foreground processes per workspace\n  private foregroundProcesses = new Map<string, ForegroundProcess>();\n  // Tracks workspaces with queued messages (for bash_output to return early)\n  private queuedMessageWorkspaces = new Set<string>();\n\n  constructor(bgOutputDir: string) {\n    super();\n    // Background bash status can have many concurrent subscribers (e.g. multiple workspaces).\n    // Raise the default listener cap to avoid noisy MaxListenersExceededWarning.\n    this.setMaxListeners(50);\n    this.bgOutputDir = bgOutputDir;\n  }\n\n  /**\n   * Mark whether a workspace has a queued user message.\n   * Used by bash_output to return early when user has sent a new message.\n   */\n  setMessageQueued(workspaceId: string, queued: boolean): void {\n    if (queued) {\n      this.queuedMessageWorkspaces.add(workspaceId);\n    } else {\n      this.queuedMessageWorkspaces.delete(workspaceId);\n    }\n  }\n\n  /**\n   * Check if a workspace has a queued user message.\n   */\n  hasQueuedMessage(workspaceId: string): boolean {\n    return this.queuedMessageWorkspaces.has(workspaceId);\n  }\n\n  /** Emit a change event for a workspace */\n  private emitChange(workspaceId: string): void {\n    this.emit(\"change\", workspaceId);\n  }\n\n  /**\n   * Get the base directory for background process output files.\n   */\n  getBgOutputDir(): string {\n    return this.bgOutputDir;\n  }\n\n  /**\n   * Generate a unique background process ID.\n   *\n   * Background process IDs are used as tool-visible identifiers (e.g. task_await with bash: IDs),\n   * so they must be globally unique across all running processes.\n   *\n   * If the base ID is already in use, we append \" (1)\", \" (2)\", etc.\n   */\n  generateUniqueProcessId(baseId: string): string {\n    assert(\n      typeof baseId === \"string\" && baseId.length > 0,\n      \"BackgroundProcessManager.generateUniqueProcessId requires a non-empty baseId\"\n    );\n\n    let processId = baseId;\n    let suffix = 1;\n    while (this.processes.has(processId)) {\n      processId = `${baseId} (${suffix})`;\n      suffix++;\n    }\n\n    return processId;\n  }\n\n  /**\n   * Spawn a new process with background-style infrastructure.\n   *\n   * All processes are spawned with nohup/setsid and file-based output,\n   * enabling seamless fg→bg transition via sendToBackground().\n   *\n   * @param runtime Runtime to spawn the process on\n   * @param workspaceId Workspace ID for tracking/filtering\n   * @param script Bash script to execute\n   * @param config Execution configuration\n   */\n  async spawn(\n    runtime: Runtime,\n    workspaceId: string,\n    script: string,\n    config: {\n      cwd: string;\n      env?: Record<string, string>;\n      /** Human-readable name for the process - used to generate the process ID */\n      displayName: string;\n      /** If true, process is foreground (being waited on). Default: false (background) */\n      isForeground?: boolean;\n      /** Auto-terminate after this many seconds (background processes only) */\n      timeoutSecs?: number;\n    }\n  ): Promise<\n    | { success: true; processId: string; outputDir: string; pid: number }\n    | { success: false; error: string }\n  > {\n    log.debug(`BackgroundProcessManager.spawn() called for workspace ${workspaceId}`);\n\n    const processId = this.generateUniqueProcessId(config.displayName);\n\n    // Spawn via executor with background infrastructure\n    // spawnProcess uses runtime.tempDir() internally for output directory\n    const result = await spawnProcess(runtime, script, {\n      cwd: config.cwd,\n      workspaceId,\n      processId,\n      env: config.env,\n    });\n\n    if (!result.success) {\n      log.debug(`BackgroundProcessManager: Failed to spawn: ${result.error}`);\n      return { success: false, error: result.error };\n    }\n\n    const { handle, pid, outputDir } = result;\n    const startTime = Date.now();\n\n    // Write meta.json with process info\n    const meta: BackgroundProcessMeta = {\n      id: processId,\n      pid,\n      script,\n      startTime,\n      status: \"running\",\n      displayName: config.displayName,\n    };\n    await handle.writeMeta(JSON.stringify(meta, null, 2));\n\n    const proc: BackgroundProcess = {\n      id: processId,\n      pid,\n      workspaceId,\n      outputDir,\n      script,\n      startTime,\n      status: \"running\",\n      handle,\n      displayName: config.displayName,\n      isForeground: config.isForeground ?? false,\n      outputBytesRead: 0,\n      outputLock: new AsyncMutex(),\n      getOutputCallCount: 0,\n      incompleteLineBuffer: \"\",\n    };\n\n    // Store process in map\n    this.processes.set(processId, proc);\n\n    log.debug(\n      `Process ${processId} spawned successfully with PID ${pid} (foreground: ${proc.isForeground})`\n    );\n\n    // Schedule auto-termination for background processes with timeout\n    const timeoutSecs = config.timeoutSecs;\n    if (!config.isForeground && timeoutSecs !== undefined && timeoutSecs > 0) {\n      setTimeout(() => {\n        void this.terminate(processId).then((result) => {\n          if (result.success) {\n            log.debug(`Process ${processId} auto-terminated after ${timeoutSecs}s timeout`);\n          }\n        });\n      }, timeoutSecs * 1000);\n    }\n\n    // Emit change event (only if background - foreground processes don't show in list)\n    if (!proc.isForeground) {\n      this.emitChange(workspaceId);\n    }\n\n    return { success: true, processId, outputDir, pid };\n  }\n\n  /**\n   * Register a foreground process that can be sent to background.\n   * Called by bash tool when starting foreground execution.\n   *\n   * @param workspaceId Workspace the process belongs to\n   * @param toolCallId Tool call ID (for UI to identify which bash row)\n   * @param script Script being executed\n   * @param onBackground Callback invoked when user requests backgrounding\n   * @returns Cleanup function to call when process completes\n   */\n  registerForegroundProcess(\n    workspaceId: string,\n    toolCallId: string,\n    script: string,\n    displayName: string,\n    onBackground: () => void\n  ): { unregister: () => void; addOutput: (line: string) => void } {\n    const proc: ForegroundProcess = {\n      workspaceId,\n      toolCallId,\n      script,\n      displayName,\n      onBackground,\n      output: [],\n    };\n    this.foregroundProcesses.set(toolCallId, proc);\n    log.debug(\n      `Registered foreground process for workspace ${workspaceId}, toolCallId ${toolCallId}`\n    );\n    this.emitChange(workspaceId);\n\n    return {\n      unregister: () => {\n        this.foregroundProcesses.delete(toolCallId);\n        log.debug(`Unregistered foreground process toolCallId ${toolCallId}`);\n        this.emitChange(workspaceId);\n      },\n      addOutput: (line: string) => {\n        proc.output.push(line);\n      },\n    };\n  }\n\n  /**\n   * Register a migrated foreground process as a tracked background process.\n   *\n   * Called by bash tool when migration completes, after migrateToBackground()\n   * has created the output directory and started file writing.\n   *\n   * @param handle The BackgroundHandle from migrateToBackground()\n   * @param processId The generated process ID\n   * @param workspaceId Workspace the process belongs to\n   * @param script Original script being executed\n   * @param outputDir Directory containing output files\n   * @param displayName Optional human-readable name\n   */\n  registerMigratedProcess(\n    handle: BackgroundHandle,\n    processId: string,\n    workspaceId: string,\n    script: string,\n    outputDir: string,\n    displayName?: string\n  ): void {\n    const startTime = Date.now();\n\n    const proc: BackgroundProcess = {\n      id: processId,\n      pid: 0, // Unknown for migrated processes (could be remote)\n      workspaceId,\n      outputDir,\n      script,\n      startTime,\n      status: \"running\",\n      handle,\n      displayName,\n      isForeground: false, // Now in background\n      outputBytesRead: 0,\n      outputLock: new AsyncMutex(),\n      getOutputCallCount: 0,\n      incompleteLineBuffer: \"\",\n    };\n\n    // Store process in map\n    this.processes.set(processId, proc);\n\n    // Write meta.json\n    const meta: BackgroundProcessMeta = {\n      id: processId,\n      pid: 0,\n      script,\n      startTime,\n      status: \"running\",\n      displayName,\n    };\n    void handle.writeMeta(JSON.stringify(meta, null, 2));\n\n    log.debug(`Migrated process ${processId} registered for workspace ${workspaceId}`);\n    this.emitChange(workspaceId);\n  }\n\n  /**\n   * Send a foreground process to background.\n   *\n   * For processes started with background infrastructure (isForeground=true in spawn):\n   * - Marks as background and emits 'backgrounded' event\n   *\n   * For processes started via runtime.exec (tracked via registerForegroundProcess):\n   * - Invokes the onBackground callback to trigger early return\n   *\n   * @param toolCallId The tool call ID of the bash to background\n   * @returns Success status\n   */\n  sendToBackground(toolCallId: string): { success: true } | { success: false; error: string } {\n    log.debug(`BackgroundProcessManager.sendToBackground(${toolCallId}) called`);\n\n    const fgProc = this.foregroundProcesses.get(toolCallId);\n    if (fgProc) {\n      fgProc.onBackground();\n      log.debug(`Foreground process toolCallId ${toolCallId} sent to background`);\n      return { success: true };\n    }\n\n    return { success: false, error: \"No foreground process found with that tool call ID\" };\n  }\n\n  /**\n   * Get all foreground tool call IDs for a workspace.\n   * Returns empty array if no foreground processes are running.\n   */\n  getForegroundToolCallIds(workspaceId: string): string[] {\n    const ids: string[] = [];\n    // Check exec-based foreground processes\n    for (const [toolCallId, proc] of this.foregroundProcesses) {\n      if (proc.workspaceId === workspaceId) {\n        ids.push(toolCallId);\n      }\n    }\n    return ids;\n  }\n\n  /**\n   * Write/update meta.json for a process\n   */\n  private async updateMetaFile(proc: BackgroundProcess): Promise<void> {\n    const meta: BackgroundProcessMeta = {\n      id: proc.id,\n      pid: proc.pid,\n      script: proc.script,\n      startTime: proc.startTime,\n      status: proc.status,\n      exitCode: proc.exitCode,\n      exitTime: proc.exitTime,\n    };\n    const metaJson = JSON.stringify(meta, null, 2);\n\n    await proc.handle.writeMeta(metaJson);\n  }\n\n  /**\n   * Get a background process by ID.\n   * Refreshes status if the process is still marked as running.\n   */\n  async getProcess(processId: string): Promise<BackgroundProcess | null> {\n    log.debug(`BackgroundProcessManager.getProcess(${processId}) called`);\n    const proc = this.processes.get(processId);\n    if (!proc) return null;\n\n    // Refresh status if still running (exit code null = still running)\n    if (proc.status === \"running\") {\n      const exitCode = await proc.handle.getExitCode();\n      if (exitCode !== null) {\n        log.debug(`Background process ${proc.id} has exited`);\n        proc.status = \"exited\";\n        proc.exitCode = exitCode;\n        proc.exitTime = Date.now();\n        await this.updateMetaFile(proc).catch((err: unknown) => {\n          log.debug(\n            `BackgroundProcessManager: Failed to update meta.json: ${getErrorMessage(err)}`\n          );\n        });\n        this.emitChange(proc.workspaceId);\n      }\n    }\n\n    return proc;\n  }\n\n  /**\n   * Get incremental output from a background process.\n   * Returns only NEW output since the last call (tracked per process).\n   * @param processId Process ID to get output from\n   * @param filter Optional regex pattern to filter output lines (non-matching lines are discarded permanently)\n   * @param filterExclude When true, invert filter to exclude matching lines instead of keeping them\n   * @param timeout Seconds to wait for output if none available (default 0 = non-blocking)\n   * @param abortSignal Optional signal to abort waiting early (e.g., when stream is cancelled)\n   * @param workspaceId Optional workspace ID to check for queued messages (return early to process them)\n   * @param noteToolName Optional tool name to use in polling guidance notes\n   */\n  async getOutput(\n    processId: string,\n    filter?: string,\n    filterExclude?: boolean,\n    timeout?: number,\n    abortSignal?: AbortSignal,\n    workspaceId?: string,\n    noteToolName?: string\n  ): Promise<\n    | {\n        success: true;\n        status: \"running\" | \"exited\" | \"killed\" | \"failed\" | \"interrupted\";\n        output: string;\n        exitCode?: number;\n        elapsed_ms: number;\n        note?: string;\n      }\n    | { success: false; error: string }\n  > {\n    const timeoutSecs = Math.max(timeout ?? 0, 0);\n    log.debug(\n      `BackgroundProcessManager.getOutput(${processId}, filter=${filter ?? \"none\"}, exclude=${filterExclude ?? false}, timeout=${timeoutSecs}s) called`\n    );\n\n    // Validate: filter_exclude requires filter\n    if (filterExclude && !filter) {\n      return { success: false, error: \"filter_exclude requires filter to be set\" };\n    }\n\n    const proc = await this.getProcess(processId);\n    if (!proc) {\n      return { success: false, error: `Process not found: ${processId}` };\n    }\n\n    // Acquire per-process mutex to serialize concurrent getOutput() calls.\n    // This prevents race conditions where parallel tool calls both read from\n    // the same offset before either updates the read position.\n    await using _lock = await proc.outputLock.acquire();\n\n    // Track call count for polling detection\n    proc.getOutputCallCount++;\n    const callCount = proc.getOutputCallCount;\n\n    log.debug(\n      `BackgroundProcessManager.getOutput: proc.outputDir=${proc.outputDir}, offset=${proc.outputBytesRead}, callCount=${callCount}`\n    );\n\n    // Pre-compile regex if filter is provided\n    let filterRegex: RegExp | undefined;\n    if (filter) {\n      try {\n        filterRegex = new RegExp(filter);\n      } catch (e) {\n        return { success: false, error: `Invalid filter regex: ${getErrorMessage(e)}` };\n      }\n    }\n\n    // Apply filtering to complete lines only\n    // Incomplete line fragments (no trailing newline) are kept in buffer for next read\n    const applyFilter = (lines: string[]): string => {\n      if (!filterRegex) return lines.join(\"\\n\");\n      const filtered = filterExclude\n        ? lines.filter((line) => !filterRegex.test(line))\n        : lines.filter((line) => filterRegex.test(line));\n      return filtered.join(\"\\n\");\n    };\n\n    // Blocking wait loop: poll for output up to timeout seconds\n    const startTime = Date.now();\n    const timeoutMs = timeoutSecs * 1000;\n    const pollIntervalMs = 100;\n    let accumulatedRaw = \"\";\n    let currentStatus = proc.status;\n\n    // Track the previous buffer to prepend to accumulated output\n    const previousBuffer = proc.incompleteLineBuffer;\n\n    while (true) {\n      // Read new content via the handle (works for both local and SSH runtimes)\n      // Output is already unified in output.log (stdout + stderr via 2>&1)\n      const result = await proc.handle.readOutput(proc.outputBytesRead);\n      accumulatedRaw += result.content;\n\n      // Update read position\n      proc.outputBytesRead = result.newOffset;\n\n      // Refresh process status\n      const refreshedProc = await this.getProcess(processId);\n      currentStatus = refreshedProc?.status ?? proc.status;\n\n      // Line-buffered filtering: prepend incomplete line from previous call\n      const rawWithBuffer = previousBuffer + accumulatedRaw;\n      const allLines = rawWithBuffer.split(\"\\n\");\n\n      // Last element is incomplete if content doesn't end with newline\n      const hasTrailingNewline = rawWithBuffer.endsWith(\"\\n\");\n      const completeLines = hasTrailingNewline ? allLines.slice(0, -1) : allLines.slice(0, -1);\n\n      // When using filter_exclude, check if we have meaningful (non-excluded) output.\n      // We only consider complete lines as \"meaningful\" here; fragments are buffered for the next read.\n      const filteredOutput = applyFilter(completeLines);\n      const hasMeaningfulOutput = filterExclude\n        ? filteredOutput.trim().length > 0\n        : completeLines.length > 0;\n\n      // Return immediately if:\n      // 1. We have meaningful output (after filtering if filter_exclude is set)\n      // 2. Timeout elapsed\n      // 3. Abort signal received (user sent a new message)\n      if (hasMeaningfulOutput) {\n        break;\n      }\n\n      // If the process is no longer running (exited/killed/failed), do one last read\n      // to avoid dropping output that arrives between our readOutput() call and\n      // the status refresh.\n      if (currentStatus !== \"running\") {\n        while (true) {\n          const finalRead = await proc.handle.readOutput(proc.outputBytesRead);\n          if (finalRead.content.length === 0) {\n            break;\n          }\n\n          // Defensive: avoid infinite loops if a handle returns inconsistent offsets.\n          if (finalRead.newOffset <= proc.outputBytesRead) {\n            break;\n          }\n\n          accumulatedRaw += finalRead.content;\n          proc.outputBytesRead = finalRead.newOffset;\n        }\n\n        break;\n      }\n\n      if (abortSignal?.aborted || (workspaceId && this.hasQueuedMessage(workspaceId))) {\n        const elapsed_ms = Date.now() - startTime;\n        return {\n          success: true,\n          status: \"interrupted\",\n          output: \"(waiting interrupted)\",\n          elapsed_ms,\n        };\n      }\n\n      const elapsed = Date.now() - startTime;\n      if (elapsed >= timeoutMs) {\n        break;\n      }\n\n      // Sleep before next poll\n      await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));\n    }\n\n    // Final line processing with buffer from previous call\n\n    // If the process exited, do a final drain of output.\n    //\n    // Rationale: stdout/stderr writes can land just after we observe that the process\n    // has exited. Without a final drain, we can return \"exited\" with empty output\n    // even though output becomes available moments later.\n    if (currentStatus !== \"running\") {\n      const offsetBeforeDrain = proc.outputBytesRead;\n\n      while (true) {\n        const extra = await proc.handle.readOutput(proc.outputBytesRead);\n        if (extra.content.length === 0) {\n          break;\n        }\n        accumulatedRaw += extra.content;\n        proc.outputBytesRead = extra.newOffset;\n      }\n\n      // If we didn't observe any new output, wait one poll interval and try once more.\n      if (proc.outputBytesRead === offsetBeforeDrain) {\n        await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));\n\n        while (true) {\n          const extra = await proc.handle.readOutput(proc.outputBytesRead);\n          if (extra.content.length === 0) {\n            break;\n          }\n          accumulatedRaw += extra.content;\n          proc.outputBytesRead = extra.newOffset;\n        }\n      }\n    }\n    const rawWithBuffer = previousBuffer + accumulatedRaw;\n    const allLines = rawWithBuffer.split(\"\\n\");\n    const hasTrailingNewline = rawWithBuffer.endsWith(\"\\n\");\n\n    // On process exit, include incomplete line; otherwise keep it buffered\n    const linesToReturn =\n      currentStatus !== \"running\"\n        ? allLines.filter((l) => l.length > 0) // Include all non-empty lines on exit\n        : hasTrailingNewline\n          ? allLines.slice(0, -1)\n          : allLines.slice(0, -1);\n\n    // Update buffer for next call (clear on exit, keep incomplete line otherwise)\n    proc.incompleteLineBuffer =\n      currentStatus === \"running\" && !hasTrailingNewline ? allLines[allLines.length - 1] : \"\";\n\n    log.debug(\n      `BackgroundProcessManager.getOutput: read rawLen=${accumulatedRaw.length}, completeLines=${linesToReturn.length}`\n    );\n\n    const filteredOutput = applyFilter(linesToReturn);\n\n    // Suggest filter_exclude if polling too frequently on a running process\n    const shouldSuggestFilterExclude =\n      callCount >= 3 && !filterExclude && currentStatus === \"running\";\n\n    // Suggest better pattern if using filter_exclude but still polling frequently\n    const shouldSuggestBetterPattern =\n      callCount >= 3 && filterExclude && currentStatus === \"running\";\n\n    const pollingToolName = noteToolName ?? \"bash_output\";\n\n    let note: string | undefined;\n    if (shouldSuggestFilterExclude) {\n      note =\n        `STOP POLLING. You've called ${pollingToolName} 3+ times on this process. ` +\n        \"This wastes tokens and clutters the conversation. \" +\n        \"Instead, make ONE call with: filter='⏳|progress|waiting|\\\\\\\\\\\\.\\\\\\\\\\\\.\\\\\\\\\\\\.', \" +\n        \"filter_exclude=true, timeout_secs=120. This blocks until meaningful output arrives.\";\n    } else if (shouldSuggestBetterPattern) {\n      note =\n        \"You're using filter_exclude but still polling frequently. \" +\n        \"Your filter pattern may not be matching the actual output. \" +\n        \"Try a broader pattern like: filter='\\\\\\\\.|\\\\\\\\d+%|running|progress|pending|⏳|waiting'. \" +\n        \"Wait for the FULL timeout before checking again.\";\n    }\n\n    return {\n      success: true,\n      status: currentStatus,\n      output: filteredOutput,\n      exitCode:\n        currentStatus !== \"running\"\n          ? ((await this.getProcess(processId))?.exitCode ?? undefined)\n          : undefined,\n      elapsed_ms: Date.now() - startTime,\n      note,\n    };\n  }\n\n  /**\n   * Peek output from a background process without advancing its incremental cursor.\n   *\n   * Used by the UI to display buffered output for background bashes. Unlike getOutput(),\n   * this must NOT mutate proc.outputBytesRead/proc.incompleteLineBuffer (which are used by\n   * bash_output + task_await).\n   */\n  async peekOutput(\n    processId: string,\n    options?: { fromOffset?: number; tailBytes?: number }\n  ): Promise<\n    | {\n        success: true;\n        status: \"running\" | \"exited\" | \"killed\" | \"failed\";\n        output: string;\n        nextOffset: number;\n        truncatedStart: boolean;\n      }\n    | { success: false; error: string }\n  > {\n    const fromOffset = options?.fromOffset;\n    const tailBytesRaw = options?.tailBytes;\n\n    log.debug(\n      `BackgroundProcessManager.peekOutput(${processId}, fromOffset=${fromOffset ?? \"tail\"}, tailBytes=${tailBytesRaw ?? DEFAULT_BACKGROUND_BASH_TAIL_BYTES}) called`\n    );\n\n    if (fromOffset !== undefined && (!Number.isFinite(fromOffset) || fromOffset < 0)) {\n      return { success: false, error: `Invalid fromOffset: ${fromOffset}` };\n    }\n\n    const tailBytes = tailBytesRaw ?? DEFAULT_BACKGROUND_BASH_TAIL_BYTES;\n    if (!Number.isFinite(tailBytes) || tailBytes <= 0) {\n      return { success: false, error: `Invalid tailBytes: ${String(tailBytesRaw)}` };\n    }\n    const clampedTailBytes = Math.min(tailBytes, MAX_BACKGROUND_BASH_TAIL_BYTES);\n\n    const proc = await this.getProcess(processId);\n    if (!proc) {\n      return { success: false, error: `Process not found: ${processId}` };\n    }\n\n    let offset = fromOffset;\n    let truncatedStart = false;\n\n    if (offset === undefined) {\n      const fileSizeBytes = await proc.handle.getOutputFileSize();\n      offset = computeTailStartOffset(fileSizeBytes, clampedTailBytes);\n      truncatedStart = offset > 0;\n    }\n\n    const result = await proc.handle.readOutput(offset);\n    assert(\n      result.newOffset >= offset,\n      `BackgroundHandle.readOutput returned newOffset < offset (offset=${offset}, newOffset=${result.newOffset})`\n    );\n\n    return {\n      success: true,\n      status: proc.status,\n      output: result.content,\n      nextOffset: result.newOffset,\n      truncatedStart,\n    };\n  }\n\n  /**\n   * List background processes (not including foreground ones being waited on).\n   * Optionally filtered by workspace.\n   * Refreshes status of running processes before returning.\n   */\n  async list(workspaceId?: string): Promise<BackgroundProcess[]> {\n    log.debug(`BackgroundProcessManager.list(${workspaceId ?? \"all\"}) called`);\n    await this.refreshRunningStatuses();\n    // Only return background processes (not foreground ones being waited on)\n    const backgroundProcesses = Array.from(this.processes.values()).filter((p) => !p.isForeground);\n    return workspaceId\n      ? backgroundProcesses.filter((p) => p.workspaceId === workspaceId)\n      : backgroundProcesses;\n  }\n\n  /**\n   * Check all \"running\" processes and update status if they've exited.\n   * Called lazily from list() to avoid polling overhead.\n   */\n  private async refreshRunningStatuses(): Promise<void> {\n    const runningProcesses = Array.from(this.processes.values()).filter(\n      (p) => p.status === \"running\"\n    );\n\n    for (const proc of runningProcesses) {\n      const exitCode = await proc.handle.getExitCode();\n      if (exitCode !== null) {\n        log.debug(`Background process ${proc.id} has exited`);\n        proc.status = \"exited\";\n        proc.exitCode = exitCode;\n        proc.exitTime = Date.now();\n        await this.updateMetaFile(proc).catch((err: unknown) => {\n          log.debug(\n            `BackgroundProcessManager: Failed to update meta.json: ${getErrorMessage(err)}`\n          );\n        });\n        this.emitChange(proc.workspaceId);\n      }\n    }\n  }\n\n  /**\n   * Terminate a background process\n   */\n  async terminate(\n    processId: string\n  ): Promise<{ success: true } | { success: false; error: string }> {\n    log.debug(`BackgroundProcessManager.terminate(${processId}) called`);\n\n    // Get process from Map\n    const proc = this.processes.get(processId);\n    if (!proc) {\n      return { success: false, error: `Process not found: ${processId}` };\n    }\n\n    // If already terminated, return success (idempotent)\n    if (proc.status === \"exited\" || proc.status === \"killed\" || proc.status === \"failed\") {\n      log.debug(`Process ${processId} already terminated with status: ${proc.status}`);\n      return { success: true };\n    }\n\n    try {\n      await proc.handle.terminate();\n\n      // Update process status and exit code\n      proc.status = \"killed\";\n      proc.exitCode = (await proc.handle.getExitCode()) ?? undefined;\n      proc.exitTime ??= Date.now();\n\n      // Update meta.json\n      await this.updateMetaFile(proc).catch((err: unknown) => {\n        log.debug(`BackgroundProcessManager: Failed to update meta.json: ${getErrorMessage(err)}`);\n      });\n\n      // Dispose of the handle\n      await proc.handle.dispose();\n\n      log.debug(`Process ${processId} terminated successfully`);\n      this.emitChange(proc.workspaceId);\n      return { success: true };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      log.debug(`Error terminating process ${processId}: ${errorMessage}`);\n      // Mark as killed even if there was an error (process likely already dead)\n      proc.status = \"killed\";\n      proc.exitTime ??= Date.now();\n      // Update meta.json\n      await this.updateMetaFile(proc).catch((err: unknown) => {\n        log.debug(`BackgroundProcessManager: Failed to update meta.json: ${getErrorMessage(err)}`);\n      });\n      // Ensure handle is cleaned up even on error\n      await proc.handle.dispose();\n      this.emitChange(proc.workspaceId);\n      return { success: true };\n    }\n  }\n\n  /**\n   * Terminate all background processes across all workspaces.\n   * Called during app shutdown to prevent orphaned processes.\n   */\n  async terminateAll(): Promise<void> {\n    log.debug(`BackgroundProcessManager.terminateAll() called`);\n    const allProcesses = Array.from(this.processes.values());\n    await Promise.all(allProcesses.map((p) => this.terminate(p.id)));\n    this.processes.clear();\n    log.debug(`Terminated ${allProcesses.length} background process(es)`);\n  }\n\n  /**\n   * Clean up all processes for a workspace.\n   * Terminates running processes and removes from memory.\n   * Output directories are left on disk (cleaned by OS for /tmp, or on workspace deletion for local).\n   */\n  async cleanup(workspaceId: string): Promise<void> {\n    log.debug(`BackgroundProcessManager.cleanup(${workspaceId}) called`);\n    const matching = Array.from(this.processes.values()).filter(\n      (p) => p.workspaceId === workspaceId\n    );\n\n    // Terminate all running processes\n    await Promise.all(matching.map((p) => this.terminate(p.id)));\n\n    // Remove from memory (output dirs left on disk for OS/workspace cleanup)\n    // All per-process state (outputBytesRead, outputLock) is stored in the\n    // BackgroundProcess object, so cleanup is automatic when we delete here.\n    for (const p of matching) {\n      this.processes.delete(p.id);\n    }\n\n    log.debug(`Cleaned up ${matching.length} process(es) for workspace ${workspaceId}`);\n  }\n}\n"]}