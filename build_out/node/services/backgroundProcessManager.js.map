{"version":3,"file":"backgroundProcessManager.js","sourceRoot":"","sources":["../../../src/node/services/backgroundProcessManager.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Runtime, BackgroundHandle } from \"@/node/runtime/Runtime\";\r\nimport { spawnProcess } from \"./backgroundProcessExecutor\";\r\nimport assert from \"@/common/utils/assert\";\r\nimport { getErrorMessage } from \"@/common/utils/errors\";\r\nimport { log } from \"./log\";\r\nimport { AsyncMutex } from \"@/node/utils/concurrency/asyncMutex\";\r\n\r\nconst DEFAULT_BACKGROUND_BASH_TAIL_BYTES = 64_000;\r\nconst MAX_BACKGROUND_BASH_TAIL_BYTES = 1_000_000;\r\n\r\nexport function computeTailStartOffset(fileSizeBytes: number, tailBytes: number): number {\r\n  assert(\r\n    Number.isFinite(fileSizeBytes) && fileSizeBytes >= 0,\r\n    `computeTailStartOffset expected fileSizeBytes >= 0 (got ${fileSizeBytes})`\r\n  );\r\n  assert(\r\n    Number.isFinite(tailBytes) && tailBytes > 0,\r\n    `computeTailStartOffset expected tailBytes > 0 (got ${tailBytes})`\r\n  );\r\n\r\n  return Math.max(0, fileSizeBytes - tailBytes);\r\n}\r\n\r\nimport { EventEmitter } from \"events\";\r\n\r\n/**\r\n * Metadata written to meta.json for bookkeeping\r\n */\r\nexport interface BackgroundProcessMeta {\r\n  id: string;\r\n  pid: number;\r\n  script: string;\r\n  startTime: number;\r\n  status: \"running\" | \"exited\" | \"killed\" | \"failed\";\r\n  exitCode?: number;\r\n  exitTime?: number;\r\n  displayName?: string;\r\n}\r\n\r\n/**\r\n * Represents a background process with file-based output.\r\n * All per-process state is consolidated here so cleanup is automatic when\r\n * the process is removed from the processes map.\r\n */\r\nexport interface BackgroundProcess {\r\n  id: string; // Process ID (display_name from the bash tool call)\r\n  pid: number; // OS process ID\r\n  workspaceId: string; // Owning workspace\r\n  outputDir: string; // Directory containing stdout.log, stderr.log, meta.json\r\n  script: string; // Original command\r\n  startTime: number; // Timestamp when started\r\n  exitCode?: number; // Undefined if still running\r\n  exitTime?: number; // Timestamp when exited (undefined if running)\r\n  status: \"running\" | \"exited\" | \"killed\" | \"failed\";\r\n  handle: BackgroundHandle; // For process interaction\r\n  displayName?: string; // Human-readable name (e.g., \"Dev Server\")\r\n  /** True if this process is being waited on (foreground mode) */\r\n  isForeground: boolean;\r\n  /** Tracks read position for incremental output retrieval */\r\n  outputBytesRead: number;\r\n  /** Mutex to serialize getOutput() calls (prevents race condition when\r\n   * parallel tool calls read from same offset before position is updated) */\r\n  outputLock: AsyncMutex;\r\n  /** Tracks how many times getOutput() has been called (for polling detection) */\r\n  getOutputCallCount: number;\r\n  /** Buffer for incomplete lines (no trailing newline) from previous read */\r\n  incompleteLineBuffer: string;\r\n}\r\n\r\n/**\r\n * Represents a foreground process that can be sent to background.\r\n * These are processes started via runtime.exec() (not nohup) that we track\r\n * so users can click \"Background\" to stop waiting for them.\r\n */\r\nexport interface ForegroundProcess {\r\n  /** Workspace ID */\r\n  workspaceId: string;\r\n  /** Tool call ID that started this process (for UI to match) */\r\n  toolCallId: string;\r\n  /** Script being executed */\r\n  script: string;\r\n  /** Display name for the process (used as ID if sent to background) */\r\n  displayName: string;\r\n  /** Callback to invoke when user requests backgrounding */\r\n  onBackground: () => void;\r\n  /** Current accumulated output (for saving to files on background) */\r\n  output: string[];\r\n}\r\n\r\n/**\r\n * Manages bash processes for workspaces.\r\n *\r\n * ALL bash commands are spawned through this manager with background-style\r\n * infrastructure (nohup, file output, exit code trap). This enables:\r\n * - Uniform code path for all bash commands\r\n * - Crash resilience (output always persisted to files)\r\n * - Seamless fg→bg transition via sendToBackground()\r\n *\r\n * Supports incremental output retrieval via getOutput().\r\n */\r\n/**\r\n * Event types emitted by BackgroundProcessManager.\r\n * The 'change' event is emitted whenever the state changes for a workspace.\r\n */\r\nexport interface BackgroundProcessManagerEvents {\r\n  change: [workspaceId: string];\r\n}\r\n\r\nexport class BackgroundProcessManager extends EventEmitter<BackgroundProcessManagerEvents> {\r\n  // NOTE: This map is in-memory only. Background processes use nohup/setsid so they\r\n  // could survive app restarts, but we kill all tracked processes on shutdown via\r\n  // dispose(). Rehydrating from meta.json on startup is out of scope for now.\r\n  // All per-process state (read position, output lock) is stored in BackgroundProcess\r\n  // so cleanup is automatic when the process is removed from this map.\r\n  private processes = new Map<string, BackgroundProcess>();\r\n\r\n  // Base directory for process output files\r\n  private readonly bgOutputDir: string;\r\n  // Tracks foreground processes (started via runtime.exec) that can be backgrounded\r\n  // Key is toolCallId to support multiple parallel foreground processes per workspace\r\n  private foregroundProcesses = new Map<string, ForegroundProcess>();\r\n  // Tracks workspaces with queued messages (for bash_output to return early)\r\n  private queuedMessageWorkspaces = new Set<string>();\r\n\r\n  constructor(bgOutputDir: string) {\r\n    super();\r\n    // Background bash status can have many concurrent subscribers (e.g. multiple workspaces).\r\n    // Raise the default listener cap to avoid noisy MaxListenersExceededWarning.\r\n    this.setMaxListeners(50);\r\n    this.bgOutputDir = bgOutputDir;\r\n  }\r\n\r\n  /**\r\n   * Mark whether a workspace has a queued user message.\r\n   * Used by bash_output to return early when user has sent a new message.\r\n   */\r\n  setMessageQueued(workspaceId: string, queued: boolean): void {\r\n    if (queued) {\r\n      this.queuedMessageWorkspaces.add(workspaceId);\r\n    } else {\r\n      this.queuedMessageWorkspaces.delete(workspaceId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a workspace has a queued user message.\r\n   */\r\n  hasQueuedMessage(workspaceId: string): boolean {\r\n    return this.queuedMessageWorkspaces.has(workspaceId);\r\n  }\r\n\r\n  /** Emit a change event for a workspace */\r\n  private emitChange(workspaceId: string): void {\r\n    this.emit(\"change\", workspaceId);\r\n  }\r\n\r\n  /**\r\n   * Get the base directory for background process output files.\r\n   */\r\n  getBgOutputDir(): string {\r\n    return this.bgOutputDir;\r\n  }\r\n\r\n  /**\r\n   * Generate a unique background process ID.\r\n   *\r\n   * Background process IDs are used as tool-visible identifiers (e.g. task_await with bash: IDs),\r\n   * so they must be globally unique across all running processes.\r\n   *\r\n   * If the base ID is already in use, we append \" (1)\", \" (2)\", etc.\r\n   */\r\n  generateUniqueProcessId(baseId: string): string {\r\n    assert(\r\n      typeof baseId === \"string\" && baseId.length > 0,\r\n      \"BackgroundProcessManager.generateUniqueProcessId requires a non-empty baseId\"\r\n    );\r\n\r\n    let processId = baseId;\r\n    let suffix = 1;\r\n    while (this.processes.has(processId)) {\r\n      processId = `${baseId} (${suffix})`;\r\n      suffix++;\r\n    }\r\n\r\n    return processId;\r\n  }\r\n\r\n  /**\r\n   * Spawn a new process with background-style infrastructure.\r\n   *\r\n   * All processes are spawned with nohup/setsid and file-based output,\r\n   * enabling seamless fg→bg transition via sendToBackground().\r\n   *\r\n   * @param runtime Runtime to spawn the process on\r\n   * @param workspaceId Workspace ID for tracking/filtering\r\n   * @param script Bash script to execute\r\n   * @param config Execution configuration\r\n   */\r\n  async spawn(\r\n    runtime: Runtime,\r\n    workspaceId: string,\r\n    script: string,\r\n    config: {\r\n      cwd: string;\r\n      env?: Record<string, string>;\r\n      /** Human-readable name for the process - used to generate the process ID */\r\n      displayName: string;\r\n      /** If true, process is foreground (being waited on). Default: false (background) */\r\n      isForeground?: boolean;\r\n      /** Auto-terminate after this many seconds (background processes only) */\r\n      timeoutSecs?: number;\r\n    }\r\n  ): Promise<\r\n    | { success: true; processId: string; outputDir: string; pid: number }\r\n    | { success: false; error: string }\r\n  > {\r\n    log.debug(`BackgroundProcessManager.spawn() called for workspace ${workspaceId}`);\r\n\r\n    const processId = this.generateUniqueProcessId(config.displayName);\r\n\r\n    // Spawn via executor with background infrastructure\r\n    // spawnProcess uses runtime.tempDir() internally for output directory\r\n    const result = await spawnProcess(runtime, script, {\r\n      cwd: config.cwd,\r\n      workspaceId,\r\n      processId,\r\n      env: config.env,\r\n    });\r\n\r\n    if (!result.success) {\r\n      log.debug(`BackgroundProcessManager: Failed to spawn: ${result.error}`);\r\n      return { success: false, error: result.error };\r\n    }\r\n\r\n    const { handle, pid, outputDir } = result;\r\n    const startTime = Date.now();\r\n\r\n    // Write meta.json with process info\r\n    const meta: BackgroundProcessMeta = {\r\n      id: processId,\r\n      pid,\r\n      script,\r\n      startTime,\r\n      status: \"running\",\r\n      displayName: config.displayName,\r\n    };\r\n    await handle.writeMeta(JSON.stringify(meta, null, 2));\r\n\r\n    const proc: BackgroundProcess = {\r\n      id: processId,\r\n      pid,\r\n      workspaceId,\r\n      outputDir,\r\n      script,\r\n      startTime,\r\n      status: \"running\",\r\n      handle,\r\n      displayName: config.displayName,\r\n      isForeground: config.isForeground ?? false,\r\n      outputBytesRead: 0,\r\n      outputLock: new AsyncMutex(),\r\n      getOutputCallCount: 0,\r\n      incompleteLineBuffer: \"\",\r\n    };\r\n\r\n    // Store process in map\r\n    this.processes.set(processId, proc);\r\n\r\n    log.debug(\r\n      `Process ${processId} spawned successfully with PID ${pid} (foreground: ${proc.isForeground})`\r\n    );\r\n\r\n    // Schedule auto-termination for background processes with timeout\r\n    const timeoutSecs = config.timeoutSecs;\r\n    if (!config.isForeground && timeoutSecs !== undefined && timeoutSecs > 0) {\r\n      setTimeout(() => {\r\n        void this.terminate(processId).then((result) => {\r\n          if (result.success) {\r\n            log.debug(`Process ${processId} auto-terminated after ${timeoutSecs}s timeout`);\r\n          }\r\n        });\r\n      }, timeoutSecs * 1000);\r\n    }\r\n\r\n    // Emit change event (only if background - foreground processes don't show in list)\r\n    if (!proc.isForeground) {\r\n      this.emitChange(workspaceId);\r\n    }\r\n\r\n    return { success: true, processId, outputDir, pid };\r\n  }\r\n\r\n  /**\r\n   * Register a foreground process that can be sent to background.\r\n   * Called by bash tool when starting foreground execution.\r\n   *\r\n   * @param workspaceId Workspace the process belongs to\r\n   * @param toolCallId Tool call ID (for UI to identify which bash row)\r\n   * @param script Script being executed\r\n   * @param onBackground Callback invoked when user requests backgrounding\r\n   * @returns Cleanup function to call when process completes\r\n   */\r\n  registerForegroundProcess(\r\n    workspaceId: string,\r\n    toolCallId: string,\r\n    script: string,\r\n    displayName: string,\r\n    onBackground: () => void\r\n  ): { unregister: () => void; addOutput: (line: string) => void } {\r\n    const proc: ForegroundProcess = {\r\n      workspaceId,\r\n      toolCallId,\r\n      script,\r\n      displayName,\r\n      onBackground,\r\n      output: [],\r\n    };\r\n    this.foregroundProcesses.set(toolCallId, proc);\r\n    log.debug(\r\n      `Registered foreground process for workspace ${workspaceId}, toolCallId ${toolCallId}`\r\n    );\r\n    this.emitChange(workspaceId);\r\n\r\n    return {\r\n      unregister: () => {\r\n        this.foregroundProcesses.delete(toolCallId);\r\n        log.debug(`Unregistered foreground process toolCallId ${toolCallId}`);\r\n        this.emitChange(workspaceId);\r\n      },\r\n      addOutput: (line: string) => {\r\n        proc.output.push(line);\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Register a migrated foreground process as a tracked background process.\r\n   *\r\n   * Called by bash tool when migration completes, after migrateToBackground()\r\n   * has created the output directory and started file writing.\r\n   *\r\n   * @param handle The BackgroundHandle from migrateToBackground()\r\n   * @param processId The generated process ID\r\n   * @param workspaceId Workspace the process belongs to\r\n   * @param script Original script being executed\r\n   * @param outputDir Directory containing output files\r\n   * @param displayName Optional human-readable name\r\n   */\r\n  registerMigratedProcess(\r\n    handle: BackgroundHandle,\r\n    processId: string,\r\n    workspaceId: string,\r\n    script: string,\r\n    outputDir: string,\r\n    displayName?: string\r\n  ): void {\r\n    const startTime = Date.now();\r\n\r\n    const proc: BackgroundProcess = {\r\n      id: processId,\r\n      pid: 0, // Unknown for migrated processes (could be remote)\r\n      workspaceId,\r\n      outputDir,\r\n      script,\r\n      startTime,\r\n      status: \"running\",\r\n      handle,\r\n      displayName,\r\n      isForeground: false, // Now in background\r\n      outputBytesRead: 0,\r\n      outputLock: new AsyncMutex(),\r\n      getOutputCallCount: 0,\r\n      incompleteLineBuffer: \"\",\r\n    };\r\n\r\n    // Store process in map\r\n    this.processes.set(processId, proc);\r\n\r\n    // Write meta.json\r\n    const meta: BackgroundProcessMeta = {\r\n      id: processId,\r\n      pid: 0,\r\n      script,\r\n      startTime,\r\n      status: \"running\",\r\n      displayName,\r\n    };\r\n    void handle.writeMeta(JSON.stringify(meta, null, 2));\r\n\r\n    log.debug(`Migrated process ${processId} registered for workspace ${workspaceId}`);\r\n    this.emitChange(workspaceId);\r\n  }\r\n\r\n  /**\r\n   * Send a foreground process to background.\r\n   *\r\n   * For processes started with background infrastructure (isForeground=true in spawn):\r\n   * - Marks as background and emits 'backgrounded' event\r\n   *\r\n   * For processes started via runtime.exec (tracked via registerForegroundProcess):\r\n   * - Invokes the onBackground callback to trigger early return\r\n   *\r\n   * @param toolCallId The tool call ID of the bash to background\r\n   * @returns Success status\r\n   */\r\n  sendToBackground(toolCallId: string): { success: true } | { success: false; error: string } {\r\n    log.debug(`BackgroundProcessManager.sendToBackground(${toolCallId}) called`);\r\n\r\n    const fgProc = this.foregroundProcesses.get(toolCallId);\r\n    if (fgProc) {\r\n      fgProc.onBackground();\r\n      log.debug(`Foreground process toolCallId ${toolCallId} sent to background`);\r\n      return { success: true };\r\n    }\r\n\r\n    return { success: false, error: \"No foreground process found with that tool call ID\" };\r\n  }\r\n\r\n  /**\r\n   * Get all foreground tool call IDs for a workspace.\r\n   * Returns empty array if no foreground processes are running.\r\n   */\r\n  getForegroundToolCallIds(workspaceId: string): string[] {\r\n    const ids: string[] = [];\r\n    // Check exec-based foreground processes\r\n    for (const [toolCallId, proc] of this.foregroundProcesses) {\r\n      if (proc.workspaceId === workspaceId) {\r\n        ids.push(toolCallId);\r\n      }\r\n    }\r\n    return ids;\r\n  }\r\n\r\n  /**\r\n   * Write/update meta.json for a process\r\n   */\r\n  private async updateMetaFile(proc: BackgroundProcess): Promise<void> {\r\n    const meta: BackgroundProcessMeta = {\r\n      id: proc.id,\r\n      pid: proc.pid,\r\n      script: proc.script,\r\n      startTime: proc.startTime,\r\n      status: proc.status,\r\n      exitCode: proc.exitCode,\r\n      exitTime: proc.exitTime,\r\n    };\r\n    const metaJson = JSON.stringify(meta, null, 2);\r\n\r\n    await proc.handle.writeMeta(metaJson);\r\n  }\r\n\r\n  /**\r\n   * Get a background process by ID.\r\n   * Refreshes status if the process is still marked as running.\r\n   */\r\n  async getProcess(processId: string): Promise<BackgroundProcess | null> {\r\n    log.debug(`BackgroundProcessManager.getProcess(${processId}) called`);\r\n    const proc = this.processes.get(processId);\r\n    if (!proc) return null;\r\n\r\n    // Refresh status if still running (exit code null = still running)\r\n    if (proc.status === \"running\") {\r\n      const exitCode = await proc.handle.getExitCode();\r\n      if (exitCode !== null) {\r\n        log.debug(`Background process ${proc.id} has exited`);\r\n        proc.status = \"exited\";\r\n        proc.exitCode = exitCode;\r\n        proc.exitTime = Date.now();\r\n        await this.updateMetaFile(proc).catch((err: unknown) => {\r\n          log.debug(\r\n            `BackgroundProcessManager: Failed to update meta.json: ${getErrorMessage(err)}`\r\n          );\r\n        });\r\n        this.emitChange(proc.workspaceId);\r\n      }\r\n    }\r\n\r\n    return proc;\r\n  }\r\n\r\n  /**\r\n   * Get incremental output from a background process.\r\n   * Returns only NEW output since the last call (tracked per process).\r\n   * @param processId Process ID to get output from\r\n   * @param filter Optional regex pattern to filter output lines (non-matching lines are discarded permanently)\r\n   * @param filterExclude When true, invert filter to exclude matching lines instead of keeping them\r\n   * @param timeout Seconds to wait for output if none available (default 0 = non-blocking)\r\n   * @param abortSignal Optional signal to abort waiting early (e.g., when stream is cancelled)\r\n   * @param workspaceId Optional workspace ID to check for queued messages (return early to process them)\r\n   * @param noteToolName Optional tool name to use in polling guidance notes\r\n   */\r\n  async getOutput(\r\n    processId: string,\r\n    filter?: string,\r\n    filterExclude?: boolean,\r\n    timeout?: number,\r\n    abortSignal?: AbortSignal,\r\n    workspaceId?: string,\r\n    noteToolName?: string\r\n  ): Promise<\r\n    | {\r\n        success: true;\r\n        status: \"running\" | \"exited\" | \"killed\" | \"failed\" | \"interrupted\";\r\n        output: string;\r\n        exitCode?: number;\r\n        elapsed_ms: number;\r\n        note?: string;\r\n      }\r\n    | { success: false; error: string }\r\n  > {\r\n    const timeoutSecs = Math.max(timeout ?? 0, 0);\r\n    log.debug(\r\n      `BackgroundProcessManager.getOutput(${processId}, filter=${filter ?? \"none\"}, exclude=${filterExclude ?? false}, timeout=${timeoutSecs}s) called`\r\n    );\r\n\r\n    // Validate: filter_exclude requires filter\r\n    if (filterExclude && !filter) {\r\n      return { success: false, error: \"filter_exclude requires filter to be set\" };\r\n    }\r\n\r\n    const proc = await this.getProcess(processId);\r\n    if (!proc) {\r\n      return { success: false, error: `Process not found: ${processId}` };\r\n    }\r\n\r\n    // Acquire per-process mutex to serialize concurrent getOutput() calls.\r\n    // This prevents race conditions where parallel tool calls both read from\r\n    // the same offset before either updates the read position.\r\n    await using _lock = await proc.outputLock.acquire();\r\n\r\n    // Track call count for polling detection\r\n    proc.getOutputCallCount++;\r\n    const callCount = proc.getOutputCallCount;\r\n\r\n    log.debug(\r\n      `BackgroundProcessManager.getOutput: proc.outputDir=${proc.outputDir}, offset=${proc.outputBytesRead}, callCount=${callCount}`\r\n    );\r\n\r\n    // Pre-compile regex if filter is provided\r\n    let filterRegex: RegExp | undefined;\r\n    if (filter) {\r\n      try {\r\n        filterRegex = new RegExp(filter);\r\n      } catch (e) {\r\n        return { success: false, error: `Invalid filter regex: ${getErrorMessage(e)}` };\r\n      }\r\n    }\r\n\r\n    // Apply filtering to complete lines only\r\n    // Incomplete line fragments (no trailing newline) are kept in buffer for next read\r\n    const applyFilter = (lines: string[]): string => {\r\n      if (!filterRegex) return lines.join(\"\\n\");\r\n      const filtered = filterExclude\r\n        ? lines.filter((line) => !filterRegex.test(line))\r\n        : lines.filter((line) => filterRegex.test(line));\r\n      return filtered.join(\"\\n\");\r\n    };\r\n\r\n    // Blocking wait loop: poll for output up to timeout seconds\r\n    const startTime = Date.now();\r\n    const timeoutMs = timeoutSecs * 1000;\r\n    const pollIntervalMs = 100;\r\n    let accumulatedRaw = \"\";\r\n    let currentStatus = proc.status;\r\n\r\n    // Track the previous buffer to prepend to accumulated output\r\n    const previousBuffer = proc.incompleteLineBuffer;\r\n\r\n    while (true) {\r\n      // Read new content via the handle (works for both local and SSH runtimes)\r\n      // Output is already unified in output.log (stdout + stderr via 2>&1)\r\n      const result = await proc.handle.readOutput(proc.outputBytesRead);\r\n      accumulatedRaw += result.content;\r\n\r\n      // Update read position\r\n      proc.outputBytesRead = result.newOffset;\r\n\r\n      // Refresh process status\r\n      const refreshedProc = await this.getProcess(processId);\r\n      currentStatus = refreshedProc?.status ?? proc.status;\r\n\r\n      // Line-buffered filtering: prepend incomplete line from previous call\r\n      const rawWithBuffer = previousBuffer + accumulatedRaw;\r\n      const allLines = rawWithBuffer.split(\"\\n\");\r\n\r\n      // Last element is incomplete if content doesn't end with newline\r\n      const hasTrailingNewline = rawWithBuffer.endsWith(\"\\n\");\r\n      const completeLines = hasTrailingNewline ? allLines.slice(0, -1) : allLines.slice(0, -1);\r\n\r\n      // When using filter_exclude, check if we have meaningful (non-excluded) output.\r\n      // We only consider complete lines as \"meaningful\" here; fragments are buffered for the next read.\r\n      const filteredOutput = applyFilter(completeLines);\r\n      const hasMeaningfulOutput = filterExclude\r\n        ? filteredOutput.trim().length > 0\r\n        : completeLines.length > 0;\r\n\r\n      // Return immediately if:\r\n      // 1. We have meaningful output (after filtering if filter_exclude is set)\r\n      // 2. Timeout elapsed\r\n      // 3. Abort signal received (user sent a new message)\r\n      if (hasMeaningfulOutput) {\r\n        break;\r\n      }\r\n\r\n      // If the process is no longer running (exited/killed/failed), do one last read\r\n      // to avoid dropping output that arrives between our readOutput() call and\r\n      // the status refresh.\r\n      if (currentStatus !== \"running\") {\r\n        while (true) {\r\n          const finalRead = await proc.handle.readOutput(proc.outputBytesRead);\r\n          if (finalRead.content.length === 0) {\r\n            break;\r\n          }\r\n\r\n          // Defensive: avoid infinite loops if a handle returns inconsistent offsets.\r\n          if (finalRead.newOffset <= proc.outputBytesRead) {\r\n            break;\r\n          }\r\n\r\n          accumulatedRaw += finalRead.content;\r\n          proc.outputBytesRead = finalRead.newOffset;\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      if (abortSignal?.aborted || (workspaceId && this.hasQueuedMessage(workspaceId))) {\r\n        const elapsed_ms = Date.now() - startTime;\r\n        return {\r\n          success: true,\r\n          status: \"interrupted\",\r\n          output: \"(waiting interrupted)\",\r\n          elapsed_ms,\r\n        };\r\n      }\r\n\r\n      const elapsed = Date.now() - startTime;\r\n      if (elapsed >= timeoutMs) {\r\n        break;\r\n      }\r\n\r\n      // Sleep before next poll\r\n      await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));\r\n    }\r\n\r\n    // Final line processing with buffer from previous call\r\n\r\n    // If the process exited, do a final drain of output.\r\n    //\r\n    // Rationale: stdout/stderr writes can land just after we observe that the process\r\n    // has exited. Without a final drain, we can return \"exited\" with empty output\r\n    // even though output becomes available moments later.\r\n    if (currentStatus !== \"running\") {\r\n      const offsetBeforeDrain = proc.outputBytesRead;\r\n\r\n      while (true) {\r\n        const extra = await proc.handle.readOutput(proc.outputBytesRead);\r\n        if (extra.content.length === 0) {\r\n          break;\r\n        }\r\n        accumulatedRaw += extra.content;\r\n        proc.outputBytesRead = extra.newOffset;\r\n      }\r\n\r\n      // If we didn't observe any new output, wait one poll interval and try once more.\r\n      if (proc.outputBytesRead === offsetBeforeDrain) {\r\n        await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));\r\n\r\n        while (true) {\r\n          const extra = await proc.handle.readOutput(proc.outputBytesRead);\r\n          if (extra.content.length === 0) {\r\n            break;\r\n          }\r\n          accumulatedRaw += extra.content;\r\n          proc.outputBytesRead = extra.newOffset;\r\n        }\r\n      }\r\n    }\r\n    const rawWithBuffer = previousBuffer + accumulatedRaw;\r\n    const allLines = rawWithBuffer.split(\"\\n\");\r\n    const hasTrailingNewline = rawWithBuffer.endsWith(\"\\n\");\r\n\r\n    // On process exit, include incomplete line; otherwise keep it buffered\r\n    const linesToReturn =\r\n      currentStatus !== \"running\"\r\n        ? allLines.filter((l) => l.length > 0) // Include all non-empty lines on exit\r\n        : hasTrailingNewline\r\n          ? allLines.slice(0, -1)\r\n          : allLines.slice(0, -1);\r\n\r\n    // Update buffer for next call (clear on exit, keep incomplete line otherwise)\r\n    proc.incompleteLineBuffer =\r\n      currentStatus === \"running\" && !hasTrailingNewline ? allLines[allLines.length - 1] : \"\";\r\n\r\n    log.debug(\r\n      `BackgroundProcessManager.getOutput: read rawLen=${accumulatedRaw.length}, completeLines=${linesToReturn.length}`\r\n    );\r\n\r\n    const filteredOutput = applyFilter(linesToReturn);\r\n\r\n    // Suggest filter_exclude if polling too frequently on a running process\r\n    const shouldSuggestFilterExclude =\r\n      callCount >= 3 && !filterExclude && currentStatus === \"running\";\r\n\r\n    // Suggest better pattern if using filter_exclude but still polling frequently\r\n    const shouldSuggestBetterPattern =\r\n      callCount >= 3 && filterExclude && currentStatus === \"running\";\r\n\r\n    const pollingToolName = noteToolName ?? \"bash_output\";\r\n\r\n    let note: string | undefined;\r\n    if (shouldSuggestFilterExclude) {\r\n      note =\r\n        `STOP POLLING. You've called ${pollingToolName} 3+ times on this process. ` +\r\n        \"This wastes tokens and clutters the conversation. \" +\r\n        \"Instead, make ONE call with: filter='⏳|progress|waiting|\\\\\\\\\\\\.\\\\\\\\\\\\.\\\\\\\\\\\\.', \" +\r\n        \"filter_exclude=true, timeout_secs=120. This blocks until meaningful output arrives.\";\r\n    } else if (shouldSuggestBetterPattern) {\r\n      note =\r\n        \"You're using filter_exclude but still polling frequently. \" +\r\n        \"Your filter pattern may not be matching the actual output. \" +\r\n        \"Try a broader pattern like: filter='\\\\\\\\.|\\\\\\\\d+%|running|progress|pending|⏳|waiting'. \" +\r\n        \"Wait for the FULL timeout before checking again.\";\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      status: currentStatus,\r\n      output: filteredOutput,\r\n      exitCode:\r\n        currentStatus !== \"running\"\r\n          ? ((await this.getProcess(processId))?.exitCode ?? undefined)\r\n          : undefined,\r\n      elapsed_ms: Date.now() - startTime,\r\n      note,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Peek output from a background process without advancing its incremental cursor.\r\n   *\r\n   * Used by the UI to display buffered output for background bashes. Unlike getOutput(),\r\n   * this must NOT mutate proc.outputBytesRead/proc.incompleteLineBuffer (which are used by\r\n   * bash_output + task_await).\r\n   */\r\n  async peekOutput(\r\n    processId: string,\r\n    options?: { fromOffset?: number; tailBytes?: number }\r\n  ): Promise<\r\n    | {\r\n        success: true;\r\n        status: \"running\" | \"exited\" | \"killed\" | \"failed\";\r\n        output: string;\r\n        nextOffset: number;\r\n        truncatedStart: boolean;\r\n      }\r\n    | { success: false; error: string }\r\n  > {\r\n    const fromOffset = options?.fromOffset;\r\n    const tailBytesRaw = options?.tailBytes;\r\n\r\n    log.debug(\r\n      `BackgroundProcessManager.peekOutput(${processId}, fromOffset=${fromOffset ?? \"tail\"}, tailBytes=${tailBytesRaw ?? DEFAULT_BACKGROUND_BASH_TAIL_BYTES}) called`\r\n    );\r\n\r\n    if (fromOffset !== undefined && (!Number.isFinite(fromOffset) || fromOffset < 0)) {\r\n      return { success: false, error: `Invalid fromOffset: ${fromOffset}` };\r\n    }\r\n\r\n    const tailBytes = tailBytesRaw ?? DEFAULT_BACKGROUND_BASH_TAIL_BYTES;\r\n    if (!Number.isFinite(tailBytes) || tailBytes <= 0) {\r\n      return { success: false, error: `Invalid tailBytes: ${String(tailBytesRaw)}` };\r\n    }\r\n    const clampedTailBytes = Math.min(tailBytes, MAX_BACKGROUND_BASH_TAIL_BYTES);\r\n\r\n    const proc = await this.getProcess(processId);\r\n    if (!proc) {\r\n      return { success: false, error: `Process not found: ${processId}` };\r\n    }\r\n\r\n    let offset = fromOffset;\r\n    let truncatedStart = false;\r\n\r\n    if (offset === undefined) {\r\n      const fileSizeBytes = await proc.handle.getOutputFileSize();\r\n      offset = computeTailStartOffset(fileSizeBytes, clampedTailBytes);\r\n      truncatedStart = offset > 0;\r\n    }\r\n\r\n    const result = await proc.handle.readOutput(offset);\r\n    assert(\r\n      result.newOffset >= offset,\r\n      `BackgroundHandle.readOutput returned newOffset < offset (offset=${offset}, newOffset=${result.newOffset})`\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      status: proc.status,\r\n      output: result.content,\r\n      nextOffset: result.newOffset,\r\n      truncatedStart,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * List background processes (not including foreground ones being waited on).\r\n   * Optionally filtered by workspace.\r\n   * Refreshes status of running processes before returning.\r\n   */\r\n  async list(workspaceId?: string): Promise<BackgroundProcess[]> {\r\n    log.debug(`BackgroundProcessManager.list(${workspaceId ?? \"all\"}) called`);\r\n    await this.refreshRunningStatuses();\r\n    // Only return background processes (not foreground ones being waited on)\r\n    const backgroundProcesses = Array.from(this.processes.values()).filter((p) => !p.isForeground);\r\n    return workspaceId\r\n      ? backgroundProcesses.filter((p) => p.workspaceId === workspaceId)\r\n      : backgroundProcesses;\r\n  }\r\n\r\n  /**\r\n   * Check all \"running\" processes and update status if they've exited.\r\n   * Called lazily from list() to avoid polling overhead.\r\n   */\r\n  private async refreshRunningStatuses(): Promise<void> {\r\n    const runningProcesses = Array.from(this.processes.values()).filter(\r\n      (p) => p.status === \"running\"\r\n    );\r\n\r\n    for (const proc of runningProcesses) {\r\n      const exitCode = await proc.handle.getExitCode();\r\n      if (exitCode !== null) {\r\n        log.debug(`Background process ${proc.id} has exited`);\r\n        proc.status = \"exited\";\r\n        proc.exitCode = exitCode;\r\n        proc.exitTime = Date.now();\r\n        await this.updateMetaFile(proc).catch((err: unknown) => {\r\n          log.debug(\r\n            `BackgroundProcessManager: Failed to update meta.json: ${getErrorMessage(err)}`\r\n          );\r\n        });\r\n        this.emitChange(proc.workspaceId);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Terminate a background process\r\n   */\r\n  async terminate(\r\n    processId: string\r\n  ): Promise<{ success: true } | { success: false; error: string }> {\r\n    log.debug(`BackgroundProcessManager.terminate(${processId}) called`);\r\n\r\n    // Get process from Map\r\n    const proc = this.processes.get(processId);\r\n    if (!proc) {\r\n      return { success: false, error: `Process not found: ${processId}` };\r\n    }\r\n\r\n    // If already terminated, return success (idempotent)\r\n    if (proc.status === \"exited\" || proc.status === \"killed\" || proc.status === \"failed\") {\r\n      log.debug(`Process ${processId} already terminated with status: ${proc.status}`);\r\n      return { success: true };\r\n    }\r\n\r\n    try {\r\n      await proc.handle.terminate();\r\n\r\n      // Update process status and exit code\r\n      proc.status = \"killed\";\r\n      proc.exitCode = (await proc.handle.getExitCode()) ?? undefined;\r\n      proc.exitTime ??= Date.now();\r\n\r\n      // Update meta.json\r\n      await this.updateMetaFile(proc).catch((err: unknown) => {\r\n        log.debug(`BackgroundProcessManager: Failed to update meta.json: ${getErrorMessage(err)}`);\r\n      });\r\n\r\n      // Dispose of the handle\r\n      await proc.handle.dispose();\r\n\r\n      log.debug(`Process ${processId} terminated successfully`);\r\n      this.emitChange(proc.workspaceId);\r\n      return { success: true };\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : String(error);\r\n      log.debug(`Error terminating process ${processId}: ${errorMessage}`);\r\n      // Mark as killed even if there was an error (process likely already dead)\r\n      proc.status = \"killed\";\r\n      proc.exitTime ??= Date.now();\r\n      // Update meta.json\r\n      await this.updateMetaFile(proc).catch((err: unknown) => {\r\n        log.debug(`BackgroundProcessManager: Failed to update meta.json: ${getErrorMessage(err)}`);\r\n      });\r\n      // Ensure handle is cleaned up even on error\r\n      await proc.handle.dispose();\r\n      this.emitChange(proc.workspaceId);\r\n      return { success: true };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Terminate all background processes across all workspaces.\r\n   * Called during app shutdown to prevent orphaned processes.\r\n   */\r\n  async terminateAll(): Promise<void> {\r\n    log.debug(`BackgroundProcessManager.terminateAll() called`);\r\n    const allProcesses = Array.from(this.processes.values());\r\n    await Promise.all(allProcesses.map((p) => this.terminate(p.id)));\r\n    this.processes.clear();\r\n    log.debug(`Terminated ${allProcesses.length} background process(es)`);\r\n  }\r\n\r\n  /**\r\n   * Clean up all processes for a workspace.\r\n   * Terminates running processes and removes from memory.\r\n   * Output directories are left on disk (cleaned by OS for /tmp, or on workspace deletion for local).\r\n   */\r\n  async cleanup(workspaceId: string): Promise<void> {\r\n    log.debug(`BackgroundProcessManager.cleanup(${workspaceId}) called`);\r\n    const matching = Array.from(this.processes.values()).filter(\r\n      (p) => p.workspaceId === workspaceId\r\n    );\r\n\r\n    // Terminate all running processes\r\n    await Promise.all(matching.map((p) => this.terminate(p.id)));\r\n\r\n    // Remove from memory (output dirs left on disk for OS/workspace cleanup)\r\n    // All per-process state (outputBytesRead, outputLock) is stored in the\r\n    // BackgroundProcess object, so cleanup is automatic when we delete here.\r\n    for (const p of matching) {\r\n      this.processes.delete(p.id);\r\n    }\r\n\r\n    log.debug(`Cleaned up ${matching.length} process(es) for workspace ${workspaceId}`);\r\n  }\r\n}\r\n"]}