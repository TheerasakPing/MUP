{"version":3,"file":"hooks.js","sourceRoot":"","sources":["../../../src/node/services/hooks.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Tool Hook System\n *\n * Provides a mechanism for users to wrap tool executions with custom pre/post logic.\n * Hooks can be used for:\n * - Environment setup (direnv, nvm, virtualenv)\n * - Linting/type-checking after file edits\n * - Blocking dangerous operations\n * - Custom logging/metrics\n *\n * Hook Location:\n *   1. .mux/tool_hook (project-level, committed)\n *   2. ~/.mux/tool_hook (user-level, personal)\n *\n * Protocol:\n *   1. Hook receives MUX_TOOL, MUX_TOOL_INPUT, MUX_EXEC, etc. as env vars\n *   2. Hook runs pre-logic\n *   3. Hook prints $MUX_EXEC (the unique marker) to signal readiness\n *   4. Mux executes the tool, sends result JSON to hook's stdin\n *   5. Hook reads result, runs post-logic\n *   6. Hook exits (non-zero = failure fed back to LLM)\n *\n * Runtime Support:\n *   Hooks execute via the Runtime abstraction, so they work correctly for both\n *   local and SSH workspaces. For SSH, the hook file must exist on the remote machine.\n */\n\nimport * as crypto from \"crypto\";\nimport * as path from \"path\";\nimport { flattenToolHookValueToEnv } from \"@/common/utils/tools/toolHookEnv\";\nimport type { Runtime } from \"@/node/runtime/Runtime\";\nimport { log } from \"@/node/services/log\";\nimport { execBuffered, writeFileString } from \"@/node/utils/runtime/helpers\";\n\nconst HOOK_FILENAME = \"tool_hook\";\nconst PRE_HOOK_FILENAME = \"tool_pre\";\nconst POST_HOOK_FILENAME = \"tool_post\";\nconst TOOL_ENV_FILENAME = \"tool_env\";\nconst TOOL_INPUT_ENV_LIMIT = 8_000;\nconst FLATTENED_TOOL_ENV_MAX_VARS = 200;\nconst FLATTENED_TOOL_ENV_MAX_ARRAY_LENGTH = 50;\nconst DEFAULT_HOOK_PHASE_TIMEOUT_MS = 10_000; // 10 seconds\nconst EXEC_MARKER_PREFIX = \"MUX_EXEC_\";\n\n/** Shell-escape a string for safe use in bash -c commands */\nfunction shellEscape(str: string): string {\n  // Wrap in single quotes and escape any embedded single quotes\n  return `'${str.replace(/'/g, \"'\\\\''\")}'`;\n}\n\nfunction isAsyncIterable(value: unknown): value is AsyncIterable<unknown> {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    Symbol.asyncIterator in value &&\n    typeof (value as Record<symbol, unknown>)[Symbol.asyncIterator] === \"function\"\n  );\n}\nfunction joinPathLike(basePath: string, ...parts: string[]): string {\n  // For SSH runtimes (and most Unix paths), we want POSIX joins.\n  // For Windows-style paths, use native joins.\n  if (basePath.includes(\"\\\\\") || /^[a-zA-Z]:/.test(basePath)) {\n    return path.join(basePath, ...parts);\n  }\n  return path.posix.join(basePath, ...parts);\n}\n\nfunction getToolInputValueForEnv(context: {\n  toolInput: string;\n  toolInputValue?: unknown;\n}): unknown {\n  if (context.toolInputValue !== undefined) {\n    return context.toolInputValue;\n  }\n\n  try {\n    return JSON.parse(context.toolInput) as unknown;\n  } catch {\n    return undefined;\n  }\n}\n\nexport interface HookContext {\n  /** Tool name (e.g., \"bash\", \"file_edit_replace_string\") */\n  tool: string;\n  /** Tool input as JSON string */\n  toolInput: string;\n  /**\n   * Tool input as a structured value (best-effort), used for flattened env vars.\n   *\n   * Optional for backwards compatibility; when omitted we'll attempt to parse\n   * `toolInput` as JSON.\n   */\n  toolInputValue?: unknown;\n  /** Workspace ID */\n  workspaceId: string;\n  /** Runtime temp dir for hook scratch files (paths in the runtime's context) */\n  runtimeTempDir?: string;\n  /** Project directory (cwd) */\n  projectDir: string;\n  /** Additional environment variables to pass to hook */\n  env?: Record<string, string>;\n  /** External abort signal (e.g., from workspace deletion) */\n  abortSignal?: AbortSignal;\n}\n\nexport interface HookResult {\n  /** Whether the hook succeeded (exit code 0) */\n  success: boolean;\n  /** Stdout output from hook before the __MUX_EXEC__ marker */\n  stdoutBeforeExec: string;\n  /** Stdout output from hook (after __MUX_EXEC__ marker) */\n  stdout: string;\n  /** Stderr output from hook */\n  stderr: string;\n  /** Hook process exit code */\n  exitCode: number;\n  /** Whether the tool was executed (hook printed __MUX_EXEC__) */\n  toolExecuted: boolean;\n}\n\n/**\n * Find the tool_hook executable for a given project directory.\n * Uses runtime abstraction so it works for both local and SSH workspaces.\n * Returns null if no hook exists.\n *\n * Note: We don't check execute permissions via runtime since FileStat doesn't\n * expose mode bits. The hook will fail at execution time if not executable.\n */\nexport async function getHookPath(runtime: Runtime, projectDir: string): Promise<string | null> {\n  // Check project-level hook first\n  const projectHook = joinPathLike(projectDir, \".mux\", HOOK_FILENAME);\n  if (await isFile(runtime, projectHook)) {\n    return projectHook;\n  }\n\n  // Fall back to user-level hook (resolve ~ for SSH compatibility)\n  try {\n    const homeDir = await runtime.resolvePath(\"~\");\n    const userHook = joinPathLike(homeDir, \".mux\", HOOK_FILENAME);\n    if (await isFile(runtime, userHook)) {\n      return userHook;\n    }\n  } catch {\n    // resolvePath failed - skip user hook\n  }\n\n  return null;\n}\n\n/**\n * Find the tool_env file for a given project directory.\n * This file is sourced before bash tool scripts to set up environment.\n * Returns null if no tool_env exists.\n */\nexport async function getToolEnvPath(runtime: Runtime, projectDir: string): Promise<string | null> {\n  // Check project-level tool_env first\n  const projectEnv = joinPathLike(projectDir, \".mux\", TOOL_ENV_FILENAME);\n  if (await isFile(runtime, projectEnv)) {\n    return projectEnv;\n  }\n\n  // Fall back to user-level tool_env (resolve ~ for SSH compatibility)\n  try {\n    const homeDir = await runtime.resolvePath(\"~\");\n    const userEnv = joinPathLike(homeDir, \".mux\", TOOL_ENV_FILENAME);\n    if (await isFile(runtime, userEnv)) {\n      return userEnv;\n    }\n  } catch {\n    // resolvePath failed - skip user tool_env\n  }\n\n  return null;\n}\n\n/**\n * Find the tool_pre executable for a given project directory.\n * This hook runs before tool execution; exit non-zero to block.\n * Returns null if no tool_pre exists.\n */\nexport async function getPreHookPath(runtime: Runtime, projectDir: string): Promise<string | null> {\n  const projectHook = joinPathLike(projectDir, \".mux\", PRE_HOOK_FILENAME);\n  if (await isFile(runtime, projectHook)) {\n    return projectHook;\n  }\n\n  try {\n    const homeDir = await runtime.resolvePath(\"~\");\n    const userHook = joinPathLike(homeDir, \".mux\", PRE_HOOK_FILENAME);\n    if (await isFile(runtime, userHook)) {\n      return userHook;\n    }\n  } catch {\n    // resolvePath failed - skip user hook\n  }\n\n  return null;\n}\n\n/**\n * Find the tool_post executable for a given project directory.\n * This hook runs after tool execution with result available.\n * Returns null if no tool_post exists.\n */\nexport async function getPostHookPath(\n  runtime: Runtime,\n  projectDir: string\n): Promise<string | null> {\n  const projectHook = joinPathLike(projectDir, \".mux\", POST_HOOK_FILENAME);\n  if (await isFile(runtime, projectHook)) {\n    return projectHook;\n  }\n\n  try {\n    const homeDir = await runtime.resolvePath(\"~\");\n    const userHook = joinPathLike(homeDir, \".mux\", POST_HOOK_FILENAME);\n    if (await isFile(runtime, userHook)) {\n      return userHook;\n    }\n  } catch {\n    // resolvePath failed - skip user hook\n  }\n\n  return null;\n}\n\n// When probing hook files over SSH, avoid hanging on dead connections.\n// Hook discovery is best-effort; a short timeout keeps tool execution responsive.\nconst HOOK_FILE_STAT_TIMEOUT_MS = 2000;\n\nasync function isFile(runtime: Runtime, filePath: string): Promise<boolean> {\n  try {\n    const stat = await runtime.stat(filePath, AbortSignal.timeout(HOOK_FILE_STAT_TIMEOUT_MS));\n    return !stat.isDirectory;\n  } catch {\n    return false;\n  }\n}\n\n/** Options for hook timing warnings */\nexport interface HookTimingOptions {\n  /** Threshold in ms before warning about slow hooks (default: 10000) */\n  slowThresholdMs?: number;\n  /** Maximum time allowed for hook pre-logic (until __MUX_EXEC__). Defaults to 10 seconds. */\n  preHookTimeoutMs?: number;\n  /** Maximum time allowed for hook post-logic (after tool result is sent). Defaults to 10 seconds. */\n  postHookTimeoutMs?: number;\n  /** Callback when hook phase exceeds threshold */\n  onSlowHook?: (phase: \"pre\" | \"post\", elapsedMs: number) => void;\n}\n\n/**\n * Execute a tool with hook wrapping.\n * Uses runtime.exec() so hooks work for both local and SSH workspaces.\n *\n * @param runtime Runtime to execute the hook in\n * @param hookPath Path to the hook executable\n * @param context Hook context with tool info\n * @param executeTool Callback to execute the actual tool (called when hook signals __MUX_EXEC__)\n * @param timingOptions Optional timing/warning configuration\n * @returns Hook result with success status and any stderr output\n */\nexport async function runWithHook<T>(\n  runtime: Runtime,\n  hookPath: string,\n  context: HookContext,\n  executeTool: () => Promise<T | AsyncIterable<T>>,\n  timingOptions?: HookTimingOptions\n): Promise<{ result: T | AsyncIterable<T> | undefined; hook: HookResult }> {\n  const slowThresholdMs = timingOptions?.slowThresholdMs ?? 10000;\n  const onSlowHook = timingOptions?.onSlowHook;\n  const preHookTimeoutMs = timingOptions?.preHookTimeoutMs ?? DEFAULT_HOOK_PHASE_TIMEOUT_MS;\n  const postHookTimeoutMs = timingOptions?.postHookTimeoutMs ?? DEFAULT_HOOK_PHASE_TIMEOUT_MS;\n  const hookStartTime = Date.now();\n\n  // Generate a unique marker for this invocation to prevent accidental triggers\n  const execMarker = `${EXEC_MARKER_PREFIX}${crypto.randomUUID().replace(/-/g, \"\")}`;\n\n  let toolInputPath: string | undefined;\n  let toolInputEnv = context.toolInput;\n  if (context.toolInput.length > TOOL_INPUT_ENV_LIMIT) {\n    // Tool input can be massive (file_edit_* old/new strings) and can exceed limits\n    // when injected as env vars (especially over SSH, where env is embedded into a\n    // single bash -c command string). Prefer writing the full JSON to a temp file.\n    try {\n      const tempDir = context.runtimeTempDir ?? \"/tmp\";\n      toolInputPath = joinPathLike(\n        tempDir,\n        `mux-tool-input-${Date.now()}-${crypto.randomUUID()}.json`\n      );\n      await writeFileString(runtime, toolInputPath, context.toolInput);\n      toolInputEnv = \"__MUX_TOOL_INPUT_FILE__\";\n    } catch (err) {\n      log.debug(\"[hooks] Failed to write tool input to temp file; falling back to truncation\", {\n        error: err,\n      });\n      toolInputPath = undefined;\n      toolInputEnv = context.toolInput.slice(0, TOOL_INPUT_ENV_LIMIT);\n    }\n  }\n\n  const toolInputValueForEnv = getToolInputValueForEnv(context);\n\n  const hookEnv: Record<string, string> = {\n    ...(context.env ?? {}),\n    MUX_TOOL: context.tool,\n    ...flattenToolHookValueToEnv(toolInputValueForEnv, \"MUX_TOOL_INPUT\", {\n      maxValueLength: TOOL_INPUT_ENV_LIMIT,\n      maxVars: FLATTENED_TOOL_ENV_MAX_VARS,\n      maxArrayLength: FLATTENED_TOOL_ENV_MAX_ARRAY_LENGTH,\n    }),\n    // Ensure the base JSON env var cannot be overwritten by flattened fields.\n    MUX_TOOL_INPUT: toolInputEnv,\n    MUX_WORKSPACE_ID: context.workspaceId,\n    MUX_PROJECT_DIR: context.projectDir,\n    MUX_EXEC: execMarker,\n  };\n  if (toolInputPath) {\n    hookEnv.MUX_TOOL_INPUT_PATH = toolInputPath;\n  }\n\n  const abortController = new AbortController();\n  let timeoutPhase: \"pre\" | \"post\" | \"external\" | undefined;\n  let preTimeoutHandle: ReturnType<typeof setTimeout> | undefined;\n  let postTimeoutHandle: ReturnType<typeof setTimeout> | undefined;\n\n  // Forward external abort signal (e.g., workspace deletion)\n  if (context.abortSignal) {\n    if (context.abortSignal.aborted) {\n      timeoutPhase = \"external\";\n      abortController.abort();\n    } else {\n      context.abortSignal.addEventListener(\n        \"abort\",\n        () => {\n          timeoutPhase = \"external\";\n          abortController.abort();\n        },\n        { once: true }\n      );\n    }\n  }\n\n  if (preHookTimeoutMs > 0) {\n    preTimeoutHandle = setTimeout(() => {\n      timeoutPhase = \"pre\";\n      abortController.abort();\n    }, preHookTimeoutMs);\n  }\n\n  let stream;\n  try {\n    // Shell-escape the hook path to handle spaces and special characters\n    // runtime.exec() uses bash -c, so unquoted paths would break\n    stream = await runtime.exec(shellEscape(hookPath), {\n      cwd: context.projectDir,\n      env: hookEnv,\n      abortSignal: abortController.signal,\n    });\n  } catch (err) {\n    if (preTimeoutHandle) {\n      clearTimeout(preTimeoutHandle);\n      preTimeoutHandle = undefined;\n    }\n    log.error(\"[hooks] Failed to spawn hook\", { hookPath, error: err });\n    if (toolInputPath) {\n      try {\n        await execBuffered(runtime, `rm -f ${shellEscape(toolInputPath)}`, {\n          cwd: context.projectDir,\n          timeout: 5,\n        });\n      } catch {\n        // Best-effort cleanup\n      }\n    }\n    return {\n      result: undefined,\n      hook: {\n        success: false,\n        stdoutBeforeExec: \"\",\n        stdout: \"\",\n        stderr: `Failed to execute hook: ${err instanceof Error ? err.message : String(err)}`,\n        exitCode: -1,\n        toolExecuted: false,\n      },\n    };\n  }\n\n  let toolResult: T | AsyncIterable<T> | undefined;\n  let toolError: Error | undefined;\n  let hookStdinWriteError: Error | undefined;\n  let toolExecuted = false;\n  let toolResultSentTime: number | undefined;\n  let stderrOutput = \"\";\n  let stdoutBuffer = \"\";\n  let stdoutBeforeExec = \"\";\n  let stdoutAfterMarker = \"\";\n  let toolPromise: Promise<void> | undefined;\n\n  // Read stderr in background\n  const stderrReader = stream.stderr.getReader();\n  const stderrPromise = (async () => {\n    const decoder = new TextDecoder();\n    try {\n      while (true) {\n        const { done, value } = await stderrReader.read();\n        if (done) break;\n        stderrOutput += decoder.decode(value, { stream: true });\n      }\n    } catch {\n      // Ignore stream errors (e.g. abort)\n    } finally {\n      stderrReader.releaseLock();\n    }\n  })();\n\n  // Read stdout, watching for __MUX_EXEC__ marker\n  const stdoutReader = stream.stdout.getReader();\n  const decoder = new TextDecoder();\n  try {\n    while (true) {\n      const { done, value } = await stdoutReader.read();\n      if (done) break;\n\n      const chunk = decoder.decode(value, { stream: true });\n\n      if (toolExecuted) {\n        // After marker: capture for hook output\n        stdoutAfterMarker += chunk;\n        continue;\n      }\n\n      stdoutBuffer += chunk;\n\n      const markerIdx = stdoutBuffer.indexOf(execMarker);\n      if (markerIdx === -1) {\n        continue;\n      }\n\n      // Marker detected: allow tool execution.\n      // Stop the pre-hook timeout clock and start the tool.\n      if (preTimeoutHandle) {\n        clearTimeout(preTimeoutHandle);\n        preTimeoutHandle = undefined;\n      }\n\n      // Check pre-hook timing before marking as executed\n      const preHookElapsed = Date.now() - hookStartTime;\n      if (onSlowHook && preHookElapsed > slowThresholdMs) {\n        onSlowHook(\"pre\", preHookElapsed);\n      }\n\n      toolExecuted = true;\n      stdoutBeforeExec = stdoutBuffer.slice(0, markerIdx);\n      stdoutAfterMarker = stdoutBuffer.slice(markerIdx + execMarker.length);\n\n      // Execute tool + send result to hook stdin in the background so we can\n      // continue draining stdout (hooks may log after __MUX_EXEC__).\n      toolPromise = (async () => {\n        try {\n          try {\n            toolResult = await executeTool();\n          } catch (err) {\n            toolError = err instanceof Error ? err : new Error(String(err));\n          }\n\n          const payload = toolError ? { error: toolError.message } : toolResult;\n          const payloadForHook = isAsyncIterable(payload) ? { streaming: true } : payload;\n\n          const writer = stream.stdin.getWriter();\n          try {\n            await writer.write(new TextEncoder().encode(JSON.stringify(payloadForHook) + \"\\n\"));\n          } catch (err) {\n            hookStdinWriteError = err instanceof Error ? err : new Error(String(err));\n          } finally {\n            try {\n              await writer.close();\n            } catch {\n              // Ignore close errors (e.g. EPIPE if hook exited)\n            }\n            toolResultSentTime = Date.now();\n\n            if (postHookTimeoutMs > 0) {\n              postTimeoutHandle = setTimeout(() => {\n                timeoutPhase = \"post\";\n                abortController.abort();\n              }, postHookTimeoutMs);\n            }\n          }\n        } catch (err) {\n          // This should never throw, but guard to avoid unhandled rejections.\n          hookStdinWriteError = err instanceof Error ? err : new Error(String(err));\n        }\n      })();\n    }\n  } catch {\n    // Ignore stream errors (e.g. abort)\n  } finally {\n    stdoutReader.releaseLock();\n  }\n\n  // If hook exited before __MUX_EXEC__, close stdin\n  if (!toolExecuted) {\n    // Cancel the pre-hook timeout.\n    if (preTimeoutHandle) {\n      clearTimeout(preTimeoutHandle);\n      preTimeoutHandle = undefined;\n    }\n    const writer = stream.stdin.getWriter();\n    try {\n      await writer.close();\n    } catch {\n      // Ignore close errors (e.g. hook already exited)\n    }\n  }\n\n  // Wait for tool execution (if started), stderr collection, and exit code\n  await toolPromise;\n  await stderrPromise;\n  const exitCode = await stream.exitCode;\n\n  if (postTimeoutHandle) {\n    clearTimeout(postTimeoutHandle);\n    postTimeoutHandle = undefined;\n  }\n\n  // Check post-hook timing (time from result sent to hook exit)\n  if (onSlowHook && toolResultSentTime) {\n    const postHookElapsed = Date.now() - toolResultSentTime;\n    if (postHookElapsed > slowThresholdMs) {\n      onSlowHook(\"post\", postHookElapsed);\n    }\n  }\n\n  if (timeoutPhase === \"pre\") {\n    stderrOutput += `\\nHook timed out before $MUX_EXEC marker (${preHookTimeoutMs}ms)`;\n  } else if (timeoutPhase === \"post\") {\n    stderrOutput += `\\nHook timed out after tool result was sent (${postHookTimeoutMs}ms)`;\n  } else if (timeoutPhase === \"external\") {\n    stderrOutput += `\\nHook aborted (workspace deleted or request cancelled)`;\n  }\n  if (hookStdinWriteError) {\n    stderrOutput += `\\nFailed to write tool result to hook stdin: ${hookStdinWriteError.message}`;\n  }\n\n  if (toolInputPath) {\n    try {\n      await execBuffered(runtime, `rm -f ${shellEscape(toolInputPath)}`, {\n        cwd: context.projectDir,\n        timeout: 5,\n      });\n    } catch {\n      // Best-effort cleanup\n    }\n  }\n\n  // If tool threw an error, rethrow it after hook completes\n  // This ensures tool failures propagate even when hooks are present\n  if (toolError) {\n    throw toolError;\n  }\n\n  return {\n    result: toolResult,\n    hook: {\n      success: exitCode === 0,\n      stdoutBeforeExec: (toolExecuted ? stdoutBeforeExec : stdoutBuffer).trim(),\n      stdout: stdoutAfterMarker.trim(),\n      stderr: stderrOutput.trim(),\n      exitCode,\n      toolExecuted,\n    },\n  };\n}\n\n/** Result from running a pre-hook */\nexport interface PreHookResult {\n  /** Whether the tool is allowed to proceed (exit code 0) */\n  allowed: boolean;\n  /** Combined stdout + stderr output */\n  output: string;\n  /** Hook process exit code */\n  exitCode: number;\n}\n\n/** Result from running a post-hook */\nexport interface PostHookResult {\n  /** Whether the hook succeeded (exit code 0) */\n  success: boolean;\n  /** Combined stdout + stderr output */\n  output: string;\n  /** Hook process exit code */\n  exitCode: number;\n}\n\n/** Context for pre/post hooks (simpler than HookContext) */\nexport interface SimpleHookContext {\n  /** Tool name */\n  tool: string;\n  /** Tool input as JSON string */\n  toolInput: string;\n  /**\n   * Tool input as a structured value (best-effort), used for flattened env vars.\n   *\n   * Optional for backwards compatibility; when omitted we'll attempt to parse\n   * `toolInput` as JSON.\n   */\n  toolInputValue?: unknown;\n  /** Workspace ID */\n  workspaceId: string;\n  /** Project directory */\n  projectDir: string;\n  /** Runtime temp dir for scratch files */\n  runtimeTempDir?: string;\n  /** Additional environment variables */\n  env?: Record<string, string>;\n  /** External abort signal */\n  abortSignal?: AbortSignal;\n}\n\n/** Options for pre/post hook execution */\nexport interface SimpleHookOptions {\n  /** Timeout in ms (default: 5 minutes) */\n  timeoutMs?: number;\n}\n\n/**\n * Run a pre-hook (tool_pre) before tool execution.\n * Simple model: spawn hook, wait for exit, check exit code.\n * Exit 0 = allow tool, non-zero = block tool.\n */\nexport async function runPreHook(\n  runtime: Runtime,\n  hookPath: string,\n  context: SimpleHookContext,\n  options?: SimpleHookOptions\n): Promise<PreHookResult> {\n  const timeoutMs = options?.timeoutMs ?? DEFAULT_HOOK_PHASE_TIMEOUT_MS;\n\n  // Prepare tool input (file if large)\n  const { toolInputEnv, toolInputPath, cleanup } = await prepareToolInput(\n    runtime,\n    context.toolInput,\n    context.runtimeTempDir,\n    context.projectDir\n  );\n\n  const toolInputValueForEnv = getToolInputValueForEnv(context);\n\n  const hookEnv: Record<string, string> = {\n    ...(context.env ?? {}),\n    MUX_TOOL: context.tool,\n    ...flattenToolHookValueToEnv(toolInputValueForEnv, \"MUX_TOOL_INPUT\", {\n      maxValueLength: TOOL_INPUT_ENV_LIMIT,\n      maxVars: FLATTENED_TOOL_ENV_MAX_VARS,\n      maxArrayLength: FLATTENED_TOOL_ENV_MAX_ARRAY_LENGTH,\n    }),\n    // Ensure the base JSON env var cannot be overwritten by flattened fields.\n    MUX_TOOL_INPUT: toolInputEnv,\n    MUX_WORKSPACE_ID: context.workspaceId,\n    MUX_PROJECT_DIR: context.projectDir,\n  };\n  if (toolInputPath) {\n    hookEnv.MUX_TOOL_INPUT_PATH = toolInputPath;\n  }\n\n  try {\n    const result = await execBuffered(runtime, shellEscape(hookPath), {\n      cwd: context.projectDir,\n      env: hookEnv,\n      timeout: Math.ceil(timeoutMs / 1000),\n      abortSignal: context.abortSignal,\n    });\n\n    const output = [result.stdout, result.stderr].filter(Boolean).join(\"\\n\").trim();\n    return {\n      allowed: result.exitCode === 0,\n      output,\n      exitCode: result.exitCode ?? -1,\n    };\n  } catch (err) {\n    log.error(\"[hooks] Pre-hook execution failed\", { hookPath, error: err });\n    return {\n      allowed: false,\n      output: `Pre-hook failed: ${err instanceof Error ? err.message : String(err)}`,\n      exitCode: -1,\n    };\n  } finally {\n    await cleanup();\n  }\n}\n\n/**\n * Run a post-hook (tool_post) after tool execution.\n * Simple model: spawn hook with result in env/file, wait for exit.\n */\nexport async function runPostHook(\n  runtime: Runtime,\n  hookPath: string,\n  context: SimpleHookContext,\n  toolResult: unknown,\n  options?: SimpleHookOptions\n): Promise<PostHookResult> {\n  const timeoutMs = options?.timeoutMs ?? DEFAULT_HOOK_PHASE_TIMEOUT_MS;\n  const resultJson = JSON.stringify(toolResult);\n\n  // Prepare tool input (file if large)\n  const {\n    toolInputEnv,\n    toolInputPath,\n    cleanup: cleanupInput,\n  } = await prepareToolInput(\n    runtime,\n    context.toolInput,\n    context.runtimeTempDir,\n    context.projectDir\n  );\n\n  // Prepare tool result (best-effort file; env var placeholder if large)\n  const resultPath = joinPathLike(\n    context.runtimeTempDir ?? \"/tmp\",\n    `mux-tool-result-${Date.now()}-${crypto.randomUUID()}.json`\n  );\n  let resultPathForEnv: string | undefined;\n  let resultEnv = resultJson;\n  try {\n    await writeFileString(runtime, resultPath, resultJson);\n    resultPathForEnv = resultPath;\n    if (resultJson.length > TOOL_INPUT_ENV_LIMIT) {\n      resultEnv = \"__MUX_TOOL_RESULT_FILE__\";\n    }\n  } catch (err) {\n    log.debug(\"[hooks] Failed to write tool result to temp file\", { error: err });\n    resultPathForEnv = undefined;\n    resultEnv = resultJson.slice(0, TOOL_INPUT_ENV_LIMIT);\n  }\n\n  const toolInputValueForEnv = getToolInputValueForEnv(context);\n\n  const hookEnv: Record<string, string> = {\n    ...(context.env ?? {}),\n    MUX_TOOL: context.tool,\n    ...flattenToolHookValueToEnv(toolInputValueForEnv, \"MUX_TOOL_INPUT\", {\n      maxValueLength: TOOL_INPUT_ENV_LIMIT,\n      maxVars: FLATTENED_TOOL_ENV_MAX_VARS,\n      maxArrayLength: FLATTENED_TOOL_ENV_MAX_ARRAY_LENGTH,\n    }),\n    ...flattenToolHookValueToEnv(toolResult, \"MUX_TOOL_RESULT\", {\n      maxValueLength: TOOL_INPUT_ENV_LIMIT,\n      maxVars: FLATTENED_TOOL_ENV_MAX_VARS,\n      maxArrayLength: FLATTENED_TOOL_ENV_MAX_ARRAY_LENGTH,\n    }),\n    // Ensure base JSON env vars cannot be overwritten by flattened fields.\n    MUX_TOOL_INPUT: toolInputEnv,\n    MUX_WORKSPACE_ID: context.workspaceId,\n    MUX_PROJECT_DIR: context.projectDir,\n    MUX_TOOL_RESULT: resultEnv,\n  };\n  if (toolInputPath) {\n    hookEnv.MUX_TOOL_INPUT_PATH = toolInputPath;\n  }\n  if (resultPathForEnv) {\n    hookEnv.MUX_TOOL_RESULT_PATH = resultPathForEnv;\n  }\n\n  const cleanup = async () => {\n    await cleanupInput();\n    if (!resultPathForEnv) return;\n\n    try {\n      await execBuffered(runtime, `rm -f ${shellEscape(resultPathForEnv)}`, {\n        cwd: context.projectDir,\n        timeout: 5,\n      });\n    } catch {\n      // Best-effort\n    }\n  };\n\n  try {\n    const result = await execBuffered(runtime, shellEscape(hookPath), {\n      cwd: context.projectDir,\n      env: hookEnv,\n      timeout: Math.ceil(timeoutMs / 1000),\n      abortSignal: context.abortSignal,\n    });\n\n    const output = [result.stdout, result.stderr].filter(Boolean).join(\"\\n\").trim();\n    return {\n      success: result.exitCode === 0,\n      output,\n      exitCode: result.exitCode ?? -1,\n    };\n  } catch (err) {\n    log.error(\"[hooks] Post-hook execution failed\", { hookPath, error: err });\n    return {\n      success: false,\n      output: `Post-hook failed: ${err instanceof Error ? err.message : String(err)}`,\n      exitCode: -1,\n    };\n  } finally {\n    await cleanup();\n  }\n}\n\n/** Helper to prepare tool input (write to file if large) */\nasync function prepareToolInput(\n  runtime: Runtime,\n  toolInput: string,\n  runtimeTempDir: string | undefined,\n  projectDir: string\n): Promise<{\n  toolInputEnv: string;\n  toolInputPath: string | undefined;\n  cleanup: () => Promise<void>;\n}> {\n  let toolInputPath: string | undefined;\n  let toolInputEnv = toolInput;\n\n  if (toolInput.length > TOOL_INPUT_ENV_LIMIT) {\n    try {\n      const tempDir = runtimeTempDir ?? \"/tmp\";\n      toolInputPath = joinPathLike(\n        tempDir,\n        `mux-tool-input-${Date.now()}-${crypto.randomUUID()}.json`\n      );\n      await writeFileString(runtime, toolInputPath, toolInput);\n      toolInputEnv = \"__MUX_TOOL_INPUT_FILE__\";\n    } catch (err) {\n      log.debug(\"[hooks] Failed to write tool input to temp file\", { error: err });\n      toolInputPath = undefined;\n      toolInputEnv = toolInput.slice(0, TOOL_INPUT_ENV_LIMIT);\n    }\n  }\n\n  const cleanup = async () => {\n    if (toolInputPath) {\n      try {\n        await execBuffered(runtime, `rm -f ${shellEscape(toolInputPath)}`, {\n          cwd: projectDir,\n          timeout: 5,\n        });\n      } catch {\n        // Best-effort\n      }\n    }\n  };\n\n  return { toolInputEnv, toolInputPath, cleanup };\n}\n"]}