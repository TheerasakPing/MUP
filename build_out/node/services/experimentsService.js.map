{"version":3,"file":"experimentsService.js","sourceRoot":"","sources":["../../../src/node/services/experimentsService.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from \"@/common/utils/assert\";\r\nimport { EXPERIMENTS, type ExperimentId } from \"@/common/constants/experiments\";\r\nimport { getMuxHome } from \"@/common/constants/paths\";\r\nimport type { ExperimentValue } from \"@/common/orpc/types\";\r\nimport { log } from \"@/node/services/log\";\r\nimport type { TelemetryService } from \"@/node/services/telemetryService\";\r\n\r\nimport * as fs from \"fs/promises\";\r\nimport writeFileAtomic from \"write-file-atomic\";\r\nimport * as path from \"path\";\r\n\r\nexport type { ExperimentValue };\r\n\r\ninterface CachedVariant {\r\n  value: string | boolean;\r\n  fetchedAtMs: number;\r\n  source: \"posthog\" | \"cache\";\r\n}\r\n\r\ninterface ExperimentsCacheFile {\r\n  version: 1;\r\n  experiments: Record<string, { value: string | boolean; fetchedAtMs: number }>;\r\n}\r\n\r\nconst CACHE_FILE_NAME = \"feature_flags.json\";\r\nconst CACHE_FILE_VERSION = 1;\r\nconst DEFAULT_CACHE_TTL_MS = 10 * 60 * 1000;\r\n\r\nfunction isRecord(value: unknown): value is Record<string, unknown> {\r\n  return typeof value === \"object\" && value !== null;\r\n}\r\n\r\n/**\r\n * Backend experiments service.\r\n *\r\n * Evaluates PostHog feature flags in the main process (via posthog-node) and exposes\r\n * the current assignments to the renderer via oRPC.\r\n *\r\n * Design goals:\r\n * - Never block user flows on network calls (use cached values and refresh in background)\r\n * - Fail closed (unknown = control/disabled)\r\n * - Avoid calling PostHog when telemetry is disabled\r\n */\r\nexport class ExperimentsService {\r\n  private readonly telemetryService: TelemetryService;\r\n  private readonly muxHome: string;\r\n  private readonly cacheFilePath: string;\r\n  private readonly cacheTtlMs: number;\r\n\r\n  private readonly cachedVariants = new Map<ExperimentId, CachedVariant>();\r\n  private readonly refreshInFlight = new Map<ExperimentId, Promise<void>>();\r\n\r\n  private cacheLoaded = false;\r\n\r\n  constructor(options: {\r\n    telemetryService: TelemetryService;\r\n    muxHome?: string;\r\n    cacheTtlMs?: number;\r\n  }) {\r\n    this.telemetryService = options.telemetryService;\r\n    this.muxHome = options.muxHome ?? getMuxHome();\r\n    this.cacheFilePath = path.join(this.muxHome, CACHE_FILE_NAME);\r\n    this.cacheTtlMs = options.cacheTtlMs ?? DEFAULT_CACHE_TTL_MS;\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    if (this.cacheLoaded) {\r\n      return;\r\n    }\r\n\r\n    await this.loadCacheFromDisk();\r\n    this.cacheLoaded = true;\r\n\r\n    // Populate telemetry properties from cache immediately so variant breakdowns\r\n    // are present even before a background refresh completes.\r\n    for (const [experimentId, cached] of this.cachedVariants) {\r\n      this.telemetryService.setFeatureFlagVariant(this.getFlagKey(experimentId), cached.value);\r\n    }\r\n\r\n    // Refresh in background (best effort). We only refresh values that are stale or missing\r\n    // to avoid unnecessary network calls during startup.\r\n    if (this.isRemoteEvaluationEnabled()) {\r\n      for (const experimentId of Object.keys(EXPERIMENTS) as ExperimentId[]) {\r\n        this.maybeRefreshInBackground(experimentId);\r\n      }\r\n    }\r\n  }\r\n\r\n  isRemoteEvaluationEnabled(): boolean {\r\n    return (\r\n      this.telemetryService.getPostHogClient() !== null &&\r\n      this.telemetryService.getDistinctId() !== null\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return current values for all known experiments.\r\n   * This is used to render Settings â†’ Experiments.\r\n   */\r\n  getAll(): Record<ExperimentId, ExperimentValue> {\r\n    const result: Partial<Record<ExperimentId, ExperimentValue>> = {};\r\n\r\n    for (const experimentId of Object.keys(EXPERIMENTS) as ExperimentId[]) {\r\n      result[experimentId] = this.getExperimentValue(experimentId);\r\n    }\r\n\r\n    return result as Record<ExperimentId, ExperimentValue>;\r\n  }\r\n\r\n  getExperimentValue(experimentId: ExperimentId): ExperimentValue {\r\n    assert(experimentId in EXPERIMENTS, `Unknown experimentId: ${experimentId}`);\r\n\r\n    if (!this.isRemoteEvaluationEnabled()) {\r\n      return { value: null, source: \"disabled\" };\r\n    }\r\n\r\n    const cached = this.cachedVariants.get(experimentId);\r\n    if (!cached) {\r\n      // No cached value yet. Fail closed, but kick off a background refresh.\r\n      this.maybeRefreshInBackground(experimentId);\r\n      return { value: null, source: \"cache\" };\r\n    }\r\n\r\n    this.maybeRefreshInBackground(experimentId);\r\n    return { value: cached.value, source: cached.source };\r\n  }\r\n\r\n  /**\r\n   * Convert an experiment assignment to a boolean gate.\r\n   *\r\n   * NOTE: This intentionally does not block on network calls.\r\n   */\r\n  isExperimentEnabled(experimentId: ExperimentId): boolean {\r\n    const value = this.getExperimentValue(experimentId).value;\r\n\r\n    // PostHog can return either boolean flags or string variants.\r\n    if (typeof value === \"boolean\") {\r\n      return value;\r\n    }\r\n\r\n    if (typeof value === \"string\") {\r\n      // For now, treat variant \"test\" as enabled for experiments with control/test variants.\r\n      // If we add experiments with different variant semantics, add a mapping per experiment.\r\n      return value === \"test\";\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  async refreshAll(): Promise<void> {\r\n    await this.ensureInitialized();\r\n\r\n    if (!this.isRemoteEvaluationEnabled()) {\r\n      return;\r\n    }\r\n\r\n    await Promise.all(\r\n      (Object.keys(EXPERIMENTS) as ExperimentId[]).map(async (experimentId) => {\r\n        await this.refreshExperiment(experimentId);\r\n      })\r\n    );\r\n  }\r\n\r\n  async refreshExperiment(experimentId: ExperimentId): Promise<void> {\r\n    await this.ensureInitialized();\r\n    assert(experimentId in EXPERIMENTS, `Unknown experimentId: ${experimentId}`);\r\n\r\n    if (!this.isRemoteEvaluationEnabled()) {\r\n      return;\r\n    }\r\n\r\n    const existing = this.refreshInFlight.get(experimentId);\r\n    if (existing) {\r\n      return existing;\r\n    }\r\n\r\n    const promise = this.refreshExperimentImpl(experimentId).finally(() => {\r\n      this.refreshInFlight.delete(experimentId);\r\n    });\r\n\r\n    this.refreshInFlight.set(experimentId, promise);\r\n    return promise;\r\n  }\r\n\r\n  private async refreshExperimentImpl(experimentId: ExperimentId): Promise<void> {\r\n    const client = this.telemetryService.getPostHogClient();\r\n    const distinctId = this.telemetryService.getDistinctId();\r\n    assert(client, \"PostHog client must exist when remote evaluation is enabled\");\r\n    assert(distinctId, \"distinctId must exist when remote evaluation is enabled\");\r\n\r\n    const flagKey = this.getFlagKey(experimentId);\r\n\r\n    try {\r\n      const value = await client.getFeatureFlag(flagKey, distinctId);\r\n      if (typeof value !== \"string\" && typeof value !== \"boolean\") {\r\n        return;\r\n      }\r\n\r\n      const cached: CachedVariant = {\r\n        value,\r\n        fetchedAtMs: Date.now(),\r\n        source: \"posthog\",\r\n      };\r\n\r\n      this.cachedVariants.set(experimentId, cached);\r\n      this.telemetryService.setFeatureFlagVariant(flagKey, value);\r\n\r\n      await this.writeCacheToDisk();\r\n    } catch (error) {\r\n      log.debug(\"Failed to refresh experiment from PostHog\", {\r\n        experimentId,\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  private maybeRefreshInBackground(experimentId: ExperimentId): void {\r\n    const cached = this.cachedVariants.get(experimentId);\r\n    if (!cached) {\r\n      void this.refreshExperiment(experimentId);\r\n      return;\r\n    }\r\n\r\n    if (Date.now() - cached.fetchedAtMs > this.cacheTtlMs) {\r\n      void this.refreshExperiment(experimentId);\r\n    }\r\n  }\r\n\r\n  private getFlagKey(experimentId: ExperimentId): string {\r\n    // Today, our experiment IDs are already PostHog flag keys.\r\n    // If that ever changes, this is the single mapping point.\r\n    return experimentId;\r\n  }\r\n\r\n  private async ensureInitialized(): Promise<void> {\r\n    if (this.cacheLoaded) {\r\n      return;\r\n    }\r\n\r\n    await this.initialize();\r\n    assert(this.cacheLoaded, \"ExperimentsService failed to initialize\");\r\n  }\r\n\r\n  private async loadCacheFromDisk(): Promise<void> {\r\n    try {\r\n      const raw = await fs.readFile(this.cacheFilePath, \"utf-8\");\r\n      const parsed = JSON.parse(raw) as unknown;\r\n\r\n      if (!isRecord(parsed)) {\r\n        return;\r\n      }\r\n\r\n      const version = parsed.version;\r\n      const experiments = parsed.experiments;\r\n\r\n      if (version !== CACHE_FILE_VERSION || !isRecord(experiments)) {\r\n        return;\r\n      }\r\n\r\n      for (const [key, value] of Object.entries(experiments)) {\r\n        if (!(key in EXPERIMENTS) || !isRecord(value)) {\r\n          continue;\r\n        }\r\n\r\n        const fetchedAtMs = value.fetchedAtMs;\r\n        const variant = value.value;\r\n\r\n        if (typeof fetchedAtMs !== \"number\" || !Number.isFinite(fetchedAtMs)) {\r\n          continue;\r\n        }\r\n\r\n        if (typeof variant !== \"string\" && typeof variant !== \"boolean\") {\r\n          continue;\r\n        }\r\n\r\n        this.cachedVariants.set(key as ExperimentId, {\r\n          value: variant,\r\n          fetchedAtMs,\r\n          source: \"cache\",\r\n        });\r\n      }\r\n    } catch {\r\n      // Ignore missing/corrupt cache\r\n    }\r\n  }\r\n\r\n  private async writeCacheToDisk(): Promise<void> {\r\n    try {\r\n      const experiments: ExperimentsCacheFile[\"experiments\"] = {};\r\n      for (const [experimentId, cached] of this.cachedVariants) {\r\n        experiments[experimentId] = {\r\n          value: cached.value,\r\n          fetchedAtMs: cached.fetchedAtMs,\r\n        };\r\n      }\r\n\r\n      const payload: ExperimentsCacheFile = {\r\n        version: CACHE_FILE_VERSION,\r\n        experiments,\r\n      };\r\n\r\n      await fs.mkdir(this.muxHome, { recursive: true });\r\n      await writeFileAtomic(this.cacheFilePath, JSON.stringify(payload, null, 2), \"utf-8\");\r\n    } catch {\r\n      // Ignore cache persistence failures\r\n    }\r\n  }\r\n}\r\n"]}