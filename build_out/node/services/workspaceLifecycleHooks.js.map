{"version":3,"file":"workspaceLifecycleHooks.js","sourceRoot":"","sources":["../../../src/node/services/workspaceLifecycleHooks.ts"],"names":[],"mappings":";;;AAEA,kDAAgD;AAChD,6CAA0C;AAgB1C,SAAS,oBAAoB,CAAC,KAAc,EAAU;IACpD,MAAM,GAAG,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IACnE,4FAA4F;IAC5F,MAAM,UAAU,GAAG,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;IACpD,OAAO,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,IAAI,eAAe,CAAC;AAAA,CACpD;AAED;;;;;;GAMG;AACH;IACmB,kBAAkB,GAAwB,EAAE,CAAC;IAC7C,mBAAmB,GAAyB,EAAE,CAAC;IAEhE,qBAAqB,CAAC,IAAuB,EAAQ;QACnD,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACpC;IAED,sBAAsB,CAAC,IAAwB,EAAQ;QACrD,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAAA,CACrC;IAED,KAAK,CAAC,gBAAgB,CAAC,IAA2B,EAAyB;QACzE,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC3C,IAAI,CAAC;gBACH,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,CAAC;gBAChC,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;oBACpB,OAAO,IAAA,YAAG,EAAC,oBAAoB,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;gBACjD,CAAC;YACH,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,OAAO,IAAA,YAAG,EAAC,6BAA6B,oBAAoB,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YACzE,CAAC;QACH,CAAC;QAED,OAAO,IAAA,WAAE,EAAC,SAAS,CAAC,CAAC;IAAA,CACtB;IAED,KAAK,CAAC,iBAAiB,CAAC,IAA4B,EAAiB;QACnE,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC5C,IAAI,CAAC;gBACH,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,CAAC;gBAChC,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;oBACpB,SAAG,CAAC,KAAK,CAAC,4BAA4B,EAAE;wBACtC,WAAW,EAAE,IAAI,CAAC,WAAW;wBAC7B,KAAK,EAAE,oBAAoB,CAAC,MAAM,CAAC,KAAK,CAAC;qBAC1C,CAAC,CAAC;gBACL,CAAC;YACH,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,SAAG,CAAC,KAAK,CAAC,2BAA2B,EAAE;oBACrC,WAAW,EAAE,IAAI,CAAC,WAAW;oBAC7B,KAAK,EAAE,oBAAoB,CAAC,KAAK,CAAC;iBACnC,CAAC,CAAC;YACL,CAAC;QACH,CAAC;IAAA,CACF;CACF","sourcesContent":["import type { WorkspaceMetadata } from \"@/common/types/workspace\";\r\nimport type { Result } from \"@/common/types/result\";\r\nimport { Ok, Err } from \"@/common/types/result\";\r\nimport { log } from \"@/node/services/log\";\r\n\r\nexport interface BeforeArchiveHookArgs {\r\n  workspaceId: string;\r\n  workspaceMetadata: WorkspaceMetadata;\r\n}\r\n\r\nexport type BeforeArchiveHook = (args: BeforeArchiveHookArgs) => Promise<Result<void>>;\r\n\r\nexport interface AfterUnarchiveHookArgs {\r\n  workspaceId: string;\r\n  workspaceMetadata: WorkspaceMetadata;\r\n}\r\n\r\nexport type AfterUnarchiveHook = (args: AfterUnarchiveHookArgs) => Promise<Result<void>>;\r\n\r\nfunction sanitizeErrorMessage(error: unknown): string {\r\n  const raw = error instanceof Error ? error.message : String(error);\r\n  // Keep single-line, capped error messages to avoid leaking stack traces or long CLI output.\r\n  const singleLine = raw.split(\"\\n\")[0]?.trim() ?? \"\";\r\n  return singleLine.slice(0, 200) || \"Unknown error\";\r\n}\r\n\r\n/**\r\n * Backend registry for workspace lifecycle hooks.\r\n *\r\n * Hooks run in-process (sequentially).\r\n * - beforeArchive hooks may block the operation if they return Err.\r\n * - afterUnarchive hooks are best-effort and never block unarchive.\r\n */\r\nexport class WorkspaceLifecycleHooks {\r\n  private readonly beforeArchiveHooks: BeforeArchiveHook[] = [];\r\n  private readonly afterUnarchiveHooks: AfterUnarchiveHook[] = [];\r\n\r\n  registerBeforeArchive(hook: BeforeArchiveHook): void {\r\n    this.beforeArchiveHooks.push(hook);\r\n  }\r\n\r\n  registerAfterUnarchive(hook: AfterUnarchiveHook): void {\r\n    this.afterUnarchiveHooks.push(hook);\r\n  }\r\n\r\n  async runBeforeArchive(args: BeforeArchiveHookArgs): Promise<Result<void>> {\r\n    for (const hook of this.beforeArchiveHooks) {\r\n      try {\r\n        const result = await hook(args);\r\n        if (!result.success) {\r\n          return Err(sanitizeErrorMessage(result.error));\r\n        }\r\n      } catch (error) {\r\n        return Err(`beforeArchive hook threw: ${sanitizeErrorMessage(error)}`);\r\n      }\r\n    }\r\n\r\n    return Ok(undefined);\r\n  }\r\n\r\n  async runAfterUnarchive(args: AfterUnarchiveHookArgs): Promise<void> {\r\n    for (const hook of this.afterUnarchiveHooks) {\r\n      try {\r\n        const result = await hook(args);\r\n        if (!result.success) {\r\n          log.debug(\"afterUnarchive hook failed\", {\r\n            workspaceId: args.workspaceId,\r\n            error: sanitizeErrorMessage(result.error),\r\n          });\r\n        }\r\n      } catch (error) {\r\n        log.debug(\"afterUnarchive hook threw\", {\r\n          workspaceId: args.workspaceId,\r\n          error: sanitizeErrorMessage(error),\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}