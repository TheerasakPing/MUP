"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.McpOauthService = void 0;
exports.parseBearerWwwAuthenticate = parseBearerWwwAuthenticate;
const crypto = __importStar(require("crypto"));
const http = __importStar(require("http"));
const path = __importStar(require("path"));
const fsPromises = __importStar(require("fs/promises"));
const write_file_atomic_1 = __importDefault(require("write-file-atomic"));
const mcp_1 = require("@ai-sdk/mcp");
const log_1 = require("../../node/services/log");
const result_1 = require("../../common/types/result");
const utils_1 = require("../../common/telemetry/utils");
const pathUtils_1 = require("../../node/utils/pathUtils");
const mutexMap_1 = require("../../node/utils/concurrency/mutexMap");
const DEFAULT_DESKTOP_TIMEOUT_MS = 5 * 60 * 1000;
const DEFAULT_SERVER_TIMEOUT_MS = 10 * 60 * 1000;
const COMPLETED_FLOW_TTL_MS = 60 * 1000;
const STORE_FILE_NAME = "mcp-oauth.json";
function createEmptyStore() {
    return { version: 2, entries: {} };
}
function closeServer(server) {
    return new Promise((resolve) => {
        server.close(() => resolve());
    });
}
function createDeferred() {
    let resolve;
    const promise = new Promise((res) => {
        resolve = res;
    });
    return { promise, resolve };
}
function isPlainObject(value) {
    return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
function normalizeProjectPathKey(projectPath) {
    // Keep keys stable across callers; config already strips trailing slashes.
    return (0, pathUtils_1.stripTrailingSlashes)(projectPath);
}
/**
 * Normalizes an MCP server URL only for keying/comparing stored credentials.
 *
 * Important: This MUST NOT be used for OAuth discovery/authorization requests.
 * Removing a trailing slash changes how relative URLs resolve (e.g. /mcp vs /mcp/).
 */
function normalizeServerUrlForComparison(serverUrl) {
    try {
        const url = new URL(serverUrl);
        // Avoid accidental mismatch from an irrelevant hash.
        url.hash = "";
        // Normalize trailing slashes for comparison (treat /foo and /foo/ as equivalent).
        if (url.pathname.endsWith("/") && url.pathname !== "/") {
            url.pathname = url.pathname.slice(0, -1);
        }
        return url.toString();
    }
    catch {
        return null;
    }
}
/**
 * Sanitizes an MCP server URL for network requests.
 *
 * This intentionally does not normalize the pathname; we only strip the hash.
 */
function sanitizeServerUrlForRequest(serverUrl) {
    try {
        const url = new URL(serverUrl);
        if (url.protocol !== "http:" && url.protocol !== "https:") {
            return null;
        }
        // Avoid accidental mismatch from an irrelevant hash.
        url.hash = "";
        return url.toString();
    }
    catch {
        return null;
    }
}
function parseBearerWwwAuthenticate(header) {
    const raw = header;
    // Minimal, spec-friendly extraction. We intentionally avoid implementing a full
    // RFC 7235 challenge parser; we only care about a subset of Bearer params.
    if (!/\bbearer\b/i.test(raw)) {
        return null;
    }
    const scopeMatch = /\bscope="([^"]*)"/i.exec(raw) ?? /\bscope=([^,\s]+)/i.exec(raw);
    const scope = scopeMatch ? scopeMatch[1] : undefined;
    const resourceMetadataMatch = /\bresource_metadata="([^"]*)"/i.exec(raw) ?? /\bresource_metadata=([^,\s]+)/i.exec(raw);
    let resourceMetadataUrl;
    if (resourceMetadataMatch) {
        try {
            resourceMetadataUrl = new URL(resourceMetadataMatch[1]);
        }
        catch {
            // Ignore invalid URLs.
        }
    }
    return {
        raw,
        scope,
        resourceMetadataUrl,
    };
}
async function probeServerForBearerChallenge(serverUrl) {
    const requestUrl = sanitizeServerUrlForRequest(serverUrl);
    if (!requestUrl) {
        return null;
    }
    // Best-effort probe: do a simple unauthenticated request and parse WWW-Authenticate.
    //
    // We intentionally avoid sending MCP-specific headers here because the probe is
    // only used to extract OAuth hints (scope/resource_metadata) and must not be
    // protocol-version coupled.
    const abortController = new AbortController();
    const timeout = setTimeout(() => abortController.abort(), 5_000);
    try {
        const response = await fetch(requestUrl, {
            method: "GET",
            headers: {
                Accept: "text/event-stream",
            },
            redirect: "manual",
            signal: abortController.signal,
        });
        const header = response.headers.get("www-authenticate") ?? response.headers.get("WWW-Authenticate");
        if (!header) {
            return null;
        }
        return parseBearerWwwAuthenticate(header);
    }
    catch {
        return null;
    }
    finally {
        clearTimeout(timeout);
    }
}
function parseStoredCredentials(value) {
    if (!isPlainObject(value)) {
        return null;
    }
    const serverUrlRaw = typeof value.serverUrl === "string" ? value.serverUrl : null;
    const updatedAtMs = typeof value.updatedAtMs === "number" ? value.updatedAtMs : null;
    if (!serverUrlRaw || updatedAtMs === null || !Number.isFinite(updatedAtMs)) {
        return null;
    }
    const serverUrl = normalizeServerUrlForComparison(serverUrlRaw);
    if (!serverUrl) {
        return null;
    }
    const clientInformationRaw = value.clientInformation;
    const clientInformation = isPlainObject(clientInformationRaw)
        ? {
            client_id: typeof clientInformationRaw.client_id === "string" ? clientInformationRaw.client_id : "",
            client_secret: typeof clientInformationRaw.client_secret === "string"
                ? clientInformationRaw.client_secret
                : undefined,
            client_id_issued_at: typeof clientInformationRaw.client_id_issued_at === "number"
                ? clientInformationRaw.client_id_issued_at
                : undefined,
            client_secret_expires_at: typeof clientInformationRaw.client_secret_expires_at === "number"
                ? clientInformationRaw.client_secret_expires_at
                : undefined,
        }
        : undefined;
    if (clientInformation && !clientInformation.client_id) {
        // client_id is required if the object is present.
        return null;
    }
    const tokensRaw = value.tokens;
    const tokens = isPlainObject(tokensRaw)
        ? {
            access_token: typeof tokensRaw.access_token === "string" ? tokensRaw.access_token : "",
            id_token: typeof tokensRaw.id_token === "string" ? tokensRaw.id_token : undefined,
            token_type: typeof tokensRaw.token_type === "string" ? tokensRaw.token_type : "",
            expires_in: typeof tokensRaw.expires_in === "number" ? tokensRaw.expires_in : undefined,
            scope: typeof tokensRaw.scope === "string" ? tokensRaw.scope : undefined,
            refresh_token: typeof tokensRaw.refresh_token === "string" ? tokensRaw.refresh_token : undefined,
        }
        : undefined;
    if (tokens && (!tokens.access_token || !tokens.token_type)) {
        return null;
    }
    return {
        serverUrl,
        clientInformation,
        tokens,
        updatedAtMs,
    };
}
function parseStoreFile(raw) {
    try {
        const parsed = JSON.parse(raw);
        if (!isPlainObject(parsed)) {
            return null;
        }
        const version = parsed.version;
        if (version !== 1 && version !== 2) {
            return null;
        }
        const entriesRaw = parsed.entries;
        if (!isPlainObject(entriesRaw)) {
            return null;
        }
        if (version === 1) {
            const entries = {};
            for (const [projectPath, byServerRaw] of Object.entries(entriesRaw)) {
                if (!isPlainObject(byServerRaw)) {
                    continue;
                }
                const byServer = {};
                for (const [serverName, credRaw] of Object.entries(byServerRaw)) {
                    const creds = parseStoredCredentials(credRaw);
                    if (!creds) {
                        continue;
                    }
                    byServer[serverName] = creds;
                }
                if (Object.keys(byServer).length > 0) {
                    entries[projectPath] = byServer;
                }
            }
            return { version: 1, entries };
        }
        // v2
        const entries = {};
        for (const credRaw of Object.values(entriesRaw)) {
            const creds = parseStoredCredentials(credRaw);
            if (!creds) {
                continue;
            }
            const serverUrlKey = creds.serverUrl;
            const existing = entries[serverUrlKey];
            if (!existing || creds.updatedAtMs > existing.updatedAtMs) {
                entries[serverUrlKey] = creds;
            }
        }
        return { version: 2, entries };
    }
    catch {
        return null;
    }
}
function migrateStoreV1ToV2(store) {
    const entries = {};
    for (const byServer of Object.values(store.entries)) {
        for (const creds of Object.values(byServer)) {
            const serverUrlKey = normalizeServerUrlForComparison(creds.serverUrl);
            if (!serverUrlKey) {
                continue;
            }
            const existing = entries[serverUrlKey];
            if (!existing || creds.updatedAtMs > existing.updatedAtMs) {
                entries[serverUrlKey] = {
                    ...creds,
                    serverUrl: serverUrlKey,
                };
            }
        }
    }
    return { version: 2, entries };
}
class McpOauthService {
    config;
    mcpConfigService;
    windowService;
    storeFilePath;
    storeLock = new mutexMap_1.MutexMap();
    store = null;
    desktopFlows = new Map();
    serverFlows = new Map();
    telemetryService;
    constructor(config, mcpConfigService, windowService, telemetryService) {
        this.config = config;
        this.mcpConfigService = mcpConfigService;
        this.windowService = windowService;
        this.telemetryService = telemetryService;
        this.storeFilePath = path.join(config.rootDir, STORE_FILE_NAME);
    }
    async dispose() {
        // Best-effort: cancel all in-flight flows.
        const desktopFlowIds = [...this.desktopFlows.keys()];
        const serverFlowIds = [...this.serverFlows.keys()];
        await Promise.all([
            ...desktopFlowIds.map((id) => this.finishDesktopFlow(id, (0, result_1.Err)("App shutting down"))),
            ...serverFlowIds.map((id) => this.finishServerFlow(id, (0, result_1.Err)("App shutting down"))),
        ]);
        for (const flow of this.desktopFlows.values()) {
            clearTimeout(flow.timeout);
            if (flow.cleanupTimeout !== null) {
                clearTimeout(flow.cleanupTimeout);
            }
        }
        for (const flow of this.serverFlows.values()) {
            clearTimeout(flow.timeout);
            if (flow.cleanupTimeout !== null) {
                clearTimeout(flow.cleanupTimeout);
            }
        }
        this.desktopFlows.clear();
        this.serverFlows.clear();
    }
    async getAuthStatus(input) {
        const normalizedServerUrl = normalizeServerUrlForComparison(input.serverUrl);
        if (!normalizedServerUrl) {
            return { isLoggedIn: false, hasRefreshToken: false };
        }
        const creds = await this.getValidStoredCredentials({ serverUrl: normalizedServerUrl });
        const tokens = creds?.tokens;
        return {
            serverUrl: normalizedServerUrl,
            isLoggedIn: Boolean(tokens),
            hasRefreshToken: Boolean(tokens?.refresh_token),
            scope: tokens?.scope,
            updatedAtMs: creds?.updatedAtMs,
        };
    }
    async logout(input) {
        const normalizedServerUrl = normalizeServerUrlForComparison(input.serverUrl);
        if (!normalizedServerUrl) {
            return (0, result_1.Ok)(undefined);
        }
        try {
            await this.storeLock.withLock(this.storeFilePath, async () => {
                const store = await this.ensureStoreLoadedLocked();
                if (!store.entries[normalizedServerUrl]) {
                    return;
                }
                delete store.entries[normalizedServerUrl];
                await this.persistStoreLocked(store);
            });
            return (0, result_1.Ok)(undefined);
        }
        catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            return (0, result_1.Err)(message);
        }
    }
    /**
     * Returns a provider suitable for attaching to an MCP HTTP/SSE transport.
     *
     * Critical: This must never trigger user-interactive auth in the background.
     * Therefore we only return a provider when tokens exist and we ensure
     * redirectToAuthorization never opens a browser.
     */
    async getAuthProviderForServer(input) {
        const normalizedServerUrl = normalizeServerUrlForComparison(input.serverUrl);
        if (!normalizedServerUrl) {
            return undefined;
        }
        const creds = await this.getValidStoredCredentials({ serverUrl: normalizedServerUrl });
        if (!creds?.tokens || !creds.clientInformation) {
            return undefined;
        }
        return this.createBackgroundProvider({
            serverUrl: normalizedServerUrl,
            serverName: input.serverName,
        });
    }
    /**
     * Used by MCPServerManager caching to restart servers when auth state changes.
     */
    async hasAuthTokens(input) {
        const normalizedServerUrl = normalizeServerUrlForComparison(input.serverUrl);
        if (!normalizedServerUrl) {
            return false;
        }
        const creds = await this.getValidStoredCredentials({ serverUrl: normalizedServerUrl });
        return Boolean(creds?.tokens && creds.clientInformation);
    }
    async resolveServerForOauthFlow(input) {
        if (input.pendingServer) {
            // Defensive: pendingServer comes from user input (add-server form), so validate.
            const transport = input.pendingServer.transport;
            if (transport !== "http" && transport !== "sse" && transport !== "auto") {
                return (0, result_1.Err)("OAuth is only supported for remote (http/sse) MCP servers");
            }
            const serverUrlForDiscovery = sanitizeServerUrlForRequest(input.pendingServer.url);
            if (!serverUrlForDiscovery) {
                return (0, result_1.Err)("Invalid MCP server URL");
            }
            const serverUrlForStoreKey = normalizeServerUrlForComparison(serverUrlForDiscovery);
            if (!serverUrlForStoreKey) {
                return (0, result_1.Err)("Invalid MCP server URL");
            }
            return (0, result_1.Ok)({ serverUrlForDiscovery, serverUrlForStoreKey, transport });
        }
        const servers = await this.mcpConfigService.listServers(input.projectPath);
        const server = servers[input.serverName];
        if (!server) {
            return (0, result_1.Err)("MCP server not found");
        }
        if (server.transport === "stdio") {
            return (0, result_1.Err)("OAuth is only supported for remote (http/sse) MCP servers");
        }
        const serverUrlForDiscovery = sanitizeServerUrlForRequest(server.url);
        if (!serverUrlForDiscovery) {
            return (0, result_1.Err)("Invalid MCP server URL");
        }
        const serverUrlForStoreKey = normalizeServerUrlForComparison(serverUrlForDiscovery);
        if (!serverUrlForStoreKey) {
            return (0, result_1.Err)("Invalid MCP server URL");
        }
        return (0, result_1.Ok)({ serverUrlForDiscovery, serverUrlForStoreKey, transport: server.transport });
    }
    async startDesktopFlow(input) {
        const serverConfig = await this.resolveServerForOauthFlow(input);
        if (!serverConfig.success) {
            return (0, result_1.Err)(serverConfig.error);
        }
        const serverUrlForDiscovery = serverConfig.data.serverUrlForDiscovery;
        const serverUrlForStoreKey = serverConfig.data.serverUrlForStoreKey;
        const transport = serverConfig.data.transport;
        const projectKey = normalizeProjectPathKey(input.projectPath);
        const flowId = crypto.randomUUID();
        const { promise: resultPromise, resolve: resolveResult } = createDeferred();
        const serverListener = http.createServer((req, res) => {
            const reqUrl = req.url ?? "/";
            const url = new URL(reqUrl, "http://localhost");
            if (req.method !== "GET" || url.pathname !== "/callback") {
                res.statusCode = 404;
                res.end("Not found");
                return;
            }
            const state = url.searchParams.get("state");
            if (state !== flowId) {
                res.statusCode = 400;
                res.setHeader("Content-Type", "text/html");
                res.end("<h1>Invalid OAuth state</h1>");
                // Strict state validation: if we receive an OAuth callback that doesn't
                // match the active flow state, fail the flow rather than waiting for a timeout.
                //
                // Note: We only fail once the flow has an authorizeUrl to avoid cancelling
                // due to unrelated localhost probes against the ephemeral loopback port.
                const flow = this.desktopFlows.get(flowId);
                if (flow?.authorizeUrl && !flow?.settled) {
                    void this.finishDesktopFlow(flowId, (0, result_1.Err)("Invalid OAuth state"));
                }
                return;
            }
            const code = url.searchParams.get("code");
            const error = url.searchParams.get("error");
            const errorDescription = url.searchParams.get("error_description") ?? undefined;
            void this.handleDesktopCallback({
                flowId,
                code,
                error,
                errorDescription,
                res,
            });
        });
        try {
            await new Promise((resolve, reject) => {
                serverListener.once("error", reject);
                serverListener.listen(0, "127.0.0.1", () => resolve());
            });
        }
        catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            return (0, result_1.Err)(`Failed to start OAuth callback listener: ${message}`);
        }
        const address = serverListener.address();
        if (!address || typeof address === "string") {
            await closeServer(serverListener).catch(() => undefined);
            return (0, result_1.Err)("Failed to determine OAuth callback listener port");
        }
        const redirectUri = `http://127.0.0.1:${address.port}/callback`;
        // Best-effort probe for OAuth hints (scope/resource_metadata). If it fails,
        // @ai-sdk/mcp can still fall back to well-known discovery.
        const challenge = await probeServerForBearerChallenge(serverUrlForDiscovery);
        const flow = {
            flowId,
            projectPath: projectKey,
            serverName: input.serverName,
            serverUrlForDiscovery,
            serverUrlForStoreKey,
            transport,
            startedAtMs: Date.now(),
            clientInformation: null,
            authorizeUrl: "",
            redirectUri,
            scope: challenge?.scope,
            resourceMetadataUrl: challenge?.resourceMetadataUrl,
            codeVerifier: null,
            server: serverListener,
            timeout: setTimeout(() => {
                void this.finishDesktopFlow(flowId, (0, result_1.Err)("Timed out waiting for OAuth callback"));
            }, DEFAULT_DESKTOP_TIMEOUT_MS),
            cleanupTimeout: null,
            resultPromise,
            resolveResult,
            settled: false,
        };
        this.desktopFlows.set(flowId, flow);
        this.captureTelemetry({
            event: "mcp_oauth_flow_started",
            properties: {
                transport: flow.transport,
                has_scope_hint: Boolean(flow.scope),
                has_resource_metadata_hint: Boolean(flow.resourceMetadataUrl),
            },
        });
        try {
            // Force a user-interactive flow by not exposing existing tokens.
            const provider = this.createFlowProvider(flow);
            const result = await (0, mcp_1.auth)(provider, {
                serverUrl: serverUrlForDiscovery,
                scope: flow.scope,
                resourceMetadataUrl: flow.resourceMetadataUrl,
            });
            if (result !== "REDIRECT" || !flow.authorizeUrl) {
                // If auth() completes without redirecting the user, treat it as a failure
                // and tear down the loopback listener.
                await this.finishDesktopFlow(flowId, (0, result_1.Err)("Failed to start OAuth authorization"));
                return (0, result_1.Err)("Failed to start OAuth authorization");
            }
            log_1.log.debug("[MCP OAuth] Desktop flow started", {
                flowId,
                projectPath: projectKey,
                serverName: input.serverName,
            });
            return (0, result_1.Ok)({ flowId, authorizeUrl: flow.authorizeUrl, redirectUri });
        }
        catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            await this.finishDesktopFlow(flowId, (0, result_1.Err)(message));
            return (0, result_1.Err)(message);
        }
    }
    async waitForDesktopFlow(flowId, opts) {
        const flow = this.desktopFlows.get(flowId);
        if (!flow) {
            return (0, result_1.Err)("OAuth flow not found");
        }
        const timeoutMs = opts?.timeoutMs ?? DEFAULT_DESKTOP_TIMEOUT_MS;
        let timeoutHandle = null;
        const timeoutPromise = new Promise((resolve) => {
            timeoutHandle = setTimeout(() => {
                resolve((0, result_1.Err)("Timed out waiting for OAuth callback"));
            }, timeoutMs);
        });
        const result = await Promise.race([flow.resultPromise, timeoutPromise]);
        if (timeoutHandle !== null) {
            clearTimeout(timeoutHandle);
        }
        if (!result.success) {
            void this.finishDesktopFlow(flowId, result);
        }
        return result;
    }
    async cancelDesktopFlow(flowId) {
        const flow = this.desktopFlows.get(flowId);
        if (!flow)
            return;
        log_1.log.debug("[MCP OAuth] Desktop flow cancelled", { flowId });
        await this.finishDesktopFlow(flowId, (0, result_1.Err)("OAuth flow cancelled"));
    }
    async startServerFlow(input) {
        const serverConfig = await this.resolveServerForOauthFlow(input);
        if (!serverConfig.success) {
            return (0, result_1.Err)(serverConfig.error);
        }
        const serverUrlForDiscovery = serverConfig.data.serverUrlForDiscovery;
        const serverUrlForStoreKey = serverConfig.data.serverUrlForStoreKey;
        const transport = serverConfig.data.transport;
        let redirectUri;
        try {
            redirectUri = new URL(input.redirectUri);
        }
        catch {
            return (0, result_1.Err)("Invalid OAuth redirect URI");
        }
        if (redirectUri.protocol !== "http:" && redirectUri.protocol !== "https:") {
            return (0, result_1.Err)("OAuth redirect URI must be http(s)");
        }
        const projectKey = normalizeProjectPathKey(input.projectPath);
        const flowId = crypto.randomUUID();
        const { promise: resultPromise, resolve: resolveResult } = createDeferred();
        // Best-effort probe for OAuth hints (scope/resource_metadata). If it fails,
        // @ai-sdk/mcp can still fall back to well-known discovery.
        const challenge = await probeServerForBearerChallenge(serverUrlForDiscovery);
        const flow = {
            flowId,
            projectPath: projectKey,
            serverName: input.serverName,
            serverUrlForDiscovery,
            serverUrlForStoreKey,
            transport,
            startedAtMs: Date.now(),
            clientInformation: null,
            authorizeUrl: "",
            redirectUri: redirectUri.toString(),
            scope: challenge?.scope,
            resourceMetadataUrl: challenge?.resourceMetadataUrl,
            codeVerifier: null,
            timeout: setTimeout(() => {
                void this.finishServerFlow(flowId, (0, result_1.Err)("Timed out waiting for OAuth callback"));
            }, DEFAULT_SERVER_TIMEOUT_MS),
            cleanupTimeout: null,
            resultPromise,
            resolveResult,
            settled: false,
        };
        this.serverFlows.set(flowId, flow);
        this.captureTelemetry({
            event: "mcp_oauth_flow_started",
            properties: {
                transport: flow.transport,
                has_scope_hint: Boolean(flow.scope),
                has_resource_metadata_hint: Boolean(flow.resourceMetadataUrl),
            },
        });
        try {
            // Force a user-interactive flow by not exposing existing tokens.
            const provider = this.createFlowProvider(flow);
            const result = await (0, mcp_1.auth)(provider, {
                serverUrl: serverUrlForDiscovery,
                scope: flow.scope,
                resourceMetadataUrl: flow.resourceMetadataUrl,
            });
            if (result !== "REDIRECT" || !flow.authorizeUrl) {
                await this.finishServerFlow(flowId, (0, result_1.Err)("Failed to start OAuth authorization"));
                return (0, result_1.Err)("Failed to start OAuth authorization");
            }
            log_1.log.debug("[MCP OAuth] Server flow started", {
                flowId,
                projectPath: projectKey,
                serverName: input.serverName,
            });
            return (0, result_1.Ok)({ flowId, authorizeUrl: flow.authorizeUrl, redirectUri: flow.redirectUri });
        }
        catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            await this.finishServerFlow(flowId, (0, result_1.Err)(message));
            return (0, result_1.Err)(message);
        }
    }
    async waitForServerFlow(flowId, opts) {
        const flow = this.serverFlows.get(flowId);
        if (!flow) {
            return (0, result_1.Err)("OAuth flow not found");
        }
        const timeoutMs = opts?.timeoutMs ?? DEFAULT_SERVER_TIMEOUT_MS;
        let timeoutHandle = null;
        const timeoutPromise = new Promise((resolve) => {
            timeoutHandle = setTimeout(() => {
                resolve((0, result_1.Err)("Timed out waiting for OAuth callback"));
            }, timeoutMs);
        });
        const result = await Promise.race([flow.resultPromise, timeoutPromise]);
        if (timeoutHandle !== null) {
            clearTimeout(timeoutHandle);
        }
        if (!result.success) {
            void this.finishServerFlow(flowId, result);
        }
        return result;
    }
    async cancelServerFlow(flowId) {
        const flow = this.serverFlows.get(flowId);
        if (!flow)
            return;
        log_1.log.debug("[MCP OAuth] Server flow cancelled", { flowId });
        await this.finishServerFlow(flowId, (0, result_1.Err)("OAuth flow cancelled"));
    }
    async handleServerCallbackAndExchange(input) {
        const state = input.state;
        if (!state) {
            return (0, result_1.Err)("Missing OAuth state");
        }
        const flow = this.serverFlows.get(state);
        if (!flow) {
            return (0, result_1.Err)("Unknown OAuth state");
        }
        if (flow.settled) {
            return (0, result_1.Err)("OAuth flow already completed");
        }
        log_1.log.debug("[MCP OAuth] Server callback received", { flowId: state });
        const result = await this.exchangeAuthorizationCode(flow, {
            code: input.code,
            error: input.error,
            errorDescription: input.errorDescription,
        });
        await this.finishServerFlow(state, result);
        return result;
    }
    captureTelemetry(payload) {
        try {
            this.telemetryService?.capture(payload);
        }
        catch (error) {
            // Telemetry must never block or crash OAuth flows.
            log_1.log.debug("[MCP OAuth] Failed to capture telemetry", { error });
        }
    }
    getOAuthFlowErrorCategory(error) {
        const lower = error.toLowerCase();
        if (lower.includes("timed out")) {
            return "timeout";
        }
        if (lower.includes("cancelled")) {
            return "cancelled";
        }
        if (lower.includes("invalid oauth state")) {
            return "state_mismatch";
        }
        if (lower.includes("oauth")) {
            return "provider_error";
        }
        return "unknown";
    }
    createFlowProvider(flow) {
        return {
            tokens: () => Promise.resolve(undefined),
            saveTokens: async (tokens) => {
                await this.saveTokens({
                    serverUrl: flow.serverUrlForStoreKey,
                    tokens: tokens,
                });
            },
            redirectToAuthorization: (authorizationUrl) => {
                flow.authorizeUrl = authorizationUrl.toString();
                return Promise.resolve();
            },
            saveCodeVerifier: (codeVerifier) => {
                flow.codeVerifier = codeVerifier;
                return Promise.resolve();
            },
            codeVerifier: () => {
                if (!flow.codeVerifier) {
                    return Promise.reject(new Error("Missing PKCE code verifier"));
                }
                return Promise.resolve(flow.codeVerifier);
            },
            invalidateCredentials: async (scope) => {
                await this.invalidateStoredCredentials({
                    serverUrl: flow.serverUrlForStoreKey,
                    scope,
                });
            },
            get redirectUrl() {
                return flow.redirectUri;
            },
            get clientMetadata() {
                return {
                    redirect_uris: [flow.redirectUri],
                    response_types: ["code"],
                    grant_types: ["authorization_code", "refresh_token"],
                    token_endpoint_auth_method: "none",
                    client_name: "Mux",
                    scope: flow.scope,
                };
            },
            clientInformation: () => {
                // We intentionally register an OAuth client per interactive flow because the
                // redirect URI may vary between environments (desktop loopback ports, proxied
                // server origins, etc.).
                return Promise.resolve(flow.clientInformation ?? undefined);
            },
            saveClientInformation: async (clientInformation) => {
                const next = clientInformation;
                flow.clientInformation = next;
                await this.saveClientInformation({
                    serverUrl: flow.serverUrlForStoreKey,
                    clientInformation: next,
                });
            },
            state: () => Promise.resolve(flow.flowId),
        };
    }
    createBackgroundProvider(input) {
        return {
            tokens: async () => {
                const creds = await this.getValidStoredCredentials({ serverUrl: input.serverUrl });
                return creds?.tokens;
            },
            saveTokens: async (tokens) => {
                await this.saveTokens({
                    serverUrl: input.serverUrl,
                    tokens: tokens,
                });
            },
            redirectToAuthorization: async () => {
                // Avoid any user-visible side effects during background tool calls.
                // If we end up here, the server requires interactive auth.
                await this.invalidateStoredCredentials({
                    serverUrl: input.serverUrl,
                    scope: "tokens",
                });
                throw new Error("MCP OAuth login required");
            },
            saveCodeVerifier: () => {
                // Background providers never start interactive flows.
                return Promise.resolve();
            },
            codeVerifier: () => Promise.reject(new Error("PKCE verifier is not available")),
            invalidateCredentials: async (scope) => {
                await this.invalidateStoredCredentials({
                    serverUrl: input.serverUrl,
                    scope,
                });
            },
            get redirectUrl() {
                // Unused in background mode.
                return "http://127.0.0.1/";
            },
            get clientMetadata() {
                // Unused in background mode; must still be present for the interface.
                return {
                    redirect_uris: ["http://127.0.0.1/"],
                };
            },
            clientInformation: async () => {
                const creds = await this.getValidStoredCredentials({ serverUrl: input.serverUrl });
                return creds?.clientInformation;
            },
            saveClientInformation: async (clientInformation) => {
                await this.saveClientInformation({
                    serverUrl: input.serverUrl,
                    clientInformation: clientInformation,
                });
            },
        };
    }
    async handleDesktopCallback(input) {
        const flow = this.desktopFlows.get(input.flowId);
        if (!flow || flow.settled) {
            input.res.statusCode = 409;
            input.res.setHeader("Content-Type", "text/html");
            input.res.end("<h1>OAuth flow already completed</h1>");
            return;
        }
        log_1.log.debug("[MCP OAuth] Callback received", { flowId: input.flowId });
        const result = await this.exchangeAuthorizationCode(flow, {
            code: input.code,
            error: input.error,
            errorDescription: input.errorDescription,
        });
        const title = result.success ? "Login complete" : "Login failed";
        const description = result.success
            ? "You can return to Mux. You may now close this tab."
            : escapeHtml(result.error);
        input.res.setHeader("Content-Type", "text/html");
        if (!result.success) {
            input.res.statusCode = 400;
        }
        input.res.end(`<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="dark light" />
    <title>${title}</title>
  </head>
  <body>
    <h1>${title}</h1>
    <p>${description}</p>
  </body>
</html>`);
        await this.finishDesktopFlow(input.flowId, result);
    }
    async exchangeAuthorizationCode(flow, input) {
        if (input.error) {
            const message = input.errorDescription
                ? `${input.error}: ${input.errorDescription}`
                : input.error;
            return (0, result_1.Err)(`MCP OAuth error: ${message}`);
        }
        if (!input.code) {
            return (0, result_1.Err)("Missing OAuth code");
        }
        try {
            const provider = this.createFlowProvider(flow);
            const result = await (0, mcp_1.auth)(provider, {
                serverUrl: flow.serverUrlForDiscovery,
                authorizationCode: input.code,
                scope: flow.scope,
                resourceMetadataUrl: flow.resourceMetadataUrl,
            });
            if (result !== "AUTHORIZED") {
                return (0, result_1.Err)("OAuth exchange did not complete");
            }
            this.windowService?.focusMainWindow();
            return (0, result_1.Ok)(undefined);
        }
        catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            return (0, result_1.Err)(message);
        }
    }
    async finishDesktopFlow(flowId, result) {
        const flow = this.desktopFlows.get(flowId);
        if (!flow || flow.settled)
            return;
        flow.settled = true;
        clearTimeout(flow.timeout);
        const durationMs = Math.max(0, Date.now() - flow.startedAtMs);
        const durationMsB2 = (0, utils_1.roundToBase2)(durationMs);
        const hasScopeHint = Boolean(flow.scope);
        const hasResourceMetadataHint = Boolean(flow.resourceMetadataUrl);
        if (result.success) {
            this.captureTelemetry({
                event: "mcp_oauth_flow_completed",
                properties: {
                    transport: flow.transport,
                    duration_ms_b2: durationMsB2,
                    has_scope_hint: hasScopeHint,
                    has_resource_metadata_hint: hasResourceMetadataHint,
                },
            });
        }
        else {
            const errorCategory = this.getOAuthFlowErrorCategory(result.error);
            this.captureTelemetry({
                event: "mcp_oauth_flow_failed",
                properties: {
                    transport: flow.transport,
                    duration_ms_b2: durationMsB2,
                    has_scope_hint: hasScopeHint,
                    has_resource_metadata_hint: hasResourceMetadataHint,
                    error_category: errorCategory,
                },
            });
        }
        try {
            flow.resolveResult(result);
            await closeServer(flow.server);
        }
        catch (error) {
            log_1.log.debug("[MCP OAuth] Failed to close OAuth callback listener", { error });
        }
        finally {
            if (flow.cleanupTimeout !== null) {
                clearTimeout(flow.cleanupTimeout);
            }
            flow.cleanupTimeout = setTimeout(() => {
                this.desktopFlows.delete(flowId);
            }, COMPLETED_FLOW_TTL_MS);
        }
    }
    finishServerFlow(flowId, result) {
        const flow = this.serverFlows.get(flowId);
        if (!flow || flow.settled) {
            return Promise.resolve();
        }
        flow.settled = true;
        clearTimeout(flow.timeout);
        const durationMs = Math.max(0, Date.now() - flow.startedAtMs);
        const durationMsB2 = (0, utils_1.roundToBase2)(durationMs);
        const hasScopeHint = Boolean(flow.scope);
        const hasResourceMetadataHint = Boolean(flow.resourceMetadataUrl);
        if (result.success) {
            this.captureTelemetry({
                event: "mcp_oauth_flow_completed",
                properties: {
                    transport: flow.transport,
                    duration_ms_b2: durationMsB2,
                    has_scope_hint: hasScopeHint,
                    has_resource_metadata_hint: hasResourceMetadataHint,
                },
            });
        }
        else {
            const errorCategory = this.getOAuthFlowErrorCategory(result.error);
            this.captureTelemetry({
                event: "mcp_oauth_flow_failed",
                properties: {
                    transport: flow.transport,
                    duration_ms_b2: durationMsB2,
                    has_scope_hint: hasScopeHint,
                    has_resource_metadata_hint: hasResourceMetadataHint,
                    error_category: errorCategory,
                },
            });
        }
        try {
            flow.resolveResult(result);
        }
        finally {
            if (flow.cleanupTimeout !== null) {
                clearTimeout(flow.cleanupTimeout);
            }
            flow.cleanupTimeout = setTimeout(() => {
                this.serverFlows.delete(flowId);
            }, COMPLETED_FLOW_TTL_MS);
        }
        return Promise.resolve();
    }
    async getValidStoredCredentials(input) {
        await this.ensureStoreLoaded();
        const store = this.store;
        if (!store) {
            return null;
        }
        const creds = store.entries[input.serverUrl];
        if (!creds) {
            return null;
        }
        // Defensive: Never use credentials bound to a different (normalized) URL.
        //
        // This shouldn't happen in a well-formed v2 store, but it can happen if the
        // store file is manually edited or corrupted.
        const storedUrlKey = normalizeServerUrlForComparison(creds.serverUrl);
        if (!storedUrlKey || storedUrlKey !== input.serverUrl) {
            await this.logout({ serverUrl: input.serverUrl });
            return null;
        }
        return creds;
    }
    async invalidateStoredCredentials(input) {
        await this.storeLock.withLock(this.storeFilePath, async () => {
            const store = await this.ensureStoreLoadedLocked();
            const creds = store.entries[input.serverUrl];
            if (!creds) {
                return;
            }
            if (input.scope === "tokens" || input.scope === "all") {
                creds.tokens = undefined;
            }
            if (input.scope === "client" || input.scope === "all") {
                creds.clientInformation = undefined;
            }
            // verifier is per-flow (in-memory) only.
            creds.updatedAtMs = Date.now();
            // If everything is gone, prune the entry.
            if (!creds.tokens && !creds.clientInformation) {
                delete store.entries[input.serverUrl];
            }
            await this.persistStoreLocked(store);
        });
    }
    async saveTokens(input) {
        await this.storeLock.withLock(this.storeFilePath, async () => {
            var _a, _b;
            const store = await this.ensureStoreLoadedLocked();
            const creds = ((_a = store.entries)[_b = input.serverUrl] ?? (_a[_b] = {
                serverUrl: input.serverUrl,
                updatedAtMs: Date.now(),
            }));
            // Defensive: Never keep tokens bound to a different URL.
            if (normalizeServerUrlForComparison(creds.serverUrl) !== input.serverUrl) {
                creds.clientInformation = undefined;
            }
            creds.serverUrl = input.serverUrl;
            creds.tokens = input.tokens;
            creds.updatedAtMs = Date.now();
            await this.persistStoreLocked(store);
        });
    }
    async saveClientInformation(input) {
        await this.storeLock.withLock(this.storeFilePath, async () => {
            var _a, _b;
            const store = await this.ensureStoreLoadedLocked();
            const creds = ((_a = store.entries)[_b = input.serverUrl] ?? (_a[_b] = {
                serverUrl: input.serverUrl,
                updatedAtMs: Date.now(),
            }));
            // Defensive: Never keep client info bound to a different URL.
            if (normalizeServerUrlForComparison(creds.serverUrl) !== input.serverUrl) {
                creds.tokens = undefined;
            }
            // Defensive: Refresh tokens are bound to a specific OAuth client_id.
            if (creds.clientInformation?.client_id &&
                creds.clientInformation.client_id !== input.clientInformation.client_id) {
                creds.tokens = undefined;
            }
            creds.serverUrl = input.serverUrl;
            creds.clientInformation = input.clientInformation;
            creds.updatedAtMs = Date.now();
            await this.persistStoreLocked(store);
        });
    }
    async ensureStoreLoaded() {
        if (this.store) {
            return;
        }
        await this.storeLock.withLock(this.storeFilePath, async () => {
            await this.ensureStoreLoadedLocked();
        });
    }
    async ensureStoreLoadedLocked() {
        if (this.store) {
            return this.store;
        }
        try {
            const raw = await fsPromises.readFile(this.storeFilePath, "utf-8");
            const parsed = parseStoreFile(raw);
            if (!parsed) {
                log_1.log.warn("[MCP OAuth] Invalid store file; resetting", { filePath: this.storeFilePath });
                this.store = createEmptyStore();
                await this.persistStoreBestEffortLocked(this.store);
                return this.store;
            }
            if (parsed.version === 1) {
                const migrated = migrateStoreV1ToV2(parsed);
                this.store = migrated;
                await this.persistStoreBestEffortLocked(migrated);
                return migrated;
            }
            this.store = parsed;
            return parsed;
        }
        catch (error) {
            if (error && typeof error === "object" && "code" in error && error.code === "ENOENT") {
                this.store = createEmptyStore();
                return this.store;
            }
            log_1.log.warn("[MCP OAuth] Failed to read store file; resetting", { error });
            this.store = createEmptyStore();
            await this.persistStoreBestEffortLocked(this.store);
            return this.store;
        }
    }
    async persistStoreBestEffortLocked(store) {
        try {
            await this.persistStoreLocked(store);
        }
        catch (error) {
            // Store read/repair must never crash the app at startup.
            log_1.log.warn("[MCP OAuth] Failed to persist store file; continuing with in-memory state", {
                error,
            });
        }
    }
    async persistStoreLocked(store) {
        // Ensure ~/.mux exists.
        await fsPromises.mkdir(this.config.rootDir, { recursive: true });
        await (0, write_file_atomic_1.default)(this.storeFilePath, JSON.stringify(store, null, 2), {
            encoding: "utf-8",
            mode: 0o600,
        });
    }
}
exports.McpOauthService = McpOauthService;
function escapeHtml(input) {
    return input
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
}
//# sourceMappingURL=mcpOauthService.js.map