{"version":3,"file":"streamSimulation.js","sourceRoot":"","sources":["../../../src/node/services/streamSimulation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Stream simulation: synthetic stream event sequences for special early-return conditions.\n *\n * Extracted from `streamMessage()` — these functions simulate the full stream\n * lifecycle (start → delta → end/error) without calling an AI provider.\n *\n * Used for:\n * - `forceContextLimitError`: OpenAI SDK testing of context-exceeded handling\n * - `simulateToolPolicyNoop`: OpenAI SDK testing of tool-policy-disabled handling\n */\n\nimport type { MuxMessage, MuxTextPart } from \"@/common/types/message\";\nimport { createMuxMessage } from \"@/common/types/message\";\nimport type { ThinkingLevel } from \"@/common/types/thinking\";\nimport type { StreamDeltaEvent, StreamEndEvent, StreamStartEvent } from \"@/common/types/stream\";\nimport type { ToolPolicy } from \"@/common/utils/tools/toolPolicy\";\nimport type { HistoryService } from \"./historyService\";\nimport type { PartialService } from \"./partialService\";\nimport { createErrorEvent } from \"./utils/sendMessageError\";\n\n// ---------------------------------------------------------------------------\n// Shared context for both simulation paths\n// ---------------------------------------------------------------------------\n\n/** Common parameters shared by all simulated stream scenarios. */\nexport interface SimulationContext {\n  workspaceId: string;\n  assistantMessageId: string;\n  canonicalModelString: string;\n  routedThroughGateway: boolean;\n  historySequence: number;\n  systemMessageTokens: number;\n  effectiveAgentId: string;\n  effectiveMode: \"plan\" | \"exec\" | \"compact\";\n  effectiveThinkingLevel: ThinkingLevel;\n  /** Emit a typed stream event (stream-start, stream-delta, stream-end, error). */\n  emit: (event: string, data: unknown) => void;\n}\n\n/** Build the common StreamStartEvent used by both simulation paths. */\nfunction createSimulatedStreamStart(ctx: SimulationContext): StreamStartEvent {\n  return {\n    type: \"stream-start\",\n    workspaceId: ctx.workspaceId,\n    messageId: ctx.assistantMessageId,\n    model: ctx.canonicalModelString,\n    routedThroughGateway: ctx.routedThroughGateway,\n    historySequence: ctx.historySequence,\n    startTime: Date.now(),\n    agentId: ctx.effectiveAgentId,\n    mode: ctx.effectiveMode,\n    thinkingLevel: ctx.effectiveThinkingLevel,\n  };\n}\n\n// ---------------------------------------------------------------------------\n// forceContextLimitError simulation\n// ---------------------------------------------------------------------------\n\n/**\n * Simulate a context-length-exceeded error without hitting the provider.\n *\n * Writes an error partial, emits stream-start + error events, then returns.\n * Used by the OpenAI SDK `forceContextLimitError` provider option.\n */\nexport async function simulateContextLimitError(\n  ctx: SimulationContext,\n  partialService: PartialService\n): Promise<void> {\n  const errorMessage =\n    \"Context length exceeded: the conversation is too long to send to this OpenAI model. Please shorten the history and try again.\";\n\n  const errorPartialMessage: MuxMessage = {\n    id: ctx.assistantMessageId,\n    role: \"assistant\",\n    metadata: {\n      historySequence: ctx.historySequence,\n      timestamp: Date.now(),\n      model: ctx.canonicalModelString,\n      routedThroughGateway: ctx.routedThroughGateway,\n      systemMessageTokens: ctx.systemMessageTokens,\n      agentId: ctx.effectiveAgentId,\n      thinkingLevel: ctx.effectiveThinkingLevel,\n      partial: true,\n      error: errorMessage,\n      errorType: \"context_exceeded\",\n    },\n    parts: [],\n  };\n\n  await partialService.writePartial(ctx.workspaceId, errorPartialMessage);\n\n  ctx.emit(\"stream-start\", createSimulatedStreamStart(ctx));\n  ctx.emit(\n    \"error\",\n    createErrorEvent(ctx.workspaceId, {\n      messageId: ctx.assistantMessageId,\n      error: errorMessage,\n      errorType: \"context_exceeded\",\n    })\n  );\n}\n\n// ---------------------------------------------------------------------------\n// simulateToolPolicyNoop simulation\n// ---------------------------------------------------------------------------\n\n/**\n * Simulate a full stream lifecycle for a tool-policy-disabled noop response.\n *\n * Emits stream-start → stream-delta → stream-end, then updates history.\n * Used by the OpenAI SDK `simulateToolPolicyNoop` provider option.\n */\nexport async function simulateToolPolicyNoop(\n  ctx: SimulationContext,\n  effectiveToolPolicy: ToolPolicy | undefined,\n  historyService: HistoryService,\n  partialService: PartialService\n): Promise<void> {\n  const noopMessage = createMuxMessage(ctx.assistantMessageId, \"assistant\", \"\", {\n    timestamp: Date.now(),\n    model: ctx.canonicalModelString,\n    routedThroughGateway: ctx.routedThroughGateway,\n    systemMessageTokens: ctx.systemMessageTokens,\n    agentId: ctx.effectiveAgentId,\n    thinkingLevel: ctx.effectiveThinkingLevel,\n    toolPolicy: effectiveToolPolicy,\n  });\n\n  const parts: StreamEndEvent[\"parts\"] = [\n    {\n      type: \"text\",\n      text: \"Tool execution skipped because the requested tool is disabled by policy.\",\n    },\n  ];\n\n  ctx.emit(\"stream-start\", createSimulatedStreamStart(ctx));\n\n  const textParts = parts.filter((part): part is MuxTextPart => part.type === \"text\");\n  if (textParts.length === 0) {\n    throw new Error(\"simulateToolPolicyNoop requires at least one text part\");\n  }\n\n  for (const textPart of textParts) {\n    if (textPart.text.length === 0) {\n      continue;\n    }\n\n    const streamDeltaEvent: StreamDeltaEvent = {\n      type: \"stream-delta\",\n      workspaceId: ctx.workspaceId,\n      messageId: ctx.assistantMessageId,\n      delta: textPart.text,\n      tokens: 0, // Mock scenario — actual tokenization happens in streamManager\n      timestamp: Date.now(),\n    };\n    ctx.emit(\"stream-delta\", streamDeltaEvent);\n  }\n\n  const streamEndEvent: StreamEndEvent = {\n    type: \"stream-end\",\n    workspaceId: ctx.workspaceId,\n    messageId: ctx.assistantMessageId,\n    metadata: {\n      model: ctx.canonicalModelString,\n      thinkingLevel: ctx.effectiveThinkingLevel,\n      routedThroughGateway: ctx.routedThroughGateway,\n      systemMessageTokens: ctx.systemMessageTokens,\n    },\n    parts,\n  };\n  ctx.emit(\"stream-end\", streamEndEvent);\n\n  const finalAssistantMessage: MuxMessage = {\n    ...noopMessage,\n    metadata: {\n      ...noopMessage.metadata,\n      historySequence: ctx.historySequence,\n    },\n    parts,\n  };\n\n  await partialService.deletePartial(ctx.workspaceId);\n  await historyService.updateHistory(ctx.workspaceId, finalAssistantMessage);\n}\n"]}