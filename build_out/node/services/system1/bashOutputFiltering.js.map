{"version":3,"file":"bashOutputFiltering.js","sourceRoot":"","sources":["../../../../src/node/services/system1/bashOutputFiltering.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from \"@/common/utils/assert\";\nimport type { z } from \"zod\";\nimport type { System1KeepRangeSchema } from \"@/common/utils/tools/toolDefinitions\";\n\n// Derived from the Zod schema (single source of truth) to avoid drift.\nexport type System1KeepRange = z.infer<typeof System1KeepRangeSchema>;\n\nexport interface ApplySystem1KeepRangesResult {\n  filteredOutput: string;\n  keptLines: number;\n  totalLines: number;\n}\n\nexport function formatSystem1BashFilterNotice(params: {\n  keptLines: number;\n  totalLines: number;\n  trigger: string;\n  fullOutputPath?: string | undefined;\n}): string {\n  assert(\n    Number.isInteger(params.keptLines) && params.keptLines >= 0,\n    \"keptLines must be a non-negative integer\"\n  );\n  assert(\n    Number.isInteger(params.totalLines) && params.totalLines >= 0,\n    \"totalLines must be a non-negative integer\"\n  );\n  assert(params.keptLines <= params.totalLines, \"keptLines must be <= totalLines\");\n  assert(\n    typeof params.trigger === \"string\" && params.trigger.length > 0,\n    \"trigger must be a string\"\n  );\n\n  const notice = `Auto-filtered output: kept ${params.keptLines}/${params.totalLines} lines (trigger: ${params.trigger}).`;\n\n  if (typeof params.fullOutputPath !== \"string\" || params.fullOutputPath.length === 0) {\n    return notice;\n  }\n\n  return (\n    notice +\n    `\\n\\nFull output saved to ${params.fullOutputPath}` +\n    \"\\n\\nFile will be automatically cleaned up when stream ends (it may already be gone).\"\n  );\n}\n\nexport function splitBashOutputLines(output: string): string[] {\n  if (output.length === 0) {\n    return [];\n  }\n\n  // NOTE: Preserve exact line contents (including any \\r characters).\n  return output.split(\"\\n\");\n}\n\nexport function formatNumberedLinesForSystem1(lines: string[]): string {\n  return lines.map((line, index) => `${String(index + 1).padStart(4, \"0\")}| ${line}`).join(\"\\n\");\n}\n\nconst GIT_CONFLICT_MARKER_REGEX = /(<{7}|={7}|>{7}|\\|{7})/;\n\nconst HEURISTIC_IMPORTANT_LINE_REGEX =\n  /(^|\\b)(error|failed|failure|fatal|panic|exception|traceback|warning|assertion failed|npm err!|err!|exited with code|exit code)(\\b|$)/i;\n\nconst HEURISTIC_CONTEXT_LINES = 2;\nconst HEURISTIC_MAX_MATCH_RANGES = 50;\n\nexport function getHeuristicKeepRangesForBashOutput(params: {\n  lines: string[];\n  maxKeptLines: number;\n}): System1KeepRange[] {\n  assert(Array.isArray(params.lines), \"lines must be an array\");\n  assert(\n    Number.isInteger(params.maxKeptLines) && params.maxKeptLines > 0,\n    \"maxKeptLines must be a positive integer\"\n  );\n\n  const totalLines = params.lines.length;\n  if (totalLines === 0) {\n    return [];\n  }\n\n  // Keep a small head/tail slice so users can see setup and summary.\n  const headTailLines = Math.max(1, Math.min(5, Math.floor(params.maxKeptLines / 8)));\n\n  const ranges: System1KeepRange[] = [];\n\n  const headEnd = Math.min(totalLines, headTailLines);\n  if (headEnd > 0) {\n    ranges.push({ start: 1, end: headEnd, reason: \"head\" });\n  }\n\n  const tailStart = Math.max(1, totalLines - headTailLines + 1);\n  if (tailStart <= totalLines) {\n    ranges.push({ start: tailStart, end: totalLines, reason: \"tail\" });\n  }\n\n  let matchRanges = 0;\n  for (let idx = 0; idx < totalLines; idx += 1) {\n    if (matchRanges >= HEURISTIC_MAX_MATCH_RANGES) {\n      break;\n    }\n\n    const line = params.lines[idx];\n    const isConflictMarkerLine = GIT_CONFLICT_MARKER_REGEX.test(line);\n    const isImportantLine = HEURISTIC_IMPORTANT_LINE_REGEX.test(line);\n\n    if (!isConflictMarkerLine && !isImportantLine) {\n      continue;\n    }\n\n    const contextLines = isConflictMarkerLine ? 0 : HEURISTIC_CONTEXT_LINES;\n\n    const lineNo = idx + 1;\n    const start = Math.max(1, lineNo - contextLines);\n    const end = Math.min(totalLines, lineNo + contextLines);\n\n    ranges.push({\n      start,\n      end,\n      reason: isConflictMarkerLine ? \"conflict_marker\" : \"match\",\n    });\n    matchRanges += 1;\n  }\n\n  return ranges;\n}\n\ninterface NormalizedRange {\n  start: number;\n  end: number;\n}\n\nfunction normalizeKeepRanges(ranges: System1KeepRange[], maxLine: number): NormalizedRange[] {\n  assert(Number.isInteger(maxLine) && maxLine >= 0, \"maxLine must be a non-negative integer\");\n\n  const normalized: NormalizedRange[] = [];\n  for (const range of ranges) {\n    if (!Number.isFinite(range.start) || !Number.isFinite(range.end)) {\n      continue;\n    }\n\n    // System 1 may return floats; clamp after rounding.\n    let start = Math.floor(range.start);\n    let end = Math.floor(range.end);\n\n    if (start > end) {\n      [start, end] = [end, start];\n    }\n\n    // 1-based indexing.\n    start = Math.max(1, Math.min(maxLine, start));\n    end = Math.max(1, Math.min(maxLine, end));\n\n    normalized.push({ start, end });\n  }\n\n  normalized.sort((a, b) => a.start - b.start || a.end - b.end);\n\n  const merged: NormalizedRange[] = [];\n  for (const range of normalized) {\n    const prev = merged[merged.length - 1];\n    if (!prev) {\n      merged.push(range);\n      continue;\n    }\n\n    // Merge overlapping/adjacent ranges.\n    if (range.start <= prev.end + 1) {\n      prev.end = Math.max(prev.end, range.end);\n      continue;\n    }\n\n    merged.push(range);\n  }\n\n  return merged;\n}\n\nexport function applySystem1KeepRangesToOutput(params: {\n  rawOutput: string;\n  keepRanges: System1KeepRange[];\n  maxKeptLines: number;\n}): ApplySystem1KeepRangesResult | undefined {\n  assert(typeof params.rawOutput === \"string\", \"rawOutput must be a string\");\n  assert(Array.isArray(params.keepRanges), \"keepRanges must be an array\");\n  assert(\n    Number.isInteger(params.maxKeptLines) && params.maxKeptLines > 0,\n    \"maxKeptLines must be a positive integer\"\n  );\n\n  const lines = splitBashOutputLines(params.rawOutput);\n  const totalLines = lines.length;\n\n  if (totalLines === 0) {\n    return {\n      filteredOutput: \"\",\n      keptLines: 0,\n      totalLines: 0,\n    };\n  }\n\n  const normalized = normalizeKeepRanges(params.keepRanges, totalLines);\n  if (normalized.length === 0) {\n    return undefined;\n  }\n\n  const kept: string[] = [];\n  for (const range of normalized) {\n    for (let lineNo = range.start; lineNo <= range.end; lineNo += 1) {\n      kept.push(lines[lineNo - 1]);\n\n      if (kept.length >= params.maxKeptLines) {\n        return {\n          filteredOutput: kept.join(\"\\n\"),\n          keptLines: kept.length,\n          totalLines,\n        };\n      }\n    }\n  }\n\n  return {\n    filteredOutput: kept.join(\"\\n\"),\n    keptLines: kept.length,\n    totalLines,\n  };\n}\n"]}