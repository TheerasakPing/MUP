{"version":3,"file":"bashOutputFiltering.js","sourceRoot":"","sources":["../../../../src/node/services/system1/bashOutputFiltering.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from \"@/common/utils/assert\";\r\nimport type { z } from \"zod\";\r\nimport type { System1KeepRangeSchema } from \"@/common/utils/tools/toolDefinitions\";\r\n\r\n// Derived from the Zod schema (single source of truth) to avoid drift.\r\nexport type System1KeepRange = z.infer<typeof System1KeepRangeSchema>;\r\n\r\nexport interface ApplySystem1KeepRangesResult {\r\n  filteredOutput: string;\r\n  keptLines: number;\r\n  totalLines: number;\r\n}\r\n\r\nexport function formatSystem1BashFilterNotice(params: {\r\n  keptLines: number;\r\n  totalLines: number;\r\n  trigger: string;\r\n  fullOutputPath?: string | undefined;\r\n}): string {\r\n  assert(\r\n    Number.isInteger(params.keptLines) && params.keptLines >= 0,\r\n    \"keptLines must be a non-negative integer\"\r\n  );\r\n  assert(\r\n    Number.isInteger(params.totalLines) && params.totalLines >= 0,\r\n    \"totalLines must be a non-negative integer\"\r\n  );\r\n  assert(params.keptLines <= params.totalLines, \"keptLines must be <= totalLines\");\r\n  assert(\r\n    typeof params.trigger === \"string\" && params.trigger.length > 0,\r\n    \"trigger must be a string\"\r\n  );\r\n\r\n  const notice = `Auto-filtered output: kept ${params.keptLines}/${params.totalLines} lines (trigger: ${params.trigger}).`;\r\n\r\n  if (typeof params.fullOutputPath !== \"string\" || params.fullOutputPath.length === 0) {\r\n    return notice;\r\n  }\r\n\r\n  return (\r\n    notice +\r\n    `\\n\\nFull output saved to ${params.fullOutputPath}` +\r\n    \"\\n\\nFile will be automatically cleaned up when stream ends (it may already be gone).\"\r\n  );\r\n}\r\n\r\nexport function splitBashOutputLines(output: string): string[] {\r\n  if (output.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  // NOTE: Preserve exact line contents (including any \\r characters).\r\n  return output.split(\"\\n\");\r\n}\r\n\r\nexport function formatNumberedLinesForSystem1(lines: string[]): string {\r\n  return lines.map((line, index) => `${String(index + 1).padStart(4, \"0\")}| ${line}`).join(\"\\n\");\r\n}\r\n\r\nconst GIT_CONFLICT_MARKER_REGEX = /(<{7}|={7}|>{7}|\\|{7})/;\r\n\r\nconst HEURISTIC_IMPORTANT_LINE_REGEX =\r\n  /(^|\\b)(error|failed|failure|fatal|panic|exception|traceback|warning|assertion failed|npm err!|err!|exited with code|exit code)(\\b|$)/i;\r\n\r\nconst HEURISTIC_CONTEXT_LINES = 2;\r\nconst HEURISTIC_MAX_MATCH_RANGES = 50;\r\n\r\nexport function getHeuristicKeepRangesForBashOutput(params: {\r\n  lines: string[];\r\n  maxKeptLines: number;\r\n}): System1KeepRange[] {\r\n  assert(Array.isArray(params.lines), \"lines must be an array\");\r\n  assert(\r\n    Number.isInteger(params.maxKeptLines) && params.maxKeptLines > 0,\r\n    \"maxKeptLines must be a positive integer\"\r\n  );\r\n\r\n  const totalLines = params.lines.length;\r\n  if (totalLines === 0) {\r\n    return [];\r\n  }\r\n\r\n  // Keep a small head/tail slice so users can see setup and summary.\r\n  const headTailLines = Math.max(1, Math.min(5, Math.floor(params.maxKeptLines / 8)));\r\n\r\n  const ranges: System1KeepRange[] = [];\r\n\r\n  const headEnd = Math.min(totalLines, headTailLines);\r\n  if (headEnd > 0) {\r\n    ranges.push({ start: 1, end: headEnd, reason: \"head\" });\r\n  }\r\n\r\n  const tailStart = Math.max(1, totalLines - headTailLines + 1);\r\n  if (tailStart <= totalLines) {\r\n    ranges.push({ start: tailStart, end: totalLines, reason: \"tail\" });\r\n  }\r\n\r\n  let matchRanges = 0;\r\n  for (let idx = 0; idx < totalLines; idx += 1) {\r\n    if (matchRanges >= HEURISTIC_MAX_MATCH_RANGES) {\r\n      break;\r\n    }\r\n\r\n    const line = params.lines[idx];\r\n    const isConflictMarkerLine = GIT_CONFLICT_MARKER_REGEX.test(line);\r\n    const isImportantLine = HEURISTIC_IMPORTANT_LINE_REGEX.test(line);\r\n\r\n    if (!isConflictMarkerLine && !isImportantLine) {\r\n      continue;\r\n    }\r\n\r\n    const contextLines = isConflictMarkerLine ? 0 : HEURISTIC_CONTEXT_LINES;\r\n\r\n    const lineNo = idx + 1;\r\n    const start = Math.max(1, lineNo - contextLines);\r\n    const end = Math.min(totalLines, lineNo + contextLines);\r\n\r\n    ranges.push({\r\n      start,\r\n      end,\r\n      reason: isConflictMarkerLine ? \"conflict_marker\" : \"match\",\r\n    });\r\n    matchRanges += 1;\r\n  }\r\n\r\n  return ranges;\r\n}\r\n\r\ninterface NormalizedRange {\r\n  start: number;\r\n  end: number;\r\n}\r\n\r\nfunction normalizeKeepRanges(ranges: System1KeepRange[], maxLine: number): NormalizedRange[] {\r\n  assert(Number.isInteger(maxLine) && maxLine >= 0, \"maxLine must be a non-negative integer\");\r\n\r\n  const normalized: NormalizedRange[] = [];\r\n  for (const range of ranges) {\r\n    if (!Number.isFinite(range.start) || !Number.isFinite(range.end)) {\r\n      continue;\r\n    }\r\n\r\n    // System 1 may return floats; clamp after rounding.\r\n    let start = Math.floor(range.start);\r\n    let end = Math.floor(range.end);\r\n\r\n    if (start > end) {\r\n      [start, end] = [end, start];\r\n    }\r\n\r\n    // 1-based indexing.\r\n    start = Math.max(1, Math.min(maxLine, start));\r\n    end = Math.max(1, Math.min(maxLine, end));\r\n\r\n    normalized.push({ start, end });\r\n  }\r\n\r\n  normalized.sort((a, b) => a.start - b.start || a.end - b.end);\r\n\r\n  const merged: NormalizedRange[] = [];\r\n  for (const range of normalized) {\r\n    const prev = merged[merged.length - 1];\r\n    if (!prev) {\r\n      merged.push(range);\r\n      continue;\r\n    }\r\n\r\n    // Merge overlapping/adjacent ranges.\r\n    if (range.start <= prev.end + 1) {\r\n      prev.end = Math.max(prev.end, range.end);\r\n      continue;\r\n    }\r\n\r\n    merged.push(range);\r\n  }\r\n\r\n  return merged;\r\n}\r\n\r\nexport function applySystem1KeepRangesToOutput(params: {\r\n  rawOutput: string;\r\n  keepRanges: System1KeepRange[];\r\n  maxKeptLines: number;\r\n}): ApplySystem1KeepRangesResult | undefined {\r\n  assert(typeof params.rawOutput === \"string\", \"rawOutput must be a string\");\r\n  assert(Array.isArray(params.keepRanges), \"keepRanges must be an array\");\r\n  assert(\r\n    Number.isInteger(params.maxKeptLines) && params.maxKeptLines > 0,\r\n    \"maxKeptLines must be a positive integer\"\r\n  );\r\n\r\n  const lines = splitBashOutputLines(params.rawOutput);\r\n  const totalLines = lines.length;\r\n\r\n  if (totalLines === 0) {\r\n    return {\r\n      filteredOutput: \"\",\r\n      keptLines: 0,\r\n      totalLines: 0,\r\n    };\r\n  }\r\n\r\n  const normalized = normalizeKeepRanges(params.keepRanges, totalLines);\r\n  if (normalized.length === 0) {\r\n    return undefined;\r\n  }\r\n\r\n  const kept: string[] = [];\r\n  for (const range of normalized) {\r\n    for (let lineNo = range.start; lineNo <= range.end; lineNo += 1) {\r\n      kept.push(lines[lineNo - 1]);\r\n\r\n      if (kept.length >= params.maxKeptLines) {\r\n        return {\r\n          filteredOutput: kept.join(\"\\n\"),\r\n          keptLines: kept.length,\r\n          totalLines,\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    filteredOutput: kept.join(\"\\n\"),\r\n    keptLines: kept.length,\r\n    totalLines,\r\n  };\r\n}\r\n"]}