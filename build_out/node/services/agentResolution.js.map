{"version":3,"file":"agentResolution.js","sourceRoot":"","sources":["../../../src/node/services/agentResolution.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Agent resolution: resolves the active agent and computes tool policy for a stream.\n *\n * Extracted from `streamMessage()` to make the agent resolution logic\n * explicit and testable. Contains:\n * - Agent ID normalization & fallback to exec\n * - Agent definition loading with error recovery\n * - Disabled-agent enforcement (subagent workspaces error, top-level falls back)\n * - Inheritance chain resolution + plan-like detection\n * - Task nesting depth enforcement\n * - Tool policy composition (agent → caller → system workspace)\n * - Sentinel tool name computation for agent transition detection\n */\n\nimport * as os from \"os\";\nimport { AgentIdSchema } from \"@/common/orpc/schemas\";\nimport { MUX_HELP_CHAT_AGENT_ID, MUX_HELP_CHAT_WORKSPACE_ID } from \"@/common/constants/muxChat\";\nimport { DEFAULT_TASK_SETTINGS } from \"@/common/types/tasks\";\nimport type { ErrorEvent } from \"@/common/types/stream\";\nimport type { WorkspaceMetadata } from \"@/common/types/workspace\";\nimport type { ProjectsConfig } from \"@/common/types/project\";\nimport type { Result } from \"@/common/types/result\";\nimport { Ok, Err } from \"@/common/types/result\";\nimport type { SendMessageError } from \"@/common/types/errors\";\nimport { applyToolPolicy, type ToolPolicy } from \"@/common/utils/tools/toolPolicy\";\nimport { getToolsForModel } from \"@/common/utils/tools/tools\";\nimport { isPlanLikeInResolvedChain } from \"@/common/utils/agentTools\";\nimport type { Runtime } from \"@/node/runtime/Runtime\";\nimport { createRuntime } from \"@/node/runtime/runtimeFactory\";\nimport {\n  readAgentDefinition,\n  resolveAgentFrontmatter,\n} from \"@/node/services/agentDefinitions/agentDefinitionsService\";\nimport { isAgentEffectivelyDisabled } from \"@/node/services/agentDefinitions/agentEnablement\";\nimport { resolveToolPolicyForAgent } from \"@/node/services/agentDefinitions/resolveToolPolicy\";\nimport { resolveAgentInheritanceChain } from \"@/node/services/agentDefinitions/resolveAgentInheritanceChain\";\nimport type { InitStateManager } from \"./initStateManager\";\nimport { createAssistantMessageId } from \"./utils/messageIds\";\nimport { createErrorEvent } from \"./utils/sendMessageError\";\nimport { getTaskDepthFromConfig } from \"./taskUtils\";\nimport { log } from \"./log\";\n\n/** Options for agent resolution. */\nexport interface ResolveAgentOptions {\n  workspaceId: string;\n  metadata: WorkspaceMetadata;\n  runtime: Runtime;\n  workspacePath: string;\n  /** Requested agent ID from the frontend (may be undefined → defaults to exec). */\n  requestedAgentId: string | undefined;\n  /** When true, skip workspace-specific agents (for \"unbricking\" broken agent files). */\n  disableWorkspaceAgents: boolean;\n  modelString: string;\n  /** Caller-supplied tool policy (applied AFTER agent policy for further restriction). */\n  callerToolPolicy: ToolPolicy | undefined;\n  /** Loaded config from Config.loadConfigOrDefault(). */\n  cfg: ProjectsConfig;\n  /** Emit an error event on the AIService EventEmitter (for disabled-agent subagent errors). */\n  emitError: (event: ErrorEvent) => void;\n  /** For sentinel tool name computation. */\n  initStateManager: InitStateManager;\n}\n\n/** Result of agent resolution — all computed values needed by the stream pipeline. */\nexport interface AgentResolutionResult {\n  effectiveAgentId: string;\n  agentDefinition: Awaited<ReturnType<typeof readAgentDefinition>>;\n  /** Path used for agent discovery (workspace path or project path if agents disabled). */\n  agentDiscoveryPath: string;\n  isSubagentWorkspace: boolean;\n  /** Whether the resolved agent inherits plan-like behavior (has propose_plan in tool chain). */\n  agentIsPlanLike: boolean;\n  effectiveMode: \"plan\" | \"exec\" | \"compact\";\n  taskSettings: ProjectsConfig[\"taskSettings\"] & {};\n  taskDepth: number;\n  shouldDisableTaskToolsForDepth: boolean;\n  /** Composed tool policy: agent → caller → system workspace (in application order). */\n  effectiveToolPolicy: ToolPolicy | undefined;\n  /** Tool names for agent transition sentinel injection in message preparation. */\n  toolNamesForSentinel: string[];\n}\n\n/**\n * Resolve the active agent and compute tool policy for a stream request.\n *\n * This is the first major phase of `streamMessage()` after workspace/runtime setup.\n * It determines which agent definition to use, whether plan mode is active, and what\n * tools are available (via policy). The result feeds into message preparation,\n * system prompt construction, and tool assembly.\n *\n * Returns `Err` only when a disabled agent is requested in a subagent workspace\n * (top-level workspaces silently fall back to exec).\n */\nexport async function resolveAgentForStream(\n  opts: ResolveAgentOptions\n): Promise<Result<AgentResolutionResult, SendMessageError>> {\n  const {\n    workspaceId,\n    metadata,\n    runtime,\n    workspacePath,\n    requestedAgentId: rawAgentId,\n    disableWorkspaceAgents,\n    modelString,\n    callerToolPolicy,\n    cfg,\n    emitError,\n    initStateManager,\n  } = opts;\n\n  const workspaceLog = log.withFields({ workspaceId, workspaceName: metadata.name });\n\n  // --- Agent ID resolution ---\n  // Precedence:\n  // - Child workspaces (tasks) use their persisted agentId/agentType.\n  // - Main workspaces use the requested agentId (frontend), falling back to exec.\n  const requestedAgentIdRaw =\n    workspaceId === MUX_HELP_CHAT_WORKSPACE_ID\n      ? MUX_HELP_CHAT_AGENT_ID\n      : ((metadata.parentWorkspaceId ? (metadata.agentId ?? metadata.agentType) : undefined) ??\n        (typeof rawAgentId === \"string\" ? rawAgentId : undefined) ??\n        \"exec\");\n  const requestedAgentIdNormalized = requestedAgentIdRaw.trim().toLowerCase();\n  const parsedAgentId = AgentIdSchema.safeParse(requestedAgentIdNormalized);\n  const requestedAgentId = parsedAgentId.success ? parsedAgentId.data : (\"exec\" as const);\n  let effectiveAgentId = requestedAgentId;\n\n  // When disableWorkspaceAgents is true, skip workspace-specific agents entirely.\n  // Use project path so only built-in/global agents are available. This allows \"unbricking\"\n  // when iterating on agent files — a broken agent in the worktree won't affect message sending.\n  const agentDiscoveryPath = disableWorkspaceAgents ? metadata.projectPath : workspacePath;\n\n  const isSubagentWorkspace = Boolean(metadata.parentWorkspaceId);\n\n  // --- Load agent definition (with fallback to exec) ---\n  let agentDefinition;\n  try {\n    agentDefinition = await readAgentDefinition(runtime, agentDiscoveryPath, effectiveAgentId);\n  } catch (error) {\n    workspaceLog.warn(\"Failed to load agent definition; falling back to exec\", {\n      effectiveAgentId,\n      agentDiscoveryPath,\n      disableWorkspaceAgents,\n      error: error instanceof Error ? error.message : String(error),\n    });\n    agentDefinition = await readAgentDefinition(runtime, agentDiscoveryPath, \"exec\");\n  }\n\n  // Keep agent ID aligned with the actual definition used (may fall back to exec).\n  effectiveAgentId = agentDefinition.id;\n\n  // --- Disabled-agent enforcement ---\n  // Disabled agents should never run as sub-agents, even if a task workspace already exists\n  // on disk (e.g., config changed since creation).\n  // For top-level workspaces, fall back to exec to keep the workspace usable.\n  if (agentDefinition.id !== \"exec\") {\n    try {\n      const resolvedFrontmatter = await resolveAgentFrontmatter(\n        runtime,\n        agentDiscoveryPath,\n        agentDefinition.id\n      );\n\n      const effectivelyDisabled = isAgentEffectivelyDisabled({\n        cfg,\n        agentId: agentDefinition.id,\n        resolvedFrontmatter,\n      });\n\n      if (effectivelyDisabled) {\n        const errorMessage = `Agent '${agentDefinition.id}' is disabled.`;\n\n        if (isSubagentWorkspace) {\n          const errorMessageId = createAssistantMessageId();\n          emitError(\n            createErrorEvent(workspaceId, {\n              messageId: errorMessageId,\n              error: errorMessage,\n              errorType: \"unknown\",\n            })\n          );\n          return Err({ type: \"unknown\", raw: errorMessage });\n        }\n\n        workspaceLog.warn(\"Selected agent is disabled; falling back to exec\", {\n          agentId: agentDefinition.id,\n          requestedAgentId,\n        });\n        agentDefinition = await readAgentDefinition(runtime, agentDiscoveryPath, \"exec\");\n        effectiveAgentId = agentDefinition.id;\n      }\n    } catch (error: unknown) {\n      // Best-effort only — do not fail a stream due to disablement resolution.\n      workspaceLog.debug(\"Failed to resolve agent enablement; continuing\", {\n        agentId: agentDefinition.id,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n\n  // --- Inheritance chain & plan-like detection ---\n  const agentsForInheritance = await resolveAgentInheritanceChain({\n    runtime,\n    workspacePath: agentDiscoveryPath,\n    agentId: agentDefinition.id,\n    agentDefinition,\n    workspaceId,\n  });\n\n  const agentIsPlanLike = isPlanLikeInResolvedChain(agentsForInheritance);\n  const effectiveMode =\n    agentDefinition.id === \"compact\" ? \"compact\" : agentIsPlanLike ? \"plan\" : \"exec\";\n\n  // --- Task nesting depth enforcement ---\n  const taskSettings = cfg.taskSettings ?? DEFAULT_TASK_SETTINGS;\n  const taskDepth = getTaskDepthFromConfig(cfg, workspaceId);\n  const shouldDisableTaskToolsForDepth = taskDepth >= taskSettings.maxTaskNestingDepth;\n\n  // --- Tool policy composition ---\n  // Agent policy establishes baseline (deny-all + enable whitelist + runtime restrictions).\n  // Caller policy then narrows further if needed.\n  const agentToolPolicy = resolveToolPolicyForAgent({\n    agents: agentsForInheritance,\n    isSubagent: isSubagentWorkspace,\n    disableTaskToolsForDepth: shouldDisableTaskToolsForDepth,\n  });\n\n  // The Chat with Mux system workspace must remain sandboxed regardless of caller-supplied\n  // toolPolicy (defense-in-depth).\n  const systemWorkspaceToolPolicy: ToolPolicy | undefined =\n    workspaceId === MUX_HELP_CHAT_WORKSPACE_ID\n      ? [\n          { regex_match: \".*\", action: \"disable\" },\n\n          // Allow docs lookup via built-in skills (e.g. mux-docs), while keeping\n          // filesystem/binary execution locked down.\n          { regex_match: \"agent_skill_read\", action: \"enable\" },\n          { regex_match: \"agent_skill_read_file\", action: \"enable\" },\n\n          { regex_match: \"mux_global_agents_read\", action: \"enable\" },\n          { regex_match: \"mux_global_agents_write\", action: \"enable\" },\n          { regex_match: \"ask_user_question\", action: \"enable\" },\n          { regex_match: \"todo_read\", action: \"enable\" },\n          { regex_match: \"todo_write\", action: \"enable\" },\n          { regex_match: \"status_set\", action: \"enable\" },\n          { regex_match: \"notify\", action: \"enable\" },\n        ]\n      : undefined;\n\n  const effectiveToolPolicy: ToolPolicy | undefined =\n    callerToolPolicy || agentToolPolicy.length > 0 || systemWorkspaceToolPolicy\n      ? [...agentToolPolicy, ...(callerToolPolicy ?? []), ...(systemWorkspaceToolPolicy ?? [])]\n      : undefined;\n\n  // --- Sentinel tool names for agent transition detection ---\n  // Creates a throwaway runtime to compute the tool name list that the message pipeline\n  // uses for mode-transition sentinel injection. This avoids depending on the real\n  // tool assembly (which happens later) while still respecting tool policy.\n  const earlyRuntime = createRuntime({ type: \"local\", srcBaseDir: process.cwd() });\n  const earlyAllTools = await getToolsForModel(\n    modelString,\n    {\n      cwd: process.cwd(),\n      runtime: earlyRuntime,\n      runtimeTempDir: os.tmpdir(),\n      secrets: {},\n      planFileOnly: agentIsPlanLike,\n    },\n    \"\", // Empty workspace ID for early stub config\n    initStateManager,\n    undefined,\n    undefined\n  );\n  const earlyTools = applyToolPolicy(earlyAllTools, effectiveToolPolicy);\n  const toolNamesForSentinel = Object.keys(earlyTools);\n\n  return Ok({\n    effectiveAgentId,\n    agentDefinition,\n    agentDiscoveryPath,\n    isSubagentWorkspace,\n    agentIsPlanLike,\n    effectiveMode,\n    taskSettings,\n    taskDepth,\n    shouldDisableTaskToolsForDepth,\n    effectiveToolPolicy,\n    toolNamesForSentinel,\n  });\n}\n"]}