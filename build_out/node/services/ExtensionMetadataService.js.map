{"version":3,"file":"ExtensionMetadataService.js","sourceRoot":"","sources":["../../../src/node/services/ExtensionMetadataService.ts"],"names":[],"mappings":"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","sourcesContent":["import { dirname } from \"path\";\nimport { mkdir, readFile, access } from \"fs/promises\";\nimport { constants } from \"fs\";\nimport writeFileAtomic from \"write-file-atomic\";\nimport {\n  type ExtensionMetadata,\n  type ExtensionMetadataFile,\n  getExtensionMetadataPath,\n} from \"@/node/utils/extensionMetadata\";\nimport type { WorkspaceActivitySnapshot } from \"@/common/types/workspace\";\nimport { log } from \"@/node/services/log\";\n\n/**\n * Stateless service for managing workspace metadata used by VS Code extension integration.\n *\n * This service tracks:\n * - recency: Unix timestamp (ms) of last user interaction\n * - streaming: Boolean indicating if workspace has an active stream\n * - lastModel: Last model used in this workspace\n * - lastThinkingLevel: Last thinking/reasoning level used in this workspace\n *\n * File location: ~/.mux/extensionMetadata.json\n *\n * Design:\n * - Stateless: reads from disk on every operation, no in-memory cache\n * - Atomic writes: uses write-file-atomic to prevent corruption\n * - Read-heavy workload: extension reads, main app writes on user interactions\n */\n\nexport interface ExtensionWorkspaceMetadata extends ExtensionMetadata {\n  workspaceId: string;\n  updatedAt: number;\n}\n\nexport class ExtensionMetadataService {\n  private readonly filePath: string;\n  private toSnapshot(entry: ExtensionMetadata): WorkspaceActivitySnapshot {\n    return {\n      recency: entry.recency,\n      streaming: entry.streaming,\n      lastModel: entry.lastModel ?? null,\n      lastThinkingLevel: entry.lastThinkingLevel ?? null,\n    };\n  }\n\n  constructor(filePath?: string) {\n    this.filePath = filePath ?? getExtensionMetadataPath();\n  }\n\n  /**\n   * Initialize the service by ensuring directory exists and clearing stale streaming flags.\n   * Call this once on app startup.\n   */\n  async initialize(): Promise<void> {\n    // Ensure directory exists\n    const dir = dirname(this.filePath);\n    try {\n      await access(dir, constants.F_OK);\n    } catch {\n      await mkdir(dir, { recursive: true });\n    }\n\n    // Clear stale streaming flags (from crashes)\n    await this.clearStaleStreaming();\n  }\n\n  private async load(): Promise<ExtensionMetadataFile> {\n    try {\n      await access(this.filePath, constants.F_OK);\n    } catch {\n      return { version: 1, workspaces: {} };\n    }\n\n    try {\n      const content = await readFile(this.filePath, \"utf-8\");\n      const parsed = JSON.parse(content) as ExtensionMetadataFile;\n\n      // Validate structure\n      if (typeof parsed !== \"object\" || parsed.version !== 1) {\n        log.error(\"Invalid metadata file, resetting\");\n        return { version: 1, workspaces: {} };\n      }\n\n      return parsed;\n    } catch (error) {\n      log.error(\"Failed to load metadata:\", error);\n      return { version: 1, workspaces: {} };\n    }\n  }\n\n  private async save(data: ExtensionMetadataFile): Promise<void> {\n    try {\n      const content = JSON.stringify(data, null, 2);\n      await writeFileAtomic(this.filePath, content, \"utf-8\");\n    } catch (error) {\n      log.error(\"Failed to save metadata:\", error);\n    }\n  }\n\n  /**\n   * Update the recency timestamp for a workspace.\n   * Call this on user messages or other interactions.\n   */\n  async updateRecency(\n    workspaceId: string,\n    timestamp: number = Date.now()\n  ): Promise<WorkspaceActivitySnapshot> {\n    const data = await this.load();\n\n    if (!data.workspaces[workspaceId]) {\n      data.workspaces[workspaceId] = {\n        recency: timestamp,\n        streaming: false,\n        lastModel: null,\n        lastThinkingLevel: null,\n      };\n    } else {\n      data.workspaces[workspaceId].recency = timestamp;\n    }\n\n    await this.save(data);\n    const workspace = data.workspaces[workspaceId];\n    if (!workspace) {\n      throw new Error(`Workspace ${workspaceId} metadata missing after update.`);\n    }\n    return this.toSnapshot(workspace);\n  }\n\n  /**\n   * Set the streaming status for a workspace.\n   * Call this when streams start/end.\n   */\n  async setStreaming(\n    workspaceId: string,\n    streaming: boolean,\n    model?: string,\n    thinkingLevel?: ExtensionMetadata[\"lastThinkingLevel\"]\n  ): Promise<WorkspaceActivitySnapshot> {\n    const data = await this.load();\n    const now = Date.now();\n\n    if (!data.workspaces[workspaceId]) {\n      data.workspaces[workspaceId] = {\n        recency: now,\n        streaming,\n        lastModel: model ?? null,\n        lastThinkingLevel: thinkingLevel ?? null,\n      };\n    } else {\n      data.workspaces[workspaceId].streaming = streaming;\n      if (model) {\n        data.workspaces[workspaceId].lastModel = model;\n      }\n      if (thinkingLevel !== undefined) {\n        data.workspaces[workspaceId].lastThinkingLevel = thinkingLevel;\n      }\n    }\n\n    await this.save(data);\n    const workspace = data.workspaces[workspaceId];\n    if (!workspace) {\n      throw new Error(`Workspace ${workspaceId} metadata missing after streaming update.`);\n    }\n    return this.toSnapshot(workspace);\n  }\n\n  /**\n   * Get metadata for a single workspace.\n   */\n  async getMetadata(workspaceId: string): Promise<ExtensionWorkspaceMetadata | null> {\n    const data = await this.load();\n    const entry = data.workspaces[workspaceId];\n    if (!entry) return null;\n\n    return {\n      workspaceId,\n      updatedAt: entry.recency, // Use recency as updatedAt for backwards compatibility\n      ...entry,\n    };\n  }\n\n  /**\n   * Get all workspace metadata, ordered by recency.\n   * Used by VS Code extension to sort workspace list.\n   */\n  async getAllMetadata(): Promise<Map<string, ExtensionWorkspaceMetadata>> {\n    const data = await this.load();\n    const map = new Map<string, ExtensionWorkspaceMetadata>();\n\n    // Convert to array, sort by recency, then create map\n    const entries = Object.entries(data.workspaces);\n    entries.sort((a, b) => b[1].recency - a[1].recency);\n\n    for (const [workspaceId, entry] of entries) {\n      map.set(workspaceId, {\n        workspaceId,\n        updatedAt: entry.recency, // Use recency as updatedAt for backwards compatibility\n        ...entry,\n      });\n    }\n\n    return map;\n  }\n\n  /**\n   * Delete metadata for a workspace.\n   * Call this when a workspace is deleted.\n   */\n  async deleteWorkspace(workspaceId: string): Promise<void> {\n    const data = await this.load();\n\n    if (data.workspaces[workspaceId]) {\n      delete data.workspaces[workspaceId];\n      await this.save(data);\n    }\n  }\n\n  /**\n   * Clear all streaming flags.\n   * Call this on app startup to clean up stale streaming states from crashes.\n   */\n  async clearStaleStreaming(): Promise<void> {\n    const data = await this.load();\n    let modified = false;\n\n    for (const entry of Object.values(data.workspaces)) {\n      if (entry.streaming) {\n        entry.streaming = false;\n        modified = true;\n      }\n    }\n\n    if (modified) {\n      await this.save(data);\n    }\n  }\n\n  async getAllSnapshots(): Promise<Map<string, WorkspaceActivitySnapshot>> {\n    const data = await this.load();\n    const map = new Map<string, WorkspaceActivitySnapshot>();\n    for (const [workspaceId, entry] of Object.entries(data.workspaces)) {\n      map.set(workspaceId, this.toSnapshot(entry));\n    }\n    return map;\n  }\n}\n"]}