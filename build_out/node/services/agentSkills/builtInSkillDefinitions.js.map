{"version":3,"file":"builtInSkillDefinitions.js","sourceRoot":"","sources":["../../../../src/node/services/agentSkills/builtInSkillDefinitions.ts"],"names":[],"mappings":"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","sourcesContent":["import * as path from \"node:path\";\n\nimport type { AgentSkillDescriptor, AgentSkillPackage, SkillName } from \"@/common/types/agentSkill\";\nimport { parseSkillMarkdown } from \"./parseSkillMarkdown\";\nimport { BUILTIN_SKILL_FILES } from \"./builtInSkillContent.generated\";\n\n/**\n * Built-in skill definitions.\n *\n * Source of truth is:\n * - src/node/builtinSkills/*.md (SKILL.md content)\n * - docs/ (embedded for mux-docs)\n *\n * Content is generated into builtInSkillContent.generated.ts via scripts/gen_builtin_skills.ts.\n */\n\ninterface BuiltInSource {\n  name: SkillName;\n  files: Record<string, string>;\n}\n\nconst BUILT_IN_SOURCES: BuiltInSource[] = Object.entries(BUILTIN_SKILL_FILES).map(\n  ([name, files]) => ({ name, files })\n);\n\nlet cachedPackages: AgentSkillPackage[] | null = null;\n\nfunction parseBuiltIns(): AgentSkillPackage[] {\n  return BUILT_IN_SOURCES.map(({ name, files }) => {\n    const content = files[\"SKILL.md\"];\n    if (content === undefined) {\n      throw new Error(`Built-in skill '${name}' is missing SKILL.md`);\n    }\n\n    const parsed = parseSkillMarkdown({\n      content,\n      byteSize: Buffer.byteLength(content, \"utf8\"),\n      directoryName: name,\n    });\n\n    return {\n      scope: \"built-in\" as const,\n      directoryName: name,\n      frontmatter: parsed.frontmatter,\n      body: parsed.body.trim(),\n    };\n  });\n}\n\nexport function getBuiltInSkillDefinitions(): AgentSkillPackage[] {\n  cachedPackages ??= parseBuiltIns();\n  return cachedPackages;\n}\n\nexport function getBuiltInSkillDescriptors(): AgentSkillDescriptor[] {\n  return getBuiltInSkillDefinitions().map((pkg) => ({\n    name: pkg.frontmatter.name,\n    description: pkg.frontmatter.description,\n    scope: pkg.scope,\n    advertise: pkg.frontmatter.advertise,\n  }));\n}\n\nexport function getBuiltInSkillByName(name: SkillName): AgentSkillPackage | undefined {\n  return getBuiltInSkillDefinitions().find((pkg) => pkg.frontmatter.name === name);\n}\n\nfunction isAbsolutePathAny(filePath: string): boolean {\n  if (filePath.startsWith(\"/\") || filePath.startsWith(\"\\\\\")) return true;\n\n  // Windows drive letter paths (e.g., C:\\foo or C:/foo)\n  if (/^[A-Za-z]:/.test(filePath)) {\n    const sep = filePath[2];\n    return sep === \"\\\\\" || sep === \"/\";\n  }\n\n  return false;\n}\n\nfunction normalizeBuiltInSkillFilePath(filePath: string): string {\n  if (!filePath) {\n    throw new Error(\"filePath is required\");\n  }\n\n  // Disallow absolute paths and home-relative paths.\n  if (isAbsolutePathAny(filePath) || filePath.startsWith(\"~\")) {\n    throw new Error(`Invalid filePath (must be relative to the skill directory): ${filePath}`);\n  }\n\n  // Always normalize with posix separators (built-in skill file paths are stored posix-style).\n  const normalized = path.posix.normalize(filePath.replaceAll(\"\\\\\", \"/\"));\n  const stripped = normalized.startsWith(\"./\") ? normalized.slice(2) : normalized;\n\n  if (stripped === \"\" || stripped === \".\" || stripped.endsWith(\"/\")) {\n    throw new Error(`Invalid filePath (expected a file, got directory): ${filePath}`);\n  }\n\n  if (stripped === \"..\" || stripped.startsWith(\"../\")) {\n    throw new Error(`Invalid filePath (path traversal): ${filePath}`);\n  }\n\n  return stripped;\n}\n\nexport function readBuiltInSkillFile(\n  name: SkillName,\n  filePath: string\n): { resolvedPath: string; content: string } {\n  const resolvedPath = normalizeBuiltInSkillFilePath(filePath);\n\n  const skillFiles = BUILTIN_SKILL_FILES[name];\n  if (!skillFiles) {\n    throw new Error(`Built-in skill not found: ${name}`);\n  }\n\n  const content = skillFiles[resolvedPath];\n  if (content === undefined) {\n    throw new Error(`Built-in skill file not found: ${name}/${resolvedPath}`);\n  }\n\n  return { resolvedPath, content };\n}\n\n/** Exposed for testing - clears cached parsed packages */\nexport function clearBuiltInSkillCache(): void {\n  cachedPackages = null;\n}\n"]}