{"version":3,"file":"builtInSkillDefinitions.js","sourceRoot":"","sources":["../../../../src/node/services/agentSkills/builtInSkillDefinitions.ts"],"names":[],"mappings":"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","sourcesContent":["import * as path from \"node:path\";\r\n\r\nimport type { AgentSkillDescriptor, AgentSkillPackage, SkillName } from \"@/common/types/agentSkill\";\r\nimport { parseSkillMarkdown } from \"./parseSkillMarkdown\";\r\nimport { BUILTIN_SKILL_FILES } from \"./builtInSkillContent.generated\";\r\n\r\n/**\r\n * Built-in skill definitions.\r\n *\r\n * Source of truth is:\r\n * - src/node/builtinSkills/*.md (SKILL.md content)\r\n * - docs/ (embedded for mux-docs)\r\n *\r\n * Content is generated into builtInSkillContent.generated.ts via scripts/gen_builtin_skills.ts.\r\n */\r\n\r\ninterface BuiltInSource {\r\n  name: SkillName;\r\n  files: Record<string, string>;\r\n}\r\n\r\nconst BUILT_IN_SOURCES: BuiltInSource[] = Object.entries(BUILTIN_SKILL_FILES).map(\r\n  ([name, files]) => ({ name, files })\r\n);\r\n\r\nlet cachedPackages: AgentSkillPackage[] | null = null;\r\n\r\nfunction parseBuiltIns(): AgentSkillPackage[] {\r\n  return BUILT_IN_SOURCES.map(({ name, files }) => {\r\n    const content = files[\"SKILL.md\"];\r\n    if (content === undefined) {\r\n      throw new Error(`Built-in skill '${name}' is missing SKILL.md`);\r\n    }\r\n\r\n    const parsed = parseSkillMarkdown({\r\n      content,\r\n      byteSize: Buffer.byteLength(content, \"utf8\"),\r\n      directoryName: name,\r\n    });\r\n\r\n    return {\r\n      scope: \"built-in\" as const,\r\n      directoryName: name,\r\n      frontmatter: parsed.frontmatter,\r\n      body: parsed.body.trim(),\r\n    };\r\n  });\r\n}\r\n\r\nexport function getBuiltInSkillDefinitions(): AgentSkillPackage[] {\r\n  cachedPackages ??= parseBuiltIns();\r\n  return cachedPackages;\r\n}\r\n\r\nexport function getBuiltInSkillDescriptors(): AgentSkillDescriptor[] {\r\n  return getBuiltInSkillDefinitions().map((pkg) => ({\r\n    name: pkg.frontmatter.name,\r\n    description: pkg.frontmatter.description,\r\n    scope: pkg.scope,\r\n    advertise: pkg.frontmatter.advertise,\r\n  }));\r\n}\r\n\r\nexport function getBuiltInSkillByName(name: SkillName): AgentSkillPackage | undefined {\r\n  return getBuiltInSkillDefinitions().find((pkg) => pkg.frontmatter.name === name);\r\n}\r\n\r\nfunction isAbsolutePathAny(filePath: string): boolean {\r\n  if (filePath.startsWith(\"/\") || filePath.startsWith(\"\\\\\")) return true;\r\n\r\n  // Windows drive letter paths (e.g., C:\\foo or C:/foo)\r\n  if (/^[A-Za-z]:/.test(filePath)) {\r\n    const sep = filePath[2];\r\n    return sep === \"\\\\\" || sep === \"/\";\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction normalizeBuiltInSkillFilePath(filePath: string): string {\r\n  if (!filePath) {\r\n    throw new Error(\"filePath is required\");\r\n  }\r\n\r\n  // Disallow absolute paths and home-relative paths.\r\n  if (isAbsolutePathAny(filePath) || filePath.startsWith(\"~\")) {\r\n    throw new Error(`Invalid filePath (must be relative to the skill directory): ${filePath}`);\r\n  }\r\n\r\n  // Always normalize with posix separators (built-in skill file paths are stored posix-style).\r\n  const normalized = path.posix.normalize(filePath.replaceAll(\"\\\\\", \"/\"));\r\n  const stripped = normalized.startsWith(\"./\") ? normalized.slice(2) : normalized;\r\n\r\n  if (stripped === \"\" || stripped === \".\" || stripped.endsWith(\"/\")) {\r\n    throw new Error(`Invalid filePath (expected a file, got directory): ${filePath}`);\r\n  }\r\n\r\n  if (stripped === \"..\" || stripped.startsWith(\"../\")) {\r\n    throw new Error(`Invalid filePath (path traversal): ${filePath}`);\r\n  }\r\n\r\n  return stripped;\r\n}\r\n\r\nexport function readBuiltInSkillFile(\r\n  name: SkillName,\r\n  filePath: string\r\n): { resolvedPath: string; content: string } {\r\n  const resolvedPath = normalizeBuiltInSkillFilePath(filePath);\r\n\r\n  const skillFiles = BUILTIN_SKILL_FILES[name];\r\n  if (!skillFiles) {\r\n    throw new Error(`Built-in skill not found: ${name}`);\r\n  }\r\n\r\n  const content = skillFiles[resolvedPath];\r\n  if (content === undefined) {\r\n    throw new Error(`Built-in skill file not found: ${name}/${resolvedPath}`);\r\n  }\r\n\r\n  return { resolvedPath, content };\r\n}\r\n\r\n/** Exposed for testing - clears cached parsed packages */\r\nexport function clearBuiltInSkillCache(): void {\r\n  cachedPackages = null;\r\n}\r\n"]}