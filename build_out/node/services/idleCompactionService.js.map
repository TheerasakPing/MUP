{"version":3,"file":"idleCompactionService.js","sourceRoot":"","sources":["../../../src/node/services/idleCompactionService.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Config } from \"@/node/config\";\r\nimport type { HistoryService } from \"./historyService\";\r\nimport type { ExtensionMetadataService } from \"./ExtensionMetadataService\";\r\nimport { computeRecencyFromMessages } from \"@/common/utils/recency\";\r\nimport { log } from \"./log\";\r\n\r\nconst INITIAL_CHECK_DELAY_MS = 60 * 1000; // 1 minute - let frontend fully initialize\r\nconst CHECK_INTERVAL_MS = 60 * 60 * 1000; // 1 hour\r\nconst HOURS_TO_MS = 60 * 60 * 1000;\r\n\r\n/**\r\n * IdleCompactionService monitors workspaces for idle time and notifies\r\n * when they've been idle long enough to warrant compaction.\r\n *\r\n * The actual compaction is triggered by the frontend - this service just\r\n * checks eligibility and emits notifications via workspaceService.emitIdleCompactionNeeded().\r\n *\r\n * No pending state is tracked here. Double-triggering is prevented by:\r\n * - `currently_streaming` check blocks during active compaction\r\n * - `already_compacted` check blocks after compaction completes\r\n * - Frontend's triggeredWorkspacesRef deduplicates within a check cycle\r\n */\r\nexport class IdleCompactionService {\r\n  private readonly config: Config;\r\n  private readonly historyService: HistoryService;\r\n  private readonly extensionMetadata: ExtensionMetadataService;\r\n  private readonly emitIdleCompactionNeeded: (workspaceId: string) => void;\r\n  private initialTimeout: ReturnType<typeof setTimeout> | null = null;\r\n  private checkInterval: ReturnType<typeof setInterval> | null = null;\r\n\r\n  constructor(\r\n    config: Config,\r\n    historyService: HistoryService,\r\n    extensionMetadata: ExtensionMetadataService,\r\n    emitIdleCompactionNeeded: (workspaceId: string) => void\r\n  ) {\r\n    this.config = config;\r\n    this.historyService = historyService;\r\n    this.extensionMetadata = extensionMetadata;\r\n    this.emitIdleCompactionNeeded = emitIdleCompactionNeeded;\r\n  }\r\n\r\n  /**\r\n   * Start the idle compaction checker.\r\n   * First check after 1 minute (let frontend fully initialize), then every hour.\r\n   */\r\n  start(): void {\r\n    // First check after delay to let frontend initialize and subscribe\r\n    this.initialTimeout = setTimeout(() => {\r\n      void this.checkAllWorkspaces();\r\n      // Then periodically\r\n      this.checkInterval = setInterval(() => {\r\n        void this.checkAllWorkspaces();\r\n      }, CHECK_INTERVAL_MS);\r\n    }, INITIAL_CHECK_DELAY_MS);\r\n    log.info(\"IdleCompactionService started\", {\r\n      initialDelayMs: INITIAL_CHECK_DELAY_MS,\r\n      intervalMs: CHECK_INTERVAL_MS,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Stop the idle compaction checker.\r\n   */\r\n  stop(): void {\r\n    if (this.initialTimeout) {\r\n      clearTimeout(this.initialTimeout);\r\n      this.initialTimeout = null;\r\n    }\r\n    if (this.checkInterval) {\r\n      clearInterval(this.checkInterval);\r\n      this.checkInterval = null;\r\n    }\r\n    log.info(\"IdleCompactionService stopped\");\r\n  }\r\n\r\n  /**\r\n   * Check all workspaces across all projects for idle compaction eligibility.\r\n   */\r\n  async checkAllWorkspaces(): Promise<void> {\r\n    const projectsConfig = this.config.loadConfigOrDefault();\r\n    const now = Date.now();\r\n\r\n    for (const [projectPath, projectConfig] of projectsConfig.projects) {\r\n      const idleHours = projectConfig.idleCompactionHours;\r\n      if (idleHours == null || idleHours < 1) continue;\r\n\r\n      const thresholdMs = idleHours * HOURS_TO_MS;\r\n\r\n      for (const workspace of projectConfig.workspaces) {\r\n        const workspaceId = workspace.id ?? workspace.name;\r\n        if (!workspaceId) continue;\r\n\r\n        try {\r\n          await this.checkWorkspace(workspaceId, projectPath, thresholdMs, now);\r\n        } catch (error) {\r\n          log.error(\"Idle compaction check failed\", { workspaceId, error });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private async checkWorkspace(\r\n    workspaceId: string,\r\n    _projectPath: string,\r\n    thresholdMs: number,\r\n    now: number\r\n  ): Promise<void> {\r\n    // Check eligibility\r\n    const eligibility = await this.checkEligibility(workspaceId, thresholdMs, now);\r\n    if (!eligibility.eligible) {\r\n      log.debug(\"Workspace not eligible for idle compaction\", {\r\n        workspaceId,\r\n        reason: eligibility.reason,\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Notify frontend to trigger compaction\r\n    log.info(\"Workspace eligible for idle compaction\", {\r\n      workspaceId,\r\n      idleHours: thresholdMs / HOURS_TO_MS,\r\n    });\r\n    this.notifyNeedsCompaction(workspaceId);\r\n  }\r\n\r\n  /**\r\n   * Check if a workspace is eligible for idle compaction.\r\n   */\r\n  async checkEligibility(\r\n    workspaceId: string,\r\n    thresholdMs: number,\r\n    now: number\r\n  ): Promise<{ eligible: boolean; reason?: string }> {\r\n    // 1. Has messages? Only need tail messages â€” recency + last-message checks don't need full history.\r\n    const historyResult = await this.historyService.getLastMessages(workspaceId, 50);\r\n    if (!historyResult.success || historyResult.data.length === 0) {\r\n      return { eligible: false, reason: \"no_messages\" };\r\n    }\r\n    const messages = historyResult.data;\r\n\r\n    // 2. Check recency from messages (single source of truth)\r\n    const recency = computeRecencyFromMessages(messages);\r\n    if (recency === null) {\r\n      return { eligible: false, reason: \"no_recency_data\" };\r\n    }\r\n    const idleMs = now - recency;\r\n    if (idleMs < thresholdMs) {\r\n      return { eligible: false, reason: \"not_idle_enough\" };\r\n    }\r\n\r\n    // 3. Currently streaming?\r\n    const activity = await this.extensionMetadata.getMetadata(workspaceId);\r\n    if (activity?.streaming) {\r\n      return { eligible: false, reason: \"currently_streaming\" };\r\n    }\r\n\r\n    // 4. Already compacted? (last message is compacted summary)\r\n    const lastMessage = messages[messages.length - 1];\r\n    // Support both new enum (\"user\"|\"idle\") and legacy boolean (true)\r\n    if (lastMessage?.metadata?.compacted) {\r\n      return { eligible: false, reason: \"already_compacted\" };\r\n    }\r\n\r\n    // 5. Last message is user message with no response? (incomplete conversation)\r\n    if (lastMessage?.role === \"user\") {\r\n      return { eligible: false, reason: \"awaiting_response\" };\r\n    }\r\n\r\n    return { eligible: true };\r\n  }\r\n\r\n  /**\r\n   * Notify that a workspace needs idle compaction.\r\n   */\r\n  private notifyNeedsCompaction(workspaceId: string): void {\r\n    this.emitIdleCompactionNeeded(workspaceId);\r\n  }\r\n}\r\n"]}