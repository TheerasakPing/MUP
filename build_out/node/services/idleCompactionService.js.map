{"version":3,"file":"idleCompactionService.js","sourceRoot":"","sources":["../../../src/node/services/idleCompactionService.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Config } from \"@/node/config\";\nimport type { HistoryService } from \"./historyService\";\nimport type { ExtensionMetadataService } from \"./ExtensionMetadataService\";\nimport { computeRecencyFromMessages } from \"@/common/utils/recency\";\nimport { log } from \"./log\";\n\nconst INITIAL_CHECK_DELAY_MS = 60 * 1000; // 1 minute - let frontend fully initialize\nconst CHECK_INTERVAL_MS = 60 * 60 * 1000; // 1 hour\nconst HOURS_TO_MS = 60 * 60 * 1000;\n\n/**\n * IdleCompactionService monitors workspaces for idle time and notifies\n * when they've been idle long enough to warrant compaction.\n *\n * The actual compaction is triggered by the frontend - this service just\n * checks eligibility and emits notifications via workspaceService.emitIdleCompactionNeeded().\n *\n * No pending state is tracked here. Double-triggering is prevented by:\n * - `currently_streaming` check blocks during active compaction\n * - `already_compacted` check blocks after compaction completes\n * - Frontend's triggeredWorkspacesRef deduplicates within a check cycle\n */\nexport class IdleCompactionService {\n  private readonly config: Config;\n  private readonly historyService: HistoryService;\n  private readonly extensionMetadata: ExtensionMetadataService;\n  private readonly emitIdleCompactionNeeded: (workspaceId: string) => void;\n  private initialTimeout: ReturnType<typeof setTimeout> | null = null;\n  private checkInterval: ReturnType<typeof setInterval> | null = null;\n\n  constructor(\n    config: Config,\n    historyService: HistoryService,\n    extensionMetadata: ExtensionMetadataService,\n    emitIdleCompactionNeeded: (workspaceId: string) => void\n  ) {\n    this.config = config;\n    this.historyService = historyService;\n    this.extensionMetadata = extensionMetadata;\n    this.emitIdleCompactionNeeded = emitIdleCompactionNeeded;\n  }\n\n  /**\n   * Start the idle compaction checker.\n   * First check after 1 minute (let frontend fully initialize), then every hour.\n   */\n  start(): void {\n    // First check after delay to let frontend initialize and subscribe\n    this.initialTimeout = setTimeout(() => {\n      void this.checkAllWorkspaces();\n      // Then periodically\n      this.checkInterval = setInterval(() => {\n        void this.checkAllWorkspaces();\n      }, CHECK_INTERVAL_MS);\n    }, INITIAL_CHECK_DELAY_MS);\n    log.info(\"IdleCompactionService started\", {\n      initialDelayMs: INITIAL_CHECK_DELAY_MS,\n      intervalMs: CHECK_INTERVAL_MS,\n    });\n  }\n\n  /**\n   * Stop the idle compaction checker.\n   */\n  stop(): void {\n    if (this.initialTimeout) {\n      clearTimeout(this.initialTimeout);\n      this.initialTimeout = null;\n    }\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = null;\n    }\n    log.info(\"IdleCompactionService stopped\");\n  }\n\n  /**\n   * Check all workspaces across all projects for idle compaction eligibility.\n   */\n  async checkAllWorkspaces(): Promise<void> {\n    const projectsConfig = this.config.loadConfigOrDefault();\n    const now = Date.now();\n\n    for (const [projectPath, projectConfig] of projectsConfig.projects) {\n      const idleHours = projectConfig.idleCompactionHours;\n      if (idleHours == null || idleHours < 1) continue;\n\n      const thresholdMs = idleHours * HOURS_TO_MS;\n\n      for (const workspace of projectConfig.workspaces) {\n        const workspaceId = workspace.id ?? workspace.name;\n        if (!workspaceId) continue;\n\n        try {\n          await this.checkWorkspace(workspaceId, projectPath, thresholdMs, now);\n        } catch (error) {\n          log.error(\"Idle compaction check failed\", { workspaceId, error });\n        }\n      }\n    }\n  }\n\n  private async checkWorkspace(\n    workspaceId: string,\n    _projectPath: string,\n    thresholdMs: number,\n    now: number\n  ): Promise<void> {\n    // Check eligibility\n    const eligibility = await this.checkEligibility(workspaceId, thresholdMs, now);\n    if (!eligibility.eligible) {\n      log.debug(\"Workspace not eligible for idle compaction\", {\n        workspaceId,\n        reason: eligibility.reason,\n      });\n      return;\n    }\n\n    // Notify frontend to trigger compaction\n    log.info(\"Workspace eligible for idle compaction\", {\n      workspaceId,\n      idleHours: thresholdMs / HOURS_TO_MS,\n    });\n    this.notifyNeedsCompaction(workspaceId);\n  }\n\n  /**\n   * Check if a workspace is eligible for idle compaction.\n   */\n  async checkEligibility(\n    workspaceId: string,\n    thresholdMs: number,\n    now: number\n  ): Promise<{ eligible: boolean; reason?: string }> {\n    // 1. Has messages? Only need tail messages â€” recency + last-message checks don't need full history.\n    const historyResult = await this.historyService.getLastMessages(workspaceId, 50);\n    if (!historyResult.success || historyResult.data.length === 0) {\n      return { eligible: false, reason: \"no_messages\" };\n    }\n    const messages = historyResult.data;\n\n    // 2. Check recency from messages (single source of truth)\n    const recency = computeRecencyFromMessages(messages);\n    if (recency === null) {\n      return { eligible: false, reason: \"no_recency_data\" };\n    }\n    const idleMs = now - recency;\n    if (idleMs < thresholdMs) {\n      return { eligible: false, reason: \"not_idle_enough\" };\n    }\n\n    // 3. Currently streaming?\n    const activity = await this.extensionMetadata.getMetadata(workspaceId);\n    if (activity?.streaming) {\n      return { eligible: false, reason: \"currently_streaming\" };\n    }\n\n    // 4. Already compacted? (last message is compacted summary)\n    const lastMessage = messages[messages.length - 1];\n    // Support both new enum (\"user\"|\"idle\") and legacy boolean (true)\n    if (lastMessage?.metadata?.compacted) {\n      return { eligible: false, reason: \"already_compacted\" };\n    }\n\n    // 5. Last message is user message with no response? (incomplete conversation)\n    if (lastMessage?.role === \"user\") {\n      return { eligible: false, reason: \"awaiting_response\" };\n    }\n\n    return { eligible: true };\n  }\n\n  /**\n   * Notify that a workspace needs idle compaction.\n   */\n  private notifyNeedsCompaction(workspaceId: string): void {\n    this.emitIdleCompactionNeeded(workspaceId);\n  }\n}\n"]}