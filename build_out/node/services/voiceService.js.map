{"version":3,"file":"voiceService.js","sourceRoot":"","sources":["../../../src/node/services/voiceService.ts"],"names":[],"mappings":";;;AAGA;;GAEG;AACH;IAC+B,MAAM;IAAnC,YAA6B,MAAc,EAAE;sBAAhB,MAAM;IAAW,CAAC;IAE/C;;;;OAIG;IACH,KAAK,CAAC,UAAU,CAAC,WAAmB,EAAmC;QACrE,IAAI,CAAC;YACH,iCAAiC;YACjC,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,mBAAmB,EAAE,IAAI,EAAE,CAAC;YAChE,MAAM,YAAY,GAAG,eAAe,CAAC,MAAyC,CAAC;YAC/E,MAAM,MAAM,GAAG,YAAY,EAAE,MAAM,CAAC;YAEpC,IAAI,CAAC,MAAM,EAAE,CAAC;gBACZ,OAAO;oBACL,OAAO,EAAE,KAAK;oBACd,KAAK,EAAE,8EAA4E;iBACpF,CAAC;YACJ,CAAC;YAED,0BAA0B;YAC1B,MAAM,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC;YACvC,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;YAClD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC7C,KAAK,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YACxC,CAAC;YACD,MAAM,SAAS,GAAG,IAAI,IAAI,CAAC,CAAC,KAAK,CAAC,EAAE,EAAE,IAAI,EAAE,YAAY,EAAE,CAAC,CAAC;YAE5D,kCAAkC;YAClC,MAAM,QAAQ,GAAG,IAAI,QAAQ,EAAE,CAAC;YAChC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,SAAS,EAAE,YAAY,CAAC,CAAC;YACjD,QAAQ,CAAC,MAAM,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;YACtC,QAAQ,CAAC,MAAM,CAAC,iBAAiB,EAAE,MAAM,CAAC,CAAC;YAE3C,0BAA0B;YAC1B,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,gDAAgD,EAAE;gBAC7E,MAAM,EAAE,MAAM;gBACd,OAAO,EAAE;oBACP,aAAa,EAAE,UAAU,MAAM,EAAE;iBAClC;gBACD,IAAI,EAAE,QAAQ;aACf,CAAC,CAAC;YAEH,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC;gBACjB,MAAM,SAAS,GAAG,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAC;gBACxC,IAAI,YAAY,GAAG,yBAAyB,QAAQ,CAAC,MAAM,EAAE,CAAC;gBAC9D,IAAI,CAAC;oBACH,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAqC,CAAC;oBAC5E,IAAI,SAAS,CAAC,KAAK,EAAE,OAAO,EAAE,CAAC;wBAC7B,YAAY,GAAG,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC;oBACzC,CAAC;gBACH,CAAC;gBAAC,MAAM,CAAC;oBACP,2CAA2C;oBAC3C,IAAI,SAAS,EAAE,CAAC;wBACd,YAAY,GAAG,SAAS,CAAC;oBAC3B,CAAC;gBACH,CAAC;gBACD,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,YAAY,EAAE,CAAC;YACjD,CAAC;YAED,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAC;YACnC,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;QACvC,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACvE,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,yBAAyB,OAAO,EAAE,EAAE,CAAC;QACvE,CAAC;IAAA,CACF;CACF","sourcesContent":["import type { Config } from \"@/node/config\";\nimport type { Result } from \"@/common/types/result\";\n\n/**\n * Voice input service using OpenAI's Whisper API for transcription.\n */\nexport class VoiceService {\n  constructor(private readonly config: Config) {}\n\n  /**\n   * Transcribe audio from base64-encoded data using OpenAI's Whisper API.\n   * @param audioBase64 Base64-encoded audio data\n   * @returns Transcribed text or error\n   */\n  async transcribe(audioBase64: string): Promise<Result<string, string>> {\n    try {\n      // Get OpenAI API key from config\n      const providersConfig = this.config.loadProvidersConfig() ?? {};\n      const openaiConfig = providersConfig.openai as { apiKey?: string } | undefined;\n      const apiKey = openaiConfig?.apiKey;\n\n      if (!apiKey) {\n        return {\n          success: false,\n          error: \"OpenAI API key not configured. Go to Settings â†’ Providers to add your key.\",\n        };\n      }\n\n      // Decode base64 to binary\n      const binaryString = atob(audioBase64);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      const audioBlob = new Blob([bytes], { type: \"audio/webm\" });\n\n      // Create form data for OpenAI API\n      const formData = new FormData();\n      formData.append(\"file\", audioBlob, \"audio.webm\");\n      formData.append(\"model\", \"whisper-1\");\n      formData.append(\"response_format\", \"text\");\n\n      // Call OpenAI Whisper API\n      const response = await fetch(\"https://api.openai.com/v1/audio/transcriptions\", {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${apiKey}`,\n        },\n        body: formData,\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        let errorMessage = `Transcription failed: ${response.status}`;\n        try {\n          const errorJson = JSON.parse(errorText) as { error?: { message?: string } };\n          if (errorJson.error?.message) {\n            errorMessage = errorJson.error.message;\n          }\n        } catch {\n          // Use raw error text if JSON parsing fails\n          if (errorText) {\n            errorMessage = errorText;\n          }\n        }\n        return { success: false, error: errorMessage };\n      }\n\n      const text = await response.text();\n      return { success: true, data: text };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return { success: false, error: `Transcription failed: ${message}` };\n    }\n  }\n}\n"]}