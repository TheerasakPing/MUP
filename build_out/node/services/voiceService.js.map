{"version":3,"file":"voiceService.js","sourceRoot":"","sources":["../../../src/node/services/voiceService.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Config } from \"@/node/config\";\r\nimport type { Result } from \"@/common/types/result\";\r\n\r\n/**\r\n * Voice input service using OpenAI's Whisper API for transcription.\r\n */\r\nexport class VoiceService {\r\n  constructor(private readonly config: Config) {}\r\n\r\n  /**\r\n   * Transcribe audio from base64-encoded data using OpenAI's Whisper API.\r\n   * @param audioBase64 Base64-encoded audio data\r\n   * @returns Transcribed text or error\r\n   */\r\n  async transcribe(audioBase64: string): Promise<Result<string, string>> {\r\n    try {\r\n      // Get OpenAI API key from config\r\n      const providersConfig = this.config.loadProvidersConfig() ?? {};\r\n      const openaiConfig = providersConfig.openai as { apiKey?: string } | undefined;\r\n      const apiKey = openaiConfig?.apiKey;\r\n\r\n      if (!apiKey) {\r\n        return {\r\n          success: false,\r\n          error: \"OpenAI API key not configured. Go to Settings â†’ Providers to add your key.\",\r\n        };\r\n      }\r\n\r\n      // Decode base64 to binary\r\n      const binaryString = atob(audioBase64);\r\n      const bytes = new Uint8Array(binaryString.length);\r\n      for (let i = 0; i < binaryString.length; i++) {\r\n        bytes[i] = binaryString.charCodeAt(i);\r\n      }\r\n      const audioBlob = new Blob([bytes], { type: \"audio/webm\" });\r\n\r\n      // Create form data for OpenAI API\r\n      const formData = new FormData();\r\n      formData.append(\"file\", audioBlob, \"audio.webm\");\r\n      formData.append(\"model\", \"whisper-1\");\r\n      formData.append(\"response_format\", \"text\");\r\n\r\n      // Call OpenAI Whisper API\r\n      const response = await fetch(\"https://api.openai.com/v1/audio/transcriptions\", {\r\n        method: \"POST\",\r\n        headers: {\r\n          Authorization: `Bearer ${apiKey}`,\r\n        },\r\n        body: formData,\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errorText = await response.text();\r\n        let errorMessage = `Transcription failed: ${response.status}`;\r\n        try {\r\n          const errorJson = JSON.parse(errorText) as { error?: { message?: string } };\r\n          if (errorJson.error?.message) {\r\n            errorMessage = errorJson.error.message;\r\n          }\r\n        } catch {\r\n          // Use raw error text if JSON parsing fails\r\n          if (errorText) {\r\n            errorMessage = errorText;\r\n          }\r\n        }\r\n        return { success: false, error: errorMessage };\r\n      }\r\n\r\n      const text = await response.text();\r\n      return { success: true, data: text };\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      return { success: false, error: `Transcription failed: ${message}` };\r\n    }\r\n  }\r\n}\r\n"]}