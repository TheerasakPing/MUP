{"version":3,"file":"mcpResultTransform.test.js","sourceRoot":"","sources":["../../../src/node/services/mcpResultTransform.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, it, expect } from \"bun:test\";\nimport { transformMCPResult, MAX_IMAGE_DATA_BYTES } from \"./mcpResultTransform\";\n\ndescribe(\"transformMCPResult\", () => {\n  describe(\"image data overflow handling\", () => {\n    it(\"should pass through small images unchanged\", () => {\n      const smallImageData = \"a\".repeat(1000); // 1KB of base64 data\n      const result = transformMCPResult({\n        content: [\n          { type: \"text\", text: \"Screenshot taken\" },\n          { type: \"image\", data: smallImageData, mimeType: \"image/png\" },\n        ],\n      });\n\n      expect(result).toEqual({\n        type: \"content\",\n        value: [\n          { type: \"text\", text: \"Screenshot taken\" },\n          { type: \"media\", data: smallImageData, mediaType: \"image/png\" },\n        ],\n      });\n    });\n\n    it(\"should omit large image data to prevent context overflow\", () => {\n      // Create a large base64 string that simulates a screenshot\n      // Even 50KB of base64 would be ~12,500 tokens when treated as text\n      const largeImageData = \"x\".repeat(MAX_IMAGE_DATA_BYTES + 10_000);\n      const result = transformMCPResult({\n        content: [\n          { type: \"text\", text: \"Screenshot taken\" },\n          { type: \"image\", data: largeImageData, mimeType: \"image/png\" },\n        ],\n      });\n\n      const transformed = result as {\n        type: \"content\";\n        value: Array<{ type: string; text?: string; data?: string; mediaType?: string }>;\n      };\n\n      expect(transformed.type).toBe(\"content\");\n      expect(transformed.value).toHaveLength(2);\n      expect(transformed.value[0]).toEqual({ type: \"text\", text: \"Screenshot taken\" });\n\n      // The image should be replaced with a text message explaining why it was omitted\n      const imageResult = transformed.value[1];\n      expect(imageResult.type).toBe(\"text\");\n      expect(imageResult.text).toContain(\"Image omitted\");\n      expect(imageResult.text).toContain(\"per-image guard\");\n    });\n\n    it(\"should handle multiple images, omitting only the oversized ones\", () => {\n      const smallImageData = \"small\".repeat(100);\n      const largeImageData = \"x\".repeat(MAX_IMAGE_DATA_BYTES + 5_000);\n\n      const result = transformMCPResult({\n        content: [\n          { type: \"image\", data: smallImageData, mimeType: \"image/png\" },\n          { type: \"image\", data: largeImageData, mimeType: \"image/jpeg\" },\n        ],\n      });\n\n      const transformed = result as {\n        type: \"content\";\n        value: Array<{ type: string; text?: string; data?: string; mediaType?: string }>;\n      };\n\n      expect(transformed.value).toHaveLength(2);\n      // Small image passes through\n      expect(transformed.value[0]).toEqual({\n        type: \"media\",\n        data: smallImageData,\n        mediaType: \"image/png\",\n      });\n      // Large image gets omitted with explanation\n      expect(transformed.value[1].type).toBe(\"text\");\n      expect(transformed.value[1].text).toContain(\"Image omitted\");\n    });\n\n    it(\"should mention size and guard limit in omission message\", () => {\n      // 100KB of base64 data should trigger the guard if limit is smaller, but we keep it big here\n      const largeImageData = \"y\".repeat(MAX_IMAGE_DATA_BYTES + 1_000);\n      const result = transformMCPResult({\n        content: [{ type: \"image\", data: largeImageData, mimeType: \"image/png\" }],\n      });\n\n      const transformed = result as {\n        type: \"content\";\n        value: Array<{ type: string; text?: string }>;\n      };\n\n      expect(transformed.value[0].type).toBe(\"text\");\n      // Should mention size and guard\n      expect(transformed.value[0].text).toMatch(/Image omitted/);\n      expect(transformed.value[0].text).toMatch(/per-image guard/i);\n      expect(transformed.value[0].text).toMatch(/MB|KB/);\n    });\n  });\n\n  describe(\"existing functionality\", () => {\n    it(\"should pass through error results unchanged\", () => {\n      const errorResult = {\n        isError: true,\n        content: [{ type: \"text\" as const, text: \"Error!\" }],\n      };\n      expect(transformMCPResult(errorResult)).toBe(errorResult);\n    });\n\n    it(\"should pass through toolResult unchanged\", () => {\n      const toolResult = { toolResult: { foo: \"bar\" } };\n      expect(transformMCPResult(toolResult)).toBe(toolResult);\n    });\n\n    it(\"should pass through results without content array\", () => {\n      const noContent = { something: \"else\" };\n      expect(transformMCPResult(noContent as never)).toBe(noContent);\n    });\n\n    it(\"should pass through text-only content without transformation wrapper\", () => {\n      const textOnly = {\n        content: [\n          { type: \"text\" as const, text: \"Hello\" },\n          { type: \"text\" as const, text: \"World\" },\n        ],\n      };\n      // No images = no transformation needed\n      expect(transformMCPResult(textOnly)).toBe(textOnly);\n    });\n\n    it(\"should convert resource content to text\", () => {\n      const result = transformMCPResult({\n        content: [\n          { type: \"image\", data: \"abc\", mimeType: \"image/png\" },\n          { type: \"resource\", resource: { uri: \"file:///test.txt\", text: \"File content\" } },\n        ],\n      });\n\n      const transformed = result as {\n        type: \"content\";\n        value: Array<{ type: string; text?: string; data?: string }>;\n      };\n\n      expect(transformed.value[1]).toEqual({ type: \"text\", text: \"File content\" });\n    });\n\n    it(\"should default to image/png when mimeType is missing\", () => {\n      const result = transformMCPResult({\n        content: [{ type: \"image\", data: \"abc\", mimeType: \"\" }],\n      });\n\n      const transformed = result as {\n        type: \"content\";\n        value: Array<{ type: string; mediaType?: string }>;\n      };\n\n      expect(transformed.value[0].mediaType).toBe(\"image/png\");\n    });\n  });\n});\n"]}