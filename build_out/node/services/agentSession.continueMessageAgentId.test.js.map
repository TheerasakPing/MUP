{"version":3,"file":"agentSession.continueMessageAgentId.test.js","sourceRoot":"","sources":["../../../src/node/services/agentSession.continueMessageAgentId.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, expect, test, mock, afterEach } from \"bun:test\";\nimport { buildContinueMessage } from \"@/common/types/message\";\nimport type { FilePart, SendMessageOptions } from \"@/common/orpc/types\";\nimport { AgentSession } from \"./agentSession\";\nimport type { Config } from \"@/node/config\";\nimport type { AIService } from \"./aiService\";\nimport type { BackgroundProcessManager } from \"./backgroundProcessManager\";\nimport type { InitStateManager } from \"./initStateManager\";\nimport type { PartialService } from \"./partialService\";\nimport type { MuxMessage } from \"@/common/types/message\";\nimport { createTestHistoryService } from \"./testHistoryService\";\nimport type { CostTrackingService } from \"./costTrackingService\";\n\n// NOTE: This test validates that legacy `mode` field in follow-up content is correctly\n// converted to `agentId` during dispatch. With the crash-safe follow-up architecture,\n// the follow-up is stored on the compaction summary message and dispatched from there.\n\ntype SendOptions = SendMessageOptions & { fileParts?: FilePart[] };\n\ninterface SessionInternals {\n  dispatchPendingFollowUp: () => Promise<void>;\n  sendMessage: (message: string, options?: SendOptions) => Promise<{ success: boolean }>;\n}\n\ndescribe(\"AgentSession continue-message agentId fallback\", () => {\n  let historyCleanup: (() => Promise<void>) | undefined;\n  afterEach(async () => {\n    await historyCleanup?.();\n  });\n\n  test(\"legacy continueMessage.mode does not fall back to compact agent\", async () => {\n    // Track the follow-up message that gets dispatched\n    let dispatchedMessage: string | undefined;\n    let dispatchedOptions: SendOptions | undefined;\n\n    const aiService: AIService = {\n      on() {\n        return this;\n      },\n      off() {\n        return this;\n      },\n      isStreaming: () => false,\n      stopStream: mock(() => Promise.resolve({ success: true as const, data: undefined })),\n    } as unknown as AIService;\n\n    // Create a mock compaction summary with legacy mode field\n    const baseContinueMessage = buildContinueMessage({\n      text: \"follow up\",\n      model: \"openai:gpt-4o\",\n      agentId: \"exec\",\n    });\n    if (!baseContinueMessage) {\n      throw new Error(\"Expected base continue message to be built\");\n    }\n\n    // Simulate legacy format: no agentId, but has mode instead\n    const legacyFollowUp = {\n      text: baseContinueMessage.text,\n      model: \"openai:gpt-4o\",\n      agentId: undefined as unknown as string, // Legacy: missing agentId\n      mode: \"plan\" as const, // Legacy: mode field instead of agentId\n    };\n\n    // Mock history service to return a compaction summary with pending follow-up\n    const mockSummaryMessage = {\n      id: \"summary-1\",\n      role: \"assistant\" as const,\n      parts: [{ type: \"text\" as const, text: \"Compaction summary\" }],\n      metadata: {\n        muxMetadata: {\n          type: \"compaction-summary\" as const,\n          pendingFollowUp: legacyFollowUp,\n        },\n      },\n    } satisfies MuxMessage;\n\n    const { historyService, cleanup } = await createTestHistoryService();\n    historyCleanup = cleanup;\n    await historyService.appendToHistory(\"ws\", mockSummaryMessage);\n\n    const initStateManager: InitStateManager = {\n      on() {\n        return this;\n      },\n      off() {\n        return this;\n      },\n    } as unknown as InitStateManager;\n\n    const backgroundProcessManager: BackgroundProcessManager = {\n      cleanup: mock(() => Promise.resolve()),\n      setMessageQueued: mock(() => undefined),\n    } as unknown as BackgroundProcessManager;\n\n    const config: Config = {\n      srcDir: \"/tmp\",\n      getSessionDir: mock(() => \"/tmp\"),\n    } as unknown as Config;\n    const partialService: PartialService = {} as unknown as PartialService;\n\n    const session = new AgentSession({\n      workspaceId: \"ws\",\n      config,\n      historyService,\n      partialService,\n      aiService,\n      initStateManager,\n      costTrackingService: {} as unknown as CostTrackingService,\n      backgroundProcessManager,\n    });\n\n    const internals = session as unknown as SessionInternals;\n\n    // Intercept sendMessage to capture what dispatchPendingFollowUp sends\n    internals.sendMessage = mock((message: string, options?: SendOptions) => {\n      dispatchedMessage = message;\n      dispatchedOptions = options;\n      return Promise.resolve({ success: true });\n    });\n\n    // Call dispatchPendingFollowUp directly (normally called after compaction completes)\n    await internals.dispatchPendingFollowUp();\n\n    // Verify the follow-up was dispatched with correct agentId derived from legacy mode\n    expect(dispatchedMessage).toBe(\"follow up\");\n    expect(dispatchedOptions?.agentId).toBe(\"plan\");\n\n    session.dispose();\n  });\n});\n"]}