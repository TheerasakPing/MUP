{"version":3,"file":"agentSession.continueMessageAgentId.test.js","sourceRoot":"","sources":["../../../src/node/services/agentSession.continueMessageAgentId.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, expect, test, mock, afterEach } from \"bun:test\";\r\nimport { buildContinueMessage } from \"@/common/types/message\";\r\nimport type { FilePart, SendMessageOptions } from \"@/common/orpc/types\";\r\nimport { AgentSession } from \"./agentSession\";\r\nimport type { Config } from \"@/node/config\";\r\nimport type { AIService } from \"./aiService\";\r\nimport type { BackgroundProcessManager } from \"./backgroundProcessManager\";\r\nimport type { InitStateManager } from \"./initStateManager\";\r\nimport type { PartialService } from \"./partialService\";\r\nimport type { MuxMessage } from \"@/common/types/message\";\r\nimport { createTestHistoryService } from \"./testHistoryService\";\r\nimport type { CostTrackingService } from \"./costTrackingService\";\r\n\r\n// NOTE: This test validates that legacy `mode` field in follow-up content is correctly\r\n// converted to `agentId` during dispatch. With the crash-safe follow-up architecture,\r\n// the follow-up is stored on the compaction summary message and dispatched from there.\r\n\r\ntype SendOptions = SendMessageOptions & { fileParts?: FilePart[] };\r\n\r\ninterface SessionInternals {\r\n  dispatchPendingFollowUp: () => Promise<void>;\r\n  sendMessage: (message: string, options?: SendOptions) => Promise<{ success: boolean }>;\r\n}\r\n\r\ndescribe(\"AgentSession continue-message agentId fallback\", () => {\r\n  let historyCleanup: (() => Promise<void>) | undefined;\r\n  afterEach(async () => {\r\n    await historyCleanup?.();\r\n  });\r\n\r\n  test(\"legacy continueMessage.mode does not fall back to compact agent\", async () => {\r\n    // Track the follow-up message that gets dispatched\r\n    let dispatchedMessage: string | undefined;\r\n    let dispatchedOptions: SendOptions | undefined;\r\n\r\n    const aiService: AIService = {\r\n      on() {\r\n        return this;\r\n      },\r\n      off() {\r\n        return this;\r\n      },\r\n      isStreaming: () => false,\r\n      stopStream: mock(() => Promise.resolve({ success: true as const, data: undefined })),\r\n    } as unknown as AIService;\r\n\r\n    // Create a mock compaction summary with legacy mode field\r\n    const baseContinueMessage = buildContinueMessage({\r\n      text: \"follow up\",\r\n      model: \"openai:gpt-4o\",\r\n      agentId: \"exec\",\r\n    });\r\n    if (!baseContinueMessage) {\r\n      throw new Error(\"Expected base continue message to be built\");\r\n    }\r\n\r\n    // Simulate legacy format: no agentId, but has mode instead\r\n    const legacyFollowUp = {\r\n      text: baseContinueMessage.text,\r\n      model: \"openai:gpt-4o\",\r\n      agentId: undefined as unknown as string, // Legacy: missing agentId\r\n      mode: \"plan\" as const, // Legacy: mode field instead of agentId\r\n    };\r\n\r\n    // Mock history service to return a compaction summary with pending follow-up\r\n    const mockSummaryMessage = {\r\n      id: \"summary-1\",\r\n      role: \"assistant\" as const,\r\n      parts: [{ type: \"text\" as const, text: \"Compaction summary\" }],\r\n      metadata: {\r\n        muxMetadata: {\r\n          type: \"compaction-summary\" as const,\r\n          pendingFollowUp: legacyFollowUp,\r\n        },\r\n      },\r\n    } satisfies MuxMessage;\r\n\r\n    const { historyService, cleanup } = await createTestHistoryService();\r\n    historyCleanup = cleanup;\r\n    await historyService.appendToHistory(\"ws\", mockSummaryMessage);\r\n\r\n    const initStateManager: InitStateManager = {\r\n      on() {\r\n        return this;\r\n      },\r\n      off() {\r\n        return this;\r\n      },\r\n    } as unknown as InitStateManager;\r\n\r\n    const backgroundProcessManager: BackgroundProcessManager = {\r\n      cleanup: mock(() => Promise.resolve()),\r\n      setMessageQueued: mock(() => undefined),\r\n    } as unknown as BackgroundProcessManager;\r\n\r\n    const config: Config = {\r\n      srcDir: \"/tmp\",\r\n      getSessionDir: mock(() => \"/tmp\"),\r\n    } as unknown as Config;\r\n    const partialService: PartialService = {} as unknown as PartialService;\r\n\r\n    const session = new AgentSession({\r\n      workspaceId: \"ws\",\r\n      config,\r\n      historyService,\r\n      partialService,\r\n      aiService,\r\n      initStateManager,\r\n      costTrackingService: {} as unknown as CostTrackingService,\r\n      backgroundProcessManager,\r\n    });\r\n\r\n    const internals = session as unknown as SessionInternals;\r\n\r\n    // Intercept sendMessage to capture what dispatchPendingFollowUp sends\r\n    internals.sendMessage = mock((message: string, options?: SendOptions) => {\r\n      dispatchedMessage = message;\r\n      dispatchedOptions = options;\r\n      return Promise.resolve({ success: true });\r\n    });\r\n\r\n    // Call dispatchPendingFollowUp directly (normally called after compaction completes)\r\n    await internals.dispatchPendingFollowUp();\r\n\r\n    // Verify the follow-up was dispatched with correct agentId derived from legacy mode\r\n    expect(dispatchedMessage).toBe(\"follow up\");\r\n    expect(dispatchedOptions?.agentId).toBe(\"plan\");\r\n\r\n    session.dispose();\r\n  });\r\n});\r\n"]}