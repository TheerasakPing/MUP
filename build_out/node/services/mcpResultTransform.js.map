{"version":3,"file":"mcpResultTransform.js","sourceRoot":"","sources":["../../../src/node/services/mcpResultTransform.ts"],"names":[],"mappings":"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","sourcesContent":["import { log } from \"@/node/services/log\";\n\n/**\n * Maximum size of base64 image data in bytes before we drop it.\n *\n * Rationale: providers already accept multi‑megabyte images, but a single\n * 20–30MB screenshot can still blow up request sizes or hit provider limits\n * (e.g., Anthropic ~32MB total request). We keep a generous per‑image guard to\n * pass normal screenshots while preventing pathological payloads.\n */\nexport const MAX_IMAGE_DATA_BYTES = 8 * 1024 * 1024; // 8MB guard per image\n\n/**\n * MCP CallToolResult content types (from @ai-sdk/mcp)\n */\ninterface MCPTextContent {\n  type: \"text\";\n  text: string;\n}\n\ninterface MCPImageContent {\n  type: \"image\";\n  data: string; // base64\n  mimeType: string;\n}\n\ninterface MCPResourceContent {\n  type: \"resource\";\n  resource: { uri: string; text?: string; blob?: string; mimeType?: string };\n}\n\ntype MCPContent = MCPTextContent | MCPImageContent | MCPResourceContent;\n\nexport interface MCPCallToolResult {\n  content?: MCPContent[];\n  isError?: boolean;\n  toolResult?: unknown;\n}\n\n/**\n * AI SDK LanguageModelV2ToolResultOutput content types\n */\ntype AISDKContentPart =\n  | { type: \"text\"; text: string }\n  | { type: \"media\"; data: string; mediaType: string };\n\n/**\n * Format byte size as human-readable string (KB or MB)\n */\nfunction formatBytes(bytes: number): string {\n  if (bytes >= 1_000_000) {\n    return `${(bytes / 1_000_000).toFixed(1)} MB`;\n  }\n  return `${Math.round(bytes / 1000)} KB`;\n}\n\n/**\n * Transform MCP tool result to AI SDK format.\n * Converts MCP's \"image\" content type to AI SDK's \"media\" type.\n * Truncates large images to prevent context overflow.\n */\nexport function transformMCPResult(result: MCPCallToolResult): unknown {\n  // If it's an error or has toolResult, pass through as-is\n  if (result.isError || result.toolResult !== undefined) {\n    return result;\n  }\n\n  // If no content array, pass through\n  if (!result.content || !Array.isArray(result.content)) {\n    return result;\n  }\n\n  // Check if any content is an image\n  const hasImage = result.content.some((c) => c.type === \"image\");\n  if (!hasImage) {\n    return result;\n  }\n\n  // Debug: log what we received from MCP\n  log.debug(\"[MCP] transformMCPResult input\", {\n    contentTypes: result.content.map((c) => c.type),\n    imageItems: result.content\n      .filter((c): c is MCPImageContent => c.type === \"image\")\n      .map((c) => ({ type: c.type, mimeType: c.mimeType, dataLen: c.data?.length })),\n  });\n\n  // Transform to AI SDK content format\n  const transformedContent: AISDKContentPart[] = result.content.map((item) => {\n    if (item.type === \"text\") {\n      return { type: \"text\" as const, text: item.text };\n    }\n    if (item.type === \"image\") {\n      const imageItem = item;\n      // Check if image data exceeds the limit\n      const dataLength = imageItem.data?.length ?? 0;\n      if (dataLength > MAX_IMAGE_DATA_BYTES) {\n        log.warn(\"[MCP] Image data too large, omitting from context\", {\n          mimeType: imageItem.mimeType,\n          dataLength,\n          maxAllowed: MAX_IMAGE_DATA_BYTES,\n        });\n        return {\n          type: \"text\" as const,\n          text: `[Image omitted: ${formatBytes(dataLength)} exceeds per-image guard of ${formatBytes(MAX_IMAGE_DATA_BYTES)}. Reduce resolution or quality and retry.]`,\n        };\n      }\n      // Ensure mediaType is present - default to image/png if missing\n      const mediaType = imageItem.mimeType || \"image/png\";\n      log.debug(\"[MCP] Transforming image content\", { mimeType: imageItem.mimeType, mediaType });\n      return { type: \"media\" as const, data: imageItem.data, mediaType };\n    }\n    // For resource type, convert to text representation\n    if (item.type === \"resource\") {\n      const text = item.resource.text ?? item.resource.uri;\n      return { type: \"text\" as const, text };\n    }\n    // Fallback: stringify unknown content\n    return { type: \"text\" as const, text: JSON.stringify(item) };\n  });\n\n  return { type: \"content\", value: transformedContent };\n}\n"]}