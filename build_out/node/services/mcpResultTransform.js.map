{"version":3,"file":"mcpResultTransform.js","sourceRoot":"","sources":["../../../src/node/services/mcpResultTransform.ts"],"names":[],"mappings":"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","sourcesContent":["import { log } from \"@/node/services/log\";\r\n\r\n/**\r\n * Maximum size of base64 image data in bytes before we drop it.\r\n *\r\n * Rationale: providers already accept multi‑megabyte images, but a single\r\n * 20–30MB screenshot can still blow up request sizes or hit provider limits\r\n * (e.g., Anthropic ~32MB total request). We keep a generous per‑image guard to\r\n * pass normal screenshots while preventing pathological payloads.\r\n */\r\nexport const MAX_IMAGE_DATA_BYTES = 8 * 1024 * 1024; // 8MB guard per image\r\n\r\n/**\r\n * MCP CallToolResult content types (from @ai-sdk/mcp)\r\n */\r\ninterface MCPTextContent {\r\n  type: \"text\";\r\n  text: string;\r\n}\r\n\r\ninterface MCPImageContent {\r\n  type: \"image\";\r\n  data: string; // base64\r\n  mimeType: string;\r\n}\r\n\r\ninterface MCPResourceContent {\r\n  type: \"resource\";\r\n  resource: { uri: string; text?: string; blob?: string; mimeType?: string };\r\n}\r\n\r\ntype MCPContent = MCPTextContent | MCPImageContent | MCPResourceContent;\r\n\r\nexport interface MCPCallToolResult {\r\n  content?: MCPContent[];\r\n  isError?: boolean;\r\n  toolResult?: unknown;\r\n}\r\n\r\n/**\r\n * AI SDK LanguageModelV2ToolResultOutput content types\r\n */\r\ntype AISDKContentPart =\r\n  | { type: \"text\"; text: string }\r\n  | { type: \"media\"; data: string; mediaType: string };\r\n\r\n/**\r\n * Format byte size as human-readable string (KB or MB)\r\n */\r\nfunction formatBytes(bytes: number): string {\r\n  if (bytes >= 1_000_000) {\r\n    return `${(bytes / 1_000_000).toFixed(1)} MB`;\r\n  }\r\n  return `${Math.round(bytes / 1000)} KB`;\r\n}\r\n\r\n/**\r\n * Transform MCP tool result to AI SDK format.\r\n * Converts MCP's \"image\" content type to AI SDK's \"media\" type.\r\n * Truncates large images to prevent context overflow.\r\n */\r\nexport function transformMCPResult(result: MCPCallToolResult): unknown {\r\n  // If it's an error or has toolResult, pass through as-is\r\n  if (result.isError || result.toolResult !== undefined) {\r\n    return result;\r\n  }\r\n\r\n  // If no content array, pass through\r\n  if (!result.content || !Array.isArray(result.content)) {\r\n    return result;\r\n  }\r\n\r\n  // Check if any content is an image\r\n  const hasImage = result.content.some((c) => c.type === \"image\");\r\n  if (!hasImage) {\r\n    return result;\r\n  }\r\n\r\n  // Debug: log what we received from MCP\r\n  log.debug(\"[MCP] transformMCPResult input\", {\r\n    contentTypes: result.content.map((c) => c.type),\r\n    imageItems: result.content\r\n      .filter((c): c is MCPImageContent => c.type === \"image\")\r\n      .map((c) => ({ type: c.type, mimeType: c.mimeType, dataLen: c.data?.length })),\r\n  });\r\n\r\n  // Transform to AI SDK content format\r\n  const transformedContent: AISDKContentPart[] = result.content.map((item) => {\r\n    if (item.type === \"text\") {\r\n      return { type: \"text\" as const, text: item.text };\r\n    }\r\n    if (item.type === \"image\") {\r\n      const imageItem = item;\r\n      // Check if image data exceeds the limit\r\n      const dataLength = imageItem.data?.length ?? 0;\r\n      if (dataLength > MAX_IMAGE_DATA_BYTES) {\r\n        log.warn(\"[MCP] Image data too large, omitting from context\", {\r\n          mimeType: imageItem.mimeType,\r\n          dataLength,\r\n          maxAllowed: MAX_IMAGE_DATA_BYTES,\r\n        });\r\n        return {\r\n          type: \"text\" as const,\r\n          text: `[Image omitted: ${formatBytes(dataLength)} exceeds per-image guard of ${formatBytes(MAX_IMAGE_DATA_BYTES)}. Reduce resolution or quality and retry.]`,\r\n        };\r\n      }\r\n      // Ensure mediaType is present - default to image/png if missing\r\n      const mediaType = imageItem.mimeType || \"image/png\";\r\n      log.debug(\"[MCP] Transforming image content\", { mimeType: imageItem.mimeType, mediaType });\r\n      return { type: \"media\" as const, data: imageItem.data, mediaType };\r\n    }\r\n    // For resource type, convert to text representation\r\n    if (item.type === \"resource\") {\r\n      const text = item.resource.text ?? item.resource.uri;\r\n      return { type: \"text\" as const, text };\r\n    }\r\n    // Fallback: stringify unknown content\r\n    return { type: \"text\" as const, text: JSON.stringify(item) };\r\n  });\r\n\r\n  return { type: \"content\", value: transformedContent };\r\n}\r\n"]}