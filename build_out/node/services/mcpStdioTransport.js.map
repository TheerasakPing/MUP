{"version":3,"file":"mcpStdioTransport.js","sourceRoot":"","sources":["../../../src/node/services/mcpStdioTransport.ts"],"names":[],"mappings":"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","sourcesContent":["import { TextDecoder, TextEncoder } from \"util\";\nimport type { MCPTransport, JSONRPCMessage } from \"@ai-sdk/mcp\";\nimport type { ExecStream } from \"@/node/runtime/Runtime\";\nimport { log } from \"@/node/services/log\";\n\n/**\n * Minimal stdio transport for MCP servers using newline-delimited JSON (NDJSON).\n * Each message is a single line of JSON followed by \\n.\n * This matches the protocol used by @ai-sdk/mcp's StdioMCPTransport.\n */\nexport class MCPStdioTransport implements MCPTransport {\n  private readonly decoder = new TextDecoder();\n  private readonly encoder = new TextEncoder();\n  private readonly stdoutReader: ReadableStreamDefaultReader<Uint8Array>;\n  private readonly stdinWriter: WritableStreamDefaultWriter<Uint8Array>;\n  private buffer = \"\";\n  private running = false;\n  private readonly exitPromise: Promise<number>;\n\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor(execStream: ExecStream) {\n    this.stdoutReader = execStream.stdout.getReader();\n    this.stdinWriter = execStream.stdin.getWriter();\n    this.exitPromise = execStream.exitCode;\n    // Observe process exit to trigger close event\n    void this.exitPromise.then(() => {\n      if (this.onclose) this.onclose();\n    });\n  }\n\n  start(): Promise<void> {\n    if (this.running) return Promise.resolve();\n    this.running = true;\n    void this.readLoop();\n    return Promise.resolve();\n  }\n\n  async send(message: JSONRPCMessage): Promise<void> {\n    // NDJSON: serialize as JSON followed by newline\n    const line = JSON.stringify(message) + \"\\n\";\n    const bytes = this.encoder.encode(line);\n    await this.stdinWriter.write(bytes);\n  }\n\n  async close(): Promise<void> {\n    try {\n      await this.stdinWriter.close();\n    } catch (error) {\n      log.debug(\"Failed to close MCP stdin writer\", { error });\n    }\n    try {\n      await this.stdoutReader.cancel();\n    } catch (error) {\n      log.debug(\"Failed to cancel MCP stdout reader\", { error });\n    }\n  }\n\n  private async readLoop(): Promise<void> {\n    try {\n      while (true) {\n        const { value, done } = await this.stdoutReader.read();\n        if (done) break;\n        if (value) {\n          this.buffer += this.decoder.decode(value, { stream: true });\n          this.processBuffer();\n        }\n      }\n    } catch (error) {\n      if (this.onerror) {\n        this.onerror(error as Error);\n      } else {\n        log.error(\"MCP stdio transport read error\", { error });\n      }\n    } finally {\n      if (this.onclose) this.onclose();\n    }\n  }\n\n  private processBuffer(): void {\n    // Process complete lines (NDJSON format)\n    let newlineIndex: number;\n    while ((newlineIndex = this.buffer.indexOf(\"\\n\")) !== -1) {\n      const line = this.buffer.slice(0, newlineIndex);\n      this.buffer = this.buffer.slice(newlineIndex + 1);\n\n      if (line.trim().length === 0) continue; // Skip empty lines\n\n      try {\n        const message = JSON.parse(line) as JSONRPCMessage;\n        if (this.onmessage) {\n          this.onmessage(message);\n        }\n      } catch (error) {\n        if (this.onerror) {\n          this.onerror(error as Error);\n        } else {\n          log.error(\"Failed to parse MCP message\", { error, line });\n        }\n      }\n    }\n  }\n}\n"]}