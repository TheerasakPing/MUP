{"version":3,"file":"mcpStdioTransport.js","sourceRoot":"","sources":["../../../src/node/services/mcpStdioTransport.ts"],"names":[],"mappings":"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","sourcesContent":["import { TextDecoder, TextEncoder } from \"util\";\r\nimport type { MCPTransport, JSONRPCMessage } from \"@ai-sdk/mcp\";\r\nimport type { ExecStream } from \"@/node/runtime/Runtime\";\r\nimport { log } from \"@/node/services/log\";\r\n\r\n/**\r\n * Minimal stdio transport for MCP servers using newline-delimited JSON (NDJSON).\r\n * Each message is a single line of JSON followed by \\n.\r\n * This matches the protocol used by @ai-sdk/mcp's StdioMCPTransport.\r\n */\r\nexport class MCPStdioTransport implements MCPTransport {\r\n  private readonly decoder = new TextDecoder();\r\n  private readonly encoder = new TextEncoder();\r\n  private readonly stdoutReader: ReadableStreamDefaultReader<Uint8Array>;\r\n  private readonly stdinWriter: WritableStreamDefaultWriter<Uint8Array>;\r\n  private buffer = \"\";\r\n  private running = false;\r\n  private readonly exitPromise: Promise<number>;\r\n\r\n  onclose?: () => void;\r\n  onerror?: (error: Error) => void;\r\n  onmessage?: (message: JSONRPCMessage) => void;\r\n\r\n  constructor(execStream: ExecStream) {\r\n    this.stdoutReader = execStream.stdout.getReader();\r\n    this.stdinWriter = execStream.stdin.getWriter();\r\n    this.exitPromise = execStream.exitCode;\r\n    // Observe process exit to trigger close event\r\n    void this.exitPromise.then(() => {\r\n      if (this.onclose) this.onclose();\r\n    });\r\n  }\r\n\r\n  start(): Promise<void> {\r\n    if (this.running) return Promise.resolve();\r\n    this.running = true;\r\n    void this.readLoop();\r\n    return Promise.resolve();\r\n  }\r\n\r\n  async send(message: JSONRPCMessage): Promise<void> {\r\n    // NDJSON: serialize as JSON followed by newline\r\n    const line = JSON.stringify(message) + \"\\n\";\r\n    const bytes = this.encoder.encode(line);\r\n    await this.stdinWriter.write(bytes);\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    try {\r\n      await this.stdinWriter.close();\r\n    } catch (error) {\r\n      log.debug(\"Failed to close MCP stdin writer\", { error });\r\n    }\r\n    try {\r\n      await this.stdoutReader.cancel();\r\n    } catch (error) {\r\n      log.debug(\"Failed to cancel MCP stdout reader\", { error });\r\n    }\r\n  }\r\n\r\n  private async readLoop(): Promise<void> {\r\n    try {\r\n      while (true) {\r\n        const { value, done } = await this.stdoutReader.read();\r\n        if (done) break;\r\n        if (value) {\r\n          this.buffer += this.decoder.decode(value, { stream: true });\r\n          this.processBuffer();\r\n        }\r\n      }\r\n    } catch (error) {\r\n      if (this.onerror) {\r\n        this.onerror(error as Error);\r\n      } else {\r\n        log.error(\"MCP stdio transport read error\", { error });\r\n      }\r\n    } finally {\r\n      if (this.onclose) this.onclose();\r\n    }\r\n  }\r\n\r\n  private processBuffer(): void {\r\n    // Process complete lines (NDJSON format)\r\n    let newlineIndex: number;\r\n    while ((newlineIndex = this.buffer.indexOf(\"\\n\")) !== -1) {\r\n      const line = this.buffer.slice(0, newlineIndex);\r\n      this.buffer = this.buffer.slice(newlineIndex + 1);\r\n\r\n      if (line.trim().length === 0) continue; // Skip empty lines\r\n\r\n      try {\r\n        const message = JSON.parse(line) as JSONRPCMessage;\r\n        if (this.onmessage) {\r\n          this.onmessage(message);\r\n        }\r\n      } catch (error) {\r\n        if (this.onerror) {\r\n          this.onerror(error as Error);\r\n        } else {\r\n          log.error(\"Failed to parse MCP message\", { error, line });\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}