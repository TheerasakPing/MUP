{"version":3,"file":"aiService.js","sourceRoot":"","sources":["../../../src/node/services/aiService.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs/promises\";\nimport { EventEmitter } from \"events\";\n\nimport { type LanguageModel, type Tool } from \"ai\";\n\nimport { linkAbortSignal } from \"@/node/utils/abort\";\nimport type { Result } from \"@/common/types/result\";\nimport { Ok, Err } from \"@/common/types/result\";\nimport type { WorkspaceMetadata } from \"@/common/types/workspace\";\nimport type { SendMessageOptions } from \"@/common/orpc/types\";\n\nimport type { DebugLlmRequestSnapshot } from \"@/common/types/debugLlmRequest\";\n\nimport type { MuxMessage } from \"@/common/types/message\";\nimport { createMuxMessage } from \"@/common/types/message\";\nimport type { Config } from \"@/node/config\";\nimport { StreamManager } from \"./streamManager\";\nimport type { InitStateManager } from \"./initStateManager\";\nimport type { SendMessageError } from \"@/common/types/errors\";\nimport { getToolsForModel } from \"@/common/utils/tools/tools\";\nimport { createRuntime } from \"@/node/runtime/runtimeFactory\";\nimport { getMuxEnv, getRuntimeType } from \"@/node/runtime/initHook\";\nimport { MUX_HELP_CHAT_WORKSPACE_ID } from \"@/common/constants/muxChat\";\nimport { secretsToRecord } from \"@/common/types/secrets\";\nimport type { MuxProviderOptions } from \"@/common/types/providerOptions\";\nimport type { PolicyService } from \"@/node/services/policyService\";\nimport type { ProviderService } from \"@/node/services/providerService\";\nimport type { CodexOauthService } from \"@/node/services/codexOauthService\";\nimport type { BackgroundProcessManager } from \"@/node/services/backgroundProcessManager\";\nimport type { FileState, EditedFileAttachment } from \"@/node/services/agentSession\";\nimport { log } from \"./log\";\nimport {\n  addInterruptedSentinel,\n  filterEmptyAssistantMessages,\n} from \"@/browser/utils/messages/modelMessageTransform\";\nimport type { PostCompactionAttachment } from \"@/common/types/attachment\";\n\nimport type { HistoryService } from \"./historyService\";\nimport type { PartialService } from \"./partialService\";\nimport { createErrorEvent } from \"./utils/sendMessageError\";\nimport { createAssistantMessageId } from \"./utils/messageIds\";\nimport type { SessionUsageService } from \"./sessionUsageService\";\nimport { sumUsageHistory, getTotalCost } from \"@/common/utils/tokens/usageAggregator\";\nimport { readToolInstructions } from \"./systemMessage\";\nimport type { TelemetryService } from \"@/node/services/telemetryService\";\n\nimport type { WorkspaceMCPOverrides } from \"@/common/types/mcp\";\nimport type { MCPServerManager, MCPWorkspaceStats } from \"@/node/services/mcpServerManager\";\nimport { WorkspaceMcpOverridesService } from \"./workspaceMcpOverridesService\";\nimport type { TaskService } from \"@/node/services/taskService\";\nimport { buildProviderOptions } from \"@/common/utils/ai/providerOptions\";\nimport { sliceMessagesFromLatestCompactionBoundary } from \"@/common/utils/messages/compactionBoundary\";\n\nimport { THINKING_LEVEL_OFF, type ThinkingLevel } from \"@/common/types/thinking\";\n\nimport type { StreamAbortEvent, StreamAbortReason, StreamEndEvent } from \"@/common/types/stream\";\nimport type { ToolPolicy } from \"@/common/utils/tools/toolPolicy\";\nimport type { PTCEventWithParent } from \"@/node/services/tools/code_execution\";\nimport { MockAiStreamPlayer } from \"./mock/mockAiStreamPlayer\";\nimport { ProviderModelFactory, modelCostsIncluded } from \"./providerModelFactory\";\nimport { wrapToolsWithSystem1 } from \"./system1ToolWrapper\";\nimport { prepareMessagesForProvider } from \"./messagePipeline\";\nimport { resolveAgentForStream } from \"./agentResolution\";\nimport { buildPlanInstructions, buildStreamSystemContext } from \"./streamContextBuilder\";\nimport {\n  simulateContextLimitError,\n  simulateToolPolicyNoop,\n  type SimulationContext,\n} from \"./streamSimulation\";\nimport { applyToolPolicyAndExperiments, captureMcpToolTelemetry } from \"./toolAssembly\";\n\n// ---------------------------------------------------------------------------\n// streamMessage options\n// ---------------------------------------------------------------------------\n\n/** Options bag for {@link AIService.streamMessage}. */\nexport interface StreamMessageOptions {\n  messages: MuxMessage[];\n  workspaceId: string;\n  modelString: string;\n  thinkingLevel?: ThinkingLevel;\n  toolPolicy?: ToolPolicy;\n  abortSignal?: AbortSignal;\n  additionalSystemInstructions?: string;\n  maxOutputTokens?: number;\n  muxProviderOptions?: MuxProviderOptions;\n  agentId?: string;\n  recordFileState?: (filePath: string, state: FileState) => void;\n  changedFileAttachments?: EditedFileAttachment[];\n  postCompactionAttachments?: PostCompactionAttachment[] | null;\n  experiments?: SendMessageOptions[\"experiments\"];\n  system1Model?: string;\n  system1ThinkingLevel?: ThinkingLevel;\n  disableWorkspaceAgents?: boolean;\n  hasQueuedMessage?: () => boolean;\n  openaiTruncationModeOverride?: \"auto\" | \"disabled\";\n}\n\n// ---------------------------------------------------------------------------\n// Utility: deep-clone with structuredClone fallback\n// ---------------------------------------------------------------------------\n\n/** Deep-clone a value using structuredClone (with JSON fallback). */\nfunction safeClone<T>(value: T): T {\n  return typeof structuredClone === \"function\"\n    ? structuredClone(value)\n    : (JSON.parse(JSON.stringify(value)) as T);\n}\n\nexport class AIService extends EventEmitter {\n  private readonly streamManager: StreamManager;\n  private readonly historyService: HistoryService;\n  private readonly partialService: PartialService;\n  private readonly config: Config;\n  private readonly workspaceMcpOverridesService: WorkspaceMcpOverridesService;\n  private mcpServerManager?: MCPServerManager;\n  private readonly policyService?: PolicyService;\n  private readonly telemetryService?: TelemetryService;\n  private readonly initStateManager: InitStateManager;\n  private mockModeEnabled: boolean;\n  private mockAiStreamPlayer?: MockAiStreamPlayer;\n  private readonly backgroundProcessManager?: BackgroundProcessManager;\n  private readonly sessionUsageService?: SessionUsageService;\n  private readonly providerModelFactory: ProviderModelFactory;\n\n  // Tracks in-flight stream startup (before StreamManager emits stream-start).\n  // This enables user interrupts (Esc/Ctrl+C) during the UI \"starting...\" phase.\n  private readonly pendingStreamStarts = new Map<\n    string,\n    { abortController: AbortController; startTime: number; syntheticMessageId: string }\n  >();\n\n  // Debug: captured LLM request payloads for last send per workspace\n  private lastLlmRequestByWorkspace = new Map<string, DebugLlmRequestSnapshot>();\n  private taskService?: TaskService;\n  private extraTools?: Record<string, Tool>;\n\n  constructor(\n    config: Config,\n    historyService: HistoryService,\n    partialService: PartialService,\n    initStateManager: InitStateManager,\n    providerService: ProviderService,\n    backgroundProcessManager?: BackgroundProcessManager,\n    sessionUsageService?: SessionUsageService,\n    workspaceMcpOverridesService?: WorkspaceMcpOverridesService,\n    policyService?: PolicyService,\n    telemetryService?: TelemetryService\n  ) {\n    super();\n    // Increase max listeners to accommodate multiple concurrent workspace listeners\n    // Each workspace subscribes to stream events, and we expect >10 concurrent workspaces\n    this.setMaxListeners(50);\n    this.workspaceMcpOverridesService =\n      workspaceMcpOverridesService ?? new WorkspaceMcpOverridesService(config);\n    this.config = config;\n    this.historyService = historyService;\n    this.partialService = partialService;\n    this.initStateManager = initStateManager;\n    this.backgroundProcessManager = backgroundProcessManager;\n    this.sessionUsageService = sessionUsageService;\n    this.policyService = policyService;\n    this.telemetryService = telemetryService;\n    this.streamManager = new StreamManager(historyService, partialService, sessionUsageService);\n    this.providerModelFactory = new ProviderModelFactory(config, providerService, policyService);\n    void this.ensureSessionsDir();\n    this.setupStreamEventForwarding();\n    this.mockModeEnabled = false;\n\n    if (process.env.MUX_MOCK_AI === \"1\") {\n      log.info(\"AIService running in MUX_MOCK_AI mode\");\n      this.enableMockMode();\n    }\n  }\n\n  setCodexOauthService(service: CodexOauthService): void {\n    this.providerModelFactory.codexOauthService = service;\n  }\n  setMCPServerManager(manager: MCPServerManager): void {\n    this.mcpServerManager = manager;\n    this.streamManager.setMCPServerManager(manager);\n  }\n\n  setTaskService(taskService: TaskService): void {\n    this.taskService = taskService;\n  }\n\n  /**\n   * Set extra tools to include in every tool call.\n   * Used by CLI to inject tools like set_exit_code without modifying core tool definitions.\n   */\n  setExtraTools(tools: Record<string, Tool>): void {\n    this.extraTools = tools;\n  }\n\n  /**\n   * Forward all stream events from StreamManager to AIService consumers\n   */\n  private setupStreamEventForwarding(): void {\n    // Simple one-to-one event forwarding from StreamManager â†’ AIService consumers\n    for (const event of [\n      \"stream-start\",\n      \"stream-delta\",\n      \"error\",\n      \"tool-call-start\",\n      \"tool-call-delta\",\n      \"tool-call-end\",\n      \"reasoning-delta\",\n      \"reasoning-end\",\n      \"usage-delta\",\n    ] as const) {\n      this.streamManager.on(event, (data) => this.emit(event, data));\n    }\n\n    // stream-end needs extra logic: capture provider response for debug modal\n    this.streamManager.on(\"stream-end\", (data: StreamEndEvent) => {\n      // Best-effort capture of the provider response for the \"Last LLM request\" debug modal.\n      // Must never break live streaming.\n      try {\n        const snapshot = this.lastLlmRequestByWorkspace.get(data.workspaceId);\n        if (snapshot) {\n          // If messageId is missing (legacy fixtures), attach anyway.\n          const shouldAttach = snapshot.messageId === data.messageId || snapshot.messageId == null;\n          if (shouldAttach) {\n            const updated: DebugLlmRequestSnapshot = {\n              ...snapshot,\n              response: {\n                capturedAt: Date.now(),\n                metadata: data.metadata,\n                parts: data.parts,\n              },\n            };\n\n            this.lastLlmRequestByWorkspace.set(data.workspaceId, safeClone(updated));\n          }\n        }\n      } catch (error) {\n        const errMsg = error instanceof Error ? error.message : String(error);\n        log.warn(\"Failed to capture debug LLM response snapshot\", { error: errMsg });\n      }\n\n      this.emit(\"stream-end\", data);\n    });\n\n    // Handle stream-abort: dispose of partial based on abandonPartial flag\n    this.streamManager.on(\"stream-abort\", (data: StreamAbortEvent) => {\n      void (async () => {\n        if (data.abandonPartial) {\n          // Caller requested discarding partial - delete without committing\n          await this.partialService.deletePartial(data.workspaceId);\n        } else {\n          // Commit interrupted message to history with partial:true metadata\n          // This ensures /clear and /truncate can clean up interrupted messages\n          const partial = await this.partialService.readPartial(data.workspaceId);\n          if (partial) {\n            await this.partialService.commitToHistory(data.workspaceId);\n            await this.partialService.deletePartial(data.workspaceId);\n          }\n        }\n\n        // Forward abort event to consumers\n        this.emit(\"stream-abort\", data);\n      })();\n    });\n  }\n\n  private async ensureSessionsDir(): Promise<void> {\n    try {\n      await fs.mkdir(this.config.sessionsDir, { recursive: true });\n    } catch (error) {\n      log.error(\"Failed to create sessions directory:\", error);\n    }\n  }\n\n  isMockModeEnabled(): boolean {\n    return this.mockModeEnabled;\n  }\n\n  releaseMockStreamStartGate(workspaceId: string): void {\n    this.mockAiStreamPlayer?.releaseStreamStartGate(workspaceId);\n  }\n\n  enableMockMode(): void {\n    this.mockModeEnabled = true;\n\n    this.mockAiStreamPlayer ??= new MockAiStreamPlayer({\n      aiService: this,\n      historyService: this.historyService,\n    });\n  }\n\n  async getWorkspaceMetadata(workspaceId: string): Promise<Result<WorkspaceMetadata>> {\n    try {\n      // Read from config.json (single source of truth)\n      // getAllWorkspaceMetadata() handles migration from legacy metadata.json files\n      const allMetadata = await this.config.getAllWorkspaceMetadata();\n      const metadata = allMetadata.find((m) => m.id === workspaceId);\n\n      if (!metadata) {\n        return Err(\n          `Workspace metadata not found for ${workspaceId}. Workspace may not be properly initialized.`\n        );\n      }\n\n      return Ok(metadata);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return Err(`Failed to read workspace metadata: ${message}`);\n    }\n  }\n\n  /**\n   * Create an AI SDK model from a model string (e.g., \"anthropic:claude-opus-4-1\").\n   * Delegates to ProviderModelFactory.\n   */\n  async createModel(\n    modelString: string,\n    muxProviderOptions?: MuxProviderOptions\n  ): Promise<Result<LanguageModel, SendMessageError>> {\n    return this.providerModelFactory.createModel(modelString, muxProviderOptions);\n  }\n\n  /** Stream a message conversation to the AI model. */\n  async streamMessage(opts: StreamMessageOptions): Promise<Result<void, SendMessageError>> {\n    const {\n      messages,\n      workspaceId,\n      modelString,\n      thinkingLevel,\n      toolPolicy,\n      abortSignal,\n      additionalSystemInstructions,\n      maxOutputTokens,\n      muxProviderOptions,\n      agentId,\n      recordFileState,\n      changedFileAttachments,\n      postCompactionAttachments,\n      experiments,\n      system1Model,\n      system1ThinkingLevel,\n      disableWorkspaceAgents,\n      hasQueuedMessage,\n      openaiTruncationModeOverride,\n    } = opts;\n    // Support interrupts during startup (before StreamManager emits stream-start).\n    // We register an AbortController up-front and let stopStream() abort it.\n    const pendingAbortController = new AbortController();\n    const startTime = Date.now();\n    const syntheticMessageId = `starting-${startTime}-${Math.random().toString(36).substring(2, 11)}`;\n\n    // Link external abort signal (if provided).\n    const unlinkAbortSignal = linkAbortSignal(abortSignal, pendingAbortController);\n\n    this.pendingStreamStarts.set(workspaceId, {\n      abortController: pendingAbortController,\n      startTime,\n      syntheticMessageId,\n    });\n\n    const combinedAbortSignal = pendingAbortController.signal;\n\n    try {\n      if (this.mockModeEnabled && this.mockAiStreamPlayer) {\n        await this.initStateManager.waitForInit(workspaceId, combinedAbortSignal);\n        if (combinedAbortSignal.aborted) {\n          return Ok(undefined);\n        }\n        return await this.mockAiStreamPlayer.play(messages, workspaceId, {\n          model: modelString,\n          abortSignal: combinedAbortSignal,\n        });\n      }\n\n      // DEBUG: Log streamMessage call\n      const lastMessage = messages[messages.length - 1];\n      log.debug(\n        `[STREAM MESSAGE] workspaceId=${workspaceId} messageCount=${messages.length} lastRole=${lastMessage?.role}`\n      );\n\n      // Before starting a new stream, commit any existing partial to history\n      // This is idempotent - won't double-commit if already in chat.jsonl\n      await this.partialService.commitToHistory(workspaceId);\n\n      // Helper: clean up an assistant placeholder that was appended to history but never\n      // streamed (due to abort during setup). Used in two abort-check sites below.\n      const deleteAbortedPlaceholder = async (messageId: string): Promise<void> => {\n        const deleteResult = await this.historyService.deleteMessage(workspaceId, messageId);\n        if (!deleteResult.success) {\n          log.error(\n            `Failed to delete aborted assistant placeholder (${messageId}): ${deleteResult.error}`\n          );\n        }\n      };\n\n      // Mode (plan|exec|compact) is derived from the selected agent definition.\n      const effectiveMuxProviderOptions: MuxProviderOptions = muxProviderOptions ?? {};\n      const effectiveThinkingLevel: ThinkingLevel = thinkingLevel ?? THINKING_LEVEL_OFF;\n\n      // Resolve model string (xAI variant mapping + gateway routing) and create the model.\n      const modelResult = await this.providerModelFactory.resolveAndCreateModel(\n        modelString,\n        effectiveThinkingLevel,\n        effectiveMuxProviderOptions\n      );\n      if (!modelResult.success) {\n        return Err(modelResult.error);\n      }\n      const {\n        effectiveModelString,\n        canonicalModelString,\n        canonicalProviderName,\n        routedThroughGateway,\n      } = modelResult.data;\n\n      // Dump original messages for debugging\n      log.debug_obj(`${workspaceId}/1_original_messages.json`, messages);\n\n      // toolNamesForSentinel is set after agent resolution below, used in message pipeline.\n      let toolNamesForSentinel: string[] = [];\n\n      // Filter out assistant messages with only reasoning (no text/tools)\n      // EXCEPTION: When extended thinking is enabled, preserve reasoning-only messages\n      // to comply with Extended Thinking API requirements\n      const preserveReasoningOnly =\n        canonicalProviderName === \"anthropic\" && effectiveThinkingLevel !== \"off\";\n      const filteredMessages = filterEmptyAssistantMessages(messages, preserveReasoningOnly);\n      log.debug(`Filtered ${messages.length - filteredMessages.length} empty assistant messages`);\n      log.debug_obj(`${workspaceId}/1a_filtered_messages.json`, filteredMessages);\n\n      // WS2 request slicing: only send the latest compaction epoch to providers.\n      // This is request-only; persisted history remains append-only for replay/debugging.\n      const providerRequestMessages = sliceMessagesFromLatestCompactionBoundary(filteredMessages);\n      if (providerRequestMessages !== filteredMessages) {\n        log.debug(\"Sliced provider history from latest compaction boundary\", {\n          workspaceId,\n          originalCount: filteredMessages.length,\n          slicedCount: providerRequestMessages.length,\n        });\n      }\n      log.debug_obj(`${workspaceId}/1b_provider_request_messages.json`, providerRequestMessages);\n\n      // OpenAI-specific: Keep reasoning parts in history\n      // OpenAI manages conversation state via previousResponseId\n      if (canonicalProviderName === \"openai\") {\n        log.debug(\"Keeping reasoning parts for OpenAI (managed via previousResponseId)\");\n      }\n      // Add [CONTINUE] sentinel to partial messages (for model context)\n      const messagesWithSentinel = addInterruptedSentinel(providerRequestMessages);\n\n      // Get workspace metadata to retrieve workspace path\n      const metadataResult = await this.getWorkspaceMetadata(workspaceId);\n      if (!metadataResult.success) {\n        return Err({ type: \"unknown\", raw: metadataResult.error });\n      }\n\n      const metadata = metadataResult.data;\n\n      if (this.policyService?.isEnforced()) {\n        if (!this.policyService.isRuntimeAllowed(metadata.runtimeConfig)) {\n          return Err({\n            type: \"policy_denied\",\n            message: \"Workspace runtime is not allowed by policy\",\n          });\n        }\n      }\n      const workspaceLog = log.withFields({ workspaceId, workspaceName: metadata.name });\n\n      if (!this.config.findWorkspace(workspaceId)) {\n        return Err({ type: \"unknown\", raw: `Workspace ${workspaceId} not found in config` });\n      }\n      const runtime = createRuntime(metadata.runtimeConfig, {\n        projectPath: metadata.projectPath,\n        workspaceName: metadata.name,\n      });\n      // In-place workspaces (CLI/benchmarks) have projectPath === name\n      // Use path directly instead of reconstructing via getWorkspacePath\n      const isInPlace = metadata.projectPath === metadata.name;\n      const workspacePath = isInPlace\n        ? metadata.projectPath\n        : runtime.getWorkspacePath(metadata.projectPath, metadata.name);\n\n      // Wait for init to complete before any runtime I/O operations\n      // (SSH/devcontainer may not be ready until init finishes pulling the container)\n      await this.initStateManager.waitForInit(workspaceId, combinedAbortSignal);\n      if (combinedAbortSignal.aborted) {\n        return Ok(undefined);\n      }\n\n      // Verify runtime is actually reachable after init completes.\n      // For Docker workspaces, this checks the container exists and starts it if stopped.\n      // For Coder workspaces, this may start a stopped workspace and wait for it.\n      // If init failed during container creation, ensureReady() will return an error.\n      const readyResult = await runtime.ensureReady({\n        signal: combinedAbortSignal,\n        statusSink: (status) => {\n          // Emit runtime-status events for frontend UX (StreamingBarrier)\n          this.emit(\"runtime-status\", {\n            type: \"runtime-status\",\n            workspaceId,\n            phase: status.phase,\n            runtimeType: status.runtimeType,\n            detail: status.detail,\n          });\n        },\n      });\n      if (!readyResult.ready) {\n        // Generate message ID for the error event (frontend needs this for synthetic message)\n        const errorMessageId = createAssistantMessageId();\n        const runtimeType = metadata.runtimeConfig?.type ?? \"local\";\n        const runtimeLabel = runtimeType === \"docker\" ? \"Container\" : \"Runtime\";\n        const errorMessage = readyResult.error || `${runtimeLabel} unavailable.`;\n\n        // Use the errorType from ensureReady result (runtime_not_ready vs runtime_start_failed)\n        const errorType = readyResult.errorType;\n\n        // Emit error event so frontend receives it via stream subscription.\n        // This mirrors the context_exceeded pattern - the fire-and-forget sendMessage\n        // call in useCreationWorkspace.ts won't see the returned Err, but will receive\n        // this event through the workspace chat subscription.\n        this.emit(\n          \"error\",\n          createErrorEvent(workspaceId, {\n            messageId: errorMessageId,\n            error: errorMessage,\n            errorType,\n          })\n        );\n\n        return Err({\n          type: errorType,\n          message: errorMessage,\n        });\n      }\n\n      // Resolve agent definition, compute effective mode & tool policy.\n      const cfg = this.config.loadConfigOrDefault();\n      const agentResult = await resolveAgentForStream({\n        workspaceId,\n        metadata,\n        runtime,\n        workspacePath,\n        requestedAgentId: agentId,\n        disableWorkspaceAgents: disableWorkspaceAgents ?? false,\n        modelString,\n        callerToolPolicy: toolPolicy,\n        cfg,\n        emitError: (event) => this.emit(\"error\", event),\n        initStateManager: this.initStateManager,\n      });\n      if (!agentResult.success) {\n        return agentResult;\n      }\n      const {\n        effectiveAgentId,\n        agentDefinition,\n        agentDiscoveryPath,\n        isSubagentWorkspace,\n        agentIsPlanLike,\n        effectiveMode,\n        taskSettings,\n        taskDepth,\n        shouldDisableTaskToolsForDepth,\n        effectiveToolPolicy,\n      } = agentResult.data;\n      toolNamesForSentinel = agentResult.data.toolNamesForSentinel;\n\n      // Fetch workspace MCP overrides (for filtering servers and tools)\n      // NOTE: Stored in <workspace>/.mux/mcp.local.jsonc (not ~/.mux/config.json).\n      let mcpOverrides: WorkspaceMCPOverrides | undefined;\n      try {\n        mcpOverrides =\n          await this.workspaceMcpOverridesService.getOverridesForWorkspace(workspaceId);\n      } catch (error) {\n        log.warn(\"[MCP] Failed to load workspace MCP overrides; continuing without overrides\", {\n          workspaceId,\n          error,\n        });\n        mcpOverrides = undefined;\n      }\n\n      // Fetch MCP server config for system prompt (before building message)\n      // Pass overrides to filter out disabled servers\n      const mcpServers =\n        this.mcpServerManager && workspaceId !== MUX_HELP_CHAT_WORKSPACE_ID\n          ? await this.mcpServerManager.listServers(metadata.projectPath, mcpOverrides)\n          : undefined;\n\n      // Build plan-aware instructions and determine planâ†’exec transition content.\n      // IMPORTANT: Derive this from the same boundary-sliced message payload that is sent to\n      // the model so plan hints/handoffs cannot be suppressed by pre-boundary history.\n      const { effectiveAdditionalInstructions, planFilePath, planContentForTransition } =\n        await buildPlanInstructions({\n          runtime,\n          metadata,\n          workspaceId,\n          workspacePath,\n          effectiveMode,\n          effectiveAgentId,\n          agentIsPlanLike,\n          agentDiscoveryPath,\n          additionalSystemInstructions,\n          shouldDisableTaskToolsForDepth,\n          taskDepth,\n          taskSettings,\n          requestPayloadMessages: providerRequestMessages,\n        });\n\n      // Run the full message preparation pipeline (inject context, transform, validate).\n      // This is a purely functional pipeline with no service dependencies.\n      const finalMessages = await prepareMessagesForProvider({\n        messagesWithSentinel,\n        effectiveAgentId,\n        toolNamesForSentinel,\n        planContentForTransition,\n        planFilePath,\n        changedFileAttachments,\n        postCompactionAttachments,\n        runtime,\n        workspacePath,\n        abortSignal: combinedAbortSignal,\n        providerForMessages: canonicalProviderName,\n        effectiveThinkingLevel,\n        modelString,\n        workspaceId,\n      });\n\n      // Build agent system prompt, system message, and discover agents/skills.\n      const {\n        agentSystemPrompt,\n        systemMessage,\n        systemMessageTokens,\n        agentDefinitions,\n        availableSkills,\n      } = await buildStreamSystemContext({\n        runtime,\n        metadata,\n        workspacePath,\n        workspaceId,\n        agentDefinition,\n        agentDiscoveryPath,\n        isSubagentWorkspace,\n        effectiveAdditionalInstructions,\n        modelString,\n        cfg,\n        mcpServers,\n      });\n\n      // Load project secrets (system workspace never gets secrets injected)\n      const projectSecrets =\n        workspaceId === MUX_HELP_CHAT_WORKSPACE_ID\n          ? []\n          : this.config.getEffectiveSecrets(metadata.projectPath);\n\n      // Generate stream token and create temp directory for tools\n      const streamToken = this.streamManager.generateStreamToken();\n\n      let mcpTools: Record<string, Tool> | undefined;\n      let mcpStats: MCPWorkspaceStats | undefined;\n      let mcpSetupDurationMs = 0;\n\n      if (this.mcpServerManager && workspaceId !== MUX_HELP_CHAT_WORKSPACE_ID) {\n        const start = Date.now();\n        try {\n          const result = await this.mcpServerManager.getToolsForWorkspace({\n            workspaceId,\n            projectPath: metadata.projectPath,\n            runtime,\n            workspacePath,\n            overrides: mcpOverrides,\n            projectSecrets: secretsToRecord(projectSecrets),\n          });\n\n          mcpTools = result.tools;\n          mcpStats = result.stats;\n        } catch (error) {\n          workspaceLog.error(\"Failed to start MCP servers\", { error });\n        } finally {\n          mcpSetupDurationMs = Date.now() - start;\n        }\n      }\n\n      const runtimeTempDir = await this.streamManager.createTempDirForStream(streamToken, runtime);\n\n      // Extract tool-specific instructions from AGENTS.md files and agent definition\n      const toolInstructions = await readToolInstructions(\n        metadata,\n        runtime,\n        workspacePath,\n        modelString,\n        agentSystemPrompt\n      );\n\n      // Calculate cumulative session costs for MUX_COSTS_USD env var\n      let sessionCostsUsd: number | undefined;\n      if (this.sessionUsageService) {\n        const sessionUsage = await this.sessionUsageService.getSessionUsage(workspaceId);\n        if (sessionUsage) {\n          const allUsage = sumUsageHistory(Object.values(sessionUsage.byModel));\n          sessionCostsUsd = getTotalCost(allUsage);\n        }\n      }\n\n      // Get model-specific tools with workspace path (correct for local or remote)\n      const allTools = await getToolsForModel(\n        modelString,\n        {\n          cwd: workspacePath,\n          runtime,\n          secrets: secretsToRecord(projectSecrets),\n          muxEnv: getMuxEnv(\n            metadata.projectPath,\n            getRuntimeType(metadata.runtimeConfig),\n            metadata.name,\n            {\n              modelString,\n              thinkingLevel: thinkingLevel ?? \"off\",\n              costsUsd: sessionCostsUsd,\n            }\n          ),\n          runtimeTempDir,\n          backgroundProcessManager: this.backgroundProcessManager,\n          // Plan agent configuration for plan file access.\n          // - read: plan file is readable in all agents (useful context)\n          // - write: enforced by file_edit_* tools (plan file is read-only outside plan agent)\n          planFileOnly: agentIsPlanLike,\n          emitChatEvent: (event) => {\n            // Defensive: tools should only emit events for the workspace they belong to.\n            if (\"workspaceId\" in event && event.workspaceId !== workspaceId) {\n              return;\n            }\n            this.emit(event.type, event as never);\n          },\n          workspaceSessionDir: this.config.getSessionDir(workspaceId),\n          planFilePath,\n          workspaceId,\n          // Only child workspaces (tasks) can report to a parent.\n          enableAgentReport: Boolean(metadata.parentWorkspaceId),\n          // External edit detection callback\n          recordFileState,\n          taskService: this.taskService,\n          // PTC experiments for inheritance to subagents\n          experiments,\n          // Dynamic context for tool descriptions (moved from system prompt for better model attention)\n          availableSubagents: agentDefinitions,\n          availableSkills,\n        },\n        workspaceId,\n        this.initStateManager,\n        toolInstructions,\n        mcpTools\n      );\n\n      // Create assistant message ID early so the PTC callback closure captures it.\n      // The placeholder is appended to history below (after abort check).\n      const assistantMessageId = createAssistantMessageId();\n\n      // Apply tool policy and PTC experiments (lazy-loads PTC dependencies only when needed).\n      const tools = await applyToolPolicyAndExperiments({\n        allTools,\n        extraTools: this.extraTools,\n        effectiveToolPolicy,\n        experiments,\n        // Forward nested PTC tool events to the stream (tool-call-start/end only,\n        // not console events which appear in final result only).\n        emitNestedToolEvent: (event: PTCEventWithParent) => {\n          if (event.type === \"tool-call-start\" || event.type === \"tool-call-end\") {\n            this.streamManager.emitNestedToolEvent(workspaceId, assistantMessageId, event);\n          }\n        },\n      });\n\n      captureMcpToolTelemetry({\n        telemetryService: this.telemetryService,\n        mcpStats,\n        mcpTools,\n        tools,\n        mcpSetupDurationMs,\n        workspaceId,\n        modelString,\n        effectiveAgentId,\n        metadata,\n        effectiveToolPolicy,\n      });\n\n      if (combinedAbortSignal.aborted) {\n        return Ok(undefined);\n      }\n\n      const assistantMessage = createMuxMessage(assistantMessageId, \"assistant\", \"\", {\n        timestamp: Date.now(),\n        model: canonicalModelString,\n        routedThroughGateway,\n        systemMessageTokens,\n        agentId: effectiveAgentId,\n      });\n\n      // Append to history to get historySequence assigned\n      const appendResult = await this.historyService.appendToHistory(workspaceId, assistantMessage);\n      if (!appendResult.success) {\n        return Err({ type: \"unknown\", raw: appendResult.error });\n      }\n\n      // Get the assigned historySequence\n      const historySequence = assistantMessage.metadata?.historySequence ?? 0;\n\n      // Handle simulated stream scenarios (OpenAI SDK testing features).\n      // These emit synthetic stream events without calling an AI provider.\n      const forceContextLimitError =\n        modelString.startsWith(\"openai:\") &&\n        effectiveMuxProviderOptions.openai?.forceContextLimitError === true;\n      const simulateToolPolicyNoopFlag =\n        modelString.startsWith(\"openai:\") &&\n        effectiveMuxProviderOptions.openai?.simulateToolPolicyNoop === true;\n\n      if (forceContextLimitError || simulateToolPolicyNoopFlag) {\n        const simulationCtx: SimulationContext = {\n          workspaceId,\n          assistantMessageId,\n          canonicalModelString,\n          routedThroughGateway,\n          historySequence,\n          systemMessageTokens,\n          effectiveAgentId,\n          effectiveMode,\n          effectiveThinkingLevel,\n          emit: (event, data) => this.emit(event, data),\n        };\n\n        if (forceContextLimitError) {\n          await simulateContextLimitError(simulationCtx, this.partialService);\n        } else {\n          await simulateToolPolicyNoop(\n            simulationCtx,\n            effectiveToolPolicy,\n            this.historyService,\n            this.partialService\n          );\n        }\n        return Ok(undefined);\n      }\n\n      // Build provider options based on thinking level and request-sliced message history.\n      const truncationMode = openaiTruncationModeOverride;\n      // Use the same boundary-sliced payload history that we send to the provider.\n      // This prevents previousResponseId lookup from reaching pre-compaction epochs.\n      // Also pass callback to filter out lost responseIds (OpenAI invalidated them).\n      // Pass workspaceId to derive stable promptCacheKey for OpenAI caching.\n      const providerOptions = buildProviderOptions(\n        modelString,\n        effectiveThinkingLevel,\n        providerRequestMessages,\n        (id) => this.streamManager.isResponseIdLost(id),\n        effectiveMuxProviderOptions,\n        workspaceId,\n        truncationMode\n      );\n\n      // Debug dump: Log the complete LLM request when MUX_DEBUG_LLM_REQUEST is set\n      if (process.env.MUX_DEBUG_LLM_REQUEST === \"1\") {\n        log.info(\n          `[MUX_DEBUG_LLM_REQUEST] Full LLM request:\\n${JSON.stringify(\n            {\n              workspaceId,\n              model: modelString,\n              systemMessage,\n              messages: finalMessages,\n              tools: Object.fromEntries(\n                Object.entries(tools).map(([n, t]) => [\n                  n,\n                  { description: t.description, inputSchema: t.inputSchema },\n                ])\n              ),\n              providerOptions,\n              thinkingLevel: effectiveThinkingLevel,\n              maxOutputTokens,\n              mode: effectiveMode,\n              agentId: effectiveAgentId,\n              toolPolicy: effectiveToolPolicy,\n            },\n            null,\n            2\n          )}`\n        );\n      }\n\n      if (combinedAbortSignal.aborted) {\n        await deleteAbortedPlaceholder(assistantMessageId);\n        return Ok(undefined);\n      }\n\n      // Capture request payload for the debug modal, then delegate to StreamManager.\n      const snapshot: DebugLlmRequestSnapshot = {\n        capturedAt: Date.now(),\n        workspaceId,\n        messageId: assistantMessageId,\n        model: modelString,\n        providerName: canonicalProviderName,\n        thinkingLevel: effectiveThinkingLevel,\n        mode: effectiveMode,\n        agentId: effectiveAgentId,\n        maxOutputTokens,\n        systemMessage,\n        messages: finalMessages,\n      };\n\n      try {\n        this.lastLlmRequestByWorkspace.set(workspaceId, safeClone(snapshot));\n      } catch (error) {\n        const errMsg = error instanceof Error ? error.message : String(error);\n        workspaceLog.warn(\"Failed to capture debug LLM request snapshot\", { error: errMsg });\n      }\n      const toolsForStream =\n        experiments?.system1 === true\n          ? wrapToolsWithSystem1({\n              tools,\n              system1Model,\n              system1ThinkingLevel,\n              modelString,\n              effectiveModelString,\n              primaryModel: modelResult.data.model,\n              muxProviderOptions: effectiveMuxProviderOptions,\n              workspaceId,\n              effectiveMode,\n              planFilePath,\n              taskSettings,\n              runtimeTempDir,\n              runtime,\n              agentDiscoveryPath,\n              resolveGatewayModelString: (ms, dm, eg) =>\n                this.providerModelFactory.resolveGatewayModelString(ms, dm, eg),\n              createModel: (ms, o) => this.createModel(ms, o),\n              emitBashOutput: (ev) => this.emit(\"bash-output\", ev),\n            })\n          : tools;\n\n      const streamResult = await this.streamManager.startStream(\n        workspaceId,\n        finalMessages,\n        modelResult.data.model,\n        modelString,\n        historySequence,\n        systemMessage,\n        runtime,\n        assistantMessageId, // Shared messageId ensures nested tool events match stream events\n        combinedAbortSignal,\n        toolsForStream,\n        {\n          systemMessageTokens,\n          timestamp: Date.now(),\n          agentId: effectiveAgentId,\n          mode: effectiveMode,\n          routedThroughGateway,\n          ...(modelCostsIncluded(modelResult.data.model) ? { costsIncluded: true } : {}),\n        },\n        providerOptions,\n        maxOutputTokens,\n        effectiveToolPolicy,\n        streamToken, // Pass the pre-generated stream token\n        hasQueuedMessage,\n        metadata.name,\n        effectiveThinkingLevel\n      );\n\n      if (!streamResult.success) {\n        // StreamManager already returns SendMessageError\n        return Err(streamResult.error);\n      }\n\n      // If we were interrupted during StreamManager startup before the stream was registered,\n      // make sure we don't leave an empty assistant placeholder behind.\n      if (combinedAbortSignal.aborted && !this.streamManager.isStreaming(workspaceId)) {\n        await deleteAbortedPlaceholder(assistantMessageId);\n      }\n\n      // StreamManager now handles history updates directly on stream-end\n      // No need for event listener here\n      return Ok(undefined);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      log.error(\"Stream message error:\", error);\n      // Return as unknown error type\n      return Err({ type: \"unknown\", raw: `Failed to stream message: ${errorMessage}` });\n    } finally {\n      unlinkAbortSignal();\n      const pending = this.pendingStreamStarts.get(workspaceId);\n      if (pending?.abortController === pendingAbortController) {\n        this.pendingStreamStarts.delete(workspaceId);\n      }\n    }\n  }\n\n  async stopStream(\n    workspaceId: string,\n    options?: { soft?: boolean; abandonPartial?: boolean; abortReason?: StreamAbortReason }\n  ): Promise<Result<void>> {\n    const pending = this.pendingStreamStarts.get(workspaceId);\n    const isActuallyStreaming =\n      this.mockModeEnabled && this.mockAiStreamPlayer\n        ? this.mockAiStreamPlayer.isStreaming(workspaceId)\n        : this.streamManager.isStreaming(workspaceId);\n\n    if (pending) {\n      pending.abortController.abort();\n\n      // If we're still in pre-stream startup (no StreamManager stream yet), emit a synthetic\n      // stream-abort so the renderer can exit the \"starting...\" UI immediately.\n      const abortReason = options?.abortReason ?? \"startup\";\n      if (!isActuallyStreaming) {\n        this.emit(\"stream-abort\", {\n          type: \"stream-abort\",\n          workspaceId,\n          abortReason,\n          messageId: pending.syntheticMessageId,\n          metadata: { duration: Date.now() - pending.startTime },\n          abandonPartial: options?.abandonPartial,\n        } satisfies StreamAbortEvent);\n      }\n    }\n\n    if (this.mockModeEnabled && this.mockAiStreamPlayer) {\n      this.mockAiStreamPlayer.stop(workspaceId);\n      return Ok(undefined);\n    }\n    return this.streamManager.stopStream(workspaceId, options);\n  }\n\n  /**\n   * Check if a workspace is currently streaming\n   */\n  isStreaming(workspaceId: string): boolean {\n    if (this.mockModeEnabled && this.mockAiStreamPlayer) {\n      return this.mockAiStreamPlayer.isStreaming(workspaceId);\n    }\n    return this.streamManager.isStreaming(workspaceId);\n  }\n\n  /**\n   * Get the current stream state for a workspace\n   */\n  getStreamState(workspaceId: string): string {\n    if (this.mockModeEnabled && this.mockAiStreamPlayer) {\n      return this.mockAiStreamPlayer.isStreaming(workspaceId) ? \"streaming\" : \"idle\";\n    }\n    return this.streamManager.getStreamState(workspaceId);\n  }\n\n  /**\n   * Get the current stream info for a workspace if actively streaming\n   * Used to re-establish streaming context on frontend reconnection\n   */\n  getStreamInfo(workspaceId: string): ReturnType<typeof this.streamManager.getStreamInfo> {\n    if (this.mockModeEnabled && this.mockAiStreamPlayer) {\n      return undefined;\n    }\n    return this.streamManager.getStreamInfo(workspaceId);\n  }\n\n  /**\n   * Replay stream events\n   * Emits the same events that would be emitted during live streaming\n   */\n  async replayStream(workspaceId: string): Promise<void> {\n    if (this.mockModeEnabled && this.mockAiStreamPlayer) {\n      await this.mockAiStreamPlayer.replayStream(workspaceId);\n      return;\n    }\n    await this.streamManager.replayStream(workspaceId);\n  }\n\n  debugGetLastMockPrompt(workspaceId: string): Result<MuxMessage[] | null> {\n    if (typeof workspaceId !== \"string\" || workspaceId.trim().length === 0) {\n      return Err(\"debugGetLastMockPrompt: workspaceId is required\");\n    }\n\n    if (!this.mockModeEnabled || !this.mockAiStreamPlayer) {\n      return Ok(null);\n    }\n\n    return Ok(this.mockAiStreamPlayer.debugGetLastPrompt(workspaceId));\n  }\n  debugGetLastMockModel(workspaceId: string): Result<string | null> {\n    if (typeof workspaceId !== \"string\" || workspaceId.trim().length === 0) {\n      return Err(\"debugGetLastMockModel: workspaceId is required\");\n    }\n\n    if (!this.mockModeEnabled || !this.mockAiStreamPlayer) {\n      return Ok(null);\n    }\n\n    return Ok(this.mockAiStreamPlayer.debugGetLastModel(workspaceId));\n  }\n\n  debugGetLastLlmRequest(workspaceId: string): Result<DebugLlmRequestSnapshot | null> {\n    if (typeof workspaceId !== \"string\" || workspaceId.trim().length === 0) {\n      return Err(\"debugGetLastLlmRequest: workspaceId is required\");\n    }\n\n    return Ok(this.lastLlmRequestByWorkspace.get(workspaceId) ?? null);\n  }\n\n  /**\n   * DEBUG ONLY: Trigger an artificial stream error for testing.\n   * This is used by integration tests to simulate network errors mid-stream.\n   * @returns true if an active stream was found and error was triggered\n   */\n  debugTriggerStreamError(\n    workspaceId: string,\n    errorMessage = \"Test-triggered stream error\"\n  ): Promise<boolean> {\n    return this.streamManager.debugTriggerStreamError(workspaceId, errorMessage);\n  }\n\n  /**\n   * Wait for workspace initialization to complete (if running).\n   * Public wrapper for agent discovery and other callers.\n   */\n  async waitForInit(workspaceId: string, abortSignal?: AbortSignal): Promise<void> {\n    return this.initStateManager.waitForInit(workspaceId, abortSignal);\n  }\n\n  async deleteWorkspace(workspaceId: string): Promise<Result<void>> {\n    try {\n      const workspaceDir = this.config.getSessionDir(workspaceId);\n      await fs.rm(workspaceDir, { recursive: true, force: true });\n      return Ok(undefined);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return Err(`Failed to delete workspace: ${message}`);\n    }\n  }\n}\n"]}