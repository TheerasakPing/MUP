{"version":3,"file":"streamManager.js","sourceRoot":"","sources":["../../../src/node/services/streamManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from \"events\";\nimport * as path from \"path\";\nimport { PlatformPaths } from \"@/common/utils/paths\";\nimport {\n  streamText,\n  stepCountIs,\n  type ModelMessage,\n  type LanguageModel,\n  type Tool,\n  LoadAPIKeyError,\n  APICallError,\n  RetryError,\n} from \"ai\";\nimport type { LanguageModelV2Usage } from \"@ai-sdk/provider\";\nimport type { Result } from \"@/common/types/result\";\nimport { Ok, Err } from \"@/common/types/result\";\nimport { log, type Logger } from \"./log\";\nimport type {\n  StreamStartEvent,\n  StreamEndEvent,\n  StreamAbortReason,\n  UsageDeltaEvent,\n  ToolCallEndEvent,\n  CompletedMessagePart,\n} from \"@/common/types/stream\";\n\nimport type { SendMessageError, StreamErrorType } from \"@/common/types/errors\";\nimport type { MuxMetadata, MuxMessage } from \"@/common/types/message\";\nimport type { ThinkingLevel } from \"@/common/types/thinking\";\nimport type { NestedToolCall } from \"@/common/orpc/schemas/message\";\nimport {\n  coerceStreamErrorTypeForMessage,\n  createErrorEvent,\n  stripNoisyErrorPrefix,\n  type StreamErrorPayload,\n} from \"@/node/services/utils/sendMessageError\";\nimport type { PartialService } from \"./partialService\";\nimport type { HistoryService } from \"./historyService\";\nimport { addUsage, accumulateProviderMetadata } from \"@/common/utils/tokens/usageHelpers\";\nimport { linkAbortSignal } from \"@/node/utils/abort\";\nimport { AsyncMutex } from \"@/node/utils/concurrency/asyncMutex\";\nimport { stripInternalToolResultFields } from \"@/common/utils/tools/internalToolResultFields\";\nimport type { ToolPolicy } from \"@/common/utils/tools/toolPolicy\";\nimport { StreamingTokenTracker } from \"@/node/utils/main/StreamingTokenTracker\";\nimport type { MCPServerManager } from \"@/node/services/mcpServerManager\";\nimport type { Runtime } from \"@/node/runtime/Runtime\";\nimport {\n  createCachedSystemMessage,\n  applyCacheControlToTools,\n} from \"@/common/utils/ai/cacheStrategy\";\nimport type { SessionUsageService } from \"./sessionUsageService\";\nimport type { CostTrackingService } from \"./costTrackingService\";\nimport { createDisplayUsage } from \"@/common/utils/tokens/displayUsage\";\nimport { extractToolMediaAsUserMessagesFromModelMessages } from \"@/node/utils/messages/extractToolMediaAsUserMessagesFromModelMessages\";\nimport { normalizeGatewayModel } from \"@/common/utils/ai/models\";\nimport { MUX_GATEWAY_SESSION_EXPIRED_MESSAGE } from \"@/common/constants/muxGatewayOAuth\";\nimport { getModelStats } from \"@/common/utils/tokens/modelStats\";\n\n// Disable AI SDK warning logging (e.g., \"setting `toolChoice` to `none` is not supported\")\nglobalThis.AI_SDK_LOG_WARNINGS = false;\n\n// Type definitions for stream parts with extended properties\ninterface ReasoningDeltaPart {\n  type: \"reasoning-delta\";\n  text?: string;\n  delta?: string;\n  providerMetadata?: {\n    anthropic?: {\n      signature?: string;\n      redactedData?: string;\n    };\n  };\n}\n\n// Tool-call tracking + branded types\ninterface ToolCallState {\n  toolCallId: string;\n  toolName: string;\n  input: unknown;\n  output?: unknown;\n}\n\ntype ToolCallMap = Map<string, ToolCallState>;\n\ntype WorkspaceId = string & { __brand: \"WorkspaceId\" };\ntype StreamToken = string & { __brand: \"StreamToken\" };\n\n// Stream request config for start/retry\n\ntype StreamToolChoice = { type: \"tool\"; toolName: string } | \"required\" | undefined;\n\ninterface StepMessageTracker {\n  latestMessages?: ModelMessage[];\n}\ninterface StreamRequestConfig {\n  model: LanguageModel;\n  messages: ModelMessage[];\n  system?: string;\n  tools?: Record<string, Tool>;\n  toolChoice?: StreamToolChoice;\n  providerOptions?: Record<string, unknown>;\n  maxOutputTokens?: number;\n  hasQueuedMessage?: () => boolean;\n}\n\n// Stream state enum for exhaustive checking\nenum StreamState {\n  IDLE = \"idle\",\n  STARTING = \"starting\",\n  STREAMING = \"streaming\",\n  STOPPING = \"stopping\",\n  COMPLETED = \"completed\", // Stream finished successfully (before cleanup)\n  ERROR = \"error\",\n}\n\n/**\n * Strip encryptedContent from web search results to reduce token usage.\n * The encrypted page content can be massive (4000+ chars per result) and isn't\n * needed for model context. Keep URL, title, and pageAge for reference.\n */\nfunction stripEncryptedContentFromArray(output: unknown[]): unknown[] {\n  return output.map((item: unknown) => {\n    if (item && typeof item === \"object\" && \"encryptedContent\" in item) {\n      // Remove encryptedContent but keep other fields\n      const { encryptedContent, ...rest } = item as Record<string, unknown>;\n      return rest;\n    }\n\n    return item;\n  });\n}\n\nexport function stripEncryptedContent(output: unknown): unknown {\n  if (Array.isArray(output)) {\n    return stripEncryptedContentFromArray(output);\n  }\n\n  // Handle SDK json output shape: { type: \"json\", value: unknown[] }\n  if (\n    typeof output === \"object\" &&\n    output !== null &&\n    \"type\" in output &&\n    output.type === \"json\" &&\n    \"value\" in output &&\n    Array.isArray(output.value)\n  ) {\n    return {\n      ...output,\n      value: stripEncryptedContentFromArray(output.value),\n    };\n  }\n\n  return output;\n}\n\nconst MAX_ORPHAN_TOOL_RESULT_WARNINGS_PER_STREAM = 3;\nconst ORPHAN_TOOL_RESULT_PREVIEW_CHARS = 160;\nconst ORPHAN_TOOL_RESULT_MAX_KEYS = 8;\n\nfunction summarizeToolResultForLog(output: unknown): Record<string, unknown> {\n  if (output === null) {\n    return { outputType: \"null\" };\n  }\n\n  if (typeof output === \"string\") {\n    return {\n      outputType: \"string\",\n      outputLength: output.length,\n      outputPreview: output.slice(0, ORPHAN_TOOL_RESULT_PREVIEW_CHARS),\n    };\n  }\n\n  if (typeof output === \"number\" || typeof output === \"boolean\") {\n    return {\n      outputType: typeof output,\n      outputPreview: String(output),\n    };\n  }\n\n  if (Array.isArray(output)) {\n    return {\n      outputType: \"array\",\n      outputLength: output.length,\n      firstItemType:\n        output.length > 0 && output[0] !== null\n          ? typeof output[0]\n          : output.length > 0\n            ? \"null\"\n            : undefined,\n    };\n  }\n\n  if (typeof output === \"object\") {\n    const outputRecord = output as Record<string, unknown>;\n    const keys = Object.keys(outputRecord);\n    const summary: Record<string, unknown> = {\n      outputType: \"object\",\n      outputKeyCount: keys.length,\n      outputKeys: keys.slice(0, ORPHAN_TOOL_RESULT_MAX_KEYS),\n    };\n\n    if (typeof outputRecord.type === \"string\") {\n      summary.outputFormat = outputRecord.type;\n    }\n\n    if (Array.isArray(outputRecord.value)) {\n      summary.outputValueLength = outputRecord.value.length;\n    }\n\n    return summary;\n  }\n\n  return {\n    outputType: typeof output,\n    outputPreview: JSON.stringify(output),\n  };\n}\n\nfunction markProviderMetadataCostsIncluded(\n  providerMetadata: Record<string, unknown> | undefined,\n  costsIncluded: boolean | undefined\n): Record<string, unknown> | undefined {\n  if (!costsIncluded) return providerMetadata;\n\n  const muxMetadata = providerMetadata?.mux;\n  const existingMux =\n    muxMetadata && typeof muxMetadata === \"object\"\n      ? (muxMetadata as Record<string, unknown>)\n      : undefined;\n\n  return {\n    ...(providerMetadata ?? {}),\n    mux: {\n      ...(existingMux ?? {}),\n      costsIncluded: true,\n    },\n  };\n}\n// Comprehensive stream info\ninterface WorkspaceStreamInfo {\n  state: StreamState;\n  streamResult: Awaited<ReturnType<typeof streamText>>;\n  unlinkAbortSignal?: () => void;\n  abortController: AbortController;\n  workspaceName?: string;\n  messageId: string;\n  token: StreamToken;\n  startTime: number;\n\n  // Used to ensure part timestamps are strictly monotonic, even when multiple deltas land in the\n  // same millisecond. This avoids collisions in reconnect replay dedupe logic which keys off of\n  // (messageId, timestamp, delta).\n  lastPartTimestamp: number;\n\n  model: string;\n  /** Effective thinking level after model policy clamping */\n  thinkingLevel?: string;\n  initialMetadata?: Partial<MuxMetadata>;\n  request: StreamRequestConfig;\n  // Track last prepared step messages for safe retries after tool steps\n  stepTracker: StepMessageTracker;\n  // Track if a previousResponseId retry happened after a step completed so\n  // stream-end uses cumulative usage instead of the retried step's totalUsage.\n  didRetryPreviousResponseIdAtStep: boolean;\n  // Index into parts where the current step started (used to ensure safe retries)\n  currentStepStartIndex: number;\n  historySequence: number;\n  // Track accumulated parts for partial message (includes reasoning, text, and tools)\n  parts: CompletedMessagePart[];\n  // Track last partial write time for throttling\n  lastPartialWriteTime: number;\n  // Throttle timer for partial writes\n  partialWriteTimer?: ReturnType<typeof setTimeout>;\n  // Track in-flight write to serialize writes\n  partialWritePromise?: Promise<void>;\n  // Track background processing promise for guaranteed cleanup\n  processingPromise: Promise<void>;\n  // Soft-interrupt state: when pending, stream will end at next block boundary\n  softInterrupt:\n  | { pending: false }\n  | { pending: true; abandonPartial: boolean; abortReason: StreamAbortReason };\n  // Temporary directory for tool outputs (auto-cleaned when stream ends)\n  runtimeTempDir: string;\n  // Runtime for temp directory cleanup\n  runtime: Runtime;\n  // Cumulative usage across all steps (for live cost display during streaming)\n  cumulativeUsage: LanguageModelV2Usage;\n  // Cumulative provider metadata across all steps (for live cost display with cache tokens)\n  cumulativeProviderMetadata?: Record<string, unknown>;\n  // Last step's usage (for context window display during streaming)\n  lastStepUsage?: LanguageModelV2Usage;\n  // Last step's provider metadata (for context window cache display)\n  lastStepProviderMetadata?: Record<string, unknown>;\n}\n\n// Ensure per-stream part timestamps are strictly monotonic.\n//\n// Date.now() is millisecond-granularity, so two distinct chunks with identical text emitted in the\n// same millisecond can otherwise collide on (timestamp, delta) during reconnect replay buffering.\nfunction nextPartTimestamp(streamInfo: WorkspaceStreamInfo): number {\n  const now = Date.now();\n  const last = streamInfo.lastPartTimestamp;\n  const timestamp = now <= last ? last + 1 : now;\n  streamInfo.lastPartTimestamp = timestamp;\n  return timestamp;\n}\n\n/**\n * StreamManager - Handles all streaming operations with type safety and atomic operations\n *\n * Key invariants:\n * - Only one active stream per workspace at any time\n * - Atomic stream creation/cancellation operations\n * - Guaranteed resource cleanup in all code paths\n */\nexport class StreamManager extends EventEmitter {\n  private workspaceStreams = new Map<WorkspaceId, WorkspaceStreamInfo>();\n  private streamLocks = new Map<WorkspaceId, AsyncMutex>();\n  private readonly PARTIAL_WRITE_THROTTLE_MS = 500;\n  private readonly historyService: HistoryService;\n  private readonly partialService: PartialService;\n  private mcpServerManager?: MCPServerManager;\n  private readonly sessionUsageService?: SessionUsageService;\n  private readonly costTrackingService?: CostTrackingService;\n  // Token tracker for live streaming statistics\n  private tokenTracker = new StreamingTokenTracker();\n  // Track OpenAI previousResponseIds that have been invalidated\n  // When frontend retries, buildProviderOptions will omit these IDs\n  private lostResponseIds = new Set<string>();\n\n  constructor(\n    historyService: HistoryService,\n    partialService: PartialService,\n    sessionUsageService?: SessionUsageService,\n    costTrackingService?: CostTrackingService\n  ) {\n    super();\n    this.historyService = historyService;\n    this.partialService = partialService;\n    this.sessionUsageService = sessionUsageService;\n    this.costTrackingService = costTrackingService;\n  }\n\n  private getWorkspaceLogger(\n    workspaceId: WorkspaceId,\n    streamInfo?: Pick<WorkspaceStreamInfo, \"workspaceName\">\n  ): Logger {\n    const fields: Record<string, unknown> = { workspaceId };\n    if (streamInfo?.workspaceName) {\n      fields.workspaceName = streamInfo.workspaceName;\n    }\n    return log.withFields(fields);\n  }\n  setMCPServerManager(manager: MCPServerManager | undefined): void {\n    this.mcpServerManager = manager;\n  }\n\n  /**\n   * Write the current partial message to disk (throttled by mtime)\n   * Ensures writes happen during rapid streaming (crash-resilient)\n   */\n  private async schedulePartialWrite(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo\n  ): Promise<void> {\n    const now = Date.now();\n    const timeSinceLastWrite = now - streamInfo.lastPartialWriteTime;\n\n    // If enough time has passed, write immediately\n    if (timeSinceLastWrite >= this.PARTIAL_WRITE_THROTTLE_MS) {\n      await this.flushPartialWrite(workspaceId, streamInfo);\n      return;\n    }\n\n    // Otherwise, schedule write for remaining time (fire-and-forget for scheduled writes)\n    if (streamInfo.partialWriteTimer) {\n      clearTimeout(streamInfo.partialWriteTimer);\n    }\n\n    const remainingTime = this.PARTIAL_WRITE_THROTTLE_MS - timeSinceLastWrite;\n    streamInfo.partialWriteTimer = setTimeout(() => {\n      void this.flushPartialWrite(workspaceId, streamInfo);\n    }, remainingTime);\n  }\n\n  private async awaitPendingPartialWrite(streamInfo: WorkspaceStreamInfo): Promise<void> {\n    if (streamInfo.partialWritePromise) {\n      await streamInfo.partialWritePromise;\n    }\n  }\n\n  /**\n   * Flush any pending partial write and write immediately\n   * Serializes writes to prevent races - waits for any in-flight write before starting new one\n   */\n  private async flushPartialWrite(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo\n  ): Promise<void> {\n    // Wait for any in-flight write to complete first (serialization)\n    await this.awaitPendingPartialWrite(streamInfo);\n\n    // Clear throttle timer\n    if (streamInfo.partialWriteTimer) {\n      clearTimeout(streamInfo.partialWriteTimer);\n      streamInfo.partialWriteTimer = undefined;\n    }\n\n    // Start new write and track the promise\n    streamInfo.partialWritePromise = (async () => {\n      try {\n        const canonicalModel = normalizeGatewayModel(streamInfo.model);\n        const routedThroughGateway =\n          streamInfo.initialMetadata?.routedThroughGateway ??\n          streamInfo.model.startsWith(\"mux-gateway:\");\n\n        const partialMessage: MuxMessage = {\n          id: streamInfo.messageId,\n          role: \"assistant\",\n          metadata: {\n            historySequence: streamInfo.historySequence,\n            timestamp: streamInfo.startTime,\n            ...streamInfo.initialMetadata,\n            model: canonicalModel,\n            routedThroughGateway,\n            ...(streamInfo.thinkingLevel && {\n              thinkingLevel: streamInfo.thinkingLevel as ThinkingLevel,\n            }),\n            partial: true, // Always true - this method only writes partial messages\n          },\n          parts: streamInfo.parts, // Parts array includes reasoning, text, and tools\n        };\n\n        await this.partialService.writePartial(workspaceId as string, partialMessage);\n        streamInfo.lastPartialWriteTime = Date.now();\n      } catch (error) {\n        log.error(\"Failed to write partial message:\", error);\n      } finally {\n        // Clear promise when write completes\n        streamInfo.partialWritePromise = undefined;\n      }\n    })();\n\n    // Wait for this write to complete\n    await streamInfo.partialWritePromise;\n  }\n\n  /**\n   * Atomically ensures stream safety by cancelling any existing stream\n   * @param workspaceId The workspace to ensure stream safety for\n   * @returns A unique stream token for the new stream\n   */\n  private async ensureStreamSafety(workspaceId: WorkspaceId): Promise<StreamToken> {\n    const existing = this.workspaceStreams.get(workspaceId);\n\n    if (existing && existing.state !== StreamState.IDLE) {\n      await this.cancelStreamSafely(workspaceId, existing, \"system\", undefined);\n    }\n\n    // Generate unique token for this stream (8 hex chars for context efficiency)\n    return Math.random().toString(16).substring(2, 10) as StreamToken;\n  }\n\n  /**\n   * Generate a unique stream token (8 hex characters)\n   * Used by callers that need to prepare resources (like tools) before starting the stream\n   * Uses 8 hex chars instead of UUID for context efficiency (shorter paths in agent output)\n   */\n  public generateStreamToken(): StreamToken {\n    return Math.random().toString(16).substring(2, 10) as StreamToken;\n  }\n\n  /**\n   * Create a temporary directory for a stream token\n   * Use ~/.mux-tmp instead of system temp directory (e.g., /var/folders/...)\n   * because macOS user-scoped temp paths are extremely long, which leads to:\n   * - Agent mistakes when copying/manipulating paths\n   * - Harder to read in tool outputs\n   * - Potential path length issues on some systems\n   *\n   * Uses the Runtime abstraction so temp directories work for both local and SSH runtimes.\n   */\n  public async createTempDirForStream(streamToken: StreamToken, runtime: Runtime): Promise<string> {\n    const tempDir = `~/.mux-tmp/${streamToken}`;\n\n    // Resolve ~ in the runtime's context.\n    //\n    // IMPORTANT: On Windows local runtime, Git Bash may use a customized $HOME,\n    // while runtime.resolvePath expands ~ via Node (USERPROFILE). To avoid drift,\n    // create the directory using the resolved absolute path.\n    let resolvedPath = (await runtime.resolvePath(tempDir)).trim();\n\n    // In the main process, PlatformPaths defaults to POSIX behavior (no navigator),\n    // so we normalize Windows paths to forward slashes.\n    if (process.platform === \"win32\") {\n      resolvedPath = resolvedPath.replace(/\\\\/g, \"/\");\n    }\n\n    try {\n      await runtime.ensureDir(resolvedPath);\n    } catch (err) {\n      const msg = err instanceof Error ? err.message : String(err);\n      throw new Error(`Failed to create temp directory ${resolvedPath}: ${msg}`);\n    }\n\n    return resolvedPath;\n  }\n\n  private cleanupStreamTempDir(runtime: Runtime, runtimeTempDir: string): void {\n    // Use parent directory as cwd for safety - if runtimeTempDir is malformed,\n    // we won't accidentally run rm -rf from root.\n    const tempDirBasename = PlatformPaths.basename(runtimeTempDir);\n    const tempDirParent = path.dirname(runtimeTempDir);\n\n    // Fire-and-forget: don't block stream completion waiting for directory deletion.\n    // This is especially important for SSH where rm -rf can take 500ms-2s.\n    void runtime\n      .exec(`rm -rf \"${tempDirBasename}\"`, {\n        cwd: tempDirParent,\n        timeout: 10,\n      })\n      .then(async (result) => {\n        await result.exitCode;\n        log.debug(`Cleaned up temp dir: ${runtimeTempDir}`);\n      })\n      .catch((error) => {\n        log.error(`Failed to cleanup temp dir ${runtimeTempDir}:`, error);\n      });\n  }\n\n  /**\n   * Extracts usage and duration metadata from stream result.\n   *\n   * Usage is only available after stream completes naturally.\n   * On abort, the usage promise may hang - we use a timeout to return quickly.\n   */\n  private async emitToolCallDeltaIfPresent(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo,\n    part: unknown\n  ): Promise<boolean> {\n    const maybeDelta = part as { type?: string } | undefined;\n    if (maybeDelta?.type !== \"tool-call-delta\") {\n      return false;\n    }\n\n    const toolDelta = part as {\n      toolCallId: string;\n      toolName: string;\n      argsTextDelta: string;\n    };\n\n    const deltaText = String(toolDelta.argsTextDelta ?? \"\");\n    if (deltaText.length === 0) {\n      return true;\n    }\n\n    const tokens = await this.tokenTracker.countTokens(deltaText);\n    const timestamp = Date.now();\n\n    this.emit(\"tool-call-delta\", {\n      type: \"tool-call-delta\",\n      workspaceId: workspaceId as string,\n      messageId: streamInfo.messageId,\n      toolCallId: toolDelta.toolCallId,\n      toolName: toolDelta.toolName,\n      delta: toolDelta.argsTextDelta,\n      tokens,\n      timestamp,\n    });\n\n    return true;\n  }\n\n  private async getStreamMetadata(\n    streamInfo: WorkspaceStreamInfo,\n    timeoutMs = 1000\n  ): Promise<{\n    totalUsage?: LanguageModelV2Usage;\n    contextUsage?: LanguageModelV2Usage;\n    contextProviderMetadata?: Record<string, unknown>;\n    duration: number;\n  }> {\n    // Helper: wrap promise with independent timeout + error handling\n    // Each promise resolves independently - one failure doesn't mask others\n    const withTimeout = <T>(promise: PromiseLike<T>): Promise<T | undefined> =>\n      Promise.race([\n        promise,\n        new Promise<undefined>((resolve) => setTimeout(() => resolve(undefined), timeoutMs)),\n      ]).catch(() => undefined);\n\n    // Fetch all metadata in parallel with independent timeouts\n    // - totalUsage: sum of all steps (for cost calculation)\n    // - contextUsage: last step only (for context window display)\n    // - contextProviderMetadata: last step (for context window cache display)\n    const [totalUsage, contextUsage, contextProviderMetadata] = await Promise.all([\n      withTimeout(streamInfo.streamResult.totalUsage),\n      withTimeout(streamInfo.streamResult.usage),\n      withTimeout(streamInfo.streamResult.providerMetadata),\n    ]);\n\n    return {\n      totalUsage,\n      contextUsage,\n      contextProviderMetadata,\n      duration: Date.now() - streamInfo.startTime,\n    };\n  }\n\n  private resolveTotalUsageForStreamEnd(\n    streamInfo: WorkspaceStreamInfo,\n    totalUsage: LanguageModelV2Usage | undefined\n  ): LanguageModelV2Usage | undefined {\n    const cumulativeUsage = streamInfo.cumulativeUsage;\n    // totalTokens can be omitted by providers, so treat any non-zero usage field as valid.\n    const hasCumulativeUsage =\n      (cumulativeUsage.inputTokens ?? 0) > 0 ||\n      (cumulativeUsage.outputTokens ?? 0) > 0 ||\n      (cumulativeUsage.totalTokens ?? 0) > 0 ||\n      (cumulativeUsage.cachedInputTokens ?? 0) > 0 ||\n      (cumulativeUsage.reasoningTokens ?? 0) > 0;\n    if (streamInfo.didRetryPreviousResponseIdAtStep && hasCumulativeUsage) {\n      return cumulativeUsage;\n    }\n\n    return totalUsage;\n  }\n\n  /**\n   * Aggregate provider metadata across all steps.\n   *\n   * CRITICAL: For multi-step tool calls, cache creation tokens are reported per-step.\n   * streamResult.providerMetadata only contains the LAST step's metadata, missing\n   * cache creation tokens from earlier steps. We must sum across all steps.\n   */\n  private async getAggregatedProviderMetadata(\n    streamInfo: WorkspaceStreamInfo,\n    timeoutMs = 1000\n  ): Promise<Record<string, unknown> | undefined> {\n    try {\n      const steps = await Promise.race([\n        streamInfo.streamResult.steps,\n        new Promise<undefined>((resolve) => setTimeout(() => resolve(undefined), timeoutMs)),\n      ]);\n\n      if (!steps || steps.length === 0) {\n        // Fall back to last step's provider metadata\n        return await streamInfo.streamResult.providerMetadata;\n      }\n\n      // If only one step, no aggregation needed\n      if (steps.length === 1) {\n        return steps[0].providerMetadata;\n      }\n\n      // Aggregate cache creation tokens across all steps\n      let totalCacheCreationTokens = 0;\n      let lastStepMetadata: Record<string, unknown> | undefined;\n\n      for (const step of steps) {\n        lastStepMetadata = step.providerMetadata;\n        const anthropicMeta = step.providerMetadata?.anthropic as\n          | { cacheCreationInputTokens?: number }\n          | undefined;\n        if (anthropicMeta?.cacheCreationInputTokens) {\n          totalCacheCreationTokens += anthropicMeta.cacheCreationInputTokens;\n        }\n      }\n\n      // If no cache creation tokens found, just return last step's metadata\n      if (totalCacheCreationTokens === 0) {\n        return lastStepMetadata;\n      }\n\n      // Merge aggregated cache creation tokens into the last step's metadata\n      return {\n        ...lastStepMetadata,\n        anthropic: {\n          ...(lastStepMetadata?.anthropic as Record<string, unknown> | undefined),\n          cacheCreationInputTokens: totalCacheCreationTokens,\n        },\n      };\n    } catch (error) {\n      log.debug(\"Could not aggregate provider metadata:\", error);\n      return undefined;\n    }\n  }\n\n  /**\n   * Safely cancels an existing stream with proper cleanup\n   *\n   * CRITICAL: Waits for the processing promise to complete before cleanup.\n   * This ensures the old stream fully exits before a new stream can start,\n   * preventing concurrent streams and race conditions.\n   */\n  /**\n   * Convert a part to an event and emit it.\n   * Shared between live streaming and replay to ensure consistent event emission.\n   * This guarantees replay reconstructs the exact stream using the same tokenization logic.\n   *\n   * @param workspaceId - Workspace identifier\n   * @param messageId - Message identifier\n   * @param part - The part to emit (text, reasoning, or tool)\n   */\n  private async emitPartAsEvent(\n    workspaceId: WorkspaceId,\n    messageId: string,\n    part: CompletedMessagePart,\n    options?: { replay?: boolean }\n  ): Promise<void> {\n    const timestamp = part.timestamp ?? Date.now();\n    const isReplay = options?.replay === true;\n\n    if (part.type === \"text\") {\n      const tokens = await this.tokenTracker.countTokens(part.text);\n      this.emit(\"stream-delta\", {\n        type: \"stream-delta\",\n        workspaceId: workspaceId as string,\n        messageId,\n        ...(isReplay ? { replay: true } : {}),\n        delta: part.text,\n        tokens,\n        timestamp,\n      });\n    } else if (part.type === \"reasoning\") {\n      const tokens = await this.tokenTracker.countTokens(part.text);\n      this.emit(\"reasoning-delta\", {\n        type: \"reasoning-delta\",\n        workspaceId: workspaceId as string,\n        messageId,\n        ...(isReplay ? { replay: true } : {}),\n        delta: part.text,\n        tokens,\n        timestamp,\n        signature: part.signature,\n      });\n    } else if (part.type === \"dynamic-tool\") {\n      const inputText = JSON.stringify(part.input);\n      const tokens = await this.tokenTracker.countTokens(inputText);\n      this.emit(\"tool-call-start\", {\n        type: \"tool-call-start\",\n        workspaceId: workspaceId as string,\n        messageId,\n        ...(isReplay ? { replay: true } : {}),\n        toolCallId: part.toolCallId,\n        toolName: part.toolName,\n        args: part.input,\n        tokens,\n        timestamp,\n      });\n\n      // If tool has output, emit completion\n      if (part.state === \"output-available\") {\n        this.emit(\"tool-call-end\", {\n          type: \"tool-call-end\",\n          workspaceId: workspaceId as string,\n          messageId,\n          ...(isReplay ? { replay: true } : {}),\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          result: part.output,\n          timestamp: Date.now(),\n        });\n      }\n    }\n  }\n\n  private async appendPartAndEmit(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo,\n    part: CompletedMessagePart,\n    schedulePartialWrite = false\n  ): Promise<void> {\n    // Emit BEFORE adding to streamInfo.parts.\n    //\n    // On reconnect, we call replayStream() which snapshots streamInfo.parts. If we push a part to\n    // streamInfo.parts and then await tokenization/emit, replay can include the \"in-flight\" part\n    // and then the live emit still happens, causing duplicate deltas in the renderer.\n    try {\n      await this.emitPartAsEvent(workspaceId, streamInfo.messageId, part);\n    } finally {\n      // Always persist the part in-memory (and to partial.json, if enabled), even if emit fails.\n      streamInfo.parts.push(part);\n      if (schedulePartialWrite) {\n        void this.schedulePartialWrite(workspaceId, streamInfo);\n      }\n    }\n  }\n\n  private async cancelStreamSafely(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo,\n    abortReason: StreamAbortReason,\n    abandonPartial?: boolean\n  ): Promise<void> {\n    // If stream already completed normally (emitted stream-end), wait for its\n    // finally block to finish before returning. This happens when ensureStreamSafety\n    // is called for a new stream after the previous one finished but before it was\n    // removed from workspaceStreams.\n    // Without this guard, we'd emit stream-abort after stream-end, causing the\n    // frontend to incorrectly flip the message back to partial:true.\n    // We must NOT delete workspaceStreams here  the finally block does that.\n    // If we delete early, the finally block's delete could race with a new stream\n    // being registered and delete the new stream's entry instead.\n    if (streamInfo.state === StreamState.COMPLETED) {\n      await streamInfo.processingPromise;\n      return;\n    }\n\n    try {\n      streamInfo.state = StreamState.STOPPING;\n      // Flush any pending partial write immediately (preserves work on interruption)\n      await this.flushPartialWrite(workspaceId, streamInfo);\n\n      streamInfo.abortController.abort();\n\n      // Unlike checkSoftCancelStream, await cleanup (blocking)\n      await this.cleanupAbortedStream(workspaceId, streamInfo, abortReason, abandonPartial);\n    } catch (error) {\n      log.error(\"Error during stream cancellation:\", error);\n      // Force cleanup even if cancellation fails\n      this.workspaceStreams.delete(workspaceId);\n    }\n  }\n\n  // Checks if a soft interrupt is necessary, and performs one if so\n  // Similar to cancelStreamSafely but performs cleanup without blocking\n  private async checkSoftCancelStream(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo\n  ): Promise<void> {\n    if (!streamInfo.softInterrupt.pending) return;\n    try {\n      streamInfo.state = StreamState.STOPPING;\n\n      // Flush any pending partial write immediately (preserves work on interruption)\n      await this.flushPartialWrite(workspaceId, streamInfo);\n\n      streamInfo.abortController.abort();\n\n      // Return back to the stream loop so we can wait for it to finish before\n      // sending the stream abort event.\n      const { abandonPartial, abortReason } = streamInfo.softInterrupt;\n      void this.cleanupAbortedStream(workspaceId, streamInfo, abortReason, abandonPartial);\n    } catch (error) {\n      log.error(\"Error during stream cancellation:\", error);\n      // Force cleanup even if cancellation fails\n      this.workspaceStreams.delete(workspaceId);\n    }\n  }\n\n  private async cleanupAbortedStream(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo,\n    abortReason: StreamAbortReason,\n    abandonPartial?: boolean\n  ): Promise<void> {\n    // CRITICAL: Wait for processing to fully complete before cleanup\n    // This prevents race conditions where the old stream is still running\n    // while a new stream starts (e.g., old stream writing to partial.json)\n    await streamInfo.processingPromise;\n\n    // For aborts, use our tracked cumulativeUsage directly instead of AI SDK's totalUsage.\n    // cumulativeUsage is updated on each finish-step event (before tool execution),\n    // so it has accurate data even when the stream is interrupted mid-tool-call.\n    // AI SDK's totalUsage may return zeros or stale data when aborted.\n    const duration = Date.now() - streamInfo.startTime;\n    const hasCumulativeUsage = (streamInfo.cumulativeUsage.totalTokens ?? 0) > 0;\n    const usage = hasCumulativeUsage ? streamInfo.cumulativeUsage : undefined;\n\n    // For context window display, use last step's usage (inputTokens = current context size)\n    const contextUsage = streamInfo.lastStepUsage;\n    const contextProviderMetadata = streamInfo.lastStepProviderMetadata;\n\n    // Include provider metadata for accurate cost calculation\n    const providerMetadata = markProviderMetadataCostsIncluded(\n      streamInfo.cumulativeProviderMetadata,\n      streamInfo.initialMetadata?.costsIncluded\n    );\n\n    // Record session usage for aborted streams (mirrors stream-end path)\n    // This ensures tokens consumed before abort are tracked for cost display\n    await this.recordSessionUsage(\n      workspaceId,\n      streamInfo.model,\n      usage,\n      providerMetadata,\n      \"Failed to record session usage on abort\",\n      \"error\",\n      streamInfo\n    );\n\n    // Emit abort event with usage if available\n    this.emitStreamAbort(\n      workspaceId,\n      streamInfo.messageId,\n      { usage, contextUsage, duration, providerMetadata, contextProviderMetadata },\n      abortReason,\n      abandonPartial\n    );\n\n    // Clean up immediately\n    this.workspaceStreams.delete(workspaceId);\n  }\n\n  private async recordSessionUsage(\n    workspaceId: WorkspaceId,\n    model: string,\n    usage: LanguageModelV2Usage | undefined,\n    providerMetadata: Record<string, unknown> | undefined,\n    logMessage: string,\n    logLevel: \"warn\" | \"error\",\n    streamInfo?: Pick<WorkspaceStreamInfo, \"workspaceName\">\n  ): Promise<void> {\n    if (!usage) {\n      return;\n    }\n\n    const messageUsage = createDisplayUsage(usage, model, providerMetadata);\n    if (!messageUsage) {\n      return;\n    }\n\n    const workspaceLog = this.getWorkspaceLogger(workspaceId, streamInfo);\n\n    // Track cost if service is available\n    if (this.costTrackingService) {\n      try {\n        await this.costTrackingService.trackCost(\n          workspaceId as string,\n          normalizeGatewayModel(model),\n          usage,\n          providerMetadata\n        );\n      } catch (error) {\n        workspaceLog.warn(\"Failed to track cost\", { error });\n      }\n    }\n\n    // Record session usage if service is available\n    if (this.sessionUsageService) {\n      try {\n        await this.sessionUsageService.recordUsage(\n          workspaceId as string,\n          normalizeGatewayModel(model),\n          messageUsage\n        );\n      } catch (error) {\n        (logLevel === \"error\" ? workspaceLog.error : workspaceLog.warn)(logMessage, { error });\n      }\n    }\n  }\n\n  private buildStreamRequestConfig(\n    model: LanguageModel,\n    modelString: string,\n    messages: ModelMessage[],\n    system: string,\n    tools?: Record<string, Tool>,\n    providerOptions?: Record<string, unknown>,\n    maxOutputTokens?: number,\n    toolPolicy?: ToolPolicy,\n    hasQueuedMessage?: () => boolean\n  ): StreamRequestConfig {\n    // Determine toolChoice based on toolPolicy.\n    //\n    // If a tool is required (tools object has exactly one tool after applyToolPolicy),\n    // force the model to use it using the AI SDK tool choice shape.\n    let toolChoice: StreamToolChoice;\n    if (tools && toolPolicy) {\n      const hasRequireAction = toolPolicy.some((filter) => filter.action === \"require\");\n      if (hasRequireAction && Object.keys(tools).length === 1) {\n        const requiredToolName = Object.keys(tools)[0];\n        toolChoice = { type: \"tool\", toolName: requiredToolName };\n        log.debug(\"Setting toolChoice to tool\", { toolName: requiredToolName });\n      }\n    }\n\n    // Anthropic Extended Thinking is incompatible with forced tool choice.\n    // If a tool is forced, disable thinking for this request to avoid API errors.\n    let finalProviderOptions = providerOptions;\n    const [provider] = normalizeGatewayModel(modelString).split(\":\", 2);\n    if (\n      toolChoice &&\n      provider === \"anthropic\" &&\n      providerOptions &&\n      typeof providerOptions === \"object\" &&\n      \"anthropic\" in providerOptions\n    ) {\n      const anthropicOptions = (providerOptions as { anthropic?: unknown }).anthropic;\n      if (\n        anthropicOptions &&\n        typeof anthropicOptions === \"object\" &&\n        \"thinking\" in anthropicOptions\n      ) {\n        const { thinking: _thinking, ...rest } = anthropicOptions as Record<string, unknown>;\n        finalProviderOptions = {\n          ...providerOptions,\n          anthropic: rest,\n        };\n      }\n    }\n\n    // Apply cache control for Anthropic models\n    let finalMessages = messages;\n    let finalTools = tools;\n    let finalSystem: string | undefined = system;\n\n    // For Anthropic models, convert system message to a cached message at the start\n    const cachedSystemMessage = createCachedSystemMessage(system, modelString);\n    if (cachedSystemMessage) {\n      // Prepend cached system message and set system parameter to undefined\n      // Note: Must be undefined, not empty string, to avoid Anthropic API error\n      finalMessages = [cachedSystemMessage, ...messages];\n      finalSystem = undefined;\n    }\n\n    // Apply cache control to tools for Anthropic models\n    if (tools) {\n      finalTools = applyCacheControlToTools(tools, modelString);\n    }\n\n    // Use model's max_output_tokens if available and caller didn't specify.\n    // If no metadata exists for the model, omit the parameter entirely to let\n    // the provider use its default (Anthropic requires this but has low defaults).\n    const modelStats = getModelStats(modelString);\n    const effectiveMaxOutputTokens = maxOutputTokens ?? modelStats?.max_output_tokens;\n\n    return {\n      model,\n      messages: finalMessages,\n      system: finalSystem,\n      tools: finalTools,\n      toolChoice,\n      providerOptions: finalProviderOptions,\n      maxOutputTokens: effectiveMaxOutputTokens,\n      hasQueuedMessage,\n    };\n  }\n\n  private createStopWhenCondition(\n    request: Pick<StreamRequestConfig, \"toolChoice\" | \"hasQueuedMessage\">\n  ): ReturnType<typeof stepCountIs> | Array<ReturnType<typeof stepCountIs>> {\n    if (request.toolChoice) {\n      // Required tool calls must stop after a single step to avoid recursive loops.\n      return stepCountIs(1);\n    }\n\n    // Allow effectively unlimited autonomous steps while still yielding quickly\n    // when a queued user message should interrupt at the next step boundary.\n    return [stepCountIs(100000), () => request.hasQueuedMessage?.() ?? false];\n  }\n\n  private createStreamResult(\n    request: StreamRequestConfig,\n    abortController: AbortController,\n    stepTracker?: StepMessageTracker\n  ): Awaited<ReturnType<typeof streamText>> {\n    return streamText({\n      model: request.model,\n      messages: request.messages,\n      system: request.system,\n      abortSignal: abortController.signal,\n      prepareStep: ({ messages: stepMessages }) => {\n        // streamText runs multiple internal LLM calls (steps) when tools are enabled.\n        // Extract base64 images out of tool-result JSON so providers don't treat them as text.\n        const rewritten = extractToolMediaAsUserMessagesFromModelMessages(stepMessages);\n        const effectiveMessages = rewritten === stepMessages ? stepMessages : rewritten;\n        if (stepTracker) {\n          stepTracker.latestMessages = effectiveMessages;\n        }\n        if (rewritten === stepMessages) return undefined;\n        return { messages: rewritten };\n      },\n      tools: request.tools,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n      toolChoice: request.toolChoice as any, // Force tool use when required by policy\n      // Explicit stopWhen configuration keeps continuation policy visible for both\n      // required-tool and autonomous tool-loop flows.\n      stopWhen: this.createStopWhenCondition(request),\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n      providerOptions: request.providerOptions as any, // Pass provider-specific options (thinking/reasoning config)\n      maxOutputTokens: request.maxOutputTokens,\n    });\n  }\n\n  /**\n   * Atomically creates a new stream with all necessary setup\n   */\n  private createStreamAtomically(\n    workspaceId: WorkspaceId,\n    streamToken: StreamToken,\n    runtimeTempDir: string,\n    runtime: Runtime,\n    messages: ModelMessage[],\n    model: LanguageModel,\n    modelString: string,\n    abortController: AbortController,\n    system: string,\n    historySequence: number,\n    messageId: string,\n    tools?: Record<string, Tool>,\n    initialMetadata?: Partial<MuxMetadata>,\n    providerOptions?: Record<string, unknown>,\n    maxOutputTokens?: number,\n    toolPolicy?: ToolPolicy,\n    hasQueuedMessage?: () => boolean,\n    workspaceName?: string,\n    thinkingLevel?: string\n  ): WorkspaceStreamInfo {\n    // abortController is created and linked to the caller-provided abortSignal in startStream().\n\n    const stepTracker: StepMessageTracker = {};\n    const request = this.buildStreamRequestConfig(\n      model,\n      modelString,\n      messages,\n      system,\n      tools,\n      providerOptions,\n      maxOutputTokens,\n      toolPolicy,\n      hasQueuedMessage\n    );\n\n    // Start streaming - this can throw immediately if API key is missing\n    let streamResult;\n    try {\n      streamResult = this.createStreamResult(request, abortController, stepTracker);\n    } catch (error) {\n      // Clean up abort controller if stream creation fails\n      abortController.abort();\n      // Re-throw the error to be caught by startStream\n      throw error;\n    }\n\n    const startTime = Date.now();\n    const streamInfo: WorkspaceStreamInfo = {\n      state: StreamState.STARTING,\n      streamResult,\n      workspaceName,\n      abortController,\n      messageId,\n      token: streamToken,\n      startTime,\n      lastPartTimestamp: startTime,\n      model: modelString,\n      thinkingLevel,\n      initialMetadata,\n      didRetryPreviousResponseIdAtStep: false,\n      stepTracker,\n      currentStepStartIndex: 0,\n      request,\n      historySequence,\n      parts: [], // Initialize empty parts array\n      lastPartialWriteTime: 0, // Initialize to 0 to allow immediate first write\n      partialWritePromise: undefined, // No write in flight initially\n      processingPromise: Promise.resolve(), // Placeholder, overwritten in startStream\n      softInterrupt: { pending: false },\n      runtimeTempDir, // Stream-scoped temp directory for tool outputs\n      runtime, // Runtime for temp directory cleanup\n      // Initialize cumulative tracking for multi-step streams\n      cumulativeUsage: { inputTokens: 0, outputTokens: 0, totalTokens: 0 },\n      cumulativeProviderMetadata: undefined,\n    };\n\n    // Atomically register the stream\n    this.workspaceStreams.set(workspaceId, streamInfo);\n\n    return streamInfo;\n  }\n\n  /**\n   * Complete a tool call by updating its part and emitting tool-call-end event.\n   * CRITICAL: Flushes partial to disk BEFORE emitting event to prevent race conditions\n   * where listeners (e.g., sendQueuedMessages) read stale partial data.\n   */\n  private async completeToolCall(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo,\n    toolCalls: ToolCallMap,\n    toolCallId: string,\n    toolName: string,\n    output: unknown\n  ): Promise<void> {\n    // Find and update the existing tool part\n    const existingPartIndex = streamInfo.parts.findIndex(\n      (p) => p.type === \"dynamic-tool\" && p.toolCallId === toolCallId\n    );\n\n    if (existingPartIndex !== -1) {\n      const existingPart = streamInfo.parts[existingPartIndex];\n      if (existingPart.type === \"dynamic-tool\") {\n        streamInfo.parts[existingPartIndex] = {\n          ...existingPart,\n          state: \"output-available\" as const,\n          output,\n        };\n      }\n    } else {\n      // Fallback: if the matching tool-call part is missing, still persist output so the UI\n      // does not stay stuck in input-available. Input may be missing for provider-native tools.\n      const toolCall = toolCalls.get(toolCallId);\n      streamInfo.parts.push({\n        type: \"dynamic-tool\" as const,\n        toolCallId,\n        toolName,\n        state: \"output-available\" as const,\n        input: toolCall?.input ?? null,\n        output,\n        timestamp: nextPartTimestamp(streamInfo),\n      });\n    }\n\n    // CRITICAL: Flush partial to disk BEFORE emitting event\n    // This ensures listeners (like sendQueuedMessages) see the tool result when they\n    // read partial.json via commitToHistory. Without this await, there's a race condition\n    // where the partial is read before the tool result is written, causing \"amnesia\".\n    await this.flushPartialWrite(workspaceId, streamInfo);\n\n    // Emit tool-call-end event (listeners can now safely read partial)\n    this.emit(\"tool-call-end\", {\n      type: \"tool-call-end\",\n      workspaceId: workspaceId as string,\n      messageId: streamInfo.messageId,\n      toolCallId,\n      toolName,\n      result: output,\n      timestamp: nextPartTimestamp(streamInfo),\n    } as ToolCallEndEvent);\n  }\n\n  private async finishToolCall(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo,\n    toolCalls: ToolCallMap,\n    toolCallId: string,\n    toolName: string,\n    output: unknown\n  ): Promise<void> {\n    await this.completeToolCall(workspaceId, streamInfo, toolCalls, toolCallId, toolName, output);\n    await this.checkSoftCancelStream(workspaceId, streamInfo);\n  }\n\n  private logOrphanToolResult(\n    workspaceLog: Logger,\n    streamInfo: WorkspaceStreamInfo,\n    part: { toolCallId: string; toolName: string },\n    output: unknown,\n    orphanCount: number,\n    trackedToolCallCount: number\n  ): void {\n    if (orphanCount > MAX_ORPHAN_TOOL_RESULT_WARNINGS_PER_STREAM) {\n      return;\n    }\n\n    workspaceLog.warn(\n      \"[streamManager] Received tool-result without matching tool-call map entry; persisting fallback output\",\n      {\n        messageId: streamInfo.messageId,\n        model: streamInfo.model,\n        toolCallId: part.toolCallId,\n        toolName: part.toolName,\n        orphanCount,\n        trackedToolCallCount,\n        isWebSearch: part.toolName === \"web_search\",\n        ...summarizeToolResultForLog(output),\n      }\n    );\n\n    if (orphanCount === MAX_ORPHAN_TOOL_RESULT_WARNINGS_PER_STREAM) {\n      workspaceLog.warn(\n        \"[streamManager] Suppressing additional orphan tool-result warnings for this stream\",\n        {\n          messageId: streamInfo.messageId,\n          model: streamInfo.model,\n          suppressedAfter: orphanCount,\n        }\n      );\n    }\n  }\n\n  /**\n   * Emit nested tool events from PTC code_execution.\n   * These are forwarded to the frontend via the same event channel as regular tool events.\n   * The parentToolCallId field identifies which code_execution call spawned this nested call.\n   *\n   * Also persists nested calls to streamInfo.parts so they survive interruption/reload.\n   */\n  emitNestedToolEvent(\n    workspaceId: string,\n    messageId: string,\n    event: {\n      type: \"tool-call-start\" | \"tool-call-end\";\n      callId: string;\n      toolName: string;\n      args: unknown;\n      parentToolCallId: string;\n      startTime: number;\n      endTime?: number;\n      result?: unknown;\n      error?: string;\n    }\n  ): void {\n    // Persist nested calls to streamInfo.parts for crash/interrupt resilience\n    const streamInfo = this.workspaceStreams.get(workspaceId as WorkspaceId);\n    if (streamInfo) {\n      const parentPartIndex = streamInfo.parts.findIndex(\n        (p): p is CompletedMessagePart & { type: \"dynamic-tool\"; toolCallId: string } =>\n          p.type === \"dynamic-tool\" && \"toolCallId\" in p && p.toolCallId === event.parentToolCallId\n      );\n\n      if (parentPartIndex !== -1) {\n        const parentPart = streamInfo.parts[parentPartIndex] as { nestedCalls?: NestedToolCall[] };\n        const nestedCalls = parentPart.nestedCalls ?? [];\n\n        if (event.type === \"tool-call-start\") {\n          nestedCalls.push({\n            toolCallId: event.callId,\n            toolName: event.toolName,\n            input: event.args,\n            state: \"input-available\",\n            timestamp: event.startTime,\n          });\n        } else if (event.type === \"tool-call-end\") {\n          const idx = nestedCalls.findIndex((n) => n.toolCallId === event.callId);\n          if (idx !== -1) {\n            nestedCalls[idx] = {\n              ...nestedCalls[idx],\n              output: event.result ?? (event.error ? { error: event.error } : undefined),\n              state: \"output-available\",\n            };\n          }\n        }\n\n        parentPart.nestedCalls = nestedCalls;\n\n        // Schedule partial write so nested calls survive crashes\n        void this.schedulePartialWrite(workspaceId as WorkspaceId, streamInfo);\n      }\n    }\n\n    // Emit to frontend\n    if (event.type === \"tool-call-start\") {\n      this.emit(\"tool-call-start\", {\n        type: \"tool-call-start\",\n        workspaceId,\n        messageId,\n        toolCallId: event.callId,\n        toolName: event.toolName,\n        args: event.args,\n        tokens: 0, // Nested calls don't count toward stream tokens\n        timestamp: event.startTime,\n        parentToolCallId: event.parentToolCallId,\n      });\n    } else if (event.type === \"tool-call-end\") {\n      this.emit(\"tool-call-end\", {\n        type: \"tool-call-end\",\n        workspaceId,\n        messageId,\n        toolCallId: event.callId,\n        toolName: event.toolName,\n        result: event.result ?? (event.error ? { error: event.error } : undefined),\n        timestamp: event.endTime!,\n        parentToolCallId: event.parentToolCallId,\n      });\n    }\n    // Console events are not streamed (appear in final result only)\n  }\n\n  private getStreamMode(initialMetadata?: Partial<MuxMetadata>): \"plan\" | \"exec\" | undefined {\n    const rawMode = initialMetadata?.mode;\n    // Stats schema only accepts \"plan\" | \"exec\".\n    return rawMode === \"plan\" || rawMode === \"exec\" ? rawMode : undefined;\n  }\n\n  private emitStreamStart(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo,\n    historySequence: number,\n    options?: { replay?: boolean }\n  ): void {\n    const streamStartAgentId = streamInfo.initialMetadata?.agentId;\n    const streamStartMode = this.getStreamMode(streamInfo.initialMetadata);\n    const canonicalModel = normalizeGatewayModel(streamInfo.model);\n    const routedThroughGateway =\n      streamInfo.initialMetadata?.routedThroughGateway ??\n      streamInfo.model.startsWith(\"mux-gateway:\");\n\n    this.emit(\"stream-start\", {\n      type: \"stream-start\",\n      workspaceId: workspaceId as string,\n      messageId: streamInfo.messageId,\n      ...(options?.replay && { replay: true }),\n      model: canonicalModel,\n      routedThroughGateway,\n      historySequence,\n      startTime: streamInfo.startTime,\n      ...(streamStartAgentId && { agentId: streamStartAgentId }),\n      ...(streamStartMode && { mode: streamStartMode }),\n      ...(streamInfo.thinkingLevel && { thinkingLevel: streamInfo.thinkingLevel }),\n    } as StreamStartEvent);\n  }\n\n  private emitStreamAbort(\n    workspaceId: WorkspaceId,\n    messageId: string,\n    metadata: Record<string, unknown>,\n    abortReason: StreamAbortReason,\n    abandonPartial?: boolean\n  ): void {\n    this.emit(\"stream-abort\", {\n      type: \"stream-abort\",\n      workspaceId: workspaceId as string,\n      messageId,\n      abortReason,\n      metadata,\n      abandonPartial,\n    });\n  }\n\n  /**\n   * Processes a stream with guaranteed cleanup, regardless of success or failure\n   */\n  private async processStreamWithCleanup(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo,\n    historySequence: number\n  ): Promise<void> {\n    this.mcpServerManager?.acquireLease(workspaceId as string);\n\n    try {\n      // Update state to streaming\n      streamInfo.state = StreamState.STREAMING;\n\n      // Emit stream start event (include mode from initialMetadata if available)\n      this.emitStreamStart(workspaceId, streamInfo, historySequence);\n\n      // Initialize token tracker for this model\n      await this.tokenTracker.setModel(streamInfo.model);\n\n      let didRetryPreviousResponseId = false;\n      const workspaceLog = this.getWorkspaceLogger(workspaceId, streamInfo);\n      let orphanToolResultCount = 0;\n\n      while (true) {\n        // Use fullStream to capture all events including tool calls\n        const toolCalls: ToolCallMap = new Map();\n\n        try {\n          for await (const part of streamInfo.streamResult.fullStream) {\n            // Check if stream was cancelled BEFORE processing any parts\n            // This improves interruption responsiveness by catching aborts earlier\n            if (streamInfo.abortController.signal.aborted) {\n              break;\n            }\n\n            // Log all stream parts to debug reasoning (commented out - too spammy)\n            // console.log(\"[DEBUG streamManager]: Stream part\", {\n            //   type: part.type,\n            //   hasText: \"text\" in part,\n            //   preview: \"text\" in part ? (part as StreamPartWithText).text?.substring(0, 50) : undefined,\n            // });\n\n            switch (part.type) {\n              case \"start-step\": {\n                streamInfo.currentStepStartIndex = streamInfo.parts.length;\n                break;\n              }\n\n              case \"text-delta\": {\n                // Providers/SDKs may stream text deltas under different keys.\n                const textDeltaPart = part as {\n                  text?: unknown;\n                  delta?: unknown;\n                  textDelta?: unknown;\n                };\n\n                const deltaText =\n                  typeof textDeltaPart.text === \"string\"\n                    ? textDeltaPart.text\n                    : typeof textDeltaPart.delta === \"string\"\n                      ? textDeltaPart.delta\n                      : typeof textDeltaPart.textDelta === \"string\"\n                        ? textDeltaPart.textDelta\n                        : \"\";\n\n                if (deltaText.length === 0) {\n                  if (\n                    textDeltaPart.text !== undefined ||\n                    textDeltaPart.delta !== undefined ||\n                    textDeltaPart.textDelta !== undefined\n                  ) {\n                    log.debug(\"[streamManager] Ignoring non-string text-delta payload\", {\n                      workspaceId,\n                      model: streamInfo.model,\n                      textType: typeof textDeltaPart.text,\n                      deltaType: typeof textDeltaPart.delta,\n                      textDeltaType: typeof textDeltaPart.textDelta,\n                    });\n                  }\n                  break;\n                }\n\n                // Append each delta as a new part (merging happens at display time)\n                const textPart = {\n                  type: \"text\" as const,\n                  text: deltaText,\n                  timestamp: nextPartTimestamp(streamInfo),\n                };\n                await this.appendPartAndEmit(workspaceId, streamInfo, textPart, true);\n                break;\n              }\n\n              default: {\n                if (await this.emitToolCallDeltaIfPresent(workspaceId, streamInfo, part)) {\n                  break;\n                }\n                break;\n              }\n\n              case \"reasoning-delta\": {\n                // Both Anthropic and OpenAI use reasoning-delta for streaming reasoning content\n                const reasoningPart = part as ReasoningDeltaPart;\n                const delta = reasoningPart.text ?? reasoningPart.delta ?? \"\";\n                const signature = reasoningPart.providerMetadata?.anthropic?.signature;\n\n                // Signature deltas come separately with empty text - attach to last reasoning part\n                if (signature && !delta) {\n                  const lastPart = streamInfo.parts.at(-1);\n                  if (lastPart?.type === \"reasoning\") {\n                    lastPart.signature = signature;\n                    // Also set providerOptions for SDK compatibility when converting to ModelMessages\n                    lastPart.providerOptions = { anthropic: { signature } };\n                    // Emit signature update event\n                    this.emit(\"reasoning-delta\", {\n                      type: \"reasoning-delta\",\n                      workspaceId: workspaceId as string,\n                      messageId: streamInfo.messageId,\n                      delta: \"\",\n                      tokens: 0,\n                      timestamp: nextPartTimestamp(streamInfo),\n                      signature,\n                    });\n                    void this.schedulePartialWrite(workspaceId, streamInfo);\n                  }\n                  break;\n                }\n\n                // Append each delta as a new part (merging happens at display time)\n                // Include providerOptions for SDK compatibility when converting to ModelMessages\n                const newPart = {\n                  type: \"reasoning\" as const,\n                  text: delta,\n                  timestamp: nextPartTimestamp(streamInfo),\n                  signature, // May be undefined, will be filled by subsequent signature delta\n                  providerOptions: signature ? { anthropic: { signature } } : undefined,\n                };\n                await this.appendPartAndEmit(workspaceId, streamInfo, newPart, true);\n                break;\n              }\n\n              case \"reasoning-end\": {\n                // Reasoning-end is just a signal - no state to update\n                this.emit(\"reasoning-end\", {\n                  type: \"reasoning-end\",\n                  workspaceId: workspaceId as string,\n                  messageId: streamInfo.messageId,\n                });\n                await this.checkSoftCancelStream(workspaceId, streamInfo);\n                break;\n              }\n\n              case \"tool-call\": {\n                // Tool call started - store in map for later lookup\n                toolCalls.set(part.toolCallId, {\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                });\n\n                // Note: Tool availability is handled by the SDK, which emits tool-error events\n                // for unavailable tools. No need to check here.\n\n                // IMPORTANT: Add tool part to streamInfo.parts immediately (not just on completion)\n                // This ensures in-progress tool calls are saved to partial.json if stream is interrupted\n                const toolPart = {\n                  type: \"dynamic-tool\" as const,\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  state: \"input-available\" as const,\n                  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                  input: part.input,\n                  timestamp: nextPartTimestamp(streamInfo),\n                };\n\n                // Emit using shared logic (ensures replay consistency)\n                const inputText = JSON.stringify(part.input);\n                log.debug(\n                  `[StreamManager] tool-call: toolName=${part.toolName}, input length=${inputText.length}`\n                );\n                await this.appendPartAndEmit(workspaceId, streamInfo, toolPart);\n\n                // CRITICAL: Flush partial immediately for ask_user_question\n                // This tool blocks waiting for user input, and if the app restarts during\n                // that wait, the partial must be persisted so it can be restored.\n                // Without this, the throttled write might not complete before app shutdown.\n                if (part.toolName === \"ask_user_question\") {\n                  await this.flushPartialWrite(workspaceId, streamInfo);\n                }\n                break;\n              }\n\n              case \"tool-result\": {\n                const toolResultPart = part as {\n                  toolCallId: string;\n                  toolName: string;\n                  output: unknown;\n                };\n\n                // Strip encrypted content from web search results before storing\n                const strippedOutput = stripInternalToolResultFields(\n                  stripEncryptedContent(toolResultPart.output)\n                );\n\n                // Tool call completed successfully\n                const toolCall = toolCalls.get(toolResultPart.toolCallId);\n                if (toolCall) {\n                  toolCall.output = strippedOutput;\n                } else {\n                  orphanToolResultCount += 1;\n                  this.logOrphanToolResult(\n                    workspaceLog,\n                    streamInfo,\n                    {\n                      toolCallId: toolResultPart.toolCallId,\n                      toolName: toolResultPart.toolName,\n                    },\n                    strippedOutput,\n                    orphanToolResultCount,\n                    toolCalls.size\n                  );\n                }\n\n                // Use shared completion logic (await to ensure partial is flushed before event)\n                await this.finishToolCall(\n                  workspaceId,\n                  streamInfo,\n                  toolCalls,\n                  toolResultPart.toolCallId,\n                  toolResultPart.toolName,\n                  strippedOutput\n                );\n                break;\n              }\n\n              // Handle tool-error parts from the stream (AI SDK 5.0+)\n              // These are emitted when tool execution fails (e.g., tool doesn't exist)\n              case \"tool-error\": {\n                const toolErrorPart = part as {\n                  toolCallId: string;\n                  toolName: string;\n                  error: unknown;\n                };\n\n                const logLevel = streamInfo.abortController.signal.aborted ? log.debug : log.error;\n                logLevel(`Tool execution error for '${toolErrorPart.toolName}'`, {\n                  toolCallId: toolErrorPart.toolCallId,\n                  error: toolErrorPart.error,\n                });\n\n                // Format error output\n                const errorOutput = {\n                  success: false,\n                  error:\n                    typeof toolErrorPart.error === \"string\"\n                      ? toolErrorPart.error\n                      : toolErrorPart.error instanceof Error\n                        ? toolErrorPart.error.message\n                        : JSON.stringify(toolErrorPart.error),\n                };\n\n                // Use shared completion logic (await to ensure partial is flushed before event)\n                await this.finishToolCall(\n                  workspaceId,\n                  streamInfo,\n                  toolCalls,\n                  toolErrorPart.toolCallId,\n                  toolErrorPart.toolName,\n                  errorOutput\n                );\n                break;\n              }\n\n              // Handle error parts from the stream (e.g., OpenAI context_length_exceeded)\n              case \"error\": {\n                // Capture the error and immediately throw to trigger error handling\n                // Error parts are structured errors from the AI SDK\n                const errorPart = part as { error: unknown };\n\n                // Try to extract error message from various possible structures\n                let errorMessage: string | undefined;\n\n                if (errorPart.error instanceof Error) {\n                  throw errorPart.error;\n                } else if (typeof errorPart.error === \"object\" && errorPart.error !== null) {\n                  const errorObj = errorPart.error as Record<string, unknown>;\n\n                  // Check for nested error object with message (OpenAI format)\n                  if (\n                    errorObj.error &&\n                    typeof errorObj.error === \"object\" &&\n                    errorObj.error !== null\n                  ) {\n                    const nestedError = errorObj.error as Record<string, unknown>;\n                    if (typeof nestedError.message === \"string\") {\n                      errorMessage = nestedError.message;\n                    }\n                  }\n\n                  // Fallback to direct message property\n                  errorMessage ??=\n                    typeof errorObj.message === \"string\" ? errorObj.message : undefined;\n\n                  // Last resort: stringify the error\n                  errorMessage ??= JSON.stringify(errorObj);\n\n                  const error = new Error(errorMessage);\n                  // Preserve original error as cause for debugging\n                  Object.assign(error, { cause: errorObj });\n                  throw error;\n                } else {\n                  throw new Error(String(errorPart.error));\n                }\n              }\n\n              // Handle other event types as needed\n              case \"start\":\n              case \"text-start\":\n              case \"finish\":\n                // These events can be logged or handled if needed\n                break;\n\n              case \"finish-step\": {\n                // Emit usage-delta event with usage from this step\n                const finishStepPart = part as {\n                  type: \"finish-step\";\n                  usage: LanguageModelV2Usage;\n                  providerMetadata?: Record<string, unknown>;\n                };\n\n                // Update cumulative totals for this stream\n                streamInfo.cumulativeUsage = addUsage(\n                  streamInfo.cumulativeUsage,\n                  finishStepPart.usage\n                );\n                streamInfo.cumulativeProviderMetadata = accumulateProviderMetadata(\n                  streamInfo.cumulativeProviderMetadata,\n                  finishStepPart.providerMetadata\n                );\n\n                // Track last step's data for context window display\n                streamInfo.lastStepUsage = finishStepPart.usage;\n                streamInfo.lastStepProviderMetadata = finishStepPart.providerMetadata;\n\n                const usageEvent: UsageDeltaEvent = {\n                  type: \"usage-delta\",\n                  workspaceId: workspaceId as string,\n                  messageId: streamInfo.messageId,\n                  // Step-level (for context window display)\n                  usage: finishStepPart.usage,\n                  providerMetadata: finishStepPart.providerMetadata,\n                  // Cumulative (for live cost display)\n                  cumulativeUsage: streamInfo.cumulativeUsage,\n                  cumulativeProviderMetadata: streamInfo.cumulativeProviderMetadata,\n                };\n                streamInfo.currentStepStartIndex = streamInfo.parts.length;\n                this.emit(\"usage-delta\", usageEvent);\n                await this.checkSoftCancelStream(workspaceId, streamInfo);\n                break;\n              }\n\n              case \"text-end\": {\n                await this.checkSoftCancelStream(workspaceId, streamInfo);\n                break;\n              }\n            }\n          }\n\n          // No need to save remaining text - text-delta handler already maintains parts array\n          // (Removed duplicate push that was causing double text parts)\n\n          // Flush final state to partial.json for crash resilience\n          // This happens regardless of abort status to ensure the final state is persisted to disk\n          // On abort: second flush after cancelStreamSafely, ensures all streamed content is saved\n          // On normal completion: provides crash resilience before AIService writes to chat.jsonl\n          await this.flushPartialWrite(workspaceId, streamInfo);\n\n          // Check if stream completed successfully\n          if (!streamInfo.abortController.signal.aborted) {\n            // Get all metadata from stream result in one call\n            // - totalUsage: sum of all steps (for cost calculation)\n            // - contextUsage: last step only (for context window display)\n            // - contextProviderMetadata: last step (for context window cache tokens)\n            // Falls back to tracked values when step retries invalidate totalUsage\n            // or streamResult metadata fails/times out.\n            const streamMeta = await this.getStreamMetadata(streamInfo);\n            const totalUsage = this.resolveTotalUsageForStreamEnd(\n              streamInfo,\n              streamMeta.totalUsage\n            );\n            const contextUsage = streamMeta.contextUsage ?? streamInfo.lastStepUsage;\n            const contextProviderMetadata =\n              streamMeta.contextProviderMetadata ?? streamInfo.lastStepProviderMetadata;\n            const duration = streamMeta.duration;\n            // Aggregated provider metadata across all steps (for cost calculation with cache tokens)\n            const providerMetadata = markProviderMetadataCostsIncluded(\n              await this.getAggregatedProviderMetadata(streamInfo),\n              streamInfo.initialMetadata?.costsIncluded\n            );\n            const canonicalModel = normalizeGatewayModel(streamInfo.model);\n            const routedThroughGateway =\n              streamInfo.initialMetadata?.routedThroughGateway ??\n              streamInfo.model.startsWith(\"mux-gateway:\");\n\n            // Emit stream end event with parts preserved in temporal order\n            const streamEndEvent: StreamEndEvent = {\n              type: \"stream-end\",\n              workspaceId: workspaceId as string,\n              messageId: streamInfo.messageId,\n              metadata: {\n                ...streamInfo.initialMetadata, // AIService-provided metadata (systemMessageTokens, etc)\n                model: canonicalModel,\n                routedThroughGateway,\n                ...(streamInfo.thinkingLevel && {\n                  thinkingLevel: streamInfo.thinkingLevel as ThinkingLevel,\n                }),\n                usage: totalUsage, // Total across all steps (for cost calculation)\n                contextUsage, // Last step only (for context window display)\n                providerMetadata, // Aggregated (for cost calculation)\n                contextProviderMetadata, // Last step (for context window display)\n                duration,\n              },\n              parts: streamInfo.parts, // Parts array with temporal ordering (includes reasoning)\n            };\n\n            // Update history with final message BEFORE emitting stream-end\n            // This prevents a race condition where compaction (triggered by stream-end)\n            // clears history while updateHistory is still running, causing old messages\n            // to be written back after compaction completes.\n            if (streamInfo.parts && streamInfo.parts.length > 0) {\n              const finalAssistantMessage: MuxMessage = {\n                id: streamInfo.messageId,\n                role: \"assistant\",\n                metadata: {\n                  ...streamEndEvent.metadata,\n                  historySequence: streamInfo.historySequence,\n                },\n                parts: streamInfo.parts,\n              };\n\n              // CRITICAL: Delete partial.json before updating chat.jsonl\n              // On successful completion, partial.json becomes stale and must be removed\n              await this.partialService.deletePartial(workspaceId as string);\n\n              // Update the placeholder message in chat.jsonl with final content\n              await this.historyService.updateHistory(workspaceId as string, finalAssistantMessage);\n\n              // Update cumulative session usage (if service is available)\n              // Wrapped in try-catch: usage recording is non-critical and shouldn't block stream completion\n              await this.recordSessionUsage(\n                workspaceId,\n                streamInfo.model,\n                totalUsage,\n                providerMetadata,\n                \"Failed to record session usage (stream completion unaffected)\",\n                \"warn\",\n                streamInfo\n              );\n            }\n\n            // Mark as completed right before emitting stream-end.\n            // This must happen AFTER async I/O (deletePartial, updateHistory) completes.\n            // If we set COMPLETED earlier, isStreaming() returns false during cleanup,\n            // allowing new messages (e.g., force-compaction) to bypass queuing and write\n            // to history before stream-end fires - causing compaction to use wrong parts.\n            streamInfo.state = StreamState.COMPLETED;\n\n            // Emit stream-end AFTER history is updated to prevent race with compaction\n            // Compaction handler listens to this event and clears history - if we emit\n            // before updateHistory completes, compaction can clear the file and then\n            // updateHistory writes stale data back.\n            this.emit(\"stream-end\", streamEndEvent);\n          }\n          break;\n        } catch (error) {\n          let handledError: unknown = error;\n          let retried = false;\n          try {\n            retried = await this.retryStreamWithoutPreviousResponseId(\n              workspaceId,\n              streamInfo,\n              error,\n              didRetryPreviousResponseId\n            );\n          } catch (retryError) {\n            handledError = retryError;\n          }\n\n          if (retried) {\n            didRetryPreviousResponseId = true;\n            continue;\n          }\n\n          await this.handleStreamFailure(workspaceId, streamInfo, handledError);\n          break;\n        }\n      }\n    } catch (error) {\n      await this.handleStreamFailure(workspaceId, streamInfo, error);\n    } finally {\n      this.mcpServerManager?.releaseLease(workspaceId as string);\n\n      // Guaranteed cleanup in all code paths\n      // Clear any pending timers to prevent keeping process alive\n      if (streamInfo.partialWriteTimer) {\n        clearTimeout(streamInfo.partialWriteTimer);\n        streamInfo.partialWriteTimer = undefined;\n      }\n\n      streamInfo.unlinkAbortSignal?.();\n      streamInfo.unlinkAbortSignal = undefined;\n\n      // Clean up stream temp directory using runtime (fire-and-forget)\n      // Don't block stream completion waiting for directory deletion\n      // This is especially important for SSH where rm -rf can take 500ms-2s\n      if (streamInfo.runtimeTempDir) {\n        this.cleanupStreamTempDir(streamInfo.runtime, streamInfo.runtimeTempDir);\n      }\n\n      this.workspaceStreams.delete(workspaceId);\n    }\n  }\n\n  /**\n   * Persist error state and emit error events for failed streams.\n   */\n  private async handleStreamFailure(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo,\n    error: unknown\n  ): Promise<void> {\n    streamInfo.state = StreamState.ERROR;\n\n    const workspaceLog = this.getWorkspaceLogger(workspaceId, streamInfo);\n\n    // Log the actual error for debugging\n    workspaceLog.error(\"Stream processing error:\", error);\n\n    // Record lost previousResponseId so future requests can filter it out\n    this.recordLostResponseIdIfApplicable(workspaceId, error, streamInfo, workspaceLog);\n\n    const errorPayload = this.buildStreamErrorPayload(streamInfo, error);\n    await this.persistStreamError(workspaceId, streamInfo, errorPayload);\n  }\n\n  private buildStreamErrorPayload(\n    streamInfo: WorkspaceStreamInfo,\n    error: unknown\n  ): StreamErrorPayload & { errorType: StreamErrorType } {\n    // Extract error message (errors thrown from 'error' parts already have the correct message)\n    // Apply prefix stripping to remove noisy \"undefined: \" prefixes from provider errors\n    let errorMessage: string = stripNoisyErrorPrefix(\n      error instanceof Error ? error.message : String(error)\n    );\n    let actualError: unknown = error;\n\n    // For categorization, use the cause if available (preserves the original error structure)\n    if (error instanceof Error && error.cause) {\n      actualError = error.cause;\n    }\n\n    let errorType = this.categorizeError(actualError);\n\n    // Enhance previous-response and model-not-found error messages\n\n    const previousResponseId = this.extractPreviousResponseIdFromError(actualError);\n    if (previousResponseId) {\n      errorMessage = \"OpenAI lost the previous response state while streaming. Retry to continue.\";\n    }\n    if (errorType === \"model_not_found\") {\n      // Extract model name from model string (e.g., \"anthropic:sonnet-1m\" -> \"sonnet-1m\")\n      const [, modelName] = streamInfo.model.split(\":\");\n      errorMessage = `Model '${modelName || streamInfo.model}' does not exist or is not available. Please check your model selection.`;\n    }\n\n    // Normalize Anthropic overload errors (HTTP 529 / overloaded_error) into a stable,\n    // user-friendly message. Keep errorType = server_error so the frontend's auto-retry\n    // behavior remains unchanged.\n    const canonicalModel = normalizeGatewayModel(streamInfo.model);\n    const isAnthropic = canonicalModel.startsWith(\"anthropic:\");\n\n    const hasErrorProperty = (data: unknown): data is { error: { type?: string } } => {\n      return (\n        typeof data === \"object\" &&\n        data !== null &&\n        \"error\" in data &&\n        typeof data.error === \"object\" &&\n        data.error !== null\n      );\n    };\n\n    const isOverloadedApiCallError = (apiError: APICallError): boolean => {\n      return (\n        apiError.statusCode === 529 ||\n        (hasErrorProperty(apiError.data) && apiError.data.error.type === \"overloaded_error\")\n      );\n    };\n\n    const isAnthropicOverloaded =\n      isAnthropic &&\n      ((APICallError.isInstance(actualError) && isOverloadedApiCallError(actualError)) ||\n        (RetryError.isInstance(actualError) &&\n          actualError.lastError &&\n          APICallError.isInstance(actualError.lastError) &&\n          isOverloadedApiCallError(actualError.lastError)));\n\n    if (isAnthropicOverloaded) {\n      errorMessage = \"Anthropic is temporarily overloaded (HTTP 529). Please try again later.\";\n      errorType = \"server_error\";\n    }\n\n    const muxGatewayUnauthorized =\n      streamInfo.model.startsWith(\"mux-gateway:\") &&\n      ((APICallError.isInstance(actualError) && actualError.statusCode === 401) ||\n        (RetryError.isInstance(actualError) &&\n          actualError.lastError &&\n          APICallError.isInstance(actualError.lastError) &&\n          actualError.lastError.statusCode === 401));\n\n    if (muxGatewayUnauthorized) {\n      // Friendly normalization for expired mux-gateway sessions.\n      errorMessage = MUX_GATEWAY_SESSION_EXPIRED_MESSAGE;\n    }\n    errorType = coerceStreamErrorTypeForMessage(errorType, errorMessage);\n\n    return {\n      messageId: streamInfo.messageId,\n      error: errorMessage,\n      errorType,\n    };\n  }\n\n  /**\n   * Write error metadata to partial.json and emit the corresponding error event.\n   */\n  private async persistStreamError(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo,\n    payload: StreamErrorPayload & { errorType: StreamErrorType }\n  ): Promise<void> {\n    const canonicalModel = normalizeGatewayModel(streamInfo.model);\n    const routedThroughGateway =\n      streamInfo.initialMetadata?.routedThroughGateway ??\n      streamInfo.model.startsWith(\"mux-gateway:\");\n\n    const errorPartialMessage: MuxMessage = {\n      id: payload.messageId,\n      role: \"assistant\",\n      metadata: {\n        historySequence: streamInfo.historySequence,\n        timestamp: streamInfo.startTime,\n        ...streamInfo.initialMetadata,\n        model: canonicalModel,\n        routedThroughGateway,\n        ...(streamInfo.thinkingLevel && {\n          thinkingLevel: streamInfo.thinkingLevel as ThinkingLevel,\n        }),\n        partial: true,\n        error: payload.error,\n        errorType: payload.errorType,\n      },\n      parts: streamInfo.parts,\n    };\n\n    // Wait for any in-flight partial write to complete before writing error state.\n    // This prevents race conditions where the error write and a throttled flush\n    // write at the same time, causing inconsistent partial.json state.\n    await this.awaitPendingPartialWrite(streamInfo);\n\n    // Write error state to disk - await to ensure consistent state before any resume.\n    await this.partialService.writePartial(workspaceId as string, errorPartialMessage);\n\n    // Emit error event.\n    this.emit(\"error\", createErrorEvent(workspaceId as string, payload));\n  }\n\n  private getOpenAIPreviousResponseId(\n    providerOptions?: Record<string, unknown>\n  ): string | undefined {\n    if (!providerOptions || typeof providerOptions !== \"object\" || !(\"openai\" in providerOptions)) {\n      return undefined;\n    }\n\n    const openaiOptions = providerOptions.openai;\n    if (!openaiOptions || typeof openaiOptions !== \"object\") {\n      return undefined;\n    }\n\n    const previousResponseId = (openaiOptions as Record<string, unknown>).previousResponseId;\n    return typeof previousResponseId === \"string\" ? previousResponseId : undefined;\n  }\n\n  private clearOpenAIPreviousResponseId(\n    providerOptions?: Record<string, unknown>\n  ): Record<string, unknown> | undefined {\n    if (!providerOptions || typeof providerOptions !== \"object\" || !(\"openai\" in providerOptions)) {\n      return providerOptions;\n    }\n\n    const openaiOptions = providerOptions.openai;\n    if (!openaiOptions || typeof openaiOptions !== \"object\") {\n      return providerOptions;\n    }\n\n    if (!(\"previousResponseId\" in openaiOptions)) {\n      return providerOptions;\n    }\n\n    const { previousResponseId: _prev, ...rest } = openaiOptions as Record<string, unknown>;\n    return {\n      ...providerOptions,\n      openai: rest,\n    };\n  }\n\n  private async resetStreamStateForRetry(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo,\n    options?: { preserveParts?: boolean; preserveUsage?: boolean; workspaceLog?: Logger }\n  ): Promise<void> {\n    const preserveParts = options?.preserveParts ?? false;\n    const preserveUsage = options?.preserveUsage ?? false;\n\n    if (streamInfo.partialWriteTimer) {\n      clearTimeout(streamInfo.partialWriteTimer);\n      streamInfo.partialWriteTimer = undefined;\n    }\n\n    await this.awaitPendingPartialWrite(streamInfo);\n    streamInfo.partialWritePromise = undefined;\n\n    if (!preserveParts) {\n      streamInfo.parts = [];\n    }\n    streamInfo.lastPartialWriteTime = 0;\n\n    if (!preserveUsage) {\n      streamInfo.cumulativeUsage = { inputTokens: 0, outputTokens: 0, totalTokens: 0 };\n      streamInfo.cumulativeProviderMetadata = undefined;\n      streamInfo.lastStepUsage = undefined;\n      streamInfo.lastStepProviderMetadata = undefined;\n    }\n\n    if (!preserveParts) {\n      try {\n        await this.partialService.deletePartial(workspaceId as string);\n      } catch (deleteError) {\n        const logger = options?.workspaceLog ?? this.getWorkspaceLogger(workspaceId, streamInfo);\n        logger.warn(\"Failed to clear partial state before retry\", { error: deleteError });\n      }\n    }\n  }\n\n  private async retryStreamWithoutPreviousResponseId(\n    workspaceId: WorkspaceId,\n    streamInfo: WorkspaceStreamInfo,\n    error: unknown,\n    hasRetried: boolean\n  ): Promise<boolean> {\n    if (hasRetried) {\n      return false;\n    }\n\n    if (streamInfo.abortController.signal.aborted || streamInfo.softInterrupt.pending) {\n      return false;\n    }\n\n    const hasParts = streamInfo.parts.length > 0;\n    const currentStepStartIndex = streamInfo.currentStepStartIndex;\n    // If the current step already emitted parts, retrying would duplicate output/tool calls.\n    if (hasParts && currentStepStartIndex !== streamInfo.parts.length) {\n      return false;\n    }\n\n    const responseId = this.extractPreviousResponseIdFromError(error);\n    if (!responseId) {\n      return false;\n    }\n\n    const errorCode = this.extractErrorCode(error);\n    const statusCode = this.extractStatusCode(error);\n    // Retry if: we have the specific error code, OR a likely status code,\n    // OR we successfully extracted a response ID from the error message\n    // (the message match is strong evidence this is a \"not found\" error regardless of status code)\n    const shouldRetry =\n      errorCode === \"previous_response_not_found\" ||\n      statusCode === 404 ||\n      statusCode === 500 ||\n      statusCode === 400;\n    if (!shouldRetry) {\n      return false;\n    }\n\n    const previousResponseId = this.getOpenAIPreviousResponseId(streamInfo.request.providerOptions);\n    if (!previousResponseId || previousResponseId !== responseId) {\n      return false;\n    }\n\n    const stepMessages = streamInfo.stepTracker.latestMessages;\n    if (hasParts && !stepMessages) {\n      return false;\n    }\n\n    const providerOptions = this.clearOpenAIPreviousResponseId(streamInfo.request.providerOptions);\n    if (providerOptions === streamInfo.request.providerOptions) {\n      return false;\n    }\n\n    const workspaceLog = this.getWorkspaceLogger(workspaceId, streamInfo);\n    this.recordLostResponseIdIfApplicable(workspaceId, error, streamInfo, workspaceLog);\n\n    // Step-boundary retries restart the SDK stream, so totalUsage only reflects\n    // the retried step. Track this to prefer cumulativeUsage at stream end.\n    if (hasParts) {\n      streamInfo.didRetryPreviousResponseIdAtStep = true;\n    }\n\n    workspaceLog.info(\"Retrying stream without invalid previousResponseId\", {\n      messageId: streamInfo.messageId,\n      model: streamInfo.model,\n      retryScope: hasParts ? \"step\" : \"stream\",\n      previousResponseId,\n      errorCode,\n      statusCode,\n    });\n\n    await this.resetStreamStateForRetry(workspaceId, streamInfo, {\n      preserveParts: hasParts,\n      preserveUsage: hasParts,\n      workspaceLog,\n    });\n\n    streamInfo.currentStepStartIndex = streamInfo.parts.length;\n    streamInfo.request = {\n      ...streamInfo.request,\n      ...(stepMessages ? { messages: stepMessages } : {}),\n      providerOptions,\n    };\n    streamInfo.streamResult = this.createStreamResult(\n      streamInfo.request,\n      streamInfo.abortController,\n      streamInfo.stepTracker\n    );\n\n    return true;\n  }\n\n  /**\n   * Converts errors to strongly-typed SendMessageError\n   */\n  private convertToSendMessageError(error: unknown): SendMessageError {\n    // Check for specific AI SDK errors using type guards\n    if (LoadAPIKeyError.isInstance(error)) {\n      return {\n        type: \"api_key_not_found\",\n        provider: \"anthropic\", // We can infer this from LoadAPIKeyError context\n      };\n    }\n\n    // TODO: Add more specific error types as needed\n    // if (APICallError.isInstance(error)) {\n    //   if (error.statusCode === 401) return { type: \"authentication\", ... };\n    //   if (error.statusCode === 429) return { type: \"rate_limit\", ... };\n    // }\n    // if (RetryError.isInstance(error)) {\n    //   return { type: \"retry_failed\", ... };\n    // }\n\n    // Fallback for unknown errors\n    const message = error instanceof Error ? error.message : String(error);\n    return { type: \"unknown\", raw: message };\n  }\n\n  /**\n   * Categorizes errors for better error handling (used for event emission)\n   */\n  private categorizeError(error: unknown): StreamErrorType {\n    // Use AI SDK error type guards first\n    if (LoadAPIKeyError.isInstance(error)) {\n      return \"authentication\";\n    }\n    if (APICallError.isInstance(error)) {\n      if (error.statusCode === 401) return \"authentication\";\n      // 402 (Payment Required) is used by mux gateway for billing/credits issues\n      // (e.g. \"Insufficient balance. Please add credits to continue.\").\n      // Treat as non-retryable quota; 429 (rate_limit) covers RPM/time-based throttling.\n      if (error.statusCode === 402) return \"quota\";\n      if (error.statusCode === 429) return \"rate_limit\";\n      if (error.statusCode && error.statusCode >= 500) return \"server_error\";\n\n      // Check for model_not_found errors (OpenAI and Anthropic)\n      // Type guard for error data structure\n      const hasErrorProperty = (\n        data: unknown\n      ): data is { error: { code?: string; type?: string } } => {\n        return (\n          typeof data === \"object\" &&\n          data !== null &&\n          \"error\" in data &&\n          typeof data.error === \"object\" &&\n          data.error !== null\n        );\n      };\n\n      // OpenAI: 400 with error.code === 'model_not_found'\n      const isOpenAIModelError =\n        error.statusCode === 400 &&\n        hasErrorProperty(error.data) &&\n        error.data.error.code === \"model_not_found\";\n\n      // Anthropic: 404 with error.type === 'not_found_error'\n      const isAnthropicModelError =\n        error.statusCode === 404 &&\n        hasErrorProperty(error.data) &&\n        error.data.error.type === \"not_found_error\";\n\n      if (isOpenAIModelError || isAnthropicModelError) {\n        return \"model_not_found\";\n      }\n\n      // Check for Anthropic context exceeded errors\n      if (error.message.includes(\"prompt is too long:\")) {\n        return \"context_exceeded\";\n      }\n\n      return \"api\";\n    }\n    if (RetryError.isInstance(error)) {\n      // The AI SDK wraps the underlying error(s) in RetryError when it exhausts its internal retries.\n      // If the underlying error is deterministically non-retryable (e.g. model_not_found), we should\n      // surface that classification so the frontend auto-retry loop stops.\n      //\n      // Keep returning retry_failed for generic/transient failures so the UI still communicates that\n      // the SDK already retried and gave up.\n      const underlyingType = error.lastError ? this.categorizeError(error.lastError) : \"unknown\";\n      if (\n        underlyingType !== \"unknown\" &&\n        underlyingType !== \"api\" &&\n        underlyingType !== \"retry_failed\"\n      ) {\n        return underlyingType;\n      }\n      return \"retry_failed\";\n    }\n\n    // Check for OpenAI/Anthropic structured error format (from error.cause)\n    // Structure: { error: { code: 'context_length_exceeded', type: '...', message: '...' } }\n    if (\n      typeof error === \"object\" &&\n      error !== null &&\n      \"error\" in error &&\n      typeof error.error === \"object\" &&\n      error.error !== null\n    ) {\n      const structuredError = error.error as { code?: string; type?: string };\n\n      // Model not found\n      if (\n        structuredError.code === \"model_not_found\" ||\n        structuredError.type === \"not_found_error\"\n      ) {\n        return \"model_not_found\";\n      }\n\n      // OpenAI context length errors have code: 'context_length_exceeded'\n      if (structuredError.code === \"context_length_exceeded\") {\n        return \"context_exceeded\";\n      }\n\n      // Check for other specific error codes/types\n      if (structuredError.code === \"rate_limit_exceeded\") {\n        return \"rate_limit\";\n      }\n    }\n\n    // Fall back to string matching for other errors\n    if (error instanceof Error) {\n      const message = error.message.toLowerCase();\n\n      if (error.name === \"AbortError\" || message.includes(\"abort\")) {\n        return \"aborted\";\n      } else if (message.includes(\"network\") || message.includes(\"fetch\")) {\n        return \"network\";\n      } else if (\n        message.includes(\"model\") &&\n        (message.includes(\"does not exist\") ||\n          message.includes(\"doesn't exist\") ||\n          message.includes(\"not found\") ||\n          message.includes(\"do not have access\") ||\n          message.includes(\"don't have access\") ||\n          message.includes(\"no access\"))\n      ) {\n        return \"model_not_found\";\n      } else if (\n        message.includes(\"token\") ||\n        message.includes(\"context\") ||\n        message.includes(\"too long\") ||\n        message.includes(\"maximum\")\n      ) {\n        return \"context_exceeded\";\n      } else if (\n        message.includes(\"quota\") ||\n        message.includes(\"limit\") ||\n        message.includes(\"insufficient balance\") ||\n        message.includes(\"add credits\") ||\n        message.includes(\"payment required\")\n      ) {\n        return \"quota\";\n      } else if (message.includes(\"auth\") || message.includes(\"key\")) {\n        return \"authentication\";\n      } else {\n        return \"api\";\n      }\n    }\n\n    return \"unknown\";\n  }\n\n  /**\n   * Starts a new stream for a workspace, automatically cancelling any existing stream\n   *\n   * Uses per-workspace mutex to prevent concurrent streams. The mutex ensures:\n   * 1. Only one startStream can execute at a time per workspace\n   * 2. Old stream fully exits before new stream starts\n   * 3. No race conditions in stream registration or cleanup\n   */\n  async startStream(\n    workspaceId: string,\n    messages: ModelMessage[],\n    model: LanguageModel,\n    modelString: string,\n    historySequence: number,\n    system: string,\n    runtime: Runtime,\n    messageId: string,\n    abortSignal?: AbortSignal,\n    tools?: Record<string, Tool>,\n    initialMetadata?: Partial<MuxMetadata>,\n    providerOptions?: Record<string, unknown>,\n    maxOutputTokens?: number,\n    toolPolicy?: ToolPolicy,\n    providedStreamToken?: StreamToken,\n    hasQueuedMessage?: () => boolean,\n    workspaceName?: string,\n    thinkingLevel?: string\n  ): Promise<Result<StreamToken, SendMessageError>> {\n    const typedWorkspaceId = workspaceId as WorkspaceId;\n\n    if (messages.length === 0) {\n      return Err({\n        type: \"unknown\",\n        raw: \"Invalid prompt: messages must not be empty\",\n      });\n    }\n\n    // Get or create mutex for this workspace\n    if (!this.streamLocks.has(typedWorkspaceId)) {\n      this.streamLocks.set(typedWorkspaceId, new AsyncMutex());\n    }\n    const mutex = this.streamLocks.get(typedWorkspaceId)!;\n\n    try {\n      // Acquire lock - guarantees only one startStream per workspace\n      // Lock is automatically released when scope exits via Symbol.asyncDispose\n      await using _lock = await mutex.acquire();\n\n      // DEBUG: Log stream start\n      log.debug(\n        `[STREAM START] workspaceId=${workspaceId} historySequence=${historySequence} model=${modelString}`\n      );\n\n      const streamAbortController = new AbortController();\n      const unlinkAbortSignal = linkAbortSignal(abortSignal, streamAbortController);\n\n      let runtimeTempDir: string | undefined;\n      let streamRegistered = false;\n\n      try {\n        // Step 1: Cancel any existing stream before proceeding\n        // This must happen regardless of whether a token was provided\n        const generatedStreamToken = await this.ensureStreamSafety(typedWorkspaceId);\n\n        // Step 2: Use provided stream token or the generated one\n        const streamToken = providedStreamToken ?? generatedStreamToken;\n\n        // If the stream was interrupted while we were waiting on async setup (mutex,\n        // temp dir creation, etc), avoid starting the stream entirely.\n        if (streamAbortController.signal.aborted) {\n          return Ok(streamToken);\n        }\n\n        // Step 3: Create temp directory for this stream using runtime\n        // If token was provided, temp dir might already exist - mkdir -p handles this\n        runtimeTempDir = await this.createTempDirForStream(streamToken, runtime);\n\n        if (streamAbortController.signal.aborted) {\n          return Ok(streamToken);\n        }\n\n        // Step 4: Atomic stream creation and registration\n        const streamInfo = this.createStreamAtomically(\n          typedWorkspaceId,\n          streamToken,\n          runtimeTempDir,\n          runtime,\n          messages,\n          model,\n          modelString,\n          streamAbortController,\n          system,\n          historySequence,\n          messageId,\n          tools,\n          initialMetadata,\n          providerOptions,\n          maxOutputTokens,\n          toolPolicy,\n          hasQueuedMessage,\n          workspaceName,\n          thinkingLevel\n        );\n\n        // Guard against a narrow race:\n        // - stopStream() may abort while we're between the last aborted-check and stream registration.\n        // - If we start processStreamWithCleanup anyway, it would emit stream-start, but no one would\n        //   subsequently call stopStream() again (it already ran), so we'd never emit stream-abort/end.\n        // In that case, immediately drop the registered stream and rely on the caller to handle UI.\n        if (streamAbortController.signal.aborted) {\n          this.workspaceStreams.delete(typedWorkspaceId);\n          return Ok(streamToken);\n        }\n\n        streamInfo.unlinkAbortSignal = unlinkAbortSignal;\n        streamRegistered = true;\n\n        // Step 5: Track the processing promise for guaranteed cleanup\n        // This allows cancelStreamSafely to wait for full exit\n        streamInfo.processingPromise = this.processStreamWithCleanup(\n          typedWorkspaceId,\n          streamInfo,\n          historySequence\n        ).catch((error) => {\n          log.error(\"Unexpected error in stream processing:\", error);\n        });\n\n        return Ok(streamToken);\n      } finally {\n        if (!streamRegistered) {\n          unlinkAbortSignal();\n          if (runtimeTempDir) {\n            this.cleanupStreamTempDir(runtime, runtimeTempDir);\n          }\n        }\n      }\n    } catch (error) {\n      // Guaranteed cleanup on any failure\n      this.workspaceStreams.delete(typedWorkspaceId);\n      // Convert to strongly-typed error\n      return Err(this.convertToSendMessageError(error));\n    }\n  }\n\n  /**\n   * Record a previousResponseId as lost if the error indicates OpenAI no longer has it.\n   * StreamManager retries once automatically, and buildProviderOptions filters it for future requests.\n   */\n  private recordLostResponseIdIfApplicable(\n    workspaceId: WorkspaceId,\n    error: unknown,\n    streamInfo: WorkspaceStreamInfo,\n    workspaceLog?: Logger\n  ): void {\n    const responseId = this.extractPreviousResponseIdFromError(error);\n    if (!responseId) {\n      return;\n    }\n\n    const errorCode = this.extractErrorCode(error);\n    const statusCode = this.extractStatusCode(error);\n    // Record if: we have the specific error code, OR a likely status code.\n    // mux-gateway currently surfaces OpenAI's \"previous_response_not_found\" as a 400\n    // (and omits the structured error code), so we treat 400 as eligible once the\n    // responseId regex matched the error payload/message.\n    const shouldRecord =\n      errorCode === \"previous_response_not_found\" ||\n      statusCode === 404 ||\n      statusCode === 500 ||\n      statusCode === 400;\n\n    if (!shouldRecord || this.lostResponseIds.has(responseId)) {\n      return;\n    }\n\n    const logger = workspaceLog ?? this.getWorkspaceLogger(workspaceId, streamInfo);\n    logger.info(\"Recording lost previousResponseId for future filtering\", {\n      previousResponseId: responseId,\n      messageId: streamInfo.messageId,\n      model: streamInfo.model,\n      statusCode,\n      errorCode,\n    });\n\n    this.lostResponseIds.add(responseId);\n  }\n\n  /**\n   * Extract previousResponseId from error response body\n   * OpenAI's error message includes the ID: \"Previous response with id 'resp_...' not found.\"\n   */\n  private extractPreviousResponseIdFromError(error: unknown): string | undefined {\n    // Check APICallError.responseBody first\n    if (APICallError.isInstance(error) && typeof error.responseBody === \"string\") {\n      const match = /'(resp_[a-f0-9]+)'/.exec(error.responseBody);\n      if (match) {\n        return match[1];\n      }\n    }\n\n    // Check error message\n    if (error instanceof Error) {\n      const match = /'(resp_[a-f0-9]+)'/.exec(error.message);\n      if (match) {\n        return match[1];\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Check if a previousResponseId has been marked as lost\n   * Called by buildProviderOptions to filter out invalid IDs\n   */\n  public isResponseIdLost(responseId: string): boolean {\n    return this.lostResponseIds.has(responseId);\n  }\n\n  private extractErrorCode(error: unknown): string | undefined {\n    const candidates: unknown[] = [];\n    if (error instanceof Error && error.cause) {\n      candidates.push(error.cause);\n    }\n    if (APICallError.isInstance(error)) {\n      candidates.push(error.data);\n    }\n    candidates.push(error);\n    for (const candidate of candidates) {\n      const directCode = this.getStructuredErrorCode(candidate);\n      if (directCode) {\n        return directCode;\n      }\n      if (candidate && typeof candidate === \"object\" && \"data\" in candidate) {\n        const dataCandidate = (candidate as { data?: unknown }).data;\n        const nestedCode = this.getStructuredErrorCode(dataCandidate);\n        if (nestedCode) {\n          return nestedCode;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  private extractStatusCode(error: unknown): number | undefined {\n    if (error instanceof Error && error.cause) {\n      const statusCode = this.extractStatusCode(error.cause);\n      if (typeof statusCode === \"number\") {\n        return statusCode;\n      }\n    }\n\n    if (APICallError.isInstance(error) && typeof error.statusCode === \"number\") {\n      return error.statusCode;\n    }\n\n    if (typeof error === \"object\" && error !== null && \"statusCode\" in error) {\n      const candidate = (error as { statusCode?: unknown }).statusCode;\n      if (typeof candidate === \"number\") {\n        return candidate;\n      }\n    }\n\n    return undefined;\n  }\n\n  private getStructuredErrorCode(candidate: unknown): string | undefined {\n    if (typeof candidate === \"object\" && candidate !== null && \"error\" in candidate) {\n      const withError = candidate as { error?: unknown };\n      if (withError.error && typeof withError.error === \"object\") {\n        const nested = withError.error as Record<string, unknown>;\n        const code = nested.code;\n        if (typeof code === \"string\") {\n          return code;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Stops an active stream for a workspace\n   * If soft is true, performs a soft interrupt (cancels at next block boundary)\n   */\n  async stopStream(\n    workspaceId: string,\n    options?: { soft?: boolean; abandonPartial?: boolean; abortReason?: StreamAbortReason }\n  ): Promise<Result<void>> {\n    const typedWorkspaceId = workspaceId as WorkspaceId;\n\n    try {\n      const streamInfo = this.workspaceStreams.get(typedWorkspaceId);\n      if (!streamInfo) {\n        const abortReason = options?.abortReason ?? \"startup\";\n        // Emit abort event so frontend clears pending stream state.\n        // This handles the case where user interrupts before stream-start arrives.\n        // Use empty messageId - frontend handles gracefully (just clears pendingStreamStartTime).\n        this.emitStreamAbort(typedWorkspaceId, \"\", {}, abortReason, options?.abandonPartial);\n        return Ok(undefined);\n      }\n\n      const abortReason = options?.abortReason ?? \"system\";\n      const soft = options?.soft ?? false;\n\n      if (soft) {\n        // Soft interrupt: set flag, will cancel at next block boundary\n        streamInfo.softInterrupt = {\n          pending: true,\n          abandonPartial: options?.abandonPartial ?? false,\n          abortReason,\n        };\n      } else {\n        // Hard interrupt: cancel immediately\n        await this.cancelStreamSafely(\n          typedWorkspaceId,\n          streamInfo,\n          abortReason,\n          options?.abandonPartial\n        );\n      }\n      return Ok(undefined);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return Err(`Failed to stop stream: ${message}`);\n    }\n  }\n\n  /**\n   * Gets the current stream state for a workspace\n   */\n  getStreamState(workspaceId: string): StreamState {\n    const typedWorkspaceId = workspaceId as WorkspaceId;\n    const streamInfo = this.workspaceStreams.get(typedWorkspaceId);\n    return streamInfo?.state ?? StreamState.IDLE;\n  }\n\n  /**\n   * Checks if a workspace currently has an active stream\n   */\n  isStreaming(workspaceId: string): boolean {\n    const state = this.getStreamState(workspaceId);\n    return state === StreamState.STARTING || state === StreamState.STREAMING;\n  }\n\n  /**\n   * Gets all active workspace streams (for debugging/monitoring)\n   */\n  getActiveStreams(): string[] {\n    return Array.from(this.workspaceStreams.keys()).map((id) => id as string);\n  }\n\n  /**\n   * Gets the current stream info for a workspace if actively streaming\n   * Returns undefined if no active stream exists\n   * Used to re-establish streaming context on frontend reconnection\n   */\n  getStreamInfo(\n    workspaceId: string\n  ):\n    | { messageId: string; model: string; historySequence: number; parts: CompletedMessagePart[] }\n    | undefined {\n    const typedWorkspaceId = workspaceId as WorkspaceId;\n    const streamInfo = this.workspaceStreams.get(typedWorkspaceId);\n\n    // Only return info if stream is actively running\n    if (\n      streamInfo &&\n      (streamInfo.state === StreamState.STARTING || streamInfo.state === StreamState.STREAMING)\n    ) {\n      return {\n        messageId: streamInfo.messageId,\n        model: streamInfo.model,\n        historySequence: streamInfo.historySequence,\n        parts: streamInfo.parts,\n      };\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Replay stream events\n   * Emits the same events (stream-start, stream-delta, etc.) that would be emitted during live streaming\n   * This allows replay to flow through the same event path as live streaming (no duplication)\n   */\n  async replayStream(workspaceId: string): Promise<void> {\n    const typedWorkspaceId = workspaceId as WorkspaceId;\n    const streamInfo = this.workspaceStreams.get(typedWorkspaceId);\n\n    // Only replay if stream is actively running\n    if (\n      !streamInfo ||\n      (streamInfo.state !== StreamState.STARTING && streamInfo.state !== StreamState.STREAMING)\n    ) {\n      return;\n    }\n\n    // Initialize token tracker for this model (required for tokenization)\n    await this.tokenTracker.setModel(streamInfo.model);\n\n    // Emit stream-start event (include mode from initialMetadata if available)\n    this.emitStreamStart(typedWorkspaceId, streamInfo, streamInfo.historySequence, {\n      replay: true,\n    });\n\n    // Replay accumulated parts as events using shared emission logic.\n    // IMPORTANT: Snapshot the parts array up-front.\n    //\n    // streamInfo.parts is mutated while the stream is running. Because emitPartAsEvent() is async\n    // (tokenization happens in worker threads), iterating the live array would keep consuming newly\n    // appended parts and can effectively block until the stream ends.\n    //\n    // That blocks AgentSession.emitHistoricalEvents() from sending \"caught-up\" on reconnect,\n    // leaving the renderer stuck in \"Loading workspace\" and suppressing the streaming indicator.\n    const replayParts = streamInfo.parts.slice();\n    const replayMessageId = streamInfo.messageId;\n    for (const part of replayParts) {\n      await this.emitPartAsEvent(typedWorkspaceId, replayMessageId, part, { replay: true });\n    }\n  }\n\n  /**\n   * DEBUG ONLY: Trigger an artificial stream error for testing\n   * This method allows integration tests to simulate stream errors without\n   * mocking the AI SDK or network layer. It triggers the same error handling\n   * path as genuine stream errors by aborting the stream and manually triggering\n   * the error event (since abort alone doesn't throw, it just sets a flag that\n   * causes the for-await loop to break cleanly).\n   */\n  async debugTriggerStreamError(workspaceId: string, errorMessage: string): Promise<boolean> {\n    const typedWorkspaceId = workspaceId as WorkspaceId;\n    const streamInfo = this.workspaceStreams.get(typedWorkspaceId);\n\n    // Only trigger error if stream is actively running\n    if (\n      !streamInfo ||\n      (streamInfo.state !== StreamState.STARTING && streamInfo.state !== StreamState.STREAMING)\n    ) {\n      return false;\n    }\n\n    // Abort the stream first (causes for-await loop to break cleanly)\n    streamInfo.abortController.abort(new Error(errorMessage));\n\n    // Mark as error state (same as catch block does)\n    streamInfo.state = StreamState.ERROR;\n\n    // Update streamInfo metadata with error (so subsequent flushes preserve it)\n    streamInfo.initialMetadata = {\n      ...streamInfo.initialMetadata,\n      error: errorMessage,\n      errorType: \"network\",\n    };\n\n    // Write error state to partial.json (same as real error handling)\n    await this.persistStreamError(typedWorkspaceId, streamInfo, {\n      messageId: streamInfo.messageId,\n      error: errorMessage,\n      errorType: \"network\",\n    });\n\n    // Wait for the stream processing to complete (cleanup)\n    await streamInfo.processingPromise;\n\n    return true;\n  }\n}\n"]}