{"version":3,"file":"streamManager.js","sourceRoot":"","sources":["../../../src/node/services/streamManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from \"events\";\r\nimport * as path from \"path\";\r\nimport { PlatformPaths } from \"@/common/utils/paths\";\r\nimport {\r\n  streamText,\r\n  stepCountIs,\r\n  type ModelMessage,\r\n  type LanguageModel,\r\n  type Tool,\r\n  LoadAPIKeyError,\r\n  APICallError,\r\n  RetryError,\r\n} from \"ai\";\r\nimport type { LanguageModelV2Usage } from \"@ai-sdk/provider\";\r\nimport type { Result } from \"@/common/types/result\";\r\nimport { Ok, Err } from \"@/common/types/result\";\r\nimport { log, type Logger } from \"./log\";\r\nimport type {\r\n  StreamStartEvent,\r\n  StreamEndEvent,\r\n  StreamAbortReason,\r\n  UsageDeltaEvent,\r\n  ToolCallEndEvent,\r\n  CompletedMessagePart,\r\n} from \"@/common/types/stream\";\r\n\r\nimport type { SendMessageError, StreamErrorType } from \"@/common/types/errors\";\r\nimport type { MuxMetadata, MuxMessage } from \"@/common/types/message\";\r\nimport type { ThinkingLevel } from \"@/common/types/thinking\";\r\nimport type { NestedToolCall } from \"@/common/orpc/schemas/message\";\r\nimport {\r\n  coerceStreamErrorTypeForMessage,\r\n  createErrorEvent,\r\n  stripNoisyErrorPrefix,\r\n  type StreamErrorPayload,\r\n} from \"@/node/services/utils/sendMessageError\";\r\nimport type { PartialService } from \"./partialService\";\r\nimport type { HistoryService } from \"./historyService\";\r\nimport { addUsage, accumulateProviderMetadata } from \"@/common/utils/tokens/usageHelpers\";\r\nimport { linkAbortSignal } from \"@/node/utils/abort\";\r\nimport { AsyncMutex } from \"@/node/utils/concurrency/asyncMutex\";\r\nimport { stripInternalToolResultFields } from \"@/common/utils/tools/internalToolResultFields\";\r\nimport type { ToolPolicy } from \"@/common/utils/tools/toolPolicy\";\r\nimport { StreamingTokenTracker } from \"@/node/utils/main/StreamingTokenTracker\";\r\nimport type { MCPServerManager } from \"@/node/services/mcpServerManager\";\r\nimport type { Runtime } from \"@/node/runtime/Runtime\";\r\nimport {\r\n  createCachedSystemMessage,\r\n  applyCacheControlToTools,\r\n} from \"@/common/utils/ai/cacheStrategy\";\r\nimport type { SessionUsageService } from \"./sessionUsageService\";\r\nimport type { CostTrackingService } from \"./costTrackingService\";\r\nimport { createDisplayUsage } from \"@/common/utils/tokens/displayUsage\";\r\nimport { extractToolMediaAsUserMessagesFromModelMessages } from \"@/node/utils/messages/extractToolMediaAsUserMessagesFromModelMessages\";\r\nimport { normalizeGatewayModel } from \"@/common/utils/ai/models\";\r\nimport { MUX_GATEWAY_SESSION_EXPIRED_MESSAGE } from \"@/common/constants/muxGatewayOAuth\";\r\nimport { getModelStats } from \"@/common/utils/tokens/modelStats\";\r\n\r\n// Disable AI SDK warning logging (e.g., \"setting `toolChoice` to `none` is not supported\")\r\nglobalThis.AI_SDK_LOG_WARNINGS = false;\r\n\r\n// Type definitions for stream parts with extended properties\r\ninterface ReasoningDeltaPart {\r\n  type: \"reasoning-delta\";\r\n  text?: string;\r\n  delta?: string;\r\n  providerMetadata?: {\r\n    anthropic?: {\r\n      signature?: string;\r\n      redactedData?: string;\r\n    };\r\n  };\r\n}\r\n\r\n// Tool-call tracking + branded types\r\ninterface ToolCallState {\r\n  toolCallId: string;\r\n  toolName: string;\r\n  input: unknown;\r\n  output?: unknown;\r\n}\r\n\r\ntype ToolCallMap = Map<string, ToolCallState>;\r\n\r\ntype WorkspaceId = string & { __brand: \"WorkspaceId\" };\r\ntype StreamToken = string & { __brand: \"StreamToken\" };\r\n\r\n// Stream request config for start/retry\r\n\r\ntype StreamToolChoice = { type: \"tool\"; toolName: string } | \"required\" | undefined;\r\n\r\ninterface StepMessageTracker {\r\n  latestMessages?: ModelMessage[];\r\n}\r\ninterface StreamRequestConfig {\r\n  model: LanguageModel;\r\n  messages: ModelMessage[];\r\n  system?: string;\r\n  tools?: Record<string, Tool>;\r\n  toolChoice?: StreamToolChoice;\r\n  providerOptions?: Record<string, unknown>;\r\n  maxOutputTokens?: number;\r\n  hasQueuedMessage?: () => boolean;\r\n}\r\n\r\n// Stream state enum for exhaustive checking\r\nenum StreamState {\r\n  IDLE = \"idle\",\r\n  STARTING = \"starting\",\r\n  STREAMING = \"streaming\",\r\n  STOPPING = \"stopping\",\r\n  COMPLETED = \"completed\", // Stream finished successfully (before cleanup)\r\n  ERROR = \"error\",\r\n}\r\n\r\n/**\r\n * Strip encryptedContent from web search results to reduce token usage.\r\n * The encrypted page content can be massive (4000+ chars per result) and isn't\r\n * needed for model context. Keep URL, title, and pageAge for reference.\r\n */\r\nfunction stripEncryptedContentFromArray(output: unknown[]): unknown[] {\r\n  return output.map((item: unknown) => {\r\n    if (item && typeof item === \"object\" && \"encryptedContent\" in item) {\r\n      // Remove encryptedContent but keep other fields\r\n      const { encryptedContent, ...rest } = item as Record<string, unknown>;\r\n      return rest;\r\n    }\r\n\r\n    return item;\r\n  });\r\n}\r\n\r\nexport function stripEncryptedContent(output: unknown): unknown {\r\n  if (Array.isArray(output)) {\r\n    return stripEncryptedContentFromArray(output);\r\n  }\r\n\r\n  // Handle SDK json output shape: { type: \"json\", value: unknown[] }\r\n  if (\r\n    typeof output === \"object\" &&\r\n    output !== null &&\r\n    \"type\" in output &&\r\n    output.type === \"json\" &&\r\n    \"value\" in output &&\r\n    Array.isArray(output.value)\r\n  ) {\r\n    return {\r\n      ...output,\r\n      value: stripEncryptedContentFromArray(output.value),\r\n    };\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nconst MAX_ORPHAN_TOOL_RESULT_WARNINGS_PER_STREAM = 3;\r\nconst ORPHAN_TOOL_RESULT_PREVIEW_CHARS = 160;\r\nconst ORPHAN_TOOL_RESULT_MAX_KEYS = 8;\r\n\r\nfunction summarizeToolResultForLog(output: unknown): Record<string, unknown> {\r\n  if (output === null) {\r\n    return { outputType: \"null\" };\r\n  }\r\n\r\n  if (typeof output === \"string\") {\r\n    return {\r\n      outputType: \"string\",\r\n      outputLength: output.length,\r\n      outputPreview: output.slice(0, ORPHAN_TOOL_RESULT_PREVIEW_CHARS),\r\n    };\r\n  }\r\n\r\n  if (typeof output === \"number\" || typeof output === \"boolean\") {\r\n    return {\r\n      outputType: typeof output,\r\n      outputPreview: String(output),\r\n    };\r\n  }\r\n\r\n  if (Array.isArray(output)) {\r\n    return {\r\n      outputType: \"array\",\r\n      outputLength: output.length,\r\n      firstItemType:\r\n        output.length > 0 && output[0] !== null\r\n          ? typeof output[0]\r\n          : output.length > 0\r\n            ? \"null\"\r\n            : undefined,\r\n    };\r\n  }\r\n\r\n  if (typeof output === \"object\") {\r\n    const outputRecord = output as Record<string, unknown>;\r\n    const keys = Object.keys(outputRecord);\r\n    const summary: Record<string, unknown> = {\r\n      outputType: \"object\",\r\n      outputKeyCount: keys.length,\r\n      outputKeys: keys.slice(0, ORPHAN_TOOL_RESULT_MAX_KEYS),\r\n    };\r\n\r\n    if (typeof outputRecord.type === \"string\") {\r\n      summary.outputFormat = outputRecord.type;\r\n    }\r\n\r\n    if (Array.isArray(outputRecord.value)) {\r\n      summary.outputValueLength = outputRecord.value.length;\r\n    }\r\n\r\n    return summary;\r\n  }\r\n\r\n  return {\r\n    outputType: typeof output,\r\n    outputPreview: JSON.stringify(output),\r\n  };\r\n}\r\n\r\nfunction markProviderMetadataCostsIncluded(\r\n  providerMetadata: Record<string, unknown> | undefined,\r\n  costsIncluded: boolean | undefined\r\n): Record<string, unknown> | undefined {\r\n  if (!costsIncluded) return providerMetadata;\r\n\r\n  const muxMetadata = providerMetadata?.mux;\r\n  const existingMux =\r\n    muxMetadata && typeof muxMetadata === \"object\"\r\n      ? (muxMetadata as Record<string, unknown>)\r\n      : undefined;\r\n\r\n  return {\r\n    ...(providerMetadata ?? {}),\r\n    mux: {\r\n      ...(existingMux ?? {}),\r\n      costsIncluded: true,\r\n    },\r\n  };\r\n}\r\n// Comprehensive stream info\r\ninterface WorkspaceStreamInfo {\r\n  state: StreamState;\r\n  streamResult: Awaited<ReturnType<typeof streamText>>;\r\n  unlinkAbortSignal?: () => void;\r\n  abortController: AbortController;\r\n  workspaceName?: string;\r\n  messageId: string;\r\n  token: StreamToken;\r\n  startTime: number;\r\n\r\n  // Used to ensure part timestamps are strictly monotonic, even when multiple deltas land in the\r\n  // same millisecond. This avoids collisions in reconnect replay dedupe logic which keys off of\r\n  // (messageId, timestamp, delta).\r\n  lastPartTimestamp: number;\r\n\r\n  model: string;\r\n  /** Effective thinking level after model policy clamping */\r\n  thinkingLevel?: string;\r\n  initialMetadata?: Partial<MuxMetadata>;\r\n  request: StreamRequestConfig;\r\n  // Track last prepared step messages for safe retries after tool steps\r\n  stepTracker: StepMessageTracker;\r\n  // Track if a previousResponseId retry happened after a step completed so\r\n  // stream-end uses cumulative usage instead of the retried step's totalUsage.\r\n  didRetryPreviousResponseIdAtStep: boolean;\r\n  // Index into parts where the current step started (used to ensure safe retries)\r\n  currentStepStartIndex: number;\r\n  historySequence: number;\r\n  // Track accumulated parts for partial message (includes reasoning, text, and tools)\r\n  parts: CompletedMessagePart[];\r\n  // Track last partial write time for throttling\r\n  lastPartialWriteTime: number;\r\n  // Throttle timer for partial writes\r\n  partialWriteTimer?: ReturnType<typeof setTimeout>;\r\n  // Track in-flight write to serialize writes\r\n  partialWritePromise?: Promise<void>;\r\n  // Track background processing promise for guaranteed cleanup\r\n  processingPromise: Promise<void>;\r\n  // Soft-interrupt state: when pending, stream will end at next block boundary\r\n  softInterrupt:\r\n  | { pending: false }\r\n  | { pending: true; abandonPartial: boolean; abortReason: StreamAbortReason };\r\n  // Temporary directory for tool outputs (auto-cleaned when stream ends)\r\n  runtimeTempDir: string;\r\n  // Runtime for temp directory cleanup\r\n  runtime: Runtime;\r\n  // Cumulative usage across all steps (for live cost display during streaming)\r\n  cumulativeUsage: LanguageModelV2Usage;\r\n  // Cumulative provider metadata across all steps (for live cost display with cache tokens)\r\n  cumulativeProviderMetadata?: Record<string, unknown>;\r\n  // Last step's usage (for context window display during streaming)\r\n  lastStepUsage?: LanguageModelV2Usage;\r\n  // Last step's provider metadata (for context window cache display)\r\n  lastStepProviderMetadata?: Record<string, unknown>;\r\n}\r\n\r\n// Ensure per-stream part timestamps are strictly monotonic.\r\n//\r\n// Date.now() is millisecond-granularity, so two distinct chunks with identical text emitted in the\r\n// same millisecond can otherwise collide on (timestamp, delta) during reconnect replay buffering.\r\nfunction nextPartTimestamp(streamInfo: WorkspaceStreamInfo): number {\r\n  const now = Date.now();\r\n  const last = streamInfo.lastPartTimestamp;\r\n  const timestamp = now <= last ? last + 1 : now;\r\n  streamInfo.lastPartTimestamp = timestamp;\r\n  return timestamp;\r\n}\r\n\r\n/**\r\n * StreamManager - Handles all streaming operations with type safety and atomic operations\r\n *\r\n * Key invariants:\r\n * - Only one active stream per workspace at any time\r\n * - Atomic stream creation/cancellation operations\r\n * - Guaranteed resource cleanup in all code paths\r\n */\r\nexport class StreamManager extends EventEmitter {\r\n  private workspaceStreams = new Map<WorkspaceId, WorkspaceStreamInfo>();\r\n  private streamLocks = new Map<WorkspaceId, AsyncMutex>();\r\n  private readonly PARTIAL_WRITE_THROTTLE_MS = 500;\r\n  private readonly historyService: HistoryService;\r\n  private readonly partialService: PartialService;\r\n  private mcpServerManager?: MCPServerManager;\r\n  private readonly sessionUsageService?: SessionUsageService;\r\n  private readonly costTrackingService?: CostTrackingService;\r\n  // Token tracker for live streaming statistics\r\n  private tokenTracker = new StreamingTokenTracker();\r\n  // Track OpenAI previousResponseIds that have been invalidated\r\n  // When frontend retries, buildProviderOptions will omit these IDs\r\n  private lostResponseIds = new Set<string>();\r\n\r\n  constructor(\r\n    historyService: HistoryService,\r\n    partialService: PartialService,\r\n    sessionUsageService?: SessionUsageService,\r\n    costTrackingService?: CostTrackingService\r\n  ) {\r\n    super();\r\n    this.historyService = historyService;\r\n    this.partialService = partialService;\r\n    this.sessionUsageService = sessionUsageService;\r\n    this.costTrackingService = costTrackingService;\r\n  }\r\n\r\n  private getWorkspaceLogger(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo?: Pick<WorkspaceStreamInfo, \"workspaceName\">\r\n  ): Logger {\r\n    const fields: Record<string, unknown> = { workspaceId };\r\n    if (streamInfo?.workspaceName) {\r\n      fields.workspaceName = streamInfo.workspaceName;\r\n    }\r\n    return log.withFields(fields);\r\n  }\r\n  setMCPServerManager(manager: MCPServerManager | undefined): void {\r\n    this.mcpServerManager = manager;\r\n  }\r\n\r\n  /**\r\n   * Write the current partial message to disk (throttled by mtime)\r\n   * Ensures writes happen during rapid streaming (crash-resilient)\r\n   */\r\n  private async schedulePartialWrite(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo: WorkspaceStreamInfo\r\n  ): Promise<void> {\r\n    const now = Date.now();\r\n    const timeSinceLastWrite = now - streamInfo.lastPartialWriteTime;\r\n\r\n    // If enough time has passed, write immediately\r\n    if (timeSinceLastWrite >= this.PARTIAL_WRITE_THROTTLE_MS) {\r\n      await this.flushPartialWrite(workspaceId, streamInfo);\r\n      return;\r\n    }\r\n\r\n    // Otherwise, schedule write for remaining time (fire-and-forget for scheduled writes)\r\n    if (streamInfo.partialWriteTimer) {\r\n      clearTimeout(streamInfo.partialWriteTimer);\r\n    }\r\n\r\n    const remainingTime = this.PARTIAL_WRITE_THROTTLE_MS - timeSinceLastWrite;\r\n    streamInfo.partialWriteTimer = setTimeout(() => {\r\n      void this.flushPartialWrite(workspaceId, streamInfo);\r\n    }, remainingTime);\r\n  }\r\n\r\n  private async awaitPendingPartialWrite(streamInfo: WorkspaceStreamInfo): Promise<void> {\r\n    if (streamInfo.partialWritePromise) {\r\n      await streamInfo.partialWritePromise;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Flush any pending partial write and write immediately\r\n   * Serializes writes to prevent races - waits for any in-flight write before starting new one\r\n   */\r\n  private async flushPartialWrite(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo: WorkspaceStreamInfo\r\n  ): Promise<void> {\r\n    // Wait for any in-flight write to complete first (serialization)\r\n    await this.awaitPendingPartialWrite(streamInfo);\r\n\r\n    // Clear throttle timer\r\n    if (streamInfo.partialWriteTimer) {\r\n      clearTimeout(streamInfo.partialWriteTimer);\r\n      streamInfo.partialWriteTimer = undefined;\r\n    }\r\n\r\n    // Start new write and track the promise\r\n    streamInfo.partialWritePromise = (async () => {\r\n      try {\r\n        const canonicalModel = normalizeGatewayModel(streamInfo.model);\r\n        const routedThroughGateway =\r\n          streamInfo.initialMetadata?.routedThroughGateway ??\r\n          streamInfo.model.startsWith(\"mux-gateway:\");\r\n\r\n        const partialMessage: MuxMessage = {\r\n          id: streamInfo.messageId,\r\n          role: \"assistant\",\r\n          metadata: {\r\n            historySequence: streamInfo.historySequence,\r\n            timestamp: streamInfo.startTime,\r\n            ...streamInfo.initialMetadata,\r\n            model: canonicalModel,\r\n            routedThroughGateway,\r\n            ...(streamInfo.thinkingLevel && {\r\n              thinkingLevel: streamInfo.thinkingLevel as ThinkingLevel,\r\n            }),\r\n            partial: true, // Always true - this method only writes partial messages\r\n          },\r\n          parts: streamInfo.parts, // Parts array includes reasoning, text, and tools\r\n        };\r\n\r\n        await this.partialService.writePartial(workspaceId as string, partialMessage);\r\n        streamInfo.lastPartialWriteTime = Date.now();\r\n      } catch (error) {\r\n        log.error(\"Failed to write partial message:\", error);\r\n      } finally {\r\n        // Clear promise when write completes\r\n        streamInfo.partialWritePromise = undefined;\r\n      }\r\n    })();\r\n\r\n    // Wait for this write to complete\r\n    await streamInfo.partialWritePromise;\r\n  }\r\n\r\n  /**\r\n   * Atomically ensures stream safety by cancelling any existing stream\r\n   * @param workspaceId The workspace to ensure stream safety for\r\n   * @returns A unique stream token for the new stream\r\n   */\r\n  private async ensureStreamSafety(workspaceId: WorkspaceId): Promise<StreamToken> {\r\n    const existing = this.workspaceStreams.get(workspaceId);\r\n\r\n    if (existing && existing.state !== StreamState.IDLE) {\r\n      await this.cancelStreamSafely(workspaceId, existing, \"system\", undefined);\r\n    }\r\n\r\n    // Generate unique token for this stream (8 hex chars for context efficiency)\r\n    return Math.random().toString(16).substring(2, 10) as StreamToken;\r\n  }\r\n\r\n  /**\r\n   * Generate a unique stream token (8 hex characters)\r\n   * Used by callers that need to prepare resources (like tools) before starting the stream\r\n   * Uses 8 hex chars instead of UUID for context efficiency (shorter paths in agent output)\r\n   */\r\n  public generateStreamToken(): StreamToken {\r\n    return Math.random().toString(16).substring(2, 10) as StreamToken;\r\n  }\r\n\r\n  /**\r\n   * Create a temporary directory for a stream token\r\n   * Use ~/.mux-tmp instead of system temp directory (e.g., /var/folders/...)\r\n   * because macOS user-scoped temp paths are extremely long, which leads to:\r\n   * - Agent mistakes when copying/manipulating paths\r\n   * - Harder to read in tool outputs\r\n   * - Potential path length issues on some systems\r\n   *\r\n   * Uses the Runtime abstraction so temp directories work for both local and SSH runtimes.\r\n   */\r\n  public async createTempDirForStream(streamToken: StreamToken, runtime: Runtime): Promise<string> {\r\n    const tempDir = `~/.mux-tmp/${streamToken}`;\r\n\r\n    // Resolve ~ in the runtime's context.\r\n    //\r\n    // IMPORTANT: On Windows local runtime, Git Bash may use a customized $HOME,\r\n    // while runtime.resolvePath expands ~ via Node (USERPROFILE). To avoid drift,\r\n    // create the directory using the resolved absolute path.\r\n    let resolvedPath = (await runtime.resolvePath(tempDir)).trim();\r\n\r\n    // In the main process, PlatformPaths defaults to POSIX behavior (no navigator),\r\n    // so we normalize Windows paths to forward slashes.\r\n    if (process.platform === \"win32\") {\r\n      resolvedPath = resolvedPath.replace(/\\\\/g, \"/\");\r\n    }\r\n\r\n    try {\r\n      await runtime.ensureDir(resolvedPath);\r\n    } catch (err) {\r\n      const msg = err instanceof Error ? err.message : String(err);\r\n      throw new Error(`Failed to create temp directory ${resolvedPath}: ${msg}`);\r\n    }\r\n\r\n    return resolvedPath;\r\n  }\r\n\r\n  private cleanupStreamTempDir(runtime: Runtime, runtimeTempDir: string): void {\r\n    // Use parent directory as cwd for safety - if runtimeTempDir is malformed,\r\n    // we won't accidentally run rm -rf from root.\r\n    const tempDirBasename = PlatformPaths.basename(runtimeTempDir);\r\n    const tempDirParent = path.dirname(runtimeTempDir);\r\n\r\n    // Fire-and-forget: don't block stream completion waiting for directory deletion.\r\n    // This is especially important for SSH where rm -rf can take 500ms-2s.\r\n    void runtime\r\n      .exec(`rm -rf \"${tempDirBasename}\"`, {\r\n        cwd: tempDirParent,\r\n        timeout: 10,\r\n      })\r\n      .then(async (result) => {\r\n        await result.exitCode;\r\n        log.debug(`Cleaned up temp dir: ${runtimeTempDir}`);\r\n      })\r\n      .catch((error) => {\r\n        log.error(`Failed to cleanup temp dir ${runtimeTempDir}:`, error);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Extracts usage and duration metadata from stream result.\r\n   *\r\n   * Usage is only available after stream completes naturally.\r\n   * On abort, the usage promise may hang - we use a timeout to return quickly.\r\n   */\r\n  private async emitToolCallDeltaIfPresent(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo: WorkspaceStreamInfo,\r\n    part: unknown\r\n  ): Promise<boolean> {\r\n    const maybeDelta = part as { type?: string } | undefined;\r\n    if (maybeDelta?.type !== \"tool-call-delta\") {\r\n      return false;\r\n    }\r\n\r\n    const toolDelta = part as {\r\n      toolCallId: string;\r\n      toolName: string;\r\n      argsTextDelta: string;\r\n    };\r\n\r\n    const deltaText = String(toolDelta.argsTextDelta ?? \"\");\r\n    if (deltaText.length === 0) {\r\n      return true;\r\n    }\r\n\r\n    const tokens = await this.tokenTracker.countTokens(deltaText);\r\n    const timestamp = Date.now();\r\n\r\n    this.emit(\"tool-call-delta\", {\r\n      type: \"tool-call-delta\",\r\n      workspaceId: workspaceId as string,\r\n      messageId: streamInfo.messageId,\r\n      toolCallId: toolDelta.toolCallId,\r\n      toolName: toolDelta.toolName,\r\n      delta: toolDelta.argsTextDelta,\r\n      tokens,\r\n      timestamp,\r\n    });\r\n\r\n    return true;\r\n  }\r\n\r\n  private async getStreamMetadata(\r\n    streamInfo: WorkspaceStreamInfo,\r\n    timeoutMs = 1000\r\n  ): Promise<{\r\n    totalUsage?: LanguageModelV2Usage;\r\n    contextUsage?: LanguageModelV2Usage;\r\n    contextProviderMetadata?: Record<string, unknown>;\r\n    duration: number;\r\n  }> {\r\n    // Helper: wrap promise with independent timeout + error handling\r\n    // Each promise resolves independently - one failure doesn't mask others\r\n    const withTimeout = <T>(promise: PromiseLike<T>): Promise<T | undefined> =>\r\n      Promise.race([\r\n        promise,\r\n        new Promise<undefined>((resolve) => setTimeout(() => resolve(undefined), timeoutMs)),\r\n      ]).catch(() => undefined);\r\n\r\n    // Fetch all metadata in parallel with independent timeouts\r\n    // - totalUsage: sum of all steps (for cost calculation)\r\n    // - contextUsage: last step only (for context window display)\r\n    // - contextProviderMetadata: last step (for context window cache display)\r\n    const [totalUsage, contextUsage, contextProviderMetadata] = await Promise.all([\r\n      withTimeout(streamInfo.streamResult.totalUsage),\r\n      withTimeout(streamInfo.streamResult.usage),\r\n      withTimeout(streamInfo.streamResult.providerMetadata),\r\n    ]);\r\n\r\n    return {\r\n      totalUsage,\r\n      contextUsage,\r\n      contextProviderMetadata,\r\n      duration: Date.now() - streamInfo.startTime,\r\n    };\r\n  }\r\n\r\n  private resolveTotalUsageForStreamEnd(\r\n    streamInfo: WorkspaceStreamInfo,\r\n    totalUsage: LanguageModelV2Usage | undefined\r\n  ): LanguageModelV2Usage | undefined {\r\n    const cumulativeUsage = streamInfo.cumulativeUsage;\r\n    // totalTokens can be omitted by providers, so treat any non-zero usage field as valid.\r\n    const hasCumulativeUsage =\r\n      (cumulativeUsage.inputTokens ?? 0) > 0 ||\r\n      (cumulativeUsage.outputTokens ?? 0) > 0 ||\r\n      (cumulativeUsage.totalTokens ?? 0) > 0 ||\r\n      (cumulativeUsage.cachedInputTokens ?? 0) > 0 ||\r\n      (cumulativeUsage.reasoningTokens ?? 0) > 0;\r\n    if (streamInfo.didRetryPreviousResponseIdAtStep && hasCumulativeUsage) {\r\n      return cumulativeUsage;\r\n    }\r\n\r\n    return totalUsage;\r\n  }\r\n\r\n  /**\r\n   * Aggregate provider metadata across all steps.\r\n   *\r\n   * CRITICAL: For multi-step tool calls, cache creation tokens are reported per-step.\r\n   * streamResult.providerMetadata only contains the LAST step's metadata, missing\r\n   * cache creation tokens from earlier steps. We must sum across all steps.\r\n   */\r\n  private async getAggregatedProviderMetadata(\r\n    streamInfo: WorkspaceStreamInfo,\r\n    timeoutMs = 1000\r\n  ): Promise<Record<string, unknown> | undefined> {\r\n    try {\r\n      const steps = await Promise.race([\r\n        streamInfo.streamResult.steps,\r\n        new Promise<undefined>((resolve) => setTimeout(() => resolve(undefined), timeoutMs)),\r\n      ]);\r\n\r\n      if (!steps || steps.length === 0) {\r\n        // Fall back to last step's provider metadata\r\n        return await streamInfo.streamResult.providerMetadata;\r\n      }\r\n\r\n      // If only one step, no aggregation needed\r\n      if (steps.length === 1) {\r\n        return steps[0].providerMetadata;\r\n      }\r\n\r\n      // Aggregate cache creation tokens across all steps\r\n      let totalCacheCreationTokens = 0;\r\n      let lastStepMetadata: Record<string, unknown> | undefined;\r\n\r\n      for (const step of steps) {\r\n        lastStepMetadata = step.providerMetadata;\r\n        const anthropicMeta = step.providerMetadata?.anthropic as\r\n          | { cacheCreationInputTokens?: number }\r\n          | undefined;\r\n        if (anthropicMeta?.cacheCreationInputTokens) {\r\n          totalCacheCreationTokens += anthropicMeta.cacheCreationInputTokens;\r\n        }\r\n      }\r\n\r\n      // If no cache creation tokens found, just return last step's metadata\r\n      if (totalCacheCreationTokens === 0) {\r\n        return lastStepMetadata;\r\n      }\r\n\r\n      // Merge aggregated cache creation tokens into the last step's metadata\r\n      return {\r\n        ...lastStepMetadata,\r\n        anthropic: {\r\n          ...(lastStepMetadata?.anthropic as Record<string, unknown> | undefined),\r\n          cacheCreationInputTokens: totalCacheCreationTokens,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      log.debug(\"Could not aggregate provider metadata:\", error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Safely cancels an existing stream with proper cleanup\r\n   *\r\n   * CRITICAL: Waits for the processing promise to complete before cleanup.\r\n   * This ensures the old stream fully exits before a new stream can start,\r\n   * preventing concurrent streams and race conditions.\r\n   */\r\n  /**\r\n   * Convert a part to an event and emit it.\r\n   * Shared between live streaming and replay to ensure consistent event emission.\r\n   * This guarantees replay reconstructs the exact stream using the same tokenization logic.\r\n   *\r\n   * @param workspaceId - Workspace identifier\r\n   * @param messageId - Message identifier\r\n   * @param part - The part to emit (text, reasoning, or tool)\r\n   */\r\n  private async emitPartAsEvent(\r\n    workspaceId: WorkspaceId,\r\n    messageId: string,\r\n    part: CompletedMessagePart,\r\n    options?: { replay?: boolean }\r\n  ): Promise<void> {\r\n    const timestamp = part.timestamp ?? Date.now();\r\n    const isReplay = options?.replay === true;\r\n\r\n    if (part.type === \"text\") {\r\n      const tokens = await this.tokenTracker.countTokens(part.text);\r\n      this.emit(\"stream-delta\", {\r\n        type: \"stream-delta\",\r\n        workspaceId: workspaceId as string,\r\n        messageId,\r\n        ...(isReplay ? { replay: true } : {}),\r\n        delta: part.text,\r\n        tokens,\r\n        timestamp,\r\n      });\r\n    } else if (part.type === \"reasoning\") {\r\n      const tokens = await this.tokenTracker.countTokens(part.text);\r\n      this.emit(\"reasoning-delta\", {\r\n        type: \"reasoning-delta\",\r\n        workspaceId: workspaceId as string,\r\n        messageId,\r\n        ...(isReplay ? { replay: true } : {}),\r\n        delta: part.text,\r\n        tokens,\r\n        timestamp,\r\n        signature: part.signature,\r\n      });\r\n    } else if (part.type === \"dynamic-tool\") {\r\n      const inputText = JSON.stringify(part.input);\r\n      const tokens = await this.tokenTracker.countTokens(inputText);\r\n      this.emit(\"tool-call-start\", {\r\n        type: \"tool-call-start\",\r\n        workspaceId: workspaceId as string,\r\n        messageId,\r\n        ...(isReplay ? { replay: true } : {}),\r\n        toolCallId: part.toolCallId,\r\n        toolName: part.toolName,\r\n        args: part.input,\r\n        tokens,\r\n        timestamp,\r\n      });\r\n\r\n      // If tool has output, emit completion\r\n      if (part.state === \"output-available\") {\r\n        this.emit(\"tool-call-end\", {\r\n          type: \"tool-call-end\",\r\n          workspaceId: workspaceId as string,\r\n          messageId,\r\n          ...(isReplay ? { replay: true } : {}),\r\n          toolCallId: part.toolCallId,\r\n          toolName: part.toolName,\r\n          result: part.output,\r\n          timestamp: Date.now(),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  private async appendPartAndEmit(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo: WorkspaceStreamInfo,\r\n    part: CompletedMessagePart,\r\n    schedulePartialWrite = false\r\n  ): Promise<void> {\r\n    // Emit BEFORE adding to streamInfo.parts.\r\n    //\r\n    // On reconnect, we call replayStream() which snapshots streamInfo.parts. If we push a part to\r\n    // streamInfo.parts and then await tokenization/emit, replay can include the \"in-flight\" part\r\n    // and then the live emit still happens, causing duplicate deltas in the renderer.\r\n    try {\r\n      await this.emitPartAsEvent(workspaceId, streamInfo.messageId, part);\r\n    } finally {\r\n      // Always persist the part in-memory (and to partial.json, if enabled), even if emit fails.\r\n      streamInfo.parts.push(part);\r\n      if (schedulePartialWrite) {\r\n        void this.schedulePartialWrite(workspaceId, streamInfo);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async cancelStreamSafely(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo: WorkspaceStreamInfo,\r\n    abortReason: StreamAbortReason,\r\n    abandonPartial?: boolean\r\n  ): Promise<void> {\r\n    // If stream already completed normally (emitted stream-end), wait for its\r\n    // finally block to finish before returning. This happens when ensureStreamSafety\r\n    // is called for a new stream after the previous one finished but before it was\r\n    // removed from workspaceStreams.\r\n    // Without this guard, we'd emit stream-abort after stream-end, causing the\r\n    // frontend to incorrectly flip the message back to partial:true.\r\n    // We must NOT delete workspaceStreams here  the finally block does that.\r\n    // If we delete early, the finally block's delete could race with a new stream\r\n    // being registered and delete the new stream's entry instead.\r\n    if (streamInfo.state === StreamState.COMPLETED) {\r\n      await streamInfo.processingPromise;\r\n      return;\r\n    }\r\n\r\n    try {\r\n      streamInfo.state = StreamState.STOPPING;\r\n      // Flush any pending partial write immediately (preserves work on interruption)\r\n      await this.flushPartialWrite(workspaceId, streamInfo);\r\n\r\n      streamInfo.abortController.abort();\r\n\r\n      // Unlike checkSoftCancelStream, await cleanup (blocking)\r\n      await this.cleanupAbortedStream(workspaceId, streamInfo, abortReason, abandonPartial);\r\n    } catch (error) {\r\n      log.error(\"Error during stream cancellation:\", error);\r\n      // Force cleanup even if cancellation fails\r\n      this.workspaceStreams.delete(workspaceId);\r\n    }\r\n  }\r\n\r\n  // Checks if a soft interrupt is necessary, and performs one if so\r\n  // Similar to cancelStreamSafely but performs cleanup without blocking\r\n  private async checkSoftCancelStream(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo: WorkspaceStreamInfo\r\n  ): Promise<void> {\r\n    if (!streamInfo.softInterrupt.pending) return;\r\n    try {\r\n      streamInfo.state = StreamState.STOPPING;\r\n\r\n      // Flush any pending partial write immediately (preserves work on interruption)\r\n      await this.flushPartialWrite(workspaceId, streamInfo);\r\n\r\n      streamInfo.abortController.abort();\r\n\r\n      // Return back to the stream loop so we can wait for it to finish before\r\n      // sending the stream abort event.\r\n      const { abandonPartial, abortReason } = streamInfo.softInterrupt;\r\n      void this.cleanupAbortedStream(workspaceId, streamInfo, abortReason, abandonPartial);\r\n    } catch (error) {\r\n      log.error(\"Error during stream cancellation:\", error);\r\n      // Force cleanup even if cancellation fails\r\n      this.workspaceStreams.delete(workspaceId);\r\n    }\r\n  }\r\n\r\n  private async cleanupAbortedStream(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo: WorkspaceStreamInfo,\r\n    abortReason: StreamAbortReason,\r\n    abandonPartial?: boolean\r\n  ): Promise<void> {\r\n    // CRITICAL: Wait for processing to fully complete before cleanup\r\n    // This prevents race conditions where the old stream is still running\r\n    // while a new stream starts (e.g., old stream writing to partial.json)\r\n    await streamInfo.processingPromise;\r\n\r\n    // For aborts, use our tracked cumulativeUsage directly instead of AI SDK's totalUsage.\r\n    // cumulativeUsage is updated on each finish-step event (before tool execution),\r\n    // so it has accurate data even when the stream is interrupted mid-tool-call.\r\n    // AI SDK's totalUsage may return zeros or stale data when aborted.\r\n    const duration = Date.now() - streamInfo.startTime;\r\n    const hasCumulativeUsage = (streamInfo.cumulativeUsage.totalTokens ?? 0) > 0;\r\n    const usage = hasCumulativeUsage ? streamInfo.cumulativeUsage : undefined;\r\n\r\n    // For context window display, use last step's usage (inputTokens = current context size)\r\n    const contextUsage = streamInfo.lastStepUsage;\r\n    const contextProviderMetadata = streamInfo.lastStepProviderMetadata;\r\n\r\n    // Include provider metadata for accurate cost calculation\r\n    const providerMetadata = markProviderMetadataCostsIncluded(\r\n      streamInfo.cumulativeProviderMetadata,\r\n      streamInfo.initialMetadata?.costsIncluded\r\n    );\r\n\r\n    // Record session usage for aborted streams (mirrors stream-end path)\r\n    // This ensures tokens consumed before abort are tracked for cost display\r\n    await this.recordSessionUsage(\r\n      workspaceId,\r\n      streamInfo.model,\r\n      usage,\r\n      providerMetadata,\r\n      \"Failed to record session usage on abort\",\r\n      \"error\",\r\n      streamInfo\r\n    );\r\n\r\n    // Emit abort event with usage if available\r\n    this.emitStreamAbort(\r\n      workspaceId,\r\n      streamInfo.messageId,\r\n      { usage, contextUsage, duration, providerMetadata, contextProviderMetadata },\r\n      abortReason,\r\n      abandonPartial\r\n    );\r\n\r\n    // Clean up immediately\r\n    this.workspaceStreams.delete(workspaceId);\r\n  }\r\n\r\n  private async recordSessionUsage(\r\n    workspaceId: WorkspaceId,\r\n    model: string,\r\n    usage: LanguageModelV2Usage | undefined,\r\n    providerMetadata: Record<string, unknown> | undefined,\r\n    logMessage: string,\r\n    logLevel: \"warn\" | \"error\",\r\n    streamInfo?: Pick<WorkspaceStreamInfo, \"workspaceName\">\r\n  ): Promise<void> {\r\n    if (!usage) {\r\n      return;\r\n    }\r\n\r\n    const messageUsage = createDisplayUsage(usage, model, providerMetadata);\r\n    if (!messageUsage) {\r\n      return;\r\n    }\r\n\r\n    const workspaceLog = this.getWorkspaceLogger(workspaceId, streamInfo);\r\n\r\n    // Track cost if service is available\r\n    if (this.costTrackingService) {\r\n      try {\r\n        await this.costTrackingService.trackCost(\r\n          workspaceId as string,\r\n          normalizeGatewayModel(model),\r\n          usage,\r\n          providerMetadata\r\n        );\r\n      } catch (error) {\r\n        workspaceLog.warn(\"Failed to track cost\", { error });\r\n      }\r\n    }\r\n\r\n    // Record session usage if service is available\r\n    if (this.sessionUsageService) {\r\n      try {\r\n        await this.sessionUsageService.recordUsage(\r\n          workspaceId as string,\r\n          normalizeGatewayModel(model),\r\n          messageUsage\r\n        );\r\n      } catch (error) {\r\n        (logLevel === \"error\" ? workspaceLog.error : workspaceLog.warn)(logMessage, { error });\r\n      }\r\n    }\r\n  }\r\n\r\n  private buildStreamRequestConfig(\r\n    model: LanguageModel,\r\n    modelString: string,\r\n    messages: ModelMessage[],\r\n    system: string,\r\n    tools?: Record<string, Tool>,\r\n    providerOptions?: Record<string, unknown>,\r\n    maxOutputTokens?: number,\r\n    toolPolicy?: ToolPolicy,\r\n    hasQueuedMessage?: () => boolean\r\n  ): StreamRequestConfig {\r\n    // Determine toolChoice based on toolPolicy.\r\n    //\r\n    // If a tool is required (tools object has exactly one tool after applyToolPolicy),\r\n    // force the model to use it using the AI SDK tool choice shape.\r\n    let toolChoice: StreamToolChoice;\r\n    if (tools && toolPolicy) {\r\n      const hasRequireAction = toolPolicy.some((filter) => filter.action === \"require\");\r\n      if (hasRequireAction && Object.keys(tools).length === 1) {\r\n        const requiredToolName = Object.keys(tools)[0];\r\n        toolChoice = { type: \"tool\", toolName: requiredToolName };\r\n        log.debug(\"Setting toolChoice to tool\", { toolName: requiredToolName });\r\n      }\r\n    }\r\n\r\n    // Anthropic Extended Thinking is incompatible with forced tool choice.\r\n    // If a tool is forced, disable thinking for this request to avoid API errors.\r\n    let finalProviderOptions = providerOptions;\r\n    const [provider] = normalizeGatewayModel(modelString).split(\":\", 2);\r\n    if (\r\n      toolChoice &&\r\n      provider === \"anthropic\" &&\r\n      providerOptions &&\r\n      typeof providerOptions === \"object\" &&\r\n      \"anthropic\" in providerOptions\r\n    ) {\r\n      const anthropicOptions = (providerOptions as { anthropic?: unknown }).anthropic;\r\n      if (\r\n        anthropicOptions &&\r\n        typeof anthropicOptions === \"object\" &&\r\n        \"thinking\" in anthropicOptions\r\n      ) {\r\n        const { thinking: _thinking, ...rest } = anthropicOptions as Record<string, unknown>;\r\n        finalProviderOptions = {\r\n          ...providerOptions,\r\n          anthropic: rest,\r\n        };\r\n      }\r\n    }\r\n\r\n    // Apply cache control for Anthropic models\r\n    let finalMessages = messages;\r\n    let finalTools = tools;\r\n    let finalSystem: string | undefined = system;\r\n\r\n    // For Anthropic models, convert system message to a cached message at the start\r\n    const cachedSystemMessage = createCachedSystemMessage(system, modelString);\r\n    if (cachedSystemMessage) {\r\n      // Prepend cached system message and set system parameter to undefined\r\n      // Note: Must be undefined, not empty string, to avoid Anthropic API error\r\n      finalMessages = [cachedSystemMessage, ...messages];\r\n      finalSystem = undefined;\r\n    }\r\n\r\n    // Apply cache control to tools for Anthropic models\r\n    if (tools) {\r\n      finalTools = applyCacheControlToTools(tools, modelString);\r\n    }\r\n\r\n    // Use model's max_output_tokens if available and caller didn't specify.\r\n    // If no metadata exists for the model, omit the parameter entirely to let\r\n    // the provider use its default (Anthropic requires this but has low defaults).\r\n    const modelStats = getModelStats(modelString);\r\n    const effectiveMaxOutputTokens = maxOutputTokens ?? modelStats?.max_output_tokens;\r\n\r\n    return {\r\n      model,\r\n      messages: finalMessages,\r\n      system: finalSystem,\r\n      tools: finalTools,\r\n      toolChoice,\r\n      providerOptions: finalProviderOptions,\r\n      maxOutputTokens: effectiveMaxOutputTokens,\r\n      hasQueuedMessage,\r\n    };\r\n  }\r\n\r\n  private createStopWhenCondition(\r\n    request: Pick<StreamRequestConfig, \"toolChoice\" | \"hasQueuedMessage\">\r\n  ): ReturnType<typeof stepCountIs> | Array<ReturnType<typeof stepCountIs>> {\r\n    if (request.toolChoice) {\r\n      // Required tool calls must stop after a single step to avoid recursive loops.\r\n      return stepCountIs(1);\r\n    }\r\n\r\n    // Allow effectively unlimited autonomous steps while still yielding quickly\r\n    // when a queued user message should interrupt at the next step boundary.\r\n    return [stepCountIs(100000), () => request.hasQueuedMessage?.() ?? false];\r\n  }\r\n\r\n  private createStreamResult(\r\n    request: StreamRequestConfig,\r\n    abortController: AbortController,\r\n    stepTracker?: StepMessageTracker\r\n  ): Awaited<ReturnType<typeof streamText>> {\r\n    return streamText({\r\n      model: request.model,\r\n      messages: request.messages,\r\n      system: request.system,\r\n      abortSignal: abortController.signal,\r\n      prepareStep: ({ messages: stepMessages }) => {\r\n        // streamText runs multiple internal LLM calls (steps) when tools are enabled.\r\n        // Extract base64 images out of tool-result JSON so providers don't treat them as text.\r\n        const rewritten = extractToolMediaAsUserMessagesFromModelMessages(stepMessages);\r\n        const effectiveMessages = rewritten === stepMessages ? stepMessages : rewritten;\r\n        if (stepTracker) {\r\n          stepTracker.latestMessages = effectiveMessages;\r\n        }\r\n        if (rewritten === stepMessages) return undefined;\r\n        return { messages: rewritten };\r\n      },\r\n      tools: request.tools,\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\r\n      toolChoice: request.toolChoice as any, // Force tool use when required by policy\r\n      // Explicit stopWhen configuration keeps continuation policy visible for both\r\n      // required-tool and autonomous tool-loop flows.\r\n      stopWhen: this.createStopWhenCondition(request),\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\r\n      providerOptions: request.providerOptions as any, // Pass provider-specific options (thinking/reasoning config)\r\n      maxOutputTokens: request.maxOutputTokens,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Atomically creates a new stream with all necessary setup\r\n   */\r\n  private createStreamAtomically(\r\n    workspaceId: WorkspaceId,\r\n    streamToken: StreamToken,\r\n    runtimeTempDir: string,\r\n    runtime: Runtime,\r\n    messages: ModelMessage[],\r\n    model: LanguageModel,\r\n    modelString: string,\r\n    abortController: AbortController,\r\n    system: string,\r\n    historySequence: number,\r\n    messageId: string,\r\n    tools?: Record<string, Tool>,\r\n    initialMetadata?: Partial<MuxMetadata>,\r\n    providerOptions?: Record<string, unknown>,\r\n    maxOutputTokens?: number,\r\n    toolPolicy?: ToolPolicy,\r\n    hasQueuedMessage?: () => boolean,\r\n    workspaceName?: string,\r\n    thinkingLevel?: string\r\n  ): WorkspaceStreamInfo {\r\n    // abortController is created and linked to the caller-provided abortSignal in startStream().\r\n\r\n    const stepTracker: StepMessageTracker = {};\r\n    const request = this.buildStreamRequestConfig(\r\n      model,\r\n      modelString,\r\n      messages,\r\n      system,\r\n      tools,\r\n      providerOptions,\r\n      maxOutputTokens,\r\n      toolPolicy,\r\n      hasQueuedMessage\r\n    );\r\n\r\n    // Start streaming - this can throw immediately if API key is missing\r\n    let streamResult;\r\n    try {\r\n      streamResult = this.createStreamResult(request, abortController, stepTracker);\r\n    } catch (error) {\r\n      // Clean up abort controller if stream creation fails\r\n      abortController.abort();\r\n      // Re-throw the error to be caught by startStream\r\n      throw error;\r\n    }\r\n\r\n    const startTime = Date.now();\r\n    const streamInfo: WorkspaceStreamInfo = {\r\n      state: StreamState.STARTING,\r\n      streamResult,\r\n      workspaceName,\r\n      abortController,\r\n      messageId,\r\n      token: streamToken,\r\n      startTime,\r\n      lastPartTimestamp: startTime,\r\n      model: modelString,\r\n      thinkingLevel,\r\n      initialMetadata,\r\n      didRetryPreviousResponseIdAtStep: false,\r\n      stepTracker,\r\n      currentStepStartIndex: 0,\r\n      request,\r\n      historySequence,\r\n      parts: [], // Initialize empty parts array\r\n      lastPartialWriteTime: 0, // Initialize to 0 to allow immediate first write\r\n      partialWritePromise: undefined, // No write in flight initially\r\n      processingPromise: Promise.resolve(), // Placeholder, overwritten in startStream\r\n      softInterrupt: { pending: false },\r\n      runtimeTempDir, // Stream-scoped temp directory for tool outputs\r\n      runtime, // Runtime for temp directory cleanup\r\n      // Initialize cumulative tracking for multi-step streams\r\n      cumulativeUsage: { inputTokens: 0, outputTokens: 0, totalTokens: 0 },\r\n      cumulativeProviderMetadata: undefined,\r\n    };\r\n\r\n    // Atomically register the stream\r\n    this.workspaceStreams.set(workspaceId, streamInfo);\r\n\r\n    return streamInfo;\r\n  }\r\n\r\n  /**\r\n   * Complete a tool call by updating its part and emitting tool-call-end event.\r\n   * CRITICAL: Flushes partial to disk BEFORE emitting event to prevent race conditions\r\n   * where listeners (e.g., sendQueuedMessages) read stale partial data.\r\n   */\r\n  private async completeToolCall(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo: WorkspaceStreamInfo,\r\n    toolCalls: ToolCallMap,\r\n    toolCallId: string,\r\n    toolName: string,\r\n    output: unknown\r\n  ): Promise<void> {\r\n    // Find and update the existing tool part\r\n    const existingPartIndex = streamInfo.parts.findIndex(\r\n      (p) => p.type === \"dynamic-tool\" && p.toolCallId === toolCallId\r\n    );\r\n\r\n    if (existingPartIndex !== -1) {\r\n      const existingPart = streamInfo.parts[existingPartIndex];\r\n      if (existingPart.type === \"dynamic-tool\") {\r\n        streamInfo.parts[existingPartIndex] = {\r\n          ...existingPart,\r\n          state: \"output-available\" as const,\r\n          output,\r\n        };\r\n      }\r\n    } else {\r\n      // Fallback: if the matching tool-call part is missing, still persist output so the UI\r\n      // does not stay stuck in input-available. Input may be missing for provider-native tools.\r\n      const toolCall = toolCalls.get(toolCallId);\r\n      streamInfo.parts.push({\r\n        type: \"dynamic-tool\" as const,\r\n        toolCallId,\r\n        toolName,\r\n        state: \"output-available\" as const,\r\n        input: toolCall?.input ?? null,\r\n        output,\r\n        timestamp: nextPartTimestamp(streamInfo),\r\n      });\r\n    }\r\n\r\n    // CRITICAL: Flush partial to disk BEFORE emitting event\r\n    // This ensures listeners (like sendQueuedMessages) see the tool result when they\r\n    // read partial.json via commitToHistory. Without this await, there's a race condition\r\n    // where the partial is read before the tool result is written, causing \"amnesia\".\r\n    await this.flushPartialWrite(workspaceId, streamInfo);\r\n\r\n    // Emit tool-call-end event (listeners can now safely read partial)\r\n    this.emit(\"tool-call-end\", {\r\n      type: \"tool-call-end\",\r\n      workspaceId: workspaceId as string,\r\n      messageId: streamInfo.messageId,\r\n      toolCallId,\r\n      toolName,\r\n      result: output,\r\n      timestamp: nextPartTimestamp(streamInfo),\r\n    } as ToolCallEndEvent);\r\n  }\r\n\r\n  private async finishToolCall(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo: WorkspaceStreamInfo,\r\n    toolCalls: ToolCallMap,\r\n    toolCallId: string,\r\n    toolName: string,\r\n    output: unknown\r\n  ): Promise<void> {\r\n    await this.completeToolCall(workspaceId, streamInfo, toolCalls, toolCallId, toolName, output);\r\n    await this.checkSoftCancelStream(workspaceId, streamInfo);\r\n  }\r\n\r\n  private logOrphanToolResult(\r\n    workspaceLog: Logger,\r\n    streamInfo: WorkspaceStreamInfo,\r\n    part: { toolCallId: string; toolName: string },\r\n    output: unknown,\r\n    orphanCount: number,\r\n    trackedToolCallCount: number\r\n  ): void {\r\n    if (orphanCount > MAX_ORPHAN_TOOL_RESULT_WARNINGS_PER_STREAM) {\r\n      return;\r\n    }\r\n\r\n    workspaceLog.warn(\r\n      \"[streamManager] Received tool-result without matching tool-call map entry; persisting fallback output\",\r\n      {\r\n        messageId: streamInfo.messageId,\r\n        model: streamInfo.model,\r\n        toolCallId: part.toolCallId,\r\n        toolName: part.toolName,\r\n        orphanCount,\r\n        trackedToolCallCount,\r\n        isWebSearch: part.toolName === \"web_search\",\r\n        ...summarizeToolResultForLog(output),\r\n      }\r\n    );\r\n\r\n    if (orphanCount === MAX_ORPHAN_TOOL_RESULT_WARNINGS_PER_STREAM) {\r\n      workspaceLog.warn(\r\n        \"[streamManager] Suppressing additional orphan tool-result warnings for this stream\",\r\n        {\r\n          messageId: streamInfo.messageId,\r\n          model: streamInfo.model,\r\n          suppressedAfter: orphanCount,\r\n        }\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Emit nested tool events from PTC code_execution.\r\n   * These are forwarded to the frontend via the same event channel as regular tool events.\r\n   * The parentToolCallId field identifies which code_execution call spawned this nested call.\r\n   *\r\n   * Also persists nested calls to streamInfo.parts so they survive interruption/reload.\r\n   */\r\n  emitNestedToolEvent(\r\n    workspaceId: string,\r\n    messageId: string,\r\n    event: {\r\n      type: \"tool-call-start\" | \"tool-call-end\";\r\n      callId: string;\r\n      toolName: string;\r\n      args: unknown;\r\n      parentToolCallId: string;\r\n      startTime: number;\r\n      endTime?: number;\r\n      result?: unknown;\r\n      error?: string;\r\n    }\r\n  ): void {\r\n    // Persist nested calls to streamInfo.parts for crash/interrupt resilience\r\n    const streamInfo = this.workspaceStreams.get(workspaceId as WorkspaceId);\r\n    if (streamInfo) {\r\n      const parentPartIndex = streamInfo.parts.findIndex(\r\n        (p): p is CompletedMessagePart & { type: \"dynamic-tool\"; toolCallId: string } =>\r\n          p.type === \"dynamic-tool\" && \"toolCallId\" in p && p.toolCallId === event.parentToolCallId\r\n      );\r\n\r\n      if (parentPartIndex !== -1) {\r\n        const parentPart = streamInfo.parts[parentPartIndex] as { nestedCalls?: NestedToolCall[] };\r\n        const nestedCalls = parentPart.nestedCalls ?? [];\r\n\r\n        if (event.type === \"tool-call-start\") {\r\n          nestedCalls.push({\r\n            toolCallId: event.callId,\r\n            toolName: event.toolName,\r\n            input: event.args,\r\n            state: \"input-available\",\r\n            timestamp: event.startTime,\r\n          });\r\n        } else if (event.type === \"tool-call-end\") {\r\n          const idx = nestedCalls.findIndex((n) => n.toolCallId === event.callId);\r\n          if (idx !== -1) {\r\n            nestedCalls[idx] = {\r\n              ...nestedCalls[idx],\r\n              output: event.result ?? (event.error ? { error: event.error } : undefined),\r\n              state: \"output-available\",\r\n            };\r\n          }\r\n        }\r\n\r\n        parentPart.nestedCalls = nestedCalls;\r\n\r\n        // Schedule partial write so nested calls survive crashes\r\n        void this.schedulePartialWrite(workspaceId as WorkspaceId, streamInfo);\r\n      }\r\n    }\r\n\r\n    // Emit to frontend\r\n    if (event.type === \"tool-call-start\") {\r\n      this.emit(\"tool-call-start\", {\r\n        type: \"tool-call-start\",\r\n        workspaceId,\r\n        messageId,\r\n        toolCallId: event.callId,\r\n        toolName: event.toolName,\r\n        args: event.args,\r\n        tokens: 0, // Nested calls don't count toward stream tokens\r\n        timestamp: event.startTime,\r\n        parentToolCallId: event.parentToolCallId,\r\n      });\r\n    } else if (event.type === \"tool-call-end\") {\r\n      this.emit(\"tool-call-end\", {\r\n        type: \"tool-call-end\",\r\n        workspaceId,\r\n        messageId,\r\n        toolCallId: event.callId,\r\n        toolName: event.toolName,\r\n        result: event.result ?? (event.error ? { error: event.error } : undefined),\r\n        timestamp: event.endTime!,\r\n        parentToolCallId: event.parentToolCallId,\r\n      });\r\n    }\r\n    // Console events are not streamed (appear in final result only)\r\n  }\r\n\r\n  private getStreamMode(initialMetadata?: Partial<MuxMetadata>): \"plan\" | \"exec\" | undefined {\r\n    const rawMode = initialMetadata?.mode;\r\n    // Stats schema only accepts \"plan\" | \"exec\".\r\n    return rawMode === \"plan\" || rawMode === \"exec\" ? rawMode : undefined;\r\n  }\r\n\r\n  private emitStreamStart(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo: WorkspaceStreamInfo,\r\n    historySequence: number,\r\n    options?: { replay?: boolean }\r\n  ): void {\r\n    const streamStartAgentId = streamInfo.initialMetadata?.agentId;\r\n    const streamStartMode = this.getStreamMode(streamInfo.initialMetadata);\r\n    const canonicalModel = normalizeGatewayModel(streamInfo.model);\r\n    const routedThroughGateway =\r\n      streamInfo.initialMetadata?.routedThroughGateway ??\r\n      streamInfo.model.startsWith(\"mux-gateway:\");\r\n\r\n    this.emit(\"stream-start\", {\r\n      type: \"stream-start\",\r\n      workspaceId: workspaceId as string,\r\n      messageId: streamInfo.messageId,\r\n      ...(options?.replay && { replay: true }),\r\n      model: canonicalModel,\r\n      routedThroughGateway,\r\n      historySequence,\r\n      startTime: streamInfo.startTime,\r\n      ...(streamStartAgentId && { agentId: streamStartAgentId }),\r\n      ...(streamStartMode && { mode: streamStartMode }),\r\n      ...(streamInfo.thinkingLevel && { thinkingLevel: streamInfo.thinkingLevel }),\r\n    } as StreamStartEvent);\r\n  }\r\n\r\n  private emitStreamAbort(\r\n    workspaceId: WorkspaceId,\r\n    messageId: string,\r\n    metadata: Record<string, unknown>,\r\n    abortReason: StreamAbortReason,\r\n    abandonPartial?: boolean\r\n  ): void {\r\n    this.emit(\"stream-abort\", {\r\n      type: \"stream-abort\",\r\n      workspaceId: workspaceId as string,\r\n      messageId,\r\n      abortReason,\r\n      metadata,\r\n      abandonPartial,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Processes a stream with guaranteed cleanup, regardless of success or failure\r\n   */\r\n  private async processStreamWithCleanup(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo: WorkspaceStreamInfo,\r\n    historySequence: number\r\n  ): Promise<void> {\r\n    this.mcpServerManager?.acquireLease(workspaceId as string);\r\n\r\n    try {\r\n      // Update state to streaming\r\n      streamInfo.state = StreamState.STREAMING;\r\n\r\n      // Emit stream start event (include mode from initialMetadata if available)\r\n      this.emitStreamStart(workspaceId, streamInfo, historySequence);\r\n\r\n      // Initialize token tracker for this model\r\n      await this.tokenTracker.setModel(streamInfo.model);\r\n\r\n      let didRetryPreviousResponseId = false;\r\n      const workspaceLog = this.getWorkspaceLogger(workspaceId, streamInfo);\r\n      let orphanToolResultCount = 0;\r\n\r\n      while (true) {\r\n        // Use fullStream to capture all events including tool calls\r\n        const toolCalls: ToolCallMap = new Map();\r\n\r\n        try {\r\n          for await (const part of streamInfo.streamResult.fullStream) {\r\n            // Check if stream was cancelled BEFORE processing any parts\r\n            // This improves interruption responsiveness by catching aborts earlier\r\n            if (streamInfo.abortController.signal.aborted) {\r\n              break;\r\n            }\r\n\r\n            // Log all stream parts to debug reasoning (commented out - too spammy)\r\n            // console.log(\"[DEBUG streamManager]: Stream part\", {\r\n            //   type: part.type,\r\n            //   hasText: \"text\" in part,\r\n            //   preview: \"text\" in part ? (part as StreamPartWithText).text?.substring(0, 50) : undefined,\r\n            // });\r\n\r\n            switch (part.type) {\r\n              case \"start-step\": {\r\n                streamInfo.currentStepStartIndex = streamInfo.parts.length;\r\n                break;\r\n              }\r\n\r\n              case \"text-delta\": {\r\n                // Providers/SDKs may stream text deltas under different keys.\r\n                const textDeltaPart = part as {\r\n                  text?: unknown;\r\n                  delta?: unknown;\r\n                  textDelta?: unknown;\r\n                };\r\n\r\n                const deltaText =\r\n                  typeof textDeltaPart.text === \"string\"\r\n                    ? textDeltaPart.text\r\n                    : typeof textDeltaPart.delta === \"string\"\r\n                      ? textDeltaPart.delta\r\n                      : typeof textDeltaPart.textDelta === \"string\"\r\n                        ? textDeltaPart.textDelta\r\n                        : \"\";\r\n\r\n                if (deltaText.length === 0) {\r\n                  if (\r\n                    textDeltaPart.text !== undefined ||\r\n                    textDeltaPart.delta !== undefined ||\r\n                    textDeltaPart.textDelta !== undefined\r\n                  ) {\r\n                    log.debug(\"[streamManager] Ignoring non-string text-delta payload\", {\r\n                      workspaceId,\r\n                      model: streamInfo.model,\r\n                      textType: typeof textDeltaPart.text,\r\n                      deltaType: typeof textDeltaPart.delta,\r\n                      textDeltaType: typeof textDeltaPart.textDelta,\r\n                    });\r\n                  }\r\n                  break;\r\n                }\r\n\r\n                // Append each delta as a new part (merging happens at display time)\r\n                const textPart = {\r\n                  type: \"text\" as const,\r\n                  text: deltaText,\r\n                  timestamp: nextPartTimestamp(streamInfo),\r\n                };\r\n                await this.appendPartAndEmit(workspaceId, streamInfo, textPart, true);\r\n                break;\r\n              }\r\n\r\n              default: {\r\n                if (await this.emitToolCallDeltaIfPresent(workspaceId, streamInfo, part)) {\r\n                  break;\r\n                }\r\n                break;\r\n              }\r\n\r\n              case \"reasoning-delta\": {\r\n                // Both Anthropic and OpenAI use reasoning-delta for streaming reasoning content\r\n                const reasoningPart = part as ReasoningDeltaPart;\r\n                const delta = reasoningPart.text ?? reasoningPart.delta ?? \"\";\r\n                const signature = reasoningPart.providerMetadata?.anthropic?.signature;\r\n\r\n                // Signature deltas come separately with empty text - attach to last reasoning part\r\n                if (signature && !delta) {\r\n                  const lastPart = streamInfo.parts.at(-1);\r\n                  if (lastPart?.type === \"reasoning\") {\r\n                    lastPart.signature = signature;\r\n                    // Also set providerOptions for SDK compatibility when converting to ModelMessages\r\n                    lastPart.providerOptions = { anthropic: { signature } };\r\n                    // Emit signature update event\r\n                    this.emit(\"reasoning-delta\", {\r\n                      type: \"reasoning-delta\",\r\n                      workspaceId: workspaceId as string,\r\n                      messageId: streamInfo.messageId,\r\n                      delta: \"\",\r\n                      tokens: 0,\r\n                      timestamp: nextPartTimestamp(streamInfo),\r\n                      signature,\r\n                    });\r\n                    void this.schedulePartialWrite(workspaceId, streamInfo);\r\n                  }\r\n                  break;\r\n                }\r\n\r\n                // Append each delta as a new part (merging happens at display time)\r\n                // Include providerOptions for SDK compatibility when converting to ModelMessages\r\n                const newPart = {\r\n                  type: \"reasoning\" as const,\r\n                  text: delta,\r\n                  timestamp: nextPartTimestamp(streamInfo),\r\n                  signature, // May be undefined, will be filled by subsequent signature delta\r\n                  providerOptions: signature ? { anthropic: { signature } } : undefined,\r\n                };\r\n                await this.appendPartAndEmit(workspaceId, streamInfo, newPart, true);\r\n                break;\r\n              }\r\n\r\n              case \"reasoning-end\": {\r\n                // Reasoning-end is just a signal - no state to update\r\n                this.emit(\"reasoning-end\", {\r\n                  type: \"reasoning-end\",\r\n                  workspaceId: workspaceId as string,\r\n                  messageId: streamInfo.messageId,\r\n                });\r\n                await this.checkSoftCancelStream(workspaceId, streamInfo);\r\n                break;\r\n              }\r\n\r\n              case \"tool-call\": {\r\n                // Tool call started - store in map for later lookup\r\n                toolCalls.set(part.toolCallId, {\r\n                  toolCallId: part.toolCallId,\r\n                  toolName: part.toolName,\r\n                  input: part.input,\r\n                });\r\n\r\n                // Note: Tool availability is handled by the SDK, which emits tool-error events\r\n                // for unavailable tools. No need to check here.\r\n\r\n                // IMPORTANT: Add tool part to streamInfo.parts immediately (not just on completion)\r\n                // This ensures in-progress tool calls are saved to partial.json if stream is interrupted\r\n                const toolPart = {\r\n                  type: \"dynamic-tool\" as const,\r\n                  toolCallId: part.toolCallId,\r\n                  toolName: part.toolName,\r\n                  state: \"input-available\" as const,\r\n                  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n                  input: part.input,\r\n                  timestamp: nextPartTimestamp(streamInfo),\r\n                };\r\n\r\n                // Emit using shared logic (ensures replay consistency)\r\n                const inputText = JSON.stringify(part.input);\r\n                log.debug(\r\n                  `[StreamManager] tool-call: toolName=${part.toolName}, input length=${inputText.length}`\r\n                );\r\n                await this.appendPartAndEmit(workspaceId, streamInfo, toolPart);\r\n\r\n                // CRITICAL: Flush partial immediately for ask_user_question\r\n                // This tool blocks waiting for user input, and if the app restarts during\r\n                // that wait, the partial must be persisted so it can be restored.\r\n                // Without this, the throttled write might not complete before app shutdown.\r\n                if (part.toolName === \"ask_user_question\") {\r\n                  await this.flushPartialWrite(workspaceId, streamInfo);\r\n                }\r\n                break;\r\n              }\r\n\r\n              case \"tool-result\": {\r\n                const toolResultPart = part as {\r\n                  toolCallId: string;\r\n                  toolName: string;\r\n                  output: unknown;\r\n                };\r\n\r\n                // Strip encrypted content from web search results before storing\r\n                const strippedOutput = stripInternalToolResultFields(\r\n                  stripEncryptedContent(toolResultPart.output)\r\n                );\r\n\r\n                // Tool call completed successfully\r\n                const toolCall = toolCalls.get(toolResultPart.toolCallId);\r\n                if (toolCall) {\r\n                  toolCall.output = strippedOutput;\r\n                } else {\r\n                  orphanToolResultCount += 1;\r\n                  this.logOrphanToolResult(\r\n                    workspaceLog,\r\n                    streamInfo,\r\n                    {\r\n                      toolCallId: toolResultPart.toolCallId,\r\n                      toolName: toolResultPart.toolName,\r\n                    },\r\n                    strippedOutput,\r\n                    orphanToolResultCount,\r\n                    toolCalls.size\r\n                  );\r\n                }\r\n\r\n                // Use shared completion logic (await to ensure partial is flushed before event)\r\n                await this.finishToolCall(\r\n                  workspaceId,\r\n                  streamInfo,\r\n                  toolCalls,\r\n                  toolResultPart.toolCallId,\r\n                  toolResultPart.toolName,\r\n                  strippedOutput\r\n                );\r\n                break;\r\n              }\r\n\r\n              // Handle tool-error parts from the stream (AI SDK 5.0+)\r\n              // These are emitted when tool execution fails (e.g., tool doesn't exist)\r\n              case \"tool-error\": {\r\n                const toolErrorPart = part as {\r\n                  toolCallId: string;\r\n                  toolName: string;\r\n                  error: unknown;\r\n                };\r\n\r\n                const logLevel = streamInfo.abortController.signal.aborted ? log.debug : log.error;\r\n                logLevel(`Tool execution error for '${toolErrorPart.toolName}'`, {\r\n                  toolCallId: toolErrorPart.toolCallId,\r\n                  error: toolErrorPart.error,\r\n                });\r\n\r\n                // Format error output\r\n                const errorOutput = {\r\n                  success: false,\r\n                  error:\r\n                    typeof toolErrorPart.error === \"string\"\r\n                      ? toolErrorPart.error\r\n                      : toolErrorPart.error instanceof Error\r\n                        ? toolErrorPart.error.message\r\n                        : JSON.stringify(toolErrorPart.error),\r\n                };\r\n\r\n                // Use shared completion logic (await to ensure partial is flushed before event)\r\n                await this.finishToolCall(\r\n                  workspaceId,\r\n                  streamInfo,\r\n                  toolCalls,\r\n                  toolErrorPart.toolCallId,\r\n                  toolErrorPart.toolName,\r\n                  errorOutput\r\n                );\r\n                break;\r\n              }\r\n\r\n              // Handle error parts from the stream (e.g., OpenAI context_length_exceeded)\r\n              case \"error\": {\r\n                // Capture the error and immediately throw to trigger error handling\r\n                // Error parts are structured errors from the AI SDK\r\n                const errorPart = part as { error: unknown };\r\n\r\n                // Try to extract error message from various possible structures\r\n                let errorMessage: string | undefined;\r\n\r\n                if (errorPart.error instanceof Error) {\r\n                  throw errorPart.error;\r\n                } else if (typeof errorPart.error === \"object\" && errorPart.error !== null) {\r\n                  const errorObj = errorPart.error as Record<string, unknown>;\r\n\r\n                  // Check for nested error object with message (OpenAI format)\r\n                  if (\r\n                    errorObj.error &&\r\n                    typeof errorObj.error === \"object\" &&\r\n                    errorObj.error !== null\r\n                  ) {\r\n                    const nestedError = errorObj.error as Record<string, unknown>;\r\n                    if (typeof nestedError.message === \"string\") {\r\n                      errorMessage = nestedError.message;\r\n                    }\r\n                  }\r\n\r\n                  // Fallback to direct message property\r\n                  errorMessage ??=\r\n                    typeof errorObj.message === \"string\" ? errorObj.message : undefined;\r\n\r\n                  // Last resort: stringify the error\r\n                  errorMessage ??= JSON.stringify(errorObj);\r\n\r\n                  const error = new Error(errorMessage);\r\n                  // Preserve original error as cause for debugging\r\n                  Object.assign(error, { cause: errorObj });\r\n                  throw error;\r\n                } else {\r\n                  throw new Error(String(errorPart.error));\r\n                }\r\n              }\r\n\r\n              // Handle other event types as needed\r\n              case \"start\":\r\n              case \"text-start\":\r\n              case \"finish\":\r\n                // These events can be logged or handled if needed\r\n                break;\r\n\r\n              case \"finish-step\": {\r\n                // Emit usage-delta event with usage from this step\r\n                const finishStepPart = part as {\r\n                  type: \"finish-step\";\r\n                  usage: LanguageModelV2Usage;\r\n                  providerMetadata?: Record<string, unknown>;\r\n                };\r\n\r\n                // Update cumulative totals for this stream\r\n                streamInfo.cumulativeUsage = addUsage(\r\n                  streamInfo.cumulativeUsage,\r\n                  finishStepPart.usage\r\n                );\r\n                streamInfo.cumulativeProviderMetadata = accumulateProviderMetadata(\r\n                  streamInfo.cumulativeProviderMetadata,\r\n                  finishStepPart.providerMetadata\r\n                );\r\n\r\n                // Track last step's data for context window display\r\n                streamInfo.lastStepUsage = finishStepPart.usage;\r\n                streamInfo.lastStepProviderMetadata = finishStepPart.providerMetadata;\r\n\r\n                const usageEvent: UsageDeltaEvent = {\r\n                  type: \"usage-delta\",\r\n                  workspaceId: workspaceId as string,\r\n                  messageId: streamInfo.messageId,\r\n                  // Step-level (for context window display)\r\n                  usage: finishStepPart.usage,\r\n                  providerMetadata: finishStepPart.providerMetadata,\r\n                  // Cumulative (for live cost display)\r\n                  cumulativeUsage: streamInfo.cumulativeUsage,\r\n                  cumulativeProviderMetadata: streamInfo.cumulativeProviderMetadata,\r\n                };\r\n                streamInfo.currentStepStartIndex = streamInfo.parts.length;\r\n                this.emit(\"usage-delta\", usageEvent);\r\n                await this.checkSoftCancelStream(workspaceId, streamInfo);\r\n                break;\r\n              }\r\n\r\n              case \"text-end\": {\r\n                await this.checkSoftCancelStream(workspaceId, streamInfo);\r\n                break;\r\n              }\r\n            }\r\n          }\r\n\r\n          // No need to save remaining text - text-delta handler already maintains parts array\r\n          // (Removed duplicate push that was causing double text parts)\r\n\r\n          // Flush final state to partial.json for crash resilience\r\n          // This happens regardless of abort status to ensure the final state is persisted to disk\r\n          // On abort: second flush after cancelStreamSafely, ensures all streamed content is saved\r\n          // On normal completion: provides crash resilience before AIService writes to chat.jsonl\r\n          await this.flushPartialWrite(workspaceId, streamInfo);\r\n\r\n          // Check if stream completed successfully\r\n          if (!streamInfo.abortController.signal.aborted) {\r\n            // Get all metadata from stream result in one call\r\n            // - totalUsage: sum of all steps (for cost calculation)\r\n            // - contextUsage: last step only (for context window display)\r\n            // - contextProviderMetadata: last step (for context window cache tokens)\r\n            // Falls back to tracked values when step retries invalidate totalUsage\r\n            // or streamResult metadata fails/times out.\r\n            const streamMeta = await this.getStreamMetadata(streamInfo);\r\n            const totalUsage = this.resolveTotalUsageForStreamEnd(\r\n              streamInfo,\r\n              streamMeta.totalUsage\r\n            );\r\n            const contextUsage = streamMeta.contextUsage ?? streamInfo.lastStepUsage;\r\n            const contextProviderMetadata =\r\n              streamMeta.contextProviderMetadata ?? streamInfo.lastStepProviderMetadata;\r\n            const duration = streamMeta.duration;\r\n            // Aggregated provider metadata across all steps (for cost calculation with cache tokens)\r\n            const providerMetadata = markProviderMetadataCostsIncluded(\r\n              await this.getAggregatedProviderMetadata(streamInfo),\r\n              streamInfo.initialMetadata?.costsIncluded\r\n            );\r\n            const canonicalModel = normalizeGatewayModel(streamInfo.model);\r\n            const routedThroughGateway =\r\n              streamInfo.initialMetadata?.routedThroughGateway ??\r\n              streamInfo.model.startsWith(\"mux-gateway:\");\r\n\r\n            // Emit stream end event with parts preserved in temporal order\r\n            const streamEndEvent: StreamEndEvent = {\r\n              type: \"stream-end\",\r\n              workspaceId: workspaceId as string,\r\n              messageId: streamInfo.messageId,\r\n              metadata: {\r\n                ...streamInfo.initialMetadata, // AIService-provided metadata (systemMessageTokens, etc)\r\n                model: canonicalModel,\r\n                routedThroughGateway,\r\n                ...(streamInfo.thinkingLevel && {\r\n                  thinkingLevel: streamInfo.thinkingLevel as ThinkingLevel,\r\n                }),\r\n                usage: totalUsage, // Total across all steps (for cost calculation)\r\n                contextUsage, // Last step only (for context window display)\r\n                providerMetadata, // Aggregated (for cost calculation)\r\n                contextProviderMetadata, // Last step (for context window display)\r\n                duration,\r\n              },\r\n              parts: streamInfo.parts, // Parts array with temporal ordering (includes reasoning)\r\n            };\r\n\r\n            // Update history with final message BEFORE emitting stream-end\r\n            // This prevents a race condition where compaction (triggered by stream-end)\r\n            // clears history while updateHistory is still running, causing old messages\r\n            // to be written back after compaction completes.\r\n            if (streamInfo.parts && streamInfo.parts.length > 0) {\r\n              const finalAssistantMessage: MuxMessage = {\r\n                id: streamInfo.messageId,\r\n                role: \"assistant\",\r\n                metadata: {\r\n                  ...streamEndEvent.metadata,\r\n                  historySequence: streamInfo.historySequence,\r\n                },\r\n                parts: streamInfo.parts,\r\n              };\r\n\r\n              // CRITICAL: Delete partial.json before updating chat.jsonl\r\n              // On successful completion, partial.json becomes stale and must be removed\r\n              await this.partialService.deletePartial(workspaceId as string);\r\n\r\n              // Update the placeholder message in chat.jsonl with final content\r\n              await this.historyService.updateHistory(workspaceId as string, finalAssistantMessage);\r\n\r\n              // Update cumulative session usage (if service is available)\r\n              // Wrapped in try-catch: usage recording is non-critical and shouldn't block stream completion\r\n              await this.recordSessionUsage(\r\n                workspaceId,\r\n                streamInfo.model,\r\n                totalUsage,\r\n                providerMetadata,\r\n                \"Failed to record session usage (stream completion unaffected)\",\r\n                \"warn\",\r\n                streamInfo\r\n              );\r\n            }\r\n\r\n            // Mark as completed right before emitting stream-end.\r\n            // This must happen AFTER async I/O (deletePartial, updateHistory) completes.\r\n            // If we set COMPLETED earlier, isStreaming() returns false during cleanup,\r\n            // allowing new messages (e.g., force-compaction) to bypass queuing and write\r\n            // to history before stream-end fires - causing compaction to use wrong parts.\r\n            streamInfo.state = StreamState.COMPLETED;\r\n\r\n            // Emit stream-end AFTER history is updated to prevent race with compaction\r\n            // Compaction handler listens to this event and clears history - if we emit\r\n            // before updateHistory completes, compaction can clear the file and then\r\n            // updateHistory writes stale data back.\r\n            this.emit(\"stream-end\", streamEndEvent);\r\n          }\r\n          break;\r\n        } catch (error) {\r\n          let handledError: unknown = error;\r\n          let retried = false;\r\n          try {\r\n            retried = await this.retryStreamWithoutPreviousResponseId(\r\n              workspaceId,\r\n              streamInfo,\r\n              error,\r\n              didRetryPreviousResponseId\r\n            );\r\n          } catch (retryError) {\r\n            handledError = retryError;\r\n          }\r\n\r\n          if (retried) {\r\n            didRetryPreviousResponseId = true;\r\n            continue;\r\n          }\r\n\r\n          await this.handleStreamFailure(workspaceId, streamInfo, handledError);\r\n          break;\r\n        }\r\n      }\r\n    } catch (error) {\r\n      await this.handleStreamFailure(workspaceId, streamInfo, error);\r\n    } finally {\r\n      this.mcpServerManager?.releaseLease(workspaceId as string);\r\n\r\n      // Guaranteed cleanup in all code paths\r\n      // Clear any pending timers to prevent keeping process alive\r\n      if (streamInfo.partialWriteTimer) {\r\n        clearTimeout(streamInfo.partialWriteTimer);\r\n        streamInfo.partialWriteTimer = undefined;\r\n      }\r\n\r\n      streamInfo.unlinkAbortSignal?.();\r\n      streamInfo.unlinkAbortSignal = undefined;\r\n\r\n      // Clean up stream temp directory using runtime (fire-and-forget)\r\n      // Don't block stream completion waiting for directory deletion\r\n      // This is especially important for SSH where rm -rf can take 500ms-2s\r\n      if (streamInfo.runtimeTempDir) {\r\n        this.cleanupStreamTempDir(streamInfo.runtime, streamInfo.runtimeTempDir);\r\n      }\r\n\r\n      this.workspaceStreams.delete(workspaceId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Persist error state and emit error events for failed streams.\r\n   */\r\n  private async handleStreamFailure(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo: WorkspaceStreamInfo,\r\n    error: unknown\r\n  ): Promise<void> {\r\n    streamInfo.state = StreamState.ERROR;\r\n\r\n    const workspaceLog = this.getWorkspaceLogger(workspaceId, streamInfo);\r\n\r\n    // Log the actual error for debugging\r\n    workspaceLog.error(\"Stream processing error:\", error);\r\n\r\n    // Record lost previousResponseId so future requests can filter it out\r\n    this.recordLostResponseIdIfApplicable(workspaceId, error, streamInfo, workspaceLog);\r\n\r\n    const errorPayload = this.buildStreamErrorPayload(streamInfo, error);\r\n    await this.persistStreamError(workspaceId, streamInfo, errorPayload);\r\n  }\r\n\r\n  private buildStreamErrorPayload(\r\n    streamInfo: WorkspaceStreamInfo,\r\n    error: unknown\r\n  ): StreamErrorPayload & { errorType: StreamErrorType } {\r\n    // Extract error message (errors thrown from 'error' parts already have the correct message)\r\n    // Apply prefix stripping to remove noisy \"undefined: \" prefixes from provider errors\r\n    let errorMessage: string = stripNoisyErrorPrefix(\r\n      error instanceof Error ? error.message : String(error)\r\n    );\r\n    let actualError: unknown = error;\r\n\r\n    // For categorization, use the cause if available (preserves the original error structure)\r\n    if (error instanceof Error && error.cause) {\r\n      actualError = error.cause;\r\n    }\r\n\r\n    let errorType = this.categorizeError(actualError);\r\n\r\n    // Enhance previous-response and model-not-found error messages\r\n\r\n    const previousResponseId = this.extractPreviousResponseIdFromError(actualError);\r\n    if (previousResponseId) {\r\n      errorMessage = \"OpenAI lost the previous response state while streaming. Retry to continue.\";\r\n    }\r\n    if (errorType === \"model_not_found\") {\r\n      // Extract model name from model string (e.g., \"anthropic:sonnet-1m\" -> \"sonnet-1m\")\r\n      const [, modelName] = streamInfo.model.split(\":\");\r\n      errorMessage = `Model '${modelName || streamInfo.model}' does not exist or is not available. Please check your model selection.`;\r\n    }\r\n\r\n    // Normalize Anthropic overload errors (HTTP 529 / overloaded_error) into a stable,\r\n    // user-friendly message. Keep errorType = server_error so the frontend's auto-retry\r\n    // behavior remains unchanged.\r\n    const canonicalModel = normalizeGatewayModel(streamInfo.model);\r\n    const isAnthropic = canonicalModel.startsWith(\"anthropic:\");\r\n\r\n    const hasErrorProperty = (data: unknown): data is { error: { type?: string } } => {\r\n      return (\r\n        typeof data === \"object\" &&\r\n        data !== null &&\r\n        \"error\" in data &&\r\n        typeof data.error === \"object\" &&\r\n        data.error !== null\r\n      );\r\n    };\r\n\r\n    const isOverloadedApiCallError = (apiError: APICallError): boolean => {\r\n      return (\r\n        apiError.statusCode === 529 ||\r\n        (hasErrorProperty(apiError.data) && apiError.data.error.type === \"overloaded_error\")\r\n      );\r\n    };\r\n\r\n    const isAnthropicOverloaded =\r\n      isAnthropic &&\r\n      ((APICallError.isInstance(actualError) && isOverloadedApiCallError(actualError)) ||\r\n        (RetryError.isInstance(actualError) &&\r\n          actualError.lastError &&\r\n          APICallError.isInstance(actualError.lastError) &&\r\n          isOverloadedApiCallError(actualError.lastError)));\r\n\r\n    if (isAnthropicOverloaded) {\r\n      errorMessage = \"Anthropic is temporarily overloaded (HTTP 529). Please try again later.\";\r\n      errorType = \"server_error\";\r\n    }\r\n\r\n    const muxGatewayUnauthorized =\r\n      streamInfo.model.startsWith(\"mux-gateway:\") &&\r\n      ((APICallError.isInstance(actualError) && actualError.statusCode === 401) ||\r\n        (RetryError.isInstance(actualError) &&\r\n          actualError.lastError &&\r\n          APICallError.isInstance(actualError.lastError) &&\r\n          actualError.lastError.statusCode === 401));\r\n\r\n    if (muxGatewayUnauthorized) {\r\n      // Friendly normalization for expired mux-gateway sessions.\r\n      errorMessage = MUX_GATEWAY_SESSION_EXPIRED_MESSAGE;\r\n    }\r\n    errorType = coerceStreamErrorTypeForMessage(errorType, errorMessage);\r\n\r\n    return {\r\n      messageId: streamInfo.messageId,\r\n      error: errorMessage,\r\n      errorType,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Write error metadata to partial.json and emit the corresponding error event.\r\n   */\r\n  private async persistStreamError(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo: WorkspaceStreamInfo,\r\n    payload: StreamErrorPayload & { errorType: StreamErrorType }\r\n  ): Promise<void> {\r\n    const canonicalModel = normalizeGatewayModel(streamInfo.model);\r\n    const routedThroughGateway =\r\n      streamInfo.initialMetadata?.routedThroughGateway ??\r\n      streamInfo.model.startsWith(\"mux-gateway:\");\r\n\r\n    const errorPartialMessage: MuxMessage = {\r\n      id: payload.messageId,\r\n      role: \"assistant\",\r\n      metadata: {\r\n        historySequence: streamInfo.historySequence,\r\n        timestamp: streamInfo.startTime,\r\n        ...streamInfo.initialMetadata,\r\n        model: canonicalModel,\r\n        routedThroughGateway,\r\n        ...(streamInfo.thinkingLevel && {\r\n          thinkingLevel: streamInfo.thinkingLevel as ThinkingLevel,\r\n        }),\r\n        partial: true,\r\n        error: payload.error,\r\n        errorType: payload.errorType,\r\n      },\r\n      parts: streamInfo.parts,\r\n    };\r\n\r\n    // Wait for any in-flight partial write to complete before writing error state.\r\n    // This prevents race conditions where the error write and a throttled flush\r\n    // write at the same time, causing inconsistent partial.json state.\r\n    await this.awaitPendingPartialWrite(streamInfo);\r\n\r\n    // Write error state to disk - await to ensure consistent state before any resume.\r\n    await this.partialService.writePartial(workspaceId as string, errorPartialMessage);\r\n\r\n    // Emit error event.\r\n    this.emit(\"error\", createErrorEvent(workspaceId as string, payload));\r\n  }\r\n\r\n  private getOpenAIPreviousResponseId(\r\n    providerOptions?: Record<string, unknown>\r\n  ): string | undefined {\r\n    if (!providerOptions || typeof providerOptions !== \"object\" || !(\"openai\" in providerOptions)) {\r\n      return undefined;\r\n    }\r\n\r\n    const openaiOptions = providerOptions.openai;\r\n    if (!openaiOptions || typeof openaiOptions !== \"object\") {\r\n      return undefined;\r\n    }\r\n\r\n    const previousResponseId = (openaiOptions as Record<string, unknown>).previousResponseId;\r\n    return typeof previousResponseId === \"string\" ? previousResponseId : undefined;\r\n  }\r\n\r\n  private clearOpenAIPreviousResponseId(\r\n    providerOptions?: Record<string, unknown>\r\n  ): Record<string, unknown> | undefined {\r\n    if (!providerOptions || typeof providerOptions !== \"object\" || !(\"openai\" in providerOptions)) {\r\n      return providerOptions;\r\n    }\r\n\r\n    const openaiOptions = providerOptions.openai;\r\n    if (!openaiOptions || typeof openaiOptions !== \"object\") {\r\n      return providerOptions;\r\n    }\r\n\r\n    if (!(\"previousResponseId\" in openaiOptions)) {\r\n      return providerOptions;\r\n    }\r\n\r\n    const { previousResponseId: _prev, ...rest } = openaiOptions as Record<string, unknown>;\r\n    return {\r\n      ...providerOptions,\r\n      openai: rest,\r\n    };\r\n  }\r\n\r\n  private async resetStreamStateForRetry(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo: WorkspaceStreamInfo,\r\n    options?: { preserveParts?: boolean; preserveUsage?: boolean; workspaceLog?: Logger }\r\n  ): Promise<void> {\r\n    const preserveParts = options?.preserveParts ?? false;\r\n    const preserveUsage = options?.preserveUsage ?? false;\r\n\r\n    if (streamInfo.partialWriteTimer) {\r\n      clearTimeout(streamInfo.partialWriteTimer);\r\n      streamInfo.partialWriteTimer = undefined;\r\n    }\r\n\r\n    await this.awaitPendingPartialWrite(streamInfo);\r\n    streamInfo.partialWritePromise = undefined;\r\n\r\n    if (!preserveParts) {\r\n      streamInfo.parts = [];\r\n    }\r\n    streamInfo.lastPartialWriteTime = 0;\r\n\r\n    if (!preserveUsage) {\r\n      streamInfo.cumulativeUsage = { inputTokens: 0, outputTokens: 0, totalTokens: 0 };\r\n      streamInfo.cumulativeProviderMetadata = undefined;\r\n      streamInfo.lastStepUsage = undefined;\r\n      streamInfo.lastStepProviderMetadata = undefined;\r\n    }\r\n\r\n    if (!preserveParts) {\r\n      try {\r\n        await this.partialService.deletePartial(workspaceId as string);\r\n      } catch (deleteError) {\r\n        const logger = options?.workspaceLog ?? this.getWorkspaceLogger(workspaceId, streamInfo);\r\n        logger.warn(\"Failed to clear partial state before retry\", { error: deleteError });\r\n      }\r\n    }\r\n  }\r\n\r\n  private async retryStreamWithoutPreviousResponseId(\r\n    workspaceId: WorkspaceId,\r\n    streamInfo: WorkspaceStreamInfo,\r\n    error: unknown,\r\n    hasRetried: boolean\r\n  ): Promise<boolean> {\r\n    if (hasRetried) {\r\n      return false;\r\n    }\r\n\r\n    if (streamInfo.abortController.signal.aborted || streamInfo.softInterrupt.pending) {\r\n      return false;\r\n    }\r\n\r\n    const hasParts = streamInfo.parts.length > 0;\r\n    const currentStepStartIndex = streamInfo.currentStepStartIndex;\r\n    // If the current step already emitted parts, retrying would duplicate output/tool calls.\r\n    if (hasParts && currentStepStartIndex !== streamInfo.parts.length) {\r\n      return false;\r\n    }\r\n\r\n    const responseId = this.extractPreviousResponseIdFromError(error);\r\n    if (!responseId) {\r\n      return false;\r\n    }\r\n\r\n    const errorCode = this.extractErrorCode(error);\r\n    const statusCode = this.extractStatusCode(error);\r\n    // Retry if: we have the specific error code, OR a likely status code,\r\n    // OR we successfully extracted a response ID from the error message\r\n    // (the message match is strong evidence this is a \"not found\" error regardless of status code)\r\n    const shouldRetry =\r\n      errorCode === \"previous_response_not_found\" ||\r\n      statusCode === 404 ||\r\n      statusCode === 500 ||\r\n      statusCode === 400;\r\n    if (!shouldRetry) {\r\n      return false;\r\n    }\r\n\r\n    const previousResponseId = this.getOpenAIPreviousResponseId(streamInfo.request.providerOptions);\r\n    if (!previousResponseId || previousResponseId !== responseId) {\r\n      return false;\r\n    }\r\n\r\n    const stepMessages = streamInfo.stepTracker.latestMessages;\r\n    if (hasParts && !stepMessages) {\r\n      return false;\r\n    }\r\n\r\n    const providerOptions = this.clearOpenAIPreviousResponseId(streamInfo.request.providerOptions);\r\n    if (providerOptions === streamInfo.request.providerOptions) {\r\n      return false;\r\n    }\r\n\r\n    const workspaceLog = this.getWorkspaceLogger(workspaceId, streamInfo);\r\n    this.recordLostResponseIdIfApplicable(workspaceId, error, streamInfo, workspaceLog);\r\n\r\n    // Step-boundary retries restart the SDK stream, so totalUsage only reflects\r\n    // the retried step. Track this to prefer cumulativeUsage at stream end.\r\n    if (hasParts) {\r\n      streamInfo.didRetryPreviousResponseIdAtStep = true;\r\n    }\r\n\r\n    workspaceLog.info(\"Retrying stream without invalid previousResponseId\", {\r\n      messageId: streamInfo.messageId,\r\n      model: streamInfo.model,\r\n      retryScope: hasParts ? \"step\" : \"stream\",\r\n      previousResponseId,\r\n      errorCode,\r\n      statusCode,\r\n    });\r\n\r\n    await this.resetStreamStateForRetry(workspaceId, streamInfo, {\r\n      preserveParts: hasParts,\r\n      preserveUsage: hasParts,\r\n      workspaceLog,\r\n    });\r\n\r\n    streamInfo.currentStepStartIndex = streamInfo.parts.length;\r\n    streamInfo.request = {\r\n      ...streamInfo.request,\r\n      ...(stepMessages ? { messages: stepMessages } : {}),\r\n      providerOptions,\r\n    };\r\n    streamInfo.streamResult = this.createStreamResult(\r\n      streamInfo.request,\r\n      streamInfo.abortController,\r\n      streamInfo.stepTracker\r\n    );\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Converts errors to strongly-typed SendMessageError\r\n   */\r\n  private convertToSendMessageError(error: unknown): SendMessageError {\r\n    // Check for specific AI SDK errors using type guards\r\n    if (LoadAPIKeyError.isInstance(error)) {\r\n      return {\r\n        type: \"api_key_not_found\",\r\n        provider: \"anthropic\", // We can infer this from LoadAPIKeyError context\r\n      };\r\n    }\r\n\r\n    // TODO: Add more specific error types as needed\r\n    // if (APICallError.isInstance(error)) {\r\n    //   if (error.statusCode === 401) return { type: \"authentication\", ... };\r\n    //   if (error.statusCode === 429) return { type: \"rate_limit\", ... };\r\n    // }\r\n    // if (RetryError.isInstance(error)) {\r\n    //   return { type: \"retry_failed\", ... };\r\n    // }\r\n\r\n    // Fallback for unknown errors\r\n    const message = error instanceof Error ? error.message : String(error);\r\n    return { type: \"unknown\", raw: message };\r\n  }\r\n\r\n  /**\r\n   * Categorizes errors for better error handling (used for event emission)\r\n   */\r\n  private categorizeError(error: unknown): StreamErrorType {\r\n    // Use AI SDK error type guards first\r\n    if (LoadAPIKeyError.isInstance(error)) {\r\n      return \"authentication\";\r\n    }\r\n    if (APICallError.isInstance(error)) {\r\n      if (error.statusCode === 401) return \"authentication\";\r\n      // 402 (Payment Required) is used by mux gateway for billing/credits issues\r\n      // (e.g. \"Insufficient balance. Please add credits to continue.\").\r\n      // Treat as non-retryable quota; 429 (rate_limit) covers RPM/time-based throttling.\r\n      if (error.statusCode === 402) return \"quota\";\r\n      if (error.statusCode === 429) return \"rate_limit\";\r\n      if (error.statusCode && error.statusCode >= 500) return \"server_error\";\r\n\r\n      // Check for model_not_found errors (OpenAI and Anthropic)\r\n      // Type guard for error data structure\r\n      const hasErrorProperty = (\r\n        data: unknown\r\n      ): data is { error: { code?: string; type?: string } } => {\r\n        return (\r\n          typeof data === \"object\" &&\r\n          data !== null &&\r\n          \"error\" in data &&\r\n          typeof data.error === \"object\" &&\r\n          data.error !== null\r\n        );\r\n      };\r\n\r\n      // OpenAI: 400 with error.code === 'model_not_found'\r\n      const isOpenAIModelError =\r\n        error.statusCode === 400 &&\r\n        hasErrorProperty(error.data) &&\r\n        error.data.error.code === \"model_not_found\";\r\n\r\n      // Anthropic: 404 with error.type === 'not_found_error'\r\n      const isAnthropicModelError =\r\n        error.statusCode === 404 &&\r\n        hasErrorProperty(error.data) &&\r\n        error.data.error.type === \"not_found_error\";\r\n\r\n      if (isOpenAIModelError || isAnthropicModelError) {\r\n        return \"model_not_found\";\r\n      }\r\n\r\n      // Check for Anthropic context exceeded errors\r\n      if (error.message.includes(\"prompt is too long:\")) {\r\n        return \"context_exceeded\";\r\n      }\r\n\r\n      return \"api\";\r\n    }\r\n    if (RetryError.isInstance(error)) {\r\n      // The AI SDK wraps the underlying error(s) in RetryError when it exhausts its internal retries.\r\n      // If the underlying error is deterministically non-retryable (e.g. model_not_found), we should\r\n      // surface that classification so the frontend auto-retry loop stops.\r\n      //\r\n      // Keep returning retry_failed for generic/transient failures so the UI still communicates that\r\n      // the SDK already retried and gave up.\r\n      const underlyingType = error.lastError ? this.categorizeError(error.lastError) : \"unknown\";\r\n      if (\r\n        underlyingType !== \"unknown\" &&\r\n        underlyingType !== \"api\" &&\r\n        underlyingType !== \"retry_failed\"\r\n      ) {\r\n        return underlyingType;\r\n      }\r\n      return \"retry_failed\";\r\n    }\r\n\r\n    // Check for OpenAI/Anthropic structured error format (from error.cause)\r\n    // Structure: { error: { code: 'context_length_exceeded', type: '...', message: '...' } }\r\n    if (\r\n      typeof error === \"object\" &&\r\n      error !== null &&\r\n      \"error\" in error &&\r\n      typeof error.error === \"object\" &&\r\n      error.error !== null\r\n    ) {\r\n      const structuredError = error.error as { code?: string; type?: string };\r\n\r\n      // Model not found\r\n      if (\r\n        structuredError.code === \"model_not_found\" ||\r\n        structuredError.type === \"not_found_error\"\r\n      ) {\r\n        return \"model_not_found\";\r\n      }\r\n\r\n      // OpenAI context length errors have code: 'context_length_exceeded'\r\n      if (structuredError.code === \"context_length_exceeded\") {\r\n        return \"context_exceeded\";\r\n      }\r\n\r\n      // Check for other specific error codes/types\r\n      if (structuredError.code === \"rate_limit_exceeded\") {\r\n        return \"rate_limit\";\r\n      }\r\n    }\r\n\r\n    // Fall back to string matching for other errors\r\n    if (error instanceof Error) {\r\n      const message = error.message.toLowerCase();\r\n\r\n      if (error.name === \"AbortError\" || message.includes(\"abort\")) {\r\n        return \"aborted\";\r\n      } else if (message.includes(\"network\") || message.includes(\"fetch\")) {\r\n        return \"network\";\r\n      } else if (\r\n        message.includes(\"model\") &&\r\n        (message.includes(\"does not exist\") ||\r\n          message.includes(\"doesn't exist\") ||\r\n          message.includes(\"not found\") ||\r\n          message.includes(\"do not have access\") ||\r\n          message.includes(\"don't have access\") ||\r\n          message.includes(\"no access\"))\r\n      ) {\r\n        return \"model_not_found\";\r\n      } else if (\r\n        message.includes(\"token\") ||\r\n        message.includes(\"context\") ||\r\n        message.includes(\"too long\") ||\r\n        message.includes(\"maximum\")\r\n      ) {\r\n        return \"context_exceeded\";\r\n      } else if (\r\n        message.includes(\"quota\") ||\r\n        message.includes(\"limit\") ||\r\n        message.includes(\"insufficient balance\") ||\r\n        message.includes(\"add credits\") ||\r\n        message.includes(\"payment required\")\r\n      ) {\r\n        return \"quota\";\r\n      } else if (message.includes(\"auth\") || message.includes(\"key\")) {\r\n        return \"authentication\";\r\n      } else {\r\n        return \"api\";\r\n      }\r\n    }\r\n\r\n    return \"unknown\";\r\n  }\r\n\r\n  /**\r\n   * Starts a new stream for a workspace, automatically cancelling any existing stream\r\n   *\r\n   * Uses per-workspace mutex to prevent concurrent streams. The mutex ensures:\r\n   * 1. Only one startStream can execute at a time per workspace\r\n   * 2. Old stream fully exits before new stream starts\r\n   * 3. No race conditions in stream registration or cleanup\r\n   */\r\n  async startStream(\r\n    workspaceId: string,\r\n    messages: ModelMessage[],\r\n    model: LanguageModel,\r\n    modelString: string,\r\n    historySequence: number,\r\n    system: string,\r\n    runtime: Runtime,\r\n    messageId: string,\r\n    abortSignal?: AbortSignal,\r\n    tools?: Record<string, Tool>,\r\n    initialMetadata?: Partial<MuxMetadata>,\r\n    providerOptions?: Record<string, unknown>,\r\n    maxOutputTokens?: number,\r\n    toolPolicy?: ToolPolicy,\r\n    providedStreamToken?: StreamToken,\r\n    hasQueuedMessage?: () => boolean,\r\n    workspaceName?: string,\r\n    thinkingLevel?: string\r\n  ): Promise<Result<StreamToken, SendMessageError>> {\r\n    const typedWorkspaceId = workspaceId as WorkspaceId;\r\n\r\n    if (messages.length === 0) {\r\n      return Err({\r\n        type: \"unknown\",\r\n        raw: \"Invalid prompt: messages must not be empty\",\r\n      });\r\n    }\r\n\r\n    // Get or create mutex for this workspace\r\n    if (!this.streamLocks.has(typedWorkspaceId)) {\r\n      this.streamLocks.set(typedWorkspaceId, new AsyncMutex());\r\n    }\r\n    const mutex = this.streamLocks.get(typedWorkspaceId)!;\r\n\r\n    try {\r\n      // Acquire lock - guarantees only one startStream per workspace\r\n      // Lock is automatically released when scope exits via Symbol.asyncDispose\r\n      await using _lock = await mutex.acquire();\r\n\r\n      // DEBUG: Log stream start\r\n      log.debug(\r\n        `[STREAM START] workspaceId=${workspaceId} historySequence=${historySequence} model=${modelString}`\r\n      );\r\n\r\n      const streamAbortController = new AbortController();\r\n      const unlinkAbortSignal = linkAbortSignal(abortSignal, streamAbortController);\r\n\r\n      let runtimeTempDir: string | undefined;\r\n      let streamRegistered = false;\r\n\r\n      try {\r\n        // Step 1: Cancel any existing stream before proceeding\r\n        // This must happen regardless of whether a token was provided\r\n        const generatedStreamToken = await this.ensureStreamSafety(typedWorkspaceId);\r\n\r\n        // Step 2: Use provided stream token or the generated one\r\n        const streamToken = providedStreamToken ?? generatedStreamToken;\r\n\r\n        // If the stream was interrupted while we were waiting on async setup (mutex,\r\n        // temp dir creation, etc), avoid starting the stream entirely.\r\n        if (streamAbortController.signal.aborted) {\r\n          return Ok(streamToken);\r\n        }\r\n\r\n        // Step 3: Create temp directory for this stream using runtime\r\n        // If token was provided, temp dir might already exist - mkdir -p handles this\r\n        runtimeTempDir = await this.createTempDirForStream(streamToken, runtime);\r\n\r\n        if (streamAbortController.signal.aborted) {\r\n          return Ok(streamToken);\r\n        }\r\n\r\n        // Step 4: Atomic stream creation and registration\r\n        const streamInfo = this.createStreamAtomically(\r\n          typedWorkspaceId,\r\n          streamToken,\r\n          runtimeTempDir,\r\n          runtime,\r\n          messages,\r\n          model,\r\n          modelString,\r\n          streamAbortController,\r\n          system,\r\n          historySequence,\r\n          messageId,\r\n          tools,\r\n          initialMetadata,\r\n          providerOptions,\r\n          maxOutputTokens,\r\n          toolPolicy,\r\n          hasQueuedMessage,\r\n          workspaceName,\r\n          thinkingLevel\r\n        );\r\n\r\n        // Guard against a narrow race:\r\n        // - stopStream() may abort while we're between the last aborted-check and stream registration.\r\n        // - If we start processStreamWithCleanup anyway, it would emit stream-start, but no one would\r\n        //   subsequently call stopStream() again (it already ran), so we'd never emit stream-abort/end.\r\n        // In that case, immediately drop the registered stream and rely on the caller to handle UI.\r\n        if (streamAbortController.signal.aborted) {\r\n          this.workspaceStreams.delete(typedWorkspaceId);\r\n          return Ok(streamToken);\r\n        }\r\n\r\n        streamInfo.unlinkAbortSignal = unlinkAbortSignal;\r\n        streamRegistered = true;\r\n\r\n        // Step 5: Track the processing promise for guaranteed cleanup\r\n        // This allows cancelStreamSafely to wait for full exit\r\n        streamInfo.processingPromise = this.processStreamWithCleanup(\r\n          typedWorkspaceId,\r\n          streamInfo,\r\n          historySequence\r\n        ).catch((error) => {\r\n          log.error(\"Unexpected error in stream processing:\", error);\r\n        });\r\n\r\n        return Ok(streamToken);\r\n      } finally {\r\n        if (!streamRegistered) {\r\n          unlinkAbortSignal();\r\n          if (runtimeTempDir) {\r\n            this.cleanupStreamTempDir(runtime, runtimeTempDir);\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      // Guaranteed cleanup on any failure\r\n      this.workspaceStreams.delete(typedWorkspaceId);\r\n      // Convert to strongly-typed error\r\n      return Err(this.convertToSendMessageError(error));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Record a previousResponseId as lost if the error indicates OpenAI no longer has it.\r\n   * StreamManager retries once automatically, and buildProviderOptions filters it for future requests.\r\n   */\r\n  private recordLostResponseIdIfApplicable(\r\n    workspaceId: WorkspaceId,\r\n    error: unknown,\r\n    streamInfo: WorkspaceStreamInfo,\r\n    workspaceLog?: Logger\r\n  ): void {\r\n    const responseId = this.extractPreviousResponseIdFromError(error);\r\n    if (!responseId) {\r\n      return;\r\n    }\r\n\r\n    const errorCode = this.extractErrorCode(error);\r\n    const statusCode = this.extractStatusCode(error);\r\n    // Record if: we have the specific error code, OR a likely status code.\r\n    // mux-gateway currently surfaces OpenAI's \"previous_response_not_found\" as a 400\r\n    // (and omits the structured error code), so we treat 400 as eligible once the\r\n    // responseId regex matched the error payload/message.\r\n    const shouldRecord =\r\n      errorCode === \"previous_response_not_found\" ||\r\n      statusCode === 404 ||\r\n      statusCode === 500 ||\r\n      statusCode === 400;\r\n\r\n    if (!shouldRecord || this.lostResponseIds.has(responseId)) {\r\n      return;\r\n    }\r\n\r\n    const logger = workspaceLog ?? this.getWorkspaceLogger(workspaceId, streamInfo);\r\n    logger.info(\"Recording lost previousResponseId for future filtering\", {\r\n      previousResponseId: responseId,\r\n      messageId: streamInfo.messageId,\r\n      model: streamInfo.model,\r\n      statusCode,\r\n      errorCode,\r\n    });\r\n\r\n    this.lostResponseIds.add(responseId);\r\n  }\r\n\r\n  /**\r\n   * Extract previousResponseId from error response body\r\n   * OpenAI's error message includes the ID: \"Previous response with id 'resp_...' not found.\"\r\n   */\r\n  private extractPreviousResponseIdFromError(error: unknown): string | undefined {\r\n    // Check APICallError.responseBody first\r\n    if (APICallError.isInstance(error) && typeof error.responseBody === \"string\") {\r\n      const match = /'(resp_[a-f0-9]+)'/.exec(error.responseBody);\r\n      if (match) {\r\n        return match[1];\r\n      }\r\n    }\r\n\r\n    // Check error message\r\n    if (error instanceof Error) {\r\n      const match = /'(resp_[a-f0-9]+)'/.exec(error.message);\r\n      if (match) {\r\n        return match[1];\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Check if a previousResponseId has been marked as lost\r\n   * Called by buildProviderOptions to filter out invalid IDs\r\n   */\r\n  public isResponseIdLost(responseId: string): boolean {\r\n    return this.lostResponseIds.has(responseId);\r\n  }\r\n\r\n  private extractErrorCode(error: unknown): string | undefined {\r\n    const candidates: unknown[] = [];\r\n    if (error instanceof Error && error.cause) {\r\n      candidates.push(error.cause);\r\n    }\r\n    if (APICallError.isInstance(error)) {\r\n      candidates.push(error.data);\r\n    }\r\n    candidates.push(error);\r\n    for (const candidate of candidates) {\r\n      const directCode = this.getStructuredErrorCode(candidate);\r\n      if (directCode) {\r\n        return directCode;\r\n      }\r\n      if (candidate && typeof candidate === \"object\" && \"data\" in candidate) {\r\n        const dataCandidate = (candidate as { data?: unknown }).data;\r\n        const nestedCode = this.getStructuredErrorCode(dataCandidate);\r\n        if (nestedCode) {\r\n          return nestedCode;\r\n        }\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  private extractStatusCode(error: unknown): number | undefined {\r\n    if (error instanceof Error && error.cause) {\r\n      const statusCode = this.extractStatusCode(error.cause);\r\n      if (typeof statusCode === \"number\") {\r\n        return statusCode;\r\n      }\r\n    }\r\n\r\n    if (APICallError.isInstance(error) && typeof error.statusCode === \"number\") {\r\n      return error.statusCode;\r\n    }\r\n\r\n    if (typeof error === \"object\" && error !== null && \"statusCode\" in error) {\r\n      const candidate = (error as { statusCode?: unknown }).statusCode;\r\n      if (typeof candidate === \"number\") {\r\n        return candidate;\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  private getStructuredErrorCode(candidate: unknown): string | undefined {\r\n    if (typeof candidate === \"object\" && candidate !== null && \"error\" in candidate) {\r\n      const withError = candidate as { error?: unknown };\r\n      if (withError.error && typeof withError.error === \"object\") {\r\n        const nested = withError.error as Record<string, unknown>;\r\n        const code = nested.code;\r\n        if (typeof code === \"string\") {\r\n          return code;\r\n        }\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Stops an active stream for a workspace\r\n   * If soft is true, performs a soft interrupt (cancels at next block boundary)\r\n   */\r\n  async stopStream(\r\n    workspaceId: string,\r\n    options?: { soft?: boolean; abandonPartial?: boolean; abortReason?: StreamAbortReason }\r\n  ): Promise<Result<void>> {\r\n    const typedWorkspaceId = workspaceId as WorkspaceId;\r\n\r\n    try {\r\n      const streamInfo = this.workspaceStreams.get(typedWorkspaceId);\r\n      if (!streamInfo) {\r\n        const abortReason = options?.abortReason ?? \"startup\";\r\n        // Emit abort event so frontend clears pending stream state.\r\n        // This handles the case where user interrupts before stream-start arrives.\r\n        // Use empty messageId - frontend handles gracefully (just clears pendingStreamStartTime).\r\n        this.emitStreamAbort(typedWorkspaceId, \"\", {}, abortReason, options?.abandonPartial);\r\n        return Ok(undefined);\r\n      }\r\n\r\n      const abortReason = options?.abortReason ?? \"system\";\r\n      const soft = options?.soft ?? false;\r\n\r\n      if (soft) {\r\n        // Soft interrupt: set flag, will cancel at next block boundary\r\n        streamInfo.softInterrupt = {\r\n          pending: true,\r\n          abandonPartial: options?.abandonPartial ?? false,\r\n          abortReason,\r\n        };\r\n      } else {\r\n        // Hard interrupt: cancel immediately\r\n        await this.cancelStreamSafely(\r\n          typedWorkspaceId,\r\n          streamInfo,\r\n          abortReason,\r\n          options?.abandonPartial\r\n        );\r\n      }\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : String(error);\r\n      return Err(`Failed to stop stream: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the current stream state for a workspace\r\n   */\r\n  getStreamState(workspaceId: string): StreamState {\r\n    const typedWorkspaceId = workspaceId as WorkspaceId;\r\n    const streamInfo = this.workspaceStreams.get(typedWorkspaceId);\r\n    return streamInfo?.state ?? StreamState.IDLE;\r\n  }\r\n\r\n  /**\r\n   * Checks if a workspace currently has an active stream\r\n   */\r\n  isStreaming(workspaceId: string): boolean {\r\n    const state = this.getStreamState(workspaceId);\r\n    return state === StreamState.STARTING || state === StreamState.STREAMING;\r\n  }\r\n\r\n  /**\r\n   * Gets all active workspace streams (for debugging/monitoring)\r\n   */\r\n  getActiveStreams(): string[] {\r\n    return Array.from(this.workspaceStreams.keys()).map((id) => id as string);\r\n  }\r\n\r\n  /**\r\n   * Gets the current stream info for a workspace if actively streaming\r\n   * Returns undefined if no active stream exists\r\n   * Used to re-establish streaming context on frontend reconnection\r\n   */\r\n  getStreamInfo(\r\n    workspaceId: string\r\n  ):\r\n    | { messageId: string; model: string; historySequence: number; parts: CompletedMessagePart[] }\r\n    | undefined {\r\n    const typedWorkspaceId = workspaceId as WorkspaceId;\r\n    const streamInfo = this.workspaceStreams.get(typedWorkspaceId);\r\n\r\n    // Only return info if stream is actively running\r\n    if (\r\n      streamInfo &&\r\n      (streamInfo.state === StreamState.STARTING || streamInfo.state === StreamState.STREAMING)\r\n    ) {\r\n      return {\r\n        messageId: streamInfo.messageId,\r\n        model: streamInfo.model,\r\n        historySequence: streamInfo.historySequence,\r\n        parts: streamInfo.parts,\r\n      };\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Replay stream events\r\n   * Emits the same events (stream-start, stream-delta, etc.) that would be emitted during live streaming\r\n   * This allows replay to flow through the same event path as live streaming (no duplication)\r\n   */\r\n  async replayStream(workspaceId: string): Promise<void> {\r\n    const typedWorkspaceId = workspaceId as WorkspaceId;\r\n    const streamInfo = this.workspaceStreams.get(typedWorkspaceId);\r\n\r\n    // Only replay if stream is actively running\r\n    if (\r\n      !streamInfo ||\r\n      (streamInfo.state !== StreamState.STARTING && streamInfo.state !== StreamState.STREAMING)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // Initialize token tracker for this model (required for tokenization)\r\n    await this.tokenTracker.setModel(streamInfo.model);\r\n\r\n    // Emit stream-start event (include mode from initialMetadata if available)\r\n    this.emitStreamStart(typedWorkspaceId, streamInfo, streamInfo.historySequence, {\r\n      replay: true,\r\n    });\r\n\r\n    // Replay accumulated parts as events using shared emission logic.\r\n    // IMPORTANT: Snapshot the parts array up-front.\r\n    //\r\n    // streamInfo.parts is mutated while the stream is running. Because emitPartAsEvent() is async\r\n    // (tokenization happens in worker threads), iterating the live array would keep consuming newly\r\n    // appended parts and can effectively block until the stream ends.\r\n    //\r\n    // That blocks AgentSession.emitHistoricalEvents() from sending \"caught-up\" on reconnect,\r\n    // leaving the renderer stuck in \"Loading workspace\" and suppressing the streaming indicator.\r\n    const replayParts = streamInfo.parts.slice();\r\n    const replayMessageId = streamInfo.messageId;\r\n    for (const part of replayParts) {\r\n      await this.emitPartAsEvent(typedWorkspaceId, replayMessageId, part, { replay: true });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * DEBUG ONLY: Trigger an artificial stream error for testing\r\n   * This method allows integration tests to simulate stream errors without\r\n   * mocking the AI SDK or network layer. It triggers the same error handling\r\n   * path as genuine stream errors by aborting the stream and manually triggering\r\n   * the error event (since abort alone doesn't throw, it just sets a flag that\r\n   * causes the for-await loop to break cleanly).\r\n   */\r\n  async debugTriggerStreamError(workspaceId: string, errorMessage: string): Promise<boolean> {\r\n    const typedWorkspaceId = workspaceId as WorkspaceId;\r\n    const streamInfo = this.workspaceStreams.get(typedWorkspaceId);\r\n\r\n    // Only trigger error if stream is actively running\r\n    if (\r\n      !streamInfo ||\r\n      (streamInfo.state !== StreamState.STARTING && streamInfo.state !== StreamState.STREAMING)\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    // Abort the stream first (causes for-await loop to break cleanly)\r\n    streamInfo.abortController.abort(new Error(errorMessage));\r\n\r\n    // Mark as error state (same as catch block does)\r\n    streamInfo.state = StreamState.ERROR;\r\n\r\n    // Update streamInfo metadata with error (so subsequent flushes preserve it)\r\n    streamInfo.initialMetadata = {\r\n      ...streamInfo.initialMetadata,\r\n      error: errorMessage,\r\n      errorType: \"network\",\r\n    };\r\n\r\n    // Write error state to partial.json (same as real error handling)\r\n    await this.persistStreamError(typedWorkspaceId, streamInfo, {\r\n      messageId: streamInfo.messageId,\r\n      error: errorMessage,\r\n      errorType: \"network\",\r\n    });\r\n\r\n    // Wait for the stream processing to complete (cleanup)\r\n    await streamInfo.processingPromise;\r\n\r\n    return true;\r\n  }\r\n}\r\n"]}