{"version":3,"file":"agentSession.resumeStreamEmptyHistory.test.js","sourceRoot":"","sources":["../../../src/node/services/agentSession.resumeStreamEmptyHistory.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, expect, test, mock, afterEach } from \"bun:test\";\n\nimport { AgentSession } from \"./agentSession\";\nimport type { Config } from \"@/node/config\";\nimport type { PartialService } from \"./partialService\";\nimport type { AIService } from \"./aiService\";\nimport type { InitStateManager } from \"./initStateManager\";\nimport type { BackgroundProcessManager } from \"./backgroundProcessManager\";\nimport type { Result } from \"@/common/types/result\";\nimport { Ok } from \"@/common/types/result\";\nimport { createTestHistoryService } from \"./testHistoryService\";\nimport type { CostTrackingService } from \"./costTrackingService\";\n\ndescribe(\"AgentSession.resumeStream\", () => {\n  let historyCleanup: (() => Promise<void>) | undefined;\n  afterEach(async () => {\n    await historyCleanup?.();\n  });\n\n  test(\"returns an error when history is empty\", async () => {\n    const streamMessage = mock(() => Promise.resolve(Ok(undefined)));\n\n    const aiService: AIService = {\n      on: mock(() => aiService),\n      off: mock(() => aiService),\n      stopStream: mock(() => Promise.resolve(Ok(undefined))),\n      isStreaming: mock(() => false),\n      streamMessage,\n    } as unknown as AIService;\n\n    const { historyService, cleanup } = await createTestHistoryService();\n    historyCleanup = cleanup;\n\n    const partialService: PartialService = {\n      commitToHistory: mock((): Promise<Result<void>> => Promise.resolve(Ok(undefined))),\n    } as unknown as PartialService;\n\n    const initStateManager: InitStateManager = {\n      on: mock(() => initStateManager),\n      off: mock(() => initStateManager),\n    } as unknown as InitStateManager;\n\n    const backgroundProcessManager: BackgroundProcessManager = {\n      cleanup: mock(() => Promise.resolve()),\n      setMessageQueued: mock(() => undefined),\n    } as unknown as BackgroundProcessManager;\n\n    const config: Config = {\n      srcDir: \"/tmp\",\n      getSessionDir: mock(() => \"/tmp\"),\n    } as unknown as Config;\n\n    const session = new AgentSession({\n      workspaceId: \"ws\",\n      config,\n      historyService,\n      partialService,\n      aiService,\n      initStateManager,\n      costTrackingService: {} as unknown as CostTrackingService,\n      backgroundProcessManager,\n    });\n\n    const result = await session.resumeStream({\n      model: \"anthropic:claude-sonnet-4-5\",\n      agentId: \"exec\",\n    });\n    expect(result.success).toBe(false);\n    if (result.success) return;\n    expect(result.error.type).toBe(\"unknown\");\n    if (result.error.type !== \"unknown\") {\n      throw new Error(`Expected unknown error, got ${result.error.type}`);\n    }\n    expect(result.error.raw).toContain(\"history is empty\");\n    expect(streamMessage).toHaveBeenCalledTimes(0);\n  });\n});\n"]}