{"version":3,"file":"codexOauthAuth.js","sourceRoot":"","sources":["../../../src/node/utils/codexOauthAuth.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Codex OAuth token parsing + JWT claim extraction.\n *\n * We intentionally do not validate token signatures here; we only need to\n * extract non-sensitive claims (e.g. ChatGPT-Account-Id) from OAuth responses.\n */\n\nexport interface CodexOauthAuth {\n  type: \"oauth\";\n  /** OAuth access token (JWT). */\n  access: string;\n  /** OAuth refresh token. */\n  refresh: string;\n  /** Unix epoch milliseconds when the access token expires. */\n  expires: number;\n  /** Value to send as the ChatGPT-Account-Id header. */\n  accountId?: string;\n}\n\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\n  return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\n\nfunction isUnknownArray(value: unknown): value is unknown[] {\n  return Array.isArray(value);\n}\n\nexport function parseCodexOauthAuth(value: unknown): CodexOauthAuth | null {\n  if (!isPlainObject(value)) {\n    return null;\n  }\n\n  const type = value.type;\n  const access = value.access;\n  const refresh = value.refresh;\n  const expires = value.expires;\n  const accountId = value.accountId;\n\n  if (type !== \"oauth\") return null;\n  if (typeof access !== \"string\" || !access) return null;\n  if (typeof refresh !== \"string\" || !refresh) return null;\n  if (typeof expires !== \"number\" || !Number.isFinite(expires)) return null;\n\n  if (typeof accountId !== \"undefined\") {\n    if (typeof accountId !== \"string\" || !accountId) return null;\n  }\n\n  return { type: \"oauth\", access, refresh, expires, accountId };\n}\n\nexport function isCodexOauthAuthExpired(\n  auth: CodexOauthAuth,\n  opts?: { nowMs?: number; skewMs?: number }\n): boolean {\n  const now = opts?.nowMs ?? Date.now();\n  const skew = opts?.skewMs ?? 30_000;\n  return now + skew >= auth.expires;\n}\n\n/**\n * Best-effort JWT claim decoding (no signature verification).\n */\nexport function parseJwtClaims(token: string): Record<string, unknown> | null {\n  const parts = token.split(\".\");\n  if (parts.length !== 3) {\n    return null;\n  }\n\n  try {\n    const json = Buffer.from(parts[1], \"base64url\").toString(\"utf-8\");\n    const parsed = JSON.parse(json) as unknown;\n    return isPlainObject(parsed) ? parsed : null;\n  } catch {\n    return null;\n  }\n}\n\nexport function extractAccountIdFromClaims(claims: Record<string, unknown>): string | null {\n  // OpenCode guide extraction order:\n  // 1) claims.chatgpt_account_id\n  // 2) claims[\"https://api.openai.com/auth\"].chatgpt_account_id\n  // 3) claims.organizations?.[0]?.id\n\n  const direct = claims.chatgpt_account_id;\n  if (typeof direct === \"string\" && direct) {\n    return direct;\n  }\n\n  const openAiAuth = claims[\"https://api.openai.com/auth\"];\n  if (isPlainObject(openAiAuth)) {\n    const candidate = openAiAuth.chatgpt_account_id;\n    if (typeof candidate === \"string\" && candidate) {\n      return candidate;\n    }\n  }\n\n  const organizations = claims.organizations;\n  if (isUnknownArray(organizations) && organizations.length > 0) {\n    const first = organizations[0];\n    if (isPlainObject(first)) {\n      const candidate = first.id;\n      if (typeof candidate === \"string\" && candidate) {\n        return candidate;\n      }\n    }\n  }\n\n  return null;\n}\n\nexport function extractAccountIdFromToken(token: string): string | null {\n  const claims = parseJwtClaims(token);\n  if (!claims) {\n    return null;\n  }\n\n  return extractAccountIdFromClaims(claims);\n}\n\nexport function extractAccountIdFromTokens(input: {\n  accessToken: string;\n  idToken?: string;\n}): string | null {\n  // Prefer id_token when present; fall back to access token.\n  if (typeof input.idToken === \"string\" && input.idToken) {\n    const fromId = extractAccountIdFromToken(input.idToken);\n    if (fromId) {\n      return fromId;\n    }\n  }\n\n  return extractAccountIdFromToken(input.accessToken);\n}\n\n// ------------------------------------------------------------------------------------\n// Backwards-compatible export names.\n// ------------------------------------------------------------------------------------\n\nexport const decodeJwtClaims = parseJwtClaims;\nexport const extractChatGptAccountIdFromClaims = extractAccountIdFromClaims;\nexport const extractChatGptAccountIdFromToken = extractAccountIdFromToken;\nexport const extractChatGptAccountIdFromTokens = extractAccountIdFromTokens;\n"]}