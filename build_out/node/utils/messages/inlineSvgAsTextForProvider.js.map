{"version":3,"file":"inlineSvgAsTextForProvider.js","sourceRoot":"","sources":["../../../../src/node/utils/messages/inlineSvgAsTextForProvider.ts"],"names":[],"mappings":"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","sourcesContent":["import { MAX_SVG_TEXT_CHARS, SVG_MEDIA_TYPE } from \"@/common/constants/imageAttachments\";\r\nimport type { MuxMessage, MuxTextPart } from \"@/common/types/message\";\r\n\r\n// Guardrail: prevent accidentally injecting a multiâ€‘MB SVG into the prompt.\r\nconst DEFAULT_MAX_SVG_TEXT_BYTES = 200 * 1024; // 200 KiB\r\n\r\n// Most provider image endpoints only accept raster formats. SVG is vector markup, and sending it as an\r\n// image frequently fails validation. We inline the SVG XML as text in provider requests instead.\r\n\r\nfunction normalizeMediaType(mediaType: string): string {\r\n  return mediaType.toLowerCase().trim();\r\n}\r\n\r\nfunction estimateBase64Bytes(base64: string): number {\r\n  const trimmed = base64.trim();\r\n  const padding = trimmed.endsWith(\"==\") ? 2 : trimmed.endsWith(\"=\") ? 1 : 0;\r\n  return Math.floor((trimmed.length * 3) / 4) - padding;\r\n}\r\n\r\nfunction decodeSvgDataUrlToUtf8(svgDataUrl: string, maxBytes: number, maxChars: number): string {\r\n  if (!svgDataUrl.startsWith(\"data:\")) {\r\n    throw new Error(\"SVG attachment must be a data URL to inline as text.\");\r\n  }\r\n\r\n  const commaIndex = svgDataUrl.indexOf(\",\");\r\n  if (commaIndex === -1) {\r\n    throw new Error(\"SVG attachment data URL is malformed (missing comma).\");\r\n  }\r\n\r\n  const meta = svgDataUrl.slice(\"data:\".length, commaIndex).toLowerCase();\r\n  const payload = svgDataUrl.slice(commaIndex + 1);\r\n  const isBase64 = meta.includes(\";base64\");\r\n\r\n  if (isBase64) {\r\n    const estimatedBytes = estimateBase64Bytes(payload);\r\n    if (estimatedBytes > maxBytes) {\r\n      throw new Error(\r\n        `SVG attachment is too large to inline as text (${estimatedBytes} bytes > ${maxBytes} bytes).`\r\n      );\r\n    }\r\n\r\n    const buf = Buffer.from(payload, \"base64\");\r\n    if (buf.length > maxBytes) {\r\n      throw new Error(\r\n        `SVG attachment is too large to inline as text (${buf.length} bytes > ${maxBytes} bytes).`\r\n      );\r\n    }\r\n\r\n    const svgText = buf.toString(\"utf8\");\r\n    if (svgText.length > maxChars) {\r\n      throw new Error(\r\n        `SVG attachment is too long to inline as text (${svgText.length} chars > ${maxChars} chars).`\r\n      );\r\n    }\r\n\r\n    return svgText;\r\n  }\r\n\r\n  let decoded: string;\r\n  try {\r\n    decoded = decodeURIComponent(payload);\r\n  } catch {\r\n    throw new Error(\"SVG attachment data URL is malformed (invalid URL encoding).\");\r\n  }\r\n\r\n  if (decoded.length > maxChars) {\r\n    throw new Error(\r\n      `SVG attachment is too long to inline as text (${decoded.length} chars > ${maxChars} chars).`\r\n    );\r\n  }\r\n\r\n  const byteLength = Buffer.byteLength(decoded, \"utf8\");\r\n  if (byteLength > maxBytes) {\r\n    throw new Error(\r\n      `SVG attachment is too large to inline as text (${byteLength} bytes > ${maxBytes} bytes).`\r\n    );\r\n  }\r\n\r\n  return decoded;\r\n}\r\n\r\n/**\r\n * Convert SVG user attachments into SVG source text in the provider request.\r\n *\r\n * Why: many providers only accept raster images (jpeg/png/gif/webp). Sending SVG as an\r\n * image frequently fails validation. Inlining as text supports SVG editing workflows.\r\n *\r\n * Notes:\r\n * - Request-only: does not mutate persisted history/UI.\r\n * - Scope: user message `file` parts only.\r\n */\r\nexport function inlineSvgAsTextForProvider(\r\n  messages: MuxMessage[],\r\n  options?: { maxSvgTextBytes?: number; maxSvgTextChars?: number }\r\n): MuxMessage[] {\r\n  const maxSvgTextChars = options?.maxSvgTextChars ?? MAX_SVG_TEXT_CHARS;\r\n  const maxSvgTextBytes = options?.maxSvgTextBytes ?? DEFAULT_MAX_SVG_TEXT_BYTES;\r\n\r\n  let didChange = false;\r\n\r\n  const result = messages.map((msg) => {\r\n    if (msg.role !== \"user\") {\r\n      return msg;\r\n    }\r\n\r\n    const hasSvg = msg.parts.some(\r\n      (part) => part.type === \"file\" && normalizeMediaType(part.mediaType) === SVG_MEDIA_TYPE\r\n    );\r\n    if (!hasSvg) {\r\n      return msg;\r\n    }\r\n\r\n    didChange = true;\r\n\r\n    const newParts: MuxMessage[\"parts\"] = [];\r\n\r\n    for (const part of msg.parts) {\r\n      if (part.type === \"file\" && normalizeMediaType(part.mediaType) === SVG_MEDIA_TYPE) {\r\n        try {\r\n          const svgText = decodeSvgDataUrlToUtf8(part.url, maxSvgTextBytes, maxSvgTextChars);\r\n          const textPart: MuxTextPart = {\r\n            type: \"text\",\r\n            text:\r\n              `[SVG attachment converted to text (providers generally don't accept ${SVG_MEDIA_TYPE} as an image input).]\\n\\n` +\r\n              `\\`\\`\\`svg\\n${svgText}\\n\\`\\`\\``,\r\n          };\r\n          newParts.push(textPart);\r\n        } catch (error) {\r\n          const errorMessage =\r\n            error instanceof Error ? error.message : \"Failed to decode SVG attachment.\";\r\n          const textPart: MuxTextPart = {\r\n            type: \"text\",\r\n            text: `[SVG attachment omitted from provider request: ${errorMessage}]`,\r\n          };\r\n          newParts.push(textPart);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      newParts.push(part);\r\n    }\r\n\r\n    return {\r\n      ...msg,\r\n      parts: newParts,\r\n    };\r\n  });\r\n\r\n  return didChange ? result : messages;\r\n}\r\n"]}