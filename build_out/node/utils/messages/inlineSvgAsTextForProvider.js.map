{"version":3,"file":"inlineSvgAsTextForProvider.js","sourceRoot":"","sources":["../../../../src/node/utils/messages/inlineSvgAsTextForProvider.ts"],"names":[],"mappings":"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","sourcesContent":["import { MAX_SVG_TEXT_CHARS, SVG_MEDIA_TYPE } from \"@/common/constants/imageAttachments\";\nimport type { MuxMessage, MuxTextPart } from \"@/common/types/message\";\n\n// Guardrail: prevent accidentally injecting a multiâ€‘MB SVG into the prompt.\nconst DEFAULT_MAX_SVG_TEXT_BYTES = 200 * 1024; // 200 KiB\n\n// Most provider image endpoints only accept raster formats. SVG is vector markup, and sending it as an\n// image frequently fails validation. We inline the SVG XML as text in provider requests instead.\n\nfunction normalizeMediaType(mediaType: string): string {\n  return mediaType.toLowerCase().trim();\n}\n\nfunction estimateBase64Bytes(base64: string): number {\n  const trimmed = base64.trim();\n  const padding = trimmed.endsWith(\"==\") ? 2 : trimmed.endsWith(\"=\") ? 1 : 0;\n  return Math.floor((trimmed.length * 3) / 4) - padding;\n}\n\nfunction decodeSvgDataUrlToUtf8(svgDataUrl: string, maxBytes: number, maxChars: number): string {\n  if (!svgDataUrl.startsWith(\"data:\")) {\n    throw new Error(\"SVG attachment must be a data URL to inline as text.\");\n  }\n\n  const commaIndex = svgDataUrl.indexOf(\",\");\n  if (commaIndex === -1) {\n    throw new Error(\"SVG attachment data URL is malformed (missing comma).\");\n  }\n\n  const meta = svgDataUrl.slice(\"data:\".length, commaIndex).toLowerCase();\n  const payload = svgDataUrl.slice(commaIndex + 1);\n  const isBase64 = meta.includes(\";base64\");\n\n  if (isBase64) {\n    const estimatedBytes = estimateBase64Bytes(payload);\n    if (estimatedBytes > maxBytes) {\n      throw new Error(\n        `SVG attachment is too large to inline as text (${estimatedBytes} bytes > ${maxBytes} bytes).`\n      );\n    }\n\n    const buf = Buffer.from(payload, \"base64\");\n    if (buf.length > maxBytes) {\n      throw new Error(\n        `SVG attachment is too large to inline as text (${buf.length} bytes > ${maxBytes} bytes).`\n      );\n    }\n\n    const svgText = buf.toString(\"utf8\");\n    if (svgText.length > maxChars) {\n      throw new Error(\n        `SVG attachment is too long to inline as text (${svgText.length} chars > ${maxChars} chars).`\n      );\n    }\n\n    return svgText;\n  }\n\n  let decoded: string;\n  try {\n    decoded = decodeURIComponent(payload);\n  } catch {\n    throw new Error(\"SVG attachment data URL is malformed (invalid URL encoding).\");\n  }\n\n  if (decoded.length > maxChars) {\n    throw new Error(\n      `SVG attachment is too long to inline as text (${decoded.length} chars > ${maxChars} chars).`\n    );\n  }\n\n  const byteLength = Buffer.byteLength(decoded, \"utf8\");\n  if (byteLength > maxBytes) {\n    throw new Error(\n      `SVG attachment is too large to inline as text (${byteLength} bytes > ${maxBytes} bytes).`\n    );\n  }\n\n  return decoded;\n}\n\n/**\n * Convert SVG user attachments into SVG source text in the provider request.\n *\n * Why: many providers only accept raster images (jpeg/png/gif/webp). Sending SVG as an\n * image frequently fails validation. Inlining as text supports SVG editing workflows.\n *\n * Notes:\n * - Request-only: does not mutate persisted history/UI.\n * - Scope: user message `file` parts only.\n */\nexport function inlineSvgAsTextForProvider(\n  messages: MuxMessage[],\n  options?: { maxSvgTextBytes?: number; maxSvgTextChars?: number }\n): MuxMessage[] {\n  const maxSvgTextChars = options?.maxSvgTextChars ?? MAX_SVG_TEXT_CHARS;\n  const maxSvgTextBytes = options?.maxSvgTextBytes ?? DEFAULT_MAX_SVG_TEXT_BYTES;\n\n  let didChange = false;\n\n  const result = messages.map((msg) => {\n    if (msg.role !== \"user\") {\n      return msg;\n    }\n\n    const hasSvg = msg.parts.some(\n      (part) => part.type === \"file\" && normalizeMediaType(part.mediaType) === SVG_MEDIA_TYPE\n    );\n    if (!hasSvg) {\n      return msg;\n    }\n\n    didChange = true;\n\n    const newParts: MuxMessage[\"parts\"] = [];\n\n    for (const part of msg.parts) {\n      if (part.type === \"file\" && normalizeMediaType(part.mediaType) === SVG_MEDIA_TYPE) {\n        try {\n          const svgText = decodeSvgDataUrlToUtf8(part.url, maxSvgTextBytes, maxSvgTextChars);\n          const textPart: MuxTextPart = {\n            type: \"text\",\n            text:\n              `[SVG attachment converted to text (providers generally don't accept ${SVG_MEDIA_TYPE} as an image input).]\\n\\n` +\n              `\\`\\`\\`svg\\n${svgText}\\n\\`\\`\\``,\n          };\n          newParts.push(textPart);\n        } catch (error) {\n          const errorMessage =\n            error instanceof Error ? error.message : \"Failed to decode SVG attachment.\";\n          const textPart: MuxTextPart = {\n            type: \"text\",\n            text: `[SVG attachment omitted from provider request: ${errorMessage}]`,\n          };\n          newParts.push(textPart);\n        }\n        continue;\n      }\n\n      newParts.push(part);\n    }\n\n    return {\n      ...msg,\n      parts: newParts,\n    };\n  });\n\n  return didChange ? result : messages;\n}\n"]}