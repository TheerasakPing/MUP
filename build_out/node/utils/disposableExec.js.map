{"version":3,"file":"disposableExec.js","sourceRoot":"","sources":["../../../src/node/utils/disposableExec.ts"],"names":[],"mappings":"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","sourcesContent":["import { exec, execFileSync } from \"child_process\";\nimport type { ChildProcess } from \"child_process\";\n\nexport function killProcessTree(pid: number): void {\n  if (!Number.isFinite(pid) || pid <= 0) {\n    return;\n  }\n\n  // process.kill(-pid) is Unix-only; on Windows we must use taskkill to kill the full tree.\n  if (process.platform === \"win32\") {\n    try {\n      execFileSync(\"taskkill\", [\"/PID\", String(pid), \"/T\", \"/F\"], {\n        stdio: \"ignore\",\n        windowsHide: true,\n      });\n    } catch {\n      // Ignore errors - process may already have exited.\n    }\n\n    return;\n  }\n\n  // Prefer killing the entire process group. This requires the target process to be a group leader.\n  try {\n    process.kill(-pid, \"SIGKILL\");\n  } catch {\n    // Fall back to just the individual process.\n    try {\n      process.kill(pid, \"SIGKILL\");\n    } catch {\n      // ignore\n    }\n  }\n}\n\n/**\n * Disposable wrapper for child processes that ensures immediate cleanup.\n * Implements TypeScript's explicit resource management (using) for process lifecycle.\n *\n * All registered cleanup callbacks execute immediately when disposed, either:\n * - Explicitly via Symbol.dispose\n * - Automatically when exiting a `using` block\n * - On process exit\n *\n * Usage:\n *   const process = spawn(\"command\");\n *   const disposable = new DisposableProcess(process);\n *   disposable.addCleanup(() => stream.destroy());\n *   // Cleanup runs automatically on process exit\n */\nexport class DisposableProcess implements Disposable {\n  private cleanupCallbacks: Array<() => void> = [];\n  private disposed = false;\n\n  constructor(private readonly process: ChildProcess) {\n    // No auto-cleanup - callers explicitly dispose via timeout/abort handlers\n    // Process streams close naturally when process exits\n  }\n\n  /**\n   * Register cleanup callback to run when process is disposed.\n   * If already disposed, runs immediately.\n   */\n  addCleanup(callback: () => void): void {\n    if (this.disposed) {\n      // Already disposed, run immediately\n      try {\n        callback();\n      } catch {\n        // Ignore errors during cleanup\n      }\n    } else {\n      this.cleanupCallbacks.push(callback);\n    }\n  }\n\n  /**\n   * Get the underlying child process\n   */\n  get underlying(): ChildProcess {\n    return this.process;\n  }\n\n  /**\n   * Cleanup: kill process + run all cleanup callbacks immediately.\n   * Safe to call multiple times (idempotent).\n   */\n  [Symbol.dispose](): void {\n    if (this.disposed) return;\n    this.disposed = true;\n\n    // Kill process if still running\n    // Check both exitCode and signalCode to avoid calling kill() on already-dead processes\n    // When a process exits via signal (e.g., segfault, kill $$), exitCode is null but signalCode is set\n    if (\n      !this.process.killed &&\n      this.process.exitCode === null &&\n      this.process.signalCode === null\n    ) {\n      // On Windows, childProcess.kill() does not terminate the full process tree.\n      // Use taskkill /T to avoid leaking child processes (e.g., spawned by Git Bash).\n      const pid = this.process.pid;\n      if (pid !== undefined && pid > 0) {\n        killProcessTree(pid);\n      } else {\n        try {\n          this.process.kill(\"SIGKILL\");\n        } catch {\n          // Ignore ESRCH errors - process may have exited between check and kill\n        }\n      }\n    }\n\n    // Run all cleanup callbacks\n    for (const callback of this.cleanupCallbacks) {\n      try {\n        callback();\n      } catch {\n        // Ignore cleanup errors - we're tearing down anyway\n      }\n    }\n\n    this.cleanupCallbacks = [];\n  }\n}\n\n/**\n * Disposable wrapper for exec that ensures child process cleanup.\n * Prevents zombie processes by killing child when scope exits.\n *\n * Usage:\n *   using proc = execAsync(\"git status\");\n *   const { stdout } = await proc.result;\n */\nclass DisposableExec implements Disposable {\n  constructor(\n    private readonly promise: Promise<{ stdout: string; stderr: string }>,\n    private readonly child: ChildProcess\n  ) {}\n\n  [Symbol.dispose](): void {\n    // Only kill if process hasn't exited naturally\n    // Check the child's actual exit state, not promise state (avoids async timing issues)\n    const hasExited = this.child.exitCode !== null || this.child.signalCode !== null;\n    if (!hasExited && !this.child.killed) {\n      this.child.kill();\n    }\n  }\n\n  get result() {\n    return this.promise;\n  }\n}\n\n/**\n * Options for execAsync.\n */\nexport interface ExecAsyncOptions {\n  /** Shell to use for command execution. If not specified, uses system default (cmd.exe on Windows). */\n  shell?: string;\n}\n\n/**\n * Execute command with automatic cleanup via `using` declaration.\n * Prevents zombie processes by ensuring child is reaped even on error.\n *\n * @example\n * using proc = execAsync(\"git status\");\n * const { stdout } = await proc.result;\n *\n * // With explicit shell (needed for POSIX commands on Windows)\n * using proc = execAsync(\"nohup bash -c ...\", { shell: getBashPath() });\n */\nexport function execAsync(command: string, options?: ExecAsyncOptions): DisposableExec {\n  // Child processes inherit process.env automatically, which includes\n  // the enriched PATH set by initShellEnv() at startup\n  const child = exec(command, { shell: options?.shell });\n  const promise = new Promise<{ stdout: string; stderr: string }>((resolve, reject) => {\n    let stdout = \"\";\n    let stderr = \"\";\n    let exitCode: number | null = null;\n    let exitSignal: string | null = null;\n\n    child.stdout?.on(\"data\", (data) => {\n      stdout += data;\n    });\n    child.stderr?.on(\"data\", (data) => {\n      stderr += data;\n    });\n\n    // Use 'close' event instead of 'exit' - close fires after all stdio streams are closed\n    // This ensures we've received all buffered output before resolving/rejecting\n    child.on(\"exit\", (code, signal) => {\n      exitCode = code;\n      exitSignal = signal;\n    });\n\n    child.on(\"close\", () => {\n      // Only resolve if process exited cleanly (code 0, no signal)\n      if (exitCode === 0 && exitSignal === null) {\n        resolve({ stdout, stderr });\n      } else {\n        // Include stderr in error message for better debugging\n        const errorMsg =\n          stderr.trim() ||\n          (exitSignal\n            ? `Command killed by signal ${exitSignal}`\n            : `Command failed with exit code ${exitCode ?? \"unknown\"}`);\n        const error = new Error(errorMsg) as Error & {\n          code: number | null;\n          signal: string | null;\n          stdout: string;\n          stderr: string;\n        };\n        error.code = exitCode;\n        error.signal = exitSignal;\n        error.stdout = stdout;\n        error.stderr = stderr;\n        reject(error);\n      }\n    });\n\n    child.on(\"error\", reject);\n  });\n\n  return new DisposableExec(promise, child);\n}\n"]}