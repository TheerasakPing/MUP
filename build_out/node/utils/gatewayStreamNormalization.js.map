{"version":3,"file":"gatewayStreamNormalization.js","sourceRoot":"","sources":["../../../src/node/utils/gatewayStreamNormalization.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Gateway stream normalization utilities.\n *\n * The @ai-sdk/gateway SDK declares specificationVersion \"v3\", so the AI SDK\n * core expects v3-format stream events. But the mux gateway server may send\n * \"finish\" events with flat v2-style usage or plain string finishReason.\n * These utilities detect and convert to v3 format so the AI SDK can extract\n * usage (inputTokens, outputTokens, etc.) correctly.\n *\n * Without this normalization, asLanguageModelUsage() does usage.inputTokens.total\n * which yields undefined when inputTokens is a number (flat v2 format), causing\n * the Cost panel to show 0 tokens.\n */\n\n/**\n * V3 specification protocol usage format (nested).\n * The AI SDK core's asLanguageModelUsage() expects this shape.\n */\nexport interface V3Usage {\n  inputTokens: { total?: number; noCache?: number; cacheRead?: number; cacheWrite?: number };\n  outputTokens: { total?: number; text?: number; reasoning?: number };\n  raw?: unknown;\n}\n\n/**\n * Check whether a usage value is already in v3 nested format.\n * V3 usage has inputTokens as an object with a `total` field;\n * v2/flat usage has inputTokens as a number.\n */\nexport function isV3Usage(usage: unknown): usage is V3Usage {\n  if (typeof usage !== \"object\" || usage == null) return false;\n  const u = usage as Record<string, unknown>;\n  return typeof u.inputTokens === \"object\" && u.inputTokens != null;\n}\n\n/**\n * Convert flat (v2-style) usage to v3 nested format.\n */\nexport function flatUsageToV3(usage: Record<string, unknown>): V3Usage {\n  const inputTokens = typeof usage.inputTokens === \"number\" ? usage.inputTokens : undefined;\n  const outputTokens = typeof usage.outputTokens === \"number\" ? usage.outputTokens : undefined;\n  const cachedInputTokens =\n    typeof usage.cachedInputTokens === \"number\" ? usage.cachedInputTokens : undefined;\n  const reasoningTokens =\n    typeof usage.reasoningTokens === \"number\" ? usage.reasoningTokens : undefined;\n\n  return {\n    inputTokens: {\n      total: inputTokens,\n      noCache:\n        inputTokens != null && cachedInputTokens != null\n          ? inputTokens - cachedInputTokens\n          : undefined,\n      cacheRead: cachedInputTokens,\n      cacheWrite: undefined,\n    },\n    outputTokens: {\n      total: outputTokens,\n      text:\n        outputTokens != null && reasoningTokens != null\n          ? outputTokens - reasoningTokens\n          : undefined,\n      reasoning: reasoningTokens,\n    },\n    raw: usage,\n  };\n}\n\n/**\n * Normalize a finish-reason value to v3 format { unified, raw }.\n * The gateway server may send a plain string instead of the nested object.\n */\nexport function normalizeFinishReason(fr: unknown): { unified: string; raw: unknown } | undefined {\n  if (fr == null) return undefined;\n  if (typeof fr === \"object\" && \"unified\" in (fr as Record<string, unknown>)) {\n    return fr as { unified: string; raw: unknown };\n  }\n  // Plain string → convert to v3 object\n  const str = typeof fr === \"string\" ? fr : \"other\";\n  return { unified: str === \"unknown\" ? \"other\" : str, raw: str };\n}\n\n/**\n * Normalize a doGenerate result from the gateway.\n * Converts flat usage and plain-string finishReason to v3 nested format.\n */\nexport function normalizeGatewayGenerateResult<T extends Record<string, unknown>>(result: T): T {\n  const normalized: Record<string, unknown> = { ...result };\n\n  if (result.usage != null && !isV3Usage(result.usage)) {\n    normalized.usage = flatUsageToV3(result.usage as Record<string, unknown>);\n  }\n\n  if (result.finishReason != null) {\n    const fr = normalizeFinishReason(result.finishReason);\n    if (fr) normalized.finishReason = fr;\n  }\n\n  return normalized as T;\n}\n\n/**\n * TransformStream that normalizes gateway SSE stream events.\n *\n * Only transforms \"finish\" events; all other chunks pass through unchanged.\n */\nexport function normalizeGatewayStreamUsage(): TransformStream {\n  return new TransformStream({\n    transform(chunk: unknown, controller: TransformStreamDefaultController) {\n      if (typeof chunk !== \"object\" || chunk == null) {\n        controller.enqueue(chunk);\n        return;\n      }\n\n      const c = chunk as Record<string, unknown>;\n      if (c.type !== \"finish\") {\n        controller.enqueue(chunk);\n        return;\n      }\n\n      // Normalize usage: convert flat → v3 nested if needed\n      let usage = c.usage;\n      if (usage != null && !isV3Usage(usage)) {\n        usage = flatUsageToV3(usage as Record<string, unknown>);\n      }\n\n      // Normalize finishReason: convert string → { unified, raw } if needed\n      const finishReason = normalizeFinishReason(c.finishReason);\n\n      controller.enqueue({\n        ...c,\n        ...(usage != null && { usage }),\n        ...(finishReason != null && { finishReason }),\n      });\n    },\n  });\n}\n"]}