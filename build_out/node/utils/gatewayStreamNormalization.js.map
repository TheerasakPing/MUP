{"version":3,"file":"gatewayStreamNormalization.js","sourceRoot":"","sources":["../../../src/node/utils/gatewayStreamNormalization.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Gateway stream normalization utilities.\r\n *\r\n * The @ai-sdk/gateway SDK declares specificationVersion \"v3\", so the AI SDK\r\n * core expects v3-format stream events. But the mux gateway server may send\r\n * \"finish\" events with flat v2-style usage or plain string finishReason.\r\n * These utilities detect and convert to v3 format so the AI SDK can extract\r\n * usage (inputTokens, outputTokens, etc.) correctly.\r\n *\r\n * Without this normalization, asLanguageModelUsage() does usage.inputTokens.total\r\n * which yields undefined when inputTokens is a number (flat v2 format), causing\r\n * the Cost panel to show 0 tokens.\r\n */\r\n\r\n/**\r\n * V3 specification protocol usage format (nested).\r\n * The AI SDK core's asLanguageModelUsage() expects this shape.\r\n */\r\nexport interface V3Usage {\r\n  inputTokens: { total?: number; noCache?: number; cacheRead?: number; cacheWrite?: number };\r\n  outputTokens: { total?: number; text?: number; reasoning?: number };\r\n  raw?: unknown;\r\n}\r\n\r\n/**\r\n * Check whether a usage value is already in v3 nested format.\r\n * V3 usage has inputTokens as an object with a `total` field;\r\n * v2/flat usage has inputTokens as a number.\r\n */\r\nexport function isV3Usage(usage: unknown): usage is V3Usage {\r\n  if (typeof usage !== \"object\" || usage == null) return false;\r\n  const u = usage as Record<string, unknown>;\r\n  return typeof u.inputTokens === \"object\" && u.inputTokens != null;\r\n}\r\n\r\n/**\r\n * Convert flat (v2-style) usage to v3 nested format.\r\n */\r\nexport function flatUsageToV3(usage: Record<string, unknown>): V3Usage {\r\n  const inputTokens = typeof usage.inputTokens === \"number\" ? usage.inputTokens : undefined;\r\n  const outputTokens = typeof usage.outputTokens === \"number\" ? usage.outputTokens : undefined;\r\n  const cachedInputTokens =\r\n    typeof usage.cachedInputTokens === \"number\" ? usage.cachedInputTokens : undefined;\r\n  const reasoningTokens =\r\n    typeof usage.reasoningTokens === \"number\" ? usage.reasoningTokens : undefined;\r\n\r\n  return {\r\n    inputTokens: {\r\n      total: inputTokens,\r\n      noCache:\r\n        inputTokens != null && cachedInputTokens != null\r\n          ? inputTokens - cachedInputTokens\r\n          : undefined,\r\n      cacheRead: cachedInputTokens,\r\n      cacheWrite: undefined,\r\n    },\r\n    outputTokens: {\r\n      total: outputTokens,\r\n      text:\r\n        outputTokens != null && reasoningTokens != null\r\n          ? outputTokens - reasoningTokens\r\n          : undefined,\r\n      reasoning: reasoningTokens,\r\n    },\r\n    raw: usage,\r\n  };\r\n}\r\n\r\n/**\r\n * Normalize a finish-reason value to v3 format { unified, raw }.\r\n * The gateway server may send a plain string instead of the nested object.\r\n */\r\nexport function normalizeFinishReason(fr: unknown): { unified: string; raw: unknown } | undefined {\r\n  if (fr == null) return undefined;\r\n  if (typeof fr === \"object\" && \"unified\" in (fr as Record<string, unknown>)) {\r\n    return fr as { unified: string; raw: unknown };\r\n  }\r\n  // Plain string → convert to v3 object\r\n  const str = typeof fr === \"string\" ? fr : \"other\";\r\n  return { unified: str === \"unknown\" ? \"other\" : str, raw: str };\r\n}\r\n\r\n/**\r\n * Normalize a doGenerate result from the gateway.\r\n * Converts flat usage and plain-string finishReason to v3 nested format.\r\n */\r\nexport function normalizeGatewayGenerateResult<T extends Record<string, unknown>>(result: T): T {\r\n  const normalized: Record<string, unknown> = { ...result };\r\n\r\n  if (result.usage != null && !isV3Usage(result.usage)) {\r\n    normalized.usage = flatUsageToV3(result.usage as Record<string, unknown>);\r\n  }\r\n\r\n  if (result.finishReason != null) {\r\n    const fr = normalizeFinishReason(result.finishReason);\r\n    if (fr) normalized.finishReason = fr;\r\n  }\r\n\r\n  return normalized as T;\r\n}\r\n\r\n/**\r\n * TransformStream that normalizes gateway SSE stream events.\r\n *\r\n * Only transforms \"finish\" events; all other chunks pass through unchanged.\r\n */\r\nexport function normalizeGatewayStreamUsage(): TransformStream {\r\n  return new TransformStream({\r\n    transform(chunk: unknown, controller: TransformStreamDefaultController) {\r\n      if (typeof chunk !== \"object\" || chunk == null) {\r\n        controller.enqueue(chunk);\r\n        return;\r\n      }\r\n\r\n      const c = chunk as Record<string, unknown>;\r\n      if (c.type !== \"finish\") {\r\n        controller.enqueue(chunk);\r\n        return;\r\n      }\r\n\r\n      // Normalize usage: convert flat → v3 nested if needed\r\n      let usage = c.usage;\r\n      if (usage != null && !isV3Usage(usage)) {\r\n        usage = flatUsageToV3(usage as Record<string, unknown>);\r\n      }\r\n\r\n      // Normalize finishReason: convert string → { unified, raw } if needed\r\n      const finishReason = normalizeFinishReason(c.finishReason);\r\n\r\n      controller.enqueue({\r\n        ...c,\r\n        ...(usage != null && { usage }),\r\n        ...(finishReason != null && { finishReason }),\r\n      });\r\n    },\r\n  });\r\n}\r\n"]}