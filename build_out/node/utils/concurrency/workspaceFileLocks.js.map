{"version":3,"file":"workspaceFileLocks.js","sourceRoot":"","sources":["../../../../src/node/utils/concurrency/workspaceFileLocks.ts"],"names":[],"mappings":";;;AAAA,yCAAsC;AAEtC;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BG;AACU,QAAA,kBAAkB,GAAG,IAAI,mBAAQ,EAAU,CAAC","sourcesContent":["import { MutexMap } from \"./mutexMap\";\r\n\r\n/**\r\n * Shared file operation lock for all workspace-related file services.\r\n *\r\n * Why this exists:\r\n * Multiple services (HistoryService, PartialService) operate on files within\r\n * the same workspace directory. When these services call each other while holding\r\n * locks, separate mutex instances can cause deadlock:\r\n *\r\n * Deadlock scenario with separate locks:\r\n * 1. PartialService.commitToHistory() acquires partialService.fileLocks[workspace]\r\n * 2. Inside commitToHistory, calls historyService.updateHistory()\r\n * 3. historyService.updateHistory() tries to acquire historyService.fileLocks[workspace]\r\n * 4. If another operation holds historyService.fileLocks and tries to acquire\r\n *    partialService.fileLocks â†’ DEADLOCK\r\n *\r\n * Solution:\r\n * All workspace file services share this single MutexMap instance. This ensures:\r\n * - Only one file operation per workspace at a time across ALL services\r\n * - Nested calls within the same operation won't try to re-acquire the lock\r\n *   (MutexMap allows this by queuing operations)\r\n * - No deadlock from lock ordering issues\r\n *\r\n * Trade-off:\r\n * This is more conservative than separate locks (less concurrency) but guarantees\r\n * correctness. Since file operations are fast (ms range), the performance impact\r\n * is negligible compared to AI API calls (seconds range).\r\n */\r\nexport const workspaceFileLocks = new MutexMap<string>();\r\n"]}