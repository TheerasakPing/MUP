{"version":3,"file":"asyncMutex.js","sourceRoot":"","sources":["../../../../src/node/utils/concurrency/asyncMutex.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;;;;;;GAaG;AACH;IACU,MAAM,GAAG,KAAK,CAAC;IACf,KAAK,GAAsB,EAAE,CAAC;IAEtC;;;OAGG;IACH,KAAK,CAAC,OAAO,GAA4B;QACvC,wCAAwC;QACxC,OAAO,IAAI,CAAC,MAAM,EAAE,CAAC;YACnB,MAAM,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;QACjE,CAAC;QAED,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,OAAO,IAAI,cAAc,CAAC,IAAI,CAAC,CAAC;IAAA,CACjC;IAED;;;OAGG;IACH,OAAO,GAAS;QACd,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;QAChC,IAAI,IAAI,EAAE,CAAC;YACT,IAAI,EAAE,CAAC,CAAC,sBAAsB;QAChC,CAAC;IAAA,CACF;CACF;;AAED;;;;;GAKG;AACH,MAAM,cAAc;IACW,KAAK;IAAlC,YAA6B,KAAiB,EAAE;qBAAnB,KAAK;IAAe,CAAC;IAElD;;OAEG;IACH,CAAC,MAAM,CAAC,YAAY,CAAC,GAAkB;QACrC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;QACrB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAAA,CAC1B;CACF","sourcesContent":["/**\r\n * AsyncMutex - A mutual exclusion lock for async operations\r\n *\r\n * Ensures only one async operation can hold the lock at a time.\r\n * Uses `using` declarations for guaranteed lock release.\r\n *\r\n * Example:\r\n * ```typescript\r\n * const mutex = new AsyncMutex();\r\n * await using lock = await mutex.acquire();\r\n * // Critical section - only one execution at a time\r\n * // Lock automatically released when scope exits\r\n * ```\r\n */\r\nexport class AsyncMutex {\r\n  private locked = false;\r\n  private queue: Array<() => void> = [];\r\n\r\n  /**\r\n   * Acquire the lock. Blocks until lock is available.\r\n   * Returns an AsyncDisposable lock that auto-releases on scope exit.\r\n   */\r\n  async acquire(): Promise<AsyncMutexLock> {\r\n    // Wait in queue until lock is available\r\n    while (this.locked) {\r\n      await new Promise<void>((resolve) => this.queue.push(resolve));\r\n    }\r\n\r\n    this.locked = true;\r\n    return new AsyncMutexLock(this);\r\n  }\r\n\r\n  /**\r\n   * Release the lock and wake up next waiter in queue\r\n   * @internal - Should only be called by AsyncMutexLock\r\n   */\r\n  release(): void {\r\n    this.locked = false;\r\n    const next = this.queue.shift();\r\n    if (next) {\r\n      next(); // Wake up next waiter\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * AsyncMutexLock - Auto-releasing lock handle\r\n *\r\n * Implements AsyncDisposable to ensure lock is released when scope exits.\r\n * This provides static compile-time guarantees against lock leaks.\r\n */\r\nclass AsyncMutexLock implements AsyncDisposable {\r\n  constructor(private readonly mutex: AsyncMutex) {}\r\n\r\n  /**\r\n   * Release the lock when the `using` block exits\r\n   */\r\n  [Symbol.asyncDispose](): Promise<void> {\r\n    this.mutex.release();\r\n    return Promise.resolve();\r\n  }\r\n}\r\n"]}