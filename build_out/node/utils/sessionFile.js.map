{"version":3,"file":"sessionFile.js","sourceRoot":"","sources":["../../../src/node/utils/sessionFile.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs/promises\";\r\nimport * as path from \"path\";\r\nimport writeFileAtomic from \"write-file-atomic\";\r\nimport type { Result } from \"@/common/types/result\";\r\nimport { Ok, Err } from \"@/common/types/result\";\r\nimport type { Config } from \"@/node/config\";\r\nimport { workspaceFileLocks } from \"@/node/utils/concurrency/workspaceFileLocks\";\r\nimport { log } from \"@/node/services/log\";\r\n\r\nexport interface SessionFileWriteOptions {\r\n  /**\r\n   * Optional guard that runs *after* the workspace file lock is acquired but *before*\r\n   * the session directory is created.\r\n   *\r\n   * If it returns false, the write is skipped.\r\n   */\r\n  shouldWrite?: () => boolean;\r\n}\r\n\r\n/**\r\n * Shared utility for managing JSON files in workspace session directories.\r\n * Provides consistent file locking, error handling, and path resolution.\r\n *\r\n * Used by PartialService, InitStateManager, and other services that need\r\n * to persist state to ~/.mux/sessions/{workspaceId}/.\r\n */\r\nexport class SessionFileManager<T> {\r\n  private readonly config: Config;\r\n  private readonly fileName: string;\r\n  private readonly fileLocks = workspaceFileLocks;\r\n\r\n  constructor(config: Config, fileName: string) {\r\n    this.config = config;\r\n    this.fileName = fileName;\r\n  }\r\n\r\n  private getFilePath(workspaceId: string): string {\r\n    return path.join(this.config.getSessionDir(workspaceId), this.fileName);\r\n  }\r\n\r\n  /**\r\n   * Read JSON file from workspace session directory.\r\n   * Returns null if file doesn't exist (not an error).\r\n   */\r\n  async read(workspaceId: string): Promise<T | null> {\r\n    try {\r\n      const filePath = this.getFilePath(workspaceId);\r\n      const data = await fs.readFile(filePath, \"utf-8\");\r\n      return JSON.parse(data) as T;\r\n    } catch (error) {\r\n      if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\r\n        return null; // File doesn't exist\r\n      }\r\n      // Log other errors but don't fail\r\n      log.error(`Error reading ${this.fileName}:`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write JSON file to workspace session directory with file locking.\r\n   * Creates session directory if it doesn't exist.\r\n   *\r\n   * If options.shouldWrite returns false, the write is skipped (and the session\r\n   * directory is not created).\r\n   */\r\n  async write(\r\n    workspaceId: string,\r\n    data: T,\r\n    options?: SessionFileWriteOptions\r\n  ): Promise<Result<void>> {\r\n    return this.fileLocks.withLock(workspaceId, async () => {\r\n      try {\r\n        if (options?.shouldWrite && !options.shouldWrite()) {\r\n          return Ok(undefined);\r\n        }\r\n\r\n        const sessionDir = this.config.getSessionDir(workspaceId);\r\n        await fs.mkdir(sessionDir, { recursive: true });\r\n        const filePath = this.getFilePath(workspaceId);\r\n        // Atomic write prevents corruption if app crashes mid-write\r\n        await writeFileAtomic(filePath, JSON.stringify(data, null, 2));\r\n        return Ok(undefined);\r\n      } catch (error) {\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        return Err(`Failed to write ${this.fileName}: ${message}`);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Delete JSON file from workspace session directory with file locking.\r\n   * Idempotent - no error if file doesn't exist.\r\n   */\r\n  async delete(workspaceId: string): Promise<Result<void>> {\r\n    return this.fileLocks.withLock(workspaceId, async () => {\r\n      try {\r\n        const filePath = this.getFilePath(workspaceId);\r\n        await fs.unlink(filePath);\r\n        return Ok(undefined);\r\n      } catch (error) {\r\n        if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\r\n          return Ok(undefined); // Already deleted\r\n        }\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        return Err(`Failed to delete ${this.fileName}: ${message}`);\r\n      }\r\n    });\r\n  }\r\n}\r\n"]}