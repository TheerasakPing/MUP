{"version":3,"file":"sessionFile.js","sourceRoot":"","sources":["../../../src/node/utils/sessionFile.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport writeFileAtomic from \"write-file-atomic\";\nimport type { Result } from \"@/common/types/result\";\nimport { Ok, Err } from \"@/common/types/result\";\nimport type { Config } from \"@/node/config\";\nimport { workspaceFileLocks } from \"@/node/utils/concurrency/workspaceFileLocks\";\nimport { log } from \"@/node/services/log\";\n\nexport interface SessionFileWriteOptions {\n  /**\n   * Optional guard that runs *after* the workspace file lock is acquired but *before*\n   * the session directory is created.\n   *\n   * If it returns false, the write is skipped.\n   */\n  shouldWrite?: () => boolean;\n}\n\n/**\n * Shared utility for managing JSON files in workspace session directories.\n * Provides consistent file locking, error handling, and path resolution.\n *\n * Used by PartialService, InitStateManager, and other services that need\n * to persist state to ~/.mux/sessions/{workspaceId}/.\n */\nexport class SessionFileManager<T> {\n  private readonly config: Config;\n  private readonly fileName: string;\n  private readonly fileLocks = workspaceFileLocks;\n\n  constructor(config: Config, fileName: string) {\n    this.config = config;\n    this.fileName = fileName;\n  }\n\n  private getFilePath(workspaceId: string): string {\n    return path.join(this.config.getSessionDir(workspaceId), this.fileName);\n  }\n\n  /**\n   * Read JSON file from workspace session directory.\n   * Returns null if file doesn't exist (not an error).\n   */\n  async read(workspaceId: string): Promise<T | null> {\n    try {\n      const filePath = this.getFilePath(workspaceId);\n      const data = await fs.readFile(filePath, \"utf-8\");\n      return JSON.parse(data) as T;\n    } catch (error) {\n      if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\n        return null; // File doesn't exist\n      }\n      // Log other errors but don't fail\n      log.error(`Error reading ${this.fileName}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Write JSON file to workspace session directory with file locking.\n   * Creates session directory if it doesn't exist.\n   *\n   * If options.shouldWrite returns false, the write is skipped (and the session\n   * directory is not created).\n   */\n  async write(\n    workspaceId: string,\n    data: T,\n    options?: SessionFileWriteOptions\n  ): Promise<Result<void>> {\n    return this.fileLocks.withLock(workspaceId, async () => {\n      try {\n        if (options?.shouldWrite && !options.shouldWrite()) {\n          return Ok(undefined);\n        }\n\n        const sessionDir = this.config.getSessionDir(workspaceId);\n        await fs.mkdir(sessionDir, { recursive: true });\n        const filePath = this.getFilePath(workspaceId);\n        // Atomic write prevents corruption if app crashes mid-write\n        await writeFileAtomic(filePath, JSON.stringify(data, null, 2));\n        return Ok(undefined);\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        return Err(`Failed to write ${this.fileName}: ${message}`);\n      }\n    });\n  }\n\n  /**\n   * Delete JSON file from workspace session directory with file locking.\n   * Idempotent - no error if file doesn't exist.\n   */\n  async delete(workspaceId: string): Promise<Result<void>> {\n    return this.fileLocks.withLock(workspaceId, async () => {\n      try {\n        const filePath = this.getFilePath(workspaceId);\n        await fs.unlink(filePath);\n        return Ok(undefined);\n      } catch (error) {\n        if (error && typeof error === \"object\" && \"code\" in error && error.code === \"ENOENT\") {\n          return Ok(undefined); // Already deleted\n        }\n        const message = error instanceof Error ? error.message : String(error);\n        return Err(`Failed to delete ${this.fileName}: ${message}`);\n      }\n    });\n  }\n}\n"]}