{"version":3,"file":"eventStore.js","sourceRoot":"","sources":["../../../src/node/utils/eventStore.ts"],"names":[],"mappings":"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","sourcesContent":["import { SessionFileManager, type SessionFileWriteOptions } from \"@/node/utils/sessionFile\";\nimport type { Config } from \"@/node/config\";\nimport { log } from \"@/node/services/log\";\n\n/**\n * EventStore - Generic state management with persistence and replay for workspace events.\n *\n * This abstraction captures the common pattern between InitStateManager and StreamManager:\n * 1. In-memory Map for active state\n * 2. Disk persistence for crash recovery / page reload\n * 3. Replay by serializing state into events and emitting them\n *\n * Type parameters:\n * - TState: The state object stored in memory/disk (e.g., InitStatus, WorkspaceStreamInfo)\n * - TEvent: The event type emitted (e.g., WorkspaceInitEvent)\n *\n * Design pattern:\n * - Composition over inheritance (doesn't extend EventEmitter directly)\n * - Subclasses provide serialization logic (state → events)\n * - Handles common operations (get/set/delete state, persist, replay)\n *\n * Example usage:\n *\n * class InitStateManager {\n *   private store = new EventStore<InitStatus, WorkspaceInitEvent>(\n *     config,\n *     \"init-status.json\",\n *     (state) => this.serializeInitEvents(state),\n *     (event) => this.emit(event.type, event)\n *   );\n *\n *   async replayInit(workspaceId: string) {\n *     await this.store.replay(workspaceId);\n *   }\n * }\n */\nexport class EventStore<TState, TEvent> {\n  private stateMap = new Map<string, TState>();\n  private readonly fileManager: SessionFileManager<TState>;\n  private readonly serializeState: (state: TState) => TEvent[];\n  private readonly emitEvent: (event: TEvent) => void;\n  private readonly storeName: string;\n\n  /**\n   * Create a new EventStore.\n   *\n   * @param config - Config object for SessionFileManager\n   * @param filename - Filename for persisted state (e.g., \"init-status.json\")\n   * @param serializeState - Function to convert state into array of events for replay\n   * @param emitEvent - Function to emit a single event (typically wraps EventEmitter.emit)\n   * @param storeName - Name for logging (e.g., \"InitStateManager\")\n   */\n  constructor(\n    config: Config,\n    filename: string,\n    serializeState: (state: TState) => TEvent[],\n    emitEvent: (event: TEvent) => void,\n    storeName = \"EventStore\"\n  ) {\n    this.fileManager = new SessionFileManager<TState>(config, filename);\n    this.serializeState = serializeState;\n    this.emitEvent = emitEvent;\n    this.storeName = storeName;\n  }\n\n  /**\n   * Get in-memory state for a workspace.\n   * Returns undefined if no state exists.\n   */\n  getState(workspaceId: string): TState | undefined {\n    return this.stateMap.get(workspaceId);\n  }\n\n  /**\n   * Set in-memory state for a workspace.\n   */\n  setState(workspaceId: string, state: TState): void {\n    this.stateMap.set(workspaceId, state);\n  }\n\n  /**\n   * Delete in-memory state for a workspace.\n   * Does NOT delete the persisted file (use deletePersisted for that).\n   */\n  deleteState(workspaceId: string): void {\n    this.stateMap.delete(workspaceId);\n  }\n\n  /**\n   * Check if in-memory state exists for a workspace.\n   */\n  hasState(workspaceId: string): boolean {\n    return this.stateMap.has(workspaceId);\n  }\n\n  /**\n   * Read persisted state from disk.\n   * Returns null if no file exists.\n   */\n  async readPersisted(workspaceId: string): Promise<TState | null> {\n    return this.fileManager.read(workspaceId);\n  }\n\n  /**\n   * Write state to disk.\n   * Logs errors but doesn't throw (fire-and-forget pattern).\n   */\n  async persist(\n    workspaceId: string,\n    state: TState,\n    options?: SessionFileWriteOptions\n  ): Promise<void> {\n    const result = await this.fileManager.write(workspaceId, state, options);\n    if (!result.success) {\n      log.error(`[${this.storeName}] Failed to persist state for ${workspaceId}: ${result.error}`);\n    }\n  }\n\n  /**\n   * Delete persisted state from disk.\n   * Does NOT clear in-memory state (use deleteState for that).\n   */\n  async deletePersisted(workspaceId: string): Promise<void> {\n    const result = await this.fileManager.delete(workspaceId);\n    if (!result.success) {\n      log.error(\n        `[${this.storeName}] Failed to delete persisted state for ${workspaceId}: ${result.error}`\n      );\n    }\n  }\n\n  /**\n   * Replay events for a workspace.\n   * Checks in-memory state first, falls back to disk.\n   * Emits events using the provided emitEvent function.\n   *\n   * @param workspaceId - Workspace ID to replay events for\n   * @param context - Optional context to pass to serializeState (e.g., workspaceId)\n   */\n  async replay(workspaceId: string, context?: Record<string, unknown>): Promise<void> {\n    // Try in-memory state first (most recent)\n    let state: TState | undefined = this.stateMap.get(workspaceId);\n\n    // Fall back to disk if not in memory\n    if (!state) {\n      const diskState = await this.fileManager.read(workspaceId);\n      if (!diskState) {\n        return; // No state to replay\n      }\n      state = diskState;\n    }\n\n    // Augment state with context for serialization\n    const augmentedState = { ...state, ...context };\n\n    // Serialize state into events and emit them\n    const events = this.serializeState(augmentedState);\n    for (const event of events) {\n      this.emitEvent(event);\n    }\n  }\n\n  /**\n   * Get all workspace IDs with in-memory state.\n   * Useful for debugging or cleanup.\n   */\n  getActiveWorkspaceIds(): string[] {\n    return Array.from(this.stateMap.keys());\n  }\n}\n\n/**\n * FUTURE REFACTORING: StreamManager Pattern\n *\n * StreamManager (src/services/streamManager.ts) follows a similar pattern to InitStateManager\n * but has NOT been refactored to use EventStore yet due to:\n * 1. Complexity: StreamManager is 1332 LoC with intricate state machine logic\n * 2. Risk: Heavily tested streaming infrastructure (40+ integration tests)\n * 3. Lifecycle differences: Streams auto-cleanup on completion, init logs persist forever\n *\n * Future refactoring could extract:\n * - WorkspaceStreamInfo state management (workspaceStreams Map)\n * - Replay logic (replayStream method at line 1244)\n * - Partial persistence (currently using PartialService)\n *\n * Key differences to handle:\n * - StreamManager has complex throttling (partialWriteTimer, PARTIAL_WRITE_THROTTLE_MS)\n * - Different persistence strategy (partial.json → chat.jsonl → delete partial)\n * - AbortController integration for stream cancellation\n * - Token tracking and usage statistics\n *\n * Pattern for adoption:\n * 1. Extract WorkspaceStreamInfo → MessagePart[] serialization into helper\n * 2. Create EventStore instance for stream state (similar to InitStateManager)\n * 3. Replace manual replay loop (line 1270-1272) with store.replay()\n * 4. Keep existing throttling and persistence strategies (out of scope for EventStore)\n *\n * See InitStateManager refactor (this PR) for reference implementation.\n */\n"]}