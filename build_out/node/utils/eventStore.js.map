{"version":3,"file":"eventStore.js","sourceRoot":"","sources":["../../../src/node/utils/eventStore.ts"],"names":[],"mappings":"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","sourcesContent":["import { SessionFileManager, type SessionFileWriteOptions } from \"@/node/utils/sessionFile\";\r\nimport type { Config } from \"@/node/config\";\r\nimport { log } from \"@/node/services/log\";\r\n\r\n/**\r\n * EventStore - Generic state management with persistence and replay for workspace events.\r\n *\r\n * This abstraction captures the common pattern between InitStateManager and StreamManager:\r\n * 1. In-memory Map for active state\r\n * 2. Disk persistence for crash recovery / page reload\r\n * 3. Replay by serializing state into events and emitting them\r\n *\r\n * Type parameters:\r\n * - TState: The state object stored in memory/disk (e.g., InitStatus, WorkspaceStreamInfo)\r\n * - TEvent: The event type emitted (e.g., WorkspaceInitEvent)\r\n *\r\n * Design pattern:\r\n * - Composition over inheritance (doesn't extend EventEmitter directly)\r\n * - Subclasses provide serialization logic (state → events)\r\n * - Handles common operations (get/set/delete state, persist, replay)\r\n *\r\n * Example usage:\r\n *\r\n * class InitStateManager {\r\n *   private store = new EventStore<InitStatus, WorkspaceInitEvent>(\r\n *     config,\r\n *     \"init-status.json\",\r\n *     (state) => this.serializeInitEvents(state),\r\n *     (event) => this.emit(event.type, event)\r\n *   );\r\n *\r\n *   async replayInit(workspaceId: string) {\r\n *     await this.store.replay(workspaceId);\r\n *   }\r\n * }\r\n */\r\nexport class EventStore<TState, TEvent> {\r\n  private stateMap = new Map<string, TState>();\r\n  private readonly fileManager: SessionFileManager<TState>;\r\n  private readonly serializeState: (state: TState) => TEvent[];\r\n  private readonly emitEvent: (event: TEvent) => void;\r\n  private readonly storeName: string;\r\n\r\n  /**\r\n   * Create a new EventStore.\r\n   *\r\n   * @param config - Config object for SessionFileManager\r\n   * @param filename - Filename for persisted state (e.g., \"init-status.json\")\r\n   * @param serializeState - Function to convert state into array of events for replay\r\n   * @param emitEvent - Function to emit a single event (typically wraps EventEmitter.emit)\r\n   * @param storeName - Name for logging (e.g., \"InitStateManager\")\r\n   */\r\n  constructor(\r\n    config: Config,\r\n    filename: string,\r\n    serializeState: (state: TState) => TEvent[],\r\n    emitEvent: (event: TEvent) => void,\r\n    storeName = \"EventStore\"\r\n  ) {\r\n    this.fileManager = new SessionFileManager<TState>(config, filename);\r\n    this.serializeState = serializeState;\r\n    this.emitEvent = emitEvent;\r\n    this.storeName = storeName;\r\n  }\r\n\r\n  /**\r\n   * Get in-memory state for a workspace.\r\n   * Returns undefined if no state exists.\r\n   */\r\n  getState(workspaceId: string): TState | undefined {\r\n    return this.stateMap.get(workspaceId);\r\n  }\r\n\r\n  /**\r\n   * Set in-memory state for a workspace.\r\n   */\r\n  setState(workspaceId: string, state: TState): void {\r\n    this.stateMap.set(workspaceId, state);\r\n  }\r\n\r\n  /**\r\n   * Delete in-memory state for a workspace.\r\n   * Does NOT delete the persisted file (use deletePersisted for that).\r\n   */\r\n  deleteState(workspaceId: string): void {\r\n    this.stateMap.delete(workspaceId);\r\n  }\r\n\r\n  /**\r\n   * Check if in-memory state exists for a workspace.\r\n   */\r\n  hasState(workspaceId: string): boolean {\r\n    return this.stateMap.has(workspaceId);\r\n  }\r\n\r\n  /**\r\n   * Read persisted state from disk.\r\n   * Returns null if no file exists.\r\n   */\r\n  async readPersisted(workspaceId: string): Promise<TState | null> {\r\n    return this.fileManager.read(workspaceId);\r\n  }\r\n\r\n  /**\r\n   * Write state to disk.\r\n   * Logs errors but doesn't throw (fire-and-forget pattern).\r\n   */\r\n  async persist(\r\n    workspaceId: string,\r\n    state: TState,\r\n    options?: SessionFileWriteOptions\r\n  ): Promise<void> {\r\n    const result = await this.fileManager.write(workspaceId, state, options);\r\n    if (!result.success) {\r\n      log.error(`[${this.storeName}] Failed to persist state for ${workspaceId}: ${result.error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete persisted state from disk.\r\n   * Does NOT clear in-memory state (use deleteState for that).\r\n   */\r\n  async deletePersisted(workspaceId: string): Promise<void> {\r\n    const result = await this.fileManager.delete(workspaceId);\r\n    if (!result.success) {\r\n      log.error(\r\n        `[${this.storeName}] Failed to delete persisted state for ${workspaceId}: ${result.error}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Replay events for a workspace.\r\n   * Checks in-memory state first, falls back to disk.\r\n   * Emits events using the provided emitEvent function.\r\n   *\r\n   * @param workspaceId - Workspace ID to replay events for\r\n   * @param context - Optional context to pass to serializeState (e.g., workspaceId)\r\n   */\r\n  async replay(workspaceId: string, context?: Record<string, unknown>): Promise<void> {\r\n    // Try in-memory state first (most recent)\r\n    let state: TState | undefined = this.stateMap.get(workspaceId);\r\n\r\n    // Fall back to disk if not in memory\r\n    if (!state) {\r\n      const diskState = await this.fileManager.read(workspaceId);\r\n      if (!diskState) {\r\n        return; // No state to replay\r\n      }\r\n      state = diskState;\r\n    }\r\n\r\n    // Augment state with context for serialization\r\n    const augmentedState = { ...state, ...context };\r\n\r\n    // Serialize state into events and emit them\r\n    const events = this.serializeState(augmentedState);\r\n    for (const event of events) {\r\n      this.emitEvent(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all workspace IDs with in-memory state.\r\n   * Useful for debugging or cleanup.\r\n   */\r\n  getActiveWorkspaceIds(): string[] {\r\n    return Array.from(this.stateMap.keys());\r\n  }\r\n}\r\n\r\n/**\r\n * FUTURE REFACTORING: StreamManager Pattern\r\n *\r\n * StreamManager (src/services/streamManager.ts) follows a similar pattern to InitStateManager\r\n * but has NOT been refactored to use EventStore yet due to:\r\n * 1. Complexity: StreamManager is 1332 LoC with intricate state machine logic\r\n * 2. Risk: Heavily tested streaming infrastructure (40+ integration tests)\r\n * 3. Lifecycle differences: Streams auto-cleanup on completion, init logs persist forever\r\n *\r\n * Future refactoring could extract:\r\n * - WorkspaceStreamInfo state management (workspaceStreams Map)\r\n * - Replay logic (replayStream method at line 1244)\r\n * - Partial persistence (currently using PartialService)\r\n *\r\n * Key differences to handle:\r\n * - StreamManager has complex throttling (partialWriteTimer, PARTIAL_WRITE_THROTTLE_MS)\r\n * - Different persistence strategy (partial.json → chat.jsonl → delete partial)\r\n * - AbortController integration for stream cancellation\r\n * - Token tracking and usage statistics\r\n *\r\n * Pattern for adoption:\r\n * 1. Extract WorkspaceStreamInfo → MessagePart[] serialization into helper\r\n * 2. Create EventStore instance for stream state (similar to InitStateManager)\r\n * 3. Replace manual replay loop (line 1270-1272) with store.replay()\r\n * 4. Keep existing throttling and persistence strategies (out of scope for EventStore)\r\n *\r\n * See InitStateManager refactor (this PR) for reference implementation.\r\n */\r\n"]}