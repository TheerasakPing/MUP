{"version":3,"file":"instructionFiles.js","sourceRoot":"","sources":["../../../../src/node/utils/main/instructionFiles.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs/promises\";\r\nimport * as path from \"path\";\r\nimport type { Runtime } from \"@/node/runtime/Runtime\";\r\nimport { readFileString } from \"@/node/utils/runtime/helpers\";\r\n\r\nconst MARKDOWN_COMMENT_REGEX = /<!--[\\s\\S]*?-->/g;\r\n\r\nfunction stripMarkdownComments(content: string): string {\r\n  return content.replace(MARKDOWN_COMMENT_REGEX, \"\").trim();\r\n}\r\n\r\n/**\r\n * Instruction file names to search for, in priority order.\r\n * The first file found in a directory is used as the base instruction set.\r\n */\r\nexport const INSTRUCTION_FILE_NAMES = [\"AGENTS.md\", \"AGENT.md\", \"CLAUDE.md\"] as const;\r\n\r\n/**\r\n * Local instruction file suffix. If a base instruction file is found,\r\n * we also look for a matching .local.md variant in the same directory.\r\n *\r\n * Example: If AGENTS.md exists, we also check for AGENTS.local.md\r\n */\r\nexport const LOCAL_INSTRUCTION_FILENAME = \"AGENTS.local.md\";\r\n\r\n/**\r\n * File reader abstraction for reading files from either local fs or Runtime.\r\n */\r\ninterface FileReader {\r\n  readFile(filePath: string): Promise<string>;\r\n}\r\n\r\n/**\r\n * Create a FileReader for local filesystem access.\r\n */\r\nfunction createLocalFileReader(): FileReader {\r\n  return {\r\n    readFile: (filePath: string) => fs.readFile(filePath, \"utf-8\"),\r\n  };\r\n}\r\n\r\n/**\r\n * Create a FileReader for Runtime-based access (supports SSH).\r\n */\r\nfunction createRuntimeFileReader(runtime: Runtime): FileReader {\r\n  return {\r\n    readFile: (filePath: string) => readFileString(runtime, filePath),\r\n  };\r\n}\r\n\r\n/**\r\n * Read the first available file from a list using the provided file reader.\r\n *\r\n * @param reader - FileReader abstraction (local or runtime)\r\n * @param directory - Directory to search in\r\n * @param filenames - List of filenames to try, in priority order\r\n * @returns Content of the first file found, or null if none exist\r\n */\r\nasync function readFirstAvailableFile(\r\n  reader: FileReader,\r\n  directory: string,\r\n  filenames: readonly string[]\r\n): Promise<string | null> {\r\n  for (const filename of filenames) {\r\n    try {\r\n      return await reader.readFile(path.join(directory, filename));\r\n    } catch {\r\n      continue; // File doesn't exist, try next\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Read a base file with optional local variant using the provided file reader.\r\n *\r\n * @param reader - FileReader abstraction (local or runtime)\r\n * @param directory - Directory to search\r\n * @param baseFilenames - Base filenames to try in priority order\r\n * @param localFilename - Optional local filename to append if present\r\n * @returns Combined content or null if no base file exists\r\n */\r\nasync function readFileWithLocalVariant(\r\n  reader: FileReader,\r\n  directory: string,\r\n  baseFilenames: readonly string[],\r\n  localFilename?: string\r\n): Promise<string | null> {\r\n  const baseContent = await readFirstAvailableFile(reader, directory, baseFilenames);\r\n  if (!baseContent) return null;\r\n\r\n  let combinedContent = baseContent;\r\n\r\n  if (localFilename) {\r\n    try {\r\n      const localContent = await reader.readFile(path.join(directory, localFilename));\r\n      combinedContent = `${combinedContent}\\n\\n${localContent}`;\r\n    } catch {\r\n      // Local variant missing, keep base only\r\n    }\r\n  }\r\n\r\n  const sanitized = stripMarkdownComments(combinedContent);\r\n  return sanitized.length > 0 ? sanitized : null;\r\n}\r\n\r\n/**\r\n * Read an instruction set from a local directory.\r\n *\r\n * An instruction set consists of:\r\n * 1. A base instruction file (AGENTS.md → AGENT.md → CLAUDE.md, first found wins)\r\n * 2. An optional local instruction file (AGENTS.local.md)\r\n *\r\n * If both exist, they are concatenated with a blank line separator.\r\n *\r\n * @param directory - Directory to search for instruction files\r\n * @returns Combined instruction content, or null if no base file exists\r\n */\r\nexport async function readInstructionSet(\r\n  directory: string | null | undefined\r\n): Promise<string | null> {\r\n  if (!directory) return null;\r\n  const reader = createLocalFileReader();\r\n  return readFileWithLocalVariant(\r\n    reader,\r\n    path.resolve(directory),\r\n    INSTRUCTION_FILE_NAMES,\r\n    LOCAL_INSTRUCTION_FILENAME\r\n  );\r\n}\r\n\r\n/**\r\n * Read an instruction set from a workspace using Runtime abstraction.\r\n * Supports both local and remote (SSH) workspaces.\r\n *\r\n * @param runtime - Runtime instance (may be local or SSH)\r\n * @param directory - Directory to search for instruction files\r\n * @returns Combined instruction content, or null if no base file exists\r\n */\r\nexport async function readInstructionSetFromRuntime(\r\n  runtime: Runtime,\r\n  directory: string\r\n): Promise<string | null> {\r\n  const reader = createRuntimeFileReader(runtime);\r\n  return readFileWithLocalVariant(\r\n    reader,\r\n    directory,\r\n    INSTRUCTION_FILE_NAMES,\r\n    LOCAL_INSTRUCTION_FILENAME\r\n  );\r\n}\r\n\r\n/**\r\n * Searches for instruction files across multiple directories in priority order.\r\n *\r\n * Each directory is searched for a complete instruction set (base + local).\r\n * All found instruction sets are returned as separate segments.\r\n *\r\n * This allows for layered instructions where:\r\n * - Global instructions (~/.mux/AGENTS.md) apply to all projects\r\n * - Project instructions (workspace/AGENTS.md) add project-specific context\r\n *\r\n * @param directories - List of directories to search, in priority order\r\n * @returns Array of instruction segments (one per directory with instructions)\r\n */\r\nexport async function gatherInstructionSets(directories: string[]): Promise<string[]> {\r\n  const segments: string[] = [];\r\n\r\n  for (const directory of directories) {\r\n    const instructionSet = await readInstructionSet(directory);\r\n    if (instructionSet) {\r\n      segments.push(instructionSet);\r\n    }\r\n  }\r\n\r\n  return segments;\r\n}\r\n"]}