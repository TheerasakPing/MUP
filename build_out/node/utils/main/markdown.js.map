{"version":3,"file":"markdown.js","sourceRoot":"","sources":["../../../../src/node/utils/main/markdown.ts"],"names":[],"mappings":"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","sourcesContent":["import MarkdownIt from \"markdown-it\";\n\ntype HeadingMatcher = (headingText: string, level: number) => boolean;\n\ninterface SectionBounds {\n  headingStartLine: number;\n  contentStartLine: number;\n  endLine: number;\n  level: number;\n}\n\nfunction collectSectionBounds(\n  markdown: string,\n  headingMatcher: HeadingMatcher\n): { bounds: SectionBounds[]; lines: string[] } {\n  const lines = markdown.split(/\\r?\\n/);\n  const md = new MarkdownIt({ html: false, linkify: false, typographer: false });\n  const tokens = md.parse(markdown, {});\n  const bounds: SectionBounds[] = [];\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.type !== \"heading_open\") continue;\n\n    const level = Number(token.tag?.replace(/^h/, \"\")) || 1;\n    const inline = tokens[i + 1];\n    if (inline?.type !== \"inline\") continue;\n\n    const headingText = (inline.content || \"\").trim();\n    if (!headingMatcher(headingText, level)) continue;\n\n    const headingStartLine = token.map?.[0] ?? 0;\n    const headingEndLine = inline.map?.[1] ?? token.map?.[1] ?? headingStartLine + 1;\n\n    let endLine = lines.length;\n    for (let j = i + 1; j < tokens.length; j++) {\n      const nextToken = tokens[j];\n      if (nextToken.type === \"heading_open\") {\n        const nextLevel = Number(nextToken.tag?.replace(/^h/, \"\")) || 1;\n        if (nextLevel <= level) {\n          endLine = nextToken.map?.[0] ?? endLine;\n          break;\n        }\n      }\n    }\n\n    bounds.push({ headingStartLine, contentStartLine: headingEndLine, endLine, level });\n  }\n\n  return { bounds, lines };\n}\n\nfunction extractSectionByHeading(markdown: string, headingMatcher: HeadingMatcher): string | null {\n  if (!markdown) return null;\n\n  const { bounds, lines } = collectSectionBounds(markdown, headingMatcher);\n  if (bounds.length === 0) return null;\n\n  const { contentStartLine, endLine } = bounds[0];\n  const slice = lines.slice(contentStartLine, endLine).join(\"\\n\").trim();\n  return slice.length > 0 ? slice : null;\n}\n\nfunction removeSectionsByHeading(markdown: string, headingMatcher: HeadingMatcher): string {\n  if (!markdown) return markdown;\n\n  const { bounds, lines } = collectSectionBounds(markdown, headingMatcher);\n  if (bounds.length === 0) return markdown;\n\n  const updatedLines = [...lines];\n  const sortedBounds = [...bounds].sort((a, b) => b.headingStartLine - a.headingStartLine);\n  for (const { headingStartLine, endLine } of sortedBounds) {\n    updatedLines.splice(headingStartLine, endLine - headingStartLine);\n  }\n\n  return updatedLines.join(\"\\n\");\n}\n\n/**\n * Extract the first section whose heading matches \"Model: <regex>\" and whose regex matches\n * the provided model identifier. Matching is case-insensitive by default unless the regex\n * heading explicitly specifies flags via /pattern/flags syntax.\n */\n\nexport function extractModelSection(markdown: string, modelId: string): string | null {\n  if (!markdown || !modelId) return null;\n\n  const headingPattern = /^model:\\s*(.+)$/i;\n\n  const compileRegex = (pattern: string): RegExp | null => {\n    const trimmed = pattern.trim();\n    if (!trimmed) return null;\n\n    if (trimmed.startsWith(\"/\") && trimmed.lastIndexOf(\"/\") > 0) {\n      const lastSlash = trimmed.lastIndexOf(\"/\");\n      const source = trimmed.slice(1, lastSlash);\n      const flags = trimmed.slice(lastSlash + 1);\n      try {\n        return new RegExp(source, flags || undefined);\n      } catch {\n        return null;\n      }\n    }\n\n    try {\n      return new RegExp(trimmed, \"i\");\n    } catch {\n      return null;\n    }\n  };\n\n  return extractSectionByHeading(markdown, (headingText) => {\n    const match = headingPattern.exec(headingText);\n    if (!match) return false;\n    const regex = compileRegex(match[1] ?? \"\");\n    return Boolean(regex?.test(modelId));\n  });\n}\n\n/**\n * Extract the content under a heading titled \"Tool: <tool_name>\" (case-insensitive).\n */\nexport function extractToolSection(markdown: string, toolName: string): string | null {\n  if (!markdown || !toolName) return null;\n\n  const expectedHeading = `tool: ${toolName}`.toLowerCase();\n  return extractSectionByHeading(\n    markdown,\n    (headingText) => headingText.toLowerCase() === expectedHeading\n  );\n}\n\nexport function stripScopedInstructionSections(markdown: string): string {\n  if (!markdown) return markdown;\n\n  return removeSectionsByHeading(markdown, (headingText) => {\n    const normalized = headingText.trim().toLowerCase();\n    return normalized.startsWith(\"model:\") || normalized.startsWith(\"tool:\");\n  });\n}\n"]}