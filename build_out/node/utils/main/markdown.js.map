{"version":3,"file":"markdown.js","sourceRoot":"","sources":["../../../../src/node/utils/main/markdown.ts"],"names":[],"mappings":"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","sourcesContent":["import MarkdownIt from \"markdown-it\";\r\n\r\ntype HeadingMatcher = (headingText: string, level: number) => boolean;\r\n\r\ninterface SectionBounds {\r\n  headingStartLine: number;\r\n  contentStartLine: number;\r\n  endLine: number;\r\n  level: number;\r\n}\r\n\r\nfunction collectSectionBounds(\r\n  markdown: string,\r\n  headingMatcher: HeadingMatcher\r\n): { bounds: SectionBounds[]; lines: string[] } {\r\n  const lines = markdown.split(/\\r?\\n/);\r\n  const md = new MarkdownIt({ html: false, linkify: false, typographer: false });\r\n  const tokens = md.parse(markdown, {});\r\n  const bounds: SectionBounds[] = [];\r\n\r\n  for (let i = 0; i < tokens.length; i++) {\r\n    const token = tokens[i];\r\n    if (token.type !== \"heading_open\") continue;\r\n\r\n    const level = Number(token.tag?.replace(/^h/, \"\")) || 1;\r\n    const inline = tokens[i + 1];\r\n    if (inline?.type !== \"inline\") continue;\r\n\r\n    const headingText = (inline.content || \"\").trim();\r\n    if (!headingMatcher(headingText, level)) continue;\r\n\r\n    const headingStartLine = token.map?.[0] ?? 0;\r\n    const headingEndLine = inline.map?.[1] ?? token.map?.[1] ?? headingStartLine + 1;\r\n\r\n    let endLine = lines.length;\r\n    for (let j = i + 1; j < tokens.length; j++) {\r\n      const nextToken = tokens[j];\r\n      if (nextToken.type === \"heading_open\") {\r\n        const nextLevel = Number(nextToken.tag?.replace(/^h/, \"\")) || 1;\r\n        if (nextLevel <= level) {\r\n          endLine = nextToken.map?.[0] ?? endLine;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    bounds.push({ headingStartLine, contentStartLine: headingEndLine, endLine, level });\r\n  }\r\n\r\n  return { bounds, lines };\r\n}\r\n\r\nfunction extractSectionByHeading(markdown: string, headingMatcher: HeadingMatcher): string | null {\r\n  if (!markdown) return null;\r\n\r\n  const { bounds, lines } = collectSectionBounds(markdown, headingMatcher);\r\n  if (bounds.length === 0) return null;\r\n\r\n  const { contentStartLine, endLine } = bounds[0];\r\n  const slice = lines.slice(contentStartLine, endLine).join(\"\\n\").trim();\r\n  return slice.length > 0 ? slice : null;\r\n}\r\n\r\nfunction removeSectionsByHeading(markdown: string, headingMatcher: HeadingMatcher): string {\r\n  if (!markdown) return markdown;\r\n\r\n  const { bounds, lines } = collectSectionBounds(markdown, headingMatcher);\r\n  if (bounds.length === 0) return markdown;\r\n\r\n  const updatedLines = [...lines];\r\n  const sortedBounds = [...bounds].sort((a, b) => b.headingStartLine - a.headingStartLine);\r\n  for (const { headingStartLine, endLine } of sortedBounds) {\r\n    updatedLines.splice(headingStartLine, endLine - headingStartLine);\r\n  }\r\n\r\n  return updatedLines.join(\"\\n\");\r\n}\r\n\r\n/**\r\n * Extract the first section whose heading matches \"Model: <regex>\" and whose regex matches\r\n * the provided model identifier. Matching is case-insensitive by default unless the regex\r\n * heading explicitly specifies flags via /pattern/flags syntax.\r\n */\r\n\r\nexport function extractModelSection(markdown: string, modelId: string): string | null {\r\n  if (!markdown || !modelId) return null;\r\n\r\n  const headingPattern = /^model:\\s*(.+)$/i;\r\n\r\n  const compileRegex = (pattern: string): RegExp | null => {\r\n    const trimmed = pattern.trim();\r\n    if (!trimmed) return null;\r\n\r\n    if (trimmed.startsWith(\"/\") && trimmed.lastIndexOf(\"/\") > 0) {\r\n      const lastSlash = trimmed.lastIndexOf(\"/\");\r\n      const source = trimmed.slice(1, lastSlash);\r\n      const flags = trimmed.slice(lastSlash + 1);\r\n      try {\r\n        return new RegExp(source, flags || undefined);\r\n      } catch {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    try {\r\n      return new RegExp(trimmed, \"i\");\r\n    } catch {\r\n      return null;\r\n    }\r\n  };\r\n\r\n  return extractSectionByHeading(markdown, (headingText) => {\r\n    const match = headingPattern.exec(headingText);\r\n    if (!match) return false;\r\n    const regex = compileRegex(match[1] ?? \"\");\r\n    return Boolean(regex?.test(modelId));\r\n  });\r\n}\r\n\r\n/**\r\n * Extract the content under a heading titled \"Tool: <tool_name>\" (case-insensitive).\r\n */\r\nexport function extractToolSection(markdown: string, toolName: string): string | null {\r\n  if (!markdown || !toolName) return null;\r\n\r\n  const expectedHeading = `tool: ${toolName}`.toLowerCase();\r\n  return extractSectionByHeading(\r\n    markdown,\r\n    (headingText) => headingText.toLowerCase() === expectedHeading\r\n  );\r\n}\r\n\r\nexport function stripScopedInstructionSections(markdown: string): string {\r\n  if (!markdown) return markdown;\r\n\r\n  return removeSectionsByHeading(markdown, (headingText) => {\r\n    const normalized = headingText.trim().toLowerCase();\r\n    return normalized.startsWith(\"model:\") || normalized.startsWith(\"tool:\");\r\n  });\r\n}\r\n"]}