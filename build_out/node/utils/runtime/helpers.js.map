{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../../../src/node/utils/runtime/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Runtime, ExecOptions } from \"@/node/runtime/Runtime\";\r\nimport { PlatformPaths } from \"@/node/utils/paths.main\";\r\nimport { getLegacyPlanFilePath, getPlanFilePath } from \"@/common/utils/planStorage\";\r\n\r\n/**\r\n * Convenience helpers for working with streaming Runtime APIs.\r\n * These provide simple string-based APIs on top of the low-level streaming primitives.\r\n */\r\n\r\n/**\r\n * Extract project name from a project path\r\n * Works for both local paths and remote paths\r\n */\r\nexport function getProjectName(projectPath: string): string {\r\n  return PlatformPaths.getProjectName(projectPath);\r\n}\r\n\r\n/**\r\n * Result from executing a command with buffered output\r\n */\r\nexport interface ExecResult {\r\n  /** Standard output */\r\n  stdout: string;\r\n  /** Standard error */\r\n  stderr: string;\r\n  /** Exit code (0 = success) */\r\n  exitCode: number;\r\n  /** Wall clock duration in milliseconds */\r\n  duration: number;\r\n}\r\n\r\n/**\r\n * Execute a command and buffer all output into strings\r\n */\r\nexport async function execBuffered(\r\n  runtime: Runtime,\r\n  command: string,\r\n  options: ExecOptions & { stdin?: string }\r\n): Promise<ExecResult> {\r\n  const stream = await runtime.exec(command, options);\r\n\r\n  // Write stdin if provided\r\n  if (options.stdin !== undefined) {\r\n    const writer = stream.stdin.getWriter();\r\n    try {\r\n      await writer.write(new TextEncoder().encode(options.stdin));\r\n      await writer.close();\r\n    } catch (err) {\r\n      writer.releaseLock();\r\n      throw err;\r\n    }\r\n  } else {\r\n    // Close stdin immediately if no input\r\n    await stream.stdin.close();\r\n  }\r\n\r\n  // Read stdout and stderr concurrently\r\n  const [stdout, stderr, exitCode, duration] = await Promise.all([\r\n    streamToString(stream.stdout),\r\n    streamToString(stream.stderr),\r\n    stream.exitCode,\r\n    stream.duration,\r\n  ]);\r\n\r\n  return { stdout, stderr, exitCode, duration };\r\n}\r\n\r\n/**\r\n * Read file contents as a UTF-8 string\r\n */\r\nexport async function readFileString(\r\n  runtime: Runtime,\r\n  path: string,\r\n  abortSignal?: AbortSignal\r\n): Promise<string> {\r\n  const stream = runtime.readFile(path, abortSignal);\r\n  return streamToString(stream);\r\n}\r\n\r\n/**\r\n * Write string contents to a file atomically\r\n */\r\nexport async function writeFileString(\r\n  runtime: Runtime,\r\n  path: string,\r\n  content: string,\r\n  abortSignal?: AbortSignal\r\n): Promise<void> {\r\n  const stream = runtime.writeFile(path, abortSignal);\r\n  const writer = stream.getWriter();\r\n  try {\r\n    await writer.write(new TextEncoder().encode(content));\r\n    await writer.close();\r\n  } catch (err) {\r\n    writer.releaseLock();\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * Convert a ReadableStream<Uint8Array> to a UTF-8 string\r\n */\r\nasync function streamToString(stream: ReadableStream<Uint8Array>): Promise<string> {\r\n  const reader = stream.getReader();\r\n  const decoder = new TextDecoder(\"utf-8\");\r\n  let result = \"\";\r\n\r\n  try {\r\n    while (true) {\r\n      const { done, value } = await reader.read();\r\n      if (done) break;\r\n      result += decoder.decode(value, { stream: true });\r\n    }\r\n    // Final flush\r\n    result += decoder.decode();\r\n    return result;\r\n  } finally {\r\n    reader.releaseLock();\r\n  }\r\n}\r\n\r\n/**\r\n * Result from reading a plan file with legacy migration support\r\n */\r\nexport interface ReadPlanResult {\r\n  /** Plan file content (empty string if file doesn't exist) */\r\n  content: string;\r\n  /** Whether a plan file exists */\r\n  exists: boolean;\r\n  /** The canonical plan file path (new format) */\r\n  path: string;\r\n}\r\n\r\n/**\r\n * Read plan file content, checking new path first then legacy, migrating if needed.\r\n * This handles the transparent migration from ~/.mux/plans/{id}.md to\r\n * ~/.mux/plans/{projectName}/{workspaceName}.md\r\n */\r\nexport async function readPlanFile(\r\n  runtime: Runtime,\r\n  workspaceName: string,\r\n  projectName: string,\r\n  workspaceId: string\r\n): Promise<ReadPlanResult> {\r\n  const muxHome = runtime.getMuxHome();\r\n  const planPath = getPlanFilePath(workspaceName, projectName, muxHome);\r\n  // Legacy paths only used for non-Docker runtimes\r\n  const legacyPath = getLegacyPlanFilePath(workspaceId);\r\n\r\n  // Resolve tilde to absolute path for client use (editor deep links, etc.)\r\n  // For local runtimes this expands ~ to /home/user; for SSH it resolves remotely\r\n  const resolvedPath = await runtime.resolvePath(planPath);\r\n\r\n  // Try new path first\r\n  try {\r\n    const content = await readFileString(runtime, planPath);\r\n    return { content, exists: true, path: resolvedPath };\r\n  } catch {\r\n    // Fall back to legacy path\r\n    try {\r\n      const content = await readFileString(runtime, legacyPath);\r\n      // Migrate: move to new location\r\n      try {\r\n        const planDir = planPath.substring(0, planPath.lastIndexOf(\"/\"));\r\n        await execBuffered(runtime, `mkdir -p \"${planDir}\" && mv \"${legacyPath}\" \"${planPath}\"`, {\r\n          cwd: \"/tmp\",\r\n          timeout: 5,\r\n        });\r\n      } catch {\r\n        // Migration failed, but we have the content\r\n      }\r\n      return { content, exists: true, path: resolvedPath };\r\n    } catch {\r\n      // File doesn't exist at either location\r\n      return { content: \"\", exists: false, path: resolvedPath };\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a non-empty plan file exists for this workspace.\r\n * Checks both the canonical (per-project) path and the legacy (by workspaceId) path.\r\n */\r\nexport async function hasNonEmptyPlanFile(\r\n  runtime: Runtime,\r\n  workspaceName: string,\r\n  projectName: string,\r\n  workspaceId: string\r\n): Promise<boolean> {\r\n  // Defensive: missing identifiers means we cannot safely resolve plan paths.\r\n  if (!workspaceName || !projectName || !workspaceId) {\r\n    return false;\r\n  }\r\n\r\n  const muxHome = runtime.getMuxHome();\r\n  const planPath = getPlanFilePath(workspaceName, projectName, muxHome);\r\n  // Legacy paths only used for non-Docker runtimes.\r\n  const legacyPath = getLegacyPlanFilePath(workspaceId);\r\n\r\n  for (const candidatePath of [planPath, legacyPath]) {\r\n    try {\r\n      const stat = await runtime.stat(candidatePath);\r\n      if (!stat.isDirectory && stat.size > 0) {\r\n        return true;\r\n      }\r\n    } catch {\r\n      // Try next candidate.\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Move a plan file from one workspace name to another (e.g., during rename).\r\n * Silently succeeds if source file doesn't exist.\r\n */\r\nexport async function movePlanFile(\r\n  runtime: Runtime,\r\n  oldWorkspaceName: string,\r\n  newWorkspaceName: string,\r\n  projectName: string\r\n): Promise<void> {\r\n  const muxHome = runtime.getMuxHome();\r\n  const oldPath = getPlanFilePath(oldWorkspaceName, projectName, muxHome);\r\n  const newPath = getPlanFilePath(newWorkspaceName, projectName, muxHome);\r\n\r\n  try {\r\n    await runtime.stat(oldPath);\r\n    // Resolve tildes to absolute paths - bash doesn't expand ~ inside quotes\r\n    const resolvedOldPath = await runtime.resolvePath(oldPath);\r\n    const resolvedNewPath = await runtime.resolvePath(newPath);\r\n    await execBuffered(runtime, `mv \"${resolvedOldPath}\" \"${resolvedNewPath}\"`, {\r\n      cwd: \"/tmp\",\r\n      timeout: 5,\r\n    });\r\n  } catch {\r\n    // No plan file to move, that's fine\r\n  }\r\n}\r\n\r\n/**\r\n * Copy a plan file from one workspace to another (e.g., during fork).\r\n * Checks both new path format and legacy path format for the source.\r\n * Silently succeeds if source file doesn't exist at either location.\r\n */\r\nexport async function copyPlanFile(\r\n  runtime: Runtime,\r\n  sourceWorkspaceName: string,\r\n  sourceWorkspaceId: string,\r\n  targetWorkspaceName: string,\r\n  projectName: string\r\n): Promise<void> {\r\n  const muxHome = runtime.getMuxHome();\r\n  const sourcePath = getPlanFilePath(sourceWorkspaceName, projectName, muxHome);\r\n  // Legacy paths only used for non-Docker runtimes\r\n  const legacySourcePath = getLegacyPlanFilePath(sourceWorkspaceId);\r\n  const targetPath = getPlanFilePath(targetWorkspaceName, projectName, muxHome);\r\n\r\n  // Prefer the new layout, but fall back to the legacy layout.\r\n  //\r\n  // Note: we intentionally use runtime file I/O instead of `cp` because:\r\n  // 1) bash doesn't expand ~ inside quotes\r\n  // 2) the target per-project plan directory may not exist yet\r\n  // 3) runtime.writeFile() already handles directory creation + tilde expansion\r\n  for (const candidatePath of [sourcePath, legacySourcePath]) {\r\n    try {\r\n      const content = await readFileString(runtime, candidatePath);\r\n      await writeFileString(runtime, targetPath, content);\r\n      return;\r\n    } catch {\r\n      // Try next candidate\r\n    }\r\n  }\r\n}\r\n"]}