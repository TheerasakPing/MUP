{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../../../src/node/utils/runtime/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Runtime, ExecOptions } from \"@/node/runtime/Runtime\";\nimport { PlatformPaths } from \"@/node/utils/paths.main\";\nimport { getLegacyPlanFilePath, getPlanFilePath } from \"@/common/utils/planStorage\";\n\n/**\n * Convenience helpers for working with streaming Runtime APIs.\n * These provide simple string-based APIs on top of the low-level streaming primitives.\n */\n\n/**\n * Extract project name from a project path\n * Works for both local paths and remote paths\n */\nexport function getProjectName(projectPath: string): string {\n  return PlatformPaths.getProjectName(projectPath);\n}\n\n/**\n * Result from executing a command with buffered output\n */\nexport interface ExecResult {\n  /** Standard output */\n  stdout: string;\n  /** Standard error */\n  stderr: string;\n  /** Exit code (0 = success) */\n  exitCode: number;\n  /** Wall clock duration in milliseconds */\n  duration: number;\n}\n\n/**\n * Execute a command and buffer all output into strings\n */\nexport async function execBuffered(\n  runtime: Runtime,\n  command: string,\n  options: ExecOptions & { stdin?: string }\n): Promise<ExecResult> {\n  const stream = await runtime.exec(command, options);\n\n  // Write stdin if provided\n  if (options.stdin !== undefined) {\n    const writer = stream.stdin.getWriter();\n    try {\n      await writer.write(new TextEncoder().encode(options.stdin));\n      await writer.close();\n    } catch (err) {\n      writer.releaseLock();\n      throw err;\n    }\n  } else {\n    // Close stdin immediately if no input\n    await stream.stdin.close();\n  }\n\n  // Read stdout and stderr concurrently\n  const [stdout, stderr, exitCode, duration] = await Promise.all([\n    streamToString(stream.stdout),\n    streamToString(stream.stderr),\n    stream.exitCode,\n    stream.duration,\n  ]);\n\n  return { stdout, stderr, exitCode, duration };\n}\n\n/**\n * Read file contents as a UTF-8 string\n */\nexport async function readFileString(\n  runtime: Runtime,\n  path: string,\n  abortSignal?: AbortSignal\n): Promise<string> {\n  const stream = runtime.readFile(path, abortSignal);\n  return streamToString(stream);\n}\n\n/**\n * Write string contents to a file atomically\n */\nexport async function writeFileString(\n  runtime: Runtime,\n  path: string,\n  content: string,\n  abortSignal?: AbortSignal\n): Promise<void> {\n  const stream = runtime.writeFile(path, abortSignal);\n  const writer = stream.getWriter();\n  try {\n    await writer.write(new TextEncoder().encode(content));\n    await writer.close();\n  } catch (err) {\n    writer.releaseLock();\n    throw err;\n  }\n}\n\n/**\n * Convert a ReadableStream<Uint8Array> to a UTF-8 string\n */\nasync function streamToString(stream: ReadableStream<Uint8Array>): Promise<string> {\n  const reader = stream.getReader();\n  const decoder = new TextDecoder(\"utf-8\");\n  let result = \"\";\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n      result += decoder.decode(value, { stream: true });\n    }\n    // Final flush\n    result += decoder.decode();\n    return result;\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n/**\n * Result from reading a plan file with legacy migration support\n */\nexport interface ReadPlanResult {\n  /** Plan file content (empty string if file doesn't exist) */\n  content: string;\n  /** Whether a plan file exists */\n  exists: boolean;\n  /** The canonical plan file path (new format) */\n  path: string;\n}\n\n/**\n * Read plan file content, checking new path first then legacy, migrating if needed.\n * This handles the transparent migration from ~/.mux/plans/{id}.md to\n * ~/.mux/plans/{projectName}/{workspaceName}.md\n */\nexport async function readPlanFile(\n  runtime: Runtime,\n  workspaceName: string,\n  projectName: string,\n  workspaceId: string\n): Promise<ReadPlanResult> {\n  const muxHome = runtime.getMuxHome();\n  const planPath = getPlanFilePath(workspaceName, projectName, muxHome);\n  // Legacy paths only used for non-Docker runtimes\n  const legacyPath = getLegacyPlanFilePath(workspaceId);\n\n  // Resolve tilde to absolute path for client use (editor deep links, etc.)\n  // For local runtimes this expands ~ to /home/user; for SSH it resolves remotely\n  const resolvedPath = await runtime.resolvePath(planPath);\n\n  // Try new path first\n  try {\n    const content = await readFileString(runtime, planPath);\n    return { content, exists: true, path: resolvedPath };\n  } catch {\n    // Fall back to legacy path\n    try {\n      const content = await readFileString(runtime, legacyPath);\n      // Migrate: move to new location\n      try {\n        const planDir = planPath.substring(0, planPath.lastIndexOf(\"/\"));\n        await execBuffered(runtime, `mkdir -p \"${planDir}\" && mv \"${legacyPath}\" \"${planPath}\"`, {\n          cwd: \"/tmp\",\n          timeout: 5,\n        });\n      } catch {\n        // Migration failed, but we have the content\n      }\n      return { content, exists: true, path: resolvedPath };\n    } catch {\n      // File doesn't exist at either location\n      return { content: \"\", exists: false, path: resolvedPath };\n    }\n  }\n}\n\n/**\n * Check if a non-empty plan file exists for this workspace.\n * Checks both the canonical (per-project) path and the legacy (by workspaceId) path.\n */\nexport async function hasNonEmptyPlanFile(\n  runtime: Runtime,\n  workspaceName: string,\n  projectName: string,\n  workspaceId: string\n): Promise<boolean> {\n  // Defensive: missing identifiers means we cannot safely resolve plan paths.\n  if (!workspaceName || !projectName || !workspaceId) {\n    return false;\n  }\n\n  const muxHome = runtime.getMuxHome();\n  const planPath = getPlanFilePath(workspaceName, projectName, muxHome);\n  // Legacy paths only used for non-Docker runtimes.\n  const legacyPath = getLegacyPlanFilePath(workspaceId);\n\n  for (const candidatePath of [planPath, legacyPath]) {\n    try {\n      const stat = await runtime.stat(candidatePath);\n      if (!stat.isDirectory && stat.size > 0) {\n        return true;\n      }\n    } catch {\n      // Try next candidate.\n    }\n  }\n\n  return false;\n}\n\n/**\n * Move a plan file from one workspace name to another (e.g., during rename).\n * Silently succeeds if source file doesn't exist.\n */\nexport async function movePlanFile(\n  runtime: Runtime,\n  oldWorkspaceName: string,\n  newWorkspaceName: string,\n  projectName: string\n): Promise<void> {\n  const muxHome = runtime.getMuxHome();\n  const oldPath = getPlanFilePath(oldWorkspaceName, projectName, muxHome);\n  const newPath = getPlanFilePath(newWorkspaceName, projectName, muxHome);\n\n  try {\n    await runtime.stat(oldPath);\n    // Resolve tildes to absolute paths - bash doesn't expand ~ inside quotes\n    const resolvedOldPath = await runtime.resolvePath(oldPath);\n    const resolvedNewPath = await runtime.resolvePath(newPath);\n    await execBuffered(runtime, `mv \"${resolvedOldPath}\" \"${resolvedNewPath}\"`, {\n      cwd: \"/tmp\",\n      timeout: 5,\n    });\n  } catch {\n    // No plan file to move, that's fine\n  }\n}\n\n/**\n * Copy a plan file from one workspace to another (e.g., during fork).\n * Checks both new path format and legacy path format for the source.\n * Silently succeeds if source file doesn't exist at either location.\n */\nexport async function copyPlanFile(\n  runtime: Runtime,\n  sourceWorkspaceName: string,\n  sourceWorkspaceId: string,\n  targetWorkspaceName: string,\n  projectName: string\n): Promise<void> {\n  const muxHome = runtime.getMuxHome();\n  const sourcePath = getPlanFilePath(sourceWorkspaceName, projectName, muxHome);\n  // Legacy paths only used for non-Docker runtimes\n  const legacySourcePath = getLegacyPlanFilePath(sourceWorkspaceId);\n  const targetPath = getPlanFilePath(targetWorkspaceName, projectName, muxHome);\n\n  // Prefer the new layout, but fall back to the legacy layout.\n  //\n  // Note: we intentionally use runtime file I/O instead of `cp` because:\n  // 1) bash doesn't expand ~ inside quotes\n  // 2) the target per-project plan directory may not exist yet\n  // 3) runtime.writeFile() already handles directory creation + tilde expansion\n  for (const candidatePath of [sourcePath, legacySourcePath]) {\n    try {\n      const content = await readFileString(runtime, candidatePath);\n      await writeFileString(runtime, targetPath, content);\n      return;\n    } catch {\n      // Try next candidate\n    }\n  }\n}\n"]}