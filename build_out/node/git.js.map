{"version":3,"file":"git.js","sourceRoot":"","sources":["../../src/node/git.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs\";\nimport * as path from \"path\";\nimport type { Config } from \"@/node/config\";\nimport type { RuntimeConfig } from \"@/common/types/runtime\";\nimport { execAsync } from \"@/node/utils/disposableExec\";\nimport { createRuntime } from \"./runtime/runtimeFactory\";\nimport { log } from \"./services/log\";\n\n/**\n * Remove stale .git/index.lock file if it exists and is old.\n *\n * Git creates index.lock during operations that modify the index. If a process\n * is killed mid-operation (user cancel, crash, terminal closed), the lock file\n * gets orphaned. This is common in Mux when git operations are interrupted.\n *\n * We only remove locks older than STALE_LOCK_AGE_MS to avoid removing locks\n * from legitimately running processes.\n */\nconst STALE_LOCK_AGE_MS = 5000; // 5 seconds\n\nexport function cleanStaleLock(repoPath: string): void {\n  const lockPath = path.join(repoPath, \".git\", \"index.lock\");\n  try {\n    const stat = fs.statSync(lockPath);\n    const ageMs = Date.now() - stat.mtimeMs;\n    if (ageMs > STALE_LOCK_AGE_MS) {\n      fs.unlinkSync(lockPath);\n      log.info(`Removed stale git index.lock (age: ${Math.round(ageMs / 1000)}s) at ${lockPath}`);\n    }\n  } catch {\n    // Lock doesn't exist or can't be accessed - this is fine\n  }\n}\n\nexport interface WorktreeResult {\n  success: boolean;\n  path?: string;\n  error?: string;\n}\n\nexport interface CreateWorktreeOptions {\n  trunkBranch: string;\n  /** Directory name to use for the worktree (if not provided, uses branchName) */\n  directoryName?: string;\n  /** Runtime configuration (needed to compute workspace path) */\n  runtimeConfig?: RuntimeConfig;\n}\n\nexport async function listLocalBranches(projectPath: string): Promise<string[]> {\n  using proc = execAsync(\n    `git -C \"${projectPath}\" for-each-ref --format=\"%(refname:short)\" refs/heads`\n  );\n  const { stdout } = await proc.result;\n  return stdout\n    .split(\"\\n\")\n    .map((line) => line.trim())\n    .filter((line) => line.length > 0)\n    .sort((a, b) => a.localeCompare(b));\n}\n\nexport async function getCurrentBranch(projectPath: string): Promise<string | null> {\n  try {\n    using proc = execAsync(`git -C \"${projectPath}\" rev-parse --abbrev-ref HEAD`);\n    const { stdout } = await proc.result;\n    const branch = stdout.trim();\n    if (!branch || branch === \"HEAD\") {\n      return null;\n    }\n    return branch;\n  } catch {\n    return null;\n  }\n}\n\nconst FALLBACK_TRUNK_CANDIDATES = [\"main\", \"master\", \"trunk\", \"develop\", \"default\"];\n\nexport async function detectDefaultTrunkBranch(\n  projectPath: string,\n  branches?: string[]\n): Promise<string> {\n  const branchList = branches ?? (await listLocalBranches(projectPath));\n\n  if (branchList.length === 0) {\n    throw new Error(`No branches available in repository ${projectPath}`);\n  }\n\n  const branchSet = new Set(branchList);\n  const currentBranch = await getCurrentBranch(projectPath);\n\n  if (currentBranch && branchSet.has(currentBranch)) {\n    return currentBranch;\n  }\n\n  for (const candidate of FALLBACK_TRUNK_CANDIDATES) {\n    if (branchSet.has(candidate)) {\n      return candidate;\n    }\n  }\n\n  return branchList[0];\n}\n\nexport async function createWorktree(\n  config: Config,\n  projectPath: string,\n  branchName: string,\n  options: CreateWorktreeOptions\n): Promise<WorktreeResult> {\n  // Clean up stale lock before git operations on main repo\n  cleanStaleLock(projectPath);\n\n  try {\n    // Use directoryName if provided, otherwise fall back to branchName (legacy)\n    const dirName = options.directoryName ?? branchName;\n    // Compute workspace path using Runtime (single source of truth)\n    const runtime = createRuntime(\n      options.runtimeConfig ?? { type: \"local\", srcBaseDir: config.srcDir },\n      { projectPath }\n    );\n    const workspacePath = runtime.getWorkspacePath(projectPath, dirName);\n    const { trunkBranch } = options;\n    const normalizedTrunkBranch = typeof trunkBranch === \"string\" ? trunkBranch.trim() : \"\";\n\n    if (!normalizedTrunkBranch) {\n      return {\n        success: false,\n        error: \"Trunk branch is required to create a workspace\",\n      };\n    }\n\n    console.assert(\n      normalizedTrunkBranch.length > 0,\n      \"Expected trunk branch to be validated before calling createWorktree\"\n    );\n\n    // Create workspace directory if it doesn't exist\n    if (!fs.existsSync(path.dirname(workspacePath))) {\n      fs.mkdirSync(path.dirname(workspacePath), { recursive: true });\n    }\n\n    // Check if workspace already exists\n    if (fs.existsSync(workspacePath)) {\n      return {\n        success: false,\n        error: `Workspace already exists at ${workspacePath}`,\n      };\n    }\n\n    const localBranches = await listLocalBranches(projectPath);\n\n    // If branch already exists locally, reuse it instead of creating a new one\n    if (localBranches.includes(branchName)) {\n      using proc = execAsync(\n        `git -C \"${projectPath}\" worktree add \"${workspacePath}\" \"${branchName}\"`\n      );\n      await proc.result;\n      return { success: true, path: workspacePath };\n    }\n\n    // Check if branch exists remotely (origin/<branchName>)\n    using remoteBranchesProc = execAsync(`git -C \"${projectPath}\" branch -a`);\n    const { stdout: remoteBranchesRaw } = await remoteBranchesProc.result;\n    const branchExists = remoteBranchesRaw\n      .split(\"\\n\")\n      .map((b) => b.trim().replace(/^(\\*)\\s+/, \"\"))\n      .some((b) => b === branchName || b === `remotes/origin/${branchName}`);\n\n    if (branchExists) {\n      using proc = execAsync(\n        `git -C \"${projectPath}\" worktree add \"${workspacePath}\" \"${branchName}\"`\n      );\n      await proc.result;\n      return { success: true, path: workspacePath };\n    }\n\n    if (!localBranches.includes(normalizedTrunkBranch)) {\n      return {\n        success: false,\n        error: `Trunk branch \"${normalizedTrunkBranch}\" does not exist locally`,\n      };\n    }\n\n    using proc = execAsync(\n      `git -C \"${projectPath}\" worktree add -b \"${branchName}\" \"${workspacePath}\" \"${normalizedTrunkBranch}\"`\n    );\n    await proc.result;\n\n    return { success: true, path: workspacePath };\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return { success: false, error: message };\n  }\n}\n\n/**\n * Get the main repository path from a worktree path\n * @param worktreePath Path to a git worktree\n * @returns Path to the main repository, or null if not found\n */\nexport async function getMainWorktreeFromWorktree(worktreePath: string): Promise<string | null> {\n  try {\n    // Get the worktree list from the worktree itself\n    using proc = execAsync(`git -C \"${worktreePath}\" worktree list --porcelain`);\n    const { stdout } = await proc.result;\n    const lines = stdout.split(\"\\n\");\n\n    // The first worktree in the list is always the main worktree\n    for (const line of lines) {\n      if (line.startsWith(\"worktree \")) {\n        return line.slice(\"worktree \".length);\n      }\n    }\n\n    return null;\n  } catch {\n    return null;\n  }\n}\n\nexport async function removeWorktree(\n  projectPath: string,\n  workspacePath: string,\n  options: { force: boolean } = { force: false }\n): Promise<WorktreeResult> {\n  // Clean up stale lock before git operations on main repo\n  cleanStaleLock(projectPath);\n\n  try {\n    // Remove the worktree (from the main repository context)\n    using proc = execAsync(\n      `git -C \"${projectPath}\" worktree remove \"${workspacePath}\" ${options.force ? \"--force\" : \"\"}`\n    );\n    await proc.result;\n    return { success: true };\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return { success: false, error: message };\n  }\n}\n\nexport async function pruneWorktrees(projectPath: string): Promise<WorktreeResult> {\n  // Clean up stale lock before git operations on main repo\n  cleanStaleLock(projectPath);\n\n  try {\n    using proc = execAsync(`git -C \"${projectPath}\" worktree prune`);\n    await proc.result;\n    return { success: true };\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return { success: false, error: message };\n  }\n}\n"]}