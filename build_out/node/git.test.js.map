{"version":3,"file":"git.test.js","sourceRoot":"","sources":["../../src/node/git.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, test, expect, beforeAll, afterAll } from \"@jest/globals\";\r\nimport { createWorktree, listLocalBranches, detectDefaultTrunkBranch, cleanStaleLock } from \"./git\";\r\nimport { Config } from \"./config\";\r\nimport * as path from \"path\";\r\nimport * as os from \"os\";\r\nimport * as fs from \"fs/promises\";\r\nimport * as fsSync from \"fs\";\r\nimport { exec } from \"child_process\";\r\nimport { promisify } from \"util\";\r\n\r\n// eslint-disable-next-line local/no-unsafe-child-process -- Test file needs direct exec access for setup\r\nconst execAsync = promisify(exec);\r\n\r\ndescribe(\"createWorktree\", () => {\r\n  let tempGitRepo: string;\r\n  let config: Config;\r\n  let defaultTrunk: string;\r\n\r\n  beforeAll(async () => {\r\n    // Create a temporary git repository for testing\r\n    tempGitRepo = await fs.mkdtemp(path.join(os.tmpdir(), \"mux-git-test-\"));\r\n    await execAsync(`git init`, { cwd: tempGitRepo });\r\n    await execAsync(`git config user.email \"test@example.com\"`, { cwd: tempGitRepo });\r\n    await execAsync(`git config user.name \"Test User\"`, { cwd: tempGitRepo });\r\n    await execAsync(`git config commit.gpgsign false`, { cwd: tempGitRepo });\r\n    await execAsync(`echo \"test\" > README.md`, { cwd: tempGitRepo });\r\n    await execAsync(`git add .`, { cwd: tempGitRepo });\r\n    await execAsync(`git commit -m \"Initial commit\"`, { cwd: tempGitRepo });\r\n\r\n    // Create a branch with a slash in the name (like \"docs/bash-timeout-ux\")\r\n    await execAsync(`git branch docs/bash-timeout-ux`, { cwd: tempGitRepo });\r\n\r\n    // Create a config instance for testing\r\n    const testConfigPath = path.join(tempGitRepo, \"test-config.json\");\r\n    config = new Config(testConfigPath);\r\n\r\n    defaultTrunk = await detectDefaultTrunkBranch(tempGitRepo);\r\n  });\r\n\r\n  afterAll(async () => {\r\n    // Cleanup temp repo\r\n    try {\r\n      await fs.rm(tempGitRepo, { recursive: true, force: true });\r\n    } catch (error) {\r\n      console.warn(\"Failed to cleanup temp git repo:\", error);\r\n    }\r\n  });\r\n\r\n  test(\"should correctly detect branch does not exist when name is prefix of existing branch\", async () => {\r\n    // This tests the bug fix: \"docs\" is a prefix of \"docs/bash-timeout-ux\"\r\n    // The old code would use .includes() which would match \"remotes/origin/docs/bash-timeout-ux\"\r\n    // and incorrectly think \"docs\" exists, then try: git worktree add <path> \"docs\"\r\n    // which fails with \"invalid reference: docs\"\r\n    //\r\n    // The fixed code correctly detects \"docs\" doesn't exist and tries: git worktree add -b \"docs\" <path>\r\n    // However, Git itself won't allow creating \"docs\" when \"docs/bash-timeout-ux\" exists\r\n    // due to ref namespace conflicts, so this will fail with a different, more informative error.\r\n    const result = await createWorktree(config, tempGitRepo, \"docs\", {\r\n      trunkBranch: defaultTrunk,\r\n    });\r\n\r\n    // Should fail, but with a ref lock error (not \"invalid reference\")\r\n    expect(result.success).toBe(false);\r\n    expect(result.error).toContain(\"cannot lock ref\");\r\n    expect(result.error).toContain(\"docs/bash-timeout-ux\");\r\n\r\n    // The old buggy code would have failed with \"invalid reference: docs\"\r\n    expect(result.error).not.toContain(\"invalid reference\");\r\n  });\r\n\r\n  test(\"should use existing branch when exact match exists\", async () => {\r\n    // Create a branch first\r\n    await execAsync(`git branch existing-branch`, { cwd: tempGitRepo });\r\n\r\n    const result = await createWorktree(config, tempGitRepo, \"existing-branch\", {\r\n      trunkBranch: defaultTrunk,\r\n    });\r\n\r\n    // Should succeed by using the existing branch\r\n    expect(result.success).toBe(true);\r\n    expect(result.path).toBeDefined();\r\n\r\n    // Verify the worktree was created\r\n    const { stdout } = await execAsync(`git worktree list`, { cwd: tempGitRepo });\r\n    expect(stdout).toContain(\"existing-branch\");\r\n  });\r\n\r\n  test(\"listLocalBranches should return sorted branch names\", async () => {\r\n    const uniqueSuffix = Date.now().toString(36);\r\n    const newBranches = [`zz-${uniqueSuffix}`, `aa-${uniqueSuffix}`, `mid/${uniqueSuffix}`];\r\n\r\n    for (const branch of newBranches) {\r\n      await execAsync(`git branch ${branch}`, { cwd: tempGitRepo });\r\n    }\r\n\r\n    const branches = await listLocalBranches(tempGitRepo);\r\n\r\n    for (const branch of newBranches) {\r\n      expect(branches).toContain(branch);\r\n    }\r\n\r\n    for (let i = 1; i < branches.length; i += 1) {\r\n      expect(branches[i - 1].localeCompare(branches[i])).toBeLessThanOrEqual(0);\r\n    }\r\n  });\r\n});\r\n\r\ndescribe(\"cleanStaleLock\", () => {\r\n  let tempDir: string;\r\n\r\n  beforeAll(async () => {\r\n    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), \"mux-lock-test-\"));\r\n    await fs.mkdir(path.join(tempDir, \".git\"));\r\n  });\r\n\r\n  afterAll(async () => {\r\n    try {\r\n      await fs.rm(tempDir, { recursive: true, force: true });\r\n    } catch {\r\n      // Ignore cleanup errors\r\n    }\r\n  });\r\n\r\n  test(\"removes lock file older than threshold\", async () => {\r\n    const lockPath = path.join(tempDir, \".git\", \"index.lock\");\r\n    // Create a lock file with old mtime\r\n    await fs.writeFile(lockPath, \"lock\");\r\n    const oldTime = Date.now() - 10000; // 10 seconds ago\r\n    fsSync.utimesSync(lockPath, oldTime / 1000, oldTime / 1000);\r\n\r\n    cleanStaleLock(tempDir);\r\n\r\n    // Lock should be removed\r\n    expect(fsSync.existsSync(lockPath)).toBe(false);\r\n  });\r\n\r\n  test(\"does not remove recent lock file\", async () => {\r\n    const lockPath = path.join(tempDir, \".git\", \"index.lock\");\r\n    // Create a fresh lock file (now)\r\n    await fs.writeFile(lockPath, \"lock\");\r\n\r\n    cleanStaleLock(tempDir);\r\n\r\n    // Lock should still exist (it's too recent)\r\n    expect(fsSync.existsSync(lockPath)).toBe(true);\r\n\r\n    // Cleanup\r\n    await fs.unlink(lockPath);\r\n  });\r\n\r\n  test(\"does nothing when no lock exists\", () => {\r\n    // Should not throw\r\n    cleanStaleLock(tempDir);\r\n  });\r\n});\r\n"]}