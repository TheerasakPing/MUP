{"version":3,"file":"WorktreeManager.js","sourceRoot":"","sources":["../../../src/node/worktree/WorktreeManager.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fsPromises from \"fs/promises\";\r\nimport * as path from \"path\";\r\nimport type {\r\n  WorkspaceCreationResult,\r\n  WorkspaceForkParams,\r\n  WorkspaceForkResult,\r\n  InitLogger,\r\n} from \"@/node/runtime/Runtime\";\r\nimport { listLocalBranches, cleanStaleLock, getCurrentBranch } from \"@/node/git\";\r\nimport { execAsync } from \"@/node/utils/disposableExec\";\r\nimport { getBashPath } from \"@/node/utils/main/bashPath\";\r\nimport { getProjectName } from \"@/node/utils/runtime/helpers\";\r\nimport { getErrorMessage } from \"@/common/utils/errors\";\r\nimport { expandTilde } from \"@/node/runtime/tildeExpansion\";\r\nimport { toPosixPath } from \"@/node/utils/paths\";\r\nimport { log } from \"@/node/services/log\";\r\n\r\nexport class WorktreeManager {\r\n  private readonly srcBaseDir: string;\r\n\r\n  constructor(srcBaseDir: string) {\r\n    // Expand tilde to actual home directory path for local file system operations\r\n    this.srcBaseDir = expandTilde(srcBaseDir);\r\n  }\r\n\r\n  getWorkspacePath(projectPath: string, workspaceName: string): string {\r\n    const projectName = getProjectName(projectPath);\r\n    return path.join(this.srcBaseDir, projectName, workspaceName);\r\n  }\r\n\r\n  async createWorkspace(params: {\r\n    projectPath: string;\r\n    branchName: string;\r\n    trunkBranch: string;\r\n    initLogger: InitLogger;\r\n  }): Promise<WorkspaceCreationResult> {\r\n    const { projectPath, branchName, trunkBranch, initLogger } = params;\r\n\r\n    // Clean up stale lock before git operations on main repo\r\n    cleanStaleLock(projectPath);\r\n\r\n    try {\r\n      // Compute workspace path using the canonical method\r\n      const workspacePath = this.getWorkspacePath(projectPath, branchName);\r\n      initLogger.logStep(\"Creating git worktree...\");\r\n\r\n      // Create parent directory if needed\r\n      const parentDir = path.dirname(workspacePath);\r\n      try {\r\n        await fsPromises.access(parentDir);\r\n      } catch {\r\n        await fsPromises.mkdir(parentDir, { recursive: true });\r\n      }\r\n\r\n      // Check if workspace already exists\r\n      try {\r\n        await fsPromises.access(workspacePath);\r\n        return {\r\n          success: false,\r\n          error: `Workspace already exists at ${workspacePath}`,\r\n        };\r\n      } catch {\r\n        // Workspace doesn't exist, proceed with creation\r\n      }\r\n\r\n      // Check if branch exists locally\r\n      const localBranches = await listLocalBranches(projectPath);\r\n      const branchExists = localBranches.includes(branchName);\r\n\r\n      // Fetch origin before creating worktree (best-effort)\r\n      // This ensures new branches start from the latest origin state\r\n      const fetchedOrigin = await this.fetchOriginTrunk(projectPath, trunkBranch, initLogger);\r\n\r\n      // Determine best base for new branches: use origin if local can fast-forward to it,\r\n      // otherwise preserve local state (user may have unpushed work)\r\n      const shouldUseOrigin =\r\n        fetchedOrigin && (await this.canFastForwardToOrigin(projectPath, trunkBranch, initLogger));\r\n\r\n      // Create worktree (git worktree is typically fast)\r\n      if (branchExists) {\r\n        // Branch exists, just add worktree pointing to it\r\n        using proc = execAsync(\r\n          `git -C \"${projectPath}\" worktree add \"${workspacePath}\" \"${branchName}\"`\r\n        );\r\n        await proc.result;\r\n      } else {\r\n        // Branch doesn't exist, create from the best available base:\r\n        // - origin/<trunk> if local is behind/equal (ensures fresh starting point)\r\n        // - local <trunk> if local is ahead/diverged (preserves user's work)\r\n        const newBranchBase = shouldUseOrigin ? `origin/${trunkBranch}` : trunkBranch;\r\n        using proc = execAsync(\r\n          `git -C \"${projectPath}\" worktree add -b \"${branchName}\" \"${workspacePath}\" \"${newBranchBase}\"`\r\n        );\r\n        await proc.result;\r\n      }\r\n\r\n      initLogger.logStep(\"Worktree created successfully\");\r\n\r\n      // For existing branches, fast-forward to latest origin (best-effort)\r\n      // Only if local can fast-forward (preserves unpushed work)\r\n      if (shouldUseOrigin && branchExists) {\r\n        await this.fastForwardToOrigin(workspacePath, trunkBranch, initLogger);\r\n      }\r\n\r\n      return { success: true, workspacePath };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: getErrorMessage(error),\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch trunk branch from origin before worktree creation.\r\n   * Returns true if fetch succeeded (origin is available for branching).\r\n   */\r\n  private async fetchOriginTrunk(\r\n    projectPath: string,\r\n    trunkBranch: string,\r\n    initLogger: InitLogger\r\n  ): Promise<boolean> {\r\n    try {\r\n      initLogger.logStep(`Fetching latest from origin/${trunkBranch}...`);\r\n\r\n      using fetchProc = execAsync(`git -C \"${projectPath}\" fetch origin \"${trunkBranch}\"`);\r\n      await fetchProc.result;\r\n\r\n      initLogger.logStep(\"Fetched latest from origin\");\r\n      return true;\r\n    } catch (error) {\r\n      const errorMsg = getErrorMessage(error);\r\n      // Branch doesn't exist on origin (common for subagent local-only branches)\r\n      if (errorMsg.includes(\"couldn't find remote ref\")) {\r\n        initLogger.logStep(`Branch \"${trunkBranch}\" not found on origin; using local state.`);\r\n      } else {\r\n        initLogger.logStderr(\r\n          `Note: Could not fetch from origin (${errorMsg}), using local branch state`\r\n        );\r\n      }\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if local trunk can fast-forward to origin/<trunk>.\r\n   * Returns true if local is behind or equal to origin (safe to use origin).\r\n   * Returns false if local is ahead or diverged (preserve local state).\r\n   */\r\n  private async canFastForwardToOrigin(\r\n    projectPath: string,\r\n    trunkBranch: string,\r\n    initLogger: InitLogger\r\n  ): Promise<boolean> {\r\n    try {\r\n      // Check if local trunk is an ancestor of origin/trunk\r\n      // Exit code 0 = local is ancestor (can fast-forward), non-zero = cannot\r\n      using proc = execAsync(\r\n        `git -C \"${projectPath}\" merge-base --is-ancestor \"${trunkBranch}\" \"origin/${trunkBranch}\"`\r\n      );\r\n      await proc.result;\r\n      return true; // Local is behind or equal to origin\r\n    } catch {\r\n      // Local is ahead or diverged - preserve local state\r\n      initLogger.logStderr(\r\n        `Note: Local ${trunkBranch} is ahead of or diverged from origin, using local state`\r\n      );\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fast-forward merge to latest origin/<trunkBranch> after checkout.\r\n   * Best-effort operation for existing branches that may be behind origin.\r\n   */\r\n  private async fastForwardToOrigin(\r\n    workspacePath: string,\r\n    trunkBranch: string,\r\n    initLogger: InitLogger\r\n  ): Promise<void> {\r\n    try {\r\n      initLogger.logStep(\"Fast-forward merging...\");\r\n\r\n      using mergeProc = execAsync(\r\n        `git -C \"${workspacePath}\" merge --ff-only \"origin/${trunkBranch}\"`\r\n      );\r\n      await mergeProc.result;\r\n      initLogger.logStep(\"Fast-forwarded to latest origin successfully\");\r\n    } catch (mergeError) {\r\n      // Fast-forward not possible (diverged branches) - just warn\r\n      const errorMsg = getErrorMessage(mergeError);\r\n      initLogger.logStderr(`Note: Fast-forward failed (${errorMsg}), using local branch state`);\r\n    }\r\n  }\r\n\r\n  async renameWorkspace(\r\n    projectPath: string,\r\n    oldName: string,\r\n    newName: string\r\n  ): Promise<\r\n    { success: true; oldPath: string; newPath: string } | { success: false; error: string }\r\n  > {\r\n    // Clean up stale lock before git operations on main repo\r\n    cleanStaleLock(projectPath);\r\n\r\n    // Compute workspace paths using canonical method\r\n    const oldPath = this.getWorkspacePath(projectPath, oldName);\r\n    const newPath = this.getWorkspacePath(projectPath, newName);\r\n\r\n    try {\r\n      // Move the worktree directory (updates git's internal worktree metadata)\r\n      using moveProc = execAsync(`git -C \"${projectPath}\" worktree move \"${oldPath}\" \"${newPath}\"`);\r\n      await moveProc.result;\r\n\r\n      // Rename the git branch to match the new workspace name\r\n      // In mux, branch name and workspace name are always kept in sync.\r\n      // Run from the new worktree path since that's where the branch is checked out.\r\n      // Best-effort: ignore errors (e.g., branch might have a different name in test scenarios).\r\n      try {\r\n        using branchProc = execAsync(`git -C \"${newPath}\" branch -m \"${oldName}\" \"${newName}\"`);\r\n        await branchProc.result;\r\n      } catch {\r\n        // Branch rename failed - this is fine, the directory was still moved\r\n        // This can happen if the branch name doesn't match the old directory name\r\n      }\r\n\r\n      return { success: true, oldPath, newPath };\r\n    } catch (error) {\r\n      return { success: false, error: `Failed to rename workspace: ${getErrorMessage(error)}` };\r\n    }\r\n  }\r\n\r\n  async deleteWorkspace(\r\n    projectPath: string,\r\n    workspaceName: string,\r\n    force: boolean\r\n  ): Promise<{ success: true; deletedPath: string } | { success: false; error: string }> {\r\n    // Clean up stale lock before git operations on main repo\r\n    cleanStaleLock(projectPath);\r\n\r\n    // In-place workspaces are identified by projectPath === workspaceName\r\n    // These are direct workspace directories (e.g., CLI/benchmark sessions), not git worktrees\r\n    const isInPlace = projectPath === workspaceName;\r\n\r\n    // For git worktree workspaces, workspaceName is the branch name.\r\n    // Now that archiving exists, deleting a workspace should also delete its local branch by default.\r\n    const shouldDeleteBranch = !isInPlace;\r\n\r\n    const tryDeleteBranch = async () => {\r\n      if (!shouldDeleteBranch) return;\r\n\r\n      const branchToDelete = workspaceName.trim();\r\n      if (!branchToDelete) {\r\n        log.debug(\"Skipping git branch deletion: empty workspace name\", {\r\n          projectPath,\r\n          workspaceName,\r\n        });\r\n        return;\r\n      }\r\n\r\n      let localBranches: string[];\r\n      try {\r\n        localBranches = await listLocalBranches(projectPath);\r\n      } catch (error) {\r\n        log.debug(\"Failed to list local branches; skipping branch deletion\", {\r\n          projectPath,\r\n          workspaceName: branchToDelete,\r\n          error: getErrorMessage(error),\r\n        });\r\n        return;\r\n      }\r\n\r\n      if (!localBranches.includes(branchToDelete)) {\r\n        log.debug(\"Skipping git branch deletion: branch does not exist locally\", {\r\n          projectPath,\r\n          workspaceName: branchToDelete,\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Never delete protected/trunk branches.\r\n      const protectedBranches = new Set<string>([\"main\", \"master\", \"trunk\", \"develop\", \"default\"]);\r\n\r\n      // If there's only one local branch, treat it as protected (likely trunk).\r\n      if (localBranches.length === 1) {\r\n        protectedBranches.add(localBranches[0]);\r\n      }\r\n\r\n      const currentBranch = await getCurrentBranch(projectPath);\r\n      if (currentBranch) {\r\n        protectedBranches.add(currentBranch);\r\n      }\r\n\r\n      // If origin/HEAD points at a local branch, also treat it as protected.\r\n      try {\r\n        using originHeadProc = execAsync(\r\n          `git -C \"${projectPath}\" symbolic-ref refs/remotes/origin/HEAD`\r\n        );\r\n        const { stdout } = await originHeadProc.result;\r\n        const ref = stdout.trim();\r\n        const prefix = \"refs/remotes/origin/\";\r\n        if (ref.startsWith(prefix)) {\r\n          protectedBranches.add(ref.slice(prefix.length));\r\n        }\r\n      } catch {\r\n        // No origin/HEAD (or not a git repo) - ignore\r\n      }\r\n\r\n      if (protectedBranches.has(branchToDelete)) {\r\n        log.debug(\"Skipping git branch deletion: protected branch\", {\r\n          projectPath,\r\n          workspaceName: branchToDelete,\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Extra safety: don't delete a branch still checked out by any worktree.\r\n      try {\r\n        using worktreeProc = execAsync(`git -C \"${projectPath}\" worktree list --porcelain`);\r\n        const { stdout } = await worktreeProc.result;\r\n        const needle = `branch refs/heads/${branchToDelete}`;\r\n        const isCheckedOut = stdout.split(\"\\n\").some((line) => line.trim() === needle);\r\n        if (isCheckedOut) {\r\n          log.debug(\"Skipping git branch deletion: branch still checked out by a worktree\", {\r\n            projectPath,\r\n            workspaceName: branchToDelete,\r\n          });\r\n          return;\r\n        }\r\n      } catch (error) {\r\n        // If the worktree list fails, proceed anyway - git itself will refuse to delete a checked-out branch.\r\n        log.debug(\"Failed to check worktree list before branch deletion; proceeding\", {\r\n          projectPath,\r\n          workspaceName: branchToDelete,\r\n          error: getErrorMessage(error),\r\n        });\r\n      }\r\n\r\n      const deleteFlag = force ? \"-D\" : \"-d\";\r\n      try {\r\n        using deleteProc = execAsync(\r\n          `git -C \"${projectPath}\" branch ${deleteFlag} \"${branchToDelete}\"`\r\n        );\r\n        await deleteProc.result;\r\n      } catch (error) {\r\n        // Best-effort: workspace deletion should not fail just because branch cleanup failed.\r\n        log.debug(\"Failed to delete git branch after removing worktree\", {\r\n          projectPath,\r\n          workspaceName: branchToDelete,\r\n          error: getErrorMessage(error),\r\n        });\r\n      }\r\n    };\r\n\r\n    // Compute workspace path using the canonical method\r\n    const deletedPath = this.getWorkspacePath(projectPath, workspaceName);\r\n\r\n    // Check if directory exists - if not, operation is idempotent\r\n    try {\r\n      await fsPromises.access(deletedPath);\r\n    } catch {\r\n      // Directory doesn't exist - operation is idempotent\r\n      // For standard worktrees, prune stale git records (best effort)\r\n      if (!isInPlace) {\r\n        try {\r\n          using pruneProc = execAsync(`git -C \"${projectPath}\" worktree prune`);\r\n          await pruneProc.result;\r\n        } catch {\r\n          // Ignore prune errors - directory is already deleted, which is the goal\r\n        }\r\n      }\r\n\r\n      // Best-effort: also delete the local branch.\r\n      await tryDeleteBranch();\r\n      return { success: true, deletedPath };\r\n    }\r\n\r\n    // For in-place workspaces, there's no worktree to remove\r\n    // Just return success - the workspace directory itself should not be deleted\r\n    // as it may contain the user's actual project files\r\n    if (isInPlace) {\r\n      return { success: true, deletedPath };\r\n    }\r\n\r\n    try {\r\n      // Use git worktree remove to delete the worktree\r\n      // This updates git's internal worktree metadata correctly\r\n      // Only use --force if explicitly requested by the caller\r\n      const forceFlag = force ? \" --force\" : \"\";\r\n      using proc = execAsync(\r\n        `git -C \"${projectPath}\" worktree remove${forceFlag} \"${deletedPath}\"`\r\n      );\r\n      await proc.result;\r\n\r\n      // Best-effort: also delete the local branch.\r\n      await tryDeleteBranch();\r\n      return { success: true, deletedPath };\r\n    } catch (error) {\r\n      const message = getErrorMessage(error);\r\n\r\n      // Check if the error is due to missing/stale worktree\r\n      const normalizedError = message.toLowerCase();\r\n      const looksLikeMissingWorktree =\r\n        normalizedError.includes(\"not a working tree\") ||\r\n        normalizedError.includes(\"does not exist\") ||\r\n        normalizedError.includes(\"no such file\");\r\n\r\n      if (looksLikeMissingWorktree) {\r\n        // Worktree records are stale - prune them\r\n        try {\r\n          using pruneProc = execAsync(`git -C \"${projectPath}\" worktree prune`);\r\n          await pruneProc.result;\r\n        } catch {\r\n          // Ignore prune errors\r\n        }\r\n        // Treat as success - workspace is gone (idempotent)\r\n        await tryDeleteBranch();\r\n        return { success: true, deletedPath };\r\n      }\r\n\r\n      // If force is enabled and git worktree remove failed, fall back to rm -rf\r\n      // This handles edge cases like submodules where git refuses to delete\r\n      if (force) {\r\n        try {\r\n          // Prune git's worktree records first (best effort)\r\n          try {\r\n            using pruneProc = execAsync(`git -C \"${projectPath}\" worktree prune`);\r\n            await pruneProc.result;\r\n          } catch {\r\n            // Ignore prune errors - we'll still try rm -rf\r\n          }\r\n\r\n          // Force delete the directory (use bash shell for rm -rf on Windows)\r\n          // Convert to POSIX path for Git Bash compatibility on Windows\r\n          using rmProc = execAsync(`rm -rf \"${toPosixPath(deletedPath)}\"`, {\r\n            shell: getBashPath(),\r\n          });\r\n          await rmProc.result;\r\n\r\n          // Best-effort: also delete the local branch.\r\n          await tryDeleteBranch();\r\n          return { success: true, deletedPath };\r\n        } catch (rmError) {\r\n          return {\r\n            success: false,\r\n            error: `Failed to remove worktree via git and rm: ${getErrorMessage(rmError)}`,\r\n          };\r\n        }\r\n      }\r\n\r\n      // force=false - return the git error without attempting rm -rf\r\n      return { success: false, error: `Failed to remove worktree: ${message}` };\r\n    }\r\n  }\r\n\r\n  async forkWorkspace(params: WorkspaceForkParams): Promise<WorkspaceForkResult> {\r\n    const { projectPath, sourceWorkspaceName, newWorkspaceName, initLogger } = params;\r\n\r\n    // Get source workspace path\r\n    const sourceWorkspacePath = this.getWorkspacePath(projectPath, sourceWorkspaceName);\r\n\r\n    // Get current branch from source workspace\r\n    try {\r\n      using proc = execAsync(`git -C \"${sourceWorkspacePath}\" branch --show-current`);\r\n      const { stdout } = await proc.result;\r\n      const sourceBranch = stdout.trim();\r\n\r\n      if (!sourceBranch) {\r\n        return {\r\n          success: false,\r\n          error: \"Failed to detect branch in source workspace\",\r\n        };\r\n      }\r\n\r\n      // Use createWorkspace with sourceBranch as trunk to fork from source branch\r\n      const createResult = await this.createWorkspace({\r\n        projectPath,\r\n        branchName: newWorkspaceName,\r\n        trunkBranch: sourceBranch, // Fork from source branch instead of main/master\r\n        initLogger,\r\n      });\r\n\r\n      if (!createResult.success || !createResult.workspacePath) {\r\n        return {\r\n          success: false,\r\n          error: createResult.error ?? \"Failed to create workspace\",\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        workspacePath: createResult.workspacePath,\r\n        sourceBranch,\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: getErrorMessage(error),\r\n      };\r\n    }\r\n  }\r\n}\r\n"]}