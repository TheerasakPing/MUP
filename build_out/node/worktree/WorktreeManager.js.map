{"version":3,"file":"WorktreeManager.js","sourceRoot":"","sources":["../../../src/node/worktree/WorktreeManager.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fsPromises from \"fs/promises\";\nimport * as path from \"path\";\nimport type {\n  WorkspaceCreationResult,\n  WorkspaceForkParams,\n  WorkspaceForkResult,\n  InitLogger,\n} from \"@/node/runtime/Runtime\";\nimport { listLocalBranches, cleanStaleLock, getCurrentBranch } from \"@/node/git\";\nimport { execAsync } from \"@/node/utils/disposableExec\";\nimport { getBashPath } from \"@/node/utils/main/bashPath\";\nimport { getProjectName } from \"@/node/utils/runtime/helpers\";\nimport { getErrorMessage } from \"@/common/utils/errors\";\nimport { expandTilde } from \"@/node/runtime/tildeExpansion\";\nimport { toPosixPath } from \"@/node/utils/paths\";\nimport { log } from \"@/node/services/log\";\n\nexport class WorktreeManager {\n  private readonly srcBaseDir: string;\n\n  constructor(srcBaseDir: string) {\n    // Expand tilde to actual home directory path for local file system operations\n    this.srcBaseDir = expandTilde(srcBaseDir);\n  }\n\n  getWorkspacePath(projectPath: string, workspaceName: string): string {\n    const projectName = getProjectName(projectPath);\n    return path.join(this.srcBaseDir, projectName, workspaceName);\n  }\n\n  async createWorkspace(params: {\n    projectPath: string;\n    branchName: string;\n    trunkBranch: string;\n    initLogger: InitLogger;\n  }): Promise<WorkspaceCreationResult> {\n    const { projectPath, branchName, trunkBranch, initLogger } = params;\n\n    // Clean up stale lock before git operations on main repo\n    cleanStaleLock(projectPath);\n\n    try {\n      // Compute workspace path using the canonical method\n      const workspacePath = this.getWorkspacePath(projectPath, branchName);\n      initLogger.logStep(\"Creating git worktree...\");\n\n      // Create parent directory if needed\n      const parentDir = path.dirname(workspacePath);\n      try {\n        await fsPromises.access(parentDir);\n      } catch {\n        await fsPromises.mkdir(parentDir, { recursive: true });\n      }\n\n      // Check if workspace already exists\n      try {\n        await fsPromises.access(workspacePath);\n        return {\n          success: false,\n          error: `Workspace already exists at ${workspacePath}`,\n        };\n      } catch {\n        // Workspace doesn't exist, proceed with creation\n      }\n\n      // Check if branch exists locally\n      const localBranches = await listLocalBranches(projectPath);\n      const branchExists = localBranches.includes(branchName);\n\n      // Fetch origin before creating worktree (best-effort)\n      // This ensures new branches start from the latest origin state\n      const fetchedOrigin = await this.fetchOriginTrunk(projectPath, trunkBranch, initLogger);\n\n      // Determine best base for new branches: use origin if local can fast-forward to it,\n      // otherwise preserve local state (user may have unpushed work)\n      const shouldUseOrigin =\n        fetchedOrigin && (await this.canFastForwardToOrigin(projectPath, trunkBranch, initLogger));\n\n      // Create worktree (git worktree is typically fast)\n      if (branchExists) {\n        // Branch exists, just add worktree pointing to it\n        using proc = execAsync(\n          `git -C \"${projectPath}\" worktree add \"${workspacePath}\" \"${branchName}\"`\n        );\n        await proc.result;\n      } else {\n        // Branch doesn't exist, create from the best available base:\n        // - origin/<trunk> if local is behind/equal (ensures fresh starting point)\n        // - local <trunk> if local is ahead/diverged (preserves user's work)\n        const newBranchBase = shouldUseOrigin ? `origin/${trunkBranch}` : trunkBranch;\n        using proc = execAsync(\n          `git -C \"${projectPath}\" worktree add -b \"${branchName}\" \"${workspacePath}\" \"${newBranchBase}\"`\n        );\n        await proc.result;\n      }\n\n      initLogger.logStep(\"Worktree created successfully\");\n\n      // For existing branches, fast-forward to latest origin (best-effort)\n      // Only if local can fast-forward (preserves unpushed work)\n      if (shouldUseOrigin && branchExists) {\n        await this.fastForwardToOrigin(workspacePath, trunkBranch, initLogger);\n      }\n\n      return { success: true, workspacePath };\n    } catch (error) {\n      return {\n        success: false,\n        error: getErrorMessage(error),\n      };\n    }\n  }\n\n  /**\n   * Fetch trunk branch from origin before worktree creation.\n   * Returns true if fetch succeeded (origin is available for branching).\n   */\n  private async fetchOriginTrunk(\n    projectPath: string,\n    trunkBranch: string,\n    initLogger: InitLogger\n  ): Promise<boolean> {\n    try {\n      initLogger.logStep(`Fetching latest from origin/${trunkBranch}...`);\n\n      using fetchProc = execAsync(`git -C \"${projectPath}\" fetch origin \"${trunkBranch}\"`);\n      await fetchProc.result;\n\n      initLogger.logStep(\"Fetched latest from origin\");\n      return true;\n    } catch (error) {\n      const errorMsg = getErrorMessage(error);\n      // Branch doesn't exist on origin (common for subagent local-only branches)\n      if (errorMsg.includes(\"couldn't find remote ref\")) {\n        initLogger.logStep(`Branch \"${trunkBranch}\" not found on origin; using local state.`);\n      } else {\n        initLogger.logStderr(\n          `Note: Could not fetch from origin (${errorMsg}), using local branch state`\n        );\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Check if local trunk can fast-forward to origin/<trunk>.\n   * Returns true if local is behind or equal to origin (safe to use origin).\n   * Returns false if local is ahead or diverged (preserve local state).\n   */\n  private async canFastForwardToOrigin(\n    projectPath: string,\n    trunkBranch: string,\n    initLogger: InitLogger\n  ): Promise<boolean> {\n    try {\n      // Check if local trunk is an ancestor of origin/trunk\n      // Exit code 0 = local is ancestor (can fast-forward), non-zero = cannot\n      using proc = execAsync(\n        `git -C \"${projectPath}\" merge-base --is-ancestor \"${trunkBranch}\" \"origin/${trunkBranch}\"`\n      );\n      await proc.result;\n      return true; // Local is behind or equal to origin\n    } catch {\n      // Local is ahead or diverged - preserve local state\n      initLogger.logStderr(\n        `Note: Local ${trunkBranch} is ahead of or diverged from origin, using local state`\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Fast-forward merge to latest origin/<trunkBranch> after checkout.\n   * Best-effort operation for existing branches that may be behind origin.\n   */\n  private async fastForwardToOrigin(\n    workspacePath: string,\n    trunkBranch: string,\n    initLogger: InitLogger\n  ): Promise<void> {\n    try {\n      initLogger.logStep(\"Fast-forward merging...\");\n\n      using mergeProc = execAsync(\n        `git -C \"${workspacePath}\" merge --ff-only \"origin/${trunkBranch}\"`\n      );\n      await mergeProc.result;\n      initLogger.logStep(\"Fast-forwarded to latest origin successfully\");\n    } catch (mergeError) {\n      // Fast-forward not possible (diverged branches) - just warn\n      const errorMsg = getErrorMessage(mergeError);\n      initLogger.logStderr(`Note: Fast-forward failed (${errorMsg}), using local branch state`);\n    }\n  }\n\n  async renameWorkspace(\n    projectPath: string,\n    oldName: string,\n    newName: string\n  ): Promise<\n    { success: true; oldPath: string; newPath: string } | { success: false; error: string }\n  > {\n    // Clean up stale lock before git operations on main repo\n    cleanStaleLock(projectPath);\n\n    // Compute workspace paths using canonical method\n    const oldPath = this.getWorkspacePath(projectPath, oldName);\n    const newPath = this.getWorkspacePath(projectPath, newName);\n\n    try {\n      // Move the worktree directory (updates git's internal worktree metadata)\n      using moveProc = execAsync(`git -C \"${projectPath}\" worktree move \"${oldPath}\" \"${newPath}\"`);\n      await moveProc.result;\n\n      // Rename the git branch to match the new workspace name\n      // In mux, branch name and workspace name are always kept in sync.\n      // Run from the new worktree path since that's where the branch is checked out.\n      // Best-effort: ignore errors (e.g., branch might have a different name in test scenarios).\n      try {\n        using branchProc = execAsync(`git -C \"${newPath}\" branch -m \"${oldName}\" \"${newName}\"`);\n        await branchProc.result;\n      } catch {\n        // Branch rename failed - this is fine, the directory was still moved\n        // This can happen if the branch name doesn't match the old directory name\n      }\n\n      return { success: true, oldPath, newPath };\n    } catch (error) {\n      return { success: false, error: `Failed to rename workspace: ${getErrorMessage(error)}` };\n    }\n  }\n\n  async deleteWorkspace(\n    projectPath: string,\n    workspaceName: string,\n    force: boolean\n  ): Promise<{ success: true; deletedPath: string } | { success: false; error: string }> {\n    // Clean up stale lock before git operations on main repo\n    cleanStaleLock(projectPath);\n\n    // In-place workspaces are identified by projectPath === workspaceName\n    // These are direct workspace directories (e.g., CLI/benchmark sessions), not git worktrees\n    const isInPlace = projectPath === workspaceName;\n\n    // For git worktree workspaces, workspaceName is the branch name.\n    // Now that archiving exists, deleting a workspace should also delete its local branch by default.\n    const shouldDeleteBranch = !isInPlace;\n\n    const tryDeleteBranch = async () => {\n      if (!shouldDeleteBranch) return;\n\n      const branchToDelete = workspaceName.trim();\n      if (!branchToDelete) {\n        log.debug(\"Skipping git branch deletion: empty workspace name\", {\n          projectPath,\n          workspaceName,\n        });\n        return;\n      }\n\n      let localBranches: string[];\n      try {\n        localBranches = await listLocalBranches(projectPath);\n      } catch (error) {\n        log.debug(\"Failed to list local branches; skipping branch deletion\", {\n          projectPath,\n          workspaceName: branchToDelete,\n          error: getErrorMessage(error),\n        });\n        return;\n      }\n\n      if (!localBranches.includes(branchToDelete)) {\n        log.debug(\"Skipping git branch deletion: branch does not exist locally\", {\n          projectPath,\n          workspaceName: branchToDelete,\n        });\n        return;\n      }\n\n      // Never delete protected/trunk branches.\n      const protectedBranches = new Set<string>([\"main\", \"master\", \"trunk\", \"develop\", \"default\"]);\n\n      // If there's only one local branch, treat it as protected (likely trunk).\n      if (localBranches.length === 1) {\n        protectedBranches.add(localBranches[0]);\n      }\n\n      const currentBranch = await getCurrentBranch(projectPath);\n      if (currentBranch) {\n        protectedBranches.add(currentBranch);\n      }\n\n      // If origin/HEAD points at a local branch, also treat it as protected.\n      try {\n        using originHeadProc = execAsync(\n          `git -C \"${projectPath}\" symbolic-ref refs/remotes/origin/HEAD`\n        );\n        const { stdout } = await originHeadProc.result;\n        const ref = stdout.trim();\n        const prefix = \"refs/remotes/origin/\";\n        if (ref.startsWith(prefix)) {\n          protectedBranches.add(ref.slice(prefix.length));\n        }\n      } catch {\n        // No origin/HEAD (or not a git repo) - ignore\n      }\n\n      if (protectedBranches.has(branchToDelete)) {\n        log.debug(\"Skipping git branch deletion: protected branch\", {\n          projectPath,\n          workspaceName: branchToDelete,\n        });\n        return;\n      }\n\n      // Extra safety: don't delete a branch still checked out by any worktree.\n      try {\n        using worktreeProc = execAsync(`git -C \"${projectPath}\" worktree list --porcelain`);\n        const { stdout } = await worktreeProc.result;\n        const needle = `branch refs/heads/${branchToDelete}`;\n        const isCheckedOut = stdout.split(\"\\n\").some((line) => line.trim() === needle);\n        if (isCheckedOut) {\n          log.debug(\"Skipping git branch deletion: branch still checked out by a worktree\", {\n            projectPath,\n            workspaceName: branchToDelete,\n          });\n          return;\n        }\n      } catch (error) {\n        // If the worktree list fails, proceed anyway - git itself will refuse to delete a checked-out branch.\n        log.debug(\"Failed to check worktree list before branch deletion; proceeding\", {\n          projectPath,\n          workspaceName: branchToDelete,\n          error: getErrorMessage(error),\n        });\n      }\n\n      const deleteFlag = force ? \"-D\" : \"-d\";\n      try {\n        using deleteProc = execAsync(\n          `git -C \"${projectPath}\" branch ${deleteFlag} \"${branchToDelete}\"`\n        );\n        await deleteProc.result;\n      } catch (error) {\n        // Best-effort: workspace deletion should not fail just because branch cleanup failed.\n        log.debug(\"Failed to delete git branch after removing worktree\", {\n          projectPath,\n          workspaceName: branchToDelete,\n          error: getErrorMessage(error),\n        });\n      }\n    };\n\n    // Compute workspace path using the canonical method\n    const deletedPath = this.getWorkspacePath(projectPath, workspaceName);\n\n    // Check if directory exists - if not, operation is idempotent\n    try {\n      await fsPromises.access(deletedPath);\n    } catch {\n      // Directory doesn't exist - operation is idempotent\n      // For standard worktrees, prune stale git records (best effort)\n      if (!isInPlace) {\n        try {\n          using pruneProc = execAsync(`git -C \"${projectPath}\" worktree prune`);\n          await pruneProc.result;\n        } catch {\n          // Ignore prune errors - directory is already deleted, which is the goal\n        }\n      }\n\n      // Best-effort: also delete the local branch.\n      await tryDeleteBranch();\n      return { success: true, deletedPath };\n    }\n\n    // For in-place workspaces, there's no worktree to remove\n    // Just return success - the workspace directory itself should not be deleted\n    // as it may contain the user's actual project files\n    if (isInPlace) {\n      return { success: true, deletedPath };\n    }\n\n    try {\n      // Use git worktree remove to delete the worktree\n      // This updates git's internal worktree metadata correctly\n      // Only use --force if explicitly requested by the caller\n      const forceFlag = force ? \" --force\" : \"\";\n      using proc = execAsync(\n        `git -C \"${projectPath}\" worktree remove${forceFlag} \"${deletedPath}\"`\n      );\n      await proc.result;\n\n      // Best-effort: also delete the local branch.\n      await tryDeleteBranch();\n      return { success: true, deletedPath };\n    } catch (error) {\n      const message = getErrorMessage(error);\n\n      // Check if the error is due to missing/stale worktree\n      const normalizedError = message.toLowerCase();\n      const looksLikeMissingWorktree =\n        normalizedError.includes(\"not a working tree\") ||\n        normalizedError.includes(\"does not exist\") ||\n        normalizedError.includes(\"no such file\");\n\n      if (looksLikeMissingWorktree) {\n        // Worktree records are stale - prune them\n        try {\n          using pruneProc = execAsync(`git -C \"${projectPath}\" worktree prune`);\n          await pruneProc.result;\n        } catch {\n          // Ignore prune errors\n        }\n        // Treat as success - workspace is gone (idempotent)\n        await tryDeleteBranch();\n        return { success: true, deletedPath };\n      }\n\n      // If force is enabled and git worktree remove failed, fall back to rm -rf\n      // This handles edge cases like submodules where git refuses to delete\n      if (force) {\n        try {\n          // Prune git's worktree records first (best effort)\n          try {\n            using pruneProc = execAsync(`git -C \"${projectPath}\" worktree prune`);\n            await pruneProc.result;\n          } catch {\n            // Ignore prune errors - we'll still try rm -rf\n          }\n\n          // Force delete the directory (use bash shell for rm -rf on Windows)\n          // Convert to POSIX path for Git Bash compatibility on Windows\n          using rmProc = execAsync(`rm -rf \"${toPosixPath(deletedPath)}\"`, {\n            shell: getBashPath(),\n          });\n          await rmProc.result;\n\n          // Best-effort: also delete the local branch.\n          await tryDeleteBranch();\n          return { success: true, deletedPath };\n        } catch (rmError) {\n          return {\n            success: false,\n            error: `Failed to remove worktree via git and rm: ${getErrorMessage(rmError)}`,\n          };\n        }\n      }\n\n      // force=false - return the git error without attempting rm -rf\n      return { success: false, error: `Failed to remove worktree: ${message}` };\n    }\n  }\n\n  async forkWorkspace(params: WorkspaceForkParams): Promise<WorkspaceForkResult> {\n    const { projectPath, sourceWorkspaceName, newWorkspaceName, initLogger } = params;\n\n    // Get source workspace path\n    const sourceWorkspacePath = this.getWorkspacePath(projectPath, sourceWorkspaceName);\n\n    // Get current branch from source workspace\n    try {\n      using proc = execAsync(`git -C \"${sourceWorkspacePath}\" branch --show-current`);\n      const { stdout } = await proc.result;\n      const sourceBranch = stdout.trim();\n\n      if (!sourceBranch) {\n        return {\n          success: false,\n          error: \"Failed to detect branch in source workspace\",\n        };\n      }\n\n      // Use createWorkspace with sourceBranch as trunk to fork from source branch\n      const createResult = await this.createWorkspace({\n        projectPath,\n        branchName: newWorkspaceName,\n        trunkBranch: sourceBranch, // Fork from source branch instead of main/master\n        initLogger,\n      });\n\n      if (!createResult.success || !createResult.workspacePath) {\n        return {\n          success: false,\n          error: createResult.error ?? \"Failed to create workspace\",\n        };\n      }\n\n      return {\n        success: true,\n        workspacePath: createResult.workspacePath,\n        sourceBranch,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: getErrorMessage(error),\n      };\n    }\n  }\n}\n"]}