{"version":3,"file":"updater.test.js","sourceRoot":"","sources":["../../src/desktop/updater.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, it, expect, beforeEach, afterEach, mock } from \"bun:test\";\nimport { EventEmitter } from \"events\";\nimport { UpdaterService, type UpdateStatus } from \"./updater\";\n\n// Create a mock autoUpdater that's an EventEmitter with the required methods\nconst mockAutoUpdater = Object.assign(new EventEmitter(), {\n  autoDownload: false,\n  autoInstallOnAppQuit: true,\n  checkForUpdates: mock(() => Promise.resolve()),\n  downloadUpdate: mock(() => Promise.resolve()),\n  quitAndInstall: mock(() => {\n    // Mock implementation - does nothing in tests\n  }),\n});\n\n// Mock electron-updater module\nvoid mock.module(\"electron-updater\", () => ({\n  autoUpdater: mockAutoUpdater,\n}));\n\ndescribe(\"UpdaterService\", () => {\n  let service: UpdaterService;\n  let statusUpdates: UpdateStatus[];\n  let originalDebugUpdater: string | undefined;\n\n  beforeEach(() => {\n    // Reset mocks\n    mockAutoUpdater.checkForUpdates.mockClear();\n    mockAutoUpdater.downloadUpdate.mockClear();\n    mockAutoUpdater.quitAndInstall.mockClear();\n    mockAutoUpdater.removeAllListeners();\n\n    // Save and clear DEBUG_UPDATER to ensure clean test environment\n    originalDebugUpdater = process.env.DEBUG_UPDATER;\n    delete process.env.DEBUG_UPDATER;\n    service = new UpdaterService();\n\n    // Capture status updates via subscriber pattern (ORPC model)\n    statusUpdates = [];\n    service.subscribe((status) => statusUpdates.push(status));\n  });\n\n  afterEach(() => {\n    // Restore DEBUG_UPDATER\n    if (originalDebugUpdater !== undefined) {\n      process.env.DEBUG_UPDATER = originalDebugUpdater;\n    } else {\n      delete process.env.DEBUG_UPDATER;\n    }\n  });\n\n  describe(\"checkForUpdates\", () => {\n    it(\"should set status to 'checking' immediately and notify subscribers\", () => {\n      // Setup\n      mockAutoUpdater.checkForUpdates.mockReturnValue(Promise.resolve());\n\n      // Act\n      service.checkForUpdates();\n\n      // Assert - should immediately notify with 'checking' status\n      expect(statusUpdates).toContainEqual({ type: \"checking\" });\n    });\n\n    it(\"should transition to 'up-to-date' when no update found\", async () => {\n      // Setup\n      mockAutoUpdater.checkForUpdates.mockImplementation(() => {\n        // Simulate electron-updater behavior: emit event, return unresolved promise\n        setImmediate(() => {\n          mockAutoUpdater.emit(\"update-not-available\");\n        });\n        return new Promise(() => {\n          // Intentionally never resolves to simulate hanging promise\n        });\n      });\n\n      // Act\n      service.checkForUpdates();\n\n      // Wait for event to be processed\n      await new Promise((resolve) => setImmediate(resolve));\n\n      // Assert - should notify with 'up-to-date' status\n      expect(statusUpdates).toContainEqual({ type: \"checking\" });\n      expect(statusUpdates).toContainEqual({ type: \"up-to-date\" });\n    });\n\n    it(\"should transition to 'available' when update found\", async () => {\n      // Setup\n      const updateInfo = {\n        version: \"1.0.0\",\n        files: [],\n        path: \"test-path\",\n        sha512: \"test-sha\",\n        releaseDate: \"2025-01-01\",\n      };\n\n      mockAutoUpdater.checkForUpdates.mockImplementation(() => {\n        setImmediate(() => {\n          mockAutoUpdater.emit(\"update-available\", updateInfo);\n        });\n        return new Promise(() => {\n          // Intentionally never resolves to simulate hanging promise\n        });\n      });\n\n      // Act\n      service.checkForUpdates();\n\n      // Wait for event to be processed\n      await new Promise((resolve) => setImmediate(resolve));\n\n      // Assert\n      expect(statusUpdates).toContainEqual({ type: \"checking\" });\n      expect(statusUpdates).toContainEqual({ type: \"available\", info: updateInfo });\n    });\n\n    it(\"should handle errors from checkForUpdates\", async () => {\n      // Setup\n      const error = new Error(\"Network error\");\n\n      mockAutoUpdater.checkForUpdates.mockImplementation(() => {\n        return Promise.reject(error);\n      });\n\n      // Act\n      service.checkForUpdates();\n\n      // Wait a bit for error to be caught\n      await new Promise((resolve) => setImmediate(resolve));\n\n      // Assert\n      expect(statusUpdates).toContainEqual({ type: \"checking\" });\n\n      // Should eventually get error status\n      const errorStatus = statusUpdates.find((s) => s.type === \"error\");\n      expect(errorStatus).toBeDefined();\n      expect(errorStatus).toEqual({ type: \"error\", message: \"Network error\" });\n    });\n\n    it(\"should timeout if no events fire within 30 seconds\", () => {\n      // Use shorter timeout for testing (100ms instead of 30s)\n      // We'll verify the timeout logic works, not the exact timing\n      const originalSetTimeout = global.setTimeout;\n      let timeoutCallback: (() => void) | null = null;\n\n      // Mock setTimeout to capture the timeout callback\n      const globalObj = global as { setTimeout: typeof setTimeout };\n      globalObj.setTimeout = ((cb: () => void, _delay: number) => {\n        timeoutCallback = cb;\n        return 123 as unknown as ReturnType<typeof setTimeout>;\n      }) as typeof setTimeout;\n\n      // Setup - checkForUpdates returns promise that never resolves and emits no events\n      mockAutoUpdater.checkForUpdates.mockImplementation(() => {\n        return new Promise(() => {\n          // Intentionally never resolves to simulate hanging promise\n        });\n      });\n\n      // Act\n      service.checkForUpdates();\n\n      // Should be in checking state\n      expect(statusUpdates).toContainEqual({ type: \"checking\" });\n\n      // Manually trigger the timeout callback\n      expect(timeoutCallback).toBeTruthy();\n      timeoutCallback!();\n\n      // Should have timed out and returned to idle\n      const lastStatus = statusUpdates[statusUpdates.length - 1];\n      expect(lastStatus).toEqual({ type: \"idle\" });\n\n      // Restore original setTimeout\n      global.setTimeout = originalSetTimeout;\n    });\n  });\n\n  describe(\"getStatus\", () => {\n    it(\"should return initial status as idle\", () => {\n      const status = service.getStatus();\n      expect(status).toEqual({ type: \"idle\" });\n    });\n\n    it(\"should return current status after check starts\", () => {\n      mockAutoUpdater.checkForUpdates.mockReturnValue(Promise.resolve());\n\n      service.checkForUpdates();\n\n      const status = service.getStatus();\n      expect(status.type).toBe(\"checking\");\n    });\n  });\n});\n"]}