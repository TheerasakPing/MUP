{"version":3,"file":"updater.test.js","sourceRoot":"","sources":["../../src/desktop/updater.test.ts"],"names":[],"mappings":";;AAAA,uCAA6E;AAC7E,mCAAsC;AACtC,uCAA8D;AAE9D,6EAA6E;AAC7E,MAAM,eAAe,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,qBAAY,EAAE,EAAE;IACxD,YAAY,EAAE,KAAK;IACnB,oBAAoB,EAAE,IAAI;IAC1B,eAAe,EAAE,IAAA,eAAI,EAAC,GAAG,EAAE,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;IAC9C,cAAc,EAAE,IAAA,eAAI,EAAC,GAAG,EAAE,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;IAC7C,cAAc,EAAE,IAAA,eAAI,EAAC,GAAG,EAAE,CAAC;QACzB,8CAA8C;IADpB,CAE3B,CAAC;CACH,CAAC,CAAC;AAEH,+BAA+B;AAC/B,KAAK,eAAI,CAAC,MAAM,CAAC,kBAAkB,EAAE,GAAG,EAAE,CAAC,CAAC;IAC1C,WAAW,EAAE,eAAe;CAC7B,CAAC,CAAC,CAAC;AAEJ,IAAA,mBAAQ,EAAC,gBAAgB,EAAE,GAAG,EAAE,CAAC;IAC/B,IAAI,OAAuB,CAAC;IAC5B,IAAI,aAA6B,CAAC;IAClC,IAAI,oBAAwC,CAAC;IAE7C,IAAA,qBAAU,EAAC,GAAG,EAAE,CAAC;QACf,cAAc;QACd,eAAe,CAAC,eAAe,CAAC,SAAS,EAAE,CAAC;QAC5C,eAAe,CAAC,cAAc,CAAC,SAAS,EAAE,CAAC;QAC3C,eAAe,CAAC,cAAc,CAAC,SAAS,EAAE,CAAC;QAC3C,eAAe,CAAC,kBAAkB,EAAE,CAAC;QAErC,gEAAgE;QAChE,oBAAoB,GAAG,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC;QACjD,OAAO,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC;QACjC,OAAO,GAAG,IAAI,wBAAc,EAAE,CAAC;QAE/B,6DAA6D;QAC7D,aAAa,GAAG,EAAE,CAAC;QACnB,OAAO,CAAC,SAAS,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;IAAA,CAC3D,CAAC,CAAC;IAEH,IAAA,oBAAS,EAAC,GAAG,EAAE,CAAC;QACd,wBAAwB;QACxB,IAAI,oBAAoB,KAAK,SAAS,EAAE,CAAC;YACvC,OAAO,CAAC,GAAG,CAAC,aAAa,GAAG,oBAAoB,CAAC;QACnD,CAAC;aAAM,CAAC;YACN,OAAO,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC;QACnC,CAAC;IAAA,CACF,CAAC,CAAC;IAEH,IAAA,mBAAQ,EAAC,iBAAiB,EAAE,GAAG,EAAE,CAAC;QAChC,IAAA,aAAE,EAAC,oEAAoE,EAAE,GAAG,EAAE,CAAC;YAC7E,QAAQ;YACR,eAAe,CAAC,eAAe,CAAC,eAAe,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;YAEnE,MAAM;YACN,OAAO,CAAC,eAAe,EAAE,CAAC;YAE1B,4DAA4D;YAC5D,IAAA,iBAAM,EAAC,aAAa,CAAC,CAAC,cAAc,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC,CAAC;QAAA,CAC5D,CAAC,CAAC;QAEH,IAAA,aAAE,EAAC,wDAAwD,EAAE,KAAK,IAAI,EAAE,CAAC;YACvE,QAAQ;YACR,eAAe,CAAC,eAAe,CAAC,kBAAkB,CAAC,GAAG,EAAE,CAAC;gBACvD,4EAA4E;gBAC5E,YAAY,CAAC,GAAG,EAAE,CAAC;oBACjB,eAAe,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC;gBAAA,CAC9C,CAAC,CAAC;gBACH,OAAO,IAAI,OAAO,CAAC,GAAG,EAAE,CAAC;oBACvB,2DAA2D;gBADnC,CAEzB,CAAC,CAAC;YAAA,CACJ,CAAC,CAAC;YAEH,MAAM;YACN,OAAO,CAAC,eAAe,EAAE,CAAC;YAE1B,iCAAiC;YACjC,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC;YAEtD,kDAAkD;YAClD,IAAA,iBAAM,EAAC,aAAa,CAAC,CAAC,cAAc,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC,CAAC;YAC3D,IAAA,iBAAM,EAAC,aAAa,CAAC,CAAC,cAAc,CAAC,EAAE,IAAI,EAAE,YAAY,EAAE,CAAC,CAAC;QAAA,CAC9D,CAAC,CAAC;QAEH,IAAA,aAAE,EAAC,oDAAoD,EAAE,KAAK,IAAI,EAAE,CAAC;YACnE,QAAQ;YACR,MAAM,UAAU,GAAG;gBACjB,OAAO,EAAE,OAAO;gBAChB,KAAK,EAAE,EAAE;gBACT,IAAI,EAAE,WAAW;gBACjB,MAAM,EAAE,UAAU;gBAClB,WAAW,EAAE,YAAY;aAC1B,CAAC;YAEF,eAAe,CAAC,eAAe,CAAC,kBAAkB,CAAC,GAAG,EAAE,CAAC;gBACvD,YAAY,CAAC,GAAG,EAAE,CAAC;oBACjB,eAAe,CAAC,IAAI,CAAC,kBAAkB,EAAE,UAAU,CAAC,CAAC;gBAAA,CACtD,CAAC,CAAC;gBACH,OAAO,IAAI,OAAO,CAAC,GAAG,EAAE,CAAC;oBACvB,2DAA2D;gBADnC,CAEzB,CAAC,CAAC;YAAA,CACJ,CAAC,CAAC;YAEH,MAAM;YACN,OAAO,CAAC,eAAe,EAAE,CAAC;YAE1B,iCAAiC;YACjC,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC;YAEtD,SAAS;YACT,IAAA,iBAAM,EAAC,aAAa,CAAC,CAAC,cAAc,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC,CAAC;YAC3D,IAAA,iBAAM,EAAC,aAAa,CAAC,CAAC,cAAc,CAAC,EAAE,IAAI,EAAE,WAAW,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC,CAAC;QAAA,CAC/E,CAAC,CAAC;QAEH,IAAA,aAAE,EAAC,2CAA2C,EAAE,KAAK,IAAI,EAAE,CAAC;YAC1D,QAAQ;YACR,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;YAEzC,eAAe,CAAC,eAAe,CAAC,kBAAkB,CAAC,GAAG,EAAE,CAAC;gBACvD,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAAA,CAC9B,CAAC,CAAC;YAEH,MAAM;YACN,OAAO,CAAC,eAAe,EAAE,CAAC;YAE1B,oCAAoC;YACpC,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC;YAEtD,SAAS;YACT,IAAA,iBAAM,EAAC,aAAa,CAAC,CAAC,cAAc,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC,CAAC;YAE3D,qCAAqC;YACrC,MAAM,WAAW,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,OAAO,CAAC,CAAC;YAClE,IAAA,iBAAM,EAAC,WAAW,CAAC,CAAC,WAAW,EAAE,CAAC;YAClC,IAAA,iBAAM,EAAC,WAAW,CAAC,CAAC,OAAO,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,eAAe,EAAE,CAAC,CAAC;QAAA,CAC1E,CAAC,CAAC;QAEH,IAAA,aAAE,EAAC,oDAAoD,EAAE,GAAG,EAAE,CAAC;YAC7D,yDAAyD;YACzD,6DAA6D;YAC7D,MAAM,kBAAkB,GAAG,MAAM,CAAC,UAAU,CAAC;YAC7C,IAAI,eAAe,GAAwB,IAAI,CAAC;YAEhD,kDAAkD;YAClD,MAAM,SAAS,GAAG,MAA2C,CAAC;YAC9D,SAAS,CAAC,UAAU,GAAG,CAAC,CAAC,EAAc,EAAE,MAAc,EAAE,EAAE,CAAC;gBAC1D,eAAe,GAAG,EAAE,CAAC;gBACrB,OAAO,GAA+C,CAAC;YAAA,CACxD,CAAsB,CAAC;YAExB,kFAAkF;YAClF,eAAe,CAAC,eAAe,CAAC,kBAAkB,CAAC,GAAG,EAAE,CAAC;gBACvD,OAAO,IAAI,OAAO,CAAC,GAAG,EAAE,CAAC;oBACvB,2DAA2D;gBADnC,CAEzB,CAAC,CAAC;YAAA,CACJ,CAAC,CAAC;YAEH,MAAM;YACN,OAAO,CAAC,eAAe,EAAE,CAAC;YAE1B,8BAA8B;YAC9B,IAAA,iBAAM,EAAC,aAAa,CAAC,CAAC,cAAc,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC,CAAC;YAE3D,wCAAwC;YACxC,IAAA,iBAAM,EAAC,eAAe,CAAC,CAAC,UAAU,EAAE,CAAC;YACrC,eAAgB,EAAE,CAAC;YAEnB,6CAA6C;YAC7C,MAAM,UAAU,GAAG,aAAa,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YAC3D,IAAA,iBAAM,EAAC,UAAU,CAAC,CAAC,OAAO,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC,CAAC;YAE7C,8BAA8B;YAC9B,MAAM,CAAC,UAAU,GAAG,kBAAkB,CAAC;QAAA,CACxC,CAAC,CAAC;IAAA,CACJ,CAAC,CAAC;IAEH,IAAA,mBAAQ,EAAC,WAAW,EAAE,GAAG,EAAE,CAAC;QAC1B,IAAA,aAAE,EAAC,sCAAsC,EAAE,GAAG,EAAE,CAAC;YAC/C,MAAM,MAAM,GAAG,OAAO,CAAC,SAAS,EAAE,CAAC;YACnC,IAAA,iBAAM,EAAC,MAAM,CAAC,CAAC,OAAO,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC,CAAC;QAAA,CAC1C,CAAC,CAAC;QAEH,IAAA,aAAE,EAAC,iDAAiD,EAAE,GAAG,EAAE,CAAC;YAC1D,eAAe,CAAC,eAAe,CAAC,eAAe,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;YAEnE,OAAO,CAAC,eAAe,EAAE,CAAC;YAE1B,MAAM,MAAM,GAAG,OAAO,CAAC,SAAS,EAAE,CAAC;YACnC,IAAA,iBAAM,EAAC,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAAA,CACtC,CAAC,CAAC;IAAA,CACJ,CAAC,CAAC;AAAA,CACJ,CAAC,CAAC","sourcesContent":["import { describe, it, expect, beforeEach, afterEach, mock } from \"bun:test\";\r\nimport { EventEmitter } from \"events\";\r\nimport { UpdaterService, type UpdateStatus } from \"./updater\";\r\n\r\n// Create a mock autoUpdater that's an EventEmitter with the required methods\r\nconst mockAutoUpdater = Object.assign(new EventEmitter(), {\r\n  autoDownload: false,\r\n  autoInstallOnAppQuit: true,\r\n  checkForUpdates: mock(() => Promise.resolve()),\r\n  downloadUpdate: mock(() => Promise.resolve()),\r\n  quitAndInstall: mock(() => {\r\n    // Mock implementation - does nothing in tests\r\n  }),\r\n});\r\n\r\n// Mock electron-updater module\r\nvoid mock.module(\"electron-updater\", () => ({\r\n  autoUpdater: mockAutoUpdater,\r\n}));\r\n\r\ndescribe(\"UpdaterService\", () => {\r\n  let service: UpdaterService;\r\n  let statusUpdates: UpdateStatus[];\r\n  let originalDebugUpdater: string | undefined;\r\n\r\n  beforeEach(() => {\r\n    // Reset mocks\r\n    mockAutoUpdater.checkForUpdates.mockClear();\r\n    mockAutoUpdater.downloadUpdate.mockClear();\r\n    mockAutoUpdater.quitAndInstall.mockClear();\r\n    mockAutoUpdater.removeAllListeners();\r\n\r\n    // Save and clear DEBUG_UPDATER to ensure clean test environment\r\n    originalDebugUpdater = process.env.DEBUG_UPDATER;\r\n    delete process.env.DEBUG_UPDATER;\r\n    service = new UpdaterService();\r\n\r\n    // Capture status updates via subscriber pattern (ORPC model)\r\n    statusUpdates = [];\r\n    service.subscribe((status) => statusUpdates.push(status));\r\n  });\r\n\r\n  afterEach(() => {\r\n    // Restore DEBUG_UPDATER\r\n    if (originalDebugUpdater !== undefined) {\r\n      process.env.DEBUG_UPDATER = originalDebugUpdater;\r\n    } else {\r\n      delete process.env.DEBUG_UPDATER;\r\n    }\r\n  });\r\n\r\n  describe(\"checkForUpdates\", () => {\r\n    it(\"should set status to 'checking' immediately and notify subscribers\", () => {\r\n      // Setup\r\n      mockAutoUpdater.checkForUpdates.mockReturnValue(Promise.resolve());\r\n\r\n      // Act\r\n      service.checkForUpdates();\r\n\r\n      // Assert - should immediately notify with 'checking' status\r\n      expect(statusUpdates).toContainEqual({ type: \"checking\" });\r\n    });\r\n\r\n    it(\"should transition to 'up-to-date' when no update found\", async () => {\r\n      // Setup\r\n      mockAutoUpdater.checkForUpdates.mockImplementation(() => {\r\n        // Simulate electron-updater behavior: emit event, return unresolved promise\r\n        setImmediate(() => {\r\n          mockAutoUpdater.emit(\"update-not-available\");\r\n        });\r\n        return new Promise(() => {\r\n          // Intentionally never resolves to simulate hanging promise\r\n        });\r\n      });\r\n\r\n      // Act\r\n      service.checkForUpdates();\r\n\r\n      // Wait for event to be processed\r\n      await new Promise((resolve) => setImmediate(resolve));\r\n\r\n      // Assert - should notify with 'up-to-date' status\r\n      expect(statusUpdates).toContainEqual({ type: \"checking\" });\r\n      expect(statusUpdates).toContainEqual({ type: \"up-to-date\" });\r\n    });\r\n\r\n    it(\"should transition to 'available' when update found\", async () => {\r\n      // Setup\r\n      const updateInfo = {\r\n        version: \"1.0.0\",\r\n        files: [],\r\n        path: \"test-path\",\r\n        sha512: \"test-sha\",\r\n        releaseDate: \"2025-01-01\",\r\n      };\r\n\r\n      mockAutoUpdater.checkForUpdates.mockImplementation(() => {\r\n        setImmediate(() => {\r\n          mockAutoUpdater.emit(\"update-available\", updateInfo);\r\n        });\r\n        return new Promise(() => {\r\n          // Intentionally never resolves to simulate hanging promise\r\n        });\r\n      });\r\n\r\n      // Act\r\n      service.checkForUpdates();\r\n\r\n      // Wait for event to be processed\r\n      await new Promise((resolve) => setImmediate(resolve));\r\n\r\n      // Assert\r\n      expect(statusUpdates).toContainEqual({ type: \"checking\" });\r\n      expect(statusUpdates).toContainEqual({ type: \"available\", info: updateInfo });\r\n    });\r\n\r\n    it(\"should handle errors from checkForUpdates\", async () => {\r\n      // Setup\r\n      const error = new Error(\"Network error\");\r\n\r\n      mockAutoUpdater.checkForUpdates.mockImplementation(() => {\r\n        return Promise.reject(error);\r\n      });\r\n\r\n      // Act\r\n      service.checkForUpdates();\r\n\r\n      // Wait a bit for error to be caught\r\n      await new Promise((resolve) => setImmediate(resolve));\r\n\r\n      // Assert\r\n      expect(statusUpdates).toContainEqual({ type: \"checking\" });\r\n\r\n      // Should eventually get error status\r\n      const errorStatus = statusUpdates.find((s) => s.type === \"error\");\r\n      expect(errorStatus).toBeDefined();\r\n      expect(errorStatus).toEqual({ type: \"error\", message: \"Network error\" });\r\n    });\r\n\r\n    it(\"should timeout if no events fire within 30 seconds\", () => {\r\n      // Use shorter timeout for testing (100ms instead of 30s)\r\n      // We'll verify the timeout logic works, not the exact timing\r\n      const originalSetTimeout = global.setTimeout;\r\n      let timeoutCallback: (() => void) | null = null;\r\n\r\n      // Mock setTimeout to capture the timeout callback\r\n      const globalObj = global as { setTimeout: typeof setTimeout };\r\n      globalObj.setTimeout = ((cb: () => void, _delay: number) => {\r\n        timeoutCallback = cb;\r\n        return 123 as unknown as ReturnType<typeof setTimeout>;\r\n      }) as typeof setTimeout;\r\n\r\n      // Setup - checkForUpdates returns promise that never resolves and emits no events\r\n      mockAutoUpdater.checkForUpdates.mockImplementation(() => {\r\n        return new Promise(() => {\r\n          // Intentionally never resolves to simulate hanging promise\r\n        });\r\n      });\r\n\r\n      // Act\r\n      service.checkForUpdates();\r\n\r\n      // Should be in checking state\r\n      expect(statusUpdates).toContainEqual({ type: \"checking\" });\r\n\r\n      // Manually trigger the timeout callback\r\n      expect(timeoutCallback).toBeTruthy();\r\n      timeoutCallback!();\r\n\r\n      // Should have timed out and returned to idle\r\n      const lastStatus = statusUpdates[statusUpdates.length - 1];\r\n      expect(lastStatus).toEqual({ type: \"idle\" });\r\n\r\n      // Restore original setTimeout\r\n      global.setTimeout = originalSetTimeout;\r\n    });\r\n  });\r\n\r\n  describe(\"getStatus\", () => {\r\n    it(\"should return initial status as idle\", () => {\r\n      const status = service.getStatus();\r\n      expect(status).toEqual({ type: \"idle\" });\r\n    });\r\n\r\n    it(\"should return current status after check starts\", () => {\r\n      mockAutoUpdater.checkForUpdates.mockReturnValue(Promise.resolve());\r\n\r\n      service.checkForUpdates();\r\n\r\n      const status = service.getStatus();\r\n      expect(status.type).toBe(\"checking\");\r\n    });\r\n  });\r\n});\r\n"]}