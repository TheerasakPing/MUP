import{createRequire}from'module';globalThis.require=createRequire(import.meta.url);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __knownSymbol = (name25, symbol25) => (symbol25 = Symbol[name25]) ? symbol25 : Symbol.for("Symbol." + name25);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name25 in all)
    __defProp(target, name25, { get: all[name25], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __using = (stack, value2, async) => {
  if (value2 != null) {
    if (typeof value2 !== "object" && typeof value2 !== "function") __typeError("Object expected");
    var dispose, inner;
    if (async) dispose = value2[__knownSymbol("asyncDispose")];
    if (dispose === void 0) {
      dispose = value2[__knownSymbol("dispose")];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") __typeError("Object not disposable");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    stack.push([async, dispose, value2]);
  } else if (async) {
    stack.push([async]);
  }
  return value2;
};
var __callDispose = (stack, error, hasError) => {
  var E = typeof SuppressedError === "function" ? SuppressedError : function(e, s, m, _) {
    return _ = Error(m), _.name = "SuppressedError", _.error = e, _.suppressed = s, _;
  };
  var fail = (e) => error = hasError ? new E(e, error, "An error was suppressed during disposal") : (hasError = true, e);
  var next = (it) => {
    while (it = stack.pop()) {
      try {
        var result = it[1] && it[1].call(it[2]);
        if (it[0]) return Promise.resolve(result).then(next, (e) => (fail(e), next()));
      } catch (e) {
        fail(e);
      }
    }
    if (hasError) throw error;
  };
  return next();
};

// node_modules/@orpc/shared/dist/index.mjs
function resolveMaybeOptionalOptions(rest) {
  return rest[0] ?? {};
}
function toArray(value2) {
  return Array.isArray(value2) ? value2 : value2 === void 0 || value2 === null ? [] : [value2];
}
function once(fn) {
  let cached;
  return () => {
    if (cached) {
      return cached.result;
    }
    const result = fn();
    cached = { result };
    return result;
  };
}
function sequential(fn) {
  let lastOperationPromise = Promise.resolve();
  return (...args2) => {
    return lastOperationPromise = lastOperationPromise.catch(() => {
    }).then(() => {
      return fn(...args2);
    });
  };
}
function getGlobalOtelConfig() {
  return globalThis[GLOBAL_OTEL_CONFIG_KEY];
}
function startSpan(name25, options = {}, context2) {
  const tracer = getGlobalOtelConfig()?.tracer;
  return tracer?.startSpan(name25, options, context2);
}
function setSpanError(span, error, options = {}) {
  if (!span) {
    return;
  }
  const exception = toOtelException(error);
  span.recordException(exception);
  if (!options.signal?.aborted || options.signal.reason !== error) {
    span.setStatus({
      code: SPAN_ERROR_STATUS,
      message: exception.message
    });
  }
}
function toOtelException(error) {
  if (error instanceof Error) {
    const exception = {
      message: error.message,
      name: error.name,
      stack: error.stack
    };
    if ("code" in error && (typeof error.code === "string" || typeof error.code === "number")) {
      exception.code = error.code;
    }
    return exception;
  }
  return { message: String(error) };
}
async function runWithSpan({ name: name25, context: context2, ...options }, fn) {
  const tracer = getGlobalOtelConfig()?.tracer;
  if (!tracer) {
    return fn();
  }
  const callback = async (span) => {
    try {
      return await fn(span);
    } catch (e) {
      setSpanError(span, e, options);
      throw e;
    } finally {
      span.end();
    }
  };
  if (context2) {
    return tracer.startActiveSpan(name25, options, context2, callback);
  } else {
    return tracer.startActiveSpan(name25, options, callback);
  }
}
async function runInSpanContext(span, fn) {
  const otelConfig = getGlobalOtelConfig();
  if (!span || !otelConfig) {
    return fn();
  }
  const ctx = otelConfig.trace.setSpan(otelConfig.context.active(), span);
  return otelConfig.context.with(ctx, fn);
}
function isAsyncIteratorObject(maybe) {
  if (!maybe || typeof maybe !== "object") {
    return false;
  }
  return "next" in maybe && typeof maybe.next === "function" && Symbol.asyncIterator in maybe && typeof maybe[Symbol.asyncIterator] === "function";
}
function asyncIteratorWithSpan({ name: name25, ...options }, iterator) {
  let span;
  return new AsyncIteratorClass(
    async () => {
      span ??= startSpan(name25);
      try {
        const result = await runInSpanContext(span, () => iterator.next());
        span?.addEvent(result.done ? "completed" : "yielded");
        return result;
      } catch (err) {
        setSpanError(span, err, options);
        throw err;
      }
    },
    async (reason) => {
      try {
        if (reason !== "next") {
          await runInSpanContext(span, () => iterator.return?.());
        }
      } catch (err) {
        setSpanError(span, err, options);
        throw err;
      } finally {
        span?.end();
      }
    }
  );
}
function onStart(callback) {
  return async (options, ...rest) => {
    await callback(options, ...rest);
    return await options.next();
  };
}
function onSuccess(callback) {
  return async (options, ...rest) => {
    const result = await options.next();
    await callback(result, options, ...rest);
    return result;
  };
}
function onError(callback) {
  return async (options, ...rest) => {
    try {
      return await options.next();
    } catch (error) {
      await callback(error, options, ...rest);
      throw error;
    }
  };
}
function onFinish(callback) {
  let state;
  return async (options, ...rest) => {
    try {
      const result = await options.next();
      state = [null, result, true];
      return result;
    } catch (error) {
      state = [error, void 0, false];
      throw error;
    } finally {
      await callback(state, options, ...rest);
    }
  };
}
function intercept(interceptors, options, main) {
  const next = (options2, index) => {
    const interceptor = interceptors[index];
    if (!interceptor) {
      return main(options2);
    }
    return interceptor({
      ...options2,
      next: (newOptions = options2) => next(newOptions, index + 1)
    });
  };
  return next(options, 0);
}
function parseEmptyableJSON(text2) {
  if (!text2) {
    return void 0;
  }
  return JSON.parse(text2);
}
function stringifyJSON(value2) {
  return JSON.stringify(value2);
}
function getConstructor(value2) {
  if (!isTypescriptObject(value2)) {
    return null;
  }
  return Object.getPrototypeOf(value2)?.constructor;
}
function isObject(value2) {
  if (!value2 || typeof value2 !== "object") {
    return false;
  }
  const proto2 = Object.getPrototypeOf(value2);
  return proto2 === Object.prototype || !proto2 || !proto2.constructor;
}
function isTypescriptObject(value2) {
  return !!value2 && (typeof value2 === "object" || typeof value2 === "function");
}
function value(value2, ...args2) {
  if (typeof value2 === "function") {
    return value2(...args2);
  }
  return value2;
}
function preventNativeAwait(target) {
  return new Proxy(target, {
    get(target2, prop, receiver) {
      const value2 = Reflect.get(target2, prop, receiver);
      if (prop !== "then" || typeof value2 !== "function") {
        return value2;
      }
      return new Proxy(value2, {
        apply(targetFn, thisArg, args2) {
          if (args2.length !== 2 || args2.some((arg) => !isNativeFunction(arg))) {
            return Reflect.apply(targetFn, thisArg, args2);
          }
          let shouldOmit = true;
          args2[0].call(thisArg, preventNativeAwait(new Proxy(target2, {
            get: (target3, prop2, receiver2) => {
              if (shouldOmit && prop2 === "then") {
                shouldOmit = false;
                return void 0;
              }
              return Reflect.get(target3, prop2, receiver2);
            }
          })));
        }
      });
    }
  });
}
function isNativeFunction(fn) {
  return typeof fn === "function" && NATIVE_FUNCTION_REGEX.test(fn.toString());
}
function overlayProxy(target, partial) {
  const proxy = new Proxy(typeof target === "function" ? partial : target, {
    get(_, prop) {
      const targetValue = prop in partial ? partial : value(target);
      const v = Reflect.get(targetValue, prop);
      return typeof v === "function" ? v.bind(targetValue) : v;
    },
    has(_, prop) {
      return Reflect.has(partial, prop) || Reflect.has(value(target), prop);
    }
  });
  return proxy;
}
function streamToAsyncIteratorClass(stream) {
  const reader = stream.getReader();
  return new AsyncIteratorClass(
    async () => {
      return reader.read();
    },
    async () => {
      await reader.cancel();
    }
  );
}
function asyncIteratorToStream(iterator) {
  return new ReadableStream({
    async pull(controller) {
      const { done, value: value2 } = await iterator.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value2);
      }
    },
    async cancel() {
      await iterator.return?.();
    }
  });
}
function asyncIteratorToUnproxiedDataStream(iterator) {
  return new ReadableStream({
    async pull(controller) {
      const { done, value: value2 } = await iterator.next();
      if (done) {
        controller.close();
      } else {
        const unproxied = isObject(value2) ? { ...value2 } : Array.isArray(value2) ? value2.map((i) => i) : value2;
        controller.enqueue(unproxied);
      }
    },
    async cancel() {
      await iterator.return?.();
    }
  });
}
function tryDecodeURIComponent(value2) {
  try {
    return decodeURIComponent(value2);
  } catch {
    return value2;
  }
}
var ORPC_NAME, ORPC_SHARED_PACKAGE_NAME, ORPC_SHARED_PACKAGE_VERSION, AbortError, SPAN_ERROR_STATUS, GLOBAL_OTEL_CONFIG_KEY, fallbackAsyncDisposeSymbol, asyncDisposeSymbol, AsyncIteratorClass, EventPublisher, NATIVE_FUNCTION_REGEX;
var init_dist = __esm({
  "node_modules/@orpc/shared/dist/index.mjs"() {
    ORPC_NAME = "orpc";
    ORPC_SHARED_PACKAGE_NAME = "@orpc/shared";
    ORPC_SHARED_PACKAGE_VERSION = "1.12.2";
    AbortError = class extends Error {
      constructor(...rest) {
        super(...rest);
        this.name = "AbortError";
      }
    };
    SPAN_ERROR_STATUS = 2;
    GLOBAL_OTEL_CONFIG_KEY = `__${ORPC_SHARED_PACKAGE_NAME}@${ORPC_SHARED_PACKAGE_VERSION}/otel/config__`;
    fallbackAsyncDisposeSymbol = Symbol.for("asyncDispose");
    asyncDisposeSymbol = Symbol.asyncDispose ?? fallbackAsyncDisposeSymbol;
    AsyncIteratorClass = class {
      #isDone = false;
      #isExecuteComplete = false;
      #cleanup;
      #next;
      constructor(next, cleanup) {
        this.#cleanup = cleanup;
        this.#next = sequential(async () => {
          if (this.#isDone) {
            return { done: true, value: void 0 };
          }
          try {
            const result = await next();
            if (result.done) {
              this.#isDone = true;
            }
            return result;
          } catch (err) {
            this.#isDone = true;
            throw err;
          } finally {
            if (this.#isDone && !this.#isExecuteComplete) {
              this.#isExecuteComplete = true;
              await this.#cleanup("next");
            }
          }
        });
      }
      next() {
        return this.#next();
      }
      async return(value2) {
        this.#isDone = true;
        if (!this.#isExecuteComplete) {
          this.#isExecuteComplete = true;
          await this.#cleanup("return");
        }
        return { done: true, value: value2 };
      }
      async throw(err) {
        this.#isDone = true;
        if (!this.#isExecuteComplete) {
          this.#isExecuteComplete = true;
          await this.#cleanup("throw");
        }
        throw err;
      }
      /**
       * asyncDispose symbol only available in esnext, we should fallback to Symbol.for('asyncDispose')
       */
      async [asyncDisposeSymbol]() {
        this.#isDone = true;
        if (!this.#isExecuteComplete) {
          this.#isExecuteComplete = true;
          await this.#cleanup("dispose");
        }
      }
      [Symbol.asyncIterator]() {
        return this;
      }
    };
    EventPublisher = class {
      #listenersMap = /* @__PURE__ */ new Map();
      #maxBufferedEvents;
      constructor(options = {}) {
        this.#maxBufferedEvents = options.maxBufferedEvents ?? 100;
      }
      get size() {
        return this.#listenersMap.size;
      }
      /**
       * Emits an event and delivers the payload to all subscribed listeners.
       */
      publish(event, payload) {
        const listeners = this.#listenersMap.get(event);
        if (!listeners) {
          return;
        }
        for (const listener of listeners) {
          listener(payload);
        }
      }
      subscribe(event, listenerOrOptions) {
        if (typeof listenerOrOptions === "function") {
          let listeners = this.#listenersMap.get(event);
          if (!listeners) {
            this.#listenersMap.set(event, listeners = []);
          }
          listeners.push(listenerOrOptions);
          return once(() => {
            listeners.splice(listeners.indexOf(listenerOrOptions), 1);
            if (listeners.length === 0) {
              this.#listenersMap.delete(event);
            }
          });
        }
        const signal = listenerOrOptions?.signal;
        const maxBufferedEvents = listenerOrOptions?.maxBufferedEvents ?? this.#maxBufferedEvents;
        signal?.throwIfAborted();
        const bufferedEvents = [];
        const pullResolvers = [];
        const unsubscribe = this.subscribe(event, (payload) => {
          const resolver = pullResolvers.shift();
          if (resolver) {
            resolver[0]({ done: false, value: payload });
          } else {
            bufferedEvents.push(payload);
            if (bufferedEvents.length > maxBufferedEvents) {
              bufferedEvents.shift();
            }
          }
        });
        const abortListener = (event2) => {
          unsubscribe();
          pullResolvers.forEach((resolver) => resolver[1](event2.target.reason));
          pullResolvers.length = 0;
          bufferedEvents.length = 0;
        };
        signal?.addEventListener("abort", abortListener, { once: true });
        return new AsyncIteratorClass(async () => {
          if (signal?.aborted) {
            throw signal.reason;
          }
          if (bufferedEvents.length > 0) {
            return { done: false, value: bufferedEvents.shift() };
          }
          return new Promise((resolve4, reject) => {
            pullResolvers.push([resolve4, reject]);
          });
        }, async () => {
          unsubscribe();
          signal?.removeEventListener("abort", abortListener);
          pullResolvers.forEach((resolver) => resolver[0]({ done: true, value: void 0 }));
          pullResolvers.length = 0;
          bufferedEvents.length = 0;
        });
      }
    };
    NATIVE_FUNCTION_REGEX = /^\s*function\s*\(\)\s*\{\s*\[native code\]\s*\}\s*$/;
  }
});

// node_modules/@orpc/client/dist/shared/client.J7pEE4Uw.mjs
function fallbackORPCErrorStatus(code, status) {
  return status ?? COMMON_ORPC_ERROR_DEFS[code]?.status ?? 500;
}
function fallbackORPCErrorMessage(code, message) {
  return message || COMMON_ORPC_ERROR_DEFS[code]?.message || code;
}
function isDefinedError(error) {
  return error instanceof ORPCError && error.defined;
}
function toORPCError(error) {
  return error instanceof ORPCError ? error : new ORPCError("INTERNAL_SERVER_ERROR", {
    message: "Internal server error",
    cause: error
  });
}
function isORPCErrorStatus(status) {
  return status < 200 || status >= 400;
}
function isORPCErrorJson(json2) {
  if (!isObject(json2)) {
    return false;
  }
  const validKeys = ["defined", "code", "status", "message", "data"];
  if (Object.keys(json2).some((k) => !validKeys.includes(k))) {
    return false;
  }
  return "defined" in json2 && typeof json2.defined === "boolean" && "code" in json2 && typeof json2.code === "string" && "status" in json2 && typeof json2.status === "number" && isORPCErrorStatus(json2.status) && "message" in json2 && typeof json2.message === "string";
}
function createORPCErrorFromJson(json2, options = {}) {
  return new ORPCError(json2.code, {
    ...options,
    ...json2
  });
}
var ORPC_CLIENT_PACKAGE_NAME, ORPC_CLIENT_PACKAGE_VERSION, COMMON_ORPC_ERROR_DEFS, GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL, globalORPCErrorConstructors, ORPCError;
var init_client_J7pEE4Uw = __esm({
  "node_modules/@orpc/client/dist/shared/client.J7pEE4Uw.mjs"() {
    init_dist();
    ORPC_CLIENT_PACKAGE_NAME = "@orpc/client";
    ORPC_CLIENT_PACKAGE_VERSION = "1.12.2";
    COMMON_ORPC_ERROR_DEFS = {
      BAD_REQUEST: {
        status: 400,
        message: "Bad Request"
      },
      UNAUTHORIZED: {
        status: 401,
        message: "Unauthorized"
      },
      FORBIDDEN: {
        status: 403,
        message: "Forbidden"
      },
      NOT_FOUND: {
        status: 404,
        message: "Not Found"
      },
      METHOD_NOT_SUPPORTED: {
        status: 405,
        message: "Method Not Supported"
      },
      NOT_ACCEPTABLE: {
        status: 406,
        message: "Not Acceptable"
      },
      TIMEOUT: {
        status: 408,
        message: "Request Timeout"
      },
      CONFLICT: {
        status: 409,
        message: "Conflict"
      },
      PRECONDITION_FAILED: {
        status: 412,
        message: "Precondition Failed"
      },
      PAYLOAD_TOO_LARGE: {
        status: 413,
        message: "Payload Too Large"
      },
      UNSUPPORTED_MEDIA_TYPE: {
        status: 415,
        message: "Unsupported Media Type"
      },
      UNPROCESSABLE_CONTENT: {
        status: 422,
        message: "Unprocessable Content"
      },
      TOO_MANY_REQUESTS: {
        status: 429,
        message: "Too Many Requests"
      },
      CLIENT_CLOSED_REQUEST: {
        status: 499,
        message: "Client Closed Request"
      },
      INTERNAL_SERVER_ERROR: {
        status: 500,
        message: "Internal Server Error"
      },
      NOT_IMPLEMENTED: {
        status: 501,
        message: "Not Implemented"
      },
      BAD_GATEWAY: {
        status: 502,
        message: "Bad Gateway"
      },
      SERVICE_UNAVAILABLE: {
        status: 503,
        message: "Service Unavailable"
      },
      GATEWAY_TIMEOUT: {
        status: 504,
        message: "Gateway Timeout"
      }
    };
    GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL = Symbol.for(`__${ORPC_CLIENT_PACKAGE_NAME}@${ORPC_CLIENT_PACKAGE_VERSION}/error/ORPC_ERROR_CONSTRUCTORS__`);
    void (globalThis[GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL] ??= /* @__PURE__ */ new WeakSet());
    globalORPCErrorConstructors = globalThis[GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL];
    ORPCError = class extends Error {
      defined;
      code;
      status;
      data;
      constructor(code, ...rest) {
        const options = resolveMaybeOptionalOptions(rest);
        if (options.status !== void 0 && !isORPCErrorStatus(options.status)) {
          throw new Error("[ORPCError] Invalid error status code.");
        }
        const message = fallbackORPCErrorMessage(code, options.message);
        super(message, options);
        this.code = code;
        this.status = fallbackORPCErrorStatus(code, options.status);
        this.defined = options.defined ?? false;
        this.data = options.data;
      }
      toJSON() {
        return {
          defined: this.defined,
          code: this.code,
          status: this.status,
          message: this.message,
          data: this.data
        };
      }
      /**
       * Workaround for Next.js where different contexts use separate
       * dependency graphs, causing multiple ORPCError constructors existing and breaking
       * `instanceof` checks across contexts.
       *
       * This is particularly problematic with "Optimized SSR", where orpc-client
       * executes in one context but is invoked from another. When an error is thrown
       * in the execution context, `instanceof ORPCError` checks fail in the
       * invocation context due to separate class constructors.
       *
       * @todo Remove this and related code if Next.js resolves the multiple dependency graph issue.
       */
      static [Symbol.hasInstance](instance) {
        if (globalORPCErrorConstructors.has(this)) {
          const constructor = getConstructor(instance);
          if (constructor && globalORPCErrorConstructors.has(constructor)) {
            return true;
          }
        }
        return super[Symbol.hasInstance](instance);
      }
    };
    globalORPCErrorConstructors.add(ORPCError);
  }
});

// node_modules/@orpc/standard-server/dist/index.mjs
function decodeEventMessage(encoded) {
  const lines = encoded.replace(/\n+$/, "").split(/\n/);
  const message = {
    data: void 0,
    event: void 0,
    id: void 0,
    retry: void 0,
    comments: []
  };
  for (const line of lines) {
    const index = line.indexOf(":");
    const key = index === -1 ? line : line.slice(0, index);
    const value2 = index === -1 ? "" : line.slice(index + 1).replace(/^\s/, "");
    if (index === 0) {
      message.comments.push(value2);
    } else if (key === "data") {
      message.data ??= "";
      message.data += `${value2}
`;
    } else if (key === "event") {
      message.event = value2;
    } else if (key === "id") {
      message.id = value2;
    } else if (key === "retry") {
      const maybeInteger = Number.parseInt(value2);
      if (Number.isInteger(maybeInteger) && maybeInteger >= 0 && maybeInteger.toString() === value2) {
        message.retry = maybeInteger;
      }
    }
  }
  message.data = message.data?.replace(/\n$/, "");
  return message;
}
function assertEventId(id) {
  if (id.includes("\n")) {
    throw new EventEncoderError("Event's id must not contain a newline character");
  }
}
function assertEventName(event) {
  if (event.includes("\n")) {
    throw new EventEncoderError("Event's event must not contain a newline character");
  }
}
function assertEventRetry(retry) {
  if (!Number.isInteger(retry) || retry < 0) {
    throw new EventEncoderError("Event's retry must be a integer and >= 0");
  }
}
function assertEventComment(comment) {
  if (comment.includes("\n")) {
    throw new EventEncoderError("Event's comment must not contain a newline character");
  }
}
function encodeEventData(data) {
  const lines = data?.split(/\n/) ?? [];
  let output = "";
  for (const line of lines) {
    output += `data: ${line}
`;
  }
  return output;
}
function encodeEventComments(comments) {
  let output = "";
  for (const comment of comments ?? []) {
    assertEventComment(comment);
    output += `: ${comment}
`;
  }
  return output;
}
function encodeEventMessage(message) {
  let output = "";
  output += encodeEventComments(message.comments);
  if (message.event !== void 0) {
    assertEventName(message.event);
    output += `event: ${message.event}
`;
  }
  if (message.retry !== void 0) {
    assertEventRetry(message.retry);
    output += `retry: ${message.retry}
`;
  }
  if (message.id !== void 0) {
    assertEventId(message.id);
    output += `id: ${message.id}
`;
  }
  output += encodeEventData(message.data);
  output += "\n";
  return output;
}
function withEventMeta(container, meta) {
  if (meta.id === void 0 && meta.retry === void 0 && !meta.comments?.length) {
    return container;
  }
  if (meta.id !== void 0) {
    assertEventId(meta.id);
  }
  if (meta.retry !== void 0) {
    assertEventRetry(meta.retry);
  }
  if (meta.comments !== void 0) {
    for (const comment of meta.comments) {
      assertEventComment(comment);
    }
  }
  return new Proxy(container, {
    get(target, prop, receiver) {
      if (prop === EVENT_SOURCE_META_SYMBOL) {
        return meta;
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function getEventMeta(container) {
  return isTypescriptObject(container) ? Reflect.get(container, EVENT_SOURCE_META_SYMBOL) : void 0;
}
function generateContentDisposition(filename) {
  const escapedFileName = filename.replace(/"/g, '\\"');
  const encodedFilenameStar = encodeURIComponent(filename).replace(/['()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`).replace(/%(7C|60|5E)/g, (str, hex) => String.fromCharCode(Number.parseInt(hex, 16)));
  return `inline; filename="${escapedFileName}"; filename*=utf-8''${encodedFilenameStar}`;
}
function getFilenameFromContentDisposition(contentDisposition) {
  const encodedFilenameStarMatch = contentDisposition.match(/filename\*=(UTF-8'')?([^;]*)/i);
  if (encodedFilenameStarMatch && typeof encodedFilenameStarMatch[2] === "string") {
    return tryDecodeURIComponent(encodedFilenameStarMatch[2]);
  }
  const encodedFilenameMatch = contentDisposition.match(/filename="((?:\\"|[^"])*)"/i);
  if (encodedFilenameMatch && typeof encodedFilenameMatch[1] === "string") {
    return encodedFilenameMatch[1].replace(/\\"/g, '"');
  }
}
function mergeStandardHeaders(a, b) {
  const merged = { ...a };
  for (const key in b) {
    if (Array.isArray(b[key])) {
      merged[key] = [...toArray(merged[key]), ...b[key]];
    } else if (b[key] !== void 0) {
      if (Array.isArray(merged[key])) {
        merged[key] = [...merged[key], b[key]];
      } else if (merged[key] !== void 0) {
        merged[key] = [merged[key], b[key]];
      } else {
        merged[key] = b[key];
      }
    }
  }
  return merged;
}
var EventEncoderError, EventDecoderError, ErrorEvent, EventDecoder, EventDecoderStream, EVENT_SOURCE_META_SYMBOL, HibernationEventIterator;
var init_dist2 = __esm({
  "node_modules/@orpc/standard-server/dist/index.mjs"() {
    init_dist();
    EventEncoderError = class extends TypeError {
    };
    EventDecoderError = class extends TypeError {
    };
    ErrorEvent = class extends Error {
      data;
      constructor(options) {
        super(options?.message ?? "An error event was received", options);
        this.data = options?.data;
      }
    };
    EventDecoder = class {
      constructor(options = {}) {
        this.options = options;
      }
      incomplete = "";
      feed(chunk) {
        this.incomplete += chunk;
        const lastCompleteIndex = this.incomplete.lastIndexOf("\n\n");
        if (lastCompleteIndex === -1) {
          return;
        }
        const completes = this.incomplete.slice(0, lastCompleteIndex).split(/\n\n/);
        this.incomplete = this.incomplete.slice(lastCompleteIndex + 2);
        for (const encoded of completes) {
          const message = decodeEventMessage(`${encoded}

`);
          if (this.options.onEvent) {
            this.options.onEvent(message);
          }
        }
        this.incomplete = "";
      }
      end() {
        if (this.incomplete) {
          throw new EventDecoderError("Event Iterator ended before complete");
        }
      }
    };
    EventDecoderStream = class extends TransformStream {
      constructor() {
        let decoder;
        super({
          start(controller) {
            decoder = new EventDecoder({
              onEvent: (event) => {
                controller.enqueue(event);
              }
            });
          },
          transform(chunk) {
            decoder.feed(chunk);
          },
          flush() {
            decoder.end();
          }
        });
      }
    };
    EVENT_SOURCE_META_SYMBOL = Symbol("ORPC_EVENT_SOURCE_META");
    HibernationEventIterator = class extends AsyncIteratorClass {
      /**
       * this property is not transferred to the client, so it should be optional for type safety
       */
      hibernationCallback;
      constructor(hibernationCallback) {
        super(async () => {
          throw new Error("Cannot iterate over hibernating iterator directly");
        }, async (reason) => {
          if (reason !== "next") {
            throw new Error("Cannot cleanup hibernating iterator directly");
          }
        });
        this.hibernationCallback = hibernationCallback;
      }
    };
  }
});

// node_modules/@orpc/client/dist/shared/client.BLtwTQUg.mjs
function mapEventIterator(iterator, maps) {
  const mapError = async (error) => {
    let mappedError = await maps.error(error);
    if (mappedError !== error) {
      const meta = getEventMeta(error);
      if (meta && isTypescriptObject(mappedError)) {
        mappedError = withEventMeta(mappedError, meta);
      }
    }
    return mappedError;
  };
  return new AsyncIteratorClass(async () => {
    const { done, value: value2 } = await (async () => {
      try {
        return await iterator.next();
      } catch (error) {
        throw await mapError(error);
      }
    })();
    let mappedValue = await maps.value(value2, done);
    if (mappedValue !== value2) {
      const meta = getEventMeta(value2);
      if (meta && isTypescriptObject(mappedValue)) {
        mappedValue = withEventMeta(mappedValue, meta);
      }
    }
    return { done, value: mappedValue };
  }, async () => {
    try {
      await iterator.return?.();
    } catch (error) {
      throw await mapError(error);
    }
  });
}
var init_client_BLtwTQUg = __esm({
  "node_modules/@orpc/client/dist/shared/client.BLtwTQUg.mjs"() {
    init_dist();
    init_dist2();
  }
});

// node_modules/@orpc/client/dist/index.mjs
async function safe(promise) {
  try {
    const output = await promise;
    return Object.assign(
      [null, output, false, true],
      { error: null, data: output, isDefined: false, isSuccess: true }
    );
  } catch (e) {
    const error = e;
    if (isDefinedError(error)) {
      return Object.assign(
        [error, void 0, true, false],
        { error, data: void 0, isDefined: true, isSuccess: false }
      );
    }
    return Object.assign(
      [error, void 0, false, false],
      { error, data: void 0, isDefined: false, isSuccess: false }
    );
  }
}
function resolveFriendlyClientOptions(options) {
  return {
    ...options,
    context: options.context ?? {}
    // Context only optional if all fields are optional
  };
}
function createORPCClient(link, options = {}) {
  const path24 = options.path ?? [];
  const procedureClient = async (...[input, options2 = {}]) => {
    return await link.call(path24, input, resolveFriendlyClientOptions(options2));
  };
  const recursive = new Proxy(procedureClient, {
    get(target, key) {
      if (typeof key !== "string") {
        return Reflect.get(target, key);
      }
      return createORPCClient(link, {
        ...options,
        path: [...path24, key]
      });
    }
  });
  return preventNativeAwait(recursive);
}
var init_dist3 = __esm({
  "node_modules/@orpc/client/dist/index.mjs"() {
    init_dist();
    init_dist();
    init_client_J7pEE4Uw();
    init_client_J7pEE4Uw();
    init_client_BLtwTQUg();
    init_dist2();
  }
});

// node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs
function mergeErrorMap(errorMap1, errorMap2) {
  return { ...errorMap1, ...errorMap2 };
}
async function validateORPCError(map, error) {
  const { code, status, message, data, cause, defined } = error;
  const config2 = map?.[error.code];
  if (!config2 || fallbackORPCErrorStatus(error.code, config2.status) !== error.status) {
    return defined ? new ORPCError(code, { defined: false, status, message, data, cause }) : error;
  }
  if (!config2.data) {
    return defined ? error : new ORPCError(code, { defined: true, status, message, data, cause });
  }
  const validated = await config2.data["~standard"].validate(error.data);
  if (validated.issues) {
    return defined ? new ORPCError(code, { defined: false, status, message, data, cause }) : error;
  }
  return new ORPCError(code, { defined: true, status, message, data: validated.value, cause });
}
function isContractProcedure(item) {
  if (item instanceof ContractProcedure) {
    return true;
  }
  return (typeof item === "object" || typeof item === "function") && item !== null && "~orpc" in item && typeof item["~orpc"] === "object" && item["~orpc"] !== null && "errorMap" in item["~orpc"] && "route" in item["~orpc"] && "meta" in item["~orpc"];
}
var ValidationError, ContractProcedure;
var init_contract_D_dZrO = __esm({
  "node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs"() {
    init_dist3();
    ValidationError = class extends Error {
      issues;
      data;
      constructor(options) {
        super(options.message, options);
        this.issues = options.issues;
        this.data = options.data;
      }
    };
    ContractProcedure = class {
      /**
       * This property holds the defined options for the contract procedure.
       */
      "~orpc";
      constructor(def) {
        if (def.route?.successStatus && isORPCErrorStatus(def.route.successStatus)) {
          throw new Error("[ContractProcedure] Invalid successStatus.");
        }
        if (Object.values(def.errorMap).some((val) => val && val.status && !isORPCErrorStatus(val.status))) {
          throw new Error("[ContractProcedure] Invalid error status code.");
        }
        this["~orpc"] = def;
      }
    };
  }
});

// node_modules/@orpc/contract/dist/index.mjs
function mergeMeta(meta1, meta2) {
  return { ...meta1, ...meta2 };
}
function mergeRoute(a, b) {
  return { ...a, ...b };
}
function prefixRoute(route, prefix) {
  if (!route.path) {
    return route;
  }
  return {
    ...route,
    path: `${prefix}${route.path}`
  };
}
function unshiftTagRoute(route, tags) {
  return {
    ...route,
    tags: [...tags, ...route.tags ?? []]
  };
}
function mergePrefix(a, b) {
  return a ? `${a}${b}` : b;
}
function mergeTags(a, b) {
  return a ? [...a, ...b] : b;
}
function enhanceRoute(route, options) {
  let router2 = route;
  if (options.prefix) {
    router2 = prefixRoute(router2, options.prefix);
  }
  if (options.tags?.length) {
    router2 = unshiftTagRoute(router2, options.tags);
  }
  return router2;
}
function getContractRouter(router2, path24) {
  let current = router2;
  for (let i = 0; i < path24.length; i++) {
    const segment = path24[i];
    if (!current) {
      return void 0;
    }
    if (isContractProcedure(current)) {
      return void 0;
    }
    current = current[segment];
  }
  return current;
}
function enhanceContractRouter(router2, options) {
  if (isContractProcedure(router2)) {
    const enhanced2 = new ContractProcedure({
      ...router2["~orpc"],
      errorMap: mergeErrorMap(options.errorMap, router2["~orpc"].errorMap),
      route: enhanceRoute(router2["~orpc"].route, options)
    });
    return enhanced2;
  }
  const enhanced = {};
  for (const key in router2) {
    enhanced[key] = enhanceContractRouter(router2[key], options);
  }
  return enhanced;
}
function fallbackContractConfig(key, value2) {
  if (value2 === void 0) {
    return DEFAULT_CONFIG[key];
  }
  return value2;
}
function eventIterator(yields, returns) {
  return {
    "~standard": {
      [EVENT_ITERATOR_DETAILS_SYMBOL]: { yields, returns },
      vendor: "orpc",
      version: 1,
      validate(iterator) {
        if (!isAsyncIteratorObject(iterator)) {
          return { issues: [{ message: "Expect event iterator", path: [] }] };
        }
        const mapped = mapEventIterator(iterator, {
          async value(value2, done) {
            const schema = done ? returns : yields;
            if (!schema) {
              return value2;
            }
            const result = await schema["~standard"].validate(value2);
            if (result.issues) {
              throw new ORPCError("EVENT_ITERATOR_VALIDATION_FAILED", {
                message: "Event iterator validation failed",
                cause: new ValidationError({
                  issues: result.issues,
                  message: "Event iterator validation failed",
                  data: value2
                })
              });
            }
            return result.value;
          },
          error: async (error) => error
        });
        return { value: mapped };
      }
    }
  };
}
function type(...[map]) {
  return {
    "~standard": {
      vendor: "custom",
      version: 1,
      async validate(value2) {
        if (map) {
          return { value: await map(value2) };
        }
        return { value: value2 };
      }
    }
  };
}
var ContractBuilder, oc, DEFAULT_CONFIG, EVENT_ITERATOR_DETAILS_SYMBOL;
var init_dist4 = __esm({
  "node_modules/@orpc/contract/dist/index.mjs"() {
    init_contract_D_dZrO();
    init_contract_D_dZrO();
    init_dist3();
    init_dist3();
    init_dist();
    init_dist();
    ContractBuilder = class _ContractBuilder extends ContractProcedure {
      constructor(def) {
        super(def);
        this["~orpc"].prefix = def.prefix;
        this["~orpc"].tags = def.tags;
      }
      /**
       * Sets or overrides the initial meta.
       *
       * @see {@link https://orpc.dev/docs/metadata Metadata Docs}
       */
      $meta(initialMeta) {
        return new _ContractBuilder({
          ...this["~orpc"],
          meta: initialMeta
        });
      }
      /**
       * Sets or overrides the initial route.
       * This option is typically relevant when integrating with OpenAPI.
       *
       * @see {@link https://orpc.dev/docs/openapi/routing OpenAPI Routing Docs}
       * @see {@link https://orpc.dev/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
       */
      $route(initialRoute) {
        return new _ContractBuilder({
          ...this["~orpc"],
          route: initialRoute
        });
      }
      /**
       * Adds type-safe custom errors to the contract.
       * The provided errors are spared-merged with any existing errors in the contract.
       *
       * @see {@link https://orpc.dev/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
       */
      errors(errors) {
        return new _ContractBuilder({
          ...this["~orpc"],
          errorMap: mergeErrorMap(this["~orpc"].errorMap, errors)
        });
      }
      /**
       * Sets or updates the metadata for the contract.
       * The provided metadata is spared-merged with any existing metadata in the contract.
       *
       * @see {@link https://orpc.dev/docs/metadata Metadata Docs}
       */
      meta(meta) {
        return new _ContractBuilder({
          ...this["~orpc"],
          meta: mergeMeta(this["~orpc"].meta, meta)
        });
      }
      /**
       * Sets or updates the route definition for the contract.
       * The provided route is spared-merged with any existing route in the contract.
       * This option is typically relevant when integrating with OpenAPI.
       *
       * @see {@link https://orpc.dev/docs/openapi/routing OpenAPI Routing Docs}
       * @see {@link https://orpc.dev/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
       */
      route(route) {
        return new _ContractBuilder({
          ...this["~orpc"],
          route: mergeRoute(this["~orpc"].route, route)
        });
      }
      /**
       * Defines the input validation schema for the contract.
       *
       * @see {@link https://orpc.dev/docs/procedure#input-output-validation Input Validation Docs}
       */
      input(schema) {
        return new _ContractBuilder({
          ...this["~orpc"],
          inputSchema: schema
        });
      }
      /**
       * Defines the output validation schema for the contract.
       *
       * @see {@link https://orpc.dev/docs/procedure#input-output-validation Output Validation Docs}
       */
      output(schema) {
        return new _ContractBuilder({
          ...this["~orpc"],
          outputSchema: schema
        });
      }
      /**
       * Prefixes all procedures in the contract router.
       * The provided prefix is post-appended to any existing router prefix.
       *
       * @note This option does not affect procedures that do not define a path in their route definition.
       *
       * @see {@link https://orpc.dev/docs/openapi/routing#route-prefixes OpenAPI Route Prefixes Docs}
       */
      prefix(prefix) {
        return new _ContractBuilder({
          ...this["~orpc"],
          prefix: mergePrefix(this["~orpc"].prefix, prefix)
        });
      }
      /**
       * Adds tags to all procedures in the contract router.
       * This helpful when you want to group procedures together in the OpenAPI specification.
       *
       * @see {@link https://orpc.dev/docs/openapi/openapi-specification#operation-metadata OpenAPI Operation Metadata Docs}
       */
      tag(...tags) {
        return new _ContractBuilder({
          ...this["~orpc"],
          tags: mergeTags(this["~orpc"].tags, tags)
        });
      }
      /**
       * Applies all of the previously defined options to the specified contract router.
       *
       * @see {@link https://orpc.dev/docs/router#extending-router Extending Router Docs}
       */
      router(router2) {
        return enhanceContractRouter(router2, this["~orpc"]);
      }
    };
    oc = new ContractBuilder({
      errorMap: {},
      route: {},
      meta: {}
    });
    DEFAULT_CONFIG = {
      defaultMethod: "POST",
      defaultSuccessStatus: 200,
      defaultSuccessDescription: "OK",
      defaultInputStructure: "compact",
      defaultOutputStructure: "compact"
    };
    EVENT_ITERATOR_DETAILS_SYMBOL = Symbol("ORPC_EVENT_ITERATOR_DETAILS");
  }
});

// node_modules/@orpc/server/dist/shared/server.Ds4HPpvH.mjs
function lazy(loader, meta = {}) {
  return {
    [LAZY_SYMBOL]: {
      loader,
      meta
    }
  };
}
function isLazy(item) {
  return (typeof item === "object" || typeof item === "function") && item !== null && LAZY_SYMBOL in item;
}
function getLazyMeta(lazied) {
  return lazied[LAZY_SYMBOL].meta;
}
function unlazy(lazied) {
  return isLazy(lazied) ? lazied[LAZY_SYMBOL].loader() : Promise.resolve({ default: lazied });
}
function isStartWithMiddlewares(middlewares, compare) {
  if (compare.length > middlewares.length) {
    return false;
  }
  for (let i = 0; i < middlewares.length; i++) {
    if (compare[i] === void 0) {
      return true;
    }
    if (middlewares[i] !== compare[i]) {
      return false;
    }
  }
  return true;
}
function mergeMiddlewares(first, second, options) {
  if (options.dedupeLeading && isStartWithMiddlewares(second, first)) {
    return second;
  }
  return [...first, ...second];
}
function addMiddleware(middlewares, addition) {
  return [...middlewares, addition];
}
function isProcedure(item) {
  if (item instanceof Procedure) {
    return true;
  }
  return isContractProcedure(item) && "middlewares" in item["~orpc"] && "inputValidationIndex" in item["~orpc"] && "outputValidationIndex" in item["~orpc"] && "handler" in item["~orpc"];
}
function mergeCurrentContext(context2, other) {
  return { ...context2, ...other };
}
function createORPCErrorConstructorMap(errors) {
  const proxy = new Proxy(errors, {
    get(target, code) {
      if (typeof code !== "string") {
        return Reflect.get(target, code);
      }
      const item = (...rest) => {
        const options = resolveMaybeOptionalOptions(rest);
        const config2 = errors[code];
        return new ORPCError(code, {
          defined: Boolean(config2),
          status: config2?.status,
          message: options.message ?? config2?.message,
          data: options.data,
          cause: options.cause
        });
      };
      return item;
    }
  });
  return proxy;
}
function middlewareOutputFn(output) {
  return { output, context: {} };
}
function createProcedureClient(lazyableProcedure, ...rest) {
  const options = resolveMaybeOptionalOptions(rest);
  return async (...[input, callerOptions]) => {
    const path24 = toArray(options.path);
    const { default: procedure } = await unlazy(lazyableProcedure);
    const clientContext = callerOptions?.context ?? {};
    const context2 = await value(options.context ?? {}, clientContext);
    const errors = createORPCErrorConstructorMap(procedure["~orpc"].errorMap);
    const validateError = async (e) => {
      if (e instanceof ORPCError) {
        return await validateORPCError(procedure["~orpc"].errorMap, e);
      }
      return e;
    };
    try {
      const output = await runWithSpan(
        { name: "call_procedure", signal: callerOptions?.signal },
        (span) => {
          span?.setAttribute("procedure.path", [...path24]);
          return intercept(
            toArray(options.interceptors),
            {
              context: context2,
              input,
              // input only optional when it undefinable so we can safely cast it
              errors,
              path: path24,
              procedure,
              signal: callerOptions?.signal,
              lastEventId: callerOptions?.lastEventId
            },
            (interceptorOptions) => executeProcedureInternal(interceptorOptions.procedure, interceptorOptions)
          );
        }
      );
      if (isAsyncIteratorObject(output)) {
        if (output instanceof HibernationEventIterator) {
          return output;
        }
        return overlayProxy(output, mapEventIterator(
          asyncIteratorWithSpan(
            { name: "consume_event_iterator_output", signal: callerOptions?.signal },
            output
          ),
          {
            value: (v) => v,
            error: (e) => validateError(e)
          }
        ));
      }
      return output;
    } catch (e) {
      throw await validateError(e);
    }
  };
}
async function validateInput(procedure, input) {
  const schema = procedure["~orpc"].inputSchema;
  if (!schema) {
    return input;
  }
  return runWithSpan(
    { name: "validate_input" },
    async () => {
      const result = await schema["~standard"].validate(input);
      if (result.issues) {
        throw new ORPCError("BAD_REQUEST", {
          message: "Input validation failed",
          data: {
            issues: result.issues
          },
          cause: new ValidationError({
            message: "Input validation failed",
            issues: result.issues,
            data: input
          })
        });
      }
      return result.value;
    }
  );
}
async function validateOutput(procedure, output) {
  const schema = procedure["~orpc"].outputSchema;
  if (!schema) {
    return output;
  }
  return runWithSpan(
    { name: "validate_output" },
    async () => {
      const result = await schema["~standard"].validate(output);
      if (result.issues) {
        throw new ORPCError("INTERNAL_SERVER_ERROR", {
          message: "Output validation failed",
          cause: new ValidationError({
            message: "Output validation failed",
            issues: result.issues,
            data: output
          })
        });
      }
      return result.value;
    }
  );
}
async function executeProcedureInternal(procedure, options) {
  const middlewares = procedure["~orpc"].middlewares;
  const inputValidationIndex = Math.min(Math.max(0, procedure["~orpc"].inputValidationIndex), middlewares.length);
  const outputValidationIndex = Math.min(Math.max(0, procedure["~orpc"].outputValidationIndex), middlewares.length);
  const next = async (index, context2, input) => {
    let currentInput = input;
    if (index === inputValidationIndex) {
      currentInput = await validateInput(procedure, currentInput);
    }
    const mid = middlewares[index];
    const output = mid ? await runWithSpan(
      { name: `middleware.${mid.name}`, signal: options.signal },
      async (span) => {
        span?.setAttribute("middleware.index", index);
        span?.setAttribute("middleware.name", mid.name);
        const result = await mid({
          ...options,
          context: context2,
          next: async (...[nextOptions]) => {
            const nextContext = nextOptions?.context ?? {};
            return {
              output: await next(index + 1, mergeCurrentContext(context2, nextContext), currentInput),
              context: nextContext
            };
          }
        }, currentInput, middlewareOutputFn);
        return result.output;
      }
    ) : await runWithSpan(
      { name: "handler", signal: options.signal },
      () => procedure["~orpc"].handler({ ...options, context: context2, input: currentInput })
    );
    if (index === outputValidationIndex) {
      return await validateOutput(procedure, output);
    }
    return output;
  };
  return next(0, options.context, options.input);
}
function setHiddenRouterContract(router2, contract) {
  return new Proxy(router2, {
    get(target, key) {
      if (key === HIDDEN_ROUTER_CONTRACT_SYMBOL) {
        return contract;
      }
      return Reflect.get(target, key);
    }
  });
}
function getHiddenRouterContract(router2) {
  return router2[HIDDEN_ROUTER_CONTRACT_SYMBOL];
}
function getRouter(router2, path24) {
  let current = router2;
  for (let i = 0; i < path24.length; i++) {
    const segment = path24[i];
    if (!current) {
      return void 0;
    }
    if (isProcedure(current)) {
      return void 0;
    }
    if (!isLazy(current)) {
      current = current[segment];
      continue;
    }
    const lazied = current;
    const rest = path24.slice(i);
    return lazy(async () => {
      const unwrapped = await unlazy(lazied);
      const next = getRouter(unwrapped.default, rest);
      return unlazy(next);
    }, getLazyMeta(lazied));
  }
  return current;
}
function createAccessibleLazyRouter(lazied) {
  const recursive = new Proxy(lazied, {
    get(target, key) {
      if (typeof key !== "string") {
        return Reflect.get(target, key);
      }
      const next = getRouter(lazied, [key]);
      return createAccessibleLazyRouter(next);
    }
  });
  return recursive;
}
function enhanceRouter(router2, options) {
  if (isLazy(router2)) {
    const laziedMeta = getLazyMeta(router2);
    const enhancedPrefix = laziedMeta?.prefix ? mergePrefix(options.prefix, laziedMeta?.prefix) : options.prefix;
    const enhanced2 = lazy(async () => {
      const { default: unlaziedRouter } = await unlazy(router2);
      const enhanced3 = enhanceRouter(unlaziedRouter, options);
      return unlazy(enhanced3);
    }, {
      ...laziedMeta,
      prefix: enhancedPrefix
    });
    const accessible = createAccessibleLazyRouter(enhanced2);
    return accessible;
  }
  if (isProcedure(router2)) {
    const newMiddlewares = mergeMiddlewares(options.middlewares, router2["~orpc"].middlewares, { dedupeLeading: options.dedupeLeadingMiddlewares });
    const newMiddlewareAdded = newMiddlewares.length - router2["~orpc"].middlewares.length;
    const enhanced2 = new Procedure({
      ...router2["~orpc"],
      route: enhanceRoute(router2["~orpc"].route, options),
      errorMap: mergeErrorMap(options.errorMap, router2["~orpc"].errorMap),
      middlewares: newMiddlewares,
      inputValidationIndex: router2["~orpc"].inputValidationIndex + newMiddlewareAdded,
      outputValidationIndex: router2["~orpc"].outputValidationIndex + newMiddlewareAdded
    });
    return enhanced2;
  }
  const enhanced = {};
  for (const key in router2) {
    enhanced[key] = enhanceRouter(router2[key], options);
  }
  return enhanced;
}
function traverseContractProcedures(options, callback, lazyOptions = []) {
  let currentRouter = options.router;
  const hiddenContract = getHiddenRouterContract(options.router);
  if (hiddenContract !== void 0) {
    currentRouter = hiddenContract;
  }
  if (isLazy(currentRouter)) {
    lazyOptions.push({
      router: currentRouter,
      path: options.path
    });
  } else if (isContractProcedure(currentRouter)) {
    callback({
      contract: currentRouter,
      path: options.path
    });
  } else {
    for (const key in currentRouter) {
      traverseContractProcedures(
        {
          router: currentRouter[key],
          path: [...options.path, key]
        },
        callback,
        lazyOptions
      );
    }
  }
  return lazyOptions;
}
async function resolveContractProcedures(options, callback) {
  const pending = [options];
  for (const options2 of pending) {
    const lazyOptions = traverseContractProcedures(options2, callback);
    for (const options3 of lazyOptions) {
      const { default: router2 } = await unlazy(options3.router);
      pending.push({
        router: router2,
        path: options3.path
      });
    }
  }
}
async function unlazyRouter(router2) {
  if (isProcedure(router2)) {
    return router2;
  }
  const unlazied = {};
  for (const key in router2) {
    const item = router2[key];
    const { default: unlaziedRouter } = await unlazy(item);
    unlazied[key] = await unlazyRouter(unlaziedRouter);
  }
  return unlazied;
}
function createAssertedLazyProcedure(lazied) {
  const lazyProcedure = lazy(async () => {
    const { default: maybeProcedure } = await unlazy(lazied);
    if (!isProcedure(maybeProcedure)) {
      throw new Error(`
            Expected a lazy<procedure> but got lazy<unknown>.
            This should be caught by TypeScript compilation.
            Please report this issue if this makes you feel uncomfortable.
        `);
    }
    return { default: maybeProcedure };
  }, getLazyMeta(lazied));
  return lazyProcedure;
}
function createContractedProcedure(procedure, contract) {
  return new Procedure({
    ...procedure["~orpc"],
    errorMap: contract["~orpc"].errorMap,
    route: contract["~orpc"].route,
    meta: contract["~orpc"].meta
  });
}
function call(procedure, input, ...rest) {
  const options = resolveMaybeOptionalOptions(rest);
  return createProcedureClient(procedure, options)(input, options);
}
var LAZY_SYMBOL, Procedure, HIDDEN_ROUTER_CONTRACT_SYMBOL;
var init_server_Ds4HPpvH = __esm({
  "node_modules/@orpc/server/dist/shared/server.Ds4HPpvH.mjs"() {
    init_dist4();
    init_dist();
    init_dist3();
    init_dist2();
    LAZY_SYMBOL = Symbol("ORPC_LAZY_SYMBOL");
    Procedure = class {
      /**
       * This property holds the defined options.
       */
      "~orpc";
      constructor(def) {
        this["~orpc"] = def;
      }
    };
    HIDDEN_ROUTER_CONTRACT_SYMBOL = Symbol("ORPC_HIDDEN_ROUTER_CONTRACT");
  }
});

// node_modules/@orpc/server/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  AsyncIteratorClass: () => AsyncIteratorClass,
  Builder: () => Builder,
  DecoratedProcedure: () => DecoratedProcedure,
  EventPublisher: () => EventPublisher,
  LAZY_SYMBOL: () => LAZY_SYMBOL,
  ORPCError: () => ORPCError,
  Procedure: () => Procedure,
  ValidationError: () => ValidationError,
  addMiddleware: () => addMiddleware,
  call: () => call,
  createAccessibleLazyRouter: () => createAccessibleLazyRouter,
  createActionableClient: () => createActionableClient,
  createAssertedLazyProcedure: () => createAssertedLazyProcedure,
  createContractedProcedure: () => createContractedProcedure,
  createORPCErrorConstructorMap: () => createORPCErrorConstructorMap,
  createProcedureClient: () => createProcedureClient,
  createRouterClient: () => createRouterClient,
  decorateMiddleware: () => decorateMiddleware,
  enhanceRouter: () => enhanceRouter,
  eventIterator: () => eventIterator,
  eventIteratorToStream: () => asyncIteratorToStream,
  eventIteratorToUnproxiedDataStream: () => asyncIteratorToUnproxiedDataStream,
  fallbackConfig: () => fallbackConfig,
  getEventMeta: () => getEventMeta,
  getHiddenRouterContract: () => getHiddenRouterContract,
  getLazyMeta: () => getLazyMeta,
  getRouter: () => getRouter,
  implement: () => implement,
  implementerInternal: () => implementerInternal,
  inferRPCMethodFromRouter: () => inferRPCMethodFromRouter,
  isDefinedError: () => isDefinedError,
  isLazy: () => isLazy,
  isProcedure: () => isProcedure,
  isStartWithMiddlewares: () => isStartWithMiddlewares,
  lazy: () => lazy,
  mergeCurrentContext: () => mergeCurrentContext,
  mergeMiddlewares: () => mergeMiddlewares,
  middlewareOutputFn: () => middlewareOutputFn,
  onError: () => onError,
  onFinish: () => onFinish,
  onStart: () => onStart,
  onSuccess: () => onSuccess,
  os: () => os,
  resolveContractProcedures: () => resolveContractProcedures,
  safe: () => safe,
  setHiddenRouterContract: () => setHiddenRouterContract,
  streamToEventIterator: () => streamToAsyncIteratorClass,
  traverseContractProcedures: () => traverseContractProcedures,
  type: () => type,
  unlazy: () => unlazy,
  unlazyRouter: () => unlazyRouter,
  validateORPCError: () => validateORPCError,
  withEventMeta: () => withEventMeta
});
function fallbackConfig(key, value2) {
  if (value2 === void 0) {
    return DEFAULT_CONFIG2[key];
  }
  return value2;
}
function decorateMiddleware(middleware) {
  const decorated = ((...args2) => middleware(...args2));
  decorated.mapInput = (mapInput) => {
    const mapped = decorateMiddleware(
      (options, input, ...rest) => middleware(options, mapInput(input), ...rest)
    );
    return mapped;
  };
  decorated.concat = (concatMiddleware, mapInput) => {
    const mapped = mapInput ? decorateMiddleware(concatMiddleware).mapInput(mapInput) : concatMiddleware;
    const concatted = decorateMiddleware((options, input, output, ...rest) => {
      const merged = middleware({
        ...options,
        next: (...[nextOptions1]) => mapped({
          ...options,
          context: { ...options.context, ...nextOptions1?.context },
          next: (...[nextOptions2]) => options.next({ context: { ...nextOptions1?.context, ...nextOptions2?.context } })
        }, input, output, ...rest)
      }, input, output, ...rest);
      return merged;
    });
    return concatted;
  };
  return decorated;
}
function createActionableClient(client) {
  const action = async (input) => {
    try {
      return [null, await client(input)];
    } catch (error) {
      if (error instanceof Error && "digest" in error && typeof error.digest === "string" && error.digest.startsWith("NEXT_")) {
        throw error;
      }
      if (error instanceof Response && "options" in error && isObject(error.options) || isObject(error) && error.isNotFound === true) {
        throw error;
      }
      return [toORPCError(error).toJSON(), void 0];
    }
  };
  return action;
}
function implementerInternal(contract, config2, middlewares) {
  if (isContractProcedure(contract)) {
    const impl2 = new Builder({
      ...contract["~orpc"],
      config: config2,
      middlewares,
      inputValidationIndex: fallbackConfig("initialInputValidationIndex", config2?.initialInputValidationIndex) + middlewares.length,
      outputValidationIndex: fallbackConfig("initialOutputValidationIndex", config2?.initialOutputValidationIndex) + middlewares.length,
      dedupeLeadingMiddlewares: fallbackConfig("dedupeLeadingMiddlewares", config2.dedupeLeadingMiddlewares)
    });
    return impl2;
  }
  const impl = new Proxy(contract, {
    get: (target, key) => {
      if (typeof key !== "string") {
        return Reflect.get(target, key);
      }
      let method;
      if (key === "middleware") {
        method = (mid) => decorateMiddleware(mid);
      } else if (key === "use") {
        method = (mid) => {
          return implementerInternal(
            contract,
            config2,
            addMiddleware(middlewares, mid)
          );
        };
      } else if (key === "router") {
        method = (router2) => {
          const adapted = enhanceRouter(router2, {
            middlewares,
            errorMap: {},
            prefix: void 0,
            tags: void 0,
            dedupeLeadingMiddlewares: fallbackConfig("dedupeLeadingMiddlewares", config2.dedupeLeadingMiddlewares)
          });
          return setHiddenRouterContract(adapted, contract);
        };
      } else if (key === "lazy") {
        method = (loader) => {
          const adapted = enhanceRouter(lazy(loader), {
            middlewares,
            errorMap: {},
            prefix: void 0,
            tags: void 0,
            dedupeLeadingMiddlewares: fallbackConfig("dedupeLeadingMiddlewares", config2.dedupeLeadingMiddlewares)
          });
          return setHiddenRouterContract(adapted, contract);
        };
      }
      const next = getContractRouter(target, [key]);
      if (!next) {
        return method ?? next;
      }
      const nextImpl = implementerInternal(next, config2, middlewares);
      if (method) {
        return new Proxy(method, {
          get(_, key2) {
            return Reflect.get(nextImpl, key2);
          }
        });
      }
      return nextImpl;
    }
  });
  return impl;
}
function implement(contract, config2 = {}) {
  const implInternal = implementerInternal(contract, config2, []);
  const impl = new Proxy(implInternal, {
    get: (target, key) => {
      let method;
      if (key === "$context") {
        method = () => impl;
      } else if (key === "$config") {
        method = (config22) => implement(contract, config22);
      }
      const next = Reflect.get(target, key);
      if (!method || !next || typeof next !== "function" && typeof next !== "object") {
        return method || next;
      }
      return new Proxy(method, {
        get(_, key2) {
          return Reflect.get(next, key2);
        }
      });
    }
  });
  return impl;
}
function inferRPCMethodFromRouter(router2) {
  return async (_, path24) => {
    const { default: procedure } = await unlazy(getRouter(router2, path24));
    if (!isProcedure(procedure)) {
      throw new Error(
        `[inferRPCMethodFromRouter] No valid procedure found at path "${path24.join(".")}". This may happen when the router is not properly configured.`
      );
    }
    const method = fallbackContractConfig("defaultMethod", procedure["~orpc"].route.method);
    return method === "HEAD" ? "GET" : method;
  };
}
function createRouterClient(router2, ...rest) {
  const options = resolveMaybeOptionalOptions(rest);
  if (isProcedure(router2)) {
    const caller = createProcedureClient(router2, options);
    return caller;
  }
  const procedureCaller = isLazy(router2) ? createProcedureClient(createAssertedLazyProcedure(router2), options) : {};
  const recursive = new Proxy(procedureCaller, {
    get(target, key) {
      if (typeof key !== "string") {
        return Reflect.get(target, key);
      }
      const next = getRouter(router2, [key]);
      if (!next) {
        return Reflect.get(target, key);
      }
      return createRouterClient(next, {
        ...rest[0],
        path: [...rest[0]?.path ?? [], key]
      });
    }
  });
  return recursive;
}
var DEFAULT_CONFIG2, DecoratedProcedure, Builder, os;
var init_dist5 = __esm({
  "node_modules/@orpc/server/dist/index.mjs"() {
    init_dist4();
    init_dist4();
    init_server_Ds4HPpvH();
    init_server_Ds4HPpvH();
    init_dist3();
    init_dist3();
    init_dist();
    init_dist();
    init_dist2();
    DEFAULT_CONFIG2 = {
      initialInputValidationIndex: 0,
      initialOutputValidationIndex: 0,
      dedupeLeadingMiddlewares: true
    };
    DecoratedProcedure = class _DecoratedProcedure extends Procedure {
      /**
       * Adds type-safe custom errors.
       * The provided errors are spared-merged with any existing errors.
       *
       * @see {@link https://orpc.dev/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
       */
      errors(errors) {
        return new _DecoratedProcedure({
          ...this["~orpc"],
          errorMap: mergeErrorMap(this["~orpc"].errorMap, errors)
        });
      }
      /**
       * Sets or updates the metadata.
       * The provided metadata is spared-merged with any existing metadata.
       *
       * @see {@link https://orpc.dev/docs/metadata Metadata Docs}
       */
      meta(meta) {
        return new _DecoratedProcedure({
          ...this["~orpc"],
          meta: mergeMeta(this["~orpc"].meta, meta)
        });
      }
      /**
       * Sets or updates the route definition.
       * The provided route is spared-merged with any existing route.
       * This option is typically relevant when integrating with OpenAPI.
       *
       * @see {@link https://orpc.dev/docs/openapi/routing OpenAPI Routing Docs}
       * @see {@link https://orpc.dev/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
       */
      route(route) {
        return new _DecoratedProcedure({
          ...this["~orpc"],
          route: mergeRoute(this["~orpc"].route, route)
        });
      }
      use(middleware, mapInput) {
        const mapped = mapInput ? decorateMiddleware(middleware).mapInput(mapInput) : middleware;
        return new _DecoratedProcedure({
          ...this["~orpc"],
          middlewares: addMiddleware(this["~orpc"].middlewares, mapped)
        });
      }
      /**
       * Make this procedure callable (works like a function while still being a procedure).
       *
       * @see {@link https://orpc.dev/docs/client/server-side Server-side Client Docs}
       */
      callable(...rest) {
        const client = createProcedureClient(this, ...rest);
        return new Proxy(client, {
          get: (target, key) => {
            return Reflect.has(this, key) ? Reflect.get(this, key) : Reflect.get(target, key);
          },
          has: (target, key) => {
            return Reflect.has(this, key) || Reflect.has(target, key);
          }
        });
      }
      /**
       * Make this procedure compatible with server action.
       *
       * @see {@link https://orpc.dev/docs/server-action Server Action Docs}
       */
      actionable(...rest) {
        const action = createActionableClient(createProcedureClient(this, ...rest));
        return new Proxy(action, {
          get: (target, key) => {
            return Reflect.has(this, key) ? Reflect.get(this, key) : Reflect.get(target, key);
          },
          has: (target, key) => {
            return Reflect.has(this, key) || Reflect.has(target, key);
          }
        });
      }
    };
    Builder = class _Builder {
      /**
       * This property holds the defined options.
       */
      "~orpc";
      constructor(def) {
        this["~orpc"] = def;
      }
      /**
       * Sets or overrides the config.
       *
       * @see {@link https://orpc.dev/docs/client/server-side#middlewares-order Middlewares Order Docs}
       * @see {@link https://orpc.dev/docs/best-practices/dedupe-middleware#configuration Dedupe Middleware Docs}
       */
      $config(config2) {
        const inputValidationCount = this["~orpc"].inputValidationIndex - fallbackConfig("initialInputValidationIndex", this["~orpc"].config.initialInputValidationIndex);
        const outputValidationCount = this["~orpc"].outputValidationIndex - fallbackConfig("initialOutputValidationIndex", this["~orpc"].config.initialOutputValidationIndex);
        return new _Builder({
          ...this["~orpc"],
          config: config2,
          dedupeLeadingMiddlewares: fallbackConfig("dedupeLeadingMiddlewares", config2.dedupeLeadingMiddlewares),
          inputValidationIndex: fallbackConfig("initialInputValidationIndex", config2.initialInputValidationIndex) + inputValidationCount,
          outputValidationIndex: fallbackConfig("initialOutputValidationIndex", config2.initialOutputValidationIndex) + outputValidationCount
        });
      }
      /**
       * Set or override the initial context.
       *
       * @see {@link https://orpc.dev/docs/context Context Docs}
       */
      $context() {
        return new _Builder({
          ...this["~orpc"],
          middlewares: [],
          inputValidationIndex: fallbackConfig("initialInputValidationIndex", this["~orpc"].config.initialInputValidationIndex),
          outputValidationIndex: fallbackConfig("initialOutputValidationIndex", this["~orpc"].config.initialOutputValidationIndex)
        });
      }
      /**
       * Sets or overrides the initial meta.
       *
       * @see {@link https://orpc.dev/docs/metadata Metadata Docs}
       */
      $meta(initialMeta) {
        return new _Builder({
          ...this["~orpc"],
          meta: initialMeta
        });
      }
      /**
       * Sets or overrides the initial route.
       * This option is typically relevant when integrating with OpenAPI.
       *
       * @see {@link https://orpc.dev/docs/openapi/routing OpenAPI Routing Docs}
       * @see {@link https://orpc.dev/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
       */
      $route(initialRoute) {
        return new _Builder({
          ...this["~orpc"],
          route: initialRoute
        });
      }
      /**
       * Sets or overrides the initial input schema.
       *
       * @see {@link https://orpc.dev/docs/procedure#initial-configuration Initial Procedure Configuration Docs}
       */
      $input(initialInputSchema) {
        return new _Builder({
          ...this["~orpc"],
          inputSchema: initialInputSchema
        });
      }
      /**
       * Creates a middleware.
       *
       * @see {@link https://orpc.dev/docs/middleware Middleware Docs}
       */
      middleware(middleware) {
        return decorateMiddleware(middleware);
      }
      /**
       * Adds type-safe custom errors.
       * The provided errors are spared-merged with any existing errors.
       *
       * @see {@link https://orpc.dev/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
       */
      errors(errors) {
        return new _Builder({
          ...this["~orpc"],
          errorMap: mergeErrorMap(this["~orpc"].errorMap, errors)
        });
      }
      use(middleware, mapInput) {
        const mapped = mapInput ? decorateMiddleware(middleware).mapInput(mapInput) : middleware;
        return new _Builder({
          ...this["~orpc"],
          middlewares: addMiddleware(this["~orpc"].middlewares, mapped)
        });
      }
      /**
       * Sets or updates the metadata.
       * The provided metadata is spared-merged with any existing metadata.
       *
       * @see {@link https://orpc.dev/docs/metadata Metadata Docs}
       */
      meta(meta) {
        return new _Builder({
          ...this["~orpc"],
          meta: mergeMeta(this["~orpc"].meta, meta)
        });
      }
      /**
       * Sets or updates the route definition.
       * The provided route is spared-merged with any existing route.
       * This option is typically relevant when integrating with OpenAPI.
       *
       * @see {@link https://orpc.dev/docs/openapi/routing OpenAPI Routing Docs}
       * @see {@link https://orpc.dev/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
       */
      route(route) {
        return new _Builder({
          ...this["~orpc"],
          route: mergeRoute(this["~orpc"].route, route)
        });
      }
      /**
       * Defines the input validation schema.
       *
       * @see {@link https://orpc.dev/docs/procedure#input-output-validation Input Validation Docs}
       */
      input(schema) {
        return new _Builder({
          ...this["~orpc"],
          inputSchema: schema,
          inputValidationIndex: fallbackConfig("initialInputValidationIndex", this["~orpc"].config.initialInputValidationIndex) + this["~orpc"].middlewares.length
        });
      }
      /**
       * Defines the output validation schema.
       *
       * @see {@link https://orpc.dev/docs/procedure#input-output-validation Output Validation Docs}
       */
      output(schema) {
        return new _Builder({
          ...this["~orpc"],
          outputSchema: schema,
          outputValidationIndex: fallbackConfig("initialOutputValidationIndex", this["~orpc"].config.initialOutputValidationIndex) + this["~orpc"].middlewares.length
        });
      }
      /**
       * Defines the handler of the procedure.
       *
       * @see {@link https://orpc.dev/docs/procedure Procedure Docs}
       */
      handler(handler) {
        return new DecoratedProcedure({
          ...this["~orpc"],
          handler
        });
      }
      /**
       * Prefixes all procedures in the router.
       * The provided prefix is post-appended to any existing router prefix.
       *
       * @note This option does not affect procedures that do not define a path in their route definition.
       *
       * @see {@link https://orpc.dev/docs/openapi/routing#route-prefixes OpenAPI Route Prefixes Docs}
       */
      prefix(prefix) {
        return new _Builder({
          ...this["~orpc"],
          prefix: mergePrefix(this["~orpc"].prefix, prefix)
        });
      }
      /**
       * Adds tags to all procedures in the router.
       * This helpful when you want to group procedures together in the OpenAPI specification.
       *
       * @see {@link https://orpc.dev/docs/openapi/openapi-specification#operation-metadata OpenAPI Operation Metadata Docs}
       */
      tag(...tags) {
        return new _Builder({
          ...this["~orpc"],
          tags: mergeTags(this["~orpc"].tags, tags)
        });
      }
      /**
       * Applies all of the previously defined options to the specified router.
       *
       * @see {@link https://orpc.dev/docs/router#extending-router Extending Router Docs}
       */
      router(router2) {
        return enhanceRouter(router2, this["~orpc"]);
      }
      /**
       * Create a lazy router
       * And applies all of the previously defined options to the specified router.
       *
       * @see {@link https://orpc.dev/docs/router#extending-router Extending Router Docs}
       */
      lazy(loader) {
        return enhanceRouter(lazy(loader), this["~orpc"]);
      }
    };
    os = new Builder({
      config: {},
      route: {},
      meta: {},
      errorMap: {},
      inputValidationIndex: fallbackConfig("initialInputValidationIndex"),
      outputValidationIndex: fallbackConfig("initialOutputValidationIndex"),
      middlewares: [],
      dedupeLeadingMiddlewares: true
    });
  }
});

// node_modules/@ai-sdk/provider/dist/index.mjs
function getErrorMessage(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
function isJSONValue(value2) {
  if (value2 === null || typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "boolean") {
    return true;
  }
  if (Array.isArray(value2)) {
    return value2.every(isJSONValue);
  }
  if (typeof value2 === "object") {
    return Object.entries(value2).every(
      ([key, val]) => typeof key === "string" && (val === void 0 || isJSONValue(val))
    );
  }
  return false;
}
function isJSONArray(value2) {
  return Array.isArray(value2) && value2.every(isJSONValue);
}
function isJSONObject(value2) {
  return value2 != null && typeof value2 === "object" && Object.entries(value2).every(
    ([key, val]) => typeof key === "string" && (val === void 0 || isJSONValue(val))
  );
}
var marker, symbol, _a, _b, AISDKError, name, marker2, symbol2, _a2, _b2, APICallError, name2, marker3, symbol3, _a3, _b3, EmptyResponseBodyError, name3, marker4, symbol4, _a4, _b4, InvalidArgumentError2, name4, marker5, symbol5, _a5, _b5, InvalidPromptError, name5, marker6, symbol6, _a6, _b6, InvalidResponseDataError, name6, marker7, symbol7, _a7, _b7, JSONParseError, name7, marker8, symbol8, _a8, _b8, LoadAPIKeyError, name8, marker9, symbol9, _a9, _b9, LoadSettingError, name9, marker10, symbol10, _a10, _b10, NoContentGeneratedError, name10, marker11, symbol11, _a11, _b11, NoSuchModelError, name11, marker12, symbol12, _a12, _b12, TooManyEmbeddingValuesForCallError, name12, marker13, symbol13, _a13, _b13, TypeValidationError, name13, marker14, symbol14, _a14, _b14, UnsupportedFunctionalityError;
var init_dist6 = __esm({
  "node_modules/@ai-sdk/provider/dist/index.mjs"() {
    marker = "vercel.ai.error";
    symbol = Symbol.for(marker);
    AISDKError = class _AISDKError extends (_b = Error, _a = symbol, _b) {
      /**
       * Creates an AI SDK Error.
       *
       * @param {Object} params - The parameters for creating the error.
       * @param {string} params.name - The name of the error.
       * @param {string} params.message - The error message.
       * @param {unknown} [params.cause] - The underlying cause of the error.
       */
      constructor({
        name: name144,
        message,
        cause
      }) {
        super(message);
        this[_a] = true;
        this.name = name144;
        this.cause = cause;
      }
      /**
       * Checks if the given error is an AI SDK Error.
       * @param {unknown} error - The error to check.
       * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
       */
      static isInstance(error) {
        return _AISDKError.hasMarker(error, marker);
      }
      static hasMarker(error, marker154) {
        const markerSymbol = Symbol.for(marker154);
        return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
      }
    };
    name = "AI_APICallError";
    marker2 = `vercel.ai.error.${name}`;
    symbol2 = Symbol.for(marker2);
    APICallError = class extends (_b2 = AISDKError, _a2 = symbol2, _b2) {
      constructor({
        message,
        url,
        requestBodyValues,
        statusCode,
        responseHeaders,
        responseBody,
        cause,
        isRetryable = statusCode != null && (statusCode === 408 || // request timeout
        statusCode === 409 || // conflict
        statusCode === 429 || // too many requests
        statusCode >= 500),
        // server error
        data
      }) {
        super({ name, message, cause });
        this[_a2] = true;
        this.url = url;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker2);
      }
    };
    name2 = "AI_EmptyResponseBodyError";
    marker3 = `vercel.ai.error.${name2}`;
    symbol3 = Symbol.for(marker3);
    EmptyResponseBodyError = class extends (_b3 = AISDKError, _a3 = symbol3, _b3) {
      // used in isInstance
      constructor({ message = "Empty response body" } = {}) {
        super({ name: name2, message });
        this[_a3] = true;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker3);
      }
    };
    name3 = "AI_InvalidArgumentError";
    marker4 = `vercel.ai.error.${name3}`;
    symbol4 = Symbol.for(marker4);
    InvalidArgumentError2 = class extends (_b4 = AISDKError, _a4 = symbol4, _b4) {
      constructor({
        message,
        cause,
        argument
      }) {
        super({ name: name3, message, cause });
        this[_a4] = true;
        this.argument = argument;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker4);
      }
    };
    name4 = "AI_InvalidPromptError";
    marker5 = `vercel.ai.error.${name4}`;
    symbol5 = Symbol.for(marker5);
    InvalidPromptError = class extends (_b5 = AISDKError, _a5 = symbol5, _b5) {
      constructor({
        prompt,
        message,
        cause
      }) {
        super({ name: name4, message: `Invalid prompt: ${message}`, cause });
        this[_a5] = true;
        this.prompt = prompt;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker5);
      }
    };
    name5 = "AI_InvalidResponseDataError";
    marker6 = `vercel.ai.error.${name5}`;
    symbol6 = Symbol.for(marker6);
    InvalidResponseDataError = class extends (_b6 = AISDKError, _a6 = symbol6, _b6) {
      constructor({
        data,
        message = `Invalid response data: ${JSON.stringify(data)}.`
      }) {
        super({ name: name5, message });
        this[_a6] = true;
        this.data = data;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker6);
      }
    };
    name6 = "AI_JSONParseError";
    marker7 = `vercel.ai.error.${name6}`;
    symbol7 = Symbol.for(marker7);
    JSONParseError = class extends (_b7 = AISDKError, _a7 = symbol7, _b7) {
      constructor({ text: text2, cause }) {
        super({
          name: name6,
          message: `JSON parsing failed: Text: ${text2}.
Error message: ${getErrorMessage(cause)}`,
          cause
        });
        this[_a7] = true;
        this.text = text2;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker7);
      }
    };
    name7 = "AI_LoadAPIKeyError";
    marker8 = `vercel.ai.error.${name7}`;
    symbol8 = Symbol.for(marker8);
    LoadAPIKeyError = class extends (_b8 = AISDKError, _a8 = symbol8, _b8) {
      // used in isInstance
      constructor({ message }) {
        super({ name: name7, message });
        this[_a8] = true;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker8);
      }
    };
    name8 = "AI_LoadSettingError";
    marker9 = `vercel.ai.error.${name8}`;
    symbol9 = Symbol.for(marker9);
    LoadSettingError = class extends (_b9 = AISDKError, _a9 = symbol9, _b9) {
      // used in isInstance
      constructor({ message }) {
        super({ name: name8, message });
        this[_a9] = true;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker9);
      }
    };
    name9 = "AI_NoContentGeneratedError";
    marker10 = `vercel.ai.error.${name9}`;
    symbol10 = Symbol.for(marker10);
    NoContentGeneratedError = class extends (_b10 = AISDKError, _a10 = symbol10, _b10) {
      // used in isInstance
      constructor({
        message = "No content generated."
      } = {}) {
        super({ name: name9, message });
        this[_a10] = true;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker10);
      }
    };
    name10 = "AI_NoSuchModelError";
    marker11 = `vercel.ai.error.${name10}`;
    symbol11 = Symbol.for(marker11);
    NoSuchModelError = class extends (_b11 = AISDKError, _a11 = symbol11, _b11) {
      constructor({
        errorName = name10,
        modelId,
        modelType,
        message = `No such ${modelType}: ${modelId}`
      }) {
        super({ name: errorName, message });
        this[_a11] = true;
        this.modelId = modelId;
        this.modelType = modelType;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker11);
      }
    };
    name11 = "AI_TooManyEmbeddingValuesForCallError";
    marker12 = `vercel.ai.error.${name11}`;
    symbol12 = Symbol.for(marker12);
    TooManyEmbeddingValuesForCallError = class extends (_b12 = AISDKError, _a12 = symbol12, _b12) {
      constructor(options) {
        super({
          name: name11,
          message: `Too many values for a single embedding call. The ${options.provider} model "${options.modelId}" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`
        });
        this[_a12] = true;
        this.provider = options.provider;
        this.modelId = options.modelId;
        this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;
        this.values = options.values;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker12);
      }
    };
    name12 = "AI_TypeValidationError";
    marker13 = `vercel.ai.error.${name12}`;
    symbol13 = Symbol.for(marker13);
    TypeValidationError = class _TypeValidationError extends (_b13 = AISDKError, _a13 = symbol13, _b13) {
      constructor({
        value: value2,
        cause,
        context: context2
      }) {
        let contextPrefix = "Type validation failed";
        if (context2 == null ? void 0 : context2.field) {
          contextPrefix += ` for ${context2.field}`;
        }
        if ((context2 == null ? void 0 : context2.entityName) || (context2 == null ? void 0 : context2.entityId)) {
          contextPrefix += " (";
          const parts = [];
          if (context2.entityName) {
            parts.push(context2.entityName);
          }
          if (context2.entityId) {
            parts.push(`id: "${context2.entityId}"`);
          }
          contextPrefix += parts.join(", ");
          contextPrefix += ")";
        }
        super({
          name: name12,
          message: `${contextPrefix}: Value: ${JSON.stringify(value2)}.
Error message: ${getErrorMessage(cause)}`,
          cause
        });
        this[_a13] = true;
        this.value = value2;
        this.context = context2;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker13);
      }
      /**
       * Wraps an error into a TypeValidationError.
       * If the cause is already a TypeValidationError with the same value and context, it returns the cause.
       * Otherwise, it creates a new TypeValidationError.
       *
       * @param {Object} params - The parameters for wrapping the error.
       * @param {unknown} params.value - The value that failed validation.
       * @param {unknown} params.cause - The original error or cause of the validation failure.
       * @param {TypeValidationContext} params.context - Optional context about what is being validated.
       * @returns {TypeValidationError} A TypeValidationError instance.
       */
      static wrap({
        value: value2,
        cause,
        context: context2
      }) {
        var _a154, _b153, _c;
        if (_TypeValidationError.isInstance(cause) && cause.value === value2 && ((_a154 = cause.context) == null ? void 0 : _a154.field) === (context2 == null ? void 0 : context2.field) && ((_b153 = cause.context) == null ? void 0 : _b153.entityName) === (context2 == null ? void 0 : context2.entityName) && ((_c = cause.context) == null ? void 0 : _c.entityId) === (context2 == null ? void 0 : context2.entityId)) {
          return cause;
        }
        return new _TypeValidationError({ value: value2, cause, context: context2 });
      }
    };
    name13 = "AI_UnsupportedFunctionalityError";
    marker14 = `vercel.ai.error.${name13}`;
    symbol14 = Symbol.for(marker14);
    UnsupportedFunctionalityError = class extends (_b14 = AISDKError, _a14 = symbol14, _b14) {
      constructor({
        functionality,
        message = `'${functionality}' functionality not supported.`
      }) {
        super({ name: name13, message });
        this[_a14] = true;
        this.functionality = functionality;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker14);
      }
    };
  }
});

// node_modules/eventsource-parser/dist/index.js
function noop(_arg) {
}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop, onError: onError2 = noop, onRetry = noop, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value2 = line.slice(fieldSeparatorIndex + offset);
      processField(field, value2, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value2, line) {
    switch (field) {
      case "event":
        eventType = value2;
        break;
      case "data":
        data = `${data}${value2}
`;
        break;
      case "id":
        id = value2.includes("\0") ? void 0 : value2;
        break;
      case "retry":
        /^\d+$/.test(value2) ? onRetry(parseInt(value2, 10)) : onError2(
          new ParseError(`Invalid \`retry\` value: "${value2}"`, {
            type: "invalid-retry",
            value: value2,
            line
          })
        );
        break;
      default:
        onError2(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value: value2, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
var ParseError;
var init_dist7 = __esm({
  "node_modules/eventsource-parser/dist/index.js"() {
    ParseError = class extends Error {
      constructor(message, options) {
        super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
      }
    };
  }
});

// node_modules/eventsource-parser/dist/stream.js
var EventSourceParserStream;
var init_stream = __esm({
  "node_modules/eventsource-parser/dist/stream.js"() {
    init_dist7();
    EventSourceParserStream = class extends TransformStream {
      constructor({ onError: onError2, onRetry, onComment } = {}) {
        let parser;
        super({
          start(controller) {
            parser = createParser({
              onEvent: (event) => {
                controller.enqueue(event);
              },
              onError(error) {
                onError2 === "terminate" ? controller.error(error) : typeof onError2 == "function" && onError2(error);
              },
              onRetry,
              onComment
            });
          },
          transform(chunk) {
            parser.feed(chunk);
          }
        });
      }
    };
  }
});

// node_modules/@ai-sdk/provider-utils/dist/index.mjs
import * as z42 from "zod/v4";
import { ZodFirstPartyTypeKind as ZodFirstPartyTypeKind3 } from "zod/v3";
import { ZodFirstPartyTypeKind as ZodFirstPartyTypeKind2 } from "zod/v3";
import {
  ZodFirstPartyTypeKind as ZodFirstPartyTypeKind22
} from "zod/v3";
function combineHeaders(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}
function createToolNameMapping({
  tools = [],
  providerToolNames
}) {
  const customToolNameToProviderToolName = {};
  const providerToolNameToCustomToolName = {};
  for (const tool2 of tools) {
    if (tool2.type === "provider" && tool2.id in providerToolNames) {
      const providerToolName = providerToolNames[tool2.id];
      customToolNameToProviderToolName[tool2.name] = providerToolName;
      providerToolNameToCustomToolName[providerToolName] = tool2.name;
    }
  }
  return {
    toProviderToolName: (customToolName) => {
      var _a25;
      return (_a25 = customToolNameToProviderToolName[customToolName]) != null ? _a25 : customToolName;
    },
    toCustomToolName: (providerToolName) => {
      var _a25;
      return (_a25 = providerToolNameToCustomToolName[providerToolName]) != null ? _a25 : providerToolName;
    }
  };
}
async function delay(delayInMs, options) {
  if (delayInMs == null) {
    return Promise.resolve();
  }
  const signal = options == null ? void 0 : options.abortSignal;
  return new Promise((resolve22, reject) => {
    if (signal == null ? void 0 : signal.aborted) {
      reject(createAbortError());
      return;
    }
    const timeoutId = setTimeout(() => {
      cleanup();
      resolve22();
    }, delayInMs);
    const cleanup = () => {
      clearTimeout(timeoutId);
      signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
    };
    const onAbort = () => {
      cleanup();
      reject(createAbortError());
    };
    signal == null ? void 0 : signal.addEventListener("abort", onAbort);
  });
}
function createAbortError() {
  return new DOMException("Delay was aborted", "AbortError");
}
function extractResponseHeaders(response) {
  return Object.fromEntries([...response.headers]);
}
function convertBase64ToUint8Array(base64String) {
  const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
  const latin1string = atob2(base64Url);
  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));
}
function convertUint8ArrayToBase64(array2) {
  let latin1string = "";
  for (let i = 0; i < array2.length; i++) {
    latin1string += String.fromCodePoint(array2[i]);
  }
  return btoa2(latin1string);
}
function convertToBase64(value2) {
  return value2 instanceof Uint8Array ? convertUint8ArrayToBase64(value2) : value2;
}
function convertToFormData(input, options = {}) {
  const { useArrayBrackets = true } = options;
  const formData = new FormData();
  for (const [key, value2] of Object.entries(input)) {
    if (value2 == null) {
      continue;
    }
    if (Array.isArray(value2)) {
      if (value2.length === 1) {
        formData.append(key, value2[0]);
        continue;
      }
      const arrayKey = useArrayBrackets ? `${key}[]` : key;
      for (const item of value2) {
        formData.append(arrayKey, item);
      }
      continue;
    }
    formData.append(key, value2);
  }
  return formData;
}
async function downloadBlob(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new DownloadError({
        url,
        statusCode: response.status,
        statusText: response.statusText
      });
    }
    return await response.blob();
  } catch (error) {
    if (DownloadError.isInstance(error)) {
      throw error;
    }
    throw new DownloadError({ url, cause: error });
  }
}
function getErrorMessage2(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
function isAbortError(error) {
  return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
  error.name === "TimeoutError");
}
function isBunNetworkError(error) {
  if (!(error instanceof Error)) {
    return false;
  }
  const code = error.code;
  if (typeof code === "string" && BUN_ERROR_CODES.includes(code)) {
    return true;
  }
  return false;
}
function handleFetchError({
  error,
  url,
  requestBodyValues
}) {
  if (isAbortError(error)) {
    return error;
  }
  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {
    const cause = error.cause;
    if (cause != null) {
      return new APICallError({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  if (isBunNetworkError(error)) {
    return new APICallError({
      message: `Cannot connect to API: ${error.message}`,
      cause: error,
      url,
      requestBodyValues,
      isRetryable: true
    });
  }
  return error;
}
function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
  var _a25, _b24, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a25 = globalThisAny.navigator) == null ? void 0 : _a25.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b24 = globalThisAny.process) == null ? void 0 : _b24.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function normalizeHeaders(headers) {
  if (headers == null) {
    return {};
  }
  const normalized = {};
  if (headers instanceof Headers) {
    headers.forEach((value2, key) => {
      normalized[key.toLowerCase()] = value2;
    });
  } else {
    if (!Array.isArray(headers)) {
      headers = Object.entries(headers);
    }
    for (const [key, value2] of headers) {
      if (value2 != null) {
        normalized[key.toLowerCase()] = value2;
      }
    }
  }
  return normalized;
}
function withUserAgentSuffix(headers, ...userAgentSuffixParts) {
  const normalizedHeaders = new Headers(normalizeHeaders(headers));
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders.entries());
}
function isNonNullable(value2) {
  return value2 != null;
}
function isUrlSupported({
  mediaType,
  url,
  supportedUrls
}) {
  url = url.toLowerCase();
  mediaType = mediaType.toLowerCase();
  return Object.entries(supportedUrls).map(([key, value2]) => {
    const mediaType2 = key.toLowerCase();
    return mediaType2 === "*" || mediaType2 === "*/*" ? { mediaTypePrefix: "", regexes: value2 } : { mediaTypePrefix: mediaType2.replace(/\*/, ""), regexes: value2 };
  }).filter(({ mediaTypePrefix }) => mediaType.startsWith(mediaTypePrefix)).flatMap(({ regexes }) => regexes).some((pattern) => pattern.test(url));
}
function loadApiKey({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
function loadOptionalSetting({
  settingValue,
  environmentVariableName
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null || typeof process === "undefined") {
    return void 0;
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null || typeof settingValue !== "string") {
    return void 0;
  }
  return settingValue;
}
function loadSetting({
  settingValue,
  environmentVariableName,
  settingName,
  description
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null) {
    throw new LoadSettingError({
      message: `${description} setting must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadSettingError({
      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null) {
    throw new LoadSettingError({
      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof settingValue !== "string") {
    throw new LoadSettingError({
      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return settingValue;
}
function mediaTypeToExtension(mediaType) {
  var _a25;
  const [_type, subtype = ""] = mediaType.toLowerCase().split("/");
  return (_a25 = {
    mpeg: "mp3",
    "x-wav": "wav",
    opus: "ogg",
    mp4: "m4a",
    "x-m4a": "m4a"
  }[subtype]) != null ? _a25 : subtype;
}
function _parse(text2) {
  const obj = JSON.parse(text2);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx.test(text2) === false && suspectConstructorRx.test(text2) === false) {
    return obj;
  }
  return filter(obj);
}
function filter(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value2 = node[key];
        if (value2 && typeof value2 === "object") {
          next.push(value2);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse(text2) {
  const { stackTraceLimit } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch (e) {
    return _parse(text2);
  }
  try {
    return _parse(text2);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
function addAdditionalPropertiesToJsonSchema(jsonSchema22) {
  if (jsonSchema22.type === "object" || Array.isArray(jsonSchema22.type) && jsonSchema22.type.includes("object")) {
    jsonSchema22.additionalProperties = false;
    const { properties } = jsonSchema22;
    if (properties != null) {
      for (const key of Object.keys(properties)) {
        properties[key] = visit(properties[key]);
      }
    }
  }
  if (jsonSchema22.items != null) {
    jsonSchema22.items = Array.isArray(jsonSchema22.items) ? jsonSchema22.items.map(visit) : visit(jsonSchema22.items);
  }
  if (jsonSchema22.anyOf != null) {
    jsonSchema22.anyOf = jsonSchema22.anyOf.map(visit);
  }
  if (jsonSchema22.allOf != null) {
    jsonSchema22.allOf = jsonSchema22.allOf.map(visit);
  }
  if (jsonSchema22.oneOf != null) {
    jsonSchema22.oneOf = jsonSchema22.oneOf.map(visit);
  }
  const { definitions } = jsonSchema22;
  if (definitions != null) {
    for (const key of Object.keys(definitions)) {
      definitions[key] = visit(definitions[key]);
    }
  }
  return jsonSchema22;
}
function visit(def) {
  if (typeof def === "boolean") return def;
  return addAdditionalPropertiesToJsonSchema(def);
}
function parseAnyDef2() {
  return {};
}
function parseArrayDef2(def, refs) {
  var _a25, _b24, _c;
  const res = {
    type: "array"
  };
  if (((_a25 = def.type) == null ? void 0 : _a25._def) && ((_c = (_b24 = def.type) == null ? void 0 : _b24._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind2.ZodAny) {
    res.items = parseDef2(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef2(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef2() {
  return { type: "boolean" };
}
function parseBrandedDef2(_def, refs) {
  return parseDef2(_def.type._def, refs);
}
function parseDateDef2(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef2(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser2(def);
  }
}
function parseDefaultDef2(_def, refs) {
  return {
    ...parseDef2(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef2(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef2(_def.schema._def, refs) : parseAnyDef2();
}
function parseEnumDef2(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
function parseIntersectionDef2(def, refs) {
  const allOf = [
    parseDef2(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef2(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType2(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef2(def) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
function parseStringDef2(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat2(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat2(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern2(res, zodPatterns2.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat2(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat2(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern2(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern2(res, zodPatterns2.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern2(res, zodPatterns2.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern2(
            res,
            RegExp(`^${escapeLiteralCheckValue2(check.value, refs)}`),
            check.message,
            refs
          );
          break;
        case "endsWith":
          addPattern2(
            res,
            RegExp(`${escapeLiteralCheckValue2(check.value, refs)}$`),
            check.message,
            refs
          );
          break;
        case "datetime":
          addFormat2(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat2(res, "date", check.message, refs);
          break;
        case "time":
          addFormat2(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat2(res, "duration", check.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "includes": {
          addPattern2(
            res,
            RegExp(escapeLiteralCheckValue2(check.value, refs)),
            check.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat2(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat2(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern2(res, zodPatterns2.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern2(res, zodPatterns2.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern2(res, zodPatterns2.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern2(res, zodPatterns2.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern2(res, zodPatterns2.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern2(res, zodPatterns2.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat2(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern2(res, zodPatterns2.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern2(res, zodPatterns2.nanoid, check.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue2(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric2(literal) : literal;
}
function escapeNonAlphaNumeric2(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC2.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat2(schema, value2, message, refs) {
  var _a25;
  if (schema.format || ((_a25 = schema.anyOf) == null ? void 0 : _a25.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push({
      format: value2,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    schema.format = value2;
  }
}
function addPattern2(schema, regex, message, refs) {
  var _a25;
  if (schema.pattern || ((_a25 = schema.allOf) == null ? void 0 : _a25.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags2(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    schema.pattern = stringifyRegExpWithFlags2(regex, refs);
  }
}
function stringifyRegExpWithFlags2(regex, refs) {
  var _a25;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a25 = source[i + 2]) == null ? void 0 : _a25.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch (e) {
    console.warn(
      `Could not convert regex pattern at ${refs.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    );
    return regex.source;
  }
  return pattern;
}
function parseRecordDef2(def, refs) {
  var _a25, _b24, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a25 = parseDef2(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _a25 : refs.allowedAdditionalProperties
  };
  if (((_b24 = def.keyType) == null ? void 0 : _b24._def.typeName) === ZodFirstPartyTypeKind22.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type: type2, ...keyType } = parseStringDef2(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind22.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind22.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind22.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type: type2, ...keyType } = parseBrandedDef2(
      def.keyType._def,
      refs
    );
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef2(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef2(def, refs);
  }
  const keys = parseDef2(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef2();
  const values = parseDef2(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef2();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef2(def) {
  const object2 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object2[object2[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object2[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef2() {
  return { not: parseAnyDef2() };
}
function parseNullDef2() {
  return {
    type: "null"
  };
}
function parseUnionDef2(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x) => x._def.typeName in primitiveMappings2 && (!x._def.checks || !x._def.checks.length)
  )) {
    const types = options.reduce((types2, x) => {
      const type2 = primitiveMappings2[x._def.typeName];
      return type2 && !types2.includes(type2) ? [...types2, type2] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce(
      (acc, x) => {
        const type2 = typeof x._def.value;
        switch (type2) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type2];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ],
        []
      )
    };
  }
  return asAnyOf2(def, refs);
}
function parseNullableDef2(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings2[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef2(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef2(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseObjectDef2(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional2(propDef);
    const parsedDef = parseDef2(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties2(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties2(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef2(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional2(schema) {
  try {
    return schema.isOptional();
  } catch (e) {
    return true;
  }
}
function parsePromiseDef2(def, refs) {
  return parseDef2(def.type._def, refs);
}
function parseSetDef2(def, refs) {
  const items = parseDef2(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef2(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef2(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      ),
      additionalItems: parseDef2(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef2(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      )
    };
  }
}
function parseUndefinedDef2() {
  return {
    not: parseAnyDef2()
  };
}
function parseUnknownDef2() {
  return parseAnyDef2();
}
function parseDef2(def, refs, forceResolution = false) {
  var _a25;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a25 = refs.override) == null ? void 0 : _a25.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride2) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref2(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser2(def, def.typeName, refs);
  const jsonSchema22 = typeof jsonSchemaOrGetter === "function" ? parseDef2(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema22) {
    addMeta2(def, refs, jsonSchema22);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema22, def, refs);
    newItem.jsonSchema = jsonSchema22;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema22;
  return jsonSchema22;
}
function lazySchema(createSchema) {
  let schema;
  return () => {
    if (schema == null) {
      schema = createSchema();
    }
    return schema;
  };
}
function jsonSchema(jsonSchema22, {
  validate
} = {}) {
  return {
    [schemaSymbol]: true,
    _type: void 0,
    // should never be used directly
    get jsonSchema() {
      if (typeof jsonSchema22 === "function") {
        jsonSchema22 = jsonSchema22();
      }
      return jsonSchema22;
    },
    validate
  };
}
function isSchema(value2) {
  return typeof value2 === "object" && value2 !== null && schemaSymbol in value2 && value2[schemaSymbol] === true && "jsonSchema" in value2 && "validate" in value2;
}
function asSchema(schema) {
  return schema == null ? jsonSchema({ properties: {}, additionalProperties: false }) : isSchema(schema) ? schema : "~standard" in schema ? schema["~standard"].vendor === "zod" ? zodSchema(schema) : standardSchema(schema) : schema();
}
function standardSchema(standardSchema22) {
  return jsonSchema(
    () => addAdditionalPropertiesToJsonSchema(
      standardSchema22["~standard"].jsonSchema.input({
        target: "draft-07"
      })
    ),
    {
      validate: async (value2) => {
        const result = await standardSchema22["~standard"].validate(value2);
        return "value" in result ? { success: true, value: result.value } : {
          success: false,
          error: new TypeValidationError({
            value: value2,
            cause: result.issues
          })
        };
      }
    }
  );
}
function zod3Schema(zodSchema22, options) {
  var _a25;
  const useReferences = (_a25 = options == null ? void 0 : options.useReferences) != null ? _a25 : false;
  return jsonSchema(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod3ToJsonSchema(zodSchema22, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: async (value2) => {
        const result = await zodSchema22.safeParseAsync(value2);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function zod4Schema(zodSchema22, options) {
  var _a25;
  const useReferences = (_a25 = options == null ? void 0 : options.useReferences) != null ? _a25 : false;
  return jsonSchema(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => addAdditionalPropertiesToJsonSchema(
      z42.toJSONSchema(zodSchema22, {
        target: "draft-7",
        io: "input",
        reused: useReferences ? "ref" : "inline"
      })
    ),
    {
      validate: async (value2) => {
        const result = await z42.safeParseAsync(zodSchema22, value2);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function isZod4Schema(zodSchema22) {
  return "_zod" in zodSchema22;
}
function zodSchema(zodSchema22, options) {
  if (isZod4Schema(zodSchema22)) {
    return zod4Schema(zodSchema22, options);
  } else {
    return zod3Schema(zodSchema22, options);
  }
}
async function validateTypes({
  value: value2,
  schema,
  context: context2
}) {
  const result = await safeValidateTypes({ value: value2, schema, context: context2 });
  if (!result.success) {
    throw TypeValidationError.wrap({ value: value2, cause: result.error, context: context2 });
  }
  return result.value;
}
async function safeValidateTypes({
  value: value2,
  schema,
  context: context2
}) {
  const actualSchema = asSchema(schema);
  try {
    if (actualSchema.validate == null) {
      return { success: true, value: value2, rawValue: value2 };
    }
    const result = await actualSchema.validate(value2);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value2 };
    }
    return {
      success: false,
      error: TypeValidationError.wrap({ value: value2, cause: result.error, context: context2 }),
      rawValue: value2
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError.wrap({ value: value2, cause: error, context: context2 }),
      rawValue: value2
    };
  }
}
async function parseJSON({
  text: text2,
  schema
}) {
  try {
    const value2 = secureJsonParse(text2);
    if (schema == null) {
      return value2;
    }
    return validateTypes({ value: value2, schema });
  } catch (error) {
    if (JSONParseError.isInstance(error) || TypeValidationError.isInstance(error)) {
      throw error;
    }
    throw new JSONParseError({ text: text2, cause: error });
  }
}
async function safeParseJSON({
  text: text2,
  schema
}) {
  try {
    const value2 = secureJsonParse(text2);
    if (schema == null) {
      return { success: true, value: value2, rawValue: value2 };
    }
    return await safeValidateTypes({ value: value2, schema });
  } catch (error) {
    return {
      success: false,
      error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text: text2, cause: error }),
      rawValue: void 0
    };
  }
}
function isParsableJson(input) {
  try {
    secureJsonParse(input);
    return true;
  } catch (e) {
    return false;
  }
}
function parseJsonEventStream({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON({ text: data, schema }));
      }
    })
  );
}
async function parseProviderOptions({
  provider,
  providerOptions,
  schema
}) {
  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {
    return void 0;
  }
  const parsedProviderOptions = await safeValidateTypes({
    value: providerOptions[provider],
    schema
  });
  if (!parsedProviderOptions.success) {
    throw new InvalidArgumentError2({
      argument: "providerOptions",
      message: `invalid ${provider} provider options`,
      cause: parsedProviderOptions.error
    });
  }
  return parsedProviderOptions.value;
}
function tool(tool2) {
  return tool2;
}
function dynamicTool(tool2) {
  return { ...tool2, type: "dynamic" };
}
function createProviderToolFactory({
  id,
  inputSchema
}) {
  return ({
    execute,
    outputSchema: outputSchema2,
    needsApproval,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable,
    ...args2
  }) => tool({
    type: "provider",
    id,
    args: args2,
    inputSchema,
    outputSchema: outputSchema2,
    execute,
    needsApproval,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable
  });
}
function createProviderToolFactoryWithOutputSchema({
  id,
  inputSchema,
  outputSchema: outputSchema2,
  supportsDeferredResults
}) {
  return ({
    execute,
    needsApproval,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable,
    ...args2
  }) => tool({
    type: "provider",
    id,
    args: args2,
    inputSchema,
    outputSchema: outputSchema2,
    execute,
    needsApproval,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable,
    supportsDeferredResults
  });
}
async function resolve(value2) {
  if (typeof value2 === "function") {
    value2 = value2();
  }
  return Promise.resolve(value2);
}
function withoutTrailingSlash(url) {
  return url == null ? void 0 : url.replace(/\/$/, "");
}
function isAsyncIterable(obj) {
  return obj != null && typeof obj[Symbol.asyncIterator] === "function";
}
async function* executeTool({
  execute,
  input,
  options
}) {
  const result = execute(input, options);
  if (isAsyncIterable(result)) {
    let lastOutput;
    for await (const output of result) {
      lastOutput = output;
      yield { type: "preliminary", output };
    }
    yield { type: "final", output: lastOutput };
  } else {
    yield { type: "final", output: await result };
  }
}
var DelayedPromise, btoa2, atob2, name14, marker15, symbol15, _a15, _b15, DownloadError, createIdGenerator, generateId, FETCH_FAILED_ERROR_MESSAGES, BUN_ERROR_CODES, VERSION, getOriginalFetch, getFromApi, suspectProtoRx, suspectConstructorRx, ignoreOverride2, defaultOptions2, getDefaultOptions2, parseCatchDef2, integerDateParser2, isJsonSchema7AllOfType2, emojiRegex2, zodPatterns2, ALPHA_NUMERIC2, primitiveMappings2, asAnyOf2, parseOptionalDef2, parsePipelineDef2, parseReadonlyDef2, selectParser2, getRelativePath2, get$ref2, addMeta2, getRefs2, zod3ToJsonSchema, schemaSymbol, getOriginalFetch2, postJsonToApi, postFormDataToApi, postToApi, createJsonErrorResponseHandler, createEventSourceResponseHandler, createJsonResponseHandler, createBinaryResponseHandler;
var init_dist8 = __esm({
  "node_modules/@ai-sdk/provider-utils/dist/index.mjs"() {
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_stream();
    init_dist6();
    init_dist6();
    init_dist6();
    DelayedPromise = class {
      constructor() {
        this.status = { type: "pending" };
        this._resolve = void 0;
        this._reject = void 0;
      }
      get promise() {
        if (this._promise) {
          return this._promise;
        }
        this._promise = new Promise((resolve22, reject) => {
          if (this.status.type === "resolved") {
            resolve22(this.status.value);
          } else if (this.status.type === "rejected") {
            reject(this.status.error);
          }
          this._resolve = resolve22;
          this._reject = reject;
        });
        return this._promise;
      }
      resolve(value2) {
        var _a25;
        this.status = { type: "resolved", value: value2 };
        if (this._promise) {
          (_a25 = this._resolve) == null ? void 0 : _a25.call(this, value2);
        }
      }
      reject(error) {
        var _a25;
        this.status = { type: "rejected", error };
        if (this._promise) {
          (_a25 = this._reject) == null ? void 0 : _a25.call(this, error);
        }
      }
      isResolved() {
        return this.status.type === "resolved";
      }
      isRejected() {
        return this.status.type === "rejected";
      }
      isPending() {
        return this.status.type === "pending";
      }
    };
    ({ btoa: btoa2, atob: atob2 } = globalThis);
    name14 = "AI_DownloadError";
    marker15 = `vercel.ai.error.${name14}`;
    symbol15 = Symbol.for(marker15);
    DownloadError = class extends (_b15 = AISDKError, _a15 = symbol15, _b15) {
      constructor({
        url,
        statusCode,
        statusText,
        cause,
        message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`
      }) {
        super({ name: name14, message, cause });
        this[_a15] = true;
        this.url = url;
        this.statusCode = statusCode;
        this.statusText = statusText;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker15);
      }
    };
    createIdGenerator = ({
      prefix,
      size = 16,
      alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
      separator = "-"
    } = {}) => {
      const generator = () => {
        const alphabetLength = alphabet.length;
        const chars = new Array(size);
        for (let i = 0; i < size; i++) {
          chars[i] = alphabet[Math.random() * alphabetLength | 0];
        }
        return chars.join("");
      };
      if (prefix == null) {
        return generator;
      }
      if (alphabet.includes(separator)) {
        throw new InvalidArgumentError2({
          argument: "separator",
          message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
      }
      return () => `${prefix}${separator}${generator()}`;
    };
    generateId = createIdGenerator();
    FETCH_FAILED_ERROR_MESSAGES = ["fetch failed", "failed to fetch"];
    BUN_ERROR_CODES = [
      "ConnectionRefused",
      "ConnectionClosed",
      "FailedToOpenSocket",
      "ECONNRESET",
      "ECONNREFUSED",
      "ETIMEDOUT",
      "EPIPE"
    ];
    VERSION = true ? "4.0.13" : "0.0.0-test";
    getOriginalFetch = () => globalThis.fetch;
    getFromApi = async ({
      url,
      headers = {},
      successfulResponseHandler,
      failedResponseHandler,
      abortSignal,
      fetch: fetch2 = getOriginalFetch()
    }) => {
      try {
        const response = await fetch2(url, {
          method: "GET",
          headers: withUserAgentSuffix(
            headers,
            `ai-sdk/provider-utils/${VERSION}`,
            getRuntimeEnvironmentUserAgent()
          ),
          signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders(response);
        if (!response.ok) {
          let errorInformation;
          try {
            errorInformation = await failedResponseHandler({
              response,
              url,
              requestBodyValues: {}
            });
          } catch (error) {
            if (isAbortError(error) || APICallError.isInstance(error)) {
              throw error;
            }
            throw new APICallError({
              message: "Failed to process error response",
              cause: error,
              statusCode: response.status,
              url,
              responseHeaders,
              requestBodyValues: {}
            });
          }
          throw errorInformation.value;
        }
        try {
          return await successfulResponseHandler({
            response,
            url,
            requestBodyValues: {}
          });
        } catch (error) {
          if (error instanceof Error) {
            if (isAbortError(error) || APICallError.isInstance(error)) {
              throw error;
            }
          }
          throw new APICallError({
            message: "Failed to process successful response",
            cause: error,
            statusCode: response.status,
            url,
            responseHeaders,
            requestBodyValues: {}
          });
        }
      } catch (error) {
        throw handleFetchError({ error, url, requestBodyValues: {} });
      }
    };
    suspectProtoRx = /"__proto__"\s*:/;
    suspectConstructorRx = /"constructor"\s*:/;
    ignoreOverride2 = Symbol(
      "Let zodToJsonSchema decide on which parser to use"
    );
    defaultOptions2 = {
      name: void 0,
      $refStrategy: "root",
      basePath: ["#"],
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "format:date-time",
      mapStrategy: "entries",
      removeAdditionalStrategy: "passthrough",
      allowedAdditionalProperties: true,
      rejectedAdditionalProperties: false,
      definitionPath: "definitions",
      strictUnions: false,
      definitions: {},
      errorMessages: false,
      patternStrategy: "escape",
      applyRegexFlags: false,
      emailStrategy: "format:email",
      base64Strategy: "contentEncoding:base64",
      nameStrategy: "ref"
    };
    getDefaultOptions2 = (options) => typeof options === "string" ? {
      ...defaultOptions2,
      name: options
    } : {
      ...defaultOptions2,
      ...options
    };
    parseCatchDef2 = (def, refs) => {
      return parseDef2(def.innerType._def, refs);
    };
    integerDateParser2 = (def) => {
      const res = {
        type: "integer",
        format: "unix-time"
      };
      for (const check of def.checks) {
        switch (check.kind) {
          case "min":
            res.minimum = check.value;
            break;
          case "max":
            res.maximum = check.value;
            break;
        }
      }
      return res;
    };
    isJsonSchema7AllOfType2 = (type2) => {
      if ("type" in type2 && type2.type === "string") return false;
      return "allOf" in type2;
    };
    emojiRegex2 = void 0;
    zodPatterns2 = {
      /**
       * `c` was changed to `[cC]` to replicate /i flag
       */
      cuid: /^[cC][^\s-]{8,}$/,
      cuid2: /^[0-9a-z]+$/,
      ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
      /**
       * `a-z` was added to replicate /i flag
       */
      email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
      /**
       * Constructed a valid Unicode RegExp
       *
       * Lazily instantiate since this type of regex isn't supported
       * in all envs (e.g. React Native).
       *
       * See:
       * https://github.com/colinhacks/zod/issues/2433
       * Fix in Zod:
       * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
       */
      emoji: () => {
        if (emojiRegex2 === void 0) {
          emojiRegex2 = RegExp(
            "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
            "u"
          );
        }
        return emojiRegex2;
      },
      /**
       * Unused
       */
      uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
      /**
       * Unused
       */
      ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
      /**
       * Unused
       */
      ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
      ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
      base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
      base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
      nanoid: /^[a-zA-Z0-9_-]{21}$/,
      jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
    };
    ALPHA_NUMERIC2 = new Set(
      "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
    );
    primitiveMappings2 = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBigInt: "integer",
      ZodBoolean: "boolean",
      ZodNull: "null"
    };
    asAnyOf2 = (def, refs) => {
      const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
        (x, i) => parseDef2(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "anyOf", `${i}`]
        })
      ).filter(
        (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
      );
      return anyOf.length ? { anyOf } : void 0;
    };
    parseOptionalDef2 = (def, refs) => {
      var _a25;
      if (refs.currentPath.toString() === ((_a25 = refs.propertyPath) == null ? void 0 : _a25.toString())) {
        return parseDef2(def.innerType._def, refs);
      }
      const innerSchema = parseDef2(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "1"]
      });
      return innerSchema ? { anyOf: [{ not: parseAnyDef2() }, innerSchema] } : parseAnyDef2();
    };
    parsePipelineDef2 = (def, refs) => {
      if (refs.pipeStrategy === "input") {
        return parseDef2(def.in._def, refs);
      } else if (refs.pipeStrategy === "output") {
        return parseDef2(def.out._def, refs);
      }
      const a = parseDef2(def.in._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      });
      const b = parseDef2(def.out._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
      });
      return {
        allOf: [a, b].filter((x) => x !== void 0)
      };
    };
    parseReadonlyDef2 = (def, refs) => {
      return parseDef2(def.innerType._def, refs);
    };
    selectParser2 = (def, typeName, refs) => {
      switch (typeName) {
        case ZodFirstPartyTypeKind3.ZodString:
          return parseStringDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodNumber:
          return parseNumberDef2(def);
        case ZodFirstPartyTypeKind3.ZodObject:
          return parseObjectDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodBigInt:
          return parseBigintDef2(def);
        case ZodFirstPartyTypeKind3.ZodBoolean:
          return parseBooleanDef2();
        case ZodFirstPartyTypeKind3.ZodDate:
          return parseDateDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodUndefined:
          return parseUndefinedDef2();
        case ZodFirstPartyTypeKind3.ZodNull:
          return parseNullDef2();
        case ZodFirstPartyTypeKind3.ZodArray:
          return parseArrayDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodUnion:
        case ZodFirstPartyTypeKind3.ZodDiscriminatedUnion:
          return parseUnionDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodIntersection:
          return parseIntersectionDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodTuple:
          return parseTupleDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodRecord:
          return parseRecordDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodLiteral:
          return parseLiteralDef2(def);
        case ZodFirstPartyTypeKind3.ZodEnum:
          return parseEnumDef2(def);
        case ZodFirstPartyTypeKind3.ZodNativeEnum:
          return parseNativeEnumDef2(def);
        case ZodFirstPartyTypeKind3.ZodNullable:
          return parseNullableDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodOptional:
          return parseOptionalDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodMap:
          return parseMapDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodSet:
          return parseSetDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodLazy:
          return () => def.getter()._def;
        case ZodFirstPartyTypeKind3.ZodPromise:
          return parsePromiseDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodNaN:
        case ZodFirstPartyTypeKind3.ZodNever:
          return parseNeverDef2();
        case ZodFirstPartyTypeKind3.ZodEffects:
          return parseEffectsDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodAny:
          return parseAnyDef2();
        case ZodFirstPartyTypeKind3.ZodUnknown:
          return parseUnknownDef2();
        case ZodFirstPartyTypeKind3.ZodDefault:
          return parseDefaultDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodBranded:
          return parseBrandedDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodReadonly:
          return parseReadonlyDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodCatch:
          return parseCatchDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodPipeline:
          return parsePipelineDef2(def, refs);
        case ZodFirstPartyTypeKind3.ZodFunction:
        case ZodFirstPartyTypeKind3.ZodVoid:
        case ZodFirstPartyTypeKind3.ZodSymbol:
          return void 0;
        default:
          return /* @__PURE__ */ ((_) => void 0)(typeName);
      }
    };
    getRelativePath2 = (pathA, pathB) => {
      let i = 0;
      for (; i < pathA.length && i < pathB.length; i++) {
        if (pathA[i] !== pathB[i]) break;
      }
      return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
    };
    get$ref2 = (item, refs) => {
      switch (refs.$refStrategy) {
        case "root":
          return { $ref: item.path.join("/") };
        case "relative":
          return { $ref: getRelativePath2(refs.currentPath, item.path) };
        case "none":
        case "seen": {
          if (item.path.length < refs.currentPath.length && item.path.every((value2, index) => refs.currentPath[index] === value2)) {
            console.warn(
              `Recursive reference detected at ${refs.currentPath.join(
                "/"
              )}! Defaulting to any`
            );
            return parseAnyDef2();
          }
          return refs.$refStrategy === "seen" ? parseAnyDef2() : void 0;
        }
      }
    };
    addMeta2 = (def, refs, jsonSchema22) => {
      if (def.description) {
        jsonSchema22.description = def.description;
      }
      return jsonSchema22;
    };
    getRefs2 = (options) => {
      const _options = getDefaultOptions2(options);
      const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
      return {
        ..._options,
        currentPath,
        propertyPath: void 0,
        seen: new Map(
          Object.entries(_options.definitions).map(([name25, def]) => [
            def._def,
            {
              def: def._def,
              path: [..._options.basePath, _options.definitionPath, name25],
              // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
              jsonSchema: void 0
            }
          ])
        )
      };
    };
    zod3ToJsonSchema = (schema, options) => {
      var _a25;
      const refs = getRefs2(options);
      let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
        (acc, [name35, schema2]) => {
          var _a35;
          return {
            ...acc,
            [name35]: (_a35 = parseDef2(
              schema2._def,
              {
                ...refs,
                currentPath: [...refs.basePath, refs.definitionPath, name35]
              },
              true
            )) != null ? _a35 : parseAnyDef2()
          };
        },
        {}
      ) : void 0;
      const name25 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
      const main = (_a25 = parseDef2(
        schema._def,
        name25 === void 0 ? refs : {
          ...refs,
          currentPath: [...refs.basePath, refs.definitionPath, name25]
        },
        false
      )) != null ? _a25 : parseAnyDef2();
      const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
      if (title !== void 0) {
        main.title = title;
      }
      const combined = name25 === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
      } : main : {
        $ref: [
          ...refs.$refStrategy === "relative" ? [] : refs.basePath,
          refs.definitionPath,
          name25
        ].join("/"),
        [refs.definitionPath]: {
          ...definitions,
          [name25]: main
        }
      };
      combined.$schema = "http://json-schema.org/draft-07/schema#";
      return combined;
    };
    schemaSymbol = Symbol.for("vercel.ai.schema");
    getOriginalFetch2 = () => globalThis.fetch;
    postJsonToApi = async ({
      url,
      headers,
      body,
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }) => postToApi({
      url,
      headers: {
        "Content-Type": "application/json",
        ...headers
      },
      body: {
        content: JSON.stringify(body),
        values: body
      },
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    });
    postFormDataToApi = async ({
      url,
      headers,
      formData,
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }) => postToApi({
      url,
      headers,
      body: {
        content: formData,
        values: Object.fromEntries(formData.entries())
      },
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    });
    postToApi = async ({
      url,
      headers = {},
      body,
      successfulResponseHandler,
      failedResponseHandler,
      abortSignal,
      fetch: fetch2 = getOriginalFetch2()
    }) => {
      try {
        const response = await fetch2(url, {
          method: "POST",
          headers: withUserAgentSuffix(
            headers,
            `ai-sdk/provider-utils/${VERSION}`,
            getRuntimeEnvironmentUserAgent()
          ),
          body: body.content,
          signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders(response);
        if (!response.ok) {
          let errorInformation;
          try {
            errorInformation = await failedResponseHandler({
              response,
              url,
              requestBodyValues: body.values
            });
          } catch (error) {
            if (isAbortError(error) || APICallError.isInstance(error)) {
              throw error;
            }
            throw new APICallError({
              message: "Failed to process error response",
              cause: error,
              statusCode: response.status,
              url,
              responseHeaders,
              requestBodyValues: body.values
            });
          }
          throw errorInformation.value;
        }
        try {
          return await successfulResponseHandler({
            response,
            url,
            requestBodyValues: body.values
          });
        } catch (error) {
          if (error instanceof Error) {
            if (isAbortError(error) || APICallError.isInstance(error)) {
              throw error;
            }
          }
          throw new APICallError({
            message: "Failed to process successful response",
            cause: error,
            statusCode: response.status,
            url,
            responseHeaders,
            requestBodyValues: body.values
          });
        }
      } catch (error) {
        throw handleFetchError({ error, url, requestBodyValues: body.values });
      }
    };
    createJsonErrorResponseHandler = ({
      errorSchema,
      errorToMessage,
      isRetryable
    }) => async ({ response, url, requestBodyValues }) => {
      const responseBody = await response.text();
      const responseHeaders = extractResponseHeaders(response);
      if (responseBody.trim() === "") {
        return {
          responseHeaders,
          value: new APICallError({
            message: response.statusText,
            url,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
      try {
        const parsedError = await parseJSON({
          text: responseBody,
          schema: errorSchema
        });
        return {
          responseHeaders,
          value: new APICallError({
            message: errorToMessage(parsedError),
            url,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            data: parsedError,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
          })
        };
      } catch (parseError) {
        return {
          responseHeaders,
          value: new APICallError({
            message: response.statusText,
            url,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
    };
    createEventSourceResponseHandler = (chunkSchema2) => async ({ response }) => {
      const responseHeaders = extractResponseHeaders(response);
      if (response.body == null) {
        throw new EmptyResponseBodyError({});
      }
      return {
        responseHeaders,
        value: parseJsonEventStream({
          stream: response.body,
          schema: chunkSchema2
        })
      };
    };
    createJsonResponseHandler = (responseSchema2) => async ({ response, url, requestBodyValues }) => {
      const responseBody = await response.text();
      const parsedResult = await safeParseJSON({
        text: responseBody,
        schema: responseSchema2
      });
      const responseHeaders = extractResponseHeaders(response);
      if (!parsedResult.success) {
        throw new APICallError({
          message: "Invalid JSON response",
          cause: parsedResult.error,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          url,
          requestBodyValues
        });
      }
      return {
        responseHeaders,
        value: parsedResult.value,
        rawValue: parsedResult.rawValue
      };
    };
    createBinaryResponseHandler = () => async ({ response, url, requestBodyValues }) => {
      const responseHeaders = extractResponseHeaders(response);
      if (!response.body) {
        throw new APICallError({
          message: "Response body is empty",
          url,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody: void 0
        });
      }
      try {
        const buffer = await response.arrayBuffer();
        return {
          responseHeaders,
          value: new Uint8Array(buffer)
        };
      } catch (error) {
        throw new APICallError({
          message: "Failed to read response as array buffer",
          url,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody: void 0,
          cause: error
        });
      }
    };
  }
});

// node_modules/@vercel/oidc/dist/get-context.js
var require_get_context = __commonJS({
  "node_modules/@vercel/oidc/dist/get-context.js"(exports, module) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export3 = (target, all) => {
      for (var name25 in all)
        __defProp4(target, name25, { get: all[name25], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp4({}, "__esModule", { value: true }), mod);
    var get_context_exports = {};
    __export3(get_context_exports, {
      SYMBOL_FOR_REQ_CONTEXT: () => SYMBOL_FOR_REQ_CONTEXT,
      getContext: () => getContext3
    });
    module.exports = __toCommonJS2(get_context_exports);
    var SYMBOL_FOR_REQ_CONTEXT = Symbol.for("@vercel/request-context");
    function getContext3() {
      const fromSymbol = globalThis;
      return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
    }
  }
});

// node_modules/@vercel/oidc/dist/token-error.js
var require_token_error = __commonJS({
  "node_modules/@vercel/oidc/dist/token-error.js"(exports, module) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export3 = (target, all) => {
      for (var name25 in all)
        __defProp4(target, name25, { get: all[name25], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp4({}, "__esModule", { value: true }), mod);
    var token_error_exports = {};
    __export3(token_error_exports, {
      VercelOidcTokenError: () => VercelOidcTokenError
    });
    module.exports = __toCommonJS2(token_error_exports);
    var VercelOidcTokenError = class extends Error {
      constructor(message, cause) {
        super(message);
        this.name = "VercelOidcTokenError";
        this.cause = cause;
      }
      toString() {
        if (this.cause) {
          return `${this.name}: ${this.message}: ${this.cause}`;
        }
        return `${this.name}: ${this.message}`;
      }
    };
  }
});

// node_modules/@vercel/oidc/dist/token-io.js
var require_token_io = __commonJS({
  "node_modules/@vercel/oidc/dist/token-io.js"(exports, module) {
    "use strict";
    var __create2 = Object.create;
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export3 = (target, all) => {
      for (var name25 in all)
        __defProp4(target, name25, { get: all[name25], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp4(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp4({}, "__esModule", { value: true }), mod);
    var token_io_exports = {};
    __export3(token_io_exports, {
      findRootDir: () => findRootDir,
      getUserDataDir: () => getUserDataDir
    });
    module.exports = __toCommonJS2(token_io_exports);
    var import_path4 = __toESM2(__require("path"));
    var import_fs3 = __toESM2(__require("fs"));
    var import_os2 = __toESM2(__require("os"));
    var import_token_error = require_token_error();
    function findRootDir() {
      try {
        let dir = process.cwd();
        while (dir !== import_path4.default.dirname(dir)) {
          const pkgPath = import_path4.default.join(dir, ".vercel");
          if (import_fs3.default.existsSync(pkgPath)) {
            return dir;
          }
          dir = import_path4.default.dirname(dir);
        }
      } catch (e) {
        throw new import_token_error.VercelOidcTokenError(
          "Token refresh only supported in node server environments"
        );
      }
      return null;
    }
    function getUserDataDir() {
      if (process.env.XDG_DATA_HOME) {
        return process.env.XDG_DATA_HOME;
      }
      switch (import_os2.default.platform()) {
        case "darwin":
          return import_path4.default.join(import_os2.default.homedir(), "Library/Application Support");
        case "linux":
          return import_path4.default.join(import_os2.default.homedir(), ".local/share");
        case "win32":
          if (process.env.LOCALAPPDATA) {
            return process.env.LOCALAPPDATA;
          }
          return null;
        default:
          return null;
      }
    }
  }
});

// node_modules/@vercel/oidc/dist/auth-config.js
var require_auth_config = __commonJS({
  "node_modules/@vercel/oidc/dist/auth-config.js"(exports, module) {
    "use strict";
    var __create2 = Object.create;
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export3 = (target, all) => {
      for (var name25 in all)
        __defProp4(target, name25, { get: all[name25], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp4(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp4({}, "__esModule", { value: true }), mod);
    var auth_config_exports = {};
    __export3(auth_config_exports, {
      isValidAccessToken: () => isValidAccessToken,
      readAuthConfig: () => readAuthConfig,
      writeAuthConfig: () => writeAuthConfig
    });
    module.exports = __toCommonJS2(auth_config_exports);
    var fs15 = __toESM2(__require("fs"));
    var path24 = __toESM2(__require("path"));
    var import_token_util = require_token_util();
    function getAuthConfigPath() {
      const dataDir = (0, import_token_util.getVercelDataDir)();
      if (!dataDir) {
        throw new Error(
          `Unable to find Vercel CLI data directory. Your platform: ${process.platform}. Supported: darwin, linux, win32.`
        );
      }
      return path24.join(dataDir, "auth.json");
    }
    function readAuthConfig() {
      try {
        const authPath = getAuthConfigPath();
        if (!fs15.existsSync(authPath)) {
          return null;
        }
        const content = fs15.readFileSync(authPath, "utf8");
        if (!content) {
          return null;
        }
        return JSON.parse(content);
      } catch (error) {
        return null;
      }
    }
    function writeAuthConfig(config2) {
      const authPath = getAuthConfigPath();
      const authDir = path24.dirname(authPath);
      if (!fs15.existsSync(authDir)) {
        fs15.mkdirSync(authDir, { mode: 504, recursive: true });
      }
      fs15.writeFileSync(authPath, JSON.stringify(config2, null, 2), { mode: 384 });
    }
    function isValidAccessToken(authConfig) {
      if (!authConfig.token)
        return false;
      if (typeof authConfig.expiresAt !== "number")
        return true;
      const nowInSeconds = Math.floor(Date.now() / 1e3);
      return authConfig.expiresAt >= nowInSeconds;
    }
  }
});

// node_modules/@vercel/oidc/dist/oauth.js
var require_oauth = __commonJS({
  "node_modules/@vercel/oidc/dist/oauth.js"(exports, module) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export3 = (target, all) => {
      for (var name25 in all)
        __defProp4(target, name25, { get: all[name25], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp4({}, "__esModule", { value: true }), mod);
    var oauth_exports = {};
    __export3(oauth_exports, {
      processTokenResponse: () => processTokenResponse,
      refreshTokenRequest: () => refreshTokenRequest
    });
    module.exports = __toCommonJS2(oauth_exports);
    var import_os2 = __require("os");
    var VERCEL_ISSUER = "https://vercel.com";
    var VERCEL_CLI_CLIENT_ID = "cl_HYyOPBNtFMfHhaUn9L4QPfTZz6TP47bp";
    var userAgent = `@vercel/oidc node-${process.version} ${(0, import_os2.platform)()} (${(0, import_os2.arch)()}) ${(0, import_os2.hostname)()}`;
    var _tokenEndpoint = null;
    async function getTokenEndpoint() {
      if (_tokenEndpoint) {
        return _tokenEndpoint;
      }
      const discoveryUrl = `${VERCEL_ISSUER}/.well-known/openid-configuration`;
      const response = await fetch(discoveryUrl, {
        headers: { "user-agent": userAgent }
      });
      if (!response.ok) {
        throw new Error("Failed to discover OAuth endpoints");
      }
      const metadata = await response.json();
      if (!metadata || typeof metadata.token_endpoint !== "string") {
        throw new Error("Invalid OAuth discovery response");
      }
      const endpoint = metadata.token_endpoint;
      _tokenEndpoint = endpoint;
      return endpoint;
    }
    async function refreshTokenRequest(options) {
      const tokenEndpoint = await getTokenEndpoint();
      return await fetch(tokenEndpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          "user-agent": userAgent
        },
        body: new URLSearchParams({
          client_id: VERCEL_CLI_CLIENT_ID,
          grant_type: "refresh_token",
          ...options
        })
      });
    }
    async function processTokenResponse(response) {
      const json2 = await response.json();
      if (!response.ok) {
        const errorMsg = typeof json2 === "object" && json2 && "error" in json2 ? String(json2.error) : "Token refresh failed";
        return [new Error(errorMsg)];
      }
      if (typeof json2 !== "object" || json2 === null) {
        return [new Error("Invalid token response")];
      }
      if (typeof json2.access_token !== "string") {
        return [new Error("Missing access_token in response")];
      }
      if (json2.token_type !== "Bearer") {
        return [new Error("Invalid token_type in response")];
      }
      if (typeof json2.expires_in !== "number") {
        return [new Error("Missing expires_in in response")];
      }
      return [null, json2];
    }
  }
});

// node_modules/@vercel/oidc/dist/token-util.js
var require_token_util = __commonJS({
  "node_modules/@vercel/oidc/dist/token-util.js"(exports, module) {
    "use strict";
    var __create2 = Object.create;
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export3 = (target, all) => {
      for (var name25 in all)
        __defProp4(target, name25, { get: all[name25], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp4(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp4({}, "__esModule", { value: true }), mod);
    var token_util_exports = {};
    __export3(token_util_exports, {
      assertVercelOidcTokenResponse: () => assertVercelOidcTokenResponse,
      findProjectInfo: () => findProjectInfo,
      getTokenPayload: () => getTokenPayload,
      getVercelCliToken: () => getVercelCliToken,
      getVercelDataDir: () => getVercelDataDir,
      getVercelOidcToken: () => getVercelOidcToken3,
      isExpired: () => isExpired,
      loadToken: () => loadToken,
      saveToken: () => saveToken
    });
    module.exports = __toCommonJS2(token_util_exports);
    var path24 = __toESM2(__require("path"));
    var fs15 = __toESM2(__require("fs"));
    var import_token_error = require_token_error();
    var import_token_io = require_token_io();
    var import_auth_config = require_auth_config();
    var import_oauth = require_oauth();
    function getVercelDataDir() {
      const vercelFolder = "com.vercel.cli";
      const dataDir = (0, import_token_io.getUserDataDir)();
      if (!dataDir) {
        return null;
      }
      return path24.join(dataDir, vercelFolder);
    }
    async function getVercelCliToken() {
      const authConfig = (0, import_auth_config.readAuthConfig)();
      if (!authConfig) {
        return null;
      }
      if ((0, import_auth_config.isValidAccessToken)(authConfig)) {
        return authConfig.token || null;
      }
      if (!authConfig.refreshToken) {
        (0, import_auth_config.writeAuthConfig)({});
        return null;
      }
      try {
        const tokenResponse = await (0, import_oauth.refreshTokenRequest)({
          refresh_token: authConfig.refreshToken
        });
        const [tokensError, tokens] = await (0, import_oauth.processTokenResponse)(tokenResponse);
        if (tokensError || !tokens) {
          (0, import_auth_config.writeAuthConfig)({});
          return null;
        }
        const updatedConfig = {
          token: tokens.access_token,
          expiresAt: Math.floor(Date.now() / 1e3) + tokens.expires_in
        };
        if (tokens.refresh_token) {
          updatedConfig.refreshToken = tokens.refresh_token;
        }
        (0, import_auth_config.writeAuthConfig)(updatedConfig);
        return updatedConfig.token ?? null;
      } catch (error) {
        (0, import_auth_config.writeAuthConfig)({});
        return null;
      }
    }
    async function getVercelOidcToken3(authToken, projectId, teamId) {
      const url = `https://api.vercel.com/v1/projects/${projectId}/token?source=vercel-oidc-refresh${teamId ? `&teamId=${teamId}` : ""}`;
      const res = await fetch(url, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${authToken}`
        }
      });
      if (!res.ok) {
        throw new import_token_error.VercelOidcTokenError(
          `Failed to refresh OIDC token: ${res.statusText}`
        );
      }
      const tokenRes = await res.json();
      assertVercelOidcTokenResponse(tokenRes);
      return tokenRes;
    }
    function assertVercelOidcTokenResponse(res) {
      if (!res || typeof res !== "object") {
        throw new TypeError(
          "Vercel OIDC token is malformed. Expected an object. Please run `vc env pull` and try again"
        );
      }
      if (!("token" in res) || typeof res.token !== "string") {
        throw new TypeError(
          "Vercel OIDC token is malformed. Expected a string-valued token property. Please run `vc env pull` and try again"
        );
      }
    }
    function findProjectInfo() {
      const dir = (0, import_token_io.findRootDir)();
      if (!dir) {
        throw new import_token_error.VercelOidcTokenError(
          "Unable to find project root directory. Have you linked your project with `vc link?`"
        );
      }
      const prjPath = path24.join(dir, ".vercel", "project.json");
      if (!fs15.existsSync(prjPath)) {
        throw new import_token_error.VercelOidcTokenError(
          "project.json not found, have you linked your project with `vc link?`"
        );
      }
      const prj = JSON.parse(fs15.readFileSync(prjPath, "utf8"));
      if (typeof prj.projectId !== "string" && typeof prj.orgId !== "string") {
        throw new TypeError(
          "Expected a string-valued projectId property. Try running `vc link` to re-link your project."
        );
      }
      return { projectId: prj.projectId, teamId: prj.orgId };
    }
    function saveToken(token, projectId) {
      const dir = (0, import_token_io.getUserDataDir)();
      if (!dir) {
        throw new import_token_error.VercelOidcTokenError(
          "Unable to find user data directory. Please reach out to Vercel support."
        );
      }
      const tokenPath = path24.join(dir, "com.vercel.token", `${projectId}.json`);
      const tokenJson = JSON.stringify(token);
      fs15.mkdirSync(path24.dirname(tokenPath), { mode: 504, recursive: true });
      fs15.writeFileSync(tokenPath, tokenJson);
      fs15.chmodSync(tokenPath, 432);
      return;
    }
    function loadToken(projectId) {
      const dir = (0, import_token_io.getUserDataDir)();
      if (!dir) {
        throw new import_token_error.VercelOidcTokenError(
          "Unable to find user data directory. Please reach out to Vercel support."
        );
      }
      const tokenPath = path24.join(dir, "com.vercel.token", `${projectId}.json`);
      if (!fs15.existsSync(tokenPath)) {
        return null;
      }
      const token = JSON.parse(fs15.readFileSync(tokenPath, "utf8"));
      assertVercelOidcTokenResponse(token);
      return token;
    }
    function getTokenPayload(token) {
      const tokenParts = token.split(".");
      if (tokenParts.length !== 3) {
        throw new import_token_error.VercelOidcTokenError(
          "Invalid token. Please run `vc env pull` and try again"
        );
      }
      const base64 = tokenParts[1].replace(/-/g, "+").replace(/_/g, "/");
      const padded = base64.padEnd(
        base64.length + (4 - base64.length % 4) % 4,
        "="
      );
      return JSON.parse(Buffer.from(padded, "base64").toString("utf8"));
    }
    function isExpired(token) {
      return token.exp * 1e3 < Date.now();
    }
  }
});

// node_modules/@vercel/oidc/dist/token.js
var require_token = __commonJS({
  "node_modules/@vercel/oidc/dist/token.js"(exports, module) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export3 = (target, all) => {
      for (var name25 in all)
        __defProp4(target, name25, { get: all[name25], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp4({}, "__esModule", { value: true }), mod);
    var token_exports = {};
    __export3(token_exports, {
      refreshToken: () => refreshToken
    });
    module.exports = __toCommonJS2(token_exports);
    var import_token_error = require_token_error();
    var import_token_util = require_token_util();
    async function refreshToken() {
      const { projectId, teamId } = (0, import_token_util.findProjectInfo)();
      let maybeToken = (0, import_token_util.loadToken)(projectId);
      if (!maybeToken || (0, import_token_util.isExpired)((0, import_token_util.getTokenPayload)(maybeToken.token))) {
        const authToken = await (0, import_token_util.getVercelCliToken)();
        if (!authToken) {
          throw new import_token_error.VercelOidcTokenError(
            "Failed to refresh OIDC token: Log in to Vercel CLI and link your project with `vc link`"
          );
        }
        if (!projectId) {
          throw new import_token_error.VercelOidcTokenError(
            "Failed to refresh OIDC token: Try re-linking your project with `vc link`"
          );
        }
        maybeToken = await (0, import_token_util.getVercelOidcToken)(authToken, projectId, teamId);
        if (!maybeToken) {
          throw new import_token_error.VercelOidcTokenError("Failed to refresh OIDC token");
        }
        (0, import_token_util.saveToken)(maybeToken, projectId);
      }
      process.env.VERCEL_OIDC_TOKEN = maybeToken.token;
      return;
    }
  }
});

// node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js
var require_get_vercel_oidc_token = __commonJS({
  "node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js"(exports, module) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export3 = (target, all) => {
      for (var name25 in all)
        __defProp4(target, name25, { get: all[name25], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp4({}, "__esModule", { value: true }), mod);
    var get_vercel_oidc_token_exports = {};
    __export3(get_vercel_oidc_token_exports, {
      getVercelOidcToken: () => getVercelOidcToken3,
      getVercelOidcTokenSync: () => getVercelOidcTokenSync2
    });
    module.exports = __toCommonJS2(get_vercel_oidc_token_exports);
    var import_get_context = require_get_context();
    var import_token_error = require_token_error();
    async function getVercelOidcToken3() {
      let token = "";
      let err;
      try {
        token = getVercelOidcTokenSync2();
      } catch (error) {
        err = error;
      }
      try {
        const [{ getTokenPayload, isExpired }, { refreshToken }] = await Promise.all([
          await Promise.resolve().then(() => __toESM(require_token_util())),
          await Promise.resolve().then(() => __toESM(require_token()))
        ]);
        if (!token || isExpired(getTokenPayload(token))) {
          await refreshToken();
          token = getVercelOidcTokenSync2();
        }
      } catch (error) {
        let message = err instanceof Error ? err.message : "";
        if (error instanceof Error) {
          message = `${message}
${error.message}`;
        }
        if (message) {
          throw new import_token_error.VercelOidcTokenError(message);
        }
        throw error;
      }
      return token;
    }
    function getVercelOidcTokenSync2() {
      const token = (0, import_get_context.getContext)().headers?.["x-vercel-oidc-token"] ?? process.env.VERCEL_OIDC_TOKEN;
      if (!token) {
        throw new Error(
          `The 'x-vercel-oidc-token' header is missing from the request. Do you have the OIDC option enabled in the Vercel project settings?`
        );
      }
      return token;
    }
  }
});

// node_modules/@vercel/oidc/dist/index.js
var require_dist = __commonJS({
  "node_modules/@vercel/oidc/dist/index.js"(exports, module) {
    "use strict";
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export3 = (target, all) => {
      for (var name25 in all)
        __defProp4(target, name25, { get: all[name25], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp4({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export3(src_exports, {
      getContext: () => import_get_context.getContext,
      getVercelOidcToken: () => import_get_vercel_oidc_token.getVercelOidcToken,
      getVercelOidcTokenSync: () => import_get_vercel_oidc_token.getVercelOidcTokenSync
    });
    module.exports = __toCommonJS2(src_exports);
    var import_get_vercel_oidc_token = require_get_vercel_oidc_token();
    var import_get_context = require_get_context();
  }
});

// node_modules/@ai-sdk/gateway/dist/index.mjs
import { z as z22 } from "zod/v4";
import { z as z16 } from "zod/v4";
import { z as z32 } from "zod/v4";
import { z as z43 } from "zod/v4";
import { z as z52 } from "zod/v4";
import { z as z62 } from "zod/v4";
import { z as z72 } from "zod/v4";
import { z as z82 } from "zod/v4";
import { z as z92 } from "zod";
import { z as z102 } from "zod";
async function createGatewayErrorFromResponse({
  response,
  statusCode,
  defaultMessage = "Gateway request failed",
  cause,
  authMethod
}) {
  var _a84;
  const parseResult = await safeValidateTypes({
    value: response,
    schema: gatewayErrorResponseSchema
  });
  if (!parseResult.success) {
    const rawGenerationId = typeof response === "object" && response !== null && "generationId" in response ? response.generationId : void 0;
    return new GatewayResponseError({
      message: `Invalid error response format: ${defaultMessage}`,
      statusCode,
      response,
      validationError: parseResult.error,
      cause,
      generationId: rawGenerationId
    });
  }
  const validatedResponse = parseResult.value;
  const errorType = validatedResponse.error.type;
  const message = validatedResponse.error.message;
  const generationId = (_a84 = validatedResponse.generationId) != null ? _a84 : void 0;
  switch (errorType) {
    case "authentication_error":
      return GatewayAuthenticationError.createContextualError({
        apiKeyProvided: authMethod === "api-key",
        oidcTokenProvided: authMethod === "oidc",
        statusCode,
        cause,
        generationId
      });
    case "invalid_request_error":
      return new GatewayInvalidRequestError({
        message,
        statusCode,
        cause,
        generationId
      });
    case "rate_limit_exceeded":
      return new GatewayRateLimitError({
        message,
        statusCode,
        cause,
        generationId
      });
    case "model_not_found": {
      const modelResult = await safeValidateTypes({
        value: validatedResponse.error.param,
        schema: modelNotFoundParamSchema
      });
      return new GatewayModelNotFoundError({
        message,
        statusCode,
        modelId: modelResult.success ? modelResult.value.modelId : void 0,
        cause,
        generationId
      });
    }
    case "internal_server_error":
      return new GatewayInternalServerError({
        message,
        statusCode,
        cause,
        generationId
      });
    default:
      return new GatewayInternalServerError({
        message,
        statusCode,
        cause,
        generationId
      });
  }
}
function asGatewayError(error, authMethod) {
  var _a84;
  if (GatewayError.isInstance(error)) {
    return error;
  }
  if (APICallError.isInstance(error)) {
    return createGatewayErrorFromResponse({
      response: extractApiCallResponse(error),
      statusCode: (_a84 = error.statusCode) != null ? _a84 : 500,
      defaultMessage: "Gateway request failed",
      cause: error,
      authMethod
    });
  }
  return createGatewayErrorFromResponse({
    response: {},
    statusCode: 500,
    defaultMessage: error instanceof Error ? `Gateway request failed: ${error.message}` : "Unknown Gateway error",
    cause: error,
    authMethod
  });
}
function extractApiCallResponse(error) {
  if (error.data !== void 0) {
    return error.data;
  }
  if (error.responseBody != null) {
    try {
      return JSON.parse(error.responseBody);
    } catch (e) {
      return error.responseBody;
    }
  }
  return {};
}
async function parseAuthMethod(headers) {
  const result = await safeValidateTypes({
    value: headers[GATEWAY_AUTH_METHOD_HEADER],
    schema: gatewayAuthMethodSchema
  });
  return result.success ? result.value : void 0;
}
function maybeEncodeImageFile(file) {
  if (file.type === "file" && file.data instanceof Uint8Array) {
    return {
      ...file,
      data: convertUint8ArrayToBase64(file.data)
    };
  }
  return file;
}
function maybeEncodeVideoFile(file) {
  if (file.type === "file" && file.data instanceof Uint8Array) {
    return {
      ...file,
      data: convertUint8ArrayToBase64(file.data)
    };
  }
  return file;
}
async function getVercelRequestId() {
  var _a84;
  return (_a84 = (0, import_oidc.getContext)().headers) == null ? void 0 : _a84["x-vercel-id"];
}
function createGatewayProvider(options = {}) {
  var _a84, _b83;
  let pendingMetadata = null;
  let metadataCache = null;
  const cacheRefreshMillis = (_a84 = options.metadataCacheRefreshMillis) != null ? _a84 : 1e3 * 60 * 5;
  let lastFetchTime = 0;
  const baseURL = (_b83 = withoutTrailingSlash(options.baseURL)) != null ? _b83 : "https://ai-gateway.vercel.sh/v3/ai";
  const getHeaders = async () => {
    try {
      const auth = await getGatewayAuthToken(options);
      return withUserAgentSuffix(
        {
          Authorization: `Bearer ${auth.token}`,
          "ai-gateway-protocol-version": AI_GATEWAY_PROTOCOL_VERSION,
          [GATEWAY_AUTH_METHOD_HEADER]: auth.authMethod,
          ...options.headers
        },
        `ai-sdk/gateway/${VERSION2}`
      );
    } catch (error) {
      throw GatewayAuthenticationError.createContextualError({
        apiKeyProvided: false,
        oidcTokenProvided: false,
        statusCode: 401,
        cause: error
      });
    }
  };
  const createO11yHeaders = () => {
    const deploymentId = loadOptionalSetting({
      settingValue: void 0,
      environmentVariableName: "VERCEL_DEPLOYMENT_ID"
    });
    const environment = loadOptionalSetting({
      settingValue: void 0,
      environmentVariableName: "VERCEL_ENV"
    });
    const region = loadOptionalSetting({
      settingValue: void 0,
      environmentVariableName: "VERCEL_REGION"
    });
    return async () => {
      const requestId = await getVercelRequestId();
      return {
        ...deploymentId && { "ai-o11y-deployment-id": deploymentId },
        ...environment && { "ai-o11y-environment": environment },
        ...region && { "ai-o11y-region": region },
        ...requestId && { "ai-o11y-request-id": requestId }
      };
    };
  };
  const createLanguageModel = (modelId) => {
    return new GatewayLanguageModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  const getAvailableModels = async () => {
    var _a94, _b93, _c;
    const now2 = (_c = (_b93 = (_a94 = options._internal) == null ? void 0 : _a94.currentDate) == null ? void 0 : _b93.call(_a94).getTime()) != null ? _c : Date.now();
    if (!pendingMetadata || now2 - lastFetchTime > cacheRefreshMillis) {
      lastFetchTime = now2;
      pendingMetadata = new GatewayFetchMetadata({
        baseURL,
        headers: getHeaders,
        fetch: options.fetch
      }).getAvailableModels().then((metadata) => {
        metadataCache = metadata;
        return metadata;
      }).catch(async (error) => {
        throw await asGatewayError(
          error,
          await parseAuthMethod(await getHeaders())
        );
      });
    }
    return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;
  };
  const getCredits = async () => {
    return new GatewayFetchMetadata({
      baseURL,
      headers: getHeaders,
      fetch: options.fetch
    }).getCredits().catch(async (error) => {
      throw await asGatewayError(
        error,
        await parseAuthMethod(await getHeaders())
      );
    });
  };
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Gateway Provider model function cannot be called with the new keyword."
      );
    }
    return createLanguageModel(modelId);
  };
  provider.specificationVersion = "v3";
  provider.getAvailableModels = getAvailableModels;
  provider.getCredits = getCredits;
  provider.imageModel = (modelId) => {
    return new GatewayImageModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  provider.languageModel = createLanguageModel;
  const createEmbeddingModel = (modelId) => {
    return new GatewayEmbeddingModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  provider.embeddingModel = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.videoModel = (modelId) => {
    return new GatewayVideoModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  provider.chat = provider.languageModel;
  provider.embedding = provider.embeddingModel;
  provider.image = provider.imageModel;
  provider.video = provider.videoModel;
  provider.tools = gatewayTools;
  return provider;
}
async function getGatewayAuthToken(options) {
  const apiKey = loadOptionalSetting({
    settingValue: options.apiKey,
    environmentVariableName: "AI_GATEWAY_API_KEY"
  });
  if (apiKey) {
    return {
      token: apiKey,
      authMethod: "api-key"
    };
  }
  const oidcToken = await (0, import_oidc2.getVercelOidcToken)();
  return {
    token: oidcToken,
    authMethod: "oidc"
  };
}
var import_oidc, import_oidc2, marker16, symbol16, _a16, _b16, GatewayError, name15, marker22, symbol22, _a22, _b22, GatewayAuthenticationError, name22, marker32, symbol32, _a32, _b32, GatewayInvalidRequestError, name32, marker42, symbol42, _a42, _b42, GatewayRateLimitError, name42, marker52, symbol52, modelNotFoundParamSchema, _a52, _b52, GatewayModelNotFoundError, name52, marker62, symbol62, _a62, _b62, GatewayInternalServerError, name62, marker72, symbol72, _a72, _b72, GatewayResponseError, gatewayErrorResponseSchema, GATEWAY_AUTH_METHOD_HEADER, gatewayAuthMethodSchema, GatewayFetchMetadata, gatewayAvailableModelsResponseSchema, gatewayCreditsResponseSchema, GatewayLanguageModel, GatewayEmbeddingModel, gatewayEmbeddingResponseSchema, GatewayImageModel, providerMetadataEntrySchema, gatewayImageResponseSchema, GatewayVideoModel, providerMetadataEntrySchema2, gatewayVideoDataSchema, gatewayVideoResponseSchema, parallelSearchInputSchema, parallelSearchOutputSchema, parallelSearchToolFactory, parallelSearch, perplexitySearchInputSchema, perplexitySearchOutputSchema, perplexitySearchToolFactory, perplexitySearch, gatewayTools, VERSION2, AI_GATEWAY_PROTOCOL_VERSION, gateway;
var init_dist9 = __esm({
  "node_modules/@ai-sdk/gateway/dist/index.mjs"() {
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    import_oidc = __toESM(require_dist(), 1);
    import_oidc2 = __toESM(require_dist(), 1);
    init_dist8();
    marker16 = "vercel.ai.gateway.error";
    symbol16 = Symbol.for(marker16);
    GatewayError = class _GatewayError extends (_b16 = Error, _a16 = symbol16, _b16) {
      constructor({
        message,
        statusCode = 500,
        cause,
        generationId
      }) {
        super(generationId ? `${message} [${generationId}]` : message);
        this[_a16] = true;
        this.statusCode = statusCode;
        this.cause = cause;
        this.generationId = generationId;
      }
      /**
       * Checks if the given error is a Gateway Error.
       * @param {unknown} error - The error to check.
       * @returns {boolean} True if the error is a Gateway Error, false otherwise.
       */
      static isInstance(error) {
        return _GatewayError.hasMarker(error);
      }
      static hasMarker(error) {
        return typeof error === "object" && error !== null && symbol16 in error && error[symbol16] === true;
      }
    };
    name15 = "GatewayAuthenticationError";
    marker22 = `vercel.ai.gateway.error.${name15}`;
    symbol22 = Symbol.for(marker22);
    GatewayAuthenticationError = class _GatewayAuthenticationError extends (_b22 = GatewayError, _a22 = symbol22, _b22) {
      constructor({
        message = "Authentication failed",
        statusCode = 401,
        cause,
        generationId
      } = {}) {
        super({ message, statusCode, cause, generationId });
        this[_a22] = true;
        this.name = name15;
        this.type = "authentication_error";
      }
      static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol22 in error;
      }
      /**
       * Creates a contextual error message when authentication fails
       */
      static createContextualError({
        apiKeyProvided,
        oidcTokenProvided,
        message = "Authentication failed",
        statusCode = 401,
        cause,
        generationId
      }) {
        let contextualMessage;
        if (apiKeyProvided) {
          contextualMessage = `AI Gateway authentication failed: Invalid API key.

Create a new API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys

Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
        } else if (oidcTokenProvided) {
          contextualMessage = `AI Gateway authentication failed: Invalid OIDC token.

Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.

Alternatively, use an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys`;
        } else {
          contextualMessage = `AI Gateway authentication failed: No authentication provided.

Option 1 - API key:
Create an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys
Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

Option 2 - OIDC token:
Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.`;
        }
        return new _GatewayAuthenticationError({
          message: contextualMessage,
          statusCode,
          cause,
          generationId
        });
      }
    };
    name22 = "GatewayInvalidRequestError";
    marker32 = `vercel.ai.gateway.error.${name22}`;
    symbol32 = Symbol.for(marker32);
    GatewayInvalidRequestError = class extends (_b32 = GatewayError, _a32 = symbol32, _b32) {
      constructor({
        message = "Invalid request",
        statusCode = 400,
        cause,
        generationId
      } = {}) {
        super({ message, statusCode, cause, generationId });
        this[_a32] = true;
        this.name = name22;
        this.type = "invalid_request_error";
      }
      static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol32 in error;
      }
    };
    name32 = "GatewayRateLimitError";
    marker42 = `vercel.ai.gateway.error.${name32}`;
    symbol42 = Symbol.for(marker42);
    GatewayRateLimitError = class extends (_b42 = GatewayError, _a42 = symbol42, _b42) {
      constructor({
        message = "Rate limit exceeded",
        statusCode = 429,
        cause,
        generationId
      } = {}) {
        super({ message, statusCode, cause, generationId });
        this[_a42] = true;
        this.name = name32;
        this.type = "rate_limit_exceeded";
      }
      static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol42 in error;
      }
    };
    name42 = "GatewayModelNotFoundError";
    marker52 = `vercel.ai.gateway.error.${name42}`;
    symbol52 = Symbol.for(marker52);
    modelNotFoundParamSchema = lazySchema(
      () => zodSchema(
        z16.object({
          modelId: z16.string()
        })
      )
    );
    GatewayModelNotFoundError = class extends (_b52 = GatewayError, _a52 = symbol52, _b52) {
      constructor({
        message = "Model not found",
        statusCode = 404,
        modelId,
        cause,
        generationId
      } = {}) {
        super({ message, statusCode, cause, generationId });
        this[_a52] = true;
        this.name = name42;
        this.type = "model_not_found";
        this.modelId = modelId;
      }
      static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol52 in error;
      }
    };
    name52 = "GatewayInternalServerError";
    marker62 = `vercel.ai.gateway.error.${name52}`;
    symbol62 = Symbol.for(marker62);
    GatewayInternalServerError = class extends (_b62 = GatewayError, _a62 = symbol62, _b62) {
      constructor({
        message = "Internal server error",
        statusCode = 500,
        cause,
        generationId
      } = {}) {
        super({ message, statusCode, cause, generationId });
        this[_a62] = true;
        this.name = name52;
        this.type = "internal_server_error";
      }
      static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol62 in error;
      }
    };
    name62 = "GatewayResponseError";
    marker72 = `vercel.ai.gateway.error.${name62}`;
    symbol72 = Symbol.for(marker72);
    GatewayResponseError = class extends (_b72 = GatewayError, _a72 = symbol72, _b72) {
      constructor({
        message = "Invalid response from Gateway",
        statusCode = 502,
        response,
        validationError,
        cause,
        generationId
      } = {}) {
        super({ message, statusCode, cause, generationId });
        this[_a72] = true;
        this.name = name62;
        this.type = "response_error";
        this.response = response;
        this.validationError = validationError;
      }
      static isInstance(error) {
        return GatewayError.hasMarker(error) && symbol72 in error;
      }
    };
    gatewayErrorResponseSchema = lazySchema(
      () => zodSchema(
        z22.object({
          error: z22.object({
            message: z22.string(),
            type: z22.string().nullish(),
            param: z22.unknown().nullish(),
            code: z22.union([z22.string(), z22.number()]).nullish()
          }),
          generationId: z22.string().nullish()
        })
      )
    );
    GATEWAY_AUTH_METHOD_HEADER = "ai-gateway-auth-method";
    gatewayAuthMethodSchema = lazySchema(
      () => zodSchema(z32.union([z32.literal("api-key"), z32.literal("oidc")]))
    );
    GatewayFetchMetadata = class {
      constructor(config2) {
        this.config = config2;
      }
      async getAvailableModels() {
        try {
          const { value: value2 } = await getFromApi({
            url: `${this.config.baseURL}/config`,
            headers: await resolve(this.config.headers()),
            successfulResponseHandler: createJsonResponseHandler(
              gatewayAvailableModelsResponseSchema
            ),
            failedResponseHandler: createJsonErrorResponseHandler({
              errorSchema: z43.any(),
              errorToMessage: (data) => data
            }),
            fetch: this.config.fetch
          });
          return value2;
        } catch (error) {
          throw await asGatewayError(error);
        }
      }
      async getCredits() {
        try {
          const baseUrl = new URL(this.config.baseURL);
          const { value: value2 } = await getFromApi({
            url: `${baseUrl.origin}/v1/credits`,
            headers: await resolve(this.config.headers()),
            successfulResponseHandler: createJsonResponseHandler(
              gatewayCreditsResponseSchema
            ),
            failedResponseHandler: createJsonErrorResponseHandler({
              errorSchema: z43.any(),
              errorToMessage: (data) => data
            }),
            fetch: this.config.fetch
          });
          return value2;
        } catch (error) {
          throw await asGatewayError(error);
        }
      }
    };
    gatewayAvailableModelsResponseSchema = lazySchema(
      () => zodSchema(
        z43.object({
          models: z43.array(
            z43.object({
              id: z43.string(),
              name: z43.string(),
              description: z43.string().nullish(),
              pricing: z43.object({
                input: z43.string(),
                output: z43.string(),
                input_cache_read: z43.string().nullish(),
                input_cache_write: z43.string().nullish()
              }).transform(
                ({ input, output, input_cache_read, input_cache_write }) => ({
                  input,
                  output,
                  ...input_cache_read ? { cachedInputTokens: input_cache_read } : {},
                  ...input_cache_write ? { cacheCreationInputTokens: input_cache_write } : {}
                })
              ).nullish(),
              specification: z43.object({
                specificationVersion: z43.literal("v3"),
                provider: z43.string(),
                modelId: z43.string()
              }),
              modelType: z43.enum(["embedding", "image", "language", "video"]).nullish()
            })
          )
        })
      )
    );
    gatewayCreditsResponseSchema = lazySchema(
      () => zodSchema(
        z43.object({
          balance: z43.string(),
          total_used: z43.string()
        }).transform(({ balance, total_used }) => ({
          balance,
          totalUsed: total_used
        }))
      )
    );
    GatewayLanguageModel = class {
      constructor(modelId, config2) {
        this.modelId = modelId;
        this.config = config2;
        this.specificationVersion = "v3";
        this.supportedUrls = { "*/*": [/.*/] };
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs(options) {
        const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;
        return {
          args: this.maybeEncodeFileParts(optionsWithoutSignal),
          warnings: []
        };
      }
      async doGenerate(options) {
        const { args: args2, warnings } = await this.getArgs(options);
        const { abortSignal } = options;
        const resolvedHeaders = await resolve(this.config.headers());
        try {
          const {
            responseHeaders,
            value: responseBody,
            rawValue: rawResponse
          } = await postJsonToApi({
            url: this.getUrl(),
            headers: combineHeaders(
              resolvedHeaders,
              options.headers,
              this.getModelConfigHeaders(this.modelId, false),
              await resolve(this.config.o11yHeaders)
            ),
            body: args2,
            successfulResponseHandler: createJsonResponseHandler(z52.any()),
            failedResponseHandler: createJsonErrorResponseHandler({
              errorSchema: z52.any(),
              errorToMessage: (data) => data
            }),
            ...abortSignal && { abortSignal },
            fetch: this.config.fetch
          });
          return {
            ...responseBody,
            request: { body: args2 },
            response: { headers: responseHeaders, body: rawResponse },
            warnings
          };
        } catch (error) {
          throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));
        }
      }
      async doStream(options) {
        const { args: args2, warnings } = await this.getArgs(options);
        const { abortSignal } = options;
        const resolvedHeaders = await resolve(this.config.headers());
        try {
          const { value: response, responseHeaders } = await postJsonToApi({
            url: this.getUrl(),
            headers: combineHeaders(
              resolvedHeaders,
              options.headers,
              this.getModelConfigHeaders(this.modelId, true),
              await resolve(this.config.o11yHeaders)
            ),
            body: args2,
            successfulResponseHandler: createEventSourceResponseHandler(z52.any()),
            failedResponseHandler: createJsonErrorResponseHandler({
              errorSchema: z52.any(),
              errorToMessage: (data) => data
            }),
            ...abortSignal && { abortSignal },
            fetch: this.config.fetch
          });
          return {
            stream: response.pipeThrough(
              new TransformStream({
                start(controller) {
                  if (warnings.length > 0) {
                    controller.enqueue({ type: "stream-start", warnings });
                  }
                },
                transform(chunk, controller) {
                  if (chunk.success) {
                    const streamPart = chunk.value;
                    if (streamPart.type === "raw" && !options.includeRawChunks) {
                      return;
                    }
                    if (streamPart.type === "response-metadata" && streamPart.timestamp && typeof streamPart.timestamp === "string") {
                      streamPart.timestamp = new Date(streamPart.timestamp);
                    }
                    controller.enqueue(streamPart);
                  } else {
                    controller.error(
                      chunk.error
                    );
                  }
                }
              })
            ),
            request: { body: args2 },
            response: { headers: responseHeaders }
          };
        } catch (error) {
          throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));
        }
      }
      isFilePart(part) {
        return part && typeof part === "object" && "type" in part && part.type === "file";
      }
      /**
       * Encodes file parts in the prompt to base64. Mutates the passed options
       * instance directly to avoid copying the file data.
       * @param options - The options to encode.
       * @returns The options with the file parts encoded.
       */
      maybeEncodeFileParts(options) {
        for (const message of options.prompt) {
          for (const part of message.content) {
            if (this.isFilePart(part)) {
              const filePart = part;
              if (filePart.data instanceof Uint8Array) {
                const buffer = Uint8Array.from(filePart.data);
                const base64Data = Buffer.from(buffer).toString("base64");
                filePart.data = new URL(
                  `data:${filePart.mediaType || "application/octet-stream"};base64,${base64Data}`
                );
              }
            }
          }
        }
        return options;
      }
      getUrl() {
        return `${this.config.baseURL}/language-model`;
      }
      getModelConfigHeaders(modelId, streaming) {
        return {
          "ai-language-model-specification-version": "3",
          "ai-language-model-id": modelId,
          "ai-language-model-streaming": String(streaming)
        };
      }
    };
    GatewayEmbeddingModel = class {
      constructor(modelId, config2) {
        this.modelId = modelId;
        this.config = config2;
        this.specificationVersion = "v3";
        this.maxEmbeddingsPerCall = 2048;
        this.supportsParallelCalls = true;
      }
      get provider() {
        return this.config.provider;
      }
      async doEmbed({
        values,
        headers,
        abortSignal,
        providerOptions
      }) {
        var _a84;
        const resolvedHeaders = await resolve(this.config.headers());
        try {
          const {
            responseHeaders,
            value: responseBody,
            rawValue
          } = await postJsonToApi({
            url: this.getUrl(),
            headers: combineHeaders(
              resolvedHeaders,
              headers != null ? headers : {},
              this.getModelConfigHeaders(),
              await resolve(this.config.o11yHeaders)
            ),
            body: {
              values,
              ...providerOptions ? { providerOptions } : {}
            },
            successfulResponseHandler: createJsonResponseHandler(
              gatewayEmbeddingResponseSchema
            ),
            failedResponseHandler: createJsonErrorResponseHandler({
              errorSchema: z62.any(),
              errorToMessage: (data) => data
            }),
            ...abortSignal && { abortSignal },
            fetch: this.config.fetch
          });
          return {
            embeddings: responseBody.embeddings,
            usage: (_a84 = responseBody.usage) != null ? _a84 : void 0,
            providerMetadata: responseBody.providerMetadata,
            response: { headers: responseHeaders, body: rawValue },
            warnings: []
          };
        } catch (error) {
          throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));
        }
      }
      getUrl() {
        return `${this.config.baseURL}/embedding-model`;
      }
      getModelConfigHeaders() {
        return {
          "ai-embedding-model-specification-version": "3",
          "ai-model-id": this.modelId
        };
      }
    };
    gatewayEmbeddingResponseSchema = lazySchema(
      () => zodSchema(
        z62.object({
          embeddings: z62.array(z62.array(z62.number())),
          usage: z62.object({ tokens: z62.number() }).nullish(),
          providerMetadata: z62.record(z62.string(), z62.record(z62.string(), z62.unknown())).optional()
        })
      )
    );
    GatewayImageModel = class {
      constructor(modelId, config2) {
        this.modelId = modelId;
        this.config = config2;
        this.specificationVersion = "v3";
        this.maxImagesPerCall = Number.MAX_SAFE_INTEGER;
      }
      get provider() {
        return this.config.provider;
      }
      async doGenerate({
        prompt,
        n,
        size,
        aspectRatio,
        seed,
        files,
        mask,
        providerOptions,
        headers,
        abortSignal
      }) {
        var _a84;
        const resolvedHeaders = await resolve(this.config.headers());
        try {
          const {
            responseHeaders,
            value: responseBody,
            rawValue
          } = await postJsonToApi({
            url: this.getUrl(),
            headers: combineHeaders(
              resolvedHeaders,
              headers != null ? headers : {},
              this.getModelConfigHeaders(),
              await resolve(this.config.o11yHeaders)
            ),
            body: {
              prompt,
              n,
              ...size && { size },
              ...aspectRatio && { aspectRatio },
              ...seed && { seed },
              ...providerOptions && { providerOptions },
              ...files && {
                files: files.map((file) => maybeEncodeImageFile(file))
              },
              ...mask && { mask: maybeEncodeImageFile(mask) }
            },
            successfulResponseHandler: createJsonResponseHandler(
              gatewayImageResponseSchema
            ),
            failedResponseHandler: createJsonErrorResponseHandler({
              errorSchema: z72.any(),
              errorToMessage: (data) => data
            }),
            ...abortSignal && { abortSignal },
            fetch: this.config.fetch
          });
          return {
            images: responseBody.images,
            // Always base64 strings from server
            warnings: (_a84 = responseBody.warnings) != null ? _a84 : [],
            providerMetadata: responseBody.providerMetadata,
            response: {
              timestamp: /* @__PURE__ */ new Date(),
              modelId: this.modelId,
              headers: responseHeaders
            }
          };
        } catch (error) {
          throw asGatewayError(error, await parseAuthMethod(resolvedHeaders));
        }
      }
      getUrl() {
        return `${this.config.baseURL}/image-model`;
      }
      getModelConfigHeaders() {
        return {
          "ai-image-model-specification-version": "3",
          "ai-model-id": this.modelId
        };
      }
    };
    providerMetadataEntrySchema = z72.object({
      images: z72.array(z72.unknown()).optional()
    }).catchall(z72.unknown());
    gatewayImageResponseSchema = z72.object({
      images: z72.array(z72.string()),
      // Always base64 strings over the wire
      warnings: z72.array(
        z72.object({
          type: z72.literal("other"),
          message: z72.string()
        })
      ).optional(),
      providerMetadata: z72.record(z72.string(), providerMetadataEntrySchema).optional()
    });
    GatewayVideoModel = class {
      constructor(modelId, config2) {
        this.modelId = modelId;
        this.config = config2;
        this.specificationVersion = "v3";
        this.maxVideosPerCall = Number.MAX_SAFE_INTEGER;
      }
      get provider() {
        return this.config.provider;
      }
      async doGenerate({
        prompt,
        n,
        aspectRatio,
        resolution,
        duration,
        fps,
        seed,
        image,
        providerOptions,
        headers,
        abortSignal
      }) {
        var _a84;
        const resolvedHeaders = await resolve(this.config.headers());
        try {
          const {
            responseHeaders,
            value: responseBody,
            rawValue
          } = await postJsonToApi({
            url: this.getUrl(),
            headers: combineHeaders(
              resolvedHeaders,
              headers != null ? headers : {},
              this.getModelConfigHeaders(),
              await resolve(this.config.o11yHeaders)
            ),
            body: {
              prompt,
              n,
              ...aspectRatio && { aspectRatio },
              ...resolution && { resolution },
              ...duration && { duration },
              ...fps && { fps },
              ...seed && { seed },
              ...providerOptions && { providerOptions },
              ...image && { image: maybeEncodeVideoFile(image) }
            },
            successfulResponseHandler: createJsonResponseHandler(
              gatewayVideoResponseSchema
            ),
            failedResponseHandler: createJsonErrorResponseHandler({
              errorSchema: z82.any(),
              errorToMessage: (data) => data
            }),
            ...abortSignal && { abortSignal },
            fetch: this.config.fetch
          });
          return {
            videos: responseBody.videos,
            warnings: (_a84 = responseBody.warnings) != null ? _a84 : [],
            providerMetadata: responseBody.providerMetadata,
            response: {
              timestamp: /* @__PURE__ */ new Date(),
              modelId: this.modelId,
              headers: responseHeaders
            }
          };
        } catch (error) {
          throw asGatewayError(error, await parseAuthMethod(resolvedHeaders));
        }
      }
      getUrl() {
        return `${this.config.baseURL}/video-model`;
      }
      getModelConfigHeaders() {
        return {
          "ai-video-model-specification-version": "3",
          "ai-model-id": this.modelId
        };
      }
    };
    providerMetadataEntrySchema2 = z82.object({
      videos: z82.array(z82.unknown()).optional()
    }).catchall(z82.unknown());
    gatewayVideoDataSchema = z82.union([
      z82.object({
        type: z82.literal("url"),
        url: z82.string(),
        mediaType: z82.string()
      }),
      z82.object({
        type: z82.literal("base64"),
        data: z82.string(),
        mediaType: z82.string()
      })
    ]);
    gatewayVideoResponseSchema = z82.object({
      videos: z82.array(gatewayVideoDataSchema),
      warnings: z82.array(
        z82.object({
          type: z82.literal("other"),
          message: z82.string()
        })
      ).optional(),
      providerMetadata: z82.record(z82.string(), providerMetadataEntrySchema2).optional()
    });
    parallelSearchInputSchema = lazySchema(
      () => zodSchema(
        z92.object({
          objective: z92.string().describe(
            "Natural-language description of the web research goal, including source or freshness guidance and broader context from the task. Maximum 5000 characters."
          ),
          search_queries: z92.array(z92.string()).optional().describe(
            "Optional search queries to supplement the objective. Maximum 200 characters per query."
          ),
          mode: z92.enum(["one-shot", "agentic"]).optional().describe(
            'Mode preset: "one-shot" for comprehensive results with longer excerpts (default), "agentic" for concise, token-efficient results for multi-step workflows.'
          ),
          max_results: z92.number().optional().describe(
            "Maximum number of results to return (1-20). Defaults to 10 if not specified."
          ),
          source_policy: z92.object({
            include_domains: z92.array(z92.string()).optional().describe("List of domains to include in search results."),
            exclude_domains: z92.array(z92.string()).optional().describe("List of domains to exclude from search results."),
            after_date: z92.string().optional().describe(
              "Only include results published after this date (ISO 8601 format)."
            )
          }).optional().describe(
            "Source policy for controlling which domains to include/exclude and freshness."
          ),
          excerpts: z92.object({
            max_chars_per_result: z92.number().optional().describe("Maximum characters per result."),
            max_chars_total: z92.number().optional().describe("Maximum total characters across all results.")
          }).optional().describe("Excerpt configuration for controlling result length."),
          fetch_policy: z92.object({
            max_age_seconds: z92.number().optional().describe(
              "Maximum age in seconds for cached content. Set to 0 to always fetch fresh content."
            )
          }).optional().describe("Fetch policy for controlling content freshness.")
        })
      )
    );
    parallelSearchOutputSchema = lazySchema(
      () => zodSchema(
        z92.union([
          // Success response
          z92.object({
            searchId: z92.string(),
            results: z92.array(
              z92.object({
                url: z92.string(),
                title: z92.string(),
                excerpt: z92.string(),
                publishDate: z92.string().nullable().optional(),
                relevanceScore: z92.number().optional()
              })
            )
          }),
          // Error response
          z92.object({
            error: z92.enum([
              "api_error",
              "rate_limit",
              "timeout",
              "invalid_input",
              "configuration_error",
              "unknown"
            ]),
            statusCode: z92.number().optional(),
            message: z92.string()
          })
        ])
      )
    );
    parallelSearchToolFactory = createProviderToolFactoryWithOutputSchema({
      id: "gateway.parallel_search",
      inputSchema: parallelSearchInputSchema,
      outputSchema: parallelSearchOutputSchema
    });
    parallelSearch = (config2 = {}) => parallelSearchToolFactory(config2);
    perplexitySearchInputSchema = lazySchema(
      () => zodSchema(
        z102.object({
          query: z102.union([z102.string(), z102.array(z102.string())]).describe(
            "Search query (string) or multiple queries (array of up to 5 strings). Multi-query searches return combined results from all queries."
          ),
          max_results: z102.number().optional().describe(
            "Maximum number of search results to return (1-20, default: 10)"
          ),
          max_tokens_per_page: z102.number().optional().describe(
            "Maximum number of tokens to extract per search result page (256-2048, default: 2048)"
          ),
          max_tokens: z102.number().optional().describe(
            "Maximum total tokens across all search results (default: 25000, max: 1000000)"
          ),
          country: z102.string().optional().describe(
            "Two-letter ISO 3166-1 alpha-2 country code for regional search results (e.g., 'US', 'GB', 'FR')"
          ),
          search_domain_filter: z102.array(z102.string()).optional().describe(
            "List of domains to include or exclude from search results (max 20). To include: ['nature.com', 'science.org']. To exclude: ['-example.com', '-spam.net']"
          ),
          search_language_filter: z102.array(z102.string()).optional().describe(
            "List of ISO 639-1 language codes to filter results (max 10, lowercase). Examples: ['en', 'fr', 'de']"
          ),
          search_after_date: z102.string().optional().describe(
            "Include only results published after this date. Format: 'MM/DD/YYYY' (e.g., '3/1/2025'). Cannot be used with search_recency_filter."
          ),
          search_before_date: z102.string().optional().describe(
            "Include only results published before this date. Format: 'MM/DD/YYYY' (e.g., '3/15/2025'). Cannot be used with search_recency_filter."
          ),
          last_updated_after_filter: z102.string().optional().describe(
            "Include only results last updated after this date. Format: 'MM/DD/YYYY' (e.g., '3/1/2025'). Cannot be used with search_recency_filter."
          ),
          last_updated_before_filter: z102.string().optional().describe(
            "Include only results last updated before this date. Format: 'MM/DD/YYYY' (e.g., '3/15/2025'). Cannot be used with search_recency_filter."
          ),
          search_recency_filter: z102.enum(["day", "week", "month", "year"]).optional().describe(
            "Filter results by relative time period. Cannot be used with search_after_date or search_before_date."
          )
        })
      )
    );
    perplexitySearchOutputSchema = lazySchema(
      () => zodSchema(
        z102.union([
          // Success response
          z102.object({
            results: z102.array(
              z102.object({
                title: z102.string(),
                url: z102.string(),
                snippet: z102.string(),
                date: z102.string().optional(),
                lastUpdated: z102.string().optional()
              })
            ),
            id: z102.string()
          }),
          // Error response
          z102.object({
            error: z102.enum([
              "api_error",
              "rate_limit",
              "timeout",
              "invalid_input",
              "unknown"
            ]),
            statusCode: z102.number().optional(),
            message: z102.string()
          })
        ])
      )
    );
    perplexitySearchToolFactory = createProviderToolFactoryWithOutputSchema({
      id: "gateway.perplexity_search",
      inputSchema: perplexitySearchInputSchema,
      outputSchema: perplexitySearchOutputSchema
    });
    perplexitySearch = (config2 = {}) => perplexitySearchToolFactory(config2);
    gatewayTools = {
      /**
       * Search the web using Parallel AI's Search API for LLM-optimized excerpts.
       *
       * Takes a natural language objective and returns relevant excerpts,
       * replacing multiple keyword searches with a single call for broad
       * or complex queries. Supports different search types for depth vs
       * breadth tradeoffs.
       */
      parallelSearch,
      /**
       * Search the web using Perplexity's Search API for real-time information,
       * news, research papers, and articles.
       *
       * Provides ranked search results with advanced filtering options including
       * domain, language, date range, and recency filters.
       */
      perplexitySearch
    };
    VERSION2 = true ? "3.0.35" : "0.0.0-test";
    AI_GATEWAY_PROTOCOL_VERSION = "0.0.1";
    gateway = createGatewayProvider();
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js
var _globalThis;
var init_globalThis = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js"() {
    _globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/node/index.js
var init_node = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/node/index.js"() {
    init_globalThis();
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/index.js
var init_platform = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/index.js"() {
    init_node();
  }
});

// node_modules/@opentelemetry/api/build/esm/version.js
var VERSION3;
var init_version = __esm({
  "node_modules/@opentelemetry/api/build/esm/version.js"() {
    VERSION3 = "1.9.0";
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/semver.js
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var re, isCompatible;
var init_semver = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/semver.js"() {
    init_version();
    re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    isCompatible = _makeCompatibilityCheck(VERSION3);
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
function registerGlobal(type2, instance, diag, allowOverride) {
  var _a25;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a25 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a25 !== void 0 ? _a25 : {
    version: VERSION3
  };
  if (!allowOverride && api[type2]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type2);
    diag.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION3) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type2 + " does not match previously registered API v" + VERSION3);
    diag.error(err.stack || err.message);
    return false;
  }
  api[type2] = instance;
  diag.debug("@opentelemetry/api: Registered a global for " + type2 + " v" + VERSION3 + ".");
  return true;
}
function getGlobal(type2) {
  var _a25, _b18;
  var globalVersion = (_a25 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a25 === void 0 ? void 0 : _a25.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b18 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b18 === void 0 ? void 0 : _b18[type2];
}
function unregisterGlobal(type2, diag) {
  diag.debug("@opentelemetry/api: Unregistering a global for " + type2 + " v" + VERSION3 + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type2];
  }
}
var major, GLOBAL_OPENTELEMETRY_API_KEY, _global;
var init_global_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/global-utils.js"() {
    init_platform();
    init_version();
    init_semver();
    major = VERSION3.split(".")[0];
    GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    _global = _globalThis;
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
function logProxy(funcName, namespace, args2) {
  var logger = getGlobal("diag");
  if (!logger) {
    return;
  }
  args2.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray([], __read(args2), false));
}
var __read, __spreadArray, DiagComponentLogger;
var init_ComponentLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js"() {
    init_global_utils();
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    DiagComponentLogger = /** @class */
    (function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      DiagComponentLogger2.prototype.debug = function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args2);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args2);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args2);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args2);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args2);
      };
      return DiagComponentLogger2;
    })();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
var init_types = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/types.js"() {
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var init_logLevelLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js"() {
    init_types();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2, __spreadArray2, API_NAME, DiagAPI;
var init_diag = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/diag.js"() {
    init_ComponentLogger();
    init_logLevelLogger();
    init_types();
    init_global_utils();
    __read2 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME = "diag";
    DiagAPI = /** @class */
    (function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args2 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args2[_i] = arguments[_i];
            }
            var logger = getGlobal("diag");
            if (!logger)
              return;
            return logger[funcName].apply(logger, __spreadArray2([], __read2(args2), false));
          };
        }
        var self = this;
        var setLogger = function(logger, optionsOrLogLevel) {
          var _a25, _b18, _c;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
          }
          if (logger === self) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self.error((_a25 = err.stack) !== null && _a25 !== void 0 ? _a25 : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger((_b18 = optionsOrLogLevel.logLevel) !== null && _b18 !== void 0 ? _b18 : DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function() {
          unregisterGlobal(API_NAME, self);
        };
        self.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy("verbose");
        self.debug = _logProxy("debug");
        self.info = _logProxy("info");
        self.warn = _logProxy("warn");
        self.error = _logProxy("error");
      }
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    })();
  }
});

// node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext, ROOT_CONTEXT;
var init_context = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/context.js"() {
    BaseContext = /** @class */
    /* @__PURE__ */ (function() {
      function BaseContext2(parentContext) {
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self.getValue = function(key) {
          return self._currentContext.get(key);
        };
        self.setValue = function(key, value2) {
          var context2 = new BaseContext2(self._currentContext);
          context2._currentContext.set(key, value2);
          return context2;
        };
        self.deleteValue = function(key) {
          var context2 = new BaseContext2(self._currentContext);
          context2._currentContext.delete(key);
          return context2;
        };
      }
      return BaseContext2;
    })();
    ROOT_CONTEXT = new BaseContext();
  }
});

// node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read3, __spreadArray3, NoopContextManager;
var init_NoopContextManager = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js"() {
    init_context();
    __read3 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    NoopContextManager = /** @class */
    (function() {
      function NoopContextManager2() {
      }
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args2 = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args2[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray3([thisArg], __read3(args2), false));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    })();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/context.js
var __read4, __spreadArray4, API_NAME2, NOOP_CONTEXT_MANAGER, ContextAPI;
var init_context2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/context.js"() {
    init_NoopContextManager();
    init_global_utils();
    init_diag();
    __read4 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME2 = "context";
    NOOP_CONTEXT_MANAGER = new NoopContextManager();
    ContextAPI = /** @class */
    (function() {
      function ContextAPI2() {
      }
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context2, fn, thisArg) {
        var _a25;
        var args2 = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args2[_i - 3] = arguments[_i];
        }
        return (_a25 = this._getContextManager()).with.apply(_a25, __spreadArray4([context2, fn, thisArg], __read4(args2), false));
      };
      ContextAPI2.prototype.bind = function(context2, target) {
        return this._getContextManager().bind(context2, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
      };
      return ContextAPI2;
    })();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
var init_trace_flags = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js"() {
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID, INVALID_TRACEID, INVALID_SPAN_CONTEXT;
var init_invalid_span_constants = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js"() {
    init_trace_flags();
    INVALID_SPANID = "0000000000000000";
    INVALID_TRACEID = "00000000000000000000000000000000";
    INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan;
var init_NonRecordingSpan = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js"() {
    init_invalid_span_constants();
    NonRecordingSpan = /** @class */
    (function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addLink = function(_link) {
        return this;
      };
      NonRecordingSpan2.prototype.addLinks = function(_links) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    })();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
function getSpan(context2) {
  return context2.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context2, span) {
  return context2.setValue(SPAN_KEY, span);
}
function deleteSpan(context2) {
  return context2.deleteValue(SPAN_KEY);
}
function setSpanContext(context2, spanContext) {
  return setSpan(context2, new NonRecordingSpan(spanContext));
}
function getSpanContext(context2) {
  var _a25;
  return (_a25 = getSpan(context2)) === null || _a25 === void 0 ? void 0 : _a25.spanContext();
}
var SPAN_KEY;
var init_context_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/context-utils.js"() {
    init_context();
    init_NonRecordingSpan();
    init_context2();
    SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var VALID_TRACEID_REGEX, VALID_SPANID_REGEX;
var init_spancontext_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js"() {
    init_invalid_span_constants();
    init_NonRecordingSpan();
    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var contextApi, NoopTracer;
var init_NoopTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js"() {
    init_context2();
    init_context_utils();
    init_NonRecordingSpan();
    init_spancontext_utils();
    contextApi = ContextAPI.getInstance();
    NoopTracer = /** @class */
    (function() {
      function NoopTracer2() {
      }
      NoopTracer2.prototype.startSpan = function(name25, options, context2) {
        if (context2 === void 0) {
          context2 = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context2 && getSpanContext(context2);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name25, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name25, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    })();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER, ProxyTracer;
var init_ProxyTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js"() {
    init_NoopTracer();
    NOOP_TRACER = new NoopTracer();
    ProxyTracer = /** @class */
    (function() {
      function ProxyTracer2(_provider, name25, version, options) {
        this._provider = _provider;
        this.name = name25;
        this.version = version;
        this.options = options;
      }
      ProxyTracer2.prototype.startSpan = function(name25, options, context2) {
        return this._getTracer().startSpan(name25, options, context2);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      };
      return ProxyTracer2;
    })();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider;
var init_NoopTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js"() {
    init_NoopTracer();
    NoopTracerProvider = /** @class */
    (function() {
      function NoopTracerProvider2() {
      }
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    })();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER, ProxyTracerProvider;
var init_ProxyTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js"() {
    init_ProxyTracer();
    init_NoopTracerProvider();
    NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    ProxyTracerProvider = /** @class */
    (function() {
      function ProxyTracerProvider2() {
      }
      ProxyTracerProvider2.prototype.getTracer = function(name25, version, options) {
        var _a25;
        return (_a25 = this.getDelegateTracer(name25, version, options)) !== null && _a25 !== void 0 ? _a25 : new ProxyTracer(this, name25, version, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a25;
        return (_a25 = this._delegate) !== null && _a25 !== void 0 ? _a25 : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name25, version, options) {
        var _a25;
        return (_a25 = this._delegate) === null || _a25 === void 0 ? void 0 : _a25.getTracer(name25, version, options);
      };
      return ProxyTracerProvider2;
    })();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
var init_status = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/status.js"() {
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
      SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
      SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/context-api.js
var context;
var init_context_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/context-api.js"() {
    init_context2();
    context = ContextAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME3, TraceAPI;
var init_trace = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/trace.js"() {
    init_global_utils();
    init_ProxyTracerProvider();
    init_spancontext_utils();
    init_context_utils();
    init_diag();
    API_NAME3 = "trace";
    TraceAPI = /** @class */
    (function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME3, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME3) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name25, version) {
        return this.getTracerProvider().getTracer(name25, version);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    })();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace;
var init_trace_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace-api.js"() {
    init_trace();
    trace = TraceAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/index.js
var init_esm = __esm({
  "node_modules/@opentelemetry/api/build/esm/index.js"() {
    init_status();
    init_context_api();
    init_trace_api();
  }
});

// node_modules/ai/dist/index.mjs
var dist_exports2 = {};
__export(dist_exports2, {
  AISDKError: () => AISDKError,
  APICallError: () => APICallError,
  AbstractChat: () => AbstractChat,
  DefaultChatTransport: () => DefaultChatTransport,
  DefaultGeneratedFile: () => DefaultGeneratedFile,
  DirectChatTransport: () => DirectChatTransport,
  DownloadError: () => DownloadError,
  EmptyResponseBodyError: () => EmptyResponseBodyError,
  Experimental_Agent: () => ToolLoopAgent,
  HttpChatTransport: () => HttpChatTransport,
  InvalidArgumentError: () => InvalidArgumentError3,
  InvalidDataContentError: () => InvalidDataContentError,
  InvalidMessageRoleError: () => InvalidMessageRoleError,
  InvalidPromptError: () => InvalidPromptError,
  InvalidResponseDataError: () => InvalidResponseDataError,
  InvalidStreamPartError: () => InvalidStreamPartError,
  InvalidToolApprovalError: () => InvalidToolApprovalError,
  InvalidToolInputError: () => InvalidToolInputError,
  JSONParseError: () => JSONParseError,
  JsonToSseTransformStream: () => JsonToSseTransformStream,
  LoadAPIKeyError: () => LoadAPIKeyError,
  LoadSettingError: () => LoadSettingError,
  MessageConversionError: () => MessageConversionError,
  MissingToolResultsError: () => MissingToolResultsError,
  NoContentGeneratedError: () => NoContentGeneratedError,
  NoImageGeneratedError: () => NoImageGeneratedError,
  NoObjectGeneratedError: () => NoObjectGeneratedError,
  NoOutputGeneratedError: () => NoOutputGeneratedError,
  NoSpeechGeneratedError: () => NoSpeechGeneratedError,
  NoSuchModelError: () => NoSuchModelError,
  NoSuchProviderError: () => NoSuchProviderError,
  NoSuchToolError: () => NoSuchToolError,
  NoTranscriptGeneratedError: () => NoTranscriptGeneratedError,
  NoVideoGeneratedError: () => NoVideoGeneratedError,
  Output: () => output_exports,
  RetryError: () => RetryError,
  SerialJobExecutor: () => SerialJobExecutor,
  TextStreamChatTransport: () => TextStreamChatTransport,
  TooManyEmbeddingValuesForCallError: () => TooManyEmbeddingValuesForCallError,
  ToolCallNotFoundForApprovalError: () => ToolCallNotFoundForApprovalError,
  ToolCallRepairError: () => ToolCallRepairError,
  ToolLoopAgent: () => ToolLoopAgent,
  TypeValidationError: () => TypeValidationError,
  UIMessageStreamError: () => UIMessageStreamError,
  UI_MESSAGE_STREAM_HEADERS: () => UI_MESSAGE_STREAM_HEADERS,
  UnsupportedFunctionalityError: () => UnsupportedFunctionalityError,
  UnsupportedModelVersionError: () => UnsupportedModelVersionError,
  addToolInputExamplesMiddleware: () => addToolInputExamplesMiddleware,
  asSchema: () => asSchema,
  assistantModelMessageSchema: () => assistantModelMessageSchema,
  callCompletionApi: () => callCompletionApi,
  consumeStream: () => consumeStream,
  convertFileListToFileUIParts: () => convertFileListToFileUIParts,
  convertToModelMessages: () => convertToModelMessages,
  cosineSimilarity: () => cosineSimilarity,
  createAgentUIStream: () => createAgentUIStream,
  createAgentUIStreamResponse: () => createAgentUIStreamResponse,
  createGateway: () => createGatewayProvider,
  createIdGenerator: () => createIdGenerator,
  createProviderRegistry: () => createProviderRegistry,
  createTextStreamResponse: () => createTextStreamResponse,
  createUIMessageStream: () => createUIMessageStream,
  createUIMessageStreamResponse: () => createUIMessageStreamResponse,
  customProvider: () => customProvider,
  defaultEmbeddingSettingsMiddleware: () => defaultEmbeddingSettingsMiddleware,
  defaultSettingsMiddleware: () => defaultSettingsMiddleware,
  dynamicTool: () => dynamicTool,
  embed: () => embed,
  embedMany: () => embedMany,
  experimental_createProviderRegistry: () => experimental_createProviderRegistry,
  experimental_customProvider: () => experimental_customProvider,
  experimental_generateImage: () => experimental_generateImage,
  experimental_generateSpeech: () => generateSpeech,
  experimental_generateVideo: () => experimental_generateVideo,
  experimental_transcribe: () => transcribe,
  extractJsonMiddleware: () => extractJsonMiddleware,
  extractReasoningMiddleware: () => extractReasoningMiddleware,
  gateway: () => gateway,
  generateId: () => generateId,
  generateImage: () => generateImage,
  generateObject: () => generateObject,
  generateText: () => generateText,
  getStaticToolName: () => getStaticToolName,
  getTextFromDataUrl: () => getTextFromDataUrl,
  getToolName: () => getToolName,
  getToolOrDynamicToolName: () => getToolOrDynamicToolName,
  hasToolCall: () => hasToolCall,
  isDataUIPart: () => isDataUIPart,
  isDeepEqualData: () => isDeepEqualData,
  isFileUIPart: () => isFileUIPart,
  isReasoningUIPart: () => isReasoningUIPart,
  isStaticToolUIPart: () => isStaticToolUIPart,
  isTextUIPart: () => isTextUIPart,
  isToolOrDynamicToolUIPart: () => isToolOrDynamicToolUIPart,
  isToolUIPart: () => isToolUIPart,
  jsonSchema: () => jsonSchema,
  lastAssistantMessageIsCompleteWithApprovalResponses: () => lastAssistantMessageIsCompleteWithApprovalResponses,
  lastAssistantMessageIsCompleteWithToolCalls: () => lastAssistantMessageIsCompleteWithToolCalls,
  modelMessageSchema: () => modelMessageSchema,
  parseJsonEventStream: () => parseJsonEventStream,
  parsePartialJson: () => parsePartialJson,
  pipeAgentUIStreamToResponse: () => pipeAgentUIStreamToResponse,
  pipeTextStreamToResponse: () => pipeTextStreamToResponse,
  pipeUIMessageStreamToResponse: () => pipeUIMessageStreamToResponse,
  pruneMessages: () => pruneMessages,
  readUIMessageStream: () => readUIMessageStream,
  rerank: () => rerank,
  safeValidateUIMessages: () => safeValidateUIMessages,
  simulateReadableStream: () => simulateReadableStream,
  simulateStreamingMiddleware: () => simulateStreamingMiddleware,
  smoothStream: () => smoothStream,
  stepCountIs: () => stepCountIs,
  streamObject: () => streamObject,
  streamText: () => streamText,
  systemModelMessageSchema: () => systemModelMessageSchema,
  tool: () => tool,
  toolModelMessageSchema: () => toolModelMessageSchema,
  uiMessageChunkSchema: () => uiMessageChunkSchema,
  userModelMessageSchema: () => userModelMessageSchema,
  validateUIMessages: () => validateUIMessages,
  wrapEmbeddingModel: () => wrapEmbeddingModel,
  wrapImageModel: () => wrapImageModel,
  wrapLanguageModel: () => wrapLanguageModel,
  wrapProvider: () => wrapProvider,
  zodSchema: () => zodSchema
});
import { z as z17 } from "zod/v4";
import { z as z63 } from "zod/v4";
import { z as z53 } from "zod/v4";
import { z as z33 } from "zod/v4";
import { z as z23 } from "zod/v4";
import { z as z44 } from "zod/v4";
import { z as z73 } from "zod/v4";
import { z as z83 } from "zod/v4";
function formatWarning({
  warning,
  provider,
  model
}) {
  const prefix = `AI SDK Warning (${provider} / ${model}):`;
  switch (warning.type) {
    case "unsupported": {
      let message = `${prefix} The feature "${warning.feature}" is not supported.`;
      if (warning.details) {
        message += ` ${warning.details}`;
      }
      return message;
    }
    case "compatibility": {
      let message = `${prefix} The feature "${warning.feature}" is used in a compatibility mode.`;
      if (warning.details) {
        message += ` ${warning.details}`;
      }
      return message;
    }
    case "other": {
      return `${prefix} ${warning.message}`;
    }
    default: {
      return `${prefix} ${JSON.stringify(warning, null, 2)}`;
    }
  }
}
function logV2CompatibilityWarning({
  provider,
  modelId
}) {
  logWarnings({
    warnings: [
      {
        type: "compatibility",
        feature: "specificationVersion",
        details: `Using v2 specification compatibility mode. Some features may not be available.`
      }
    ],
    provider,
    model: modelId
  });
}
function asEmbeddingModelV3(model) {
  if (model.specificationVersion === "v3") {
    return model;
  }
  logV2CompatibilityWarning({
    provider: model.provider,
    modelId: model.modelId
  });
  return new Proxy(model, {
    get(target, prop) {
      if (prop === "specificationVersion")
        return "v3";
      return target[prop];
    }
  });
}
function asImageModelV3(model) {
  if (model.specificationVersion === "v3") {
    return model;
  }
  logV2CompatibilityWarning({
    provider: model.provider,
    modelId: model.modelId
  });
  return new Proxy(model, {
    get(target, prop) {
      if (prop === "specificationVersion")
        return "v3";
      return target[prop];
    }
  });
}
function asLanguageModelV3(model) {
  if (model.specificationVersion === "v3") {
    return model;
  }
  logV2CompatibilityWarning({
    provider: model.provider,
    modelId: model.modelId
  });
  return new Proxy(model, {
    get(target, prop) {
      switch (prop) {
        case "specificationVersion":
          return "v3";
        case "doGenerate":
          return async (...args2) => {
            const result = await target.doGenerate(...args2);
            return {
              ...result,
              finishReason: convertV2FinishReasonToV3(result.finishReason),
              usage: convertV2UsageToV3(result.usage)
            };
          };
        case "doStream":
          return async (...args2) => {
            const result = await target.doStream(...args2);
            return {
              ...result,
              stream: convertV2StreamToV3(result.stream)
            };
          };
        default:
          return target[prop];
      }
    }
  });
}
function convertV2StreamToV3(stream) {
  return stream.pipeThrough(
    new TransformStream({
      transform(chunk, controller) {
        switch (chunk.type) {
          case "finish":
            controller.enqueue({
              ...chunk,
              finishReason: convertV2FinishReasonToV3(chunk.finishReason),
              usage: convertV2UsageToV3(chunk.usage)
            });
            break;
          default:
            controller.enqueue(chunk);
            break;
        }
      }
    })
  );
}
function convertV2FinishReasonToV3(finishReason) {
  return {
    unified: finishReason === "unknown" ? "other" : finishReason,
    raw: void 0
  };
}
function convertV2UsageToV3(usage) {
  return {
    inputTokens: {
      total: usage.inputTokens,
      noCache: void 0,
      cacheRead: usage.cachedInputTokens,
      cacheWrite: void 0
    },
    outputTokens: {
      total: usage.outputTokens,
      text: void 0,
      reasoning: usage.reasoningTokens
    }
  };
}
function asSpeechModelV3(model) {
  if (model.specificationVersion === "v3") {
    return model;
  }
  logV2CompatibilityWarning({
    provider: model.provider,
    modelId: model.modelId
  });
  return new Proxy(model, {
    get(target, prop) {
      if (prop === "specificationVersion")
        return "v3";
      return target[prop];
    }
  });
}
function asTranscriptionModelV3(model) {
  if (model.specificationVersion === "v3") {
    return model;
  }
  logV2CompatibilityWarning({
    provider: model.provider,
    modelId: model.modelId
  });
  return new Proxy(model, {
    get(target, prop) {
      if (prop === "specificationVersion")
        return "v3";
      return target[prop];
    }
  });
}
function resolveLanguageModel(model) {
  if (typeof model !== "string") {
    if (model.specificationVersion !== "v3" && model.specificationVersion !== "v2") {
      const unsupportedModel = model;
      throw new UnsupportedModelVersionError({
        version: unsupportedModel.specificationVersion,
        provider: unsupportedModel.provider,
        modelId: unsupportedModel.modelId
      });
    }
    return asLanguageModelV3(model);
  }
  return getGlobalProvider().languageModel(model);
}
function resolveEmbeddingModel(model) {
  if (typeof model !== "string") {
    if (model.specificationVersion !== "v3" && model.specificationVersion !== "v2") {
      const unsupportedModel = model;
      throw new UnsupportedModelVersionError({
        version: unsupportedModel.specificationVersion,
        provider: unsupportedModel.provider,
        modelId: unsupportedModel.modelId
      });
    }
    return asEmbeddingModelV3(model);
  }
  return getGlobalProvider().embeddingModel(model);
}
function resolveTranscriptionModel(model) {
  var _a212, _b18;
  if (typeof model !== "string") {
    if (model.specificationVersion !== "v3" && model.specificationVersion !== "v2") {
      const unsupportedModel = model;
      throw new UnsupportedModelVersionError({
        version: unsupportedModel.specificationVersion,
        provider: unsupportedModel.provider,
        modelId: unsupportedModel.modelId
      });
    }
    return asTranscriptionModelV3(model);
  }
  return (_b18 = (_a212 = getGlobalProvider()).transcriptionModel) == null ? void 0 : _b18.call(_a212, model);
}
function resolveSpeechModel(model) {
  var _a212, _b18;
  if (typeof model !== "string") {
    if (model.specificationVersion !== "v3" && model.specificationVersion !== "v2") {
      const unsupportedModel = model;
      throw new UnsupportedModelVersionError({
        version: unsupportedModel.specificationVersion,
        provider: unsupportedModel.provider,
        modelId: unsupportedModel.modelId
      });
    }
    return asSpeechModelV3(model);
  }
  return (_b18 = (_a212 = getGlobalProvider()).speechModel) == null ? void 0 : _b18.call(_a212, model);
}
function resolveImageModel(model) {
  if (typeof model !== "string") {
    if (model.specificationVersion !== "v3" && model.specificationVersion !== "v2") {
      const unsupportedModel = model;
      throw new UnsupportedModelVersionError({
        version: unsupportedModel.specificationVersion,
        provider: unsupportedModel.provider,
        modelId: unsupportedModel.modelId
      });
    }
    return asImageModelV3(model);
  }
  return getGlobalProvider().imageModel(model);
}
function resolveVideoModel(model) {
  if (typeof model === "string") {
    throw new Error(
      'Video models cannot be resolved from strings. Please use a Experimental_VideoModelV3 object from a provider (e.g., fal.video("model-id")).'
    );
  }
  if (model.specificationVersion !== "v3") {
    const unsupportedModel = model;
    throw new UnsupportedModelVersionError({
      version: unsupportedModel.specificationVersion,
      provider: unsupportedModel.provider,
      modelId: unsupportedModel.modelId
    });
  }
  return model;
}
function getGlobalProvider() {
  var _a212;
  return (_a212 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a212 : gateway;
}
function getTotalTimeoutMs(timeout) {
  if (timeout == null) {
    return void 0;
  }
  if (typeof timeout === "number") {
    return timeout;
  }
  return timeout.totalMs;
}
function getStepTimeoutMs(timeout) {
  if (timeout == null || typeof timeout === "number") {
    return void 0;
  }
  return timeout.stepMs;
}
function getChunkTimeoutMs(timeout) {
  if (timeout == null || typeof timeout === "number") {
    return void 0;
  }
  return timeout.chunkMs;
}
function stripID3TagsIfPresent(data) {
  const hasId3 = typeof data === "string" && data.startsWith("SUQz") || typeof data !== "string" && data.length > 10 && data[0] === 73 && // 'I'
  data[1] === 68 && // 'D'
  data[2] === 51;
  return hasId3 ? stripID3(data) : data;
}
function detectMediaType({
  data,
  signatures
}) {
  const processedData = stripID3TagsIfPresent(data);
  const bytes = typeof processedData === "string" ? convertBase64ToUint8Array(
    processedData.substring(0, Math.min(processedData.length, 24))
  ) : processedData;
  for (const signature of signatures) {
    if (bytes.length >= signature.bytesPrefix.length && signature.bytesPrefix.every(
      (byte, index) => byte === null || bytes[index] === byte
    )) {
      return signature.mediaType;
    }
  }
  return void 0;
}
function splitDataUrl(dataUrl) {
  try {
    const [header, base64Content] = dataUrl.split(",");
    return {
      mediaType: header.split(";")[0].split(":")[1],
      base64Content
    };
  } catch (error) {
    return {
      mediaType: void 0,
      base64Content: void 0
    };
  }
}
function convertToLanguageModelV3DataContent(content) {
  if (content instanceof Uint8Array) {
    return { data: content, mediaType: void 0 };
  }
  if (content instanceof ArrayBuffer) {
    return { data: new Uint8Array(content), mediaType: void 0 };
  }
  if (typeof content === "string") {
    try {
      content = new URL(content);
    } catch (error) {
    }
  }
  if (content instanceof URL && content.protocol === "data:") {
    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(
      content.toString()
    );
    if (dataUrlMediaType == null || base64Content == null) {
      throw new AISDKError({
        name: "InvalidDataContentError",
        message: `Invalid data URL format in content ${content.toString()}`
      });
    }
    return { data: base64Content, mediaType: dataUrlMediaType };
  }
  return { data: content, mediaType: void 0 };
}
function convertDataContentToBase64String(content) {
  if (typeof content === "string") {
    return content;
  }
  if (content instanceof ArrayBuffer) {
    return convertUint8ArrayToBase64(new Uint8Array(content));
  }
  return convertUint8ArrayToBase64(content);
}
function convertDataContentToUint8Array(content) {
  if (content instanceof Uint8Array) {
    return content;
  }
  if (typeof content === "string") {
    try {
      return convertBase64ToUint8Array(content);
    } catch (error) {
      throw new InvalidDataContentError({
        message: "Invalid data content. Content string is not a base64-encoded media.",
        content,
        cause: error
      });
    }
  }
  if (content instanceof ArrayBuffer) {
    return new Uint8Array(content);
  }
  throw new InvalidDataContentError({ content });
}
function asArray(value2) {
  return value2 === void 0 ? [] : Array.isArray(value2) ? value2 : [value2];
}
async function convertToLanguageModelPrompt({
  prompt,
  supportedUrls,
  download: download2 = createDefaultDownloadFunction()
}) {
  const downloadedAssets = await downloadAssets(
    prompt.messages,
    download2,
    supportedUrls
  );
  const approvalIdToToolCallId = /* @__PURE__ */ new Map();
  for (const message of prompt.messages) {
    if (message.role === "assistant" && Array.isArray(message.content)) {
      for (const part of message.content) {
        if (part.type === "tool-approval-request" && "approvalId" in part && "toolCallId" in part) {
          approvalIdToToolCallId.set(
            part.approvalId,
            part.toolCallId
          );
        }
      }
    }
  }
  const approvedToolCallIds = /* @__PURE__ */ new Set();
  for (const message of prompt.messages) {
    if (message.role === "tool") {
      for (const part of message.content) {
        if (part.type === "tool-approval-response") {
          const toolCallId = approvalIdToToolCallId.get(part.approvalId);
          if (toolCallId) {
            approvedToolCallIds.add(toolCallId);
          }
        }
      }
    }
  }
  const messages = [
    ...prompt.system != null ? typeof prompt.system === "string" ? [{ role: "system", content: prompt.system }] : asArray(prompt.system).map((message) => ({
      role: "system",
      content: message.content,
      providerOptions: message.providerOptions
    })) : [],
    ...prompt.messages.map(
      (message) => convertToLanguageModelMessage({ message, downloadedAssets })
    )
  ];
  const combinedMessages = [];
  for (const message of messages) {
    if (message.role !== "tool") {
      combinedMessages.push(message);
      continue;
    }
    const lastCombinedMessage = combinedMessages.at(-1);
    if ((lastCombinedMessage == null ? void 0 : lastCombinedMessage.role) === "tool") {
      lastCombinedMessage.content.push(...message.content);
    } else {
      combinedMessages.push(message);
    }
  }
  const toolCallIds = /* @__PURE__ */ new Set();
  for (const message of combinedMessages) {
    switch (message.role) {
      case "assistant": {
        for (const content of message.content) {
          if (content.type === "tool-call" && !content.providerExecuted) {
            toolCallIds.add(content.toolCallId);
          }
        }
        break;
      }
      case "tool": {
        for (const content of message.content) {
          if (content.type === "tool-result") {
            toolCallIds.delete(content.toolCallId);
          }
        }
        break;
      }
      case "user":
      case "system":
        for (const id of approvedToolCallIds) {
          toolCallIds.delete(id);
        }
        if (toolCallIds.size > 0) {
          throw new MissingToolResultsError({
            toolCallIds: Array.from(toolCallIds)
          });
        }
        break;
    }
  }
  for (const id of approvedToolCallIds) {
    toolCallIds.delete(id);
  }
  if (toolCallIds.size > 0) {
    throw new MissingToolResultsError({ toolCallIds: Array.from(toolCallIds) });
  }
  return combinedMessages.filter(
    // Filter out empty tool messages (e.g. if they only contained
    // tool-approval-response parts that were removed).
    // This prevents sending invalid empty messages to the provider.
    // Note: provider-executed tool-approval-response parts are preserved.
    (message) => message.role !== "tool" || message.content.length > 0
  );
}
function convertToLanguageModelMessage({
  message,
  downloadedAssets
}) {
  const role = message.role;
  switch (role) {
    case "system": {
      return {
        role: "system",
        content: message.content,
        providerOptions: message.providerOptions
      };
    }
    case "user": {
      if (typeof message.content === "string") {
        return {
          role: "user",
          content: [{ type: "text", text: message.content }],
          providerOptions: message.providerOptions
        };
      }
      return {
        role: "user",
        content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== "text" || part.text !== ""),
        providerOptions: message.providerOptions
      };
    }
    case "assistant": {
      if (typeof message.content === "string") {
        return {
          role: "assistant",
          content: [{ type: "text", text: message.content }],
          providerOptions: message.providerOptions
        };
      }
      return {
        role: "assistant",
        content: message.content.filter(
          // remove empty text parts (no text, and no provider options):
          (part) => part.type !== "text" || part.text !== "" || part.providerOptions != null
        ).filter(
          (part) => part.type !== "tool-approval-request"
        ).map((part) => {
          const providerOptions = part.providerOptions;
          switch (part.type) {
            case "file": {
              const { data, mediaType } = convertToLanguageModelV3DataContent(
                part.data
              );
              return {
                type: "file",
                data,
                filename: part.filename,
                mediaType: mediaType != null ? mediaType : part.mediaType,
                providerOptions
              };
            }
            case "reasoning": {
              return {
                type: "reasoning",
                text: part.text,
                providerOptions
              };
            }
            case "text": {
              return {
                type: "text",
                text: part.text,
                providerOptions
              };
            }
            case "tool-call": {
              return {
                type: "tool-call",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                input: part.input,
                providerExecuted: part.providerExecuted,
                providerOptions
              };
            }
            case "tool-result": {
              return {
                type: "tool-result",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                output: mapToolResultOutput(part.output),
                providerOptions
              };
            }
          }
        }),
        providerOptions: message.providerOptions
      };
    }
    case "tool": {
      return {
        role: "tool",
        content: message.content.filter(
          // Only include tool-approval-response for provider-executed tools
          (part) => part.type !== "tool-approval-response" || part.providerExecuted
        ).map((part) => {
          switch (part.type) {
            case "tool-result": {
              return {
                type: "tool-result",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                output: mapToolResultOutput(part.output),
                providerOptions: part.providerOptions
              };
            }
            case "tool-approval-response": {
              return {
                type: "tool-approval-response",
                approvalId: part.approvalId,
                approved: part.approved,
                reason: part.reason
              };
            }
          }
        }),
        providerOptions: message.providerOptions
      };
    }
    default: {
      const _exhaustiveCheck = role;
      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });
    }
  }
}
async function downloadAssets(messages, download2, supportedUrls) {
  const plannedDownloads = messages.filter((message) => message.role === "user").map((message) => message.content).filter(
    (content) => Array.isArray(content)
  ).flat().filter(
    (part) => part.type === "image" || part.type === "file"
  ).map((part) => {
    var _a212;
    const mediaType = (_a212 = part.mediaType) != null ? _a212 : part.type === "image" ? "image/*" : void 0;
    let data = part.type === "image" ? part.image : part.data;
    if (typeof data === "string") {
      try {
        data = new URL(data);
      } catch (ignored) {
      }
    }
    return { mediaType, data };
  }).filter(
    (part) => part.data instanceof URL
  ).map((part) => ({
    url: part.data,
    isUrlSupportedByModel: part.mediaType != null && isUrlSupported({
      url: part.data.toString(),
      mediaType: part.mediaType,
      supportedUrls
    })
  }));
  const downloadedFiles = await download2(plannedDownloads);
  return Object.fromEntries(
    downloadedFiles.map(
      (file, index) => file == null ? null : [
        plannedDownloads[index].url.toString(),
        { data: file.data, mediaType: file.mediaType }
      ]
    ).filter((file) => file != null)
  );
}
function convertPartToLanguageModelPart(part, downloadedAssets) {
  var _a212;
  if (part.type === "text") {
    return {
      type: "text",
      text: part.text,
      providerOptions: part.providerOptions
    };
  }
  let originalData;
  const type2 = part.type;
  switch (type2) {
    case "image":
      originalData = part.image;
      break;
    case "file":
      originalData = part.data;
      break;
    default:
      throw new Error(`Unsupported part type: ${type2}`);
  }
  const { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV3DataContent(originalData);
  let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;
  let data = convertedData;
  if (data instanceof URL) {
    const downloadedFile = downloadedAssets[data.toString()];
    if (downloadedFile) {
      data = downloadedFile.data;
      mediaType != null ? mediaType : mediaType = downloadedFile.mediaType;
    }
  }
  switch (type2) {
    case "image": {
      if (data instanceof Uint8Array || typeof data === "string") {
        mediaType = (_a212 = detectMediaType({ data, signatures: imageMediaTypeSignatures })) != null ? _a212 : mediaType;
      }
      return {
        type: "file",
        mediaType: mediaType != null ? mediaType : "image/*",
        // any image
        filename: void 0,
        data,
        providerOptions: part.providerOptions
      };
    }
    case "file": {
      if (mediaType == null) {
        throw new Error(`Media type is missing for file part`);
      }
      return {
        type: "file",
        mediaType,
        filename: part.filename,
        data,
        providerOptions: part.providerOptions
      };
    }
  }
}
function mapToolResultOutput(output) {
  if (output.type !== "content") {
    return output;
  }
  return {
    type: "content",
    value: output.value.map((item) => {
      if (item.type !== "media") {
        return item;
      }
      if (item.mediaType.startsWith("image/")) {
        return {
          type: "image-data",
          data: item.data,
          mediaType: item.mediaType
        };
      }
      return {
        type: "file-data",
        data: item.data,
        mediaType: item.mediaType
      };
    })
  };
}
async function createToolModelOutput({
  toolCallId,
  input,
  output,
  tool: tool2,
  errorMode
}) {
  if (errorMode === "text") {
    return { type: "error-text", value: getErrorMessage(output) };
  } else if (errorMode === "json") {
    return { type: "error-json", value: toJSONValue(output) };
  }
  if (tool2 == null ? void 0 : tool2.toModelOutput) {
    return await tool2.toModelOutput({ toolCallId, input, output });
  }
  return typeof output === "string" ? { type: "text", value: output } : { type: "json", value: toJSONValue(output) };
}
function toJSONValue(value2) {
  return value2 === void 0 ? null : value2;
}
function prepareCallSettings({
  maxOutputTokens,
  temperature,
  topP,
  topK,
  presencePenalty,
  frequencyPenalty,
  seed,
  stopSequences
}) {
  if (maxOutputTokens != null) {
    if (!Number.isInteger(maxOutputTokens)) {
      throw new InvalidArgumentError3({
        parameter: "maxOutputTokens",
        value: maxOutputTokens,
        message: "maxOutputTokens must be an integer"
      });
    }
    if (maxOutputTokens < 1) {
      throw new InvalidArgumentError3({
        parameter: "maxOutputTokens",
        value: maxOutputTokens,
        message: "maxOutputTokens must be >= 1"
      });
    }
  }
  if (temperature != null) {
    if (typeof temperature !== "number") {
      throw new InvalidArgumentError3({
        parameter: "temperature",
        value: temperature,
        message: "temperature must be a number"
      });
    }
  }
  if (topP != null) {
    if (typeof topP !== "number") {
      throw new InvalidArgumentError3({
        parameter: "topP",
        value: topP,
        message: "topP must be a number"
      });
    }
  }
  if (topK != null) {
    if (typeof topK !== "number") {
      throw new InvalidArgumentError3({
        parameter: "topK",
        value: topK,
        message: "topK must be a number"
      });
    }
  }
  if (presencePenalty != null) {
    if (typeof presencePenalty !== "number") {
      throw new InvalidArgumentError3({
        parameter: "presencePenalty",
        value: presencePenalty,
        message: "presencePenalty must be a number"
      });
    }
  }
  if (frequencyPenalty != null) {
    if (typeof frequencyPenalty !== "number") {
      throw new InvalidArgumentError3({
        parameter: "frequencyPenalty",
        value: frequencyPenalty,
        message: "frequencyPenalty must be a number"
      });
    }
  }
  if (seed != null) {
    if (!Number.isInteger(seed)) {
      throw new InvalidArgumentError3({
        parameter: "seed",
        value: seed,
        message: "seed must be an integer"
      });
    }
  }
  return {
    maxOutputTokens,
    temperature,
    topP,
    topK,
    presencePenalty,
    frequencyPenalty,
    stopSequences,
    seed
  };
}
function isNonEmptyObject(object2) {
  return object2 != null && Object.keys(object2).length > 0;
}
async function prepareToolsAndToolChoice({
  tools,
  toolChoice,
  activeTools
}) {
  if (!isNonEmptyObject(tools)) {
    return {
      tools: void 0,
      toolChoice: void 0
    };
  }
  const filteredTools = activeTools != null ? Object.entries(tools).filter(
    ([name212]) => activeTools.includes(name212)
  ) : Object.entries(tools);
  const languageModelTools = [];
  for (const [name212, tool2] of filteredTools) {
    const toolType = tool2.type;
    switch (toolType) {
      case void 0:
      case "dynamic":
      case "function":
        languageModelTools.push({
          type: "function",
          name: name212,
          description: tool2.description,
          inputSchema: await asSchema(tool2.inputSchema).jsonSchema,
          ...tool2.inputExamples != null ? { inputExamples: tool2.inputExamples } : {},
          providerOptions: tool2.providerOptions,
          ...tool2.strict != null ? { strict: tool2.strict } : {}
        });
        break;
      case "provider":
        languageModelTools.push({
          type: "provider",
          name: name212,
          id: tool2.id,
          args: tool2.args
        });
        break;
      default: {
        const exhaustiveCheck = toolType;
        throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);
      }
    }
  }
  return {
    tools: languageModelTools,
    toolChoice: toolChoice == null ? { type: "auto" } : typeof toolChoice === "string" ? { type: toolChoice } : { type: "tool", toolName: toolChoice.toolName }
  };
}
async function standardizePrompt(prompt) {
  if (prompt.prompt == null && prompt.messages == null) {
    throw new InvalidPromptError({
      prompt,
      message: "prompt or messages must be defined"
    });
  }
  if (prompt.prompt != null && prompt.messages != null) {
    throw new InvalidPromptError({
      prompt,
      message: "prompt and messages cannot be defined at the same time"
    });
  }
  if (prompt.system != null && typeof prompt.system !== "string" && !asArray(prompt.system).every(
    (message) => typeof message === "object" && message !== null && "role" in message && message.role === "system"
  )) {
    throw new InvalidPromptError({
      prompt,
      message: "system must be a string, SystemModelMessage, or array of SystemModelMessage"
    });
  }
  let messages;
  if (prompt.prompt != null && typeof prompt.prompt === "string") {
    messages = [{ role: "user", content: prompt.prompt }];
  } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {
    messages = prompt.prompt;
  } else if (prompt.messages != null) {
    messages = prompt.messages;
  } else {
    throw new InvalidPromptError({
      prompt,
      message: "prompt or messages must be defined"
    });
  }
  if (messages.length === 0) {
    throw new InvalidPromptError({
      prompt,
      message: "messages must not be empty"
    });
  }
  const validationResult = await safeValidateTypes({
    value: messages,
    schema: z63.array(modelMessageSchema)
  });
  if (!validationResult.success) {
    throw new InvalidPromptError({
      prompt,
      message: "The messages do not match the ModelMessage[] schema.",
      cause: validationResult.error
    });
  }
  return {
    messages,
    system: prompt.system
  };
}
function wrapGatewayError(error) {
  if (!GatewayAuthenticationError.isInstance(error))
    return error;
  const isProductionEnv = (process == null ? void 0 : process.env.NODE_ENV) === "production";
  const moreInfoURL = "https://ai-sdk.dev/unauthenticated-ai-gateway";
  if (isProductionEnv) {
    return new AISDKError({
      name: "GatewayError",
      message: `Unauthenticated. Configure AI_GATEWAY_API_KEY or use a provider module. Learn more: ${moreInfoURL}`
    });
  }
  return Object.assign(
    new Error(`\x1B[1m\x1B[31mUnauthenticated request to AI Gateway.\x1B[0m

To authenticate, set the \x1B[33mAI_GATEWAY_API_KEY\x1B[0m environment variable with your API key.

Alternatively, you can use a provider module instead of the AI Gateway.

Learn more: \x1B[34m${moreInfoURL}\x1B[0m

`),
    { name: "GatewayAuthenticationError" }
  );
}
function assembleOperationName({
  operationId,
  telemetry: telemetry2
}) {
  return {
    // standardized operation and resource name:
    "operation.name": `${operationId}${(telemetry2 == null ? void 0 : telemetry2.functionId) != null ? ` ${telemetry2.functionId}` : ""}`,
    "resource.name": telemetry2 == null ? void 0 : telemetry2.functionId,
    // detailed, AI SDK specific data:
    "ai.operationId": operationId,
    "ai.telemetry.functionId": telemetry2 == null ? void 0 : telemetry2.functionId
  };
}
function getBaseTelemetryAttributes({
  model,
  settings,
  telemetry: telemetry2,
  headers
}) {
  var _a212;
  return {
    "ai.model.provider": model.provider,
    "ai.model.id": model.modelId,
    // settings:
    ...Object.entries(settings).reduce((attributes, [key, value2]) => {
      if (key === "timeout") {
        const totalTimeoutMs = getTotalTimeoutMs(
          value2
        );
        if (totalTimeoutMs != null) {
          attributes[`ai.settings.${key}`] = totalTimeoutMs;
        }
      } else {
        attributes[`ai.settings.${key}`] = value2;
      }
      return attributes;
    }, {}),
    // add metadata as attributes:
    ...Object.entries((_a212 = telemetry2 == null ? void 0 : telemetry2.metadata) != null ? _a212 : {}).reduce(
      (attributes, [key, value2]) => {
        attributes[`ai.telemetry.metadata.${key}`] = value2;
        return attributes;
      },
      {}
    ),
    // request headers
    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value2]) => {
      if (value2 !== void 0) {
        attributes[`ai.request.headers.${key}`] = value2;
      }
      return attributes;
    }, {})
  };
}
function getTracer({
  isEnabled = false,
  tracer
} = {}) {
  if (!isEnabled) {
    return noopTracer;
  }
  if (tracer) {
    return tracer;
  }
  return trace.getTracer("ai");
}
async function recordSpan({
  name: name212,
  tracer,
  attributes,
  fn,
  endWhenDone = true
}) {
  return tracer.startActiveSpan(
    name212,
    { attributes: await attributes },
    async (span) => {
      const ctx = context.active();
      try {
        const result = await context.with(ctx, () => fn(span));
        if (endWhenDone) {
          span.end();
        }
        return result;
      } catch (error) {
        try {
          recordErrorOnSpan(span, error);
        } finally {
          span.end();
        }
        throw error;
      }
    }
  );
}
function recordErrorOnSpan(span, error) {
  if (error instanceof Error) {
    span.recordException({
      name: error.name,
      message: error.message,
      stack: error.stack
    });
    span.setStatus({
      code: SpanStatusCode.ERROR,
      message: error.message
    });
  } else {
    span.setStatus({ code: SpanStatusCode.ERROR });
  }
}
async function selectTelemetryAttributes({
  telemetry: telemetry2,
  attributes
}) {
  if ((telemetry2 == null ? void 0 : telemetry2.isEnabled) !== true) {
    return {};
  }
  const resultAttributes = {};
  for (const [key, value2] of Object.entries(attributes)) {
    if (value2 == null) {
      continue;
    }
    if (typeof value2 === "object" && "input" in value2 && typeof value2.input === "function") {
      if ((telemetry2 == null ? void 0 : telemetry2.recordInputs) === false) {
        continue;
      }
      const result = await value2.input();
      if (result != null) {
        resultAttributes[key] = result;
      }
      continue;
    }
    if (typeof value2 === "object" && "output" in value2 && typeof value2.output === "function") {
      if ((telemetry2 == null ? void 0 : telemetry2.recordOutputs) === false) {
        continue;
      }
      const result = await value2.output();
      if (result != null) {
        resultAttributes[key] = result;
      }
      continue;
    }
    resultAttributes[key] = value2;
  }
  return resultAttributes;
}
function stringifyForTelemetry(prompt) {
  return JSON.stringify(
    prompt.map((message) => ({
      ...message,
      content: typeof message.content === "string" ? message.content : message.content.map(
        (part) => part.type === "file" ? {
          ...part,
          data: part.data instanceof Uint8Array ? convertDataContentToBase64String(part.data) : part.data
        } : part
      )
    }))
  );
}
function asLanguageModelUsage(usage) {
  return {
    inputTokens: usage.inputTokens.total,
    inputTokenDetails: {
      noCacheTokens: usage.inputTokens.noCache,
      cacheReadTokens: usage.inputTokens.cacheRead,
      cacheWriteTokens: usage.inputTokens.cacheWrite
    },
    outputTokens: usage.outputTokens.total,
    outputTokenDetails: {
      textTokens: usage.outputTokens.text,
      reasoningTokens: usage.outputTokens.reasoning
    },
    totalTokens: addTokenCounts(
      usage.inputTokens.total,
      usage.outputTokens.total
    ),
    raw: usage.raw,
    reasoningTokens: usage.outputTokens.reasoning,
    cachedInputTokens: usage.inputTokens.cacheRead
  };
}
function createNullLanguageModelUsage() {
  return {
    inputTokens: void 0,
    inputTokenDetails: {
      noCacheTokens: void 0,
      cacheReadTokens: void 0,
      cacheWriteTokens: void 0
    },
    outputTokens: void 0,
    outputTokenDetails: {
      textTokens: void 0,
      reasoningTokens: void 0
    },
    totalTokens: void 0,
    raw: void 0
  };
}
function addLanguageModelUsage(usage1, usage2) {
  var _a212, _b18, _c, _d, _e, _f, _g, _h, _i, _j;
  return {
    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),
    inputTokenDetails: {
      noCacheTokens: addTokenCounts(
        (_a212 = usage1.inputTokenDetails) == null ? void 0 : _a212.noCacheTokens,
        (_b18 = usage2.inputTokenDetails) == null ? void 0 : _b18.noCacheTokens
      ),
      cacheReadTokens: addTokenCounts(
        (_c = usage1.inputTokenDetails) == null ? void 0 : _c.cacheReadTokens,
        (_d = usage2.inputTokenDetails) == null ? void 0 : _d.cacheReadTokens
      ),
      cacheWriteTokens: addTokenCounts(
        (_e = usage1.inputTokenDetails) == null ? void 0 : _e.cacheWriteTokens,
        (_f = usage2.inputTokenDetails) == null ? void 0 : _f.cacheWriteTokens
      )
    },
    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),
    outputTokenDetails: {
      textTokens: addTokenCounts(
        (_g = usage1.outputTokenDetails) == null ? void 0 : _g.textTokens,
        (_h = usage2.outputTokenDetails) == null ? void 0 : _h.textTokens
      ),
      reasoningTokens: addTokenCounts(
        (_i = usage1.outputTokenDetails) == null ? void 0 : _i.reasoningTokens,
        (_j = usage2.outputTokenDetails) == null ? void 0 : _j.reasoningTokens
      )
    },
    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),
    reasoningTokens: addTokenCounts(
      usage1.reasoningTokens,
      usage2.reasoningTokens
    ),
    cachedInputTokens: addTokenCounts(
      usage1.cachedInputTokens,
      usage2.cachedInputTokens
    )
  };
}
function addTokenCounts(tokenCount1, tokenCount2) {
  return tokenCount1 == null && tokenCount2 == null ? void 0 : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);
}
function addImageModelUsage(usage1, usage2) {
  return {
    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),
    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),
    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens)
  };
}
function mergeObjects(base, overrides) {
  if (base === void 0 && overrides === void 0) {
    return void 0;
  }
  if (base === void 0) {
    return overrides;
  }
  if (overrides === void 0) {
    return base;
  }
  const result = { ...base };
  for (const key in overrides) {
    if (Object.prototype.hasOwnProperty.call(overrides, key)) {
      const overridesValue = overrides[key];
      if (overridesValue === void 0)
        continue;
      const baseValue = key in base ? base[key] : void 0;
      const isSourceObject = overridesValue !== null && typeof overridesValue === "object" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);
      const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === "object" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);
      if (isSourceObject && isTargetObject) {
        result[key] = mergeObjects(
          baseValue,
          overridesValue
        );
      } else {
        result[key] = overridesValue;
      }
    }
  }
  return result;
}
function getRetryDelayInMs({
  error,
  exponentialBackoffDelay
}) {
  const headers = error.responseHeaders;
  if (!headers)
    return exponentialBackoffDelay;
  let ms;
  const retryAfterMs = headers["retry-after-ms"];
  if (retryAfterMs) {
    const timeoutMs = parseFloat(retryAfterMs);
    if (!Number.isNaN(timeoutMs)) {
      ms = timeoutMs;
    }
  }
  const retryAfter = headers["retry-after"];
  if (retryAfter && ms === void 0) {
    const timeoutSeconds = parseFloat(retryAfter);
    if (!Number.isNaN(timeoutSeconds)) {
      ms = timeoutSeconds * 1e3;
    } else {
      ms = Date.parse(retryAfter) - Date.now();
    }
  }
  if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {
    return ms;
  }
  return exponentialBackoffDelay;
}
async function _retryWithExponentialBackoff(f, {
  maxRetries,
  delayInMs,
  backoffFactor,
  abortSignal
}, errors = []) {
  try {
    return await f();
  } catch (error) {
    if (isAbortError(error)) {
      throw error;
    }
    if (maxRetries === 0) {
      throw error;
    }
    const errorMessage = getErrorMessage2(error);
    const newErrors = [...errors, error];
    const tryNumber = newErrors.length;
    if (tryNumber > maxRetries) {
      throw new RetryError({
        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
        reason: "maxRetriesExceeded",
        errors: newErrors
      });
    }
    if (error instanceof Error && APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {
      await delay(
        getRetryDelayInMs({
          error,
          exponentialBackoffDelay: delayInMs
        }),
        { abortSignal }
      );
      return _retryWithExponentialBackoff(
        f,
        {
          maxRetries,
          delayInMs: backoffFactor * delayInMs,
          backoffFactor,
          abortSignal
        },
        newErrors
      );
    }
    if (tryNumber === 1) {
      throw error;
    }
    throw new RetryError({
      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
      reason: "errorNotRetryable",
      errors: newErrors
    });
  }
}
function prepareRetries({
  maxRetries,
  abortSignal
}) {
  if (maxRetries != null) {
    if (!Number.isInteger(maxRetries)) {
      throw new InvalidArgumentError3({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be an integer"
      });
    }
    if (maxRetries < 0) {
      throw new InvalidArgumentError3({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be >= 0"
      });
    }
  }
  const maxRetriesResult = maxRetries != null ? maxRetries : 2;
  return {
    maxRetries: maxRetriesResult,
    retry: retryWithExponentialBackoffRespectingRetryHeaders({
      maxRetries: maxRetriesResult,
      abortSignal
    })
  };
}
function collectToolApprovals({
  messages
}) {
  const lastMessage = messages.at(-1);
  if ((lastMessage == null ? void 0 : lastMessage.role) != "tool") {
    return {
      approvedToolApprovals: [],
      deniedToolApprovals: []
    };
  }
  const toolCallsByToolCallId = {};
  for (const message of messages) {
    if (message.role === "assistant" && typeof message.content !== "string") {
      const content = message.content;
      for (const part of content) {
        if (part.type === "tool-call") {
          toolCallsByToolCallId[part.toolCallId] = part;
        }
      }
    }
  }
  const toolApprovalRequestsByApprovalId = {};
  for (const message of messages) {
    if (message.role === "assistant" && typeof message.content !== "string") {
      const content = message.content;
      for (const part of content) {
        if (part.type === "tool-approval-request") {
          toolApprovalRequestsByApprovalId[part.approvalId] = part;
        }
      }
    }
  }
  const toolResults = {};
  for (const part of lastMessage.content) {
    if (part.type === "tool-result") {
      toolResults[part.toolCallId] = part;
    }
  }
  const approvedToolApprovals = [];
  const deniedToolApprovals = [];
  const approvalResponses = lastMessage.content.filter(
    (part) => part.type === "tool-approval-response"
  );
  for (const approvalResponse of approvalResponses) {
    const approvalRequest = toolApprovalRequestsByApprovalId[approvalResponse.approvalId];
    if (approvalRequest == null) {
      throw new InvalidToolApprovalError({
        approvalId: approvalResponse.approvalId
      });
    }
    if (toolResults[approvalRequest.toolCallId] != null) {
      continue;
    }
    const toolCall = toolCallsByToolCallId[approvalRequest.toolCallId];
    if (toolCall == null) {
      throw new ToolCallNotFoundForApprovalError({
        toolCallId: approvalRequest.toolCallId,
        approvalId: approvalRequest.approvalId
      });
    }
    const approval = {
      approvalRequest,
      approvalResponse,
      toolCall
    };
    if (approvalResponse.approved) {
      approvedToolApprovals.push(approval);
    } else {
      deniedToolApprovals.push(approval);
    }
  }
  return { approvedToolApprovals, deniedToolApprovals };
}
async function executeToolCall({
  toolCall,
  tools,
  tracer,
  telemetry: telemetry2,
  messages,
  abortSignal,
  experimental_context,
  onPreliminaryToolResult
}) {
  const { toolName, toolCallId, input } = toolCall;
  const tool2 = tools == null ? void 0 : tools[toolName];
  if ((tool2 == null ? void 0 : tool2.execute) == null) {
    return void 0;
  }
  return recordSpan({
    name: "ai.toolCall",
    attributes: selectTelemetryAttributes({
      telemetry: telemetry2,
      attributes: {
        ...assembleOperationName({
          operationId: "ai.toolCall",
          telemetry: telemetry2
        }),
        "ai.toolCall.name": toolName,
        "ai.toolCall.id": toolCallId,
        "ai.toolCall.args": {
          output: () => JSON.stringify(input)
        }
      }
    }),
    tracer,
    fn: async (span) => {
      let output;
      try {
        const stream = executeTool({
          execute: tool2.execute.bind(tool2),
          input,
          options: {
            toolCallId,
            messages,
            abortSignal,
            experimental_context
          }
        });
        for await (const part of stream) {
          if (part.type === "preliminary") {
            onPreliminaryToolResult == null ? void 0 : onPreliminaryToolResult({
              ...toolCall,
              type: "tool-result",
              output: part.output,
              preliminary: true
            });
          } else {
            output = part.output;
          }
        }
      } catch (error) {
        recordErrorOnSpan(span, error);
        return {
          type: "tool-error",
          toolCallId,
          toolName,
          input,
          error,
          dynamic: tool2.type === "dynamic",
          ...toolCall.providerMetadata != null ? { providerMetadata: toolCall.providerMetadata } : {}
        };
      }
      try {
        span.setAttributes(
          await selectTelemetryAttributes({
            telemetry: telemetry2,
            attributes: {
              "ai.toolCall.result": {
                output: () => JSON.stringify(output)
              }
            }
          })
        );
      } catch (ignored) {
      }
      return {
        type: "tool-result",
        toolCallId,
        toolName,
        input,
        output,
        dynamic: tool2.type === "dynamic",
        ...toolCall.providerMetadata != null ? { providerMetadata: toolCall.providerMetadata } : {}
      };
    }
  });
}
function extractTextContent(content) {
  const parts = content.filter(
    (content2) => content2.type === "text"
  );
  if (parts.length === 0) {
    return void 0;
  }
  return parts.map((content2) => content2.text).join("");
}
async function isApprovalNeeded({
  tool: tool2,
  toolCall,
  messages,
  experimental_context
}) {
  if (tool2.needsApproval == null) {
    return false;
  }
  if (typeof tool2.needsApproval === "boolean") {
    return tool2.needsApproval;
  }
  return await tool2.needsApproval(toolCall.input, {
    toolCallId: toolCall.toolCallId,
    messages,
    experimental_context
  });
}
function fixJson(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
async function parsePartialJson(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = await safeParseJSON({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = await safeParseJSON({ text: fixJson(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
async function parseToolCall({
  toolCall,
  tools,
  repairToolCall,
  system,
  messages
}) {
  var _a212;
  try {
    if (tools == null) {
      if (toolCall.providerExecuted && toolCall.dynamic) {
        return await parseProviderExecutedDynamicToolCall(toolCall);
      }
      throw new NoSuchToolError({ toolName: toolCall.toolName });
    }
    try {
      return await doParseToolCall({ toolCall, tools });
    } catch (error) {
      if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolInputError.isInstance(error))) {
        throw error;
      }
      let repairedToolCall = null;
      try {
        repairedToolCall = await repairToolCall({
          toolCall,
          tools,
          inputSchema: async ({ toolName }) => {
            const { inputSchema } = tools[toolName];
            return await asSchema(inputSchema).jsonSchema;
          },
          system,
          messages,
          error
        });
      } catch (repairError) {
        throw new ToolCallRepairError({
          cause: repairError,
          originalError: error
        });
      }
      if (repairedToolCall == null) {
        throw error;
      }
      return await doParseToolCall({ toolCall: repairedToolCall, tools });
    }
  } catch (error) {
    const parsedInput = await safeParseJSON({ text: toolCall.input });
    const input = parsedInput.success ? parsedInput.value : toolCall.input;
    return {
      type: "tool-call",
      toolCallId: toolCall.toolCallId,
      toolName: toolCall.toolName,
      input,
      dynamic: true,
      invalid: true,
      error,
      title: (_a212 = tools == null ? void 0 : tools[toolCall.toolName]) == null ? void 0 : _a212.title,
      providerExecuted: toolCall.providerExecuted,
      providerMetadata: toolCall.providerMetadata
    };
  }
}
async function parseProviderExecutedDynamicToolCall(toolCall) {
  const parseResult = toolCall.input.trim() === "" ? { success: true, value: {} } : await safeParseJSON({ text: toolCall.input });
  if (parseResult.success === false) {
    throw new InvalidToolInputError({
      toolName: toolCall.toolName,
      toolInput: toolCall.input,
      cause: parseResult.error
    });
  }
  return {
    type: "tool-call",
    toolCallId: toolCall.toolCallId,
    toolName: toolCall.toolName,
    input: parseResult.value,
    providerExecuted: true,
    dynamic: true,
    providerMetadata: toolCall.providerMetadata
  };
}
async function doParseToolCall({
  toolCall,
  tools
}) {
  const toolName = toolCall.toolName;
  const tool2 = tools[toolName];
  if (tool2 == null) {
    if (toolCall.providerExecuted && toolCall.dynamic) {
      return await parseProviderExecutedDynamicToolCall(toolCall);
    }
    throw new NoSuchToolError({
      toolName: toolCall.toolName,
      availableTools: Object.keys(tools)
    });
  }
  const schema = asSchema(tool2.inputSchema);
  const parseResult = toolCall.input.trim() === "" ? await safeValidateTypes({ value: {}, schema }) : await safeParseJSON({ text: toolCall.input, schema });
  if (parseResult.success === false) {
    throw new InvalidToolInputError({
      toolName,
      toolInput: toolCall.input,
      cause: parseResult.error
    });
  }
  return tool2.type === "dynamic" ? {
    type: "tool-call",
    toolCallId: toolCall.toolCallId,
    toolName: toolCall.toolName,
    input: parseResult.value,
    providerExecuted: toolCall.providerExecuted,
    providerMetadata: toolCall.providerMetadata,
    dynamic: true,
    title: tool2.title
  } : {
    type: "tool-call",
    toolCallId: toolCall.toolCallId,
    toolName,
    input: parseResult.value,
    providerExecuted: toolCall.providerExecuted,
    providerMetadata: toolCall.providerMetadata,
    title: tool2.title
  };
}
function stepCountIs(stepCount) {
  return ({ steps }) => steps.length === stepCount;
}
function hasToolCall(toolName) {
  return ({ steps }) => {
    var _a212, _b18, _c;
    return (_c = (_b18 = (_a212 = steps[steps.length - 1]) == null ? void 0 : _a212.toolCalls) == null ? void 0 : _b18.some(
      (toolCall) => toolCall.toolName === toolName
    )) != null ? _c : false;
  };
}
async function isStopConditionMet({
  stopConditions,
  steps
}) {
  return (await Promise.all(stopConditions.map((condition) => condition({ steps })))).some((result) => result);
}
async function toResponseMessages({
  content: inputContent,
  tools
}) {
  const responseMessages = [];
  const content = [];
  for (const part of inputContent) {
    if (part.type === "source") {
      continue;
    }
    if ((part.type === "tool-result" || part.type === "tool-error") && !part.providerExecuted) {
      continue;
    }
    if (part.type === "text" && part.text.length === 0) {
      continue;
    }
    switch (part.type) {
      case "text":
        content.push({
          type: "text",
          text: part.text,
          providerOptions: part.providerMetadata
        });
        break;
      case "reasoning":
        content.push({
          type: "reasoning",
          text: part.text,
          providerOptions: part.providerMetadata
        });
        break;
      case "file":
        content.push({
          type: "file",
          data: part.file.base64,
          mediaType: part.file.mediaType,
          providerOptions: part.providerMetadata
        });
        break;
      case "tool-call":
        content.push({
          type: "tool-call",
          toolCallId: part.toolCallId,
          toolName: part.toolName,
          input: part.input,
          providerExecuted: part.providerExecuted,
          providerOptions: part.providerMetadata
        });
        break;
      case "tool-result": {
        const output = await createToolModelOutput({
          toolCallId: part.toolCallId,
          input: part.input,
          tool: tools == null ? void 0 : tools[part.toolName],
          output: part.output,
          errorMode: "none"
        });
        content.push({
          type: "tool-result",
          toolCallId: part.toolCallId,
          toolName: part.toolName,
          output,
          providerOptions: part.providerMetadata
        });
        break;
      }
      case "tool-error": {
        const output = await createToolModelOutput({
          toolCallId: part.toolCallId,
          input: part.input,
          tool: tools == null ? void 0 : tools[part.toolName],
          output: part.error,
          errorMode: "json"
        });
        content.push({
          type: "tool-result",
          toolCallId: part.toolCallId,
          toolName: part.toolName,
          output,
          providerOptions: part.providerMetadata
        });
        break;
      }
      case "tool-approval-request":
        content.push({
          type: "tool-approval-request",
          approvalId: part.approvalId,
          toolCallId: part.toolCall.toolCallId
        });
        break;
    }
  }
  if (content.length > 0) {
    responseMessages.push({
      role: "assistant",
      content
    });
  }
  const toolResultContent = [];
  for (const part of inputContent) {
    if (!(part.type === "tool-result" || part.type === "tool-error") || part.providerExecuted) {
      continue;
    }
    const output = await createToolModelOutput({
      toolCallId: part.toolCallId,
      input: part.input,
      tool: tools == null ? void 0 : tools[part.toolName],
      output: part.type === "tool-result" ? part.output : part.error,
      errorMode: part.type === "tool-error" ? "text" : "none"
    });
    toolResultContent.push({
      type: "tool-result",
      toolCallId: part.toolCallId,
      toolName: part.toolName,
      output,
      ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}
    });
  }
  if (toolResultContent.length > 0) {
    responseMessages.push({
      role: "tool",
      content: toolResultContent
    });
  }
  return responseMessages;
}
function mergeAbortSignals(...signals) {
  const validSignals = signals.filter(
    (signal) => signal != null
  );
  if (validSignals.length === 0) {
    return void 0;
  }
  if (validSignals.length === 1) {
    return validSignals[0];
  }
  const controller = new AbortController();
  for (const signal of validSignals) {
    if (signal.aborted) {
      controller.abort(signal.reason);
      return controller.signal;
    }
    signal.addEventListener(
      "abort",
      () => {
        controller.abort(signal.reason);
      },
      { once: true }
    );
  }
  return controller.signal;
}
async function generateText({
  model: modelArg,
  tools,
  toolChoice,
  system,
  prompt,
  messages,
  maxRetries: maxRetriesArg,
  abortSignal,
  timeout,
  headers,
  stopWhen = stepCountIs(1),
  experimental_output,
  output = experimental_output,
  experimental_telemetry: telemetry2,
  providerOptions,
  experimental_activeTools,
  activeTools = experimental_activeTools,
  experimental_prepareStep,
  prepareStep = experimental_prepareStep,
  experimental_repairToolCall: repairToolCall,
  experimental_download: download2,
  experimental_context,
  experimental_include: include,
  _internal: { generateId: generateId22 = originalGenerateId } = {},
  onStepFinish,
  onFinish: onFinish2,
  ...settings
}) {
  const model = resolveLanguageModel(modelArg);
  const stopConditions = asArray(stopWhen);
  const totalTimeoutMs = getTotalTimeoutMs(timeout);
  const stepTimeoutMs = getStepTimeoutMs(timeout);
  const stepAbortController = stepTimeoutMs != null ? new AbortController() : void 0;
  const mergedAbortSignal = mergeAbortSignals(
    abortSignal,
    totalTimeoutMs != null ? AbortSignal.timeout(totalTimeoutMs) : void 0,
    stepAbortController == null ? void 0 : stepAbortController.signal
  );
  const { maxRetries, retry } = prepareRetries({
    maxRetries: maxRetriesArg,
    abortSignal: mergedAbortSignal
  });
  const callSettings = prepareCallSettings(settings);
  const headersWithUserAgent = withUserAgentSuffix(
    headers != null ? headers : {},
    `ai/${VERSION4}`
  );
  const baseTelemetryAttributes = getBaseTelemetryAttributes({
    model,
    telemetry: telemetry2,
    headers: headersWithUserAgent,
    settings: { ...callSettings, maxRetries }
  });
  const initialPrompt = await standardizePrompt({
    system,
    prompt,
    messages
  });
  const tracer = getTracer(telemetry2);
  try {
    return await recordSpan({
      name: "ai.generateText",
      attributes: selectTelemetryAttributes({
        telemetry: telemetry2,
        attributes: {
          ...assembleOperationName({
            operationId: "ai.generateText",
            telemetry: telemetry2
          }),
          ...baseTelemetryAttributes,
          // model:
          "ai.model.provider": model.provider,
          "ai.model.id": model.modelId,
          // specific settings that only make sense on the outer level:
          "ai.prompt": {
            input: () => JSON.stringify({ system, prompt, messages })
          }
        }
      }),
      tracer,
      fn: async (span) => {
        var _a212, _b18, _c, _d, _e, _f, _g, _h, _i, _j, _k;
        const initialMessages = initialPrompt.messages;
        const responseMessages = [];
        const { approvedToolApprovals, deniedToolApprovals } = collectToolApprovals({ messages: initialMessages });
        const localApprovedToolApprovals = approvedToolApprovals.filter(
          (toolApproval) => !toolApproval.toolCall.providerExecuted
        );
        if (deniedToolApprovals.length > 0 || localApprovedToolApprovals.length > 0) {
          const toolOutputs = await executeTools({
            toolCalls: localApprovedToolApprovals.map(
              (toolApproval) => toolApproval.toolCall
            ),
            tools,
            tracer,
            telemetry: telemetry2,
            messages: initialMessages,
            abortSignal: mergedAbortSignal,
            experimental_context
          });
          const toolContent = [];
          for (const output2 of toolOutputs) {
            const modelOutput = await createToolModelOutput({
              toolCallId: output2.toolCallId,
              input: output2.input,
              tool: tools == null ? void 0 : tools[output2.toolName],
              output: output2.type === "tool-result" ? output2.output : output2.error,
              errorMode: output2.type === "tool-error" ? "json" : "none"
            });
            toolContent.push({
              type: "tool-result",
              toolCallId: output2.toolCallId,
              toolName: output2.toolName,
              output: modelOutput
            });
          }
          for (const toolApproval of deniedToolApprovals) {
            toolContent.push({
              type: "tool-result",
              toolCallId: toolApproval.toolCall.toolCallId,
              toolName: toolApproval.toolCall.toolName,
              output: {
                type: "execution-denied",
                reason: toolApproval.approvalResponse.reason,
                // For provider-executed tools, include approvalId so provider can correlate
                ...toolApproval.toolCall.providerExecuted && {
                  providerOptions: {
                    openai: {
                      approvalId: toolApproval.approvalResponse.approvalId
                    }
                  }
                }
              }
            });
          }
          responseMessages.push({
            role: "tool",
            content: toolContent
          });
        }
        const providerExecutedToolApprovals = [
          ...approvedToolApprovals,
          ...deniedToolApprovals
        ].filter((toolApproval) => toolApproval.toolCall.providerExecuted);
        if (providerExecutedToolApprovals.length > 0) {
          responseMessages.push({
            role: "tool",
            content: providerExecutedToolApprovals.map(
              (toolApproval) => ({
                type: "tool-approval-response",
                approvalId: toolApproval.approvalResponse.approvalId,
                approved: toolApproval.approvalResponse.approved,
                reason: toolApproval.approvalResponse.reason,
                providerExecuted: true
              })
            )
          });
        }
        const callSettings2 = prepareCallSettings(settings);
        let currentModelResponse;
        let clientToolCalls = [];
        let clientToolOutputs = [];
        const steps = [];
        const pendingDeferredToolCalls = /* @__PURE__ */ new Map();
        do {
          const stepTimeoutId = stepTimeoutMs != null ? setTimeout(() => stepAbortController.abort(), stepTimeoutMs) : void 0;
          try {
            const stepInputMessages = [...initialMessages, ...responseMessages];
            const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({
              model,
              steps,
              stepNumber: steps.length,
              messages: stepInputMessages,
              experimental_context
            }));
            const stepModel = resolveLanguageModel(
              (_a212 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a212 : model
            );
            const promptMessages = await convertToLanguageModelPrompt({
              prompt: {
                system: (_b18 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b18 : initialPrompt.system,
                messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages
              },
              supportedUrls: await stepModel.supportedUrls,
              download: download2
            });
            experimental_context = (_d = prepareStepResult == null ? void 0 : prepareStepResult.experimental_context) != null ? _d : experimental_context;
            const { toolChoice: stepToolChoice, tools: stepTools } = await prepareToolsAndToolChoice({
              tools,
              toolChoice: (_e = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _e : toolChoice,
              activeTools: (_f = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _f : activeTools
            });
            currentModelResponse = await retry(
              () => {
                var _a222;
                return recordSpan({
                  name: "ai.generateText.doGenerate",
                  attributes: selectTelemetryAttributes({
                    telemetry: telemetry2,
                    attributes: {
                      ...assembleOperationName({
                        operationId: "ai.generateText.doGenerate",
                        telemetry: telemetry2
                      }),
                      ...baseTelemetryAttributes,
                      // model:
                      "ai.model.provider": stepModel.provider,
                      "ai.model.id": stepModel.modelId,
                      // prompt:
                      "ai.prompt.messages": {
                        input: () => stringifyForTelemetry(promptMessages)
                      },
                      "ai.prompt.tools": {
                        // convert the language model level tools:
                        input: () => stepTools == null ? void 0 : stepTools.map((tool2) => JSON.stringify(tool2))
                      },
                      "ai.prompt.toolChoice": {
                        input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0
                      },
                      // standardized gen-ai llm span attributes:
                      "gen_ai.system": stepModel.provider,
                      "gen_ai.request.model": stepModel.modelId,
                      "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                      "gen_ai.request.max_tokens": settings.maxOutputTokens,
                      "gen_ai.request.presence_penalty": settings.presencePenalty,
                      "gen_ai.request.stop_sequences": settings.stopSequences,
                      "gen_ai.request.temperature": (_a222 = settings.temperature) != null ? _a222 : void 0,
                      "gen_ai.request.top_k": settings.topK,
                      "gen_ai.request.top_p": settings.topP
                    }
                  }),
                  tracer,
                  fn: async (span2) => {
                    var _a232, _b24, _c2, _d2, _e2, _f2, _g2, _h2;
                    const stepProviderOptions = mergeObjects(
                      providerOptions,
                      prepareStepResult == null ? void 0 : prepareStepResult.providerOptions
                    );
                    const result = await stepModel.doGenerate({
                      ...callSettings2,
                      tools: stepTools,
                      toolChoice: stepToolChoice,
                      responseFormat: await (output == null ? void 0 : output.responseFormat),
                      prompt: promptMessages,
                      providerOptions: stepProviderOptions,
                      abortSignal: mergedAbortSignal,
                      headers: headersWithUserAgent
                    });
                    const responseData = {
                      id: (_b24 = (_a232 = result.response) == null ? void 0 : _a232.id) != null ? _b24 : generateId22(),
                      timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : /* @__PURE__ */ new Date(),
                      modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : stepModel.modelId,
                      headers: (_g2 = result.response) == null ? void 0 : _g2.headers,
                      body: (_h2 = result.response) == null ? void 0 : _h2.body
                    };
                    span2.setAttributes(
                      await selectTelemetryAttributes({
                        telemetry: telemetry2,
                        attributes: {
                          "ai.response.finishReason": result.finishReason.unified,
                          "ai.response.text": {
                            output: () => extractTextContent(result.content)
                          },
                          "ai.response.toolCalls": {
                            output: () => {
                              const toolCalls = asToolCalls(result.content);
                              return toolCalls == null ? void 0 : JSON.stringify(toolCalls);
                            }
                          },
                          "ai.response.id": responseData.id,
                          "ai.response.model": responseData.modelId,
                          "ai.response.timestamp": responseData.timestamp.toISOString(),
                          "ai.response.providerMetadata": JSON.stringify(
                            result.providerMetadata
                          ),
                          // TODO rename telemetry attributes to inputTokens and outputTokens
                          "ai.usage.promptTokens": result.usage.inputTokens.total,
                          "ai.usage.completionTokens": result.usage.outputTokens.total,
                          // standardized gen-ai llm span attributes:
                          "gen_ai.response.finish_reasons": [
                            result.finishReason.unified
                          ],
                          "gen_ai.response.id": responseData.id,
                          "gen_ai.response.model": responseData.modelId,
                          "gen_ai.usage.input_tokens": result.usage.inputTokens.total,
                          "gen_ai.usage.output_tokens": result.usage.outputTokens.total
                        }
                      })
                    );
                    return { ...result, response: responseData };
                  }
                });
              }
            );
            const stepToolCalls = await Promise.all(
              currentModelResponse.content.filter(
                (part) => part.type === "tool-call"
              ).map(
                (toolCall) => parseToolCall({
                  toolCall,
                  tools,
                  repairToolCall,
                  system,
                  messages: stepInputMessages
                })
              )
            );
            const toolApprovalRequests = {};
            for (const toolCall of stepToolCalls) {
              if (toolCall.invalid) {
                continue;
              }
              const tool2 = tools == null ? void 0 : tools[toolCall.toolName];
              if (tool2 == null) {
                continue;
              }
              if ((tool2 == null ? void 0 : tool2.onInputAvailable) != null) {
                await tool2.onInputAvailable({
                  input: toolCall.input,
                  toolCallId: toolCall.toolCallId,
                  messages: stepInputMessages,
                  abortSignal: mergedAbortSignal,
                  experimental_context
                });
              }
              if (await isApprovalNeeded({
                tool: tool2,
                toolCall,
                messages: stepInputMessages,
                experimental_context
              })) {
                toolApprovalRequests[toolCall.toolCallId] = {
                  type: "tool-approval-request",
                  approvalId: generateId22(),
                  toolCall
                };
              }
            }
            const invalidToolCalls = stepToolCalls.filter(
              (toolCall) => toolCall.invalid && toolCall.dynamic
            );
            clientToolOutputs = [];
            for (const toolCall of invalidToolCalls) {
              clientToolOutputs.push({
                type: "tool-error",
                toolCallId: toolCall.toolCallId,
                toolName: toolCall.toolName,
                input: toolCall.input,
                error: getErrorMessage2(toolCall.error),
                dynamic: true
              });
            }
            clientToolCalls = stepToolCalls.filter(
              (toolCall) => !toolCall.providerExecuted
            );
            if (tools != null) {
              clientToolOutputs.push(
                ...await executeTools({
                  toolCalls: clientToolCalls.filter(
                    (toolCall) => !toolCall.invalid && toolApprovalRequests[toolCall.toolCallId] == null
                  ),
                  tools,
                  tracer,
                  telemetry: telemetry2,
                  messages: stepInputMessages,
                  abortSignal: mergedAbortSignal,
                  experimental_context
                })
              );
            }
            for (const toolCall of stepToolCalls) {
              if (!toolCall.providerExecuted)
                continue;
              const tool2 = tools == null ? void 0 : tools[toolCall.toolName];
              if ((tool2 == null ? void 0 : tool2.type) === "provider" && tool2.supportsDeferredResults) {
                const hasResultInResponse = currentModelResponse.content.some(
                  (part) => part.type === "tool-result" && part.toolCallId === toolCall.toolCallId
                );
                if (!hasResultInResponse) {
                  pendingDeferredToolCalls.set(toolCall.toolCallId, {
                    toolName: toolCall.toolName
                  });
                }
              }
            }
            for (const part of currentModelResponse.content) {
              if (part.type === "tool-result") {
                pendingDeferredToolCalls.delete(part.toolCallId);
              }
            }
            const stepContent = asContent({
              content: currentModelResponse.content,
              toolCalls: stepToolCalls,
              toolOutputs: clientToolOutputs,
              toolApprovalRequests: Object.values(toolApprovalRequests),
              tools
            });
            responseMessages.push(
              ...await toResponseMessages({
                content: stepContent,
                tools
              })
            );
            const stepRequest = ((_g = include == null ? void 0 : include.requestBody) != null ? _g : true) ? (_h = currentModelResponse.request) != null ? _h : {} : { ...currentModelResponse.request, body: void 0 };
            const stepResponse = {
              ...currentModelResponse.response,
              // deep clone msgs to avoid mutating past messages in multi-step:
              messages: structuredClone(responseMessages),
              // Conditionally include response body:
              body: ((_i = include == null ? void 0 : include.responseBody) != null ? _i : true) ? (_j = currentModelResponse.response) == null ? void 0 : _j.body : void 0
            };
            const currentStepResult = new DefaultStepResult({
              content: stepContent,
              finishReason: currentModelResponse.finishReason.unified,
              rawFinishReason: currentModelResponse.finishReason.raw,
              usage: asLanguageModelUsage(currentModelResponse.usage),
              warnings: currentModelResponse.warnings,
              providerMetadata: currentModelResponse.providerMetadata,
              request: stepRequest,
              response: stepResponse
            });
            logWarnings({
              warnings: (_k = currentModelResponse.warnings) != null ? _k : [],
              provider: stepModel.provider,
              model: stepModel.modelId
            });
            steps.push(currentStepResult);
            await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));
          } finally {
            if (stepTimeoutId != null) {
              clearTimeout(stepTimeoutId);
            }
          }
        } while (
          // Continue if:
          // 1. There are client tool calls that have all been executed, OR
          // 2. There are pending deferred results from provider-executed tools
          (clientToolCalls.length > 0 && clientToolOutputs.length === clientToolCalls.length || pendingDeferredToolCalls.size > 0) && // continue until a stop condition is met:
          !await isStopConditionMet({ stopConditions, steps })
        );
        span.setAttributes(
          await selectTelemetryAttributes({
            telemetry: telemetry2,
            attributes: {
              "ai.response.finishReason": currentModelResponse.finishReason.unified,
              "ai.response.text": {
                output: () => extractTextContent(currentModelResponse.content)
              },
              "ai.response.toolCalls": {
                output: () => {
                  const toolCalls = asToolCalls(currentModelResponse.content);
                  return toolCalls == null ? void 0 : JSON.stringify(toolCalls);
                }
              },
              "ai.response.providerMetadata": JSON.stringify(
                currentModelResponse.providerMetadata
              ),
              // TODO rename telemetry attributes to inputTokens and outputTokens
              "ai.usage.promptTokens": currentModelResponse.usage.inputTokens.total,
              "ai.usage.completionTokens": currentModelResponse.usage.outputTokens.total
            }
          })
        );
        const lastStep = steps[steps.length - 1];
        const totalUsage = steps.reduce(
          (totalUsage2, step) => {
            return addLanguageModelUsage(totalUsage2, step.usage);
          },
          {
            inputTokens: void 0,
            outputTokens: void 0,
            totalTokens: void 0,
            reasoningTokens: void 0,
            cachedInputTokens: void 0
          }
        );
        await (onFinish2 == null ? void 0 : onFinish2({
          finishReason: lastStep.finishReason,
          rawFinishReason: lastStep.rawFinishReason,
          usage: lastStep.usage,
          content: lastStep.content,
          text: lastStep.text,
          reasoningText: lastStep.reasoningText,
          reasoning: lastStep.reasoning,
          files: lastStep.files,
          sources: lastStep.sources,
          toolCalls: lastStep.toolCalls,
          staticToolCalls: lastStep.staticToolCalls,
          dynamicToolCalls: lastStep.dynamicToolCalls,
          toolResults: lastStep.toolResults,
          staticToolResults: lastStep.staticToolResults,
          dynamicToolResults: lastStep.dynamicToolResults,
          request: lastStep.request,
          response: lastStep.response,
          warnings: lastStep.warnings,
          providerMetadata: lastStep.providerMetadata,
          steps,
          totalUsage,
          experimental_context
        }));
        let resolvedOutput;
        if (lastStep.finishReason === "stop") {
          const outputSpecification = output != null ? output : text();
          resolvedOutput = await outputSpecification.parseCompleteOutput(
            { text: lastStep.text },
            {
              response: lastStep.response,
              usage: lastStep.usage,
              finishReason: lastStep.finishReason
            }
          );
        }
        return new DefaultGenerateTextResult({
          steps,
          totalUsage,
          output: resolvedOutput
        });
      }
    });
  } catch (error) {
    throw wrapGatewayError(error);
  }
}
async function executeTools({
  toolCalls,
  tools,
  tracer,
  telemetry: telemetry2,
  messages,
  abortSignal,
  experimental_context
}) {
  const toolOutputs = await Promise.all(
    toolCalls.map(
      async (toolCall) => executeToolCall({
        toolCall,
        tools,
        tracer,
        telemetry: telemetry2,
        messages,
        abortSignal,
        experimental_context
      })
    )
  );
  return toolOutputs.filter(
    (output) => output != null
  );
}
function asToolCalls(content) {
  const parts = content.filter(
    (part) => part.type === "tool-call"
  );
  if (parts.length === 0) {
    return void 0;
  }
  return parts.map((toolCall) => ({
    toolCallId: toolCall.toolCallId,
    toolName: toolCall.toolName,
    input: toolCall.input
  }));
}
function asContent({
  content,
  toolCalls,
  toolOutputs,
  toolApprovalRequests,
  tools
}) {
  const contentParts = [];
  for (const part of content) {
    switch (part.type) {
      case "text":
      case "reasoning":
      case "source":
        contentParts.push(part);
        break;
      case "file": {
        contentParts.push({
          type: "file",
          file: new DefaultGeneratedFile(part),
          ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
        });
        break;
      }
      case "tool-call": {
        contentParts.push(
          toolCalls.find((toolCall) => toolCall.toolCallId === part.toolCallId)
        );
        break;
      }
      case "tool-result": {
        const toolCall = toolCalls.find(
          (toolCall2) => toolCall2.toolCallId === part.toolCallId
        );
        if (toolCall == null) {
          const tool2 = tools == null ? void 0 : tools[part.toolName];
          const supportsDeferredResults = (tool2 == null ? void 0 : tool2.type) === "provider" && tool2.supportsDeferredResults;
          if (!supportsDeferredResults) {
            throw new Error(`Tool call ${part.toolCallId} not found.`);
          }
          if (part.isError) {
            contentParts.push({
              type: "tool-error",
              toolCallId: part.toolCallId,
              toolName: part.toolName,
              input: void 0,
              error: part.result,
              providerExecuted: true,
              dynamic: part.dynamic
            });
          } else {
            contentParts.push({
              type: "tool-result",
              toolCallId: part.toolCallId,
              toolName: part.toolName,
              input: void 0,
              output: part.result,
              providerExecuted: true,
              dynamic: part.dynamic
            });
          }
          break;
        }
        if (part.isError) {
          contentParts.push({
            type: "tool-error",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            input: toolCall.input,
            error: part.result,
            providerExecuted: true,
            dynamic: toolCall.dynamic
          });
        } else {
          contentParts.push({
            type: "tool-result",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            input: toolCall.input,
            output: part.result,
            providerExecuted: true,
            dynamic: toolCall.dynamic
          });
        }
        break;
      }
      case "tool-approval-request": {
        const toolCall = toolCalls.find(
          (toolCall2) => toolCall2.toolCallId === part.toolCallId
        );
        if (toolCall == null) {
          throw new ToolCallNotFoundForApprovalError({
            toolCallId: part.toolCallId,
            approvalId: part.approvalId
          });
        }
        contentParts.push({
          type: "tool-approval-request",
          approvalId: part.approvalId,
          toolCall
        });
        break;
      }
    }
  }
  return [...contentParts, ...toolOutputs, ...toolApprovalRequests];
}
function prepareHeaders(headers, defaultHeaders) {
  const responseHeaders = new Headers(headers != null ? headers : {});
  for (const [key, value2] of Object.entries(defaultHeaders)) {
    if (!responseHeaders.has(key)) {
      responseHeaders.set(key, value2);
    }
  }
  return responseHeaders;
}
function createTextStreamResponse({
  status,
  statusText,
  headers,
  textStream
}) {
  return new Response(textStream.pipeThrough(new TextEncoderStream()), {
    status: status != null ? status : 200,
    statusText,
    headers: prepareHeaders(headers, {
      "content-type": "text/plain; charset=utf-8"
    })
  });
}
function writeToServerResponse({
  response,
  status,
  statusText,
  headers,
  stream
}) {
  const statusCode = status != null ? status : 200;
  if (statusText !== void 0) {
    response.writeHead(statusCode, statusText, headers);
  } else {
    response.writeHead(statusCode, headers);
  }
  const reader = stream.getReader();
  const read = async () => {
    try {
      while (true) {
        const { done, value: value2 } = await reader.read();
        if (done)
          break;
        const canContinue = response.write(value2);
        if (!canContinue) {
          await new Promise((resolve32) => {
            response.once("drain", resolve32);
          });
        }
      }
    } catch (error) {
      throw error;
    } finally {
      response.end();
    }
  };
  read();
}
function pipeTextStreamToResponse({
  response,
  status,
  statusText,
  headers,
  textStream
}) {
  writeToServerResponse({
    response,
    status,
    statusText,
    headers: Object.fromEntries(
      prepareHeaders(headers, {
        "content-type": "text/plain; charset=utf-8"
      }).entries()
    ),
    stream: textStream.pipeThrough(new TextEncoderStream())
  });
}
function createUIMessageStreamResponse({
  status,
  statusText,
  headers,
  stream,
  consumeSseStream
}) {
  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());
  if (consumeSseStream) {
    const [stream1, stream2] = sseStream.tee();
    sseStream = stream1;
    consumeSseStream({ stream: stream2 });
  }
  return new Response(sseStream.pipeThrough(new TextEncoderStream()), {
    status,
    statusText,
    headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS)
  });
}
function getResponseUIMessageId({
  originalMessages,
  responseMessageId
}) {
  if (originalMessages == null) {
    return void 0;
  }
  const lastMessage = originalMessages[originalMessages.length - 1];
  return (lastMessage == null ? void 0 : lastMessage.role) === "assistant" ? lastMessage.id : typeof responseMessageId === "function" ? responseMessageId() : responseMessageId;
}
function isDataUIMessageChunk(chunk) {
  return chunk.type.startsWith("data-");
}
function isDataUIPart(part) {
  return part.type.startsWith("data-");
}
function isTextUIPart(part) {
  return part.type === "text";
}
function isFileUIPart(part) {
  return part.type === "file";
}
function isReasoningUIPart(part) {
  return part.type === "reasoning";
}
function isStaticToolUIPart(part) {
  return part.type.startsWith("tool-");
}
function isDynamicToolUIPart(part) {
  return part.type === "dynamic-tool";
}
function isToolUIPart(part) {
  return isStaticToolUIPart(part) || isDynamicToolUIPart(part);
}
function getStaticToolName(part) {
  return part.type.split("-").slice(1).join("-");
}
function getToolName(part) {
  return isDynamicToolUIPart(part) ? part.toolName : getStaticToolName(part);
}
function createStreamingUIMessageState({
  lastMessage,
  messageId
}) {
  return {
    message: (lastMessage == null ? void 0 : lastMessage.role) === "assistant" ? lastMessage : {
      id: messageId,
      metadata: void 0,
      role: "assistant",
      parts: []
    },
    activeTextParts: {},
    activeReasoningParts: {},
    partialToolCalls: {}
  };
}
function processUIMessageStream({
  stream,
  messageMetadataSchema,
  dataPartSchemas,
  runUpdateMessageJob,
  onError: onError2,
  onToolCall,
  onData
}) {
  return stream.pipeThrough(
    new TransformStream({
      async transform(chunk, controller) {
        await runUpdateMessageJob(async ({ state, write }) => {
          var _a212, _b18, _c, _d;
          function getToolInvocation(toolCallId) {
            const toolInvocations = state.message.parts.filter(isToolUIPart);
            const toolInvocation = toolInvocations.find(
              (invocation) => invocation.toolCallId === toolCallId
            );
            if (toolInvocation == null) {
              throw new UIMessageStreamError({
                chunkType: "tool-invocation",
                chunkId: toolCallId,
                message: `No tool invocation found for tool call ID "${toolCallId}".`
              });
            }
            return toolInvocation;
          }
          function updateToolPart(options) {
            var _a222;
            const part = state.message.parts.find(
              (part2) => isStaticToolUIPart(part2) && part2.toolCallId === options.toolCallId
            );
            const anyOptions = options;
            const anyPart = part;
            if (part != null) {
              part.state = options.state;
              anyPart.input = anyOptions.input;
              anyPart.output = anyOptions.output;
              anyPart.errorText = anyOptions.errorText;
              anyPart.rawInput = anyOptions.rawInput;
              anyPart.preliminary = anyOptions.preliminary;
              if (options.title !== void 0) {
                anyPart.title = options.title;
              }
              anyPart.providerExecuted = (_a222 = anyOptions.providerExecuted) != null ? _a222 : part.providerExecuted;
              if (anyOptions.providerMetadata != null) {
                part.callProviderMetadata = anyOptions.providerMetadata;
              }
            } else {
              state.message.parts.push({
                type: `tool-${options.toolName}`,
                toolCallId: options.toolCallId,
                state: options.state,
                title: options.title,
                input: anyOptions.input,
                output: anyOptions.output,
                rawInput: anyOptions.rawInput,
                errorText: anyOptions.errorText,
                providerExecuted: anyOptions.providerExecuted,
                preliminary: anyOptions.preliminary,
                ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}
              });
            }
          }
          function updateDynamicToolPart(options) {
            var _a222, _b24;
            const part = state.message.parts.find(
              (part2) => part2.type === "dynamic-tool" && part2.toolCallId === options.toolCallId
            );
            const anyOptions = options;
            const anyPart = part;
            if (part != null) {
              part.state = options.state;
              anyPart.toolName = options.toolName;
              anyPart.input = anyOptions.input;
              anyPart.output = anyOptions.output;
              anyPart.errorText = anyOptions.errorText;
              anyPart.rawInput = (_a222 = anyOptions.rawInput) != null ? _a222 : anyPart.rawInput;
              anyPart.preliminary = anyOptions.preliminary;
              if (options.title !== void 0) {
                anyPart.title = options.title;
              }
              anyPart.providerExecuted = (_b24 = anyOptions.providerExecuted) != null ? _b24 : part.providerExecuted;
              if (anyOptions.providerMetadata != null) {
                part.callProviderMetadata = anyOptions.providerMetadata;
              }
            } else {
              state.message.parts.push({
                type: "dynamic-tool",
                toolName: options.toolName,
                toolCallId: options.toolCallId,
                state: options.state,
                input: anyOptions.input,
                output: anyOptions.output,
                errorText: anyOptions.errorText,
                preliminary: anyOptions.preliminary,
                providerExecuted: anyOptions.providerExecuted,
                title: options.title,
                ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}
              });
            }
          }
          async function updateMessageMetadata(metadata) {
            if (metadata != null) {
              const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;
              if (messageMetadataSchema != null) {
                await validateTypes({
                  value: mergedMetadata,
                  schema: messageMetadataSchema,
                  context: {
                    field: "message.metadata",
                    entityId: state.message.id
                  }
                });
              }
              state.message.metadata = mergedMetadata;
            }
          }
          switch (chunk.type) {
            case "text-start": {
              const textPart = {
                type: "text",
                text: "",
                providerMetadata: chunk.providerMetadata,
                state: "streaming"
              };
              state.activeTextParts[chunk.id] = textPart;
              state.message.parts.push(textPart);
              write();
              break;
            }
            case "text-delta": {
              const textPart = state.activeTextParts[chunk.id];
              if (textPart == null) {
                throw new UIMessageStreamError({
                  chunkType: "text-delta",
                  chunkId: chunk.id,
                  message: `Received text-delta for missing text part with ID "${chunk.id}". Ensure a "text-start" chunk is sent before any "text-delta" chunks.`
                });
              }
              textPart.text += chunk.delta;
              textPart.providerMetadata = (_a212 = chunk.providerMetadata) != null ? _a212 : textPart.providerMetadata;
              write();
              break;
            }
            case "text-end": {
              const textPart = state.activeTextParts[chunk.id];
              if (textPart == null) {
                throw new UIMessageStreamError({
                  chunkType: "text-end",
                  chunkId: chunk.id,
                  message: `Received text-end for missing text part with ID "${chunk.id}". Ensure a "text-start" chunk is sent before any "text-end" chunks.`
                });
              }
              textPart.state = "done";
              textPart.providerMetadata = (_b18 = chunk.providerMetadata) != null ? _b18 : textPart.providerMetadata;
              delete state.activeTextParts[chunk.id];
              write();
              break;
            }
            case "reasoning-start": {
              const reasoningPart = {
                type: "reasoning",
                text: "",
                providerMetadata: chunk.providerMetadata,
                state: "streaming"
              };
              state.activeReasoningParts[chunk.id] = reasoningPart;
              state.message.parts.push(reasoningPart);
              write();
              break;
            }
            case "reasoning-delta": {
              const reasoningPart = state.activeReasoningParts[chunk.id];
              if (reasoningPart == null) {
                throw new UIMessageStreamError({
                  chunkType: "reasoning-delta",
                  chunkId: chunk.id,
                  message: `Received reasoning-delta for missing reasoning part with ID "${chunk.id}". Ensure a "reasoning-start" chunk is sent before any "reasoning-delta" chunks.`
                });
              }
              reasoningPart.text += chunk.delta;
              reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata;
              write();
              break;
            }
            case "reasoning-end": {
              const reasoningPart = state.activeReasoningParts[chunk.id];
              if (reasoningPart == null) {
                throw new UIMessageStreamError({
                  chunkType: "reasoning-end",
                  chunkId: chunk.id,
                  message: `Received reasoning-end for missing reasoning part with ID "${chunk.id}". Ensure a "reasoning-start" chunk is sent before any "reasoning-end" chunks.`
                });
              }
              reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata;
              reasoningPart.state = "done";
              delete state.activeReasoningParts[chunk.id];
              write();
              break;
            }
            case "file": {
              state.message.parts.push({
                type: "file",
                mediaType: chunk.mediaType,
                url: chunk.url
              });
              write();
              break;
            }
            case "source-url": {
              state.message.parts.push({
                type: "source-url",
                sourceId: chunk.sourceId,
                url: chunk.url,
                title: chunk.title,
                providerMetadata: chunk.providerMetadata
              });
              write();
              break;
            }
            case "source-document": {
              state.message.parts.push({
                type: "source-document",
                sourceId: chunk.sourceId,
                mediaType: chunk.mediaType,
                title: chunk.title,
                filename: chunk.filename,
                providerMetadata: chunk.providerMetadata
              });
              write();
              break;
            }
            case "tool-input-start": {
              const toolInvocations = state.message.parts.filter(isStaticToolUIPart);
              state.partialToolCalls[chunk.toolCallId] = {
                text: "",
                toolName: chunk.toolName,
                index: toolInvocations.length,
                dynamic: chunk.dynamic,
                title: chunk.title
              };
              if (chunk.dynamic) {
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "input-streaming",
                  input: void 0,
                  providerExecuted: chunk.providerExecuted,
                  title: chunk.title,
                  providerMetadata: chunk.providerMetadata
                });
              } else {
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "input-streaming",
                  input: void 0,
                  providerExecuted: chunk.providerExecuted,
                  title: chunk.title,
                  providerMetadata: chunk.providerMetadata
                });
              }
              write();
              break;
            }
            case "tool-input-delta": {
              const partialToolCall = state.partialToolCalls[chunk.toolCallId];
              if (partialToolCall == null) {
                throw new UIMessageStreamError({
                  chunkType: "tool-input-delta",
                  chunkId: chunk.toolCallId,
                  message: `Received tool-input-delta for missing tool call with ID "${chunk.toolCallId}". Ensure a "tool-input-start" chunk is sent before any "tool-input-delta" chunks.`
                });
              }
              partialToolCall.text += chunk.inputTextDelta;
              const { value: partialArgs } = await parsePartialJson(
                partialToolCall.text
              );
              if (partialToolCall.dynamic) {
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: partialToolCall.toolName,
                  state: "input-streaming",
                  input: partialArgs,
                  title: partialToolCall.title
                });
              } else {
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: partialToolCall.toolName,
                  state: "input-streaming",
                  input: partialArgs,
                  title: partialToolCall.title
                });
              }
              write();
              break;
            }
            case "tool-input-available": {
              if (chunk.dynamic) {
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "input-available",
                  input: chunk.input,
                  providerExecuted: chunk.providerExecuted,
                  providerMetadata: chunk.providerMetadata,
                  title: chunk.title
                });
              } else {
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "input-available",
                  input: chunk.input,
                  providerExecuted: chunk.providerExecuted,
                  providerMetadata: chunk.providerMetadata,
                  title: chunk.title
                });
              }
              write();
              if (onToolCall && !chunk.providerExecuted) {
                await onToolCall({
                  toolCall: chunk
                });
              }
              break;
            }
            case "tool-input-error": {
              if (chunk.dynamic) {
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "output-error",
                  input: chunk.input,
                  errorText: chunk.errorText,
                  providerExecuted: chunk.providerExecuted,
                  providerMetadata: chunk.providerMetadata
                });
              } else {
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "output-error",
                  input: void 0,
                  rawInput: chunk.input,
                  errorText: chunk.errorText,
                  providerExecuted: chunk.providerExecuted,
                  providerMetadata: chunk.providerMetadata
                });
              }
              write();
              break;
            }
            case "tool-approval-request": {
              const toolInvocation = getToolInvocation(chunk.toolCallId);
              toolInvocation.state = "approval-requested";
              toolInvocation.approval = { id: chunk.approvalId };
              write();
              break;
            }
            case "tool-output-denied": {
              const toolInvocation = getToolInvocation(chunk.toolCallId);
              toolInvocation.state = "output-denied";
              write();
              break;
            }
            case "tool-output-available": {
              const toolInvocation = getToolInvocation(chunk.toolCallId);
              if (toolInvocation.type === "dynamic-tool") {
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: toolInvocation.toolName,
                  state: "output-available",
                  input: toolInvocation.input,
                  output: chunk.output,
                  preliminary: chunk.preliminary,
                  providerExecuted: chunk.providerExecuted,
                  title: toolInvocation.title
                });
              } else {
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: getStaticToolName(toolInvocation),
                  state: "output-available",
                  input: toolInvocation.input,
                  output: chunk.output,
                  providerExecuted: chunk.providerExecuted,
                  preliminary: chunk.preliminary,
                  title: toolInvocation.title
                });
              }
              write();
              break;
            }
            case "tool-output-error": {
              const toolInvocation = getToolInvocation(chunk.toolCallId);
              if (toolInvocation.type === "dynamic-tool") {
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: toolInvocation.toolName,
                  state: "output-error",
                  input: toolInvocation.input,
                  errorText: chunk.errorText,
                  providerExecuted: chunk.providerExecuted,
                  title: toolInvocation.title
                });
              } else {
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: getStaticToolName(toolInvocation),
                  state: "output-error",
                  input: toolInvocation.input,
                  rawInput: toolInvocation.rawInput,
                  errorText: chunk.errorText,
                  providerExecuted: chunk.providerExecuted,
                  title: toolInvocation.title
                });
              }
              write();
              break;
            }
            case "start-step": {
              state.message.parts.push({ type: "step-start" });
              break;
            }
            case "finish-step": {
              state.activeTextParts = {};
              state.activeReasoningParts = {};
              break;
            }
            case "start": {
              if (chunk.messageId != null) {
                state.message.id = chunk.messageId;
              }
              await updateMessageMetadata(chunk.messageMetadata);
              if (chunk.messageId != null || chunk.messageMetadata != null) {
                write();
              }
              break;
            }
            case "finish": {
              if (chunk.finishReason != null) {
                state.finishReason = chunk.finishReason;
              }
              await updateMessageMetadata(chunk.messageMetadata);
              if (chunk.messageMetadata != null) {
                write();
              }
              break;
            }
            case "message-metadata": {
              await updateMessageMetadata(chunk.messageMetadata);
              if (chunk.messageMetadata != null) {
                write();
              }
              break;
            }
            case "error": {
              onError2 == null ? void 0 : onError2(new Error(chunk.errorText));
              break;
            }
            default: {
              if (isDataUIMessageChunk(chunk)) {
                if ((dataPartSchemas == null ? void 0 : dataPartSchemas[chunk.type]) != null) {
                  const partIdx = state.message.parts.findIndex(
                    (p) => "id" in p && "data" in p && p.id === chunk.id && p.type === chunk.type
                  );
                  const actualPartIdx = partIdx >= 0 ? partIdx : state.message.parts.length;
                  await validateTypes({
                    value: chunk.data,
                    schema: dataPartSchemas[chunk.type],
                    context: {
                      field: `message.parts[${actualPartIdx}].data`,
                      entityName: chunk.type,
                      entityId: chunk.id
                    }
                  });
                }
                const dataChunk = chunk;
                if (dataChunk.transient) {
                  onData == null ? void 0 : onData(dataChunk);
                  break;
                }
                const existingUIPart = dataChunk.id != null ? state.message.parts.find(
                  (chunkArg) => dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id
                ) : void 0;
                if (existingUIPart != null) {
                  existingUIPart.data = dataChunk.data;
                } else {
                  state.message.parts.push(dataChunk);
                }
                onData == null ? void 0 : onData(dataChunk);
                write();
              }
            }
          }
          controller.enqueue(chunk);
        });
      }
    })
  );
}
function handleUIMessageStreamFinish({
  messageId,
  originalMessages = [],
  onFinish: onFinish2,
  onError: onError2,
  stream
}) {
  let lastMessage = originalMessages == null ? void 0 : originalMessages[originalMessages.length - 1];
  if ((lastMessage == null ? void 0 : lastMessage.role) !== "assistant") {
    lastMessage = void 0;
  } else {
    messageId = lastMessage.id;
  }
  let isAborted = false;
  const idInjectedStream = stream.pipeThrough(
    new TransformStream({
      transform(chunk, controller) {
        if (chunk.type === "start") {
          const startChunk = chunk;
          if (startChunk.messageId == null && messageId != null) {
            startChunk.messageId = messageId;
          }
        }
        if (chunk.type === "abort") {
          isAborted = true;
        }
        controller.enqueue(chunk);
      }
    })
  );
  if (onFinish2 == null) {
    return idInjectedStream;
  }
  const state = createStreamingUIMessageState({
    lastMessage: lastMessage ? structuredClone(lastMessage) : void 0,
    messageId: messageId != null ? messageId : ""
    // will be overridden by the stream
  });
  const runUpdateMessageJob = async (job) => {
    await job({ state, write: () => {
    } });
  };
  let finishCalled = false;
  const callOnFinish = async () => {
    if (finishCalled || !onFinish2) {
      return;
    }
    finishCalled = true;
    const isContinuation = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);
    await onFinish2({
      isAborted,
      isContinuation,
      responseMessage: state.message,
      messages: [
        ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,
        state.message
      ],
      finishReason: state.finishReason
    });
  };
  return processUIMessageStream({
    stream: idInjectedStream,
    runUpdateMessageJob,
    onError: onError2
  }).pipeThrough(
    new TransformStream({
      transform(chunk, controller) {
        controller.enqueue(chunk);
      },
      // @ts-expect-error cancel is still new and missing from types https://developer.mozilla.org/en-US/docs/Web/API/TransformStream#browser_compatibility
      async cancel() {
        await callOnFinish();
      },
      async flush() {
        await callOnFinish();
      }
    })
  );
}
function pipeUIMessageStreamToResponse({
  response,
  status,
  statusText,
  headers,
  stream,
  consumeSseStream
}) {
  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());
  if (consumeSseStream) {
    const [stream1, stream2] = sseStream.tee();
    sseStream = stream1;
    consumeSseStream({ stream: stream2 });
  }
  writeToServerResponse({
    response,
    status,
    statusText,
    headers: Object.fromEntries(
      prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS).entries()
    ),
    stream: sseStream.pipeThrough(new TextEncoderStream())
  });
}
function createAsyncIterableStream(source) {
  const stream = source.pipeThrough(new TransformStream());
  stream[Symbol.asyncIterator] = function() {
    const reader = this.getReader();
    let finished = false;
    async function cleanup(cancelStream) {
      var _a212;
      if (finished)
        return;
      finished = true;
      try {
        if (cancelStream) {
          await ((_a212 = reader.cancel) == null ? void 0 : _a212.call(reader));
        }
      } finally {
        try {
          reader.releaseLock();
        } catch (e) {
        }
      }
    }
    return {
      /**
       * Reads the next chunk from the stream.
       * @returns A promise resolving to the next IteratorResult.
       */
      async next() {
        if (finished) {
          return { done: true, value: void 0 };
        }
        const { done, value: value2 } = await reader.read();
        if (done) {
          await cleanup(true);
          return { done: true, value: void 0 };
        }
        return { done: false, value: value2 };
      },
      /**
       * May be called on early exit (e.g., break from for-await) or after completion.
       * Ensures the stream is cancelled and resources are released.
       * @returns A promise resolving to a completed IteratorResult.
       */
      async return() {
        await cleanup(true);
        return { done: true, value: void 0 };
      },
      /**
       * Called on early exit with error.
       * Ensures the stream is cancelled and resources are released, then rethrows the error.
       * @param err The error to throw.
       * @returns A promise that rejects with the provided error.
       */
      async throw(err) {
        await cleanup(true);
        throw err;
      }
    };
  };
  return stream;
}
async function consumeStream({
  stream,
  onError: onError2
}) {
  const reader = stream.getReader();
  try {
    while (true) {
      const { done } = await reader.read();
      if (done)
        break;
    }
  } catch (error) {
    onError2 == null ? void 0 : onError2(error);
  } finally {
    reader.releaseLock();
  }
}
function createResolvablePromise() {
  let resolve32;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve32 = res;
    reject = rej;
  });
  return {
    promise,
    resolve: resolve32,
    reject
  };
}
function createStitchableStream() {
  let innerStreamReaders = [];
  let controller = null;
  let isClosed = false;
  let waitForNewStream = createResolvablePromise();
  const terminate = () => {
    isClosed = true;
    waitForNewStream.resolve();
    innerStreamReaders.forEach((reader) => reader.cancel());
    innerStreamReaders = [];
    controller == null ? void 0 : controller.close();
  };
  const processPull = async () => {
    if (isClosed && innerStreamReaders.length === 0) {
      controller == null ? void 0 : controller.close();
      return;
    }
    if (innerStreamReaders.length === 0) {
      waitForNewStream = createResolvablePromise();
      await waitForNewStream.promise;
      return processPull();
    }
    try {
      const { value: value2, done } = await innerStreamReaders[0].read();
      if (done) {
        innerStreamReaders.shift();
        if (innerStreamReaders.length === 0 && isClosed) {
          controller == null ? void 0 : controller.close();
        } else {
          await processPull();
        }
      } else {
        controller == null ? void 0 : controller.enqueue(value2);
      }
    } catch (error) {
      controller == null ? void 0 : controller.error(error);
      innerStreamReaders.shift();
      terminate();
    }
  };
  return {
    stream: new ReadableStream({
      start(controllerParam) {
        controller = controllerParam;
      },
      pull: processPull,
      async cancel() {
        for (const reader of innerStreamReaders) {
          await reader.cancel();
        }
        innerStreamReaders = [];
        isClosed = true;
      }
    }),
    addStream: (innerStream) => {
      if (isClosed) {
        throw new Error("Cannot add inner stream: outer stream is closed");
      }
      innerStreamReaders.push(innerStream.getReader());
      waitForNewStream.resolve();
    },
    /**
     * Gracefully close the outer stream. This will let the inner streams
     * finish processing and then close the outer stream.
     */
    close: () => {
      isClosed = true;
      waitForNewStream.resolve();
      if (innerStreamReaders.length === 0) {
        controller == null ? void 0 : controller.close();
      }
    },
    /**
     * Immediately close the outer stream. This will cancel all inner streams
     * and close the outer stream.
     */
    terminate
  };
}
function now() {
  var _a212, _b18;
  return (_b18 = (_a212 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a212.now()) != null ? _b18 : Date.now();
}
function runToolsTransformation({
  tools,
  generatorStream,
  tracer,
  telemetry: telemetry2,
  system,
  messages,
  abortSignal,
  repairToolCall,
  experimental_context,
  generateId: generateId22
}) {
  let toolResultsStreamController = null;
  const toolResultsStream = new ReadableStream({
    start(controller) {
      toolResultsStreamController = controller;
    }
  });
  const outstandingToolResults = /* @__PURE__ */ new Set();
  const toolInputs = /* @__PURE__ */ new Map();
  const toolCallsByToolCallId = /* @__PURE__ */ new Map();
  let canClose = false;
  let finishChunk = void 0;
  function attemptClose() {
    if (canClose && outstandingToolResults.size === 0) {
      if (finishChunk != null) {
        toolResultsStreamController.enqueue(finishChunk);
      }
      toolResultsStreamController.close();
    }
  }
  const forwardStream = new TransformStream({
    async transform(chunk, controller) {
      const chunkType = chunk.type;
      switch (chunkType) {
        case "stream-start":
        case "text-start":
        case "text-delta":
        case "text-end":
        case "reasoning-start":
        case "reasoning-delta":
        case "reasoning-end":
        case "tool-input-start":
        case "tool-input-delta":
        case "tool-input-end":
        case "source":
        case "response-metadata":
        case "error":
        case "raw": {
          controller.enqueue(chunk);
          break;
        }
        case "file": {
          controller.enqueue({
            type: "file",
            file: new DefaultGeneratedFileWithType({
              data: chunk.data,
              mediaType: chunk.mediaType
            })
          });
          break;
        }
        case "finish": {
          finishChunk = {
            type: "finish",
            finishReason: chunk.finishReason.unified,
            rawFinishReason: chunk.finishReason.raw,
            usage: asLanguageModelUsage(chunk.usage),
            providerMetadata: chunk.providerMetadata
          };
          break;
        }
        case "tool-approval-request": {
          const toolCall = toolCallsByToolCallId.get(chunk.toolCallId);
          if (toolCall == null) {
            toolResultsStreamController.enqueue({
              type: "error",
              error: new ToolCallNotFoundForApprovalError({
                toolCallId: chunk.toolCallId,
                approvalId: chunk.approvalId
              })
            });
            break;
          }
          controller.enqueue({
            type: "tool-approval-request",
            approvalId: chunk.approvalId,
            toolCall
          });
          break;
        }
        case "tool-call": {
          try {
            const toolCall = await parseToolCall({
              toolCall: chunk,
              tools,
              repairToolCall,
              system,
              messages
            });
            toolCallsByToolCallId.set(toolCall.toolCallId, toolCall);
            controller.enqueue(toolCall);
            if (toolCall.invalid) {
              toolResultsStreamController.enqueue({
                type: "tool-error",
                toolCallId: toolCall.toolCallId,
                toolName: toolCall.toolName,
                input: toolCall.input,
                error: getErrorMessage2(toolCall.error),
                dynamic: true,
                title: toolCall.title
              });
              break;
            }
            const tool2 = tools == null ? void 0 : tools[toolCall.toolName];
            if (tool2 == null) {
              break;
            }
            if (tool2.onInputAvailable != null) {
              await tool2.onInputAvailable({
                input: toolCall.input,
                toolCallId: toolCall.toolCallId,
                messages,
                abortSignal,
                experimental_context
              });
            }
            if (await isApprovalNeeded({
              tool: tool2,
              toolCall,
              messages,
              experimental_context
            })) {
              toolResultsStreamController.enqueue({
                type: "tool-approval-request",
                approvalId: generateId22(),
                toolCall
              });
              break;
            }
            toolInputs.set(toolCall.toolCallId, toolCall.input);
            if (tool2.execute != null && toolCall.providerExecuted !== true) {
              const toolExecutionId = generateId22();
              outstandingToolResults.add(toolExecutionId);
              executeToolCall({
                toolCall,
                tools,
                tracer,
                telemetry: telemetry2,
                messages,
                abortSignal,
                experimental_context,
                onPreliminaryToolResult: (result) => {
                  toolResultsStreamController.enqueue(result);
                }
              }).then((result) => {
                toolResultsStreamController.enqueue(result);
              }).catch((error) => {
                toolResultsStreamController.enqueue({
                  type: "error",
                  error
                });
              }).finally(() => {
                outstandingToolResults.delete(toolExecutionId);
                attemptClose();
              });
            }
          } catch (error) {
            toolResultsStreamController.enqueue({ type: "error", error });
          }
          break;
        }
        case "tool-result": {
          const toolName = chunk.toolName;
          if (chunk.isError) {
            toolResultsStreamController.enqueue({
              type: "tool-error",
              toolCallId: chunk.toolCallId,
              toolName,
              input: toolInputs.get(chunk.toolCallId),
              providerExecuted: true,
              error: chunk.result,
              dynamic: chunk.dynamic
            });
          } else {
            controller.enqueue({
              type: "tool-result",
              toolCallId: chunk.toolCallId,
              toolName,
              input: toolInputs.get(chunk.toolCallId),
              output: chunk.result,
              providerExecuted: true,
              dynamic: chunk.dynamic
            });
          }
          break;
        }
        default: {
          const _exhaustiveCheck = chunkType;
          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);
        }
      }
    },
    flush() {
      canClose = true;
      attemptClose();
    }
  });
  return new ReadableStream({
    async start(controller) {
      return Promise.all([
        generatorStream.pipeThrough(forwardStream).pipeTo(
          new WritableStream({
            write(chunk) {
              controller.enqueue(chunk);
            },
            close() {
            }
          })
        ),
        toolResultsStream.pipeTo(
          new WritableStream({
            write(chunk) {
              controller.enqueue(chunk);
            },
            close() {
              controller.close();
            }
          })
        )
      ]);
    }
  });
}
function streamText({
  model,
  tools,
  toolChoice,
  system,
  prompt,
  messages,
  maxRetries,
  abortSignal,
  timeout,
  headers,
  stopWhen = stepCountIs(1),
  experimental_output,
  output = experimental_output,
  experimental_telemetry: telemetry2,
  prepareStep,
  providerOptions,
  experimental_activeTools,
  activeTools = experimental_activeTools,
  experimental_repairToolCall: repairToolCall,
  experimental_transform: transform,
  experimental_download: download2,
  includeRawChunks = false,
  onChunk,
  onError: onError2 = ({ error }) => {
    console.error(error);
  },
  onFinish: onFinish2,
  onAbort,
  onStepFinish,
  experimental_context,
  experimental_include: include,
  _internal: { now: now2 = now, generateId: generateId22 = originalGenerateId2 } = {},
  ...settings
}) {
  const totalTimeoutMs = getTotalTimeoutMs(timeout);
  const stepTimeoutMs = getStepTimeoutMs(timeout);
  const chunkTimeoutMs = getChunkTimeoutMs(timeout);
  const stepAbortController = stepTimeoutMs != null ? new AbortController() : void 0;
  const chunkAbortController = chunkTimeoutMs != null ? new AbortController() : void 0;
  return new DefaultStreamTextResult({
    model: resolveLanguageModel(model),
    telemetry: telemetry2,
    headers,
    settings,
    maxRetries,
    abortSignal: mergeAbortSignals(
      abortSignal,
      totalTimeoutMs != null ? AbortSignal.timeout(totalTimeoutMs) : void 0,
      stepAbortController == null ? void 0 : stepAbortController.signal,
      chunkAbortController == null ? void 0 : chunkAbortController.signal
    ),
    stepTimeoutMs,
    stepAbortController,
    chunkTimeoutMs,
    chunkAbortController,
    system,
    prompt,
    messages,
    tools,
    toolChoice,
    transforms: asArray(transform),
    activeTools,
    repairToolCall,
    stopConditions: asArray(stopWhen),
    output,
    providerOptions,
    prepareStep,
    includeRawChunks,
    onChunk,
    onError: onError2,
    onFinish: onFinish2,
    onAbort,
    onStepFinish,
    now: now2,
    generateId: generateId22,
    experimental_context,
    download: download2,
    include
  });
}
function createOutputTransformStream(output) {
  let firstTextChunkId = void 0;
  let text2 = "";
  let textChunk = "";
  let textProviderMetadata = void 0;
  let lastPublishedJson = "";
  function publishTextChunk({
    controller,
    partialOutput = void 0
  }) {
    controller.enqueue({
      part: {
        type: "text-delta",
        id: firstTextChunkId,
        text: textChunk,
        providerMetadata: textProviderMetadata
      },
      partialOutput
    });
    textChunk = "";
  }
  return new TransformStream({
    async transform(chunk, controller) {
      var _a212;
      if (chunk.type === "finish-step" && textChunk.length > 0) {
        publishTextChunk({ controller });
      }
      if (chunk.type !== "text-delta" && chunk.type !== "text-start" && chunk.type !== "text-end") {
        controller.enqueue({ part: chunk, partialOutput: void 0 });
        return;
      }
      if (firstTextChunkId == null) {
        firstTextChunkId = chunk.id;
      } else if (chunk.id !== firstTextChunkId) {
        controller.enqueue({ part: chunk, partialOutput: void 0 });
        return;
      }
      if (chunk.type === "text-start") {
        controller.enqueue({ part: chunk, partialOutput: void 0 });
        return;
      }
      if (chunk.type === "text-end") {
        if (textChunk.length > 0) {
          publishTextChunk({ controller });
        }
        controller.enqueue({ part: chunk, partialOutput: void 0 });
        return;
      }
      text2 += chunk.text;
      textChunk += chunk.text;
      textProviderMetadata = (_a212 = chunk.providerMetadata) != null ? _a212 : textProviderMetadata;
      const result = await output.parsePartialOutput({ text: text2 });
      if (result !== void 0) {
        const currentJson = JSON.stringify(result.partial);
        if (currentJson !== lastPublishedJson) {
          publishTextChunk({ controller, partialOutput: result.partial });
          lastPublishedJson = currentJson;
        }
      }
    }
  });
}
function createUIMessageStream({
  execute,
  onError: onError2 = getErrorMessage2,
  originalMessages,
  onFinish: onFinish2,
  generateId: generateId22 = generateId
}) {
  let controller;
  const ongoingStreamPromises = [];
  const stream = new ReadableStream({
    start(controllerArg) {
      controller = controllerArg;
    }
  });
  function safeEnqueue(data) {
    try {
      controller.enqueue(data);
    } catch (error) {
    }
  }
  try {
    const result = execute({
      writer: {
        write(part) {
          safeEnqueue(part);
        },
        merge(streamArg) {
          ongoingStreamPromises.push(
            (async () => {
              const reader = streamArg.getReader();
              while (true) {
                const { done, value: value2 } = await reader.read();
                if (done)
                  break;
                safeEnqueue(value2);
              }
            })().catch((error) => {
              safeEnqueue({
                type: "error",
                errorText: onError2(error)
              });
            })
          );
        },
        onError: onError2
      }
    });
    if (result) {
      ongoingStreamPromises.push(
        result.catch((error) => {
          safeEnqueue({
            type: "error",
            errorText: onError2(error)
          });
        })
      );
    }
  } catch (error) {
    safeEnqueue({
      type: "error",
      errorText: onError2(error)
    });
  }
  const waitForStreams = new Promise(async (resolve32) => {
    while (ongoingStreamPromises.length > 0) {
      await ongoingStreamPromises.shift();
    }
    resolve32();
  });
  waitForStreams.finally(() => {
    try {
      controller.close();
    } catch (error) {
    }
  });
  return handleUIMessageStreamFinish({
    stream,
    messageId: generateId22(),
    originalMessages,
    onFinish: onFinish2,
    onError: onError2
  });
}
function readUIMessageStream({
  message,
  stream,
  onError: onError2,
  terminateOnError = false
}) {
  var _a212;
  let controller;
  let hasErrored = false;
  const outputStream = new ReadableStream({
    start(controllerParam) {
      controller = controllerParam;
    }
  });
  const state = createStreamingUIMessageState({
    messageId: (_a212 = message == null ? void 0 : message.id) != null ? _a212 : "",
    lastMessage: message
  });
  const handleError = (error) => {
    onError2 == null ? void 0 : onError2(error);
    if (!hasErrored && terminateOnError) {
      hasErrored = true;
      controller == null ? void 0 : controller.error(error);
    }
  };
  consumeStream({
    stream: processUIMessageStream({
      stream,
      runUpdateMessageJob(job) {
        return job({
          state,
          write: () => {
            controller == null ? void 0 : controller.enqueue(structuredClone(state.message));
          }
        });
      },
      onError: handleError
    }),
    onError: handleError
  }).finally(() => {
    if (!hasErrored) {
      controller == null ? void 0 : controller.close();
    }
  });
  return createAsyncIterableStream(outputStream);
}
async function convertToModelMessages(messages, options) {
  const modelMessages = [];
  if (options == null ? void 0 : options.ignoreIncompleteToolCalls) {
    messages = messages.map((message) => ({
      ...message,
      parts: message.parts.filter(
        (part) => !isToolUIPart(part) || part.state !== "input-streaming" && part.state !== "input-available"
      )
    }));
  }
  for (const message of messages) {
    switch (message.role) {
      case "system": {
        const textParts = message.parts.filter(
          (part) => part.type === "text"
        );
        const providerMetadata = textParts.reduce((acc, part) => {
          if (part.providerMetadata != null) {
            return { ...acc, ...part.providerMetadata };
          }
          return acc;
        }, {});
        modelMessages.push({
          role: "system",
          content: textParts.map((part) => part.text).join(""),
          ...Object.keys(providerMetadata).length > 0 ? { providerOptions: providerMetadata } : {}
        });
        break;
      }
      case "user": {
        modelMessages.push({
          role: "user",
          content: message.parts.map((part) => {
            var _a212;
            if (isTextUIPart(part)) {
              return {
                type: "text",
                text: part.text,
                ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}
              };
            }
            if (isFileUIPart(part)) {
              return {
                type: "file",
                mediaType: part.mediaType,
                filename: part.filename,
                data: part.url,
                ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}
              };
            }
            if (isDataUIPart(part)) {
              return (_a212 = options == null ? void 0 : options.convertDataPart) == null ? void 0 : _a212.call(
                options,
                part
              );
            }
          }).filter(isNonNullable)
        });
        break;
      }
      case "assistant": {
        if (message.parts != null) {
          let block = [];
          async function processBlock() {
            var _a212, _b18, _c, _d, _e, _f;
            if (block.length === 0) {
              return;
            }
            const content = [];
            for (const part of block) {
              if (isTextUIPart(part)) {
                content.push({
                  type: "text",
                  text: part.text,
                  ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}
                });
              } else if (isFileUIPart(part)) {
                content.push({
                  type: "file",
                  mediaType: part.mediaType,
                  filename: part.filename,
                  data: part.url
                });
              } else if (isReasoningUIPart(part)) {
                content.push({
                  type: "reasoning",
                  text: part.text,
                  providerOptions: part.providerMetadata
                });
              } else if (isToolUIPart(part)) {
                const toolName = getToolName(part);
                if (part.state !== "input-streaming") {
                  content.push({
                    type: "tool-call",
                    toolCallId: part.toolCallId,
                    toolName,
                    input: part.state === "output-error" ? (_a212 = part.input) != null ? _a212 : "rawInput" in part ? part.rawInput : void 0 : part.input,
                    providerExecuted: part.providerExecuted,
                    ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}
                  });
                  if (part.approval != null) {
                    content.push({
                      type: "tool-approval-request",
                      approvalId: part.approval.id,
                      toolCallId: part.toolCallId
                    });
                  }
                  if (part.providerExecuted === true && part.state !== "approval-responded" && (part.state === "output-available" || part.state === "output-error")) {
                    content.push({
                      type: "tool-result",
                      toolCallId: part.toolCallId,
                      toolName,
                      output: await createToolModelOutput({
                        toolCallId: part.toolCallId,
                        input: part.input,
                        output: part.state === "output-error" ? part.errorText : part.output,
                        tool: (_b18 = options == null ? void 0 : options.tools) == null ? void 0 : _b18[toolName],
                        errorMode: part.state === "output-error" ? "json" : "none"
                      }),
                      ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}
                    });
                  }
                }
              } else if (isDataUIPart(part)) {
                const dataPart = (_c = options == null ? void 0 : options.convertDataPart) == null ? void 0 : _c.call(
                  options,
                  part
                );
                if (dataPart != null) {
                  content.push(dataPart);
                }
              } else {
                const _exhaustiveCheck = part;
                throw new Error(`Unsupported part: ${_exhaustiveCheck}`);
              }
            }
            modelMessages.push({
              role: "assistant",
              content
            });
            const toolParts = block.filter(
              (part) => {
                var _a222;
                return isToolUIPart(part) && (part.providerExecuted !== true || ((_a222 = part.approval) == null ? void 0 : _a222.approved) != null);
              }
            );
            if (toolParts.length > 0) {
              {
                const content2 = [];
                for (const toolPart of toolParts) {
                  if (((_d = toolPart.approval) == null ? void 0 : _d.approved) != null) {
                    content2.push({
                      type: "tool-approval-response",
                      approvalId: toolPart.approval.id,
                      approved: toolPart.approval.approved,
                      reason: toolPart.approval.reason,
                      providerExecuted: toolPart.providerExecuted
                    });
                  }
                  if (toolPart.providerExecuted === true) {
                    continue;
                  }
                  switch (toolPart.state) {
                    case "output-denied": {
                      content2.push({
                        type: "tool-result",
                        toolCallId: toolPart.toolCallId,
                        toolName: getToolName(toolPart),
                        output: {
                          type: "error-text",
                          value: (_e = toolPart.approval.reason) != null ? _e : "Tool execution denied."
                        },
                        ...toolPart.callProviderMetadata != null ? { providerOptions: toolPart.callProviderMetadata } : {}
                      });
                      break;
                    }
                    case "output-error":
                    case "output-available": {
                      const toolName = getToolName(toolPart);
                      content2.push({
                        type: "tool-result",
                        toolCallId: toolPart.toolCallId,
                        toolName,
                        output: await createToolModelOutput({
                          toolCallId: toolPart.toolCallId,
                          input: toolPart.input,
                          output: toolPart.state === "output-error" ? toolPart.errorText : toolPart.output,
                          tool: (_f = options == null ? void 0 : options.tools) == null ? void 0 : _f[toolName],
                          errorMode: toolPart.state === "output-error" ? "text" : "none"
                        }),
                        ...toolPart.callProviderMetadata != null ? { providerOptions: toolPart.callProviderMetadata } : {}
                      });
                      break;
                    }
                  }
                }
                if (content2.length > 0) {
                  modelMessages.push({
                    role: "tool",
                    content: content2
                  });
                }
              }
            }
            block = [];
          }
          for (const part of message.parts) {
            if (isTextUIPart(part) || isReasoningUIPart(part) || isFileUIPart(part) || isToolUIPart(part) || isDataUIPart(part)) {
              block.push(part);
            } else if (part.type === "step-start") {
              await processBlock();
            }
          }
          await processBlock();
          break;
        }
        break;
      }
      default: {
        const _exhaustiveCheck = message.role;
        throw new MessageConversionError({
          originalMessage: message,
          message: `Unsupported role: ${_exhaustiveCheck}`
        });
      }
    }
  }
  return modelMessages;
}
async function safeValidateUIMessages({
  messages,
  metadataSchema,
  dataSchemas,
  tools
}) {
  try {
    if (messages == null) {
      return {
        success: false,
        error: new InvalidArgumentError3({
          parameter: "messages",
          value: messages,
          message: "messages parameter must be provided"
        })
      };
    }
    const validatedMessages = await validateTypes({
      value: messages,
      schema: uiMessagesSchema
    });
    if (metadataSchema) {
      for (const [msgIdx, message] of validatedMessages.entries()) {
        await validateTypes({
          value: message.metadata,
          schema: metadataSchema,
          context: {
            field: `messages[${msgIdx}].metadata`,
            entityId: message.id
          }
        });
      }
    }
    if (dataSchemas || tools) {
      for (const [msgIdx, message] of validatedMessages.entries()) {
        for (const [partIdx, part] of message.parts.entries()) {
          if (dataSchemas && part.type.startsWith("data-")) {
            const dataPart = part;
            const dataName = dataPart.type.slice(5);
            const dataSchema = dataSchemas[dataName];
            if (!dataSchema) {
              return {
                success: false,
                error: new TypeValidationError({
                  value: dataPart.data,
                  cause: `No data schema found for data part ${dataName}`,
                  context: {
                    field: `messages[${msgIdx}].parts[${partIdx}].data`,
                    entityName: dataName,
                    entityId: dataPart.id
                  }
                })
              };
            }
            await validateTypes({
              value: dataPart.data,
              schema: dataSchema,
              context: {
                field: `messages[${msgIdx}].parts[${partIdx}].data`,
                entityName: dataName,
                entityId: dataPart.id
              }
            });
          }
          if (tools && part.type.startsWith("tool-")) {
            const toolPart = part;
            const toolName = toolPart.type.slice(5);
            const tool2 = tools[toolName];
            if (!tool2) {
              return {
                success: false,
                error: new TypeValidationError({
                  value: toolPart.input,
                  cause: `No tool schema found for tool part ${toolName}`,
                  context: {
                    field: `messages[${msgIdx}].parts[${partIdx}].input`,
                    entityName: toolName,
                    entityId: toolPart.toolCallId
                  }
                })
              };
            }
            if (toolPart.state === "input-available" || toolPart.state === "output-available" || toolPart.state === "output-error" && toolPart.input !== void 0) {
              await validateTypes({
                value: toolPart.input,
                schema: tool2.inputSchema,
                context: {
                  field: `messages[${msgIdx}].parts[${partIdx}].input`,
                  entityName: toolName,
                  entityId: toolPart.toolCallId
                }
              });
            }
            if (toolPart.state === "output-available" && tool2.outputSchema) {
              await validateTypes({
                value: toolPart.output,
                schema: tool2.outputSchema,
                context: {
                  field: `messages[${msgIdx}].parts[${partIdx}].output`,
                  entityName: toolName,
                  entityId: toolPart.toolCallId
                }
              });
            }
          }
        }
      }
    }
    return {
      success: true,
      data: validatedMessages
    };
  } catch (error) {
    const err = error;
    return {
      success: false,
      error: err
    };
  }
}
async function validateUIMessages({
  messages,
  metadataSchema,
  dataSchemas,
  tools
}) {
  const response = await safeValidateUIMessages({
    messages,
    metadataSchema,
    dataSchemas,
    tools
  });
  if (!response.success)
    throw response.error;
  return response.data;
}
async function createAgentUIStream({
  agent,
  uiMessages,
  options,
  abortSignal,
  timeout,
  experimental_transform,
  onStepFinish,
  ...uiMessageStreamOptions
}) {
  var _a212;
  const validatedMessages = await validateUIMessages({
    messages: uiMessages,
    tools: agent.tools
  });
  const modelMessages = await convertToModelMessages(validatedMessages, {
    tools: agent.tools
  });
  const result = await agent.stream({
    prompt: modelMessages,
    options,
    abortSignal,
    timeout,
    experimental_transform,
    onStepFinish
  });
  return result.toUIMessageStream({
    ...uiMessageStreamOptions,
    // TODO reading `originalMessages` is here for bc, always use `validatedMessages` in v7
    originalMessages: (_a212 = uiMessageStreamOptions.originalMessages) != null ? _a212 : validatedMessages
  });
}
async function createAgentUIStreamResponse({
  headers,
  status,
  statusText,
  consumeSseStream,
  ...options
}) {
  return createUIMessageStreamResponse({
    headers,
    status,
    statusText,
    consumeSseStream,
    stream: await createAgentUIStream(options)
  });
}
async function pipeAgentUIStreamToResponse({
  response,
  headers,
  status,
  statusText,
  consumeSseStream,
  ...options
}) {
  pipeUIMessageStreamToResponse({
    response,
    headers,
    status,
    statusText,
    consumeSseStream,
    stream: await createAgentUIStream(options)
  });
}
async function embed({
  model: modelArg,
  value: value2,
  providerOptions,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  experimental_telemetry: telemetry2
}) {
  const model = resolveEmbeddingModel(modelArg);
  const { maxRetries, retry } = prepareRetries({
    maxRetries: maxRetriesArg,
    abortSignal
  });
  const headersWithUserAgent = withUserAgentSuffix(
    headers != null ? headers : {},
    `ai/${VERSION4}`
  );
  const baseTelemetryAttributes = getBaseTelemetryAttributes({
    model,
    telemetry: telemetry2,
    headers: headersWithUserAgent,
    settings: { maxRetries }
  });
  const tracer = getTracer(telemetry2);
  return recordSpan({
    name: "ai.embed",
    attributes: selectTelemetryAttributes({
      telemetry: telemetry2,
      attributes: {
        ...assembleOperationName({ operationId: "ai.embed", telemetry: telemetry2 }),
        ...baseTelemetryAttributes,
        "ai.value": { input: () => JSON.stringify(value2) }
      }
    }),
    tracer,
    fn: async (span) => {
      const { embedding, usage, warnings, response, providerMetadata } = await retry(
        () => (
          // nested spans to align with the embedMany telemetry data:
          recordSpan({
            name: "ai.embed.doEmbed",
            attributes: selectTelemetryAttributes({
              telemetry: telemetry2,
              attributes: {
                ...assembleOperationName({
                  operationId: "ai.embed.doEmbed",
                  telemetry: telemetry2
                }),
                ...baseTelemetryAttributes,
                // specific settings that only make sense on the outer level:
                "ai.values": { input: () => [JSON.stringify(value2)] }
              }
            }),
            tracer,
            fn: async (doEmbedSpan) => {
              var _a212;
              const modelResponse = await model.doEmbed({
                values: [value2],
                abortSignal,
                headers: headersWithUserAgent,
                providerOptions
              });
              const embedding2 = modelResponse.embeddings[0];
              const usage2 = (_a212 = modelResponse.usage) != null ? _a212 : { tokens: NaN };
              doEmbedSpan.setAttributes(
                await selectTelemetryAttributes({
                  telemetry: telemetry2,
                  attributes: {
                    "ai.embeddings": {
                      output: () => modelResponse.embeddings.map(
                        (embedding3) => JSON.stringify(embedding3)
                      )
                    },
                    "ai.usage.tokens": usage2.tokens
                  }
                })
              );
              return {
                embedding: embedding2,
                usage: usage2,
                warnings: modelResponse.warnings,
                providerMetadata: modelResponse.providerMetadata,
                response: modelResponse.response
              };
            }
          })
        )
      );
      span.setAttributes(
        await selectTelemetryAttributes({
          telemetry: telemetry2,
          attributes: {
            "ai.embedding": { output: () => JSON.stringify(embedding) },
            "ai.usage.tokens": usage.tokens
          }
        })
      );
      logWarnings({ warnings, provider: model.provider, model: model.modelId });
      return new DefaultEmbedResult({
        value: value2,
        embedding,
        usage,
        warnings,
        providerMetadata,
        response
      });
    }
  });
}
function splitArray(array2, chunkSize) {
  if (chunkSize <= 0) {
    throw new Error("chunkSize must be greater than 0");
  }
  const result = [];
  for (let i = 0; i < array2.length; i += chunkSize) {
    result.push(array2.slice(i, i + chunkSize));
  }
  return result;
}
async function embedMany({
  model: modelArg,
  values,
  maxParallelCalls = Infinity,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  providerOptions,
  experimental_telemetry: telemetry2
}) {
  const model = resolveEmbeddingModel(modelArg);
  const { maxRetries, retry } = prepareRetries({
    maxRetries: maxRetriesArg,
    abortSignal
  });
  const headersWithUserAgent = withUserAgentSuffix(
    headers != null ? headers : {},
    `ai/${VERSION4}`
  );
  const baseTelemetryAttributes = getBaseTelemetryAttributes({
    model,
    telemetry: telemetry2,
    headers: headersWithUserAgent,
    settings: { maxRetries }
  });
  const tracer = getTracer(telemetry2);
  return recordSpan({
    name: "ai.embedMany",
    attributes: selectTelemetryAttributes({
      telemetry: telemetry2,
      attributes: {
        ...assembleOperationName({ operationId: "ai.embedMany", telemetry: telemetry2 }),
        ...baseTelemetryAttributes,
        // specific settings that only make sense on the outer level:
        "ai.values": {
          input: () => values.map((value2) => JSON.stringify(value2))
        }
      }
    }),
    tracer,
    fn: async (span) => {
      var _a212;
      const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([
        model.maxEmbeddingsPerCall,
        model.supportsParallelCalls
      ]);
      if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {
        const { embeddings: embeddings2, usage, warnings: warnings2, response, providerMetadata: providerMetadata2 } = await retry(() => {
          return recordSpan({
            name: "ai.embedMany.doEmbed",
            attributes: selectTelemetryAttributes({
              telemetry: telemetry2,
              attributes: {
                ...assembleOperationName({
                  operationId: "ai.embedMany.doEmbed",
                  telemetry: telemetry2
                }),
                ...baseTelemetryAttributes,
                // specific settings that only make sense on the outer level:
                "ai.values": {
                  input: () => values.map((value2) => JSON.stringify(value2))
                }
              }
            }),
            tracer,
            fn: async (doEmbedSpan) => {
              var _a222;
              const modelResponse = await model.doEmbed({
                values,
                abortSignal,
                headers: headersWithUserAgent,
                providerOptions
              });
              const embeddings3 = modelResponse.embeddings;
              const usage2 = (_a222 = modelResponse.usage) != null ? _a222 : { tokens: NaN };
              doEmbedSpan.setAttributes(
                await selectTelemetryAttributes({
                  telemetry: telemetry2,
                  attributes: {
                    "ai.embeddings": {
                      output: () => embeddings3.map(
                        (embedding) => JSON.stringify(embedding)
                      )
                    },
                    "ai.usage.tokens": usage2.tokens
                  }
                })
              );
              return {
                embeddings: embeddings3,
                usage: usage2,
                warnings: modelResponse.warnings,
                providerMetadata: modelResponse.providerMetadata,
                response: modelResponse.response
              };
            }
          });
        });
        span.setAttributes(
          await selectTelemetryAttributes({
            telemetry: telemetry2,
            attributes: {
              "ai.embeddings": {
                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))
              },
              "ai.usage.tokens": usage.tokens
            }
          })
        );
        logWarnings({
          warnings: warnings2,
          provider: model.provider,
          model: model.modelId
        });
        return new DefaultEmbedManyResult({
          values,
          embeddings: embeddings2,
          usage,
          warnings: warnings2,
          providerMetadata: providerMetadata2,
          responses: [response]
        });
      }
      const valueChunks = splitArray(values, maxEmbeddingsPerCall);
      const embeddings = [];
      const warnings = [];
      const responses = [];
      let tokens = 0;
      let providerMetadata;
      const parallelChunks = splitArray(
        valueChunks,
        supportsParallelCalls ? maxParallelCalls : 1
      );
      for (const parallelChunk of parallelChunks) {
        const results = await Promise.all(
          parallelChunk.map((chunk) => {
            return retry(() => {
              return recordSpan({
                name: "ai.embedMany.doEmbed",
                attributes: selectTelemetryAttributes({
                  telemetry: telemetry2,
                  attributes: {
                    ...assembleOperationName({
                      operationId: "ai.embedMany.doEmbed",
                      telemetry: telemetry2
                    }),
                    ...baseTelemetryAttributes,
                    // specific settings that only make sense on the outer level:
                    "ai.values": {
                      input: () => chunk.map((value2) => JSON.stringify(value2))
                    }
                  }
                }),
                tracer,
                fn: async (doEmbedSpan) => {
                  var _a222;
                  const modelResponse = await model.doEmbed({
                    values: chunk,
                    abortSignal,
                    headers: headersWithUserAgent,
                    providerOptions
                  });
                  const embeddings2 = modelResponse.embeddings;
                  const usage = (_a222 = modelResponse.usage) != null ? _a222 : { tokens: NaN };
                  doEmbedSpan.setAttributes(
                    await selectTelemetryAttributes({
                      telemetry: telemetry2,
                      attributes: {
                        "ai.embeddings": {
                          output: () => embeddings2.map(
                            (embedding) => JSON.stringify(embedding)
                          )
                        },
                        "ai.usage.tokens": usage.tokens
                      }
                    })
                  );
                  return {
                    embeddings: embeddings2,
                    usage,
                    warnings: modelResponse.warnings,
                    providerMetadata: modelResponse.providerMetadata,
                    response: modelResponse.response
                  };
                }
              });
            });
          })
        );
        for (const result of results) {
          embeddings.push(...result.embeddings);
          warnings.push(...result.warnings);
          responses.push(result.response);
          tokens += result.usage.tokens;
          if (result.providerMetadata) {
            if (!providerMetadata) {
              providerMetadata = { ...result.providerMetadata };
            } else {
              for (const [providerName, metadata] of Object.entries(
                result.providerMetadata
              )) {
                providerMetadata[providerName] = {
                  ...(_a212 = providerMetadata[providerName]) != null ? _a212 : {},
                  ...metadata
                };
              }
            }
          }
        }
      }
      span.setAttributes(
        await selectTelemetryAttributes({
          telemetry: telemetry2,
          attributes: {
            "ai.embeddings": {
              output: () => embeddings.map((embedding) => JSON.stringify(embedding))
            },
            "ai.usage.tokens": tokens
          }
        })
      );
      logWarnings({
        warnings,
        provider: model.provider,
        model: model.modelId
      });
      return new DefaultEmbedManyResult({
        values,
        embeddings,
        usage: { tokens },
        warnings,
        providerMetadata,
        responses
      });
    }
  });
}
async function generateImage({
  model: modelArg,
  prompt: promptArg,
  n = 1,
  maxImagesPerCall,
  size,
  aspectRatio,
  seed,
  providerOptions,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers
}) {
  var _a212, _b18;
  const model = resolveImageModel(modelArg);
  const headersWithUserAgent = withUserAgentSuffix(
    headers != null ? headers : {},
    `ai/${VERSION4}`
  );
  const { retry } = prepareRetries({
    maxRetries: maxRetriesArg,
    abortSignal
  });
  const maxImagesPerCallWithDefault = (_a212 = maxImagesPerCall != null ? maxImagesPerCall : await invokeModelMaxImagesPerCall(model)) != null ? _a212 : 1;
  const callCount = Math.ceil(n / maxImagesPerCallWithDefault);
  const callImageCounts = Array.from({ length: callCount }, (_, i) => {
    if (i < callCount - 1) {
      return maxImagesPerCallWithDefault;
    }
    const remainder = n % maxImagesPerCallWithDefault;
    return remainder === 0 ? maxImagesPerCallWithDefault : remainder;
  });
  const results = await Promise.all(
    callImageCounts.map(
      async (callImageCount) => retry(() => {
        const { prompt, files, mask } = normalizePrompt(promptArg);
        return model.doGenerate({
          prompt,
          files,
          mask,
          n: callImageCount,
          abortSignal,
          headers: headersWithUserAgent,
          size,
          aspectRatio,
          seed,
          providerOptions: providerOptions != null ? providerOptions : {}
        });
      })
    )
  );
  const images = [];
  const warnings = [];
  const responses = [];
  const providerMetadata = {};
  let totalUsage = {
    inputTokens: void 0,
    outputTokens: void 0,
    totalTokens: void 0
  };
  for (const result of results) {
    images.push(
      ...result.images.map(
        (image) => {
          var _a222;
          return new DefaultGeneratedFile({
            data: image,
            mediaType: (_a222 = detectMediaType({
              data: image,
              signatures: imageMediaTypeSignatures
            })) != null ? _a222 : "image/png"
          });
        }
      )
    );
    warnings.push(...result.warnings);
    if (result.usage != null) {
      totalUsage = addImageModelUsage(totalUsage, result.usage);
    }
    if (result.providerMetadata) {
      for (const [providerName, metadata] of Object.entries(result.providerMetadata)) {
        if (providerName === "gateway") {
          const currentEntry = providerMetadata[providerName];
          if (currentEntry != null && typeof currentEntry === "object") {
            providerMetadata[providerName] = {
              ...currentEntry,
              ...metadata
            };
          } else {
            providerMetadata[providerName] = metadata;
          }
          const imagesValue = providerMetadata[providerName].images;
          if (Array.isArray(imagesValue) && imagesValue.length === 0) {
            delete providerMetadata[providerName].images;
          }
        } else {
          (_b18 = providerMetadata[providerName]) != null ? _b18 : providerMetadata[providerName] = { images: [] };
          providerMetadata[providerName].images.push(
            ...result.providerMetadata[providerName].images
          );
        }
      }
    }
    responses.push(result.response);
  }
  logWarnings({ warnings, provider: model.provider, model: model.modelId });
  if (!images.length) {
    throw new NoImageGeneratedError({ responses });
  }
  return new DefaultGenerateImageResult({
    images,
    warnings,
    responses,
    providerMetadata,
    usage: totalUsage
  });
}
async function invokeModelMaxImagesPerCall(model) {
  const isFunction = model.maxImagesPerCall instanceof Function;
  if (!isFunction) {
    return model.maxImagesPerCall;
  }
  return model.maxImagesPerCall({
    modelId: model.modelId
  });
}
function normalizePrompt(prompt) {
  if (typeof prompt === "string") {
    return { prompt, files: void 0, mask: void 0 };
  }
  return {
    prompt: prompt.text,
    files: prompt.images.map(toImageModelV3File),
    mask: prompt.mask ? toImageModelV3File(prompt.mask) : void 0
  };
}
function toImageModelV3File(dataContent) {
  if (typeof dataContent === "string" && dataContent.startsWith("http")) {
    return {
      type: "url",
      url: dataContent
    };
  }
  if (typeof dataContent === "string" && dataContent.startsWith("data:")) {
    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(dataContent);
    if (base64Content != null) {
      const uint8Data2 = convertBase64ToUint8Array(base64Content);
      return {
        type: "file",
        data: uint8Data2,
        mediaType: dataUrlMediaType || detectMediaType({
          data: uint8Data2,
          signatures: imageMediaTypeSignatures
        }) || "image/png"
      };
    }
  }
  const uint8Data = convertDataContentToUint8Array(dataContent);
  return {
    type: "file",
    data: uint8Data,
    mediaType: detectMediaType({
      data: uint8Data,
      signatures: imageMediaTypeSignatures
    }) || "image/png"
  };
}
function extractReasoningContent(content) {
  const parts = content.filter(
    (content2) => content2.type === "reasoning"
  );
  return parts.length === 0 ? void 0 : parts.map((content2) => content2.text).join("\n");
}
function getOutputStrategy({
  output,
  schema,
  enumValues
}) {
  switch (output) {
    case "object":
      return objectOutputStrategy(asSchema(schema));
    case "array":
      return arrayOutputStrategy(asSchema(schema));
    case "enum":
      return enumOutputStrategy(enumValues);
    case "no-schema":
      return noSchemaOutputStrategy;
    default: {
      const _exhaustiveCheck = output;
      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);
    }
  }
}
async function parseAndValidateObjectResult(result, outputStrategy, context2) {
  const parseResult = await safeParseJSON({ text: result });
  if (!parseResult.success) {
    throw new NoObjectGeneratedError({
      message: "No object generated: could not parse the response.",
      cause: parseResult.error,
      text: result,
      response: context2.response,
      usage: context2.usage,
      finishReason: context2.finishReason
    });
  }
  const validationResult = await outputStrategy.validateFinalResult(
    parseResult.value,
    {
      text: result,
      response: context2.response,
      usage: context2.usage
    }
  );
  if (!validationResult.success) {
    throw new NoObjectGeneratedError({
      message: "No object generated: response did not match schema.",
      cause: validationResult.error,
      text: result,
      response: context2.response,
      usage: context2.usage,
      finishReason: context2.finishReason
    });
  }
  return validationResult.value;
}
async function parseAndValidateObjectResultWithRepair(result, outputStrategy, repairText, context2) {
  try {
    return await parseAndValidateObjectResult(result, outputStrategy, context2);
  } catch (error) {
    if (repairText != null && NoObjectGeneratedError.isInstance(error) && (JSONParseError.isInstance(error.cause) || TypeValidationError.isInstance(error.cause))) {
      const repairedText = await repairText({
        text: result,
        error: error.cause
      });
      if (repairedText === null) {
        throw error;
      }
      return await parseAndValidateObjectResult(
        repairedText,
        outputStrategy,
        context2
      );
    }
    throw error;
  }
}
function validateObjectGenerationInput({
  output,
  schema,
  schemaName,
  schemaDescription,
  enumValues
}) {
  if (output != null && output !== "object" && output !== "array" && output !== "enum" && output !== "no-schema") {
    throw new InvalidArgumentError3({
      parameter: "output",
      value: output,
      message: "Invalid output type."
    });
  }
  if (output === "no-schema") {
    if (schema != null) {
      throw new InvalidArgumentError3({
        parameter: "schema",
        value: schema,
        message: "Schema is not supported for no-schema output."
      });
    }
    if (schemaDescription != null) {
      throw new InvalidArgumentError3({
        parameter: "schemaDescription",
        value: schemaDescription,
        message: "Schema description is not supported for no-schema output."
      });
    }
    if (schemaName != null) {
      throw new InvalidArgumentError3({
        parameter: "schemaName",
        value: schemaName,
        message: "Schema name is not supported for no-schema output."
      });
    }
    if (enumValues != null) {
      throw new InvalidArgumentError3({
        parameter: "enumValues",
        value: enumValues,
        message: "Enum values are not supported for no-schema output."
      });
    }
  }
  if (output === "object") {
    if (schema == null) {
      throw new InvalidArgumentError3({
        parameter: "schema",
        value: schema,
        message: "Schema is required for object output."
      });
    }
    if (enumValues != null) {
      throw new InvalidArgumentError3({
        parameter: "enumValues",
        value: enumValues,
        message: "Enum values are not supported for object output."
      });
    }
  }
  if (output === "array") {
    if (schema == null) {
      throw new InvalidArgumentError3({
        parameter: "schema",
        value: schema,
        message: "Element schema is required for array output."
      });
    }
    if (enumValues != null) {
      throw new InvalidArgumentError3({
        parameter: "enumValues",
        value: enumValues,
        message: "Enum values are not supported for array output."
      });
    }
  }
  if (output === "enum") {
    if (schema != null) {
      throw new InvalidArgumentError3({
        parameter: "schema",
        value: schema,
        message: "Schema is not supported for enum output."
      });
    }
    if (schemaDescription != null) {
      throw new InvalidArgumentError3({
        parameter: "schemaDescription",
        value: schemaDescription,
        message: "Schema description is not supported for enum output."
      });
    }
    if (schemaName != null) {
      throw new InvalidArgumentError3({
        parameter: "schemaName",
        value: schemaName,
        message: "Schema name is not supported for enum output."
      });
    }
    if (enumValues == null) {
      throw new InvalidArgumentError3({
        parameter: "enumValues",
        value: enumValues,
        message: "Enum values are required for enum output."
      });
    }
    for (const value2 of enumValues) {
      if (typeof value2 !== "string") {
        throw new InvalidArgumentError3({
          parameter: "enumValues",
          value: value2,
          message: "Enum values must be strings."
        });
      }
    }
  }
}
async function generateObject(options) {
  const {
    model: modelArg,
    output = "object",
    system,
    prompt,
    messages,
    maxRetries: maxRetriesArg,
    abortSignal,
    headers,
    experimental_repairText: repairText,
    experimental_telemetry: telemetry2,
    experimental_download: download2,
    providerOptions,
    _internal: {
      generateId: generateId22 = originalGenerateId3,
      currentDate = () => /* @__PURE__ */ new Date()
    } = {},
    ...settings
  } = options;
  const model = resolveLanguageModel(modelArg);
  const enumValues = "enum" in options ? options.enum : void 0;
  const {
    schema: inputSchema,
    schemaDescription,
    schemaName
  } = "schema" in options ? options : {};
  validateObjectGenerationInput({
    output,
    schema: inputSchema,
    schemaName,
    schemaDescription,
    enumValues
  });
  const { maxRetries, retry } = prepareRetries({
    maxRetries: maxRetriesArg,
    abortSignal
  });
  const outputStrategy = getOutputStrategy({
    output,
    schema: inputSchema,
    enumValues
  });
  const callSettings = prepareCallSettings(settings);
  const headersWithUserAgent = withUserAgentSuffix(
    headers != null ? headers : {},
    `ai/${VERSION4}`
  );
  const baseTelemetryAttributes = getBaseTelemetryAttributes({
    model,
    telemetry: telemetry2,
    headers: headersWithUserAgent,
    settings: { ...callSettings, maxRetries }
  });
  const tracer = getTracer(telemetry2);
  const jsonSchema22 = await outputStrategy.jsonSchema();
  try {
    return await recordSpan({
      name: "ai.generateObject",
      attributes: selectTelemetryAttributes({
        telemetry: telemetry2,
        attributes: {
          ...assembleOperationName({
            operationId: "ai.generateObject",
            telemetry: telemetry2
          }),
          ...baseTelemetryAttributes,
          // specific settings that only make sense on the outer level:
          "ai.prompt": {
            input: () => JSON.stringify({ system, prompt, messages })
          },
          "ai.schema": jsonSchema22 != null ? { input: () => JSON.stringify(jsonSchema22) } : void 0,
          "ai.schema.name": schemaName,
          "ai.schema.description": schemaDescription,
          "ai.settings.output": outputStrategy.type
        }
      }),
      tracer,
      fn: async (span) => {
        var _a212;
        let result;
        let finishReason;
        let usage;
        let warnings;
        let response;
        let request;
        let resultProviderMetadata;
        let reasoning;
        const standardizedPrompt = await standardizePrompt({
          system,
          prompt,
          messages
        });
        const promptMessages = await convertToLanguageModelPrompt({
          prompt: standardizedPrompt,
          supportedUrls: await model.supportedUrls,
          download: download2
        });
        const generateResult = await retry(
          () => recordSpan({
            name: "ai.generateObject.doGenerate",
            attributes: selectTelemetryAttributes({
              telemetry: telemetry2,
              attributes: {
                ...assembleOperationName({
                  operationId: "ai.generateObject.doGenerate",
                  telemetry: telemetry2
                }),
                ...baseTelemetryAttributes,
                "ai.prompt.messages": {
                  input: () => stringifyForTelemetry(promptMessages)
                },
                // standardized gen-ai llm span attributes:
                "gen_ai.system": model.provider,
                "gen_ai.request.model": model.modelId,
                "gen_ai.request.frequency_penalty": callSettings.frequencyPenalty,
                "gen_ai.request.max_tokens": callSettings.maxOutputTokens,
                "gen_ai.request.presence_penalty": callSettings.presencePenalty,
                "gen_ai.request.temperature": callSettings.temperature,
                "gen_ai.request.top_k": callSettings.topK,
                "gen_ai.request.top_p": callSettings.topP
              }
            }),
            tracer,
            fn: async (span2) => {
              var _a222, _b18, _c, _d, _e, _f, _g, _h;
              const result2 = await model.doGenerate({
                responseFormat: {
                  type: "json",
                  schema: jsonSchema22,
                  name: schemaName,
                  description: schemaDescription
                },
                ...prepareCallSettings(settings),
                prompt: promptMessages,
                providerOptions,
                abortSignal,
                headers: headersWithUserAgent
              });
              const responseData = {
                id: (_b18 = (_a222 = result2.response) == null ? void 0 : _a222.id) != null ? _b18 : generateId22(),
                timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),
                modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId,
                headers: (_g = result2.response) == null ? void 0 : _g.headers,
                body: (_h = result2.response) == null ? void 0 : _h.body
              };
              const text2 = extractTextContent(result2.content);
              const reasoning2 = extractReasoningContent(result2.content);
              if (text2 === void 0) {
                throw new NoObjectGeneratedError({
                  message: "No object generated: the model did not return a response.",
                  response: responseData,
                  usage: asLanguageModelUsage(result2.usage),
                  finishReason: result2.finishReason.unified
                });
              }
              span2.setAttributes(
                await selectTelemetryAttributes({
                  telemetry: telemetry2,
                  attributes: {
                    "ai.response.finishReason": result2.finishReason.unified,
                    "ai.response.object": { output: () => text2 },
                    "ai.response.id": responseData.id,
                    "ai.response.model": responseData.modelId,
                    "ai.response.timestamp": responseData.timestamp.toISOString(),
                    "ai.response.providerMetadata": JSON.stringify(
                      result2.providerMetadata
                    ),
                    // TODO rename telemetry attributes to inputTokens and outputTokens
                    "ai.usage.promptTokens": result2.usage.inputTokens.total,
                    "ai.usage.completionTokens": result2.usage.outputTokens.total,
                    // standardized gen-ai llm span attributes:
                    "gen_ai.response.finish_reasons": [
                      result2.finishReason.unified
                    ],
                    "gen_ai.response.id": responseData.id,
                    "gen_ai.response.model": responseData.modelId,
                    "gen_ai.usage.input_tokens": result2.usage.inputTokens.total,
                    "gen_ai.usage.output_tokens": result2.usage.outputTokens.total
                  }
                })
              );
              return {
                ...result2,
                objectText: text2,
                reasoning: reasoning2,
                responseData
              };
            }
          })
        );
        result = generateResult.objectText;
        finishReason = generateResult.finishReason.unified;
        usage = asLanguageModelUsage(generateResult.usage);
        warnings = generateResult.warnings;
        resultProviderMetadata = generateResult.providerMetadata;
        request = (_a212 = generateResult.request) != null ? _a212 : {};
        response = generateResult.responseData;
        reasoning = generateResult.reasoning;
        logWarnings({
          warnings,
          provider: model.provider,
          model: model.modelId
        });
        const object2 = await parseAndValidateObjectResultWithRepair(
          result,
          outputStrategy,
          repairText,
          {
            response,
            usage,
            finishReason
          }
        );
        span.setAttributes(
          await selectTelemetryAttributes({
            telemetry: telemetry2,
            attributes: {
              "ai.response.finishReason": finishReason,
              "ai.response.object": {
                output: () => JSON.stringify(object2)
              },
              "ai.response.providerMetadata": JSON.stringify(
                resultProviderMetadata
              ),
              // TODO rename telemetry attributes to inputTokens and outputTokens
              "ai.usage.promptTokens": usage.inputTokens,
              "ai.usage.completionTokens": usage.outputTokens
            }
          })
        );
        return new DefaultGenerateObjectResult({
          object: object2,
          reasoning,
          finishReason,
          usage,
          warnings,
          request,
          response,
          providerMetadata: resultProviderMetadata
        });
      }
    });
  } catch (error) {
    throw wrapGatewayError(error);
  }
}
function cosineSimilarity(vector1, vector2) {
  if (vector1.length !== vector2.length) {
    throw new InvalidArgumentError3({
      parameter: "vector1,vector2",
      value: { vector1Length: vector1.length, vector2Length: vector2.length },
      message: `Vectors must have the same length`
    });
  }
  const n = vector1.length;
  if (n === 0) {
    return 0;
  }
  let magnitudeSquared1 = 0;
  let magnitudeSquared2 = 0;
  let dotProduct = 0;
  for (let i = 0; i < n; i++) {
    const value1 = vector1[i];
    const value2 = vector2[i];
    magnitudeSquared1 += value1 * value1;
    magnitudeSquared2 += value2 * value2;
    dotProduct += value1 * value2;
  }
  return magnitudeSquared1 === 0 || magnitudeSquared2 === 0 ? 0 : dotProduct / (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));
}
function getTextFromDataUrl(dataUrl) {
  const [header, base64Content] = dataUrl.split(",");
  const mediaType = header.split(";")[0].split(":")[1];
  if (mediaType == null || base64Content == null) {
    throw new Error("Invalid data URL format");
  }
  try {
    return window.atob(base64Content);
  } catch (error) {
    throw new Error(`Error decoding data URL`);
  }
}
function isDeepEqualData(obj1, obj2) {
  if (obj1 === obj2)
    return true;
  if (obj1 == null || obj2 == null)
    return false;
  if (typeof obj1 !== "object" && typeof obj2 !== "object")
    return obj1 === obj2;
  if (obj1.constructor !== obj2.constructor)
    return false;
  if (obj1 instanceof Date && obj2 instanceof Date) {
    return obj1.getTime() === obj2.getTime();
  }
  if (Array.isArray(obj1)) {
    if (obj1.length !== obj2.length)
      return false;
    for (let i = 0; i < obj1.length; i++) {
      if (!isDeepEqualData(obj1[i], obj2[i]))
        return false;
    }
    return true;
  }
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  if (keys1.length !== keys2.length)
    return false;
  for (const key of keys1) {
    if (!keys2.includes(key))
      return false;
    if (!isDeepEqualData(obj1[key], obj2[key]))
      return false;
  }
  return true;
}
function simulateReadableStream({
  chunks,
  initialDelayInMs = 0,
  chunkDelayInMs = 0,
  _internal
}) {
  var _a212;
  const delay2 = (_a212 = _internal == null ? void 0 : _internal.delay) != null ? _a212 : delay;
  let index = 0;
  return new ReadableStream({
    async pull(controller) {
      if (index < chunks.length) {
        await delay2(index === 0 ? initialDelayInMs : chunkDelayInMs);
        controller.enqueue(chunks[index++]);
      } else {
        controller.close();
      }
    }
  });
}
function streamObject(options) {
  const {
    model,
    output = "object",
    system,
    prompt,
    messages,
    maxRetries,
    abortSignal,
    headers,
    experimental_repairText: repairText,
    experimental_telemetry: telemetry2,
    experimental_download: download2,
    providerOptions,
    onError: onError2 = ({ error }) => {
      console.error(error);
    },
    onFinish: onFinish2,
    _internal: {
      generateId: generateId22 = originalGenerateId4,
      currentDate = () => /* @__PURE__ */ new Date(),
      now: now2 = now
    } = {},
    ...settings
  } = options;
  const enumValues = "enum" in options && options.enum ? options.enum : void 0;
  const {
    schema: inputSchema,
    schemaDescription,
    schemaName
  } = "schema" in options ? options : {};
  validateObjectGenerationInput({
    output,
    schema: inputSchema,
    schemaName,
    schemaDescription,
    enumValues
  });
  const outputStrategy = getOutputStrategy({
    output,
    schema: inputSchema,
    enumValues
  });
  return new DefaultStreamObjectResult({
    model,
    telemetry: telemetry2,
    headers,
    settings,
    maxRetries,
    abortSignal,
    outputStrategy,
    system,
    prompt,
    messages,
    schemaName,
    schemaDescription,
    providerOptions,
    repairText,
    onError: onError2,
    onFinish: onFinish2,
    download: download2,
    generateId: generateId22,
    currentDate,
    now: now2
  });
}
async function generateSpeech({
  model,
  text: text2,
  voice: voice2,
  outputFormat,
  instructions,
  speed,
  language,
  providerOptions = {},
  maxRetries: maxRetriesArg,
  abortSignal,
  headers
}) {
  var _a212;
  const resolvedModel = resolveSpeechModel(model);
  if (!resolvedModel) {
    throw new Error("Model could not be resolved");
  }
  const headersWithUserAgent = withUserAgentSuffix(
    headers != null ? headers : {},
    `ai/${VERSION4}`
  );
  const { retry } = prepareRetries({
    maxRetries: maxRetriesArg,
    abortSignal
  });
  const result = await retry(
    () => resolvedModel.doGenerate({
      text: text2,
      voice: voice2,
      outputFormat,
      instructions,
      speed,
      language,
      abortSignal,
      headers: headersWithUserAgent,
      providerOptions
    })
  );
  if (!result.audio || result.audio.length === 0) {
    throw new NoSpeechGeneratedError({ responses: [result.response] });
  }
  logWarnings({
    warnings: result.warnings,
    provider: resolvedModel.provider,
    model: resolvedModel.modelId
  });
  return new DefaultSpeechResult({
    audio: new DefaultGeneratedAudioFile({
      data: result.audio,
      mediaType: (_a212 = detectMediaType({
        data: result.audio,
        signatures: audioMediaTypeSignatures
      })) != null ? _a212 : "audio/mp3"
    }),
    warnings: result.warnings,
    responses: [result.response],
    providerMetadata: result.providerMetadata
  });
}
function pruneMessages({
  messages,
  reasoning = "none",
  toolCalls = [],
  emptyMessages = "remove"
}) {
  if (reasoning === "all" || reasoning === "before-last-message") {
    messages = messages.map((message, messageIndex) => {
      if (message.role !== "assistant" || typeof message.content === "string" || reasoning === "before-last-message" && messageIndex === messages.length - 1) {
        return message;
      }
      return {
        ...message,
        content: message.content.filter((part) => part.type !== "reasoning")
      };
    });
  }
  if (toolCalls === "none") {
    toolCalls = [];
  } else if (toolCalls === "all") {
    toolCalls = [{ type: "all" }];
  } else if (toolCalls === "before-last-message") {
    toolCalls = [{ type: "before-last-message" }];
  } else if (typeof toolCalls === "string") {
    toolCalls = [{ type: toolCalls }];
  }
  for (const toolCall of toolCalls) {
    const keepLastMessagesCount = toolCall.type === "all" ? void 0 : toolCall.type === "before-last-message" ? 1 : Number(
      toolCall.type.slice("before-last-".length).slice(0, -"-messages".length)
    );
    const keptToolCallIds = /* @__PURE__ */ new Set();
    const keptApprovalIds = /* @__PURE__ */ new Set();
    if (keepLastMessagesCount != null) {
      for (const message of messages.slice(-keepLastMessagesCount)) {
        if ((message.role === "assistant" || message.role === "tool") && typeof message.content !== "string") {
          for (const part of message.content) {
            if (part.type === "tool-call" || part.type === "tool-result") {
              keptToolCallIds.add(part.toolCallId);
            } else if (part.type === "tool-approval-request" || part.type === "tool-approval-response") {
              keptApprovalIds.add(part.approvalId);
            }
          }
        }
      }
    }
    messages = messages.map((message, messageIndex) => {
      if (message.role !== "assistant" && message.role !== "tool" || typeof message.content === "string" || keepLastMessagesCount && messageIndex >= messages.length - keepLastMessagesCount) {
        return message;
      }
      const toolCallIdToToolName = {};
      const approvalIdToToolName = {};
      return {
        ...message,
        content: message.content.filter((part) => {
          if (part.type !== "tool-call" && part.type !== "tool-result" && part.type !== "tool-approval-request" && part.type !== "tool-approval-response") {
            return true;
          }
          if (part.type === "tool-call") {
            toolCallIdToToolName[part.toolCallId] = part.toolName;
          } else if (part.type === "tool-approval-request") {
            approvalIdToToolName[part.approvalId] = toolCallIdToToolName[part.toolCallId];
          }
          if ((part.type === "tool-call" || part.type === "tool-result") && keptToolCallIds.has(part.toolCallId) || (part.type === "tool-approval-request" || part.type === "tool-approval-response") && keptApprovalIds.has(part.approvalId)) {
            return true;
          }
          return toolCall.tools != null && !toolCall.tools.includes(
            part.type === "tool-call" || part.type === "tool-result" ? part.toolName : approvalIdToToolName[part.approvalId]
          );
        })
      };
    });
  }
  if (emptyMessages === "remove") {
    messages = messages.filter((message) => message.content.length > 0);
  }
  return messages;
}
function smoothStream({
  delayInMs = 10,
  chunking = "word",
  _internal: { delay: delay2 = delay } = {}
} = {}) {
  let detectChunk;
  if (chunking != null && typeof chunking === "object" && "segment" in chunking && typeof chunking.segment === "function") {
    const segmenter = chunking;
    detectChunk = (buffer) => {
      if (buffer.length === 0)
        return null;
      const iterator = segmenter.segment(buffer)[Symbol.iterator]();
      const first = iterator.next().value;
      return (first == null ? void 0 : first.segment) || null;
    };
  } else if (typeof chunking === "function") {
    detectChunk = (buffer) => {
      const match = chunking(buffer);
      if (match == null) {
        return null;
      }
      if (!match.length) {
        throw new Error(`Chunking function must return a non-empty string.`);
      }
      if (!buffer.startsWith(match)) {
        throw new Error(
          `Chunking function must return a match that is a prefix of the buffer. Received: "${match}" expected to start with "${buffer}"`
        );
      }
      return match;
    };
  } else {
    const chunkingRegex = typeof chunking === "string" ? CHUNKING_REGEXPS[chunking] : chunking instanceof RegExp ? chunking : void 0;
    if (chunkingRegex == null) {
      throw new InvalidArgumentError2({
        argument: "chunking",
        message: `Chunking must be "word", "line", a RegExp, an Intl.Segmenter, or a ChunkDetector function. Received: ${chunking}`
      });
    }
    detectChunk = (buffer) => {
      const match = chunkingRegex.exec(buffer);
      if (!match) {
        return null;
      }
      return buffer.slice(0, match.index) + (match == null ? void 0 : match[0]);
    };
  }
  return () => {
    let buffer = "";
    let id = "";
    let type2 = void 0;
    let providerMetadata = void 0;
    function flushBuffer(controller) {
      if (buffer.length > 0 && type2 !== void 0) {
        controller.enqueue({
          type: type2,
          text: buffer,
          id,
          ...providerMetadata != null ? { providerMetadata } : {}
        });
        buffer = "";
        providerMetadata = void 0;
      }
    }
    return new TransformStream({
      async transform(chunk, controller) {
        if (chunk.type !== "text-delta" && chunk.type !== "reasoning-delta") {
          flushBuffer(controller);
          controller.enqueue(chunk);
          return;
        }
        if ((chunk.type !== type2 || chunk.id !== id) && buffer.length > 0) {
          flushBuffer(controller);
        }
        buffer += chunk.text;
        id = chunk.id;
        type2 = chunk.type;
        if (chunk.providerMetadata != null) {
          providerMetadata = chunk.providerMetadata;
        }
        let match;
        while ((match = detectChunk(buffer)) != null) {
          controller.enqueue({ type: type2, text: match, id });
          buffer = buffer.slice(match.length);
          await delay2(delayInMs);
        }
      }
    });
  };
}
async function experimental_generateVideo({
  model: modelArg,
  prompt: promptArg,
  n = 1,
  maxVideosPerCall,
  aspectRatio,
  resolution,
  duration,
  fps,
  seed,
  providerOptions,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers
}) {
  var _a212;
  const model = resolveVideoModel(modelArg);
  const headersWithUserAgent = withUserAgentSuffix(
    headers != null ? headers : {},
    `ai/${VERSION4}`
  );
  const { retry } = prepareRetries({
    maxRetries: maxRetriesArg,
    abortSignal
  });
  const { prompt, image } = normalizePrompt2(promptArg);
  const maxVideosPerCallWithDefault = (_a212 = maxVideosPerCall != null ? maxVideosPerCall : await invokeModelMaxVideosPerCall(model)) != null ? _a212 : 1;
  const callCount = Math.ceil(n / maxVideosPerCallWithDefault);
  const callVideoCounts = Array.from({ length: callCount }, (_, index) => {
    const remaining = n - index * maxVideosPerCallWithDefault;
    return Math.min(remaining, maxVideosPerCallWithDefault);
  });
  const results = await Promise.all(
    callVideoCounts.map(
      async (callVideoCount) => retry(
        () => model.doGenerate({
          prompt,
          n: callVideoCount,
          aspectRatio,
          resolution,
          duration,
          fps,
          seed,
          image,
          providerOptions: providerOptions != null ? providerOptions : {},
          headers: headersWithUserAgent,
          abortSignal
        })
      )
    )
  );
  const videos = [];
  const warnings = [];
  const responses = [];
  const providerMetadata = {};
  for (const result of results) {
    for (const videoData of result.videos) {
      switch (videoData.type) {
        case "url": {
          const { data, mediaType: downloadedMediaType } = await download({
            url: new URL(videoData.url)
          });
          const isUsableMediaType = (type2) => !!type2 && type2 !== "application/octet-stream";
          const mediaType = isUsableMediaType(videoData.mediaType) && videoData.mediaType || isUsableMediaType(downloadedMediaType) && downloadedMediaType || detectMediaType({
            data,
            signatures: videoMediaTypeSignatures
          }) || "video/mp4";
          videos.push(
            new DefaultGeneratedFile({
              data,
              mediaType
            })
          );
          break;
        }
        case "base64": {
          videos.push(
            new DefaultGeneratedFile({
              data: videoData.data,
              mediaType: videoData.mediaType || "video/mp4"
            })
          );
          break;
        }
        case "binary": {
          const mediaType = videoData.mediaType || detectMediaType({
            data: videoData.data,
            signatures: videoMediaTypeSignatures
          }) || "video/mp4";
          videos.push(
            new DefaultGeneratedFile({
              data: videoData.data,
              mediaType
            })
          );
          break;
        }
      }
    }
    warnings.push(...result.warnings);
    responses.push({
      timestamp: result.response.timestamp,
      modelId: result.response.modelId,
      headers: result.response.headers,
      providerMetadata: result.providerMetadata
    });
    if (result.providerMetadata != null) {
      for (const [providerName, metadata] of Object.entries(
        result.providerMetadata
      )) {
        const existingMetadata = providerMetadata[providerName];
        if (existingMetadata != null && typeof existingMetadata === "object") {
          providerMetadata[providerName] = {
            ...existingMetadata,
            ...metadata
          };
          if ("videos" in existingMetadata && Array.isArray(existingMetadata.videos) && "videos" in metadata && Array.isArray(metadata.videos)) {
            providerMetadata[providerName].videos = [
              ...existingMetadata.videos,
              ...metadata.videos
            ];
          }
        } else {
          providerMetadata[providerName] = metadata;
        }
      }
    }
  }
  if (videos.length === 0) {
    throw new NoVideoGeneratedError({ responses });
  }
  if (warnings.length > 0) {
    logWarnings({
      warnings,
      provider: model.provider,
      model: model.modelId
    });
  }
  return {
    video: videos[0],
    videos,
    warnings,
    responses,
    providerMetadata
  };
}
function normalizePrompt2(promptArg) {
  var _a212, _b18;
  if (typeof promptArg === "string") {
    return {
      prompt: promptArg,
      image: void 0
    };
  }
  let image;
  if (promptArg.image != null) {
    const dataContent = promptArg.image;
    if (typeof dataContent === "string") {
      if (dataContent.startsWith("http://") || dataContent.startsWith("https://")) {
        image = {
          type: "url",
          url: dataContent
        };
      } else if (dataContent.startsWith("data:")) {
        const { mediaType, base64Content } = splitDataUrl(dataContent);
        image = {
          type: "file",
          mediaType: mediaType != null ? mediaType : "image/png",
          data: convertBase64ToUint8Array(base64Content != null ? base64Content : "")
        };
      } else {
        const bytes = convertBase64ToUint8Array(dataContent);
        const mediaType = (_a212 = detectMediaType({
          data: bytes,
          signatures: imageMediaTypeSignatures
        })) != null ? _a212 : "image/png";
        image = {
          type: "file",
          mediaType,
          data: bytes
        };
      }
    } else if (dataContent instanceof Uint8Array) {
      const mediaType = (_b18 = detectMediaType({
        data: dataContent,
        signatures: imageMediaTypeSignatures
      })) != null ? _b18 : "image/png";
      image = {
        type: "file",
        mediaType,
        data: dataContent
      };
    }
  }
  return {
    prompt: promptArg.text,
    image
  };
}
async function invokeModelMaxVideosPerCall(model) {
  if (typeof model.maxVideosPerCall === "function") {
    return await model.maxVideosPerCall({ modelId: model.modelId });
  }
  return model.maxVideosPerCall;
}
function defaultEmbeddingSettingsMiddleware({
  settings
}) {
  return {
    specificationVersion: "v3",
    transformParams: async ({ params }) => {
      return mergeObjects(settings, params);
    }
  };
}
function defaultSettingsMiddleware({
  settings
}) {
  return {
    specificationVersion: "v3",
    transformParams: async ({ params }) => {
      return mergeObjects(settings, params);
    }
  };
}
function defaultTransform(text2) {
  return text2.replace(/^```(?:json)?\s*\n?/, "").replace(/\n?```\s*$/, "").trim();
}
function extractJsonMiddleware(options) {
  var _a212;
  const transform = (_a212 = options == null ? void 0 : options.transform) != null ? _a212 : defaultTransform;
  const hasCustomTransform = (options == null ? void 0 : options.transform) !== void 0;
  return {
    specificationVersion: "v3",
    wrapGenerate: async ({ doGenerate }) => {
      const { content, ...rest } = await doGenerate();
      const transformedContent = [];
      for (const part of content) {
        if (part.type !== "text") {
          transformedContent.push(part);
          continue;
        }
        transformedContent.push({
          ...part,
          text: transform(part.text)
        });
      }
      return { content: transformedContent, ...rest };
    },
    wrapStream: async ({ doStream }) => {
      const { stream, ...rest } = await doStream();
      const textBlocks = {};
      const SUFFIX_BUFFER_SIZE = 12;
      return {
        stream: stream.pipeThrough(
          new TransformStream({
            transform: (chunk, controller) => {
              if (chunk.type === "text-start") {
                textBlocks[chunk.id] = {
                  startEvent: chunk,
                  // Custom transforms need to buffer all content
                  phase: hasCustomTransform ? "buffering" : "prefix",
                  buffer: "",
                  prefixStripped: false
                };
                return;
              }
              if (chunk.type === "text-delta") {
                const block = textBlocks[chunk.id];
                if (!block) {
                  controller.enqueue(chunk);
                  return;
                }
                block.buffer += chunk.delta;
                if (block.phase === "buffering") {
                  return;
                }
                if (block.phase === "prefix") {
                  if (block.buffer.length > 0 && !block.buffer.startsWith("`")) {
                    block.phase = "streaming";
                    controller.enqueue(block.startEvent);
                  } else if (block.buffer.startsWith("```")) {
                    if (block.buffer.includes("\n")) {
                      const prefixMatch = block.buffer.match(/^```(?:json)?\s*\n/);
                      if (prefixMatch) {
                        block.buffer = block.buffer.slice(
                          prefixMatch[0].length
                        );
                        block.prefixStripped = true;
                        block.phase = "streaming";
                        controller.enqueue(block.startEvent);
                      } else {
                        block.phase = "streaming";
                        controller.enqueue(block.startEvent);
                      }
                    }
                  } else if (block.buffer.length >= 3 && !block.buffer.startsWith("```")) {
                    block.phase = "streaming";
                    controller.enqueue(block.startEvent);
                  }
                }
                if (block.phase === "streaming" && block.buffer.length > SUFFIX_BUFFER_SIZE) {
                  const toStream = block.buffer.slice(0, -SUFFIX_BUFFER_SIZE);
                  block.buffer = block.buffer.slice(-SUFFIX_BUFFER_SIZE);
                  controller.enqueue({
                    type: "text-delta",
                    id: chunk.id,
                    delta: toStream
                  });
                }
                return;
              }
              if (chunk.type === "text-end") {
                const block = textBlocks[chunk.id];
                if (block) {
                  if (block.phase === "prefix" || block.phase === "buffering") {
                    controller.enqueue(block.startEvent);
                  }
                  let remaining = block.buffer;
                  if (block.phase === "buffering") {
                    remaining = transform(remaining);
                  } else if (block.prefixStripped) {
                    remaining = remaining.replace(/\n?```\s*$/, "").trimEnd();
                  } else {
                    remaining = transform(remaining);
                  }
                  if (remaining.length > 0) {
                    controller.enqueue({
                      type: "text-delta",
                      id: chunk.id,
                      delta: remaining
                    });
                  }
                  controller.enqueue(chunk);
                  delete textBlocks[chunk.id];
                  return;
                }
              }
              controller.enqueue(chunk);
            }
          })
        ),
        ...rest
      };
    }
  };
}
function getPotentialStartIndex(text2, searchedText) {
  if (searchedText.length === 0) {
    return null;
  }
  const directIndex = text2.indexOf(searchedText);
  if (directIndex !== -1) {
    return directIndex;
  }
  for (let i = text2.length - 1; i >= 0; i--) {
    const suffix = text2.substring(i);
    if (searchedText.startsWith(suffix)) {
      return i;
    }
  }
  return null;
}
function extractReasoningMiddleware({
  tagName,
  separator = "\n",
  startWithReasoning = false
}) {
  const openingTag = `<${tagName}>`;
  const closingTag = `</${tagName}>`;
  return {
    specificationVersion: "v3",
    wrapGenerate: async ({ doGenerate }) => {
      const { content, ...rest } = await doGenerate();
      const transformedContent = [];
      for (const part of content) {
        if (part.type !== "text") {
          transformedContent.push(part);
          continue;
        }
        const text2 = startWithReasoning ? openingTag + part.text : part.text;
        const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, "gs");
        const matches = Array.from(text2.matchAll(regexp));
        if (!matches.length) {
          transformedContent.push(part);
          continue;
        }
        const reasoningText = matches.map((match) => match[1]).join(separator);
        let textWithoutReasoning = text2;
        for (let i = matches.length - 1; i >= 0; i--) {
          const match = matches[i];
          const beforeMatch = textWithoutReasoning.slice(0, match.index);
          const afterMatch = textWithoutReasoning.slice(
            match.index + match[0].length
          );
          textWithoutReasoning = beforeMatch + (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : "") + afterMatch;
        }
        transformedContent.push({
          type: "reasoning",
          text: reasoningText
        });
        transformedContent.push({
          type: "text",
          text: textWithoutReasoning
        });
      }
      return { content: transformedContent, ...rest };
    },
    wrapStream: async ({ doStream }) => {
      const { stream, ...rest } = await doStream();
      const reasoningExtractions = {};
      let delayedTextStart;
      return {
        stream: stream.pipeThrough(
          new TransformStream({
            transform: (chunk, controller) => {
              if (chunk.type === "text-start") {
                delayedTextStart = chunk;
                return;
              }
              if (chunk.type === "text-end" && delayedTextStart) {
                controller.enqueue(delayedTextStart);
                delayedTextStart = void 0;
              }
              if (chunk.type !== "text-delta") {
                controller.enqueue(chunk);
                return;
              }
              if (reasoningExtractions[chunk.id] == null) {
                reasoningExtractions[chunk.id] = {
                  isFirstReasoning: true,
                  isFirstText: true,
                  afterSwitch: false,
                  isReasoning: startWithReasoning,
                  buffer: "",
                  idCounter: 0,
                  textId: chunk.id
                };
              }
              const activeExtraction = reasoningExtractions[chunk.id];
              activeExtraction.buffer += chunk.delta;
              function publish(text2) {
                if (text2.length > 0) {
                  const prefix = activeExtraction.afterSwitch && (activeExtraction.isReasoning ? !activeExtraction.isFirstReasoning : !activeExtraction.isFirstText) ? separator : "";
                  if (activeExtraction.isReasoning && (activeExtraction.afterSwitch || activeExtraction.isFirstReasoning)) {
                    controller.enqueue({
                      type: "reasoning-start",
                      id: `reasoning-${activeExtraction.idCounter}`
                    });
                  }
                  if (activeExtraction.isReasoning) {
                    controller.enqueue({
                      type: "reasoning-delta",
                      delta: prefix + text2,
                      id: `reasoning-${activeExtraction.idCounter}`
                    });
                  } else {
                    if (delayedTextStart) {
                      controller.enqueue(delayedTextStart);
                      delayedTextStart = void 0;
                    }
                    controller.enqueue({
                      type: "text-delta",
                      delta: prefix + text2,
                      id: activeExtraction.textId
                    });
                  }
                  activeExtraction.afterSwitch = false;
                  if (activeExtraction.isReasoning) {
                    activeExtraction.isFirstReasoning = false;
                  } else {
                    activeExtraction.isFirstText = false;
                  }
                }
              }
              do {
                const nextTag = activeExtraction.isReasoning ? closingTag : openingTag;
                const startIndex = getPotentialStartIndex(
                  activeExtraction.buffer,
                  nextTag
                );
                if (startIndex == null) {
                  publish(activeExtraction.buffer);
                  activeExtraction.buffer = "";
                  break;
                }
                publish(activeExtraction.buffer.slice(0, startIndex));
                const foundFullMatch = startIndex + nextTag.length <= activeExtraction.buffer.length;
                if (foundFullMatch) {
                  activeExtraction.buffer = activeExtraction.buffer.slice(
                    startIndex + nextTag.length
                  );
                  if (activeExtraction.isReasoning) {
                    if (activeExtraction.isFirstReasoning) {
                      controller.enqueue({
                        type: "reasoning-start",
                        id: `reasoning-${activeExtraction.idCounter}`
                      });
                    }
                    controller.enqueue({
                      type: "reasoning-end",
                      id: `reasoning-${activeExtraction.idCounter++}`
                    });
                  }
                  activeExtraction.isReasoning = !activeExtraction.isReasoning;
                  activeExtraction.afterSwitch = true;
                } else {
                  activeExtraction.buffer = activeExtraction.buffer.slice(startIndex);
                  break;
                }
              } while (true);
            }
          })
        ),
        ...rest
      };
    }
  };
}
function simulateStreamingMiddleware() {
  return {
    specificationVersion: "v3",
    wrapStream: async ({ doGenerate }) => {
      const result = await doGenerate();
      let id = 0;
      const simulatedStream = new ReadableStream({
        start(controller) {
          controller.enqueue({
            type: "stream-start",
            warnings: result.warnings
          });
          controller.enqueue({ type: "response-metadata", ...result.response });
          for (const part of result.content) {
            switch (part.type) {
              case "text": {
                if (part.text.length > 0) {
                  controller.enqueue({ type: "text-start", id: String(id) });
                  controller.enqueue({
                    type: "text-delta",
                    id: String(id),
                    delta: part.text
                  });
                  controller.enqueue({ type: "text-end", id: String(id) });
                  id++;
                }
                break;
              }
              case "reasoning": {
                controller.enqueue({
                  type: "reasoning-start",
                  id: String(id),
                  providerMetadata: part.providerMetadata
                });
                controller.enqueue({
                  type: "reasoning-delta",
                  id: String(id),
                  delta: part.text
                });
                controller.enqueue({ type: "reasoning-end", id: String(id) });
                id++;
                break;
              }
              default: {
                controller.enqueue(part);
                break;
              }
            }
          }
          controller.enqueue({
            type: "finish",
            finishReason: result.finishReason,
            usage: result.usage,
            providerMetadata: result.providerMetadata
          });
          controller.close();
        }
      });
      return {
        stream: simulatedStream,
        request: result.request,
        response: result.response
      };
    }
  };
}
function defaultFormatExample(example) {
  return JSON.stringify(example.input);
}
function addToolInputExamplesMiddleware({
  prefix = "Input Examples:",
  format = defaultFormatExample,
  remove = true
} = {}) {
  return {
    specificationVersion: "v3",
    transformParams: async ({ params }) => {
      var _a212;
      if (!((_a212 = params.tools) == null ? void 0 : _a212.length)) {
        return params;
      }
      const transformedTools = params.tools.map((tool2) => {
        var _a222;
        if (tool2.type !== "function" || !((_a222 = tool2.inputExamples) == null ? void 0 : _a222.length)) {
          return tool2;
        }
        const formattedExamples = tool2.inputExamples.map((example, index) => format(example, index)).join("\n");
        const examplesSection = `${prefix}
${formattedExamples}`;
        const toolDescription = tool2.description ? `${tool2.description}

${examplesSection}` : examplesSection;
        return {
          ...tool2,
          description: toolDescription,
          inputExamples: remove ? void 0 : tool2.inputExamples
        };
      });
      return {
        ...params,
        tools: transformedTools
      };
    }
  };
}
function asProviderV3(provider) {
  if ("specificationVersion" in provider && provider.specificationVersion === "v3") {
    return provider;
  }
  const v2Provider = provider;
  return {
    specificationVersion: "v3",
    languageModel: (modelId) => asLanguageModelV3(v2Provider.languageModel(modelId)),
    embeddingModel: (modelId) => asEmbeddingModelV3(v2Provider.textEmbeddingModel(modelId)),
    imageModel: (modelId) => asImageModelV3(v2Provider.imageModel(modelId)),
    transcriptionModel: v2Provider.transcriptionModel ? (modelId) => asTranscriptionModelV3(v2Provider.transcriptionModel(modelId)) : void 0,
    speechModel: v2Provider.speechModel ? (modelId) => asSpeechModelV3(v2Provider.speechModel(modelId)) : void 0,
    rerankingModel: void 0
    // v2 providers don't have reranking models
  };
}
function wrapProvider({
  provider,
  languageModelMiddleware,
  imageModelMiddleware
}) {
  const providerV3 = asProviderV3(provider);
  return {
    specificationVersion: "v3",
    languageModel: (modelId) => wrapLanguageModel({
      model: providerV3.languageModel(modelId),
      middleware: languageModelMiddleware
    }),
    embeddingModel: providerV3.embeddingModel,
    imageModel: (modelId) => {
      let model = providerV3.imageModel(modelId);
      if (imageModelMiddleware != null) {
        model = wrapImageModel({ model, middleware: imageModelMiddleware });
      }
      return model;
    },
    transcriptionModel: providerV3.transcriptionModel,
    speechModel: providerV3.speechModel,
    rerankingModel: providerV3.rerankingModel
  };
}
function customProvider({
  languageModels,
  embeddingModels,
  imageModels,
  transcriptionModels,
  speechModels,
  rerankingModels,
  fallbackProvider: fallbackProviderArg
}) {
  const fallbackProvider = fallbackProviderArg ? asProviderV3(fallbackProviderArg) : void 0;
  return {
    specificationVersion: "v3",
    languageModel(modelId) {
      if (languageModels != null && modelId in languageModels) {
        return languageModels[modelId];
      }
      if (fallbackProvider) {
        return fallbackProvider.languageModel(modelId);
      }
      throw new NoSuchModelError({ modelId, modelType: "languageModel" });
    },
    embeddingModel(modelId) {
      if (embeddingModels != null && modelId in embeddingModels) {
        return embeddingModels[modelId];
      }
      if (fallbackProvider) {
        return fallbackProvider.embeddingModel(modelId);
      }
      throw new NoSuchModelError({ modelId, modelType: "embeddingModel" });
    },
    imageModel(modelId) {
      if (imageModels != null && modelId in imageModels) {
        return imageModels[modelId];
      }
      if (fallbackProvider == null ? void 0 : fallbackProvider.imageModel) {
        return fallbackProvider.imageModel(modelId);
      }
      throw new NoSuchModelError({ modelId, modelType: "imageModel" });
    },
    transcriptionModel(modelId) {
      if (transcriptionModels != null && modelId in transcriptionModels) {
        return transcriptionModels[modelId];
      }
      if (fallbackProvider == null ? void 0 : fallbackProvider.transcriptionModel) {
        return fallbackProvider.transcriptionModel(modelId);
      }
      throw new NoSuchModelError({ modelId, modelType: "transcriptionModel" });
    },
    speechModel(modelId) {
      if (speechModels != null && modelId in speechModels) {
        return speechModels[modelId];
      }
      if (fallbackProvider == null ? void 0 : fallbackProvider.speechModel) {
        return fallbackProvider.speechModel(modelId);
      }
      throw new NoSuchModelError({ modelId, modelType: "speechModel" });
    },
    rerankingModel(modelId) {
      if (rerankingModels != null && modelId in rerankingModels) {
        return rerankingModels[modelId];
      }
      if (fallbackProvider == null ? void 0 : fallbackProvider.rerankingModel) {
        return fallbackProvider.rerankingModel(modelId);
      }
      throw new NoSuchModelError({ modelId, modelType: "rerankingModel" });
    }
  };
}
function createProviderRegistry(providers2, {
  separator = ":",
  languageModelMiddleware,
  imageModelMiddleware
} = {}) {
  const registry = new DefaultProviderRegistry({
    separator,
    languageModelMiddleware,
    imageModelMiddleware
  });
  for (const [id, provider] of Object.entries(providers2)) {
    registry.registerProvider({ id, provider });
  }
  return registry;
}
async function rerank({
  model,
  documents,
  query,
  topN,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  providerOptions,
  experimental_telemetry: telemetry2
}) {
  if (documents.length === 0) {
    return new DefaultRerankResult({
      originalDocuments: [],
      ranking: [],
      providerMetadata: void 0,
      response: {
        timestamp: /* @__PURE__ */ new Date(),
        modelId: model.modelId
      }
    });
  }
  const { maxRetries, retry } = prepareRetries({
    maxRetries: maxRetriesArg,
    abortSignal
  });
  const documentsToSend = typeof documents[0] === "string" ? { type: "text", values: documents } : { type: "object", values: documents };
  const baseTelemetryAttributes = getBaseTelemetryAttributes({
    model,
    telemetry: telemetry2,
    headers,
    settings: { maxRetries }
  });
  const tracer = getTracer(telemetry2);
  return recordSpan({
    name: "ai.rerank",
    attributes: selectTelemetryAttributes({
      telemetry: telemetry2,
      attributes: {
        ...assembleOperationName({ operationId: "ai.rerank", telemetry: telemetry2 }),
        ...baseTelemetryAttributes,
        "ai.documents": {
          input: () => documents.map((document) => JSON.stringify(document))
        }
      }
    }),
    tracer,
    fn: async () => {
      var _a212, _b18;
      const { ranking, response, providerMetadata, warnings } = await retry(
        () => recordSpan({
          name: "ai.rerank.doRerank",
          attributes: selectTelemetryAttributes({
            telemetry: telemetry2,
            attributes: {
              ...assembleOperationName({
                operationId: "ai.rerank.doRerank",
                telemetry: telemetry2
              }),
              ...baseTelemetryAttributes,
              // specific settings that only make sense on the outer level:
              "ai.documents": {
                input: () => documents.map((document) => JSON.stringify(document))
              }
            }
          }),
          tracer,
          fn: async (doRerankSpan) => {
            const modelResponse = await model.doRerank({
              documents: documentsToSend,
              query,
              topN,
              providerOptions,
              abortSignal,
              headers
            });
            const ranking2 = modelResponse.ranking;
            doRerankSpan.setAttributes(
              await selectTelemetryAttributes({
                telemetry: telemetry2,
                attributes: {
                  "ai.ranking.type": documentsToSend.type,
                  "ai.ranking": {
                    output: () => ranking2.map((ranking3) => JSON.stringify(ranking3))
                  }
                }
              })
            );
            return {
              ranking: ranking2,
              providerMetadata: modelResponse.providerMetadata,
              response: modelResponse.response,
              warnings: modelResponse.warnings
            };
          }
        })
      );
      logWarnings({
        warnings: warnings != null ? warnings : [],
        provider: model.provider,
        model: model.modelId
      });
      return new DefaultRerankResult({
        originalDocuments: documents,
        ranking: ranking.map((ranking2) => ({
          originalIndex: ranking2.index,
          score: ranking2.relevanceScore,
          document: documents[ranking2.index]
        })),
        providerMetadata,
        response: {
          id: response == null ? void 0 : response.id,
          timestamp: (_a212 = response == null ? void 0 : response.timestamp) != null ? _a212 : /* @__PURE__ */ new Date(),
          modelId: (_b18 = response == null ? void 0 : response.modelId) != null ? _b18 : model.modelId,
          headers: response == null ? void 0 : response.headers,
          body: response == null ? void 0 : response.body
        }
      });
    }
  });
}
async function transcribe({
  model,
  audio,
  providerOptions = {},
  maxRetries: maxRetriesArg,
  abortSignal,
  headers
}) {
  const resolvedModel = resolveTranscriptionModel(model);
  if (!resolvedModel) {
    throw new Error("Model could not be resolved");
  }
  const { retry } = prepareRetries({
    maxRetries: maxRetriesArg,
    abortSignal
  });
  const headersWithUserAgent = withUserAgentSuffix(
    headers != null ? headers : {},
    `ai/${VERSION4}`
  );
  const audioData = audio instanceof URL ? (await download({ url: audio })).data : convertDataContentToUint8Array(audio);
  const result = await retry(
    () => {
      var _a212;
      return resolvedModel.doGenerate({
        audio: audioData,
        abortSignal,
        headers: headersWithUserAgent,
        providerOptions,
        mediaType: (_a212 = detectMediaType({
          data: audioData,
          signatures: audioMediaTypeSignatures
        })) != null ? _a212 : "audio/wav"
      });
    }
  );
  logWarnings({
    warnings: result.warnings,
    provider: resolvedModel.provider,
    model: resolvedModel.modelId
  });
  if (!result.text) {
    throw new NoTranscriptGeneratedError({ responses: [result.response] });
  }
  return new DefaultTranscriptionResult({
    text: result.text,
    segments: result.segments,
    language: result.language,
    durationInSeconds: result.durationInSeconds,
    warnings: result.warnings,
    responses: [result.response],
    providerMetadata: result.providerMetadata
  });
}
async function processTextStream({
  stream,
  onTextPart
}) {
  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();
  while (true) {
    const { done, value: value2 } = await reader.read();
    if (done) {
      break;
    }
    await onTextPart(value2);
  }
}
async function callCompletionApi({
  api,
  prompt,
  credentials,
  headers,
  body,
  streamProtocol = "data",
  setCompletion,
  setLoading,
  setError,
  setAbortController,
  onFinish: onFinish2,
  onError: onError2,
  fetch: fetch2 = getOriginalFetch3()
}) {
  var _a212;
  try {
    setLoading(true);
    setError(void 0);
    const abortController = new AbortController();
    setAbortController(abortController);
    setCompletion("");
    const response = await fetch2(api, {
      method: "POST",
      body: JSON.stringify({
        prompt,
        ...body
      }),
      credentials,
      headers: withUserAgentSuffix(
        {
          "Content-Type": "application/json",
          ...headers
        },
        `ai-sdk/${VERSION4}`,
        getRuntimeEnvironmentUserAgent()
      ),
      signal: abortController.signal
    }).catch((err) => {
      throw err;
    });
    if (!response.ok) {
      throw new Error(
        (_a212 = await response.text()) != null ? _a212 : "Failed to fetch the chat response."
      );
    }
    if (!response.body) {
      throw new Error("The response body is empty.");
    }
    let result = "";
    switch (streamProtocol) {
      case "text": {
        await processTextStream({
          stream: response.body,
          onTextPart: (chunk) => {
            result += chunk;
            setCompletion(result);
          }
        });
        break;
      }
      case "data": {
        await consumeStream({
          stream: parseJsonEventStream({
            stream: response.body,
            schema: uiMessageChunkSchema
          }).pipeThrough(
            new TransformStream({
              async transform(part) {
                if (!part.success) {
                  throw part.error;
                }
                const streamPart = part.value;
                if (streamPart.type === "text-delta") {
                  result += streamPart.delta;
                  setCompletion(result);
                } else if (streamPart.type === "error") {
                  throw new Error(streamPart.errorText);
                }
              }
            })
          ),
          onError: (error) => {
            throw error;
          }
        });
        break;
      }
      default: {
        const exhaustiveCheck = streamProtocol;
        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);
      }
    }
    if (onFinish2) {
      onFinish2(prompt, result);
    }
    setAbortController(null);
    return result;
  } catch (err) {
    if (err.name === "AbortError") {
      setAbortController(null);
      return null;
    }
    if (err instanceof Error) {
      if (onError2) {
        onError2(err);
      }
    }
    setError(err);
  } finally {
    setLoading(false);
  }
}
async function convertFileListToFileUIParts(files) {
  if (files == null) {
    return [];
  }
  if (!globalThis.FileList || !(files instanceof globalThis.FileList)) {
    throw new Error("FileList is not supported in the current environment");
  }
  return Promise.all(
    Array.from(files).map(async (file) => {
      const { name: name212, type: type2 } = file;
      const dataUrl = await new Promise((resolve32, reject) => {
        const reader = new FileReader();
        reader.onload = (readerEvent) => {
          var _a212;
          resolve32((_a212 = readerEvent.target) == null ? void 0 : _a212.result);
        };
        reader.onerror = (error) => reject(error);
        reader.readAsDataURL(file);
      });
      return {
        type: "file",
        mediaType: type2,
        filename: name212,
        url: dataUrl
      };
    })
  );
}
function lastAssistantMessageIsCompleteWithApprovalResponses({
  messages
}) {
  const message = messages[messages.length - 1];
  if (!message) {
    return false;
  }
  if (message.role !== "assistant") {
    return false;
  }
  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {
    return part.type === "step-start" ? index : lastIndex;
  }, -1);
  const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter(isToolUIPart).filter((part) => !part.providerExecuted);
  return (
    // has at least one tool approval response
    lastStepToolInvocations.filter((part) => part.state === "approval-responded").length > 0 && // all tool approvals must have a response
    lastStepToolInvocations.every(
      (part) => part.state === "output-available" || part.state === "output-error" || part.state === "approval-responded"
    )
  );
}
function lastAssistantMessageIsCompleteWithToolCalls({
  messages
}) {
  const message = messages[messages.length - 1];
  if (!message) {
    return false;
  }
  if (message.role !== "assistant") {
    return false;
  }
  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {
    return part.type === "step-start" ? index : lastIndex;
  }, -1);
  const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter(isToolUIPart).filter((part) => !part.providerExecuted);
  return lastStepToolInvocations.length > 0 && lastStepToolInvocations.every(
    (part) => part.state === "output-available" || part.state === "output-error"
  );
}
function transformTextToUiMessageStream({
  stream
}) {
  return stream.pipeThrough(
    new TransformStream({
      start(controller) {
        controller.enqueue({ type: "start" });
        controller.enqueue({ type: "start-step" });
        controller.enqueue({ type: "text-start", id: "text-1" });
      },
      async transform(part, controller) {
        controller.enqueue({ type: "text-delta", id: "text-1", delta: part });
      },
      async flush(controller) {
        controller.enqueue({ type: "text-end", id: "text-1" });
        controller.enqueue({ type: "finish-step" });
        controller.enqueue({ type: "finish" });
      }
    })
  );
}
var __defProp2, __export2, name16, marker17, symbol17, _a17, InvalidArgumentError3, name23, marker23, symbol23, _a23, InvalidStreamPartError, name33, marker33, symbol33, _a33, InvalidToolApprovalError, name43, marker43, symbol43, _a43, InvalidToolInputError, name53, marker53, symbol53, _a53, ToolCallNotFoundForApprovalError, name63, marker63, symbol63, _a63, MissingToolResultsError, name72, marker73, symbol73, _a73, NoImageGeneratedError, name82, marker82, symbol82, _a82, NoObjectGeneratedError, name92, marker92, symbol92, _a92, NoOutputGeneratedError, name102, marker102, symbol102, _a102, NoSpeechGeneratedError, name112, marker112, symbol112, _a112, NoTranscriptGeneratedError, name122, marker122, symbol122, _a122, NoVideoGeneratedError, name132, marker132, symbol132, _a132, NoSuchToolError, name142, marker142, symbol142, _a142, ToolCallRepairError, UnsupportedModelVersionError, name152, marker152, symbol152, _a152, UIMessageStreamError, name162, marker162, symbol162, _a162, InvalidDataContentError, name17, marker172, symbol172, _a172, InvalidMessageRoleError, name18, marker18, symbol18, _a18, MessageConversionError, name19, marker19, symbol19, _a19, RetryError, FIRST_WARNING_INFO_MESSAGE, hasLoggedBefore, logWarnings, imageMediaTypeSignatures, audioMediaTypeSignatures, videoMediaTypeSignatures, stripID3, VERSION4, download, createDefaultDownloadFunction, dataContentSchema, jsonValueSchema, providerMetadataSchema, textPartSchema, imagePartSchema, filePartSchema, reasoningPartSchema, toolCallPartSchema, outputSchema, toolResultPartSchema, toolApprovalRequestSchema, toolApprovalResponseSchema, systemModelMessageSchema, userModelMessageSchema, assistantModelMessageSchema, toolModelMessageSchema, modelMessageSchema, noopTracer, noopSpan, noopSpanContext, retryWithExponentialBackoffRespectingRetryHeaders, DefaultGeneratedFile, DefaultGeneratedFileWithType, output_exports, text, object, array, choice, json, DefaultStepResult, originalGenerateId, DefaultGenerateTextResult, JsonToSseTransformStream, UI_MESSAGE_STREAM_HEADERS, uiMessageChunkSchema, isToolOrDynamicToolUIPart, getToolOrDynamicToolName, originalGenerateId2, DefaultStreamTextResult, ToolLoopAgent, uiMessagesSchema, DefaultEmbedResult, DefaultEmbedManyResult, DefaultGenerateImageResult, experimental_generateImage, noSchemaOutputStrategy, objectOutputStrategy, arrayOutputStrategy, enumOutputStrategy, originalGenerateId3, DefaultGenerateObjectResult, SerialJobExecutor, originalGenerateId4, DefaultStreamObjectResult, DefaultGeneratedAudioFile, DefaultSpeechResult, CHUNKING_REGEXPS, wrapLanguageModel, doWrap, wrapEmbeddingModel, doWrap2, wrapImageModel, doWrap3, experimental_customProvider, name20, marker20, symbol20, _a20, NoSuchProviderError, experimental_createProviderRegistry, DefaultProviderRegistry, DefaultRerankResult, DefaultTranscriptionResult, getOriginalFetch3, HttpChatTransport, DefaultChatTransport, AbstractChat, DirectChatTransport, TextStreamChatTransport;
var init_dist10 = __esm({
  "node_modules/ai/dist/index.mjs"() {
    init_dist9();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist9();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist9();
    init_dist6();
    init_esm();
    init_esm();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    __defProp2 = Object.defineProperty;
    __export2 = (target, all) => {
      for (var name212 in all)
        __defProp2(target, name212, { get: all[name212], enumerable: true });
    };
    name16 = "AI_InvalidArgumentError";
    marker17 = `vercel.ai.error.${name16}`;
    symbol17 = Symbol.for(marker17);
    InvalidArgumentError3 = class extends AISDKError {
      constructor({
        parameter,
        value: value2,
        message
      }) {
        super({
          name: name16,
          message: `Invalid argument for parameter ${parameter}: ${message}`
        });
        this[_a17] = true;
        this.parameter = parameter;
        this.value = value2;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker17);
      }
    };
    _a17 = symbol17;
    name23 = "AI_InvalidStreamPartError";
    marker23 = `vercel.ai.error.${name23}`;
    symbol23 = Symbol.for(marker23);
    InvalidStreamPartError = class extends AISDKError {
      constructor({
        chunk,
        message
      }) {
        super({ name: name23, message });
        this[_a23] = true;
        this.chunk = chunk;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker23);
      }
    };
    _a23 = symbol23;
    name33 = "AI_InvalidToolApprovalError";
    marker33 = `vercel.ai.error.${name33}`;
    symbol33 = Symbol.for(marker33);
    InvalidToolApprovalError = class extends AISDKError {
      constructor({ approvalId }) {
        super({
          name: name33,
          message: `Tool approval response references unknown approvalId: "${approvalId}". No matching tool-approval-request found in message history.`
        });
        this[_a33] = true;
        this.approvalId = approvalId;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker33);
      }
    };
    _a33 = symbol33;
    name43 = "AI_InvalidToolInputError";
    marker43 = `vercel.ai.error.${name43}`;
    symbol43 = Symbol.for(marker43);
    InvalidToolInputError = class extends AISDKError {
      constructor({
        toolInput,
        toolName,
        cause,
        message = `Invalid input for tool ${toolName}: ${getErrorMessage(cause)}`
      }) {
        super({ name: name43, message, cause });
        this[_a43] = true;
        this.toolInput = toolInput;
        this.toolName = toolName;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker43);
      }
    };
    _a43 = symbol43;
    name53 = "AI_ToolCallNotFoundForApprovalError";
    marker53 = `vercel.ai.error.${name53}`;
    symbol53 = Symbol.for(marker53);
    ToolCallNotFoundForApprovalError = class extends AISDKError {
      constructor({
        toolCallId,
        approvalId
      }) {
        super({
          name: name53,
          message: `Tool call "${toolCallId}" not found for approval request "${approvalId}".`
        });
        this[_a53] = true;
        this.toolCallId = toolCallId;
        this.approvalId = approvalId;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker53);
      }
    };
    _a53 = symbol53;
    name63 = "AI_MissingToolResultsError";
    marker63 = `vercel.ai.error.${name63}`;
    symbol63 = Symbol.for(marker63);
    MissingToolResultsError = class extends AISDKError {
      constructor({ toolCallIds }) {
        super({
          name: name63,
          message: `Tool result${toolCallIds.length > 1 ? "s are" : " is"} missing for tool call${toolCallIds.length > 1 ? "s" : ""} ${toolCallIds.join(
            ", "
          )}.`
        });
        this[_a63] = true;
        this.toolCallIds = toolCallIds;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker63);
      }
    };
    _a63 = symbol63;
    name72 = "AI_NoImageGeneratedError";
    marker73 = `vercel.ai.error.${name72}`;
    symbol73 = Symbol.for(marker73);
    NoImageGeneratedError = class extends AISDKError {
      constructor({
        message = "No image generated.",
        cause,
        responses
      }) {
        super({ name: name72, message, cause });
        this[_a73] = true;
        this.responses = responses;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker73);
      }
    };
    _a73 = symbol73;
    name82 = "AI_NoObjectGeneratedError";
    marker82 = `vercel.ai.error.${name82}`;
    symbol82 = Symbol.for(marker82);
    NoObjectGeneratedError = class extends AISDKError {
      constructor({
        message = "No object generated.",
        cause,
        text: text2,
        response,
        usage,
        finishReason
      }) {
        super({ name: name82, message, cause });
        this[_a82] = true;
        this.text = text2;
        this.response = response;
        this.usage = usage;
        this.finishReason = finishReason;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker82);
      }
    };
    _a82 = symbol82;
    name92 = "AI_NoOutputGeneratedError";
    marker92 = `vercel.ai.error.${name92}`;
    symbol92 = Symbol.for(marker92);
    NoOutputGeneratedError = class extends AISDKError {
      // used in isInstance
      constructor({
        message = "No output generated.",
        cause
      } = {}) {
        super({ name: name92, message, cause });
        this[_a92] = true;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker92);
      }
    };
    _a92 = symbol92;
    name102 = "AI_NoSpeechGeneratedError";
    marker102 = `vercel.ai.error.${name102}`;
    symbol102 = Symbol.for(marker102);
    NoSpeechGeneratedError = class extends AISDKError {
      constructor(options) {
        super({
          name: name102,
          message: "No speech audio generated."
        });
        this[_a102] = true;
        this.responses = options.responses;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker102);
      }
    };
    _a102 = symbol102;
    name112 = "AI_NoTranscriptGeneratedError";
    marker112 = `vercel.ai.error.${name112}`;
    symbol112 = Symbol.for(marker112);
    NoTranscriptGeneratedError = class extends AISDKError {
      constructor(options) {
        super({
          name: name112,
          message: "No transcript generated."
        });
        this[_a112] = true;
        this.responses = options.responses;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker112);
      }
    };
    _a112 = symbol112;
    name122 = "AI_NoVideoGeneratedError";
    marker122 = `vercel.ai.error.${name122}`;
    symbol122 = Symbol.for(marker122);
    NoVideoGeneratedError = class extends AISDKError {
      constructor({
        message = "No video generated.",
        cause,
        responses
      }) {
        super({ name: name122, message, cause });
        this[_a122] = true;
        this.responses = responses;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker122);
      }
      /**
       * @deprecated use `isInstance` instead
       */
      static isNoVideoGeneratedError(error) {
        return error instanceof Error && error.name === name122 && typeof error.responses !== "undefined" ? true : false;
      }
      /**
       * @deprecated Do not use this method. It will be removed in the next major version.
       */
      toJSON() {
        return {
          name: this.name,
          message: this.message,
          stack: this.stack,
          cause: this.cause,
          responses: this.responses
        };
      }
    };
    _a122 = symbol122;
    name132 = "AI_NoSuchToolError";
    marker132 = `vercel.ai.error.${name132}`;
    symbol132 = Symbol.for(marker132);
    NoSuchToolError = class extends AISDKError {
      constructor({
        toolName,
        availableTools = void 0,
        message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? "No tools are available." : `Available tools: ${availableTools.join(", ")}.`}`
      }) {
        super({ name: name132, message });
        this[_a132] = true;
        this.toolName = toolName;
        this.availableTools = availableTools;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker132);
      }
    };
    _a132 = symbol132;
    name142 = "AI_ToolCallRepairError";
    marker142 = `vercel.ai.error.${name142}`;
    symbol142 = Symbol.for(marker142);
    ToolCallRepairError = class extends AISDKError {
      constructor({
        cause,
        originalError,
        message = `Error repairing tool call: ${getErrorMessage(cause)}`
      }) {
        super({ name: name142, message, cause });
        this[_a142] = true;
        this.originalError = originalError;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker142);
      }
    };
    _a142 = symbol142;
    UnsupportedModelVersionError = class extends AISDKError {
      constructor(options) {
        super({
          name: "AI_UnsupportedModelVersionError",
          message: `Unsupported model version ${options.version} for provider "${options.provider}" and model "${options.modelId}". AI SDK 5 only supports models that implement specification version "v2".`
        });
        this.version = options.version;
        this.provider = options.provider;
        this.modelId = options.modelId;
      }
    };
    name152 = "AI_UIMessageStreamError";
    marker152 = `vercel.ai.error.${name152}`;
    symbol152 = Symbol.for(marker152);
    UIMessageStreamError = class extends AISDKError {
      constructor({
        chunkType,
        chunkId,
        message
      }) {
        super({ name: name152, message });
        this[_a152] = true;
        this.chunkType = chunkType;
        this.chunkId = chunkId;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker152);
      }
    };
    _a152 = symbol152;
    name162 = "AI_InvalidDataContentError";
    marker162 = `vercel.ai.error.${name162}`;
    symbol162 = Symbol.for(marker162);
    InvalidDataContentError = class extends AISDKError {
      constructor({
        content,
        cause,
        message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`
      }) {
        super({ name: name162, message, cause });
        this[_a162] = true;
        this.content = content;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker162);
      }
    };
    _a162 = symbol162;
    name17 = "AI_InvalidMessageRoleError";
    marker172 = `vercel.ai.error.${name17}`;
    symbol172 = Symbol.for(marker172);
    InvalidMessageRoleError = class extends AISDKError {
      constructor({
        role,
        message = `Invalid message role: '${role}'. Must be one of: "system", "user", "assistant", "tool".`
      }) {
        super({ name: name17, message });
        this[_a172] = true;
        this.role = role;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker172);
      }
    };
    _a172 = symbol172;
    name18 = "AI_MessageConversionError";
    marker18 = `vercel.ai.error.${name18}`;
    symbol18 = Symbol.for(marker18);
    MessageConversionError = class extends AISDKError {
      constructor({
        originalMessage,
        message
      }) {
        super({ name: name18, message });
        this[_a18] = true;
        this.originalMessage = originalMessage;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker18);
      }
    };
    _a18 = symbol18;
    name19 = "AI_RetryError";
    marker19 = `vercel.ai.error.${name19}`;
    symbol19 = Symbol.for(marker19);
    RetryError = class extends AISDKError {
      constructor({
        message,
        reason,
        errors
      }) {
        super({ name: name19, message });
        this[_a19] = true;
        this.reason = reason;
        this.errors = errors;
        this.lastError = errors[errors.length - 1];
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker19);
      }
    };
    _a19 = symbol19;
    FIRST_WARNING_INFO_MESSAGE = "AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.";
    hasLoggedBefore = false;
    logWarnings = (options) => {
      if (options.warnings.length === 0) {
        return;
      }
      const logger = globalThis.AI_SDK_LOG_WARNINGS;
      if (logger === false) {
        return;
      }
      if (typeof logger === "function") {
        logger(options);
        return;
      }
      if (!hasLoggedBefore) {
        hasLoggedBefore = true;
        console.info(FIRST_WARNING_INFO_MESSAGE);
      }
      for (const warning of options.warnings) {
        console.warn(
          formatWarning({
            warning,
            provider: options.provider,
            model: options.model
          })
        );
      }
    };
    imageMediaTypeSignatures = [
      {
        mediaType: "image/gif",
        bytesPrefix: [71, 73, 70]
        // GIF
      },
      {
        mediaType: "image/png",
        bytesPrefix: [137, 80, 78, 71]
        // PNG
      },
      {
        mediaType: "image/jpeg",
        bytesPrefix: [255, 216]
        // JPEG
      },
      {
        mediaType: "image/webp",
        bytesPrefix: [
          82,
          73,
          70,
          70,
          // "RIFF"
          null,
          null,
          null,
          null,
          // file size (variable)
          87,
          69,
          66,
          80
          // "WEBP"
        ]
      },
      {
        mediaType: "image/bmp",
        bytesPrefix: [66, 77]
      },
      {
        mediaType: "image/tiff",
        bytesPrefix: [73, 73, 42, 0]
      },
      {
        mediaType: "image/tiff",
        bytesPrefix: [77, 77, 0, 42]
      },
      {
        mediaType: "image/avif",
        bytesPrefix: [
          0,
          0,
          0,
          32,
          102,
          116,
          121,
          112,
          97,
          118,
          105,
          102
        ]
      },
      {
        mediaType: "image/heic",
        bytesPrefix: [
          0,
          0,
          0,
          32,
          102,
          116,
          121,
          112,
          104,
          101,
          105,
          99
        ]
      }
    ];
    audioMediaTypeSignatures = [
      {
        mediaType: "audio/mpeg",
        bytesPrefix: [255, 251]
      },
      {
        mediaType: "audio/mpeg",
        bytesPrefix: [255, 250]
      },
      {
        mediaType: "audio/mpeg",
        bytesPrefix: [255, 243]
      },
      {
        mediaType: "audio/mpeg",
        bytesPrefix: [255, 242]
      },
      {
        mediaType: "audio/mpeg",
        bytesPrefix: [255, 227]
      },
      {
        mediaType: "audio/mpeg",
        bytesPrefix: [255, 226]
      },
      {
        mediaType: "audio/wav",
        bytesPrefix: [
          82,
          // R
          73,
          // I
          70,
          // F
          70,
          // F
          null,
          null,
          null,
          null,
          87,
          // W
          65,
          // A
          86,
          // V
          69
          // E
        ]
      },
      {
        mediaType: "audio/ogg",
        bytesPrefix: [79, 103, 103, 83]
      },
      {
        mediaType: "audio/flac",
        bytesPrefix: [102, 76, 97, 67]
      },
      {
        mediaType: "audio/aac",
        bytesPrefix: [64, 21, 0, 0]
      },
      {
        mediaType: "audio/mp4",
        bytesPrefix: [102, 116, 121, 112]
      },
      {
        mediaType: "audio/webm",
        bytesPrefix: [26, 69, 223, 163]
      }
    ];
    videoMediaTypeSignatures = [
      {
        mediaType: "video/mp4",
        bytesPrefix: [
          0,
          0,
          0,
          null,
          102,
          116,
          121,
          112
          // ftyp
        ]
      },
      {
        mediaType: "video/webm",
        bytesPrefix: [26, 69, 223, 163]
        // EBML
      },
      {
        mediaType: "video/quicktime",
        bytesPrefix: [
          0,
          0,
          0,
          20,
          102,
          116,
          121,
          112,
          113,
          116
          // ftypqt
        ]
      },
      {
        mediaType: "video/x-msvideo",
        bytesPrefix: [82, 73, 70, 70]
        // RIFF (AVI)
      }
    ];
    stripID3 = (data) => {
      const bytes = typeof data === "string" ? convertBase64ToUint8Array(data) : data;
      const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;
      return bytes.slice(id3Size + 10);
    };
    VERSION4 = true ? "6.0.72" : "0.0.0-test";
    download = async ({ url }) => {
      var _a212;
      const urlText = url.toString();
      try {
        const response = await fetch(urlText, {
          headers: withUserAgentSuffix(
            {},
            `ai-sdk/${VERSION4}`,
            getRuntimeEnvironmentUserAgent()
          )
        });
        if (!response.ok) {
          throw new DownloadError({
            url: urlText,
            statusCode: response.status,
            statusText: response.statusText
          });
        }
        return {
          data: new Uint8Array(await response.arrayBuffer()),
          mediaType: (_a212 = response.headers.get("content-type")) != null ? _a212 : void 0
        };
      } catch (error) {
        if (DownloadError.isInstance(error)) {
          throw error;
        }
        throw new DownloadError({ url: urlText, cause: error });
      }
    };
    createDefaultDownloadFunction = (download2 = download) => (requestedDownloads) => Promise.all(
      requestedDownloads.map(
        async (requestedDownload) => requestedDownload.isUrlSupportedByModel ? null : download2(requestedDownload)
      )
    );
    dataContentSchema = z17.union([
      z17.string(),
      z17.instanceof(Uint8Array),
      z17.instanceof(ArrayBuffer),
      z17.custom(
        // Buffer might not be available in some environments such as CloudFlare:
        (value2) => {
          var _a212, _b18;
          return (_b18 = (_a212 = globalThis.Buffer) == null ? void 0 : _a212.isBuffer(value2)) != null ? _b18 : false;
        },
        { message: "Must be a Buffer" }
      )
    ]);
    jsonValueSchema = z23.lazy(
      () => z23.union([
        z23.null(),
        z23.string(),
        z23.number(),
        z23.boolean(),
        z23.record(z23.string(), jsonValueSchema.optional()),
        z23.array(jsonValueSchema)
      ])
    );
    providerMetadataSchema = z33.record(
      z33.string(),
      z33.record(z33.string(), jsonValueSchema.optional())
    );
    textPartSchema = z44.object({
      type: z44.literal("text"),
      text: z44.string(),
      providerOptions: providerMetadataSchema.optional()
    });
    imagePartSchema = z44.object({
      type: z44.literal("image"),
      image: z44.union([dataContentSchema, z44.instanceof(URL)]),
      mediaType: z44.string().optional(),
      providerOptions: providerMetadataSchema.optional()
    });
    filePartSchema = z44.object({
      type: z44.literal("file"),
      data: z44.union([dataContentSchema, z44.instanceof(URL)]),
      filename: z44.string().optional(),
      mediaType: z44.string(),
      providerOptions: providerMetadataSchema.optional()
    });
    reasoningPartSchema = z44.object({
      type: z44.literal("reasoning"),
      text: z44.string(),
      providerOptions: providerMetadataSchema.optional()
    });
    toolCallPartSchema = z44.object({
      type: z44.literal("tool-call"),
      toolCallId: z44.string(),
      toolName: z44.string(),
      input: z44.unknown(),
      providerOptions: providerMetadataSchema.optional(),
      providerExecuted: z44.boolean().optional()
    });
    outputSchema = z44.discriminatedUnion(
      "type",
      [
        z44.object({
          type: z44.literal("text"),
          value: z44.string(),
          providerOptions: providerMetadataSchema.optional()
        }),
        z44.object({
          type: z44.literal("json"),
          value: jsonValueSchema,
          providerOptions: providerMetadataSchema.optional()
        }),
        z44.object({
          type: z44.literal("execution-denied"),
          reason: z44.string().optional(),
          providerOptions: providerMetadataSchema.optional()
        }),
        z44.object({
          type: z44.literal("error-text"),
          value: z44.string(),
          providerOptions: providerMetadataSchema.optional()
        }),
        z44.object({
          type: z44.literal("error-json"),
          value: jsonValueSchema,
          providerOptions: providerMetadataSchema.optional()
        }),
        z44.object({
          type: z44.literal("content"),
          value: z44.array(
            z44.union([
              z44.object({
                type: z44.literal("text"),
                text: z44.string(),
                providerOptions: providerMetadataSchema.optional()
              }),
              z44.object({
                type: z44.literal("media"),
                data: z44.string(),
                mediaType: z44.string()
              }),
              z44.object({
                type: z44.literal("file-data"),
                data: z44.string(),
                mediaType: z44.string(),
                filename: z44.string().optional(),
                providerOptions: providerMetadataSchema.optional()
              }),
              z44.object({
                type: z44.literal("file-url"),
                url: z44.string(),
                providerOptions: providerMetadataSchema.optional()
              }),
              z44.object({
                type: z44.literal("file-id"),
                fileId: z44.union([z44.string(), z44.record(z44.string(), z44.string())]),
                providerOptions: providerMetadataSchema.optional()
              }),
              z44.object({
                type: z44.literal("image-data"),
                data: z44.string(),
                mediaType: z44.string(),
                providerOptions: providerMetadataSchema.optional()
              }),
              z44.object({
                type: z44.literal("image-url"),
                url: z44.string(),
                providerOptions: providerMetadataSchema.optional()
              }),
              z44.object({
                type: z44.literal("image-file-id"),
                fileId: z44.union([z44.string(), z44.record(z44.string(), z44.string())]),
                providerOptions: providerMetadataSchema.optional()
              }),
              z44.object({
                type: z44.literal("custom"),
                providerOptions: providerMetadataSchema.optional()
              })
            ])
          )
        })
      ]
    );
    toolResultPartSchema = z44.object({
      type: z44.literal("tool-result"),
      toolCallId: z44.string(),
      toolName: z44.string(),
      output: outputSchema,
      providerOptions: providerMetadataSchema.optional()
    });
    toolApprovalRequestSchema = z44.object({
      type: z44.literal("tool-approval-request"),
      approvalId: z44.string(),
      toolCallId: z44.string()
    });
    toolApprovalResponseSchema = z44.object({
      type: z44.literal("tool-approval-response"),
      approvalId: z44.string(),
      approved: z44.boolean(),
      reason: z44.string().optional()
    });
    systemModelMessageSchema = z53.object(
      {
        role: z53.literal("system"),
        content: z53.string(),
        providerOptions: providerMetadataSchema.optional()
      }
    );
    userModelMessageSchema = z53.object({
      role: z53.literal("user"),
      content: z53.union([
        z53.string(),
        z53.array(z53.union([textPartSchema, imagePartSchema, filePartSchema]))
      ]),
      providerOptions: providerMetadataSchema.optional()
    });
    assistantModelMessageSchema = z53.object({
      role: z53.literal("assistant"),
      content: z53.union([
        z53.string(),
        z53.array(
          z53.union([
            textPartSchema,
            filePartSchema,
            reasoningPartSchema,
            toolCallPartSchema,
            toolResultPartSchema,
            toolApprovalRequestSchema
          ])
        )
      ]),
      providerOptions: providerMetadataSchema.optional()
    });
    toolModelMessageSchema = z53.object({
      role: z53.literal("tool"),
      content: z53.array(z53.union([toolResultPartSchema, toolApprovalResponseSchema])),
      providerOptions: providerMetadataSchema.optional()
    });
    modelMessageSchema = z53.union([
      systemModelMessageSchema,
      userModelMessageSchema,
      assistantModelMessageSchema,
      toolModelMessageSchema
    ]);
    noopTracer = {
      startSpan() {
        return noopSpan;
      },
      startActiveSpan(name212, arg1, arg2, arg3) {
        if (typeof arg1 === "function") {
          return arg1(noopSpan);
        }
        if (typeof arg2 === "function") {
          return arg2(noopSpan);
        }
        if (typeof arg3 === "function") {
          return arg3(noopSpan);
        }
      }
    };
    noopSpan = {
      spanContext() {
        return noopSpanContext;
      },
      setAttribute() {
        return this;
      },
      setAttributes() {
        return this;
      },
      addEvent() {
        return this;
      },
      addLink() {
        return this;
      },
      addLinks() {
        return this;
      },
      setStatus() {
        return this;
      },
      updateName() {
        return this;
      },
      end() {
        return this;
      },
      isRecording() {
        return false;
      },
      recordException() {
        return this;
      }
    };
    noopSpanContext = {
      traceId: "",
      spanId: "",
      traceFlags: 0
    };
    retryWithExponentialBackoffRespectingRetryHeaders = ({
      maxRetries = 2,
      initialDelayInMs = 2e3,
      backoffFactor = 2,
      abortSignal
    } = {}) => async (f) => _retryWithExponentialBackoff(f, {
      maxRetries,
      delayInMs: initialDelayInMs,
      backoffFactor,
      abortSignal
    });
    DefaultGeneratedFile = class {
      constructor({
        data,
        mediaType
      }) {
        const isUint8Array = data instanceof Uint8Array;
        this.base64Data = isUint8Array ? void 0 : data;
        this.uint8ArrayData = isUint8Array ? data : void 0;
        this.mediaType = mediaType;
      }
      // lazy conversion with caching to avoid unnecessary conversion overhead:
      get base64() {
        if (this.base64Data == null) {
          this.base64Data = convertUint8ArrayToBase64(this.uint8ArrayData);
        }
        return this.base64Data;
      }
      // lazy conversion with caching to avoid unnecessary conversion overhead:
      get uint8Array() {
        if (this.uint8ArrayData == null) {
          this.uint8ArrayData = convertBase64ToUint8Array(this.base64Data);
        }
        return this.uint8ArrayData;
      }
    };
    DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {
      constructor(options) {
        super(options);
        this.type = "file";
      }
    };
    output_exports = {};
    __export2(output_exports, {
      array: () => array,
      choice: () => choice,
      json: () => json,
      object: () => object,
      text: () => text
    });
    text = () => ({
      name: "text",
      responseFormat: Promise.resolve({ type: "text" }),
      async parseCompleteOutput({ text: text2 }) {
        return text2;
      },
      async parsePartialOutput({ text: text2 }) {
        return { partial: text2 };
      },
      createElementStreamTransform() {
        return void 0;
      }
    });
    object = ({
      schema: inputSchema,
      name: name212,
      description
    }) => {
      const schema = asSchema(inputSchema);
      return {
        name: "object",
        responseFormat: resolve(schema.jsonSchema).then((jsonSchema22) => ({
          type: "json",
          schema: jsonSchema22,
          ...name212 != null && { name: name212 },
          ...description != null && { description }
        })),
        async parseCompleteOutput({ text: text2 }, context2) {
          const parseResult = await safeParseJSON({ text: text2 });
          if (!parseResult.success) {
            throw new NoObjectGeneratedError({
              message: "No object generated: could not parse the response.",
              cause: parseResult.error,
              text: text2,
              response: context2.response,
              usage: context2.usage,
              finishReason: context2.finishReason
            });
          }
          const validationResult = await safeValidateTypes({
            value: parseResult.value,
            schema
          });
          if (!validationResult.success) {
            throw new NoObjectGeneratedError({
              message: "No object generated: response did not match schema.",
              cause: validationResult.error,
              text: text2,
              response: context2.response,
              usage: context2.usage,
              finishReason: context2.finishReason
            });
          }
          return validationResult.value;
        },
        async parsePartialOutput({ text: text2 }) {
          const result = await parsePartialJson(text2);
          switch (result.state) {
            case "failed-parse":
            case "undefined-input": {
              return void 0;
            }
            case "repaired-parse":
            case "successful-parse": {
              return {
                // Note: currently no validation of partial results:
                partial: result.value
              };
            }
          }
        },
        createElementStreamTransform() {
          return void 0;
        }
      };
    };
    array = ({
      element: inputElementSchema,
      name: name212,
      description
    }) => {
      const elementSchema = asSchema(inputElementSchema);
      return {
        name: "array",
        // JSON schema that describes an array of elements:
        responseFormat: resolve(elementSchema.jsonSchema).then((jsonSchema22) => {
          const { $schema, ...itemSchema } = jsonSchema22;
          return {
            type: "json",
            schema: {
              $schema: "http://json-schema.org/draft-07/schema#",
              type: "object",
              properties: {
                elements: { type: "array", items: itemSchema }
              },
              required: ["elements"],
              additionalProperties: false
            },
            ...name212 != null && { name: name212 },
            ...description != null && { description }
          };
        }),
        async parseCompleteOutput({ text: text2 }, context2) {
          const parseResult = await safeParseJSON({ text: text2 });
          if (!parseResult.success) {
            throw new NoObjectGeneratedError({
              message: "No object generated: could not parse the response.",
              cause: parseResult.error,
              text: text2,
              response: context2.response,
              usage: context2.usage,
              finishReason: context2.finishReason
            });
          }
          const outerValue = parseResult.value;
          if (outerValue == null || typeof outerValue !== "object" || !("elements" in outerValue) || !Array.isArray(outerValue.elements)) {
            throw new NoObjectGeneratedError({
              message: "No object generated: response did not match schema.",
              cause: new TypeValidationError({
                value: outerValue,
                cause: "response must be an object with an elements array"
              }),
              text: text2,
              response: context2.response,
              usage: context2.usage,
              finishReason: context2.finishReason
            });
          }
          for (const element of outerValue.elements) {
            const validationResult = await safeValidateTypes({
              value: element,
              schema: elementSchema
            });
            if (!validationResult.success) {
              throw new NoObjectGeneratedError({
                message: "No object generated: response did not match schema.",
                cause: validationResult.error,
                text: text2,
                response: context2.response,
                usage: context2.usage,
                finishReason: context2.finishReason
              });
            }
          }
          return outerValue.elements;
        },
        async parsePartialOutput({ text: text2 }) {
          const result = await parsePartialJson(text2);
          switch (result.state) {
            case "failed-parse":
            case "undefined-input": {
              return void 0;
            }
            case "repaired-parse":
            case "successful-parse": {
              const outerValue = result.value;
              if (outerValue == null || typeof outerValue !== "object" || !("elements" in outerValue) || !Array.isArray(outerValue.elements)) {
                return void 0;
              }
              const rawElements = result.state === "repaired-parse" && outerValue.elements.length > 0 ? outerValue.elements.slice(0, -1) : outerValue.elements;
              const parsedElements = [];
              for (const rawElement of rawElements) {
                const validationResult = await safeValidateTypes({
                  value: rawElement,
                  schema: elementSchema
                });
                if (validationResult.success) {
                  parsedElements.push(validationResult.value);
                }
              }
              return { partial: parsedElements };
            }
          }
        },
        createElementStreamTransform() {
          let publishedElements = 0;
          return new TransformStream({
            transform({ partialOutput }, controller) {
              if (partialOutput != null) {
                for (; publishedElements < partialOutput.length; publishedElements++) {
                  controller.enqueue(partialOutput[publishedElements]);
                }
              }
            }
          });
        }
      };
    };
    choice = ({
      options: choiceOptions,
      name: name212,
      description
    }) => {
      return {
        name: "choice",
        // JSON schema that describes an enumeration:
        responseFormat: Promise.resolve({
          type: "json",
          schema: {
            $schema: "http://json-schema.org/draft-07/schema#",
            type: "object",
            properties: {
              result: { type: "string", enum: choiceOptions }
            },
            required: ["result"],
            additionalProperties: false
          },
          ...name212 != null && { name: name212 },
          ...description != null && { description }
        }),
        async parseCompleteOutput({ text: text2 }, context2) {
          const parseResult = await safeParseJSON({ text: text2 });
          if (!parseResult.success) {
            throw new NoObjectGeneratedError({
              message: "No object generated: could not parse the response.",
              cause: parseResult.error,
              text: text2,
              response: context2.response,
              usage: context2.usage,
              finishReason: context2.finishReason
            });
          }
          const outerValue = parseResult.value;
          if (outerValue == null || typeof outerValue !== "object" || !("result" in outerValue) || typeof outerValue.result !== "string" || !choiceOptions.includes(outerValue.result)) {
            throw new NoObjectGeneratedError({
              message: "No object generated: response did not match schema.",
              cause: new TypeValidationError({
                value: outerValue,
                cause: "response must be an object that contains a choice value."
              }),
              text: text2,
              response: context2.response,
              usage: context2.usage,
              finishReason: context2.finishReason
            });
          }
          return outerValue.result;
        },
        async parsePartialOutput({ text: text2 }) {
          const result = await parsePartialJson(text2);
          switch (result.state) {
            case "failed-parse":
            case "undefined-input": {
              return void 0;
            }
            case "repaired-parse":
            case "successful-parse": {
              const outerValue = result.value;
              if (outerValue == null || typeof outerValue !== "object" || !("result" in outerValue) || typeof outerValue.result !== "string") {
                return void 0;
              }
              const potentialMatches = choiceOptions.filter(
                (choiceOption) => choiceOption.startsWith(outerValue.result)
              );
              if (result.state === "successful-parse") {
                return potentialMatches.includes(outerValue.result) ? { partial: outerValue.result } : void 0;
              } else {
                return potentialMatches.length === 1 ? { partial: potentialMatches[0] } : void 0;
              }
            }
          }
        },
        createElementStreamTransform() {
          return void 0;
        }
      };
    };
    json = ({
      name: name212,
      description
    } = {}) => {
      return {
        name: "json",
        responseFormat: Promise.resolve({
          type: "json",
          ...name212 != null && { name: name212 },
          ...description != null && { description }
        }),
        async parseCompleteOutput({ text: text2 }, context2) {
          const parseResult = await safeParseJSON({ text: text2 });
          if (!parseResult.success) {
            throw new NoObjectGeneratedError({
              message: "No object generated: could not parse the response.",
              cause: parseResult.error,
              text: text2,
              response: context2.response,
              usage: context2.usage,
              finishReason: context2.finishReason
            });
          }
          return parseResult.value;
        },
        async parsePartialOutput({ text: text2 }) {
          const result = await parsePartialJson(text2);
          switch (result.state) {
            case "failed-parse":
            case "undefined-input": {
              return void 0;
            }
            case "repaired-parse":
            case "successful-parse": {
              return result.value === void 0 ? void 0 : { partial: result.value };
            }
          }
        },
        createElementStreamTransform() {
          return void 0;
        }
      };
    };
    DefaultStepResult = class {
      constructor({
        content,
        finishReason,
        rawFinishReason,
        usage,
        warnings,
        request,
        response,
        providerMetadata
      }) {
        this.content = content;
        this.finishReason = finishReason;
        this.rawFinishReason = rawFinishReason;
        this.usage = usage;
        this.warnings = warnings;
        this.request = request;
        this.response = response;
        this.providerMetadata = providerMetadata;
      }
      get text() {
        return this.content.filter((part) => part.type === "text").map((part) => part.text).join("");
      }
      get reasoning() {
        return this.content.filter((part) => part.type === "reasoning");
      }
      get reasoningText() {
        return this.reasoning.length === 0 ? void 0 : this.reasoning.map((part) => part.text).join("");
      }
      get files() {
        return this.content.filter((part) => part.type === "file").map((part) => part.file);
      }
      get sources() {
        return this.content.filter((part) => part.type === "source");
      }
      get toolCalls() {
        return this.content.filter((part) => part.type === "tool-call");
      }
      get staticToolCalls() {
        return this.toolCalls.filter(
          (toolCall) => toolCall.dynamic !== true
        );
      }
      get dynamicToolCalls() {
        return this.toolCalls.filter(
          (toolCall) => toolCall.dynamic === true
        );
      }
      get toolResults() {
        return this.content.filter((part) => part.type === "tool-result");
      }
      get staticToolResults() {
        return this.toolResults.filter(
          (toolResult) => toolResult.dynamic !== true
        );
      }
      get dynamicToolResults() {
        return this.toolResults.filter(
          (toolResult) => toolResult.dynamic === true
        );
      }
    };
    originalGenerateId = createIdGenerator({
      prefix: "aitxt",
      size: 24
    });
    DefaultGenerateTextResult = class {
      constructor(options) {
        this.steps = options.steps;
        this._output = options.output;
        this.totalUsage = options.totalUsage;
      }
      get finalStep() {
        return this.steps[this.steps.length - 1];
      }
      get content() {
        return this.finalStep.content;
      }
      get text() {
        return this.finalStep.text;
      }
      get files() {
        return this.finalStep.files;
      }
      get reasoningText() {
        return this.finalStep.reasoningText;
      }
      get reasoning() {
        return this.finalStep.reasoning;
      }
      get toolCalls() {
        return this.finalStep.toolCalls;
      }
      get staticToolCalls() {
        return this.finalStep.staticToolCalls;
      }
      get dynamicToolCalls() {
        return this.finalStep.dynamicToolCalls;
      }
      get toolResults() {
        return this.finalStep.toolResults;
      }
      get staticToolResults() {
        return this.finalStep.staticToolResults;
      }
      get dynamicToolResults() {
        return this.finalStep.dynamicToolResults;
      }
      get sources() {
        return this.finalStep.sources;
      }
      get finishReason() {
        return this.finalStep.finishReason;
      }
      get rawFinishReason() {
        return this.finalStep.rawFinishReason;
      }
      get warnings() {
        return this.finalStep.warnings;
      }
      get providerMetadata() {
        return this.finalStep.providerMetadata;
      }
      get response() {
        return this.finalStep.response;
      }
      get request() {
        return this.finalStep.request;
      }
      get usage() {
        return this.finalStep.usage;
      }
      get experimental_output() {
        return this.output;
      }
      get output() {
        if (this._output == null) {
          throw new NoOutputGeneratedError();
        }
        return this._output;
      }
    };
    JsonToSseTransformStream = class extends TransformStream {
      constructor() {
        super({
          transform(part, controller) {
            controller.enqueue(`data: ${JSON.stringify(part)}

`);
          },
          flush(controller) {
            controller.enqueue("data: [DONE]\n\n");
          }
        });
      }
    };
    UI_MESSAGE_STREAM_HEADERS = {
      "content-type": "text/event-stream",
      "cache-control": "no-cache",
      connection: "keep-alive",
      "x-vercel-ai-ui-message-stream": "v1",
      "x-accel-buffering": "no"
      // disable nginx buffering
    };
    uiMessageChunkSchema = lazySchema(
      () => zodSchema(
        z73.union([
          z73.strictObject({
            type: z73.literal("text-start"),
            id: z73.string(),
            providerMetadata: providerMetadataSchema.optional()
          }),
          z73.strictObject({
            type: z73.literal("text-delta"),
            id: z73.string(),
            delta: z73.string(),
            providerMetadata: providerMetadataSchema.optional()
          }),
          z73.strictObject({
            type: z73.literal("text-end"),
            id: z73.string(),
            providerMetadata: providerMetadataSchema.optional()
          }),
          z73.strictObject({
            type: z73.literal("error"),
            errorText: z73.string()
          }),
          z73.strictObject({
            type: z73.literal("tool-input-start"),
            toolCallId: z73.string(),
            toolName: z73.string(),
            providerExecuted: z73.boolean().optional(),
            providerMetadata: providerMetadataSchema.optional(),
            dynamic: z73.boolean().optional(),
            title: z73.string().optional()
          }),
          z73.strictObject({
            type: z73.literal("tool-input-delta"),
            toolCallId: z73.string(),
            inputTextDelta: z73.string()
          }),
          z73.strictObject({
            type: z73.literal("tool-input-available"),
            toolCallId: z73.string(),
            toolName: z73.string(),
            input: z73.unknown(),
            providerExecuted: z73.boolean().optional(),
            providerMetadata: providerMetadataSchema.optional(),
            dynamic: z73.boolean().optional(),
            title: z73.string().optional()
          }),
          z73.strictObject({
            type: z73.literal("tool-input-error"),
            toolCallId: z73.string(),
            toolName: z73.string(),
            input: z73.unknown(),
            providerExecuted: z73.boolean().optional(),
            providerMetadata: providerMetadataSchema.optional(),
            dynamic: z73.boolean().optional(),
            errorText: z73.string(),
            title: z73.string().optional()
          }),
          z73.strictObject({
            type: z73.literal("tool-approval-request"),
            approvalId: z73.string(),
            toolCallId: z73.string()
          }),
          z73.strictObject({
            type: z73.literal("tool-output-available"),
            toolCallId: z73.string(),
            output: z73.unknown(),
            providerExecuted: z73.boolean().optional(),
            dynamic: z73.boolean().optional(),
            preliminary: z73.boolean().optional()
          }),
          z73.strictObject({
            type: z73.literal("tool-output-error"),
            toolCallId: z73.string(),
            errorText: z73.string(),
            providerExecuted: z73.boolean().optional(),
            dynamic: z73.boolean().optional()
          }),
          z73.strictObject({
            type: z73.literal("tool-output-denied"),
            toolCallId: z73.string()
          }),
          z73.strictObject({
            type: z73.literal("reasoning-start"),
            id: z73.string(),
            providerMetadata: providerMetadataSchema.optional()
          }),
          z73.strictObject({
            type: z73.literal("reasoning-delta"),
            id: z73.string(),
            delta: z73.string(),
            providerMetadata: providerMetadataSchema.optional()
          }),
          z73.strictObject({
            type: z73.literal("reasoning-end"),
            id: z73.string(),
            providerMetadata: providerMetadataSchema.optional()
          }),
          z73.strictObject({
            type: z73.literal("source-url"),
            sourceId: z73.string(),
            url: z73.string(),
            title: z73.string().optional(),
            providerMetadata: providerMetadataSchema.optional()
          }),
          z73.strictObject({
            type: z73.literal("source-document"),
            sourceId: z73.string(),
            mediaType: z73.string(),
            title: z73.string(),
            filename: z73.string().optional(),
            providerMetadata: providerMetadataSchema.optional()
          }),
          z73.strictObject({
            type: z73.literal("file"),
            url: z73.string(),
            mediaType: z73.string(),
            providerMetadata: providerMetadataSchema.optional()
          }),
          z73.strictObject({
            type: z73.custom(
              (value2) => typeof value2 === "string" && value2.startsWith("data-"),
              { message: 'Type must start with "data-"' }
            ),
            id: z73.string().optional(),
            data: z73.unknown(),
            transient: z73.boolean().optional()
          }),
          z73.strictObject({
            type: z73.literal("start-step")
          }),
          z73.strictObject({
            type: z73.literal("finish-step")
          }),
          z73.strictObject({
            type: z73.literal("start"),
            messageId: z73.string().optional(),
            messageMetadata: z73.unknown().optional()
          }),
          z73.strictObject({
            type: z73.literal("finish"),
            finishReason: z73.enum([
              "stop",
              "length",
              "content-filter",
              "tool-calls",
              "error",
              "other"
            ]).optional(),
            messageMetadata: z73.unknown().optional()
          }),
          z73.strictObject({
            type: z73.literal("abort"),
            reason: z73.string().optional()
          }),
          z73.strictObject({
            type: z73.literal("message-metadata"),
            messageMetadata: z73.unknown()
          })
        ])
      )
    );
    isToolOrDynamicToolUIPart = isToolUIPart;
    getToolOrDynamicToolName = getToolName;
    originalGenerateId2 = createIdGenerator({
      prefix: "aitxt",
      size: 24
    });
    DefaultStreamTextResult = class {
      constructor({
        model,
        telemetry: telemetry2,
        headers,
        settings,
        maxRetries: maxRetriesArg,
        abortSignal,
        stepTimeoutMs,
        stepAbortController,
        chunkTimeoutMs,
        chunkAbortController,
        system,
        prompt,
        messages,
        tools,
        toolChoice,
        transforms,
        activeTools,
        repairToolCall,
        stopConditions,
        output,
        providerOptions,
        prepareStep,
        includeRawChunks,
        now: now2,
        generateId: generateId22,
        onChunk,
        onError: onError2,
        onFinish: onFinish2,
        onAbort,
        onStepFinish,
        experimental_context,
        download: download2,
        include
      }) {
        this._totalUsage = new DelayedPromise();
        this._finishReason = new DelayedPromise();
        this._rawFinishReason = new DelayedPromise();
        this._steps = new DelayedPromise();
        this.outputSpecification = output;
        this.includeRawChunks = includeRawChunks;
        this.tools = tools;
        let stepFinish;
        let recordedContent = [];
        const recordedResponseMessages = [];
        let recordedFinishReason = void 0;
        let recordedRawFinishReason = void 0;
        let recordedTotalUsage = void 0;
        let recordedRequest = {};
        let recordedWarnings = [];
        const recordedSteps = [];
        const pendingDeferredToolCalls = /* @__PURE__ */ new Map();
        let rootSpan;
        let activeTextContent = {};
        let activeReasoningContent = {};
        const eventProcessor = new TransformStream({
          async transform(chunk, controller) {
            var _a212, _b18, _c, _d;
            controller.enqueue(chunk);
            const { part } = chunk;
            if (part.type === "text-delta" || part.type === "reasoning-delta" || part.type === "source" || part.type === "tool-call" || part.type === "tool-result" || part.type === "tool-input-start" || part.type === "tool-input-delta" || part.type === "raw") {
              await (onChunk == null ? void 0 : onChunk({ chunk: part }));
            }
            if (part.type === "error") {
              await onError2({ error: wrapGatewayError(part.error) });
            }
            if (part.type === "text-start") {
              activeTextContent[part.id] = {
                type: "text",
                text: "",
                providerMetadata: part.providerMetadata
              };
              recordedContent.push(activeTextContent[part.id]);
            }
            if (part.type === "text-delta") {
              const activeText = activeTextContent[part.id];
              if (activeText == null) {
                controller.enqueue({
                  part: {
                    type: "error",
                    error: `text part ${part.id} not found`
                  },
                  partialOutput: void 0
                });
                return;
              }
              activeText.text += part.text;
              activeText.providerMetadata = (_a212 = part.providerMetadata) != null ? _a212 : activeText.providerMetadata;
            }
            if (part.type === "text-end") {
              const activeText = activeTextContent[part.id];
              if (activeText == null) {
                controller.enqueue({
                  part: {
                    type: "error",
                    error: `text part ${part.id} not found`
                  },
                  partialOutput: void 0
                });
                return;
              }
              activeText.providerMetadata = (_b18 = part.providerMetadata) != null ? _b18 : activeText.providerMetadata;
              delete activeTextContent[part.id];
            }
            if (part.type === "reasoning-start") {
              activeReasoningContent[part.id] = {
                type: "reasoning",
                text: "",
                providerMetadata: part.providerMetadata
              };
              recordedContent.push(activeReasoningContent[part.id]);
            }
            if (part.type === "reasoning-delta") {
              const activeReasoning = activeReasoningContent[part.id];
              if (activeReasoning == null) {
                controller.enqueue({
                  part: {
                    type: "error",
                    error: `reasoning part ${part.id} not found`
                  },
                  partialOutput: void 0
                });
                return;
              }
              activeReasoning.text += part.text;
              activeReasoning.providerMetadata = (_c = part.providerMetadata) != null ? _c : activeReasoning.providerMetadata;
            }
            if (part.type === "reasoning-end") {
              const activeReasoning = activeReasoningContent[part.id];
              if (activeReasoning == null) {
                controller.enqueue({
                  part: {
                    type: "error",
                    error: `reasoning part ${part.id} not found`
                  },
                  partialOutput: void 0
                });
                return;
              }
              activeReasoning.providerMetadata = (_d = part.providerMetadata) != null ? _d : activeReasoning.providerMetadata;
              delete activeReasoningContent[part.id];
            }
            if (part.type === "file") {
              recordedContent.push({ type: "file", file: part.file });
            }
            if (part.type === "source") {
              recordedContent.push(part);
            }
            if (part.type === "tool-call") {
              recordedContent.push(part);
            }
            if (part.type === "tool-result" && !part.preliminary) {
              recordedContent.push(part);
            }
            if (part.type === "tool-approval-request") {
              recordedContent.push(part);
            }
            if (part.type === "tool-error") {
              recordedContent.push(part);
            }
            if (part.type === "start-step") {
              recordedContent = [];
              activeReasoningContent = {};
              activeTextContent = {};
              recordedRequest = part.request;
              recordedWarnings = part.warnings;
            }
            if (part.type === "finish-step") {
              const stepMessages = await toResponseMessages({
                content: recordedContent,
                tools
              });
              const currentStepResult = new DefaultStepResult({
                content: recordedContent,
                finishReason: part.finishReason,
                rawFinishReason: part.rawFinishReason,
                usage: part.usage,
                warnings: recordedWarnings,
                request: recordedRequest,
                response: {
                  ...part.response,
                  messages: [...recordedResponseMessages, ...stepMessages]
                },
                providerMetadata: part.providerMetadata
              });
              await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));
              logWarnings({
                warnings: recordedWarnings,
                provider: model.provider,
                model: model.modelId
              });
              recordedSteps.push(currentStepResult);
              recordedResponseMessages.push(...stepMessages);
              stepFinish.resolve();
            }
            if (part.type === "finish") {
              recordedTotalUsage = part.totalUsage;
              recordedFinishReason = part.finishReason;
              recordedRawFinishReason = part.rawFinishReason;
            }
          },
          async flush(controller) {
            try {
              if (recordedSteps.length === 0) {
                const error = (abortSignal == null ? void 0 : abortSignal.aborted) ? abortSignal.reason : new NoOutputGeneratedError({
                  message: "No output generated. Check the stream for errors."
                });
                self._finishReason.reject(error);
                self._rawFinishReason.reject(error);
                self._totalUsage.reject(error);
                self._steps.reject(error);
                return;
              }
              const finishReason = recordedFinishReason != null ? recordedFinishReason : "other";
              const totalUsage = recordedTotalUsage != null ? recordedTotalUsage : createNullLanguageModelUsage();
              self._finishReason.resolve(finishReason);
              self._rawFinishReason.resolve(recordedRawFinishReason);
              self._totalUsage.resolve(totalUsage);
              self._steps.resolve(recordedSteps);
              const finalStep = recordedSteps[recordedSteps.length - 1];
              await (onFinish2 == null ? void 0 : onFinish2({
                finishReason: finalStep.finishReason,
                rawFinishReason: finalStep.rawFinishReason,
                totalUsage,
                usage: finalStep.usage,
                content: finalStep.content,
                text: finalStep.text,
                reasoningText: finalStep.reasoningText,
                reasoning: finalStep.reasoning,
                files: finalStep.files,
                sources: finalStep.sources,
                toolCalls: finalStep.toolCalls,
                staticToolCalls: finalStep.staticToolCalls,
                dynamicToolCalls: finalStep.dynamicToolCalls,
                toolResults: finalStep.toolResults,
                staticToolResults: finalStep.staticToolResults,
                dynamicToolResults: finalStep.dynamicToolResults,
                request: finalStep.request,
                response: finalStep.response,
                warnings: finalStep.warnings,
                providerMetadata: finalStep.providerMetadata,
                steps: recordedSteps,
                experimental_context
              }));
              rootSpan.setAttributes(
                await selectTelemetryAttributes({
                  telemetry: telemetry2,
                  attributes: {
                    "ai.response.finishReason": finishReason,
                    "ai.response.text": { output: () => finalStep.text },
                    "ai.response.toolCalls": {
                      output: () => {
                        var _a212;
                        return ((_a212 = finalStep.toolCalls) == null ? void 0 : _a212.length) ? JSON.stringify(finalStep.toolCalls) : void 0;
                      }
                    },
                    "ai.response.providerMetadata": JSON.stringify(
                      finalStep.providerMetadata
                    ),
                    "ai.usage.inputTokens": totalUsage.inputTokens,
                    "ai.usage.outputTokens": totalUsage.outputTokens,
                    "ai.usage.totalTokens": totalUsage.totalTokens,
                    "ai.usage.reasoningTokens": totalUsage.reasoningTokens,
                    "ai.usage.cachedInputTokens": totalUsage.cachedInputTokens
                  }
                })
              );
            } catch (error) {
              controller.error(error);
            } finally {
              rootSpan.end();
            }
          }
        });
        const stitchableStream = createStitchableStream();
        this.addStream = stitchableStream.addStream;
        this.closeStream = stitchableStream.close;
        const reader = stitchableStream.stream.getReader();
        let stream = new ReadableStream({
          async start(controller) {
            controller.enqueue({ type: "start" });
          },
          async pull(controller) {
            function abort() {
              onAbort == null ? void 0 : onAbort({ steps: recordedSteps });
              controller.enqueue({
                type: "abort",
                // The `reason` is usually of type DOMException, but it can also be of any type,
                // so we use getErrorMessage for serialization because it is already designed to accept values of the unknown type.
                // See: https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/reason
                ...(abortSignal == null ? void 0 : abortSignal.reason) !== void 0 ? { reason: getErrorMessage(abortSignal.reason) } : {}
              });
              controller.close();
            }
            try {
              const { done, value: value2 } = await reader.read();
              if (done) {
                controller.close();
                return;
              }
              if (abortSignal == null ? void 0 : abortSignal.aborted) {
                abort();
                return;
              }
              controller.enqueue(value2);
            } catch (error) {
              if (isAbortError(error) && (abortSignal == null ? void 0 : abortSignal.aborted)) {
                abort();
              } else {
                controller.error(error);
              }
            }
          },
          cancel(reason) {
            return stitchableStream.stream.cancel(reason);
          }
        });
        for (const transform of transforms) {
          stream = stream.pipeThrough(
            transform({
              tools,
              stopStream() {
                stitchableStream.terminate();
              }
            })
          );
        }
        this.baseStream = stream.pipeThrough(createOutputTransformStream(output != null ? output : text())).pipeThrough(eventProcessor);
        const { maxRetries, retry } = prepareRetries({
          maxRetries: maxRetriesArg,
          abortSignal
        });
        const tracer = getTracer(telemetry2);
        const callSettings = prepareCallSettings(settings);
        const baseTelemetryAttributes = getBaseTelemetryAttributes({
          model,
          telemetry: telemetry2,
          headers,
          settings: { ...callSettings, maxRetries }
        });
        const self = this;
        recordSpan({
          name: "ai.streamText",
          attributes: selectTelemetryAttributes({
            telemetry: telemetry2,
            attributes: {
              ...assembleOperationName({ operationId: "ai.streamText", telemetry: telemetry2 }),
              ...baseTelemetryAttributes,
              // specific settings that only make sense on the outer level:
              "ai.prompt": {
                input: () => JSON.stringify({ system, prompt, messages })
              }
            }
          }),
          tracer,
          endWhenDone: false,
          fn: async (rootSpanArg) => {
            rootSpan = rootSpanArg;
            const initialPrompt = await standardizePrompt({
              system,
              prompt,
              messages
            });
            const initialMessages = initialPrompt.messages;
            const initialResponseMessages = [];
            const { approvedToolApprovals, deniedToolApprovals } = collectToolApprovals({ messages: initialMessages });
            if (deniedToolApprovals.length > 0 || approvedToolApprovals.length > 0) {
              const providerExecutedToolApprovals = [
                ...approvedToolApprovals,
                ...deniedToolApprovals
              ].filter((toolApproval) => toolApproval.toolCall.providerExecuted);
              const localApprovedToolApprovals = approvedToolApprovals.filter(
                (toolApproval) => !toolApproval.toolCall.providerExecuted
              );
              const localDeniedToolApprovals = deniedToolApprovals.filter(
                (toolApproval) => !toolApproval.toolCall.providerExecuted
              );
              const deniedProviderExecutedToolApprovals = deniedToolApprovals.filter(
                (toolApproval) => toolApproval.toolCall.providerExecuted
              );
              let toolExecutionStepStreamController;
              const toolExecutionStepStream = new ReadableStream({
                start(controller) {
                  toolExecutionStepStreamController = controller;
                }
              });
              self.addStream(toolExecutionStepStream);
              try {
                for (const toolApproval of [
                  ...localDeniedToolApprovals,
                  ...deniedProviderExecutedToolApprovals
                ]) {
                  toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue({
                    type: "tool-output-denied",
                    toolCallId: toolApproval.toolCall.toolCallId,
                    toolName: toolApproval.toolCall.toolName
                  });
                }
                const toolOutputs = [];
                await Promise.all(
                  localApprovedToolApprovals.map(async (toolApproval) => {
                    const result = await executeToolCall({
                      toolCall: toolApproval.toolCall,
                      tools,
                      tracer,
                      telemetry: telemetry2,
                      messages: initialMessages,
                      abortSignal,
                      experimental_context,
                      onPreliminaryToolResult: (result2) => {
                        toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue(result2);
                      }
                    });
                    if (result != null) {
                      toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue(result);
                      toolOutputs.push(result);
                    }
                  })
                );
                if (providerExecutedToolApprovals.length > 0) {
                  initialResponseMessages.push({
                    role: "tool",
                    content: providerExecutedToolApprovals.map(
                      (toolApproval) => ({
                        type: "tool-approval-response",
                        approvalId: toolApproval.approvalResponse.approvalId,
                        approved: toolApproval.approvalResponse.approved,
                        reason: toolApproval.approvalResponse.reason,
                        providerExecuted: true
                      })
                    )
                  });
                }
                if (toolOutputs.length > 0 || localDeniedToolApprovals.length > 0) {
                  const localToolContent = [];
                  for (const output2 of toolOutputs) {
                    localToolContent.push({
                      type: "tool-result",
                      toolCallId: output2.toolCallId,
                      toolName: output2.toolName,
                      output: await createToolModelOutput({
                        toolCallId: output2.toolCallId,
                        input: output2.input,
                        tool: tools == null ? void 0 : tools[output2.toolName],
                        output: output2.type === "tool-result" ? output2.output : output2.error,
                        errorMode: output2.type === "tool-error" ? "json" : "none"
                      })
                    });
                  }
                  for (const toolApproval of localDeniedToolApprovals) {
                    localToolContent.push({
                      type: "tool-result",
                      toolCallId: toolApproval.toolCall.toolCallId,
                      toolName: toolApproval.toolCall.toolName,
                      output: {
                        type: "execution-denied",
                        reason: toolApproval.approvalResponse.reason
                      }
                    });
                  }
                  initialResponseMessages.push({
                    role: "tool",
                    content: localToolContent
                  });
                }
              } finally {
                toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.close();
              }
            }
            recordedResponseMessages.push(...initialResponseMessages);
            async function streamStep({
              currentStep,
              responseMessages,
              usage
            }) {
              var _a212, _b18, _c, _d, _e, _f, _g;
              const includeRawChunks2 = self.includeRawChunks;
              const stepTimeoutId = stepTimeoutMs != null ? setTimeout(() => stepAbortController.abort(), stepTimeoutMs) : void 0;
              let chunkTimeoutId = void 0;
              function resetChunkTimeout() {
                if (chunkTimeoutMs != null) {
                  if (chunkTimeoutId != null) {
                    clearTimeout(chunkTimeoutId);
                  }
                  chunkTimeoutId = setTimeout(
                    () => chunkAbortController.abort(),
                    chunkTimeoutMs
                  );
                }
              }
              function clearChunkTimeout() {
                if (chunkTimeoutId != null) {
                  clearTimeout(chunkTimeoutId);
                  chunkTimeoutId = void 0;
                }
              }
              function clearStepTimeout() {
                if (stepTimeoutId != null) {
                  clearTimeout(stepTimeoutId);
                }
              }
              try {
                stepFinish = new DelayedPromise();
                const stepInputMessages = [...initialMessages, ...responseMessages];
                const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({
                  model,
                  steps: recordedSteps,
                  stepNumber: recordedSteps.length,
                  messages: stepInputMessages,
                  experimental_context
                }));
                const stepModel = resolveLanguageModel(
                  (_a212 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a212 : model
                );
                const promptMessages = await convertToLanguageModelPrompt({
                  prompt: {
                    system: (_b18 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b18 : initialPrompt.system,
                    messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages
                  },
                  supportedUrls: await stepModel.supportedUrls,
                  download: download2
                });
                const { toolChoice: stepToolChoice, tools: stepTools } = await prepareToolsAndToolChoice({
                  tools,
                  toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,
                  activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools
                });
                experimental_context = (_f = prepareStepResult == null ? void 0 : prepareStepResult.experimental_context) != null ? _f : experimental_context;
                const stepProviderOptions = mergeObjects(
                  providerOptions,
                  prepareStepResult == null ? void 0 : prepareStepResult.providerOptions
                );
                const {
                  result: { stream: stream2, response, request },
                  doStreamSpan,
                  startTimestampMs
                } = await retry(
                  () => recordSpan({
                    name: "ai.streamText.doStream",
                    attributes: selectTelemetryAttributes({
                      telemetry: telemetry2,
                      attributes: {
                        ...assembleOperationName({
                          operationId: "ai.streamText.doStream",
                          telemetry: telemetry2
                        }),
                        ...baseTelemetryAttributes,
                        // model:
                        "ai.model.provider": stepModel.provider,
                        "ai.model.id": stepModel.modelId,
                        // prompt:
                        "ai.prompt.messages": {
                          input: () => stringifyForTelemetry(promptMessages)
                        },
                        "ai.prompt.tools": {
                          // convert the language model level tools:
                          input: () => stepTools == null ? void 0 : stepTools.map((tool2) => JSON.stringify(tool2))
                        },
                        "ai.prompt.toolChoice": {
                          input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0
                        },
                        // standardized gen-ai llm span attributes:
                        "gen_ai.system": stepModel.provider,
                        "gen_ai.request.model": stepModel.modelId,
                        "gen_ai.request.frequency_penalty": callSettings.frequencyPenalty,
                        "gen_ai.request.max_tokens": callSettings.maxOutputTokens,
                        "gen_ai.request.presence_penalty": callSettings.presencePenalty,
                        "gen_ai.request.stop_sequences": callSettings.stopSequences,
                        "gen_ai.request.temperature": callSettings.temperature,
                        "gen_ai.request.top_k": callSettings.topK,
                        "gen_ai.request.top_p": callSettings.topP
                      }
                    }),
                    tracer,
                    endWhenDone: false,
                    fn: async (doStreamSpan2) => ({
                      startTimestampMs: now2(),
                      // get before the call
                      doStreamSpan: doStreamSpan2,
                      result: await stepModel.doStream({
                        ...callSettings,
                        tools: stepTools,
                        toolChoice: stepToolChoice,
                        responseFormat: await (output == null ? void 0 : output.responseFormat),
                        prompt: promptMessages,
                        providerOptions: stepProviderOptions,
                        abortSignal,
                        headers,
                        includeRawChunks: includeRawChunks2
                      })
                    })
                  })
                );
                const streamWithToolResults = runToolsTransformation({
                  tools,
                  generatorStream: stream2,
                  tracer,
                  telemetry: telemetry2,
                  system,
                  messages: stepInputMessages,
                  repairToolCall,
                  abortSignal,
                  experimental_context,
                  generateId: generateId22
                });
                const stepRequest = ((_g = include == null ? void 0 : include.requestBody) != null ? _g : true) ? request != null ? request : {} : { ...request, body: void 0 };
                const stepToolCalls = [];
                const stepToolOutputs = [];
                let warnings;
                const activeToolCallToolNames = {};
                let stepFinishReason = "other";
                let stepRawFinishReason = void 0;
                let stepUsage = createNullLanguageModelUsage();
                let stepProviderMetadata;
                let stepFirstChunk = true;
                let stepResponse = {
                  id: generateId22(),
                  timestamp: /* @__PURE__ */ new Date(),
                  modelId: model.modelId
                };
                let activeText = "";
                self.addStream(
                  streamWithToolResults.pipeThrough(
                    new TransformStream({
                      async transform(chunk, controller) {
                        var _a222, _b24, _c2, _d2, _e2;
                        resetChunkTimeout();
                        if (chunk.type === "stream-start") {
                          warnings = chunk.warnings;
                          return;
                        }
                        if (stepFirstChunk) {
                          const msToFirstChunk = now2() - startTimestampMs;
                          stepFirstChunk = false;
                          doStreamSpan.addEvent("ai.stream.firstChunk", {
                            "ai.response.msToFirstChunk": msToFirstChunk
                          });
                          doStreamSpan.setAttributes({
                            "ai.response.msToFirstChunk": msToFirstChunk
                          });
                          controller.enqueue({
                            type: "start-step",
                            request: stepRequest,
                            warnings: warnings != null ? warnings : []
                          });
                        }
                        const chunkType = chunk.type;
                        switch (chunkType) {
                          case "tool-approval-request":
                          case "text-start":
                          case "text-end": {
                            controller.enqueue(chunk);
                            break;
                          }
                          case "text-delta": {
                            if (chunk.delta.length > 0) {
                              controller.enqueue({
                                type: "text-delta",
                                id: chunk.id,
                                text: chunk.delta,
                                providerMetadata: chunk.providerMetadata
                              });
                              activeText += chunk.delta;
                            }
                            break;
                          }
                          case "reasoning-start":
                          case "reasoning-end": {
                            controller.enqueue(chunk);
                            break;
                          }
                          case "reasoning-delta": {
                            controller.enqueue({
                              type: "reasoning-delta",
                              id: chunk.id,
                              text: chunk.delta,
                              providerMetadata: chunk.providerMetadata
                            });
                            break;
                          }
                          case "tool-call": {
                            controller.enqueue(chunk);
                            stepToolCalls.push(chunk);
                            break;
                          }
                          case "tool-result": {
                            controller.enqueue(chunk);
                            if (!chunk.preliminary) {
                              stepToolOutputs.push(chunk);
                            }
                            break;
                          }
                          case "tool-error": {
                            controller.enqueue(chunk);
                            stepToolOutputs.push(chunk);
                            break;
                          }
                          case "response-metadata": {
                            stepResponse = {
                              id: (_a222 = chunk.id) != null ? _a222 : stepResponse.id,
                              timestamp: (_b24 = chunk.timestamp) != null ? _b24 : stepResponse.timestamp,
                              modelId: (_c2 = chunk.modelId) != null ? _c2 : stepResponse.modelId
                            };
                            break;
                          }
                          case "finish": {
                            stepUsage = chunk.usage;
                            stepFinishReason = chunk.finishReason;
                            stepRawFinishReason = chunk.rawFinishReason;
                            stepProviderMetadata = chunk.providerMetadata;
                            const msToFinish = now2() - startTimestampMs;
                            doStreamSpan.addEvent("ai.stream.finish");
                            doStreamSpan.setAttributes({
                              "ai.response.msToFinish": msToFinish,
                              "ai.response.avgOutputTokensPerSecond": 1e3 * ((_d2 = stepUsage.outputTokens) != null ? _d2 : 0) / msToFinish
                            });
                            break;
                          }
                          case "file": {
                            controller.enqueue(chunk);
                            break;
                          }
                          case "source": {
                            controller.enqueue(chunk);
                            break;
                          }
                          case "tool-input-start": {
                            activeToolCallToolNames[chunk.id] = chunk.toolName;
                            const tool2 = tools == null ? void 0 : tools[chunk.toolName];
                            if ((tool2 == null ? void 0 : tool2.onInputStart) != null) {
                              await tool2.onInputStart({
                                toolCallId: chunk.id,
                                messages: stepInputMessages,
                                abortSignal,
                                experimental_context
                              });
                            }
                            controller.enqueue({
                              ...chunk,
                              dynamic: (_e2 = chunk.dynamic) != null ? _e2 : (tool2 == null ? void 0 : tool2.type) === "dynamic",
                              title: tool2 == null ? void 0 : tool2.title
                            });
                            break;
                          }
                          case "tool-input-end": {
                            delete activeToolCallToolNames[chunk.id];
                            controller.enqueue(chunk);
                            break;
                          }
                          case "tool-input-delta": {
                            const toolName = activeToolCallToolNames[chunk.id];
                            const tool2 = tools == null ? void 0 : tools[toolName];
                            if ((tool2 == null ? void 0 : tool2.onInputDelta) != null) {
                              await tool2.onInputDelta({
                                inputTextDelta: chunk.delta,
                                toolCallId: chunk.id,
                                messages: stepInputMessages,
                                abortSignal,
                                experimental_context
                              });
                            }
                            controller.enqueue(chunk);
                            break;
                          }
                          case "error": {
                            controller.enqueue(chunk);
                            stepFinishReason = "error";
                            break;
                          }
                          case "raw": {
                            if (includeRawChunks2) {
                              controller.enqueue(chunk);
                            }
                            break;
                          }
                          default: {
                            const exhaustiveCheck = chunkType;
                            throw new Error(
                              `Unknown chunk type: ${exhaustiveCheck}`
                            );
                          }
                        }
                      },
                      // invoke onFinish callback and resolve toolResults promise when the stream is about to close:
                      async flush(controller) {
                        const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;
                        try {
                          doStreamSpan.setAttributes(
                            await selectTelemetryAttributes({
                              telemetry: telemetry2,
                              attributes: {
                                "ai.response.finishReason": stepFinishReason,
                                "ai.response.text": {
                                  output: () => activeText
                                },
                                "ai.response.toolCalls": {
                                  output: () => stepToolCallsJson
                                },
                                "ai.response.id": stepResponse.id,
                                "ai.response.model": stepResponse.modelId,
                                "ai.response.timestamp": stepResponse.timestamp.toISOString(),
                                "ai.response.providerMetadata": JSON.stringify(stepProviderMetadata),
                                "ai.usage.inputTokens": stepUsage.inputTokens,
                                "ai.usage.outputTokens": stepUsage.outputTokens,
                                "ai.usage.totalTokens": stepUsage.totalTokens,
                                "ai.usage.reasoningTokens": stepUsage.reasoningTokens,
                                "ai.usage.cachedInputTokens": stepUsage.cachedInputTokens,
                                // standardized gen-ai llm span attributes:
                                "gen_ai.response.finish_reasons": [
                                  stepFinishReason
                                ],
                                "gen_ai.response.id": stepResponse.id,
                                "gen_ai.response.model": stepResponse.modelId,
                                "gen_ai.usage.input_tokens": stepUsage.inputTokens,
                                "gen_ai.usage.output_tokens": stepUsage.outputTokens
                              }
                            })
                          );
                        } catch (error) {
                        } finally {
                          doStreamSpan.end();
                        }
                        controller.enqueue({
                          type: "finish-step",
                          finishReason: stepFinishReason,
                          rawFinishReason: stepRawFinishReason,
                          usage: stepUsage,
                          providerMetadata: stepProviderMetadata,
                          response: {
                            ...stepResponse,
                            headers: response == null ? void 0 : response.headers
                          }
                        });
                        const combinedUsage = addLanguageModelUsage(
                          usage,
                          stepUsage
                        );
                        await stepFinish.promise;
                        const clientToolCalls = stepToolCalls.filter(
                          (toolCall) => toolCall.providerExecuted !== true
                        );
                        const clientToolOutputs = stepToolOutputs.filter(
                          (toolOutput) => toolOutput.providerExecuted !== true
                        );
                        for (const toolCall of stepToolCalls) {
                          if (toolCall.providerExecuted !== true)
                            continue;
                          const tool2 = tools == null ? void 0 : tools[toolCall.toolName];
                          if ((tool2 == null ? void 0 : tool2.type) === "provider" && tool2.supportsDeferredResults) {
                            const hasResultInStep = stepToolOutputs.some(
                              (output2) => (output2.type === "tool-result" || output2.type === "tool-error") && output2.toolCallId === toolCall.toolCallId
                            );
                            if (!hasResultInStep) {
                              pendingDeferredToolCalls.set(toolCall.toolCallId, {
                                toolName: toolCall.toolName
                              });
                            }
                          }
                        }
                        for (const output2 of stepToolOutputs) {
                          if (output2.type === "tool-result" || output2.type === "tool-error") {
                            pendingDeferredToolCalls.delete(output2.toolCallId);
                          }
                        }
                        clearStepTimeout();
                        clearChunkTimeout();
                        if (
                          // Continue if:
                          // 1. There are client tool calls that have all been executed, OR
                          // 2. There are pending deferred results from provider-executed tools
                          (clientToolCalls.length > 0 && clientToolOutputs.length === clientToolCalls.length || pendingDeferredToolCalls.size > 0) && // continue until a stop condition is met:
                          !await isStopConditionMet({
                            stopConditions,
                            steps: recordedSteps
                          })
                        ) {
                          responseMessages.push(
                            ...await toResponseMessages({
                              content: (
                                // use transformed content to create the messages for the next step:
                                recordedSteps[recordedSteps.length - 1].content
                              ),
                              tools
                            })
                          );
                          try {
                            await streamStep({
                              currentStep: currentStep + 1,
                              responseMessages,
                              usage: combinedUsage
                            });
                          } catch (error) {
                            controller.enqueue({
                              type: "error",
                              error
                            });
                            self.closeStream();
                          }
                        } else {
                          controller.enqueue({
                            type: "finish",
                            finishReason: stepFinishReason,
                            rawFinishReason: stepRawFinishReason,
                            totalUsage: combinedUsage
                          });
                          self.closeStream();
                        }
                      }
                    })
                  )
                );
              } finally {
                clearStepTimeout();
                clearChunkTimeout();
              }
            }
            await streamStep({
              currentStep: 0,
              responseMessages: initialResponseMessages,
              usage: createNullLanguageModelUsage()
            });
          }
        }).catch((error) => {
          self.addStream(
            new ReadableStream({
              start(controller) {
                controller.enqueue({ type: "error", error });
                controller.close();
              }
            })
          );
          self.closeStream();
        });
      }
      get steps() {
        this.consumeStream();
        return this._steps.promise;
      }
      get finalStep() {
        return this.steps.then((steps) => steps[steps.length - 1]);
      }
      get content() {
        return this.finalStep.then((step) => step.content);
      }
      get warnings() {
        return this.finalStep.then((step) => step.warnings);
      }
      get providerMetadata() {
        return this.finalStep.then((step) => step.providerMetadata);
      }
      get text() {
        return this.finalStep.then((step) => step.text);
      }
      get reasoningText() {
        return this.finalStep.then((step) => step.reasoningText);
      }
      get reasoning() {
        return this.finalStep.then((step) => step.reasoning);
      }
      get sources() {
        return this.finalStep.then((step) => step.sources);
      }
      get files() {
        return this.finalStep.then((step) => step.files);
      }
      get toolCalls() {
        return this.finalStep.then((step) => step.toolCalls);
      }
      get staticToolCalls() {
        return this.finalStep.then((step) => step.staticToolCalls);
      }
      get dynamicToolCalls() {
        return this.finalStep.then((step) => step.dynamicToolCalls);
      }
      get toolResults() {
        return this.finalStep.then((step) => step.toolResults);
      }
      get staticToolResults() {
        return this.finalStep.then((step) => step.staticToolResults);
      }
      get dynamicToolResults() {
        return this.finalStep.then((step) => step.dynamicToolResults);
      }
      get usage() {
        return this.finalStep.then((step) => step.usage);
      }
      get request() {
        return this.finalStep.then((step) => step.request);
      }
      get response() {
        return this.finalStep.then((step) => step.response);
      }
      get totalUsage() {
        this.consumeStream();
        return this._totalUsage.promise;
      }
      get finishReason() {
        this.consumeStream();
        return this._finishReason.promise;
      }
      get rawFinishReason() {
        this.consumeStream();
        return this._rawFinishReason.promise;
      }
      /**
       * Split out a new stream from the original stream.
       * The original stream is replaced to allow for further splitting,
       * since we do not know how many times the stream will be split.
       *
       * Note: this leads to buffering the stream content on the server.
       * However, the LLM results are expected to be small enough to not cause issues.
       */
      teeStream() {
        const [stream1, stream2] = this.baseStream.tee();
        this.baseStream = stream2;
        return stream1;
      }
      get textStream() {
        return createAsyncIterableStream(
          this.teeStream().pipeThrough(
            new TransformStream({
              transform({ part }, controller) {
                if (part.type === "text-delta") {
                  controller.enqueue(part.text);
                }
              }
            })
          )
        );
      }
      get fullStream() {
        return createAsyncIterableStream(
          this.teeStream().pipeThrough(
            new TransformStream({
              transform({ part }, controller) {
                controller.enqueue(part);
              }
            })
          )
        );
      }
      async consumeStream(options) {
        var _a212;
        try {
          await consumeStream({
            stream: this.fullStream,
            onError: options == null ? void 0 : options.onError
          });
        } catch (error) {
          (_a212 = options == null ? void 0 : options.onError) == null ? void 0 : _a212.call(options, error);
        }
      }
      get experimental_partialOutputStream() {
        return this.partialOutputStream;
      }
      get partialOutputStream() {
        return createAsyncIterableStream(
          this.teeStream().pipeThrough(
            new TransformStream({
              transform({ partialOutput }, controller) {
                if (partialOutput != null) {
                  controller.enqueue(partialOutput);
                }
              }
            })
          )
        );
      }
      get elementStream() {
        var _a212, _b18, _c;
        const transform = (_a212 = this.outputSpecification) == null ? void 0 : _a212.createElementStreamTransform();
        if (transform == null) {
          throw new UnsupportedFunctionalityError({
            functionality: `element streams in ${(_c = (_b18 = this.outputSpecification) == null ? void 0 : _b18.name) != null ? _c : "text"} mode`
          });
        }
        return createAsyncIterableStream(this.teeStream().pipeThrough(transform));
      }
      get output() {
        return this.finalStep.then((step) => {
          var _a212;
          const output = (_a212 = this.outputSpecification) != null ? _a212 : text();
          return output.parseCompleteOutput(
            { text: step.text },
            {
              response: step.response,
              usage: step.usage,
              finishReason: step.finishReason
            }
          );
        });
      }
      toUIMessageStream({
        originalMessages,
        generateMessageId,
        onFinish: onFinish2,
        messageMetadata,
        sendReasoning = true,
        sendSources = false,
        sendStart = true,
        sendFinish = true,
        onError: onError2 = getErrorMessage
      } = {}) {
        const responseMessageId = generateMessageId != null ? getResponseUIMessageId({
          originalMessages,
          responseMessageId: generateMessageId
        }) : void 0;
        const isDynamic = (part) => {
          var _a212;
          const tool2 = (_a212 = this.tools) == null ? void 0 : _a212[part.toolName];
          if (tool2 == null) {
            return part.dynamic;
          }
          return (tool2 == null ? void 0 : tool2.type) === "dynamic" ? true : void 0;
        };
        const baseStream = this.fullStream.pipeThrough(
          new TransformStream({
            transform: async (part, controller) => {
              const messageMetadataValue = messageMetadata == null ? void 0 : messageMetadata({ part });
              const partType = part.type;
              switch (partType) {
                case "text-start": {
                  controller.enqueue({
                    type: "text-start",
                    id: part.id,
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                  });
                  break;
                }
                case "text-delta": {
                  controller.enqueue({
                    type: "text-delta",
                    id: part.id,
                    delta: part.text,
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                  });
                  break;
                }
                case "text-end": {
                  controller.enqueue({
                    type: "text-end",
                    id: part.id,
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                  });
                  break;
                }
                case "reasoning-start": {
                  controller.enqueue({
                    type: "reasoning-start",
                    id: part.id,
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                  });
                  break;
                }
                case "reasoning-delta": {
                  if (sendReasoning) {
                    controller.enqueue({
                      type: "reasoning-delta",
                      id: part.id,
                      delta: part.text,
                      ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                    });
                  }
                  break;
                }
                case "reasoning-end": {
                  controller.enqueue({
                    type: "reasoning-end",
                    id: part.id,
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                  });
                  break;
                }
                case "file": {
                  controller.enqueue({
                    type: "file",
                    mediaType: part.file.mediaType,
                    url: `data:${part.file.mediaType};base64,${part.file.base64}`
                  });
                  break;
                }
                case "source": {
                  if (sendSources && part.sourceType === "url") {
                    controller.enqueue({
                      type: "source-url",
                      sourceId: part.id,
                      url: part.url,
                      title: part.title,
                      ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                    });
                  }
                  if (sendSources && part.sourceType === "document") {
                    controller.enqueue({
                      type: "source-document",
                      sourceId: part.id,
                      mediaType: part.mediaType,
                      title: part.title,
                      filename: part.filename,
                      ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                    });
                  }
                  break;
                }
                case "tool-input-start": {
                  const dynamic = isDynamic(part);
                  controller.enqueue({
                    type: "tool-input-start",
                    toolCallId: part.id,
                    toolName: part.toolName,
                    ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},
                    ...dynamic != null ? { dynamic } : {},
                    ...part.title != null ? { title: part.title } : {}
                  });
                  break;
                }
                case "tool-input-delta": {
                  controller.enqueue({
                    type: "tool-input-delta",
                    toolCallId: part.id,
                    inputTextDelta: part.delta
                  });
                  break;
                }
                case "tool-call": {
                  const dynamic = isDynamic(part);
                  if (part.invalid) {
                    controller.enqueue({
                      type: "tool-input-error",
                      toolCallId: part.toolCallId,
                      toolName: part.toolName,
                      input: part.input,
                      ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                      ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},
                      ...dynamic != null ? { dynamic } : {},
                      errorText: onError2(part.error),
                      ...part.title != null ? { title: part.title } : {}
                    });
                  } else {
                    controller.enqueue({
                      type: "tool-input-available",
                      toolCallId: part.toolCallId,
                      toolName: part.toolName,
                      input: part.input,
                      ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                      ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},
                      ...dynamic != null ? { dynamic } : {},
                      ...part.title != null ? { title: part.title } : {}
                    });
                  }
                  break;
                }
                case "tool-approval-request": {
                  controller.enqueue({
                    type: "tool-approval-request",
                    approvalId: part.approvalId,
                    toolCallId: part.toolCall.toolCallId
                  });
                  break;
                }
                case "tool-result": {
                  const dynamic = isDynamic(part);
                  controller.enqueue({
                    type: "tool-output-available",
                    toolCallId: part.toolCallId,
                    output: part.output,
                    ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                    ...part.preliminary != null ? { preliminary: part.preliminary } : {},
                    ...dynamic != null ? { dynamic } : {}
                  });
                  break;
                }
                case "tool-error": {
                  const dynamic = isDynamic(part);
                  controller.enqueue({
                    type: "tool-output-error",
                    toolCallId: part.toolCallId,
                    errorText: onError2(part.error),
                    ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                    ...dynamic != null ? { dynamic } : {}
                  });
                  break;
                }
                case "tool-output-denied": {
                  controller.enqueue({
                    type: "tool-output-denied",
                    toolCallId: part.toolCallId
                  });
                  break;
                }
                case "error": {
                  controller.enqueue({
                    type: "error",
                    errorText: onError2(part.error)
                  });
                  break;
                }
                case "start-step": {
                  controller.enqueue({ type: "start-step" });
                  break;
                }
                case "finish-step": {
                  controller.enqueue({ type: "finish-step" });
                  break;
                }
                case "start": {
                  if (sendStart) {
                    controller.enqueue({
                      type: "start",
                      ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {},
                      ...responseMessageId != null ? { messageId: responseMessageId } : {}
                    });
                  }
                  break;
                }
                case "finish": {
                  if (sendFinish) {
                    controller.enqueue({
                      type: "finish",
                      finishReason: part.finishReason,
                      ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {}
                    });
                  }
                  break;
                }
                case "abort": {
                  controller.enqueue(part);
                  break;
                }
                case "tool-input-end": {
                  break;
                }
                case "raw": {
                  break;
                }
                default: {
                  const exhaustiveCheck = partType;
                  throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
                }
              }
              if (messageMetadataValue != null && partType !== "start" && partType !== "finish") {
                controller.enqueue({
                  type: "message-metadata",
                  messageMetadata: messageMetadataValue
                });
              }
            }
          })
        );
        return createAsyncIterableStream(
          handleUIMessageStreamFinish({
            stream: baseStream,
            messageId: responseMessageId != null ? responseMessageId : generateMessageId == null ? void 0 : generateMessageId(),
            originalMessages,
            onFinish: onFinish2,
            onError: onError2
          })
        );
      }
      pipeUIMessageStreamToResponse(response, {
        originalMessages,
        generateMessageId,
        onFinish: onFinish2,
        messageMetadata,
        sendReasoning,
        sendSources,
        sendFinish,
        sendStart,
        onError: onError2,
        ...init
      } = {}) {
        pipeUIMessageStreamToResponse({
          response,
          stream: this.toUIMessageStream({
            originalMessages,
            generateMessageId,
            onFinish: onFinish2,
            messageMetadata,
            sendReasoning,
            sendSources,
            sendFinish,
            sendStart,
            onError: onError2
          }),
          ...init
        });
      }
      pipeTextStreamToResponse(response, init) {
        pipeTextStreamToResponse({
          response,
          textStream: this.textStream,
          ...init
        });
      }
      toUIMessageStreamResponse({
        originalMessages,
        generateMessageId,
        onFinish: onFinish2,
        messageMetadata,
        sendReasoning,
        sendSources,
        sendFinish,
        sendStart,
        onError: onError2,
        ...init
      } = {}) {
        return createUIMessageStreamResponse({
          stream: this.toUIMessageStream({
            originalMessages,
            generateMessageId,
            onFinish: onFinish2,
            messageMetadata,
            sendReasoning,
            sendSources,
            sendFinish,
            sendStart,
            onError: onError2
          }),
          ...init
        });
      }
      toTextStreamResponse(init) {
        return createTextStreamResponse({
          textStream: this.textStream,
          ...init
        });
      }
    };
    ToolLoopAgent = class {
      constructor(settings) {
        this.version = "agent-v1";
        this.settings = settings;
      }
      /**
       * The id of the agent.
       */
      get id() {
        return this.settings.id;
      }
      /**
       * The tools that the agent can use.
       */
      get tools() {
        return this.settings.tools;
      }
      async prepareCall(options) {
        var _a212, _b18, _c, _d;
        const { onStepFinish: _settingsOnStepFinish, ...settingsWithoutCallback } = this.settings;
        const baseCallArgs = {
          ...settingsWithoutCallback,
          stopWhen: (_a212 = this.settings.stopWhen) != null ? _a212 : stepCountIs(20),
          ...options
        };
        const preparedCallArgs = (_d = await ((_c = (_b18 = this.settings).prepareCall) == null ? void 0 : _c.call(
          _b18,
          baseCallArgs
        ))) != null ? _d : baseCallArgs;
        const { instructions, messages, prompt, ...callArgs } = preparedCallArgs;
        return {
          ...callArgs,
          // restore prompt types
          ...{ system: instructions, messages, prompt }
        };
      }
      mergeOnStepFinishCallbacks(methodCallback) {
        const constructorCallback = this.settings.onStepFinish;
        if (methodCallback && constructorCallback) {
          return async (stepResult) => {
            await constructorCallback(stepResult);
            await methodCallback(stepResult);
          };
        }
        return methodCallback != null ? methodCallback : constructorCallback;
      }
      /**
       * Generates an output from the agent (non-streaming).
       */
      async generate({
        abortSignal,
        timeout,
        onStepFinish,
        ...options
      }) {
        return generateText({
          ...await this.prepareCall(options),
          abortSignal,
          timeout,
          onStepFinish: this.mergeOnStepFinishCallbacks(onStepFinish)
        });
      }
      /**
       * Streams an output from the agent (streaming).
       */
      async stream({
        abortSignal,
        timeout,
        experimental_transform,
        onStepFinish,
        ...options
      }) {
        return streamText({
          ...await this.prepareCall(options),
          abortSignal,
          timeout,
          experimental_transform,
          onStepFinish: this.mergeOnStepFinishCallbacks(onStepFinish)
        });
      }
    };
    uiMessagesSchema = lazySchema(
      () => zodSchema(
        z83.array(
          z83.object({
            id: z83.string(),
            role: z83.enum(["system", "user", "assistant"]),
            metadata: z83.unknown().optional(),
            parts: z83.array(
              z83.union([
                z83.object({
                  type: z83.literal("text"),
                  text: z83.string(),
                  state: z83.enum(["streaming", "done"]).optional(),
                  providerMetadata: providerMetadataSchema.optional()
                }),
                z83.object({
                  type: z83.literal("reasoning"),
                  text: z83.string(),
                  state: z83.enum(["streaming", "done"]).optional(),
                  providerMetadata: providerMetadataSchema.optional()
                }),
                z83.object({
                  type: z83.literal("source-url"),
                  sourceId: z83.string(),
                  url: z83.string(),
                  title: z83.string().optional(),
                  providerMetadata: providerMetadataSchema.optional()
                }),
                z83.object({
                  type: z83.literal("source-document"),
                  sourceId: z83.string(),
                  mediaType: z83.string(),
                  title: z83.string(),
                  filename: z83.string().optional(),
                  providerMetadata: providerMetadataSchema.optional()
                }),
                z83.object({
                  type: z83.literal("file"),
                  mediaType: z83.string(),
                  filename: z83.string().optional(),
                  url: z83.string(),
                  providerMetadata: providerMetadataSchema.optional()
                }),
                z83.object({
                  type: z83.literal("step-start")
                }),
                z83.object({
                  type: z83.string().startsWith("data-"),
                  id: z83.string().optional(),
                  data: z83.unknown()
                }),
                z83.object({
                  type: z83.literal("dynamic-tool"),
                  toolName: z83.string(),
                  toolCallId: z83.string(),
                  state: z83.literal("input-streaming"),
                  input: z83.unknown().optional(),
                  providerExecuted: z83.boolean().optional(),
                  callProviderMetadata: providerMetadataSchema.optional(),
                  output: z83.never().optional(),
                  errorText: z83.never().optional(),
                  approval: z83.never().optional()
                }),
                z83.object({
                  type: z83.literal("dynamic-tool"),
                  toolName: z83.string(),
                  toolCallId: z83.string(),
                  state: z83.literal("input-available"),
                  input: z83.unknown(),
                  providerExecuted: z83.boolean().optional(),
                  output: z83.never().optional(),
                  errorText: z83.never().optional(),
                  callProviderMetadata: providerMetadataSchema.optional(),
                  approval: z83.never().optional()
                }),
                z83.object({
                  type: z83.literal("dynamic-tool"),
                  toolName: z83.string(),
                  toolCallId: z83.string(),
                  state: z83.literal("approval-requested"),
                  input: z83.unknown(),
                  providerExecuted: z83.boolean().optional(),
                  output: z83.never().optional(),
                  errorText: z83.never().optional(),
                  callProviderMetadata: providerMetadataSchema.optional(),
                  approval: z83.object({
                    id: z83.string(),
                    approved: z83.never().optional(),
                    reason: z83.never().optional()
                  })
                }),
                z83.object({
                  type: z83.literal("dynamic-tool"),
                  toolName: z83.string(),
                  toolCallId: z83.string(),
                  state: z83.literal("approval-responded"),
                  input: z83.unknown(),
                  providerExecuted: z83.boolean().optional(),
                  output: z83.never().optional(),
                  errorText: z83.never().optional(),
                  callProviderMetadata: providerMetadataSchema.optional(),
                  approval: z83.object({
                    id: z83.string(),
                    approved: z83.boolean(),
                    reason: z83.string().optional()
                  })
                }),
                z83.object({
                  type: z83.literal("dynamic-tool"),
                  toolName: z83.string(),
                  toolCallId: z83.string(),
                  state: z83.literal("output-available"),
                  input: z83.unknown(),
                  providerExecuted: z83.boolean().optional(),
                  output: z83.unknown(),
                  errorText: z83.never().optional(),
                  callProviderMetadata: providerMetadataSchema.optional(),
                  preliminary: z83.boolean().optional(),
                  approval: z83.object({
                    id: z83.string(),
                    approved: z83.literal(true),
                    reason: z83.string().optional()
                  }).optional()
                }),
                z83.object({
                  type: z83.literal("dynamic-tool"),
                  toolName: z83.string(),
                  toolCallId: z83.string(),
                  state: z83.literal("output-error"),
                  input: z83.unknown(),
                  rawInput: z83.unknown().optional(),
                  providerExecuted: z83.boolean().optional(),
                  output: z83.never().optional(),
                  errorText: z83.string(),
                  callProviderMetadata: providerMetadataSchema.optional(),
                  approval: z83.object({
                    id: z83.string(),
                    approved: z83.literal(true),
                    reason: z83.string().optional()
                  }).optional()
                }),
                z83.object({
                  type: z83.literal("dynamic-tool"),
                  toolName: z83.string(),
                  toolCallId: z83.string(),
                  state: z83.literal("output-denied"),
                  input: z83.unknown(),
                  providerExecuted: z83.boolean().optional(),
                  output: z83.never().optional(),
                  errorText: z83.never().optional(),
                  callProviderMetadata: providerMetadataSchema.optional(),
                  approval: z83.object({
                    id: z83.string(),
                    approved: z83.literal(false),
                    reason: z83.string().optional()
                  })
                }),
                z83.object({
                  type: z83.string().startsWith("tool-"),
                  toolCallId: z83.string(),
                  state: z83.literal("input-streaming"),
                  providerExecuted: z83.boolean().optional(),
                  callProviderMetadata: providerMetadataSchema.optional(),
                  input: z83.unknown().optional(),
                  output: z83.never().optional(),
                  errorText: z83.never().optional(),
                  approval: z83.never().optional()
                }),
                z83.object({
                  type: z83.string().startsWith("tool-"),
                  toolCallId: z83.string(),
                  state: z83.literal("input-available"),
                  providerExecuted: z83.boolean().optional(),
                  input: z83.unknown(),
                  output: z83.never().optional(),
                  errorText: z83.never().optional(),
                  callProviderMetadata: providerMetadataSchema.optional(),
                  approval: z83.never().optional()
                }),
                z83.object({
                  type: z83.string().startsWith("tool-"),
                  toolCallId: z83.string(),
                  state: z83.literal("approval-requested"),
                  input: z83.unknown(),
                  providerExecuted: z83.boolean().optional(),
                  output: z83.never().optional(),
                  errorText: z83.never().optional(),
                  callProviderMetadata: providerMetadataSchema.optional(),
                  approval: z83.object({
                    id: z83.string(),
                    approved: z83.never().optional(),
                    reason: z83.never().optional()
                  })
                }),
                z83.object({
                  type: z83.string().startsWith("tool-"),
                  toolCallId: z83.string(),
                  state: z83.literal("approval-responded"),
                  input: z83.unknown(),
                  providerExecuted: z83.boolean().optional(),
                  output: z83.never().optional(),
                  errorText: z83.never().optional(),
                  callProviderMetadata: providerMetadataSchema.optional(),
                  approval: z83.object({
                    id: z83.string(),
                    approved: z83.boolean(),
                    reason: z83.string().optional()
                  })
                }),
                z83.object({
                  type: z83.string().startsWith("tool-"),
                  toolCallId: z83.string(),
                  state: z83.literal("output-available"),
                  providerExecuted: z83.boolean().optional(),
                  input: z83.unknown(),
                  output: z83.unknown(),
                  errorText: z83.never().optional(),
                  callProviderMetadata: providerMetadataSchema.optional(),
                  preliminary: z83.boolean().optional(),
                  approval: z83.object({
                    id: z83.string(),
                    approved: z83.literal(true),
                    reason: z83.string().optional()
                  }).optional()
                }),
                z83.object({
                  type: z83.string().startsWith("tool-"),
                  toolCallId: z83.string(),
                  state: z83.literal("output-error"),
                  providerExecuted: z83.boolean().optional(),
                  input: z83.unknown(),
                  rawInput: z83.unknown().optional(),
                  output: z83.never().optional(),
                  errorText: z83.string(),
                  callProviderMetadata: providerMetadataSchema.optional(),
                  approval: z83.object({
                    id: z83.string(),
                    approved: z83.literal(true),
                    reason: z83.string().optional()
                  }).optional()
                }),
                z83.object({
                  type: z83.string().startsWith("tool-"),
                  toolCallId: z83.string(),
                  state: z83.literal("output-denied"),
                  providerExecuted: z83.boolean().optional(),
                  input: z83.unknown(),
                  output: z83.never().optional(),
                  errorText: z83.never().optional(),
                  callProviderMetadata: providerMetadataSchema.optional(),
                  approval: z83.object({
                    id: z83.string(),
                    approved: z83.literal(false),
                    reason: z83.string().optional()
                  })
                })
              ])
            ).nonempty("Message must contain at least one part")
          })
        ).nonempty("Messages array must not be empty")
      )
    );
    DefaultEmbedResult = class {
      constructor(options) {
        this.value = options.value;
        this.embedding = options.embedding;
        this.usage = options.usage;
        this.warnings = options.warnings;
        this.providerMetadata = options.providerMetadata;
        this.response = options.response;
      }
    };
    DefaultEmbedManyResult = class {
      constructor(options) {
        this.values = options.values;
        this.embeddings = options.embeddings;
        this.usage = options.usage;
        this.warnings = options.warnings;
        this.providerMetadata = options.providerMetadata;
        this.responses = options.responses;
      }
    };
    DefaultGenerateImageResult = class {
      constructor(options) {
        this.images = options.images;
        this.warnings = options.warnings;
        this.responses = options.responses;
        this.providerMetadata = options.providerMetadata;
        this.usage = options.usage;
      }
      get image() {
        return this.images[0];
      }
    };
    experimental_generateImage = generateImage;
    noSchemaOutputStrategy = {
      type: "no-schema",
      jsonSchema: async () => void 0,
      async validatePartialResult({ value: value2, textDelta }) {
        return { success: true, value: { partial: value2, textDelta } };
      },
      async validateFinalResult(value2, context2) {
        return value2 === void 0 ? {
          success: false,
          error: new NoObjectGeneratedError({
            message: "No object generated: response did not match schema.",
            text: context2.text,
            response: context2.response,
            usage: context2.usage,
            finishReason: context2.finishReason
          })
        } : { success: true, value: value2 };
      },
      createElementStream() {
        throw new UnsupportedFunctionalityError({
          functionality: "element streams in no-schema mode"
        });
      }
    };
    objectOutputStrategy = (schema) => ({
      type: "object",
      jsonSchema: async () => await schema.jsonSchema,
      async validatePartialResult({ value: value2, textDelta }) {
        return {
          success: true,
          value: {
            // Note: currently no validation of partial results:
            partial: value2,
            textDelta
          }
        };
      },
      async validateFinalResult(value2) {
        return safeValidateTypes({ value: value2, schema });
      },
      createElementStream() {
        throw new UnsupportedFunctionalityError({
          functionality: "element streams in object mode"
        });
      }
    });
    arrayOutputStrategy = (schema) => {
      return {
        type: "array",
        // wrap in object that contains array of elements, since most LLMs will not
        // be able to generate an array directly:
        // possible future optimization: use arrays directly when model supports grammar-guided generation
        jsonSchema: async () => {
          const { $schema, ...itemSchema } = await schema.jsonSchema;
          return {
            $schema: "http://json-schema.org/draft-07/schema#",
            type: "object",
            properties: {
              elements: { type: "array", items: itemSchema }
            },
            required: ["elements"],
            additionalProperties: false
          };
        },
        async validatePartialResult({
          value: value2,
          latestObject,
          isFirstDelta,
          isFinalDelta
        }) {
          var _a212;
          if (!isJSONObject(value2) || !isJSONArray(value2.elements)) {
            return {
              success: false,
              error: new TypeValidationError({
                value: value2,
                cause: "value must be an object that contains an array of elements"
              })
            };
          }
          const inputArray = value2.elements;
          const resultArray = [];
          for (let i = 0; i < inputArray.length; i++) {
            const element = inputArray[i];
            const result = await safeValidateTypes({ value: element, schema });
            if (i === inputArray.length - 1 && !isFinalDelta) {
              continue;
            }
            if (!result.success) {
              return result;
            }
            resultArray.push(result.value);
          }
          const publishedElementCount = (_a212 = latestObject == null ? void 0 : latestObject.length) != null ? _a212 : 0;
          let textDelta = "";
          if (isFirstDelta) {
            textDelta += "[";
          }
          if (publishedElementCount > 0) {
            textDelta += ",";
          }
          textDelta += resultArray.slice(publishedElementCount).map((element) => JSON.stringify(element)).join(",");
          if (isFinalDelta) {
            textDelta += "]";
          }
          return {
            success: true,
            value: {
              partial: resultArray,
              textDelta
            }
          };
        },
        async validateFinalResult(value2) {
          if (!isJSONObject(value2) || !isJSONArray(value2.elements)) {
            return {
              success: false,
              error: new TypeValidationError({
                value: value2,
                cause: "value must be an object that contains an array of elements"
              })
            };
          }
          const inputArray = value2.elements;
          for (const element of inputArray) {
            const result = await safeValidateTypes({ value: element, schema });
            if (!result.success) {
              return result;
            }
          }
          return { success: true, value: inputArray };
        },
        createElementStream(originalStream) {
          let publishedElements = 0;
          return createAsyncIterableStream(
            originalStream.pipeThrough(
              new TransformStream({
                transform(chunk, controller) {
                  switch (chunk.type) {
                    case "object": {
                      const array2 = chunk.object;
                      for (; publishedElements < array2.length; publishedElements++) {
                        controller.enqueue(array2[publishedElements]);
                      }
                      break;
                    }
                    case "text-delta":
                    case "finish":
                    case "error":
                      break;
                    default: {
                      const _exhaustiveCheck = chunk;
                      throw new Error(
                        `Unsupported chunk type: ${_exhaustiveCheck}`
                      );
                    }
                  }
                }
              })
            )
          );
        }
      };
    };
    enumOutputStrategy = (enumValues) => {
      return {
        type: "enum",
        // wrap in object that contains result, since most LLMs will not
        // be able to generate an enum value directly:
        // possible future optimization: use enums directly when model supports top-level enums
        jsonSchema: async () => ({
          $schema: "http://json-schema.org/draft-07/schema#",
          type: "object",
          properties: {
            result: { type: "string", enum: enumValues }
          },
          required: ["result"],
          additionalProperties: false
        }),
        async validateFinalResult(value2) {
          if (!isJSONObject(value2) || typeof value2.result !== "string") {
            return {
              success: false,
              error: new TypeValidationError({
                value: value2,
                cause: 'value must be an object that contains a string in the "result" property.'
              })
            };
          }
          const result = value2.result;
          return enumValues.includes(result) ? { success: true, value: result } : {
            success: false,
            error: new TypeValidationError({
              value: value2,
              cause: "value must be a string in the enum"
            })
          };
        },
        async validatePartialResult({ value: value2, textDelta }) {
          if (!isJSONObject(value2) || typeof value2.result !== "string") {
            return {
              success: false,
              error: new TypeValidationError({
                value: value2,
                cause: 'value must be an object that contains a string in the "result" property.'
              })
            };
          }
          const result = value2.result;
          const possibleEnumValues = enumValues.filter(
            (enumValue) => enumValue.startsWith(result)
          );
          if (value2.result.length === 0 || possibleEnumValues.length === 0) {
            return {
              success: false,
              error: new TypeValidationError({
                value: value2,
                cause: "value must be a string in the enum"
              })
            };
          }
          return {
            success: true,
            value: {
              partial: possibleEnumValues.length > 1 ? result : possibleEnumValues[0],
              textDelta
            }
          };
        },
        createElementStream() {
          throw new UnsupportedFunctionalityError({
            functionality: "element streams in enum mode"
          });
        }
      };
    };
    originalGenerateId3 = createIdGenerator({ prefix: "aiobj", size: 24 });
    DefaultGenerateObjectResult = class {
      constructor(options) {
        this.object = options.object;
        this.finishReason = options.finishReason;
        this.usage = options.usage;
        this.warnings = options.warnings;
        this.providerMetadata = options.providerMetadata;
        this.response = options.response;
        this.request = options.request;
        this.reasoning = options.reasoning;
      }
      toJsonResponse(init) {
        var _a212;
        return new Response(JSON.stringify(this.object), {
          status: (_a212 = init == null ? void 0 : init.status) != null ? _a212 : 200,
          headers: prepareHeaders(init == null ? void 0 : init.headers, {
            "content-type": "application/json; charset=utf-8"
          })
        });
      }
    };
    SerialJobExecutor = class {
      constructor() {
        this.queue = [];
        this.isProcessing = false;
      }
      async processQueue() {
        if (this.isProcessing) {
          return;
        }
        this.isProcessing = true;
        while (this.queue.length > 0) {
          await this.queue[0]();
          this.queue.shift();
        }
        this.isProcessing = false;
      }
      async run(job) {
        return new Promise((resolve32, reject) => {
          this.queue.push(async () => {
            try {
              await job();
              resolve32();
            } catch (error) {
              reject(error);
            }
          });
          void this.processQueue();
        });
      }
    };
    originalGenerateId4 = createIdGenerator({ prefix: "aiobj", size: 24 });
    DefaultStreamObjectResult = class {
      constructor({
        model: modelArg,
        headers,
        telemetry: telemetry2,
        settings,
        maxRetries: maxRetriesArg,
        abortSignal,
        outputStrategy,
        system,
        prompt,
        messages,
        schemaName,
        schemaDescription,
        providerOptions,
        repairText,
        onError: onError2,
        onFinish: onFinish2,
        download: download2,
        generateId: generateId22,
        currentDate,
        now: now2
      }) {
        this._object = new DelayedPromise();
        this._usage = new DelayedPromise();
        this._providerMetadata = new DelayedPromise();
        this._warnings = new DelayedPromise();
        this._request = new DelayedPromise();
        this._response = new DelayedPromise();
        this._finishReason = new DelayedPromise();
        const model = resolveLanguageModel(modelArg);
        const { maxRetries, retry } = prepareRetries({
          maxRetries: maxRetriesArg,
          abortSignal
        });
        const callSettings = prepareCallSettings(settings);
        const baseTelemetryAttributes = getBaseTelemetryAttributes({
          model,
          telemetry: telemetry2,
          headers,
          settings: { ...callSettings, maxRetries }
        });
        const tracer = getTracer(telemetry2);
        const self = this;
        const stitchableStream = createStitchableStream();
        const eventProcessor = new TransformStream({
          transform(chunk, controller) {
            controller.enqueue(chunk);
            if (chunk.type === "error") {
              onError2({ error: wrapGatewayError(chunk.error) });
            }
          }
        });
        this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);
        recordSpan({
          name: "ai.streamObject",
          attributes: selectTelemetryAttributes({
            telemetry: telemetry2,
            attributes: {
              ...assembleOperationName({
                operationId: "ai.streamObject",
                telemetry: telemetry2
              }),
              ...baseTelemetryAttributes,
              // specific settings that only make sense on the outer level:
              "ai.prompt": {
                input: () => JSON.stringify({ system, prompt, messages })
              },
              "ai.schema": {
                input: async () => JSON.stringify(await outputStrategy.jsonSchema())
              },
              "ai.schema.name": schemaName,
              "ai.schema.description": schemaDescription,
              "ai.settings.output": outputStrategy.type
            }
          }),
          tracer,
          endWhenDone: false,
          fn: async (rootSpan) => {
            const standardizedPrompt = await standardizePrompt({
              system,
              prompt,
              messages
            });
            const callOptions = {
              responseFormat: {
                type: "json",
                schema: await outputStrategy.jsonSchema(),
                name: schemaName,
                description: schemaDescription
              },
              ...prepareCallSettings(settings),
              prompt: await convertToLanguageModelPrompt({
                prompt: standardizedPrompt,
                supportedUrls: await model.supportedUrls,
                download: download2
              }),
              providerOptions,
              abortSignal,
              headers,
              includeRawChunks: false
            };
            const transformer = {
              transform: (chunk, controller) => {
                switch (chunk.type) {
                  case "text-delta":
                    controller.enqueue(chunk.delta);
                    break;
                  case "response-metadata":
                  case "finish":
                  case "error":
                  case "stream-start":
                    controller.enqueue(chunk);
                    break;
                }
              }
            };
            const {
              result: { stream, response, request },
              doStreamSpan,
              startTimestampMs
            } = await retry(
              () => recordSpan({
                name: "ai.streamObject.doStream",
                attributes: selectTelemetryAttributes({
                  telemetry: telemetry2,
                  attributes: {
                    ...assembleOperationName({
                      operationId: "ai.streamObject.doStream",
                      telemetry: telemetry2
                    }),
                    ...baseTelemetryAttributes,
                    "ai.prompt.messages": {
                      input: () => stringifyForTelemetry(callOptions.prompt)
                    },
                    // standardized gen-ai llm span attributes:
                    "gen_ai.system": model.provider,
                    "gen_ai.request.model": model.modelId,
                    "gen_ai.request.frequency_penalty": callSettings.frequencyPenalty,
                    "gen_ai.request.max_tokens": callSettings.maxOutputTokens,
                    "gen_ai.request.presence_penalty": callSettings.presencePenalty,
                    "gen_ai.request.temperature": callSettings.temperature,
                    "gen_ai.request.top_k": callSettings.topK,
                    "gen_ai.request.top_p": callSettings.topP
                  }
                }),
                tracer,
                endWhenDone: false,
                fn: async (doStreamSpan2) => ({
                  startTimestampMs: now2(),
                  doStreamSpan: doStreamSpan2,
                  result: await model.doStream(callOptions)
                })
              })
            );
            self._request.resolve(request != null ? request : {});
            let warnings;
            let usage = createNullLanguageModelUsage();
            let finishReason;
            let providerMetadata;
            let object2;
            let error;
            let accumulatedText = "";
            let textDelta = "";
            let fullResponse = {
              id: generateId22(),
              timestamp: currentDate(),
              modelId: model.modelId
            };
            let latestObjectJson = void 0;
            let latestObject = void 0;
            let isFirstChunk = true;
            let isFirstDelta = true;
            const transformedStream = stream.pipeThrough(new TransformStream(transformer)).pipeThrough(
              new TransformStream({
                async transform(chunk, controller) {
                  var _a212, _b18, _c;
                  if (typeof chunk === "object" && chunk.type === "stream-start") {
                    warnings = chunk.warnings;
                    return;
                  }
                  if (isFirstChunk) {
                    const msToFirstChunk = now2() - startTimestampMs;
                    isFirstChunk = false;
                    doStreamSpan.addEvent("ai.stream.firstChunk", {
                      "ai.stream.msToFirstChunk": msToFirstChunk
                    });
                    doStreamSpan.setAttributes({
                      "ai.stream.msToFirstChunk": msToFirstChunk
                    });
                  }
                  if (typeof chunk === "string") {
                    accumulatedText += chunk;
                    textDelta += chunk;
                    const { value: currentObjectJson, state: parseState } = await parsePartialJson(accumulatedText);
                    if (currentObjectJson !== void 0 && !isDeepEqualData(latestObjectJson, currentObjectJson)) {
                      const validationResult = await outputStrategy.validatePartialResult({
                        value: currentObjectJson,
                        textDelta,
                        latestObject,
                        isFirstDelta,
                        isFinalDelta: parseState === "successful-parse"
                      });
                      if (validationResult.success && !isDeepEqualData(
                        latestObject,
                        validationResult.value.partial
                      )) {
                        latestObjectJson = currentObjectJson;
                        latestObject = validationResult.value.partial;
                        controller.enqueue({
                          type: "object",
                          object: latestObject
                        });
                        controller.enqueue({
                          type: "text-delta",
                          textDelta: validationResult.value.textDelta
                        });
                        textDelta = "";
                        isFirstDelta = false;
                      }
                    }
                    return;
                  }
                  switch (chunk.type) {
                    case "response-metadata": {
                      fullResponse = {
                        id: (_a212 = chunk.id) != null ? _a212 : fullResponse.id,
                        timestamp: (_b18 = chunk.timestamp) != null ? _b18 : fullResponse.timestamp,
                        modelId: (_c = chunk.modelId) != null ? _c : fullResponse.modelId
                      };
                      break;
                    }
                    case "finish": {
                      if (textDelta !== "") {
                        controller.enqueue({ type: "text-delta", textDelta });
                      }
                      finishReason = chunk.finishReason.unified;
                      usage = asLanguageModelUsage(chunk.usage);
                      providerMetadata = chunk.providerMetadata;
                      controller.enqueue({
                        ...chunk,
                        finishReason: chunk.finishReason.unified,
                        usage,
                        response: fullResponse
                      });
                      logWarnings({
                        warnings: warnings != null ? warnings : [],
                        provider: model.provider,
                        model: model.modelId
                      });
                      self._usage.resolve(usage);
                      self._providerMetadata.resolve(providerMetadata);
                      self._warnings.resolve(warnings);
                      self._response.resolve({
                        ...fullResponse,
                        headers: response == null ? void 0 : response.headers
                      });
                      self._finishReason.resolve(finishReason != null ? finishReason : "other");
                      try {
                        object2 = await parseAndValidateObjectResultWithRepair(
                          accumulatedText,
                          outputStrategy,
                          repairText,
                          {
                            response: fullResponse,
                            usage,
                            finishReason
                          }
                        );
                        self._object.resolve(object2);
                      } catch (e) {
                        error = e;
                        self._object.reject(e);
                      }
                      break;
                    }
                    default: {
                      controller.enqueue(chunk);
                      break;
                    }
                  }
                },
                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:
                async flush(controller) {
                  try {
                    const finalUsage = usage != null ? usage : {
                      promptTokens: NaN,
                      completionTokens: NaN,
                      totalTokens: NaN
                    };
                    doStreamSpan.setAttributes(
                      await selectTelemetryAttributes({
                        telemetry: telemetry2,
                        attributes: {
                          "ai.response.finishReason": finishReason,
                          "ai.response.object": {
                            output: () => JSON.stringify(object2)
                          },
                          "ai.response.id": fullResponse.id,
                          "ai.response.model": fullResponse.modelId,
                          "ai.response.timestamp": fullResponse.timestamp.toISOString(),
                          "ai.response.providerMetadata": JSON.stringify(providerMetadata),
                          "ai.usage.inputTokens": finalUsage.inputTokens,
                          "ai.usage.outputTokens": finalUsage.outputTokens,
                          "ai.usage.totalTokens": finalUsage.totalTokens,
                          "ai.usage.reasoningTokens": finalUsage.reasoningTokens,
                          "ai.usage.cachedInputTokens": finalUsage.cachedInputTokens,
                          // standardized gen-ai llm span attributes:
                          "gen_ai.response.finish_reasons": [finishReason],
                          "gen_ai.response.id": fullResponse.id,
                          "gen_ai.response.model": fullResponse.modelId,
                          "gen_ai.usage.input_tokens": finalUsage.inputTokens,
                          "gen_ai.usage.output_tokens": finalUsage.outputTokens
                        }
                      })
                    );
                    doStreamSpan.end();
                    rootSpan.setAttributes(
                      await selectTelemetryAttributes({
                        telemetry: telemetry2,
                        attributes: {
                          "ai.usage.inputTokens": finalUsage.inputTokens,
                          "ai.usage.outputTokens": finalUsage.outputTokens,
                          "ai.usage.totalTokens": finalUsage.totalTokens,
                          "ai.usage.reasoningTokens": finalUsage.reasoningTokens,
                          "ai.usage.cachedInputTokens": finalUsage.cachedInputTokens,
                          "ai.response.object": {
                            output: () => JSON.stringify(object2)
                          },
                          "ai.response.providerMetadata": JSON.stringify(providerMetadata)
                        }
                      })
                    );
                    await (onFinish2 == null ? void 0 : onFinish2({
                      usage: finalUsage,
                      object: object2,
                      error,
                      response: {
                        ...fullResponse,
                        headers: response == null ? void 0 : response.headers
                      },
                      warnings,
                      providerMetadata
                    }));
                  } catch (error2) {
                    controller.enqueue({ type: "error", error: error2 });
                  } finally {
                    rootSpan.end();
                  }
                }
              })
            );
            stitchableStream.addStream(transformedStream);
          }
        }).catch((error) => {
          stitchableStream.addStream(
            new ReadableStream({
              start(controller) {
                controller.enqueue({ type: "error", error });
                controller.close();
              }
            })
          );
        }).finally(() => {
          stitchableStream.close();
        });
        this.outputStrategy = outputStrategy;
      }
      get object() {
        return this._object.promise;
      }
      get usage() {
        return this._usage.promise;
      }
      get providerMetadata() {
        return this._providerMetadata.promise;
      }
      get warnings() {
        return this._warnings.promise;
      }
      get request() {
        return this._request.promise;
      }
      get response() {
        return this._response.promise;
      }
      get finishReason() {
        return this._finishReason.promise;
      }
      get partialObjectStream() {
        return createAsyncIterableStream(
          this.baseStream.pipeThrough(
            new TransformStream({
              transform(chunk, controller) {
                switch (chunk.type) {
                  case "object":
                    controller.enqueue(chunk.object);
                    break;
                  case "text-delta":
                  case "finish":
                  case "error":
                    break;
                  default: {
                    const _exhaustiveCheck = chunk;
                    throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
                  }
                }
              }
            })
          )
        );
      }
      get elementStream() {
        return this.outputStrategy.createElementStream(this.baseStream);
      }
      get textStream() {
        return createAsyncIterableStream(
          this.baseStream.pipeThrough(
            new TransformStream({
              transform(chunk, controller) {
                switch (chunk.type) {
                  case "text-delta":
                    controller.enqueue(chunk.textDelta);
                    break;
                  case "object":
                  case "finish":
                  case "error":
                    break;
                  default: {
                    const _exhaustiveCheck = chunk;
                    throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
                  }
                }
              }
            })
          )
        );
      }
      get fullStream() {
        return createAsyncIterableStream(this.baseStream);
      }
      pipeTextStreamToResponse(response, init) {
        pipeTextStreamToResponse({
          response,
          textStream: this.textStream,
          ...init
        });
      }
      toTextStreamResponse(init) {
        return createTextStreamResponse({
          textStream: this.textStream,
          ...init
        });
      }
    };
    DefaultGeneratedAudioFile = class extends DefaultGeneratedFile {
      constructor({
        data,
        mediaType
      }) {
        super({ data, mediaType });
        let format = "mp3";
        if (mediaType) {
          const mediaTypeParts = mediaType.split("/");
          if (mediaTypeParts.length === 2) {
            if (mediaType !== "audio/mpeg") {
              format = mediaTypeParts[1];
            }
          }
        }
        if (!format) {
          throw new Error(
            "Audio format must be provided or determinable from media type"
          );
        }
        this.format = format;
      }
    };
    DefaultSpeechResult = class {
      constructor(options) {
        var _a212;
        this.audio = options.audio;
        this.warnings = options.warnings;
        this.responses = options.responses;
        this.providerMetadata = (_a212 = options.providerMetadata) != null ? _a212 : {};
      }
    };
    CHUNKING_REGEXPS = {
      word: /\S+\s+/m,
      line: /\n+/m
    };
    wrapLanguageModel = ({
      model,
      middleware: middlewareArg,
      modelId,
      providerId
    }) => {
      return [...asArray(middlewareArg)].reverse().reduce((wrappedModel, middleware) => {
        return doWrap({ model: wrappedModel, middleware, modelId, providerId });
      }, model);
    };
    doWrap = ({
      model,
      middleware: {
        transformParams,
        wrapGenerate,
        wrapStream,
        overrideProvider,
        overrideModelId,
        overrideSupportedUrls
      },
      modelId,
      providerId
    }) => {
      var _a212, _b18, _c;
      async function doTransform({
        params,
        type: type2
      }) {
        return transformParams ? await transformParams({ params, type: type2, model }) : params;
      }
      return {
        specificationVersion: "v3",
        provider: (_a212 = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({ model })) != null ? _a212 : model.provider,
        modelId: (_b18 = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({ model })) != null ? _b18 : model.modelId,
        supportedUrls: (_c = overrideSupportedUrls == null ? void 0 : overrideSupportedUrls({ model })) != null ? _c : model.supportedUrls,
        async doGenerate(params) {
          const transformedParams = await doTransform({ params, type: "generate" });
          const doGenerate = async () => model.doGenerate(transformedParams);
          const doStream = async () => model.doStream(transformedParams);
          return wrapGenerate ? wrapGenerate({
            doGenerate,
            doStream,
            params: transformedParams,
            model
          }) : doGenerate();
        },
        async doStream(params) {
          const transformedParams = await doTransform({ params, type: "stream" });
          const doGenerate = async () => model.doGenerate(transformedParams);
          const doStream = async () => model.doStream(transformedParams);
          return wrapStream ? wrapStream({ doGenerate, doStream, params: transformedParams, model }) : doStream();
        }
      };
    };
    wrapEmbeddingModel = ({
      model,
      middleware: middlewareArg,
      modelId,
      providerId
    }) => {
      return [...asArray(middlewareArg)].reverse().reduce((wrappedModel, middleware) => {
        return doWrap2({ model: wrappedModel, middleware, modelId, providerId });
      }, model);
    };
    doWrap2 = ({
      model,
      middleware: {
        transformParams,
        wrapEmbed,
        overrideProvider,
        overrideModelId,
        overrideMaxEmbeddingsPerCall,
        overrideSupportsParallelCalls
      },
      modelId,
      providerId
    }) => {
      var _a212, _b18, _c, _d;
      async function doTransform({
        params
      }) {
        return transformParams ? await transformParams({ params, model }) : params;
      }
      return {
        specificationVersion: "v3",
        provider: (_a212 = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({ model })) != null ? _a212 : model.provider,
        modelId: (_b18 = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({ model })) != null ? _b18 : model.modelId,
        maxEmbeddingsPerCall: (_c = overrideMaxEmbeddingsPerCall == null ? void 0 : overrideMaxEmbeddingsPerCall({ model })) != null ? _c : model.maxEmbeddingsPerCall,
        supportsParallelCalls: (_d = overrideSupportsParallelCalls == null ? void 0 : overrideSupportsParallelCalls({ model })) != null ? _d : model.supportsParallelCalls,
        async doEmbed(params) {
          const transformedParams = await doTransform({ params });
          const doEmbed = async () => model.doEmbed(transformedParams);
          return wrapEmbed ? wrapEmbed({
            doEmbed,
            params: transformedParams,
            model
          }) : doEmbed();
        }
      };
    };
    wrapImageModel = ({
      model,
      middleware: middlewareArg,
      modelId,
      providerId
    }) => {
      return [...asArray(middlewareArg)].reverse().reduce((wrappedModel, middleware) => {
        return doWrap3({ model: wrappedModel, middleware, modelId, providerId });
      }, model);
    };
    doWrap3 = ({
      model,
      middleware: {
        transformParams,
        wrapGenerate,
        overrideProvider,
        overrideModelId,
        overrideMaxImagesPerCall
      },
      modelId,
      providerId
    }) => {
      var _a212, _b18, _c;
      async function doTransform({ params }) {
        return transformParams ? await transformParams({ params, model }) : params;
      }
      const maxImagesPerCallRaw = (_a212 = overrideMaxImagesPerCall == null ? void 0 : overrideMaxImagesPerCall({ model })) != null ? _a212 : model.maxImagesPerCall;
      const maxImagesPerCall = maxImagesPerCallRaw instanceof Function ? maxImagesPerCallRaw.bind(model) : maxImagesPerCallRaw;
      return {
        specificationVersion: "v3",
        provider: (_b18 = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({ model })) != null ? _b18 : model.provider,
        modelId: (_c = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({ model })) != null ? _c : model.modelId,
        maxImagesPerCall,
        async doGenerate(params) {
          const transformedParams = await doTransform({ params });
          const doGenerate = async () => model.doGenerate(transformedParams);
          return wrapGenerate ? wrapGenerate({
            doGenerate,
            params: transformedParams,
            model
          }) : doGenerate();
        }
      };
    };
    experimental_customProvider = customProvider;
    name20 = "AI_NoSuchProviderError";
    marker20 = `vercel.ai.error.${name20}`;
    symbol20 = Symbol.for(marker20);
    NoSuchProviderError = class extends NoSuchModelError {
      constructor({
        modelId,
        modelType,
        providerId,
        availableProviders,
        message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`
      }) {
        super({ errorName: name20, modelId, modelType, message });
        this[_a20] = true;
        this.providerId = providerId;
        this.availableProviders = availableProviders;
      }
      static isInstance(error) {
        return AISDKError.hasMarker(error, marker20);
      }
    };
    _a20 = symbol20;
    experimental_createProviderRegistry = createProviderRegistry;
    DefaultProviderRegistry = class {
      constructor({
        separator,
        languageModelMiddleware,
        imageModelMiddleware
      }) {
        this.providers = {};
        this.separator = separator;
        this.languageModelMiddleware = languageModelMiddleware;
        this.imageModelMiddleware = imageModelMiddleware;
      }
      registerProvider({
        id,
        provider
      }) {
        this.providers[id] = provider;
      }
      getProvider(id, modelType) {
        const provider = this.providers[id];
        if (provider == null) {
          throw new NoSuchProviderError({
            modelId: id,
            modelType,
            providerId: id,
            availableProviders: Object.keys(this.providers)
          });
        }
        return provider;
      }
      splitId(id, modelType) {
        const index = id.indexOf(this.separator);
        if (index === -1) {
          throw new NoSuchModelError({
            modelId: id,
            modelType,
            message: `Invalid ${modelType} id for registry: ${id} (must be in the format "providerId${this.separator}modelId")`
          });
        }
        return [id.slice(0, index), id.slice(index + this.separator.length)];
      }
      languageModel(id) {
        var _a212, _b18;
        const [providerId, modelId] = this.splitId(id, "languageModel");
        let model = (_b18 = (_a212 = this.getProvider(providerId, "languageModel")).languageModel) == null ? void 0 : _b18.call(
          _a212,
          modelId
        );
        if (model == null) {
          throw new NoSuchModelError({ modelId: id, modelType: "languageModel" });
        }
        if (this.languageModelMiddleware != null) {
          model = wrapLanguageModel({
            model,
            middleware: this.languageModelMiddleware
          });
        }
        return model;
      }
      embeddingModel(id) {
        var _a212;
        const [providerId, modelId] = this.splitId(id, "embeddingModel");
        const provider = this.getProvider(providerId, "embeddingModel");
        const model = (_a212 = provider.embeddingModel) == null ? void 0 : _a212.call(provider, modelId);
        if (model == null) {
          throw new NoSuchModelError({
            modelId: id,
            modelType: "embeddingModel"
          });
        }
        return model;
      }
      imageModel(id) {
        var _a212;
        const [providerId, modelId] = this.splitId(id, "imageModel");
        const provider = this.getProvider(providerId, "imageModel");
        let model = (_a212 = provider.imageModel) == null ? void 0 : _a212.call(provider, modelId);
        if (model == null) {
          throw new NoSuchModelError({ modelId: id, modelType: "imageModel" });
        }
        if (this.imageModelMiddleware != null) {
          model = wrapImageModel({
            model,
            middleware: this.imageModelMiddleware
          });
        }
        return model;
      }
      transcriptionModel(id) {
        var _a212;
        const [providerId, modelId] = this.splitId(id, "transcriptionModel");
        const provider = this.getProvider(providerId, "transcriptionModel");
        const model = (_a212 = provider.transcriptionModel) == null ? void 0 : _a212.call(provider, modelId);
        if (model == null) {
          throw new NoSuchModelError({
            modelId: id,
            modelType: "transcriptionModel"
          });
        }
        return model;
      }
      speechModel(id) {
        var _a212;
        const [providerId, modelId] = this.splitId(id, "speechModel");
        const provider = this.getProvider(providerId, "speechModel");
        const model = (_a212 = provider.speechModel) == null ? void 0 : _a212.call(provider, modelId);
        if (model == null) {
          throw new NoSuchModelError({ modelId: id, modelType: "speechModel" });
        }
        return model;
      }
      rerankingModel(id) {
        var _a212;
        const [providerId, modelId] = this.splitId(id, "rerankingModel");
        const provider = this.getProvider(providerId, "rerankingModel");
        const model = (_a212 = provider.rerankingModel) == null ? void 0 : _a212.call(provider, modelId);
        if (model == null) {
          throw new NoSuchModelError({ modelId: id, modelType: "rerankingModel" });
        }
        return model;
      }
    };
    DefaultRerankResult = class {
      constructor(options) {
        this.originalDocuments = options.originalDocuments;
        this.ranking = options.ranking;
        this.response = options.response;
        this.providerMetadata = options.providerMetadata;
      }
      get rerankedDocuments() {
        return this.ranking.map((ranking) => ranking.document);
      }
    };
    DefaultTranscriptionResult = class {
      constructor(options) {
        var _a212;
        this.text = options.text;
        this.segments = options.segments;
        this.language = options.language;
        this.durationInSeconds = options.durationInSeconds;
        this.warnings = options.warnings;
        this.responses = options.responses;
        this.providerMetadata = (_a212 = options.providerMetadata) != null ? _a212 : {};
      }
    };
    getOriginalFetch3 = () => fetch;
    HttpChatTransport = class {
      constructor({
        api = "/api/chat",
        credentials,
        headers,
        body,
        fetch: fetch2,
        prepareSendMessagesRequest,
        prepareReconnectToStreamRequest
      }) {
        this.api = api;
        this.credentials = credentials;
        this.headers = headers;
        this.body = body;
        this.fetch = fetch2;
        this.prepareSendMessagesRequest = prepareSendMessagesRequest;
        this.prepareReconnectToStreamRequest = prepareReconnectToStreamRequest;
      }
      async sendMessages({
        abortSignal,
        ...options
      }) {
        var _a212, _b18, _c, _d, _e;
        const resolvedBody = await resolve(this.body);
        const resolvedHeaders = await resolve(this.headers);
        const resolvedCredentials = await resolve(this.credentials);
        const baseHeaders = {
          ...normalizeHeaders(resolvedHeaders),
          ...normalizeHeaders(options.headers)
        };
        const preparedRequest = await ((_a212 = this.prepareSendMessagesRequest) == null ? void 0 : _a212.call(this, {
          api: this.api,
          id: options.chatId,
          messages: options.messages,
          body: { ...resolvedBody, ...options.body },
          headers: baseHeaders,
          credentials: resolvedCredentials,
          requestMetadata: options.metadata,
          trigger: options.trigger,
          messageId: options.messageId
        }));
        const api = (_b18 = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b18 : this.api;
        const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? normalizeHeaders(preparedRequest.headers) : baseHeaders;
        const body = (preparedRequest == null ? void 0 : preparedRequest.body) !== void 0 ? preparedRequest.body : {
          ...resolvedBody,
          ...options.body,
          id: options.chatId,
          messages: options.messages,
          trigger: options.trigger,
          messageId: options.messageId
        };
        const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;
        const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;
        const response = await fetch2(api, {
          method: "POST",
          headers: withUserAgentSuffix(
            {
              "Content-Type": "application/json",
              ...headers
            },
            `ai-sdk/${VERSION4}`,
            getRuntimeEnvironmentUserAgent()
          ),
          body: JSON.stringify(body),
          credentials,
          signal: abortSignal
        });
        if (!response.ok) {
          throw new Error(
            (_e = await response.text()) != null ? _e : "Failed to fetch the chat response."
          );
        }
        if (!response.body) {
          throw new Error("The response body is empty.");
        }
        return this.processResponseStream(response.body);
      }
      async reconnectToStream(options) {
        var _a212, _b18, _c, _d, _e;
        const resolvedBody = await resolve(this.body);
        const resolvedHeaders = await resolve(this.headers);
        const resolvedCredentials = await resolve(this.credentials);
        const baseHeaders = {
          ...normalizeHeaders(resolvedHeaders),
          ...normalizeHeaders(options.headers)
        };
        const preparedRequest = await ((_a212 = this.prepareReconnectToStreamRequest) == null ? void 0 : _a212.call(this, {
          api: this.api,
          id: options.chatId,
          body: { ...resolvedBody, ...options.body },
          headers: baseHeaders,
          credentials: resolvedCredentials,
          requestMetadata: options.metadata
        }));
        const api = (_b18 = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b18 : `${this.api}/${options.chatId}/stream`;
        const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? normalizeHeaders(preparedRequest.headers) : baseHeaders;
        const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;
        const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;
        const response = await fetch2(api, {
          method: "GET",
          headers: withUserAgentSuffix(
            headers,
            `ai-sdk/${VERSION4}`,
            getRuntimeEnvironmentUserAgent()
          ),
          credentials
        });
        if (response.status === 204) {
          return null;
        }
        if (!response.ok) {
          throw new Error(
            (_e = await response.text()) != null ? _e : "Failed to fetch the chat response."
          );
        }
        if (!response.body) {
          throw new Error("The response body is empty.");
        }
        return this.processResponseStream(response.body);
      }
    };
    DefaultChatTransport = class extends HttpChatTransport {
      constructor(options = {}) {
        super(options);
      }
      processResponseStream(stream) {
        return parseJsonEventStream({
          stream,
          schema: uiMessageChunkSchema
        }).pipeThrough(
          new TransformStream({
            async transform(chunk, controller) {
              if (!chunk.success) {
                throw chunk.error;
              }
              controller.enqueue(chunk.value);
            }
          })
        );
      }
    };
    AbstractChat = class {
      constructor({
        generateId: generateId22 = generateId,
        id = generateId22(),
        transport = new DefaultChatTransport(),
        messageMetadataSchema,
        dataPartSchemas,
        state,
        onError: onError2,
        onToolCall,
        onFinish: onFinish2,
        onData,
        sendAutomaticallyWhen
      }) {
        this.activeResponse = void 0;
        this.jobExecutor = new SerialJobExecutor();
        this.sendMessage = async (message, options) => {
          var _a212, _b18, _c, _d;
          if (message == null) {
            await this.makeRequest({
              trigger: "submit-message",
              messageId: (_a212 = this.lastMessage) == null ? void 0 : _a212.id,
              ...options
            });
            return;
          }
          let uiMessage;
          if ("text" in message || "files" in message) {
            const fileParts = Array.isArray(message.files) ? message.files : await convertFileListToFileUIParts(message.files);
            uiMessage = {
              parts: [
                ...fileParts,
                ..."text" in message && message.text != null ? [{ type: "text", text: message.text }] : []
              ]
            };
          } else {
            uiMessage = message;
          }
          if (message.messageId != null) {
            const messageIndex = this.state.messages.findIndex(
              (m) => m.id === message.messageId
            );
            if (messageIndex === -1) {
              throw new Error(`message with id ${message.messageId} not found`);
            }
            if (this.state.messages[messageIndex].role !== "user") {
              throw new Error(
                `message with id ${message.messageId} is not a user message`
              );
            }
            this.state.messages = this.state.messages.slice(0, messageIndex + 1);
            this.state.replaceMessage(messageIndex, {
              ...uiMessage,
              id: message.messageId,
              role: (_b18 = uiMessage.role) != null ? _b18 : "user",
              metadata: message.metadata
            });
          } else {
            this.state.pushMessage({
              ...uiMessage,
              id: (_c = uiMessage.id) != null ? _c : this.generateId(),
              role: (_d = uiMessage.role) != null ? _d : "user",
              metadata: message.metadata
            });
          }
          await this.makeRequest({
            trigger: "submit-message",
            messageId: message.messageId,
            ...options
          });
        };
        this.regenerate = async ({
          messageId,
          ...options
        } = {}) => {
          const messageIndex = messageId == null ? this.state.messages.length - 1 : this.state.messages.findIndex((message) => message.id === messageId);
          if (messageIndex === -1) {
            throw new Error(`message ${messageId} not found`);
          }
          this.state.messages = this.state.messages.slice(
            0,
            // if the message is a user message, we need to include it in the request:
            this.messages[messageIndex].role === "assistant" ? messageIndex : messageIndex + 1
          );
          await this.makeRequest({
            trigger: "regenerate-message",
            messageId,
            ...options
          });
        };
        this.resumeStream = async (options = {}) => {
          await this.makeRequest({ trigger: "resume-stream", ...options });
        };
        this.clearError = () => {
          if (this.status === "error") {
            this.state.error = void 0;
            this.setStatus({ status: "ready" });
          }
        };
        this.addToolApprovalResponse = async ({
          id: id2,
          approved,
          reason
        }) => this.jobExecutor.run(async () => {
          const messages = this.state.messages;
          const lastMessage = messages[messages.length - 1];
          const updatePart = (part) => isToolUIPart(part) && part.state === "approval-requested" && part.approval.id === id2 ? {
            ...part,
            state: "approval-responded",
            approval: { id: id2, approved, reason }
          } : part;
          this.state.replaceMessage(messages.length - 1, {
            ...lastMessage,
            parts: lastMessage.parts.map(updatePart)
          });
          if (this.activeResponse) {
            this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(updatePart);
          }
          if (this.status !== "streaming" && this.status !== "submitted" && this.sendAutomaticallyWhen) {
            this.shouldSendAutomatically().then((shouldSend) => {
              var _a212;
              if (shouldSend) {
                this.makeRequest({
                  trigger: "submit-message",
                  messageId: (_a212 = this.lastMessage) == null ? void 0 : _a212.id
                });
              }
            });
          }
        });
        this.addToolOutput = async ({
          state: state2 = "output-available",
          tool: tool2,
          toolCallId,
          output,
          errorText
        }) => this.jobExecutor.run(async () => {
          const messages = this.state.messages;
          const lastMessage = messages[messages.length - 1];
          const updatePart = (part) => isToolUIPart(part) && part.toolCallId === toolCallId ? { ...part, state: state2, output, errorText } : part;
          this.state.replaceMessage(messages.length - 1, {
            ...lastMessage,
            parts: lastMessage.parts.map(updatePart)
          });
          if (this.activeResponse) {
            this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(updatePart);
          }
          if (this.status !== "streaming" && this.status !== "submitted" && this.sendAutomaticallyWhen) {
            this.shouldSendAutomatically().then((shouldSend) => {
              var _a212;
              if (shouldSend) {
                this.makeRequest({
                  trigger: "submit-message",
                  messageId: (_a212 = this.lastMessage) == null ? void 0 : _a212.id
                });
              }
            });
          }
        });
        this.addToolResult = this.addToolOutput;
        this.stop = async () => {
          var _a212;
          if (this.status !== "streaming" && this.status !== "submitted")
            return;
          if ((_a212 = this.activeResponse) == null ? void 0 : _a212.abortController) {
            this.activeResponse.abortController.abort();
          }
        };
        this.id = id;
        this.transport = transport;
        this.generateId = generateId22;
        this.messageMetadataSchema = messageMetadataSchema;
        this.dataPartSchemas = dataPartSchemas;
        this.state = state;
        this.onError = onError2;
        this.onToolCall = onToolCall;
        this.onFinish = onFinish2;
        this.onData = onData;
        this.sendAutomaticallyWhen = sendAutomaticallyWhen;
      }
      /**
       * Hook status:
       *
       * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.
       * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.
       * - `ready`: The full response has been received and processed; a new user message can be submitted.
       * - `error`: An error occurred during the API request, preventing successful completion.
       */
      get status() {
        return this.state.status;
      }
      setStatus({
        status,
        error
      }) {
        if (this.status === status)
          return;
        this.state.status = status;
        this.state.error = error;
      }
      get error() {
        return this.state.error;
      }
      get messages() {
        return this.state.messages;
      }
      get lastMessage() {
        return this.state.messages[this.state.messages.length - 1];
      }
      set messages(messages) {
        this.state.messages = messages;
      }
      async shouldSendAutomatically() {
        if (!this.sendAutomaticallyWhen)
          return false;
        const result = this.sendAutomaticallyWhen({
          messages: this.state.messages
        });
        if (result && typeof result === "object" && "then" in result) {
          return await result;
        }
        return result;
      }
      async makeRequest({
        trigger,
        metadata,
        headers,
        body,
        messageId
      }) {
        var _a212, _b18, _c;
        this.setStatus({ status: "submitted", error: void 0 });
        const lastMessage = this.lastMessage;
        let isAbort = false;
        let isDisconnect = false;
        let isError = false;
        try {
          const activeResponse = {
            state: createStreamingUIMessageState({
              lastMessage: this.state.snapshot(lastMessage),
              messageId: this.generateId()
            }),
            abortController: new AbortController()
          };
          activeResponse.abortController.signal.addEventListener("abort", () => {
            isAbort = true;
          });
          this.activeResponse = activeResponse;
          let stream;
          if (trigger === "resume-stream") {
            const reconnect = await this.transport.reconnectToStream({
              chatId: this.id,
              metadata,
              headers,
              body
            });
            if (reconnect == null) {
              this.setStatus({ status: "ready" });
              return;
            }
            stream = reconnect;
          } else {
            stream = await this.transport.sendMessages({
              chatId: this.id,
              messages: this.state.messages,
              abortSignal: activeResponse.abortController.signal,
              metadata,
              headers,
              body,
              trigger,
              messageId
            });
          }
          const runUpdateMessageJob = (job) => (
            // serialize the job execution to avoid race conditions:
            this.jobExecutor.run(
              () => job({
                state: activeResponse.state,
                write: () => {
                  var _a222;
                  this.setStatus({ status: "streaming" });
                  const replaceLastMessage = activeResponse.state.message.id === ((_a222 = this.lastMessage) == null ? void 0 : _a222.id);
                  if (replaceLastMessage) {
                    this.state.replaceMessage(
                      this.state.messages.length - 1,
                      activeResponse.state.message
                    );
                  } else {
                    this.state.pushMessage(activeResponse.state.message);
                  }
                }
              })
            )
          );
          await consumeStream({
            stream: processUIMessageStream({
              stream,
              onToolCall: this.onToolCall,
              onData: this.onData,
              messageMetadataSchema: this.messageMetadataSchema,
              dataPartSchemas: this.dataPartSchemas,
              runUpdateMessageJob,
              onError: (error) => {
                throw error;
              }
            }),
            onError: (error) => {
              throw error;
            }
          });
          this.setStatus({ status: "ready" });
        } catch (err) {
          if (isAbort || err.name === "AbortError") {
            isAbort = true;
            this.setStatus({ status: "ready" });
            return null;
          }
          isError = true;
          if (err instanceof TypeError && (err.message.toLowerCase().includes("fetch") || err.message.toLowerCase().includes("network"))) {
            isDisconnect = true;
          }
          if (this.onError && err instanceof Error) {
            this.onError(err);
          }
          this.setStatus({ status: "error", error: err });
        } finally {
          try {
            (_b18 = this.onFinish) == null ? void 0 : _b18.call(this, {
              message: this.activeResponse.state.message,
              messages: this.state.messages,
              isAbort,
              isDisconnect,
              isError,
              finishReason: (_a212 = this.activeResponse) == null ? void 0 : _a212.state.finishReason
            });
          } catch (err) {
            console.error(err);
          }
          this.activeResponse = void 0;
        }
        if (!isError && await this.shouldSendAutomatically()) {
          await this.makeRequest({
            trigger: "submit-message",
            messageId: (_c = this.lastMessage) == null ? void 0 : _c.id,
            metadata,
            headers,
            body
          });
        }
      }
    };
    DirectChatTransport = class {
      constructor({
        agent,
        options,
        ...uiMessageStreamOptions
      }) {
        this.agent = agent;
        this.agentOptions = options;
        this.uiMessageStreamOptions = uiMessageStreamOptions;
      }
      async sendMessages({
        messages,
        abortSignal
      }) {
        const validatedMessages = await validateUIMessages({
          messages,
          tools: this.agent.tools
        });
        const modelMessages = await convertToModelMessages(validatedMessages, {
          tools: this.agent.tools
        });
        const result = await this.agent.stream({
          prompt: modelMessages,
          abortSignal,
          ...this.agentOptions !== void 0 ? { options: this.agentOptions } : {}
        });
        return result.toUIMessageStream(this.uiMessageStreamOptions);
      }
      /**
       * Direct transport does not support reconnection since there is no
       * persistent server-side stream to reconnect to.
       *
       * @returns Always returns `null`
       */
      async reconnectToStream(_options) {
        return null;
      }
    };
    TextStreamChatTransport = class extends HttpChatTransport {
      constructor(options = {}) {
        super(options);
      }
      processResponseStream(stream) {
        return transformTextToUiMessageStream({
          stream: stream.pipeThrough(new TextDecoderStream())
        });
      }
    };
  }
});

// node_modules/@ai-sdk/anthropic/dist/index.mjs
var dist_exports3 = {};
__export(dist_exports3, {
  VERSION: () => VERSION5,
  anthropic: () => anthropic,
  createAnthropic: () => createAnthropic,
  forwardAnthropicContainerIdFromLastStep: () => forwardAnthropicContainerIdFromLastStep
});
import { z as z18 } from "zod/v4";
import { z as z24 } from "zod/v4";
import { z as z34 } from "zod/v4";
import { z as z45 } from "zod/v4";
import { z as z54 } from "zod/v4";
import { z as z64 } from "zod/v4";
import { z as z74 } from "zod/v4";
import { z as z84 } from "zod/v4";
import { z as z93 } from "zod/v4";
import { z as z103 } from "zod/v4";
import { z as z112 } from "zod/v4";
import { z as z122 } from "zod/v4";
import { z as z132 } from "zod/v4";
import { z as z142 } from "zod/v4";
import { z as z152 } from "zod/v4";
import { z as z162 } from "zod/v4";
import { z as z172 } from "zod/v4";
import { z as z182 } from "zod/v4";
import { z as z19 } from "zod/v4";
function getCacheControl(providerMetadata) {
  var _a25;
  const anthropic2 = providerMetadata == null ? void 0 : providerMetadata.anthropic;
  const cacheControlValue = (_a25 = anthropic2 == null ? void 0 : anthropic2.cacheControl) != null ? _a25 : anthropic2 == null ? void 0 : anthropic2.cache_control;
  return cacheControlValue;
}
async function prepareTools({
  tools,
  toolChoice,
  disableParallelToolUse,
  cacheControlValidator,
  supportsStructuredOutput
}) {
  var _a25;
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  const betas = /* @__PURE__ */ new Set();
  const validator = cacheControlValidator || new CacheControlValidator();
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
  }
  const anthropicTools22 = [];
  for (const tool2 of tools) {
    switch (tool2.type) {
      case "function": {
        const cacheControl = validator.getCacheControl(tool2.providerOptions, {
          type: "tool definition",
          canCache: true
        });
        const anthropicOptions = (_a25 = tool2.providerOptions) == null ? void 0 : _a25.anthropic;
        const deferLoading = anthropicOptions == null ? void 0 : anthropicOptions.deferLoading;
        const allowedCallers = anthropicOptions == null ? void 0 : anthropicOptions.allowedCallers;
        anthropicTools22.push({
          name: tool2.name,
          description: tool2.description,
          input_schema: tool2.inputSchema,
          cache_control: cacheControl,
          ...supportsStructuredOutput === true && tool2.strict != null ? { strict: tool2.strict } : {},
          ...deferLoading != null ? { defer_loading: deferLoading } : {},
          ...allowedCallers != null ? { allowed_callers: allowedCallers } : {},
          ...tool2.inputExamples != null ? {
            input_examples: tool2.inputExamples.map(
              (example) => example.input
            )
          } : {}
        });
        if (supportsStructuredOutput === true) {
          betas.add("structured-outputs-2025-11-13");
        }
        if (tool2.inputExamples != null || allowedCallers != null) {
          betas.add("advanced-tool-use-2025-11-20");
        }
        break;
      }
      case "provider": {
        switch (tool2.id) {
          case "anthropic.code_execution_20250522": {
            betas.add("code-execution-2025-05-22");
            anthropicTools22.push({
              type: "code_execution_20250522",
              name: "code_execution",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.code_execution_20250825": {
            betas.add("code-execution-2025-08-25");
            anthropicTools22.push({
              type: "code_execution_20250825",
              name: "code_execution"
            });
            break;
          }
          case "anthropic.computer_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools22.push({
              name: "computer",
              type: "computer_20250124",
              display_width_px: tool2.args.displayWidthPx,
              display_height_px: tool2.args.displayHeightPx,
              display_number: tool2.args.displayNumber,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.computer_20251124": {
            betas.add("computer-use-2025-11-24");
            anthropicTools22.push({
              name: "computer",
              type: "computer_20251124",
              display_width_px: tool2.args.displayWidthPx,
              display_height_px: tool2.args.displayHeightPx,
              display_number: tool2.args.displayNumber,
              enable_zoom: tool2.args.enableZoom,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.computer_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools22.push({
              name: "computer",
              type: "computer_20241022",
              display_width_px: tool2.args.displayWidthPx,
              display_height_px: tool2.args.displayHeightPx,
              display_number: tool2.args.displayNumber,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools22.push({
              name: "str_replace_editor",
              type: "text_editor_20250124",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools22.push({
              name: "str_replace_editor",
              type: "text_editor_20241022",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250429": {
            betas.add("computer-use-2025-01-24");
            anthropicTools22.push({
              name: "str_replace_based_edit_tool",
              type: "text_editor_20250429",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250728": {
            const args2 = await validateTypes({
              value: tool2.args,
              schema: textEditor_20250728ArgsSchema
            });
            anthropicTools22.push({
              name: "str_replace_based_edit_tool",
              type: "text_editor_20250728",
              max_characters: args2.maxCharacters,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.bash_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools22.push({
              name: "bash",
              type: "bash_20250124",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.bash_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools22.push({
              name: "bash",
              type: "bash_20241022",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.memory_20250818": {
            betas.add("context-management-2025-06-27");
            anthropicTools22.push({
              name: "memory",
              type: "memory_20250818"
            });
            break;
          }
          case "anthropic.web_fetch_20250910": {
            betas.add("web-fetch-2025-09-10");
            const args2 = await validateTypes({
              value: tool2.args,
              schema: webFetch_20250910ArgsSchema
            });
            anthropicTools22.push({
              type: "web_fetch_20250910",
              name: "web_fetch",
              max_uses: args2.maxUses,
              allowed_domains: args2.allowedDomains,
              blocked_domains: args2.blockedDomains,
              citations: args2.citations,
              max_content_tokens: args2.maxContentTokens,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.web_search_20250305": {
            const args2 = await validateTypes({
              value: tool2.args,
              schema: webSearch_20250305ArgsSchema
            });
            anthropicTools22.push({
              type: "web_search_20250305",
              name: "web_search",
              max_uses: args2.maxUses,
              allowed_domains: args2.allowedDomains,
              blocked_domains: args2.blockedDomains,
              user_location: args2.userLocation,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.tool_search_regex_20251119": {
            betas.add("advanced-tool-use-2025-11-20");
            anthropicTools22.push({
              type: "tool_search_tool_regex_20251119",
              name: "tool_search_tool_regex"
            });
            break;
          }
          case "anthropic.tool_search_bm25_20251119": {
            betas.add("advanced-tool-use-2025-11-20");
            anthropicTools22.push({
              type: "tool_search_tool_bm25_20251119",
              name: "tool_search_tool_bm25"
            });
            break;
          }
          default: {
            toolWarnings.push({
              type: "unsupported",
              feature: `provider-defined tool ${tool2.id}`
            });
            break;
          }
        }
        break;
      }
      default: {
        toolWarnings.push({
          type: "unsupported",
          feature: `tool ${tool2}`
        });
        break;
      }
    }
  }
  if (toolChoice == null) {
    return {
      tools: anthropicTools22,
      toolChoice: disableParallelToolUse ? { type: "auto", disable_parallel_tool_use: disableParallelToolUse } : void 0,
      toolWarnings,
      betas
    };
  }
  const type2 = toolChoice.type;
  switch (type2) {
    case "auto":
      return {
        tools: anthropicTools22,
        toolChoice: {
          type: "auto",
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    case "required":
      return {
        tools: anthropicTools22,
        toolChoice: {
          type: "any",
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    case "none":
      return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
    case "tool":
      return {
        tools: anthropicTools22,
        toolChoice: {
          type: "tool",
          name: toolChoice.toolName,
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    default: {
      const _exhaustiveCheck = type2;
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function convertAnthropicMessagesUsage(usage) {
  var _a25, _b18;
  const inputTokens = usage.input_tokens;
  const outputTokens = usage.output_tokens;
  const cacheCreationTokens = (_a25 = usage.cache_creation_input_tokens) != null ? _a25 : 0;
  const cacheReadTokens = (_b18 = usage.cache_read_input_tokens) != null ? _b18 : 0;
  return {
    inputTokens: {
      total: inputTokens + cacheCreationTokens + cacheReadTokens,
      noCache: inputTokens,
      cacheRead: cacheReadTokens,
      cacheWrite: cacheCreationTokens
    },
    outputTokens: {
      total: outputTokens,
      text: void 0,
      reasoning: void 0
    },
    raw: usage
  };
}
function convertToString(data) {
  if (typeof data === "string") {
    return Buffer.from(data, "base64").toString("utf-8");
  }
  if (data instanceof Uint8Array) {
    return new TextDecoder().decode(data);
  }
  if (data instanceof URL) {
    throw new UnsupportedFunctionalityError({
      functionality: "URL-based text documents are not supported for citations"
    });
  }
  throw new UnsupportedFunctionalityError({
    functionality: `unsupported data type for text documents: ${typeof data}`
  });
}
function isUrlData(data) {
  return data instanceof URL || isUrlString(data);
}
function isUrlString(data) {
  return typeof data === "string" && /^https?:\/\//i.test(data);
}
function getUrlString(data) {
  return data instanceof URL ? data.toString() : data;
}
async function convertToAnthropicMessagesPrompt({
  prompt,
  sendReasoning,
  warnings,
  cacheControlValidator,
  toolNameMapping
}) {
  var _a25, _b18, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
  const betas = /* @__PURE__ */ new Set();
  const blocks = groupIntoBlocks(prompt);
  const validator = cacheControlValidator || new CacheControlValidator();
  let system = void 0;
  const messages = [];
  async function shouldEnableCitations2(providerMetadata) {
    var _a26, _b24;
    const anthropicOptions = await parseProviderOptions({
      provider: "anthropic",
      providerOptions: providerMetadata,
      schema: anthropicFilePartProviderOptions
    });
    return (_b24 = (_a26 = anthropicOptions == null ? void 0 : anthropicOptions.citations) == null ? void 0 : _a26.enabled) != null ? _b24 : false;
  }
  async function getDocumentMetadata(providerMetadata) {
    const anthropicOptions = await parseProviderOptions({
      provider: "anthropic",
      providerOptions: providerMetadata,
      schema: anthropicFilePartProviderOptions
    });
    return {
      title: anthropicOptions == null ? void 0 : anthropicOptions.title,
      context: anthropicOptions == null ? void 0 : anthropicOptions.context
    };
  }
  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    const isLastBlock = i === blocks.length - 1;
    const type2 = block.type;
    switch (type2) {
      case "system": {
        if (system != null) {
          throw new UnsupportedFunctionalityError({
            functionality: "Multiple system messages that are separated by user/assistant messages"
          });
        }
        system = block.messages.map(({ content, providerOptions }) => ({
          type: "text",
          text: content,
          cache_control: validator.getCacheControl(providerOptions, {
            type: "system message",
            canCache: true
          })
        }));
        break;
      }
      case "user": {
        const anthropicContent = [];
        for (const message of block.messages) {
          const { role, content } = message;
          switch (role) {
            case "user": {
              for (let j = 0; j < content.length; j++) {
                const part = content[j];
                const isLastPart = j === content.length - 1;
                const cacheControl = (_a25 = validator.getCacheControl(part.providerOptions, {
                  type: "user message part",
                  canCache: true
                })) != null ? _a25 : isLastPart ? validator.getCacheControl(message.providerOptions, {
                  type: "user message",
                  canCache: true
                }) : void 0;
                switch (part.type) {
                  case "text": {
                    anthropicContent.push({
                      type: "text",
                      text: part.text,
                      cache_control: cacheControl
                    });
                    break;
                  }
                  case "file": {
                    if (part.mediaType.startsWith("image/")) {
                      anthropicContent.push({
                        type: "image",
                        source: isUrlData(part.data) ? {
                          type: "url",
                          url: getUrlString(part.data)
                        } : {
                          type: "base64",
                          media_type: part.mediaType === "image/*" ? "image/jpeg" : part.mediaType,
                          data: convertToBase64(part.data)
                        },
                        cache_control: cacheControl
                      });
                    } else if (part.mediaType === "application/pdf") {
                      betas.add("pdfs-2024-09-25");
                      const enableCitations = await shouldEnableCitations2(
                        part.providerOptions
                      );
                      const metadata = await getDocumentMetadata(
                        part.providerOptions
                      );
                      anthropicContent.push({
                        type: "document",
                        source: isUrlData(part.data) ? {
                          type: "url",
                          url: getUrlString(part.data)
                        } : {
                          type: "base64",
                          media_type: "application/pdf",
                          data: convertToBase64(part.data)
                        },
                        title: (_b18 = metadata.title) != null ? _b18 : part.filename,
                        ...metadata.context && { context: metadata.context },
                        ...enableCitations && {
                          citations: { enabled: true }
                        },
                        cache_control: cacheControl
                      });
                    } else if (part.mediaType === "text/plain") {
                      const enableCitations = await shouldEnableCitations2(
                        part.providerOptions
                      );
                      const metadata = await getDocumentMetadata(
                        part.providerOptions
                      );
                      anthropicContent.push({
                        type: "document",
                        source: isUrlData(part.data) ? {
                          type: "url",
                          url: getUrlString(part.data)
                        } : {
                          type: "text",
                          media_type: "text/plain",
                          data: convertToString(part.data)
                        },
                        title: (_c = metadata.title) != null ? _c : part.filename,
                        ...metadata.context && { context: metadata.context },
                        ...enableCitations && {
                          citations: { enabled: true }
                        },
                        cache_control: cacheControl
                      });
                    } else {
                      throw new UnsupportedFunctionalityError({
                        functionality: `media type: ${part.mediaType}`
                      });
                    }
                    break;
                  }
                }
              }
              break;
            }
            case "tool": {
              for (let i2 = 0; i2 < content.length; i2++) {
                const part = content[i2];
                if (part.type === "tool-approval-response") {
                  continue;
                }
                const isLastPart = i2 === content.length - 1;
                const cacheControl = (_d = validator.getCacheControl(part.providerOptions, {
                  type: "tool result part",
                  canCache: true
                })) != null ? _d : isLastPart ? validator.getCacheControl(message.providerOptions, {
                  type: "tool result message",
                  canCache: true
                }) : void 0;
                const output = part.output;
                let contentValue;
                switch (output.type) {
                  case "content":
                    contentValue = output.value.map((contentPart) => {
                      var _a26;
                      switch (contentPart.type) {
                        case "text":
                          return {
                            type: "text",
                            text: contentPart.text
                          };
                        case "image-data": {
                          return {
                            type: "image",
                            source: {
                              type: "base64",
                              media_type: contentPart.mediaType,
                              data: contentPart.data
                            }
                          };
                        }
                        case "image-url": {
                          return {
                            type: "image",
                            source: {
                              type: "url",
                              url: contentPart.url
                            }
                          };
                        }
                        case "file-url": {
                          return {
                            type: "document",
                            source: {
                              type: "url",
                              url: contentPart.url
                            }
                          };
                        }
                        case "file-data": {
                          if (contentPart.mediaType === "application/pdf") {
                            betas.add("pdfs-2024-09-25");
                            return {
                              type: "document",
                              source: {
                                type: "base64",
                                media_type: contentPart.mediaType,
                                data: contentPart.data
                              }
                            };
                          }
                          warnings.push({
                            type: "other",
                            message: `unsupported tool content part type: ${contentPart.type} with media type: ${contentPart.mediaType}`
                          });
                          return void 0;
                        }
                        case "custom": {
                          const anthropicOptions = (_a26 = contentPart.providerOptions) == null ? void 0 : _a26.anthropic;
                          if ((anthropicOptions == null ? void 0 : anthropicOptions.type) === "tool-reference") {
                            return {
                              type: "tool_reference",
                              tool_name: anthropicOptions.toolName
                            };
                          }
                          warnings.push({
                            type: "other",
                            message: `unsupported custom tool content part`
                          });
                          return void 0;
                        }
                        default: {
                          warnings.push({
                            type: "other",
                            message: `unsupported tool content part type: ${contentPart.type}`
                          });
                          return void 0;
                        }
                      }
                    }).filter(isNonNullable);
                    break;
                  case "text":
                  case "error-text":
                    contentValue = output.value;
                    break;
                  case "execution-denied":
                    contentValue = (_e = output.reason) != null ? _e : "Tool execution denied.";
                    break;
                  case "json":
                  case "error-json":
                  default:
                    contentValue = JSON.stringify(output.value);
                    break;
                }
                anthropicContent.push({
                  type: "tool_result",
                  tool_use_id: part.toolCallId,
                  content: contentValue,
                  is_error: output.type === "error-text" || output.type === "error-json" ? true : void 0,
                  cache_control: cacheControl
                });
              }
              break;
            }
            default: {
              const _exhaustiveCheck = role;
              throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
            }
          }
        }
        messages.push({ role: "user", content: anthropicContent });
        break;
      }
      case "assistant": {
        const anthropicContent = [];
        const mcpToolUseIds = /* @__PURE__ */ new Set();
        for (let j = 0; j < block.messages.length; j++) {
          const message = block.messages[j];
          const isLastMessage = j === block.messages.length - 1;
          const { content } = message;
          for (let k = 0; k < content.length; k++) {
            const part = content[k];
            const isLastContentPart = k === content.length - 1;
            const cacheControl = (_f = validator.getCacheControl(part.providerOptions, {
              type: "assistant message part",
              canCache: true
            })) != null ? _f : isLastContentPart ? validator.getCacheControl(message.providerOptions, {
              type: "assistant message",
              canCache: true
            }) : void 0;
            switch (part.type) {
              case "text": {
                anthropicContent.push({
                  type: "text",
                  text: (
                    // trim the last text part if it's the last message in the block
                    // because Anthropic does not allow trailing whitespace
                    // in pre-filled assistant responses
                    isLastBlock && isLastMessage && isLastContentPart ? part.text.trim() : part.text
                  ),
                  cache_control: cacheControl
                });
                break;
              }
              case "reasoning": {
                if (sendReasoning) {
                  const reasoningMetadata = await parseProviderOptions({
                    provider: "anthropic",
                    providerOptions: part.providerOptions,
                    schema: anthropicReasoningMetadataSchema
                  });
                  if (reasoningMetadata != null) {
                    if (reasoningMetadata.signature != null) {
                      validator.getCacheControl(part.providerOptions, {
                        type: "thinking block",
                        canCache: false
                      });
                      anthropicContent.push({
                        type: "thinking",
                        thinking: part.text,
                        signature: reasoningMetadata.signature
                      });
                    } else if (reasoningMetadata.redactedData != null) {
                      validator.getCacheControl(part.providerOptions, {
                        type: "redacted thinking block",
                        canCache: false
                      });
                      anthropicContent.push({
                        type: "redacted_thinking",
                        data: reasoningMetadata.redactedData
                      });
                    } else {
                      warnings.push({
                        type: "other",
                        message: "unsupported reasoning metadata"
                      });
                    }
                  } else {
                    warnings.push({
                      type: "other",
                      message: "unsupported reasoning metadata"
                    });
                  }
                } else {
                  warnings.push({
                    type: "other",
                    message: "sending reasoning content is disabled for this model"
                  });
                }
                break;
              }
              case "tool-call": {
                if (part.providerExecuted) {
                  const providerToolName = toolNameMapping.toProviderToolName(
                    part.toolName
                  );
                  const isMcpToolUse = ((_h = (_g = part.providerOptions) == null ? void 0 : _g.anthropic) == null ? void 0 : _h.type) === "mcp-tool-use";
                  if (isMcpToolUse) {
                    mcpToolUseIds.add(part.toolCallId);
                    const serverName = (_j = (_i = part.providerOptions) == null ? void 0 : _i.anthropic) == null ? void 0 : _j.serverName;
                    if (serverName == null || typeof serverName !== "string") {
                      warnings.push({
                        type: "other",
                        message: "mcp tool use server name is required and must be a string"
                      });
                      break;
                    }
                    anthropicContent.push({
                      type: "mcp_tool_use",
                      id: part.toolCallId,
                      name: part.toolName,
                      input: part.input,
                      server_name: serverName,
                      cache_control: cacheControl
                    });
                  } else if (
                    // code execution 20250825:
                    providerToolName === "code_execution" && part.input != null && typeof part.input === "object" && "type" in part.input && typeof part.input.type === "string" && (part.input.type === "bash_code_execution" || part.input.type === "text_editor_code_execution")
                  ) {
                    anthropicContent.push({
                      type: "server_tool_use",
                      id: part.toolCallId,
                      name: part.input.type,
                      // map back to subtool name
                      input: part.input,
                      cache_control: cacheControl
                    });
                  } else if (
                    // code execution 20250825 programmatic tool calling:
                    // Strip the fake 'programmatic-tool-call' type before sending to Anthropic
                    providerToolName === "code_execution" && part.input != null && typeof part.input === "object" && "type" in part.input && part.input.type === "programmatic-tool-call"
                  ) {
                    const { type: _, ...inputWithoutType } = part.input;
                    anthropicContent.push({
                      type: "server_tool_use",
                      id: part.toolCallId,
                      name: "code_execution",
                      input: inputWithoutType,
                      cache_control: cacheControl
                    });
                  } else {
                    if (providerToolName === "code_execution" || // code execution 20250522
                    providerToolName === "web_fetch" || providerToolName === "web_search") {
                      anthropicContent.push({
                        type: "server_tool_use",
                        id: part.toolCallId,
                        name: providerToolName,
                        input: part.input,
                        cache_control: cacheControl
                      });
                    } else if (providerToolName === "tool_search_tool_regex" || providerToolName === "tool_search_tool_bm25") {
                      anthropicContent.push({
                        type: "server_tool_use",
                        id: part.toolCallId,
                        name: providerToolName,
                        input: part.input,
                        cache_control: cacheControl
                      });
                    } else {
                      warnings.push({
                        type: "other",
                        message: `provider executed tool call for tool ${part.toolName} is not supported`
                      });
                    }
                  }
                  break;
                }
                const callerOptions = (_k = part.providerOptions) == null ? void 0 : _k.anthropic;
                const caller = (callerOptions == null ? void 0 : callerOptions.caller) ? callerOptions.caller.type === "code_execution_20250825" && callerOptions.caller.toolId ? {
                  type: "code_execution_20250825",
                  tool_id: callerOptions.caller.toolId
                } : callerOptions.caller.type === "direct" ? { type: "direct" } : void 0 : void 0;
                anthropicContent.push({
                  type: "tool_use",
                  id: part.toolCallId,
                  name: part.toolName,
                  input: part.input,
                  ...caller && { caller },
                  cache_control: cacheControl
                });
                break;
              }
              case "tool-result": {
                const providerToolName = toolNameMapping.toProviderToolName(
                  part.toolName
                );
                if (mcpToolUseIds.has(part.toolCallId)) {
                  const output = part.output;
                  if (output.type !== "json" && output.type !== "error-json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  anthropicContent.push({
                    type: "mcp_tool_result",
                    tool_use_id: part.toolCallId,
                    is_error: output.type === "error-json",
                    content: output.value,
                    cache_control: cacheControl
                  });
                } else if (providerToolName === "code_execution") {
                  const output = part.output;
                  if (output.type === "error-text" || output.type === "error-json") {
                    let errorInfo = {};
                    try {
                      if (typeof output.value === "string") {
                        errorInfo = JSON.parse(output.value);
                      } else if (typeof output.value === "object" && output.value !== null) {
                        errorInfo = output.value;
                      }
                    } catch (e) {
                    }
                    if (errorInfo.type === "code_execution_tool_result_error") {
                      anthropicContent.push({
                        type: "code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        content: {
                          type: "code_execution_tool_result_error",
                          error_code: (_l = errorInfo.errorCode) != null ? _l : "unknown"
                        },
                        cache_control: cacheControl
                      });
                    } else {
                      anthropicContent.push({
                        type: "bash_code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        cache_control: cacheControl,
                        content: {
                          type: "bash_code_execution_tool_result_error",
                          error_code: (_m = errorInfo.errorCode) != null ? _m : "unknown"
                        }
                      });
                    }
                    break;
                  }
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  if (output.value == null || typeof output.value !== "object" || !("type" in output.value) || typeof output.value.type !== "string") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output value is not a valid code execution result for tool ${part.toolName}`
                    });
                    break;
                  }
                  if (output.value.type === "code_execution_result") {
                    const codeExecutionOutput = await validateTypes({
                      value: output.value,
                      schema: codeExecution_20250522OutputSchema
                    });
                    anthropicContent.push({
                      type: "code_execution_tool_result",
                      tool_use_id: part.toolCallId,
                      content: {
                        type: codeExecutionOutput.type,
                        stdout: codeExecutionOutput.stdout,
                        stderr: codeExecutionOutput.stderr,
                        return_code: codeExecutionOutput.return_code,
                        content: (_n = codeExecutionOutput.content) != null ? _n : []
                      },
                      cache_control: cacheControl
                    });
                  } else {
                    const codeExecutionOutput = await validateTypes({
                      value: output.value,
                      schema: codeExecution_20250825OutputSchema
                    });
                    if (codeExecutionOutput.type === "code_execution_result") {
                      anthropicContent.push({
                        type: "code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        content: {
                          type: codeExecutionOutput.type,
                          stdout: codeExecutionOutput.stdout,
                          stderr: codeExecutionOutput.stderr,
                          return_code: codeExecutionOutput.return_code,
                          content: (_o = codeExecutionOutput.content) != null ? _o : []
                        },
                        cache_control: cacheControl
                      });
                    } else if (codeExecutionOutput.type === "bash_code_execution_result" || codeExecutionOutput.type === "bash_code_execution_tool_result_error") {
                      anthropicContent.push({
                        type: "bash_code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        cache_control: cacheControl,
                        content: codeExecutionOutput
                      });
                    } else {
                      anthropicContent.push({
                        type: "text_editor_code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        cache_control: cacheControl,
                        content: codeExecutionOutput
                      });
                    }
                  }
                  break;
                }
                if (providerToolName === "web_fetch") {
                  const output = part.output;
                  if (output.type === "error-json") {
                    let errorValue = {};
                    try {
                      if (typeof output.value === "string") {
                        errorValue = JSON.parse(output.value);
                      } else if (typeof output.value === "object" && output.value !== null) {
                        errorValue = output.value;
                      }
                    } catch (e) {
                      const extractedErrorCode = (_p = output.value) == null ? void 0 : _p.errorCode;
                      errorValue = {
                        errorCode: typeof extractedErrorCode === "string" ? extractedErrorCode : "unknown"
                      };
                    }
                    anthropicContent.push({
                      type: "web_fetch_tool_result",
                      tool_use_id: part.toolCallId,
                      content: {
                        type: "web_fetch_tool_result_error",
                        error_code: (_q = errorValue.errorCode) != null ? _q : "unknown"
                      },
                      cache_control: cacheControl
                    });
                    break;
                  }
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  const webFetchOutput = await validateTypes({
                    value: output.value,
                    schema: webFetch_20250910OutputSchema
                  });
                  anthropicContent.push({
                    type: "web_fetch_tool_result",
                    tool_use_id: part.toolCallId,
                    content: {
                      type: "web_fetch_result",
                      url: webFetchOutput.url,
                      retrieved_at: webFetchOutput.retrievedAt,
                      content: {
                        type: "document",
                        title: webFetchOutput.content.title,
                        citations: webFetchOutput.content.citations,
                        source: {
                          type: webFetchOutput.content.source.type,
                          media_type: webFetchOutput.content.source.mediaType,
                          data: webFetchOutput.content.source.data
                        }
                      }
                    },
                    cache_control: cacheControl
                  });
                  break;
                }
                if (providerToolName === "web_search") {
                  const output = part.output;
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  const webSearchOutput = await validateTypes({
                    value: output.value,
                    schema: webSearch_20250305OutputSchema
                  });
                  anthropicContent.push({
                    type: "web_search_tool_result",
                    tool_use_id: part.toolCallId,
                    content: webSearchOutput.map((result) => ({
                      url: result.url,
                      title: result.title,
                      page_age: result.pageAge,
                      encrypted_content: result.encryptedContent,
                      type: result.type
                    })),
                    cache_control: cacheControl
                  });
                  break;
                }
                if (providerToolName === "tool_search_tool_regex" || providerToolName === "tool_search_tool_bm25") {
                  const output = part.output;
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  const toolSearchOutput = await validateTypes({
                    value: output.value,
                    schema: toolSearchRegex_20251119OutputSchema
                  });
                  const toolReferences = toolSearchOutput.map((ref) => ({
                    type: "tool_reference",
                    tool_name: ref.toolName
                  }));
                  anthropicContent.push({
                    type: "tool_search_tool_result",
                    tool_use_id: part.toolCallId,
                    content: {
                      type: "tool_search_tool_search_result",
                      tool_references: toolReferences
                    },
                    cache_control: cacheControl
                  });
                  break;
                }
                warnings.push({
                  type: "other",
                  message: `provider executed tool result for tool ${part.toolName} is not supported`
                });
                break;
              }
            }
          }
        }
        messages.push({ role: "assistant", content: anthropicContent });
        break;
      }
      default: {
        const _exhaustiveCheck = type2;
        throw new Error(`content type: ${_exhaustiveCheck}`);
      }
    }
  }
  return {
    prompt: { system, messages },
    betas
  };
}
function groupIntoBlocks(prompt) {
  const blocks = [];
  let currentBlock = void 0;
  for (const message of prompt) {
    const { role } = message;
    switch (role) {
      case "system": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "system") {
          currentBlock = { type: "system", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "assistant": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "assistant") {
          currentBlock = { type: "assistant", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "user": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
          currentBlock = { type: "user", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "tool": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
          currentBlock = { type: "user", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return blocks;
}
function mapAnthropicStopReason({
  finishReason,
  isJsonResponseFromTool
}) {
  switch (finishReason) {
    case "pause_turn":
    case "end_turn":
    case "stop_sequence":
      return "stop";
    case "refusal":
      return "content-filter";
    case "tool_use":
      return isJsonResponseFromTool ? "stop" : "tool-calls";
    case "max_tokens":
    case "model_context_window_exceeded":
      return "length";
    default:
      return "other";
  }
}
function createCitationSource(citation, citationDocuments, generateId3) {
  var _a25;
  if (citation.type === "web_search_result_location") {
    return {
      type: "source",
      sourceType: "url",
      id: generateId3(),
      url: citation.url,
      title: citation.title,
      providerMetadata: {
        anthropic: {
          citedText: citation.cited_text,
          encryptedIndex: citation.encrypted_index
        }
      }
    };
  }
  if (citation.type !== "page_location" && citation.type !== "char_location") {
    return;
  }
  const documentInfo = citationDocuments[citation.document_index];
  if (!documentInfo) {
    return;
  }
  return {
    type: "source",
    sourceType: "document",
    id: generateId3(),
    mediaType: documentInfo.mediaType,
    title: (_a25 = citation.document_title) != null ? _a25 : documentInfo.title,
    filename: documentInfo.filename,
    providerMetadata: {
      anthropic: citation.type === "page_location" ? {
        citedText: citation.cited_text,
        startPageNumber: citation.start_page_number,
        endPageNumber: citation.end_page_number
      } : {
        citedText: citation.cited_text,
        startCharIndex: citation.start_char_index,
        endCharIndex: citation.end_char_index
      }
    }
  };
}
function getModelCapabilities(modelId) {
  if (modelId.includes("claude-opus-4-6")) {
    return {
      maxOutputTokens: 128e3,
      supportsStructuredOutput: true,
      isKnownModel: true
    };
  } else if (modelId.includes("claude-sonnet-4-5") || modelId.includes("claude-opus-4-5") || modelId.includes("claude-haiku-4-5")) {
    return {
      maxOutputTokens: 64e3,
      supportsStructuredOutput: true,
      isKnownModel: true
    };
  } else if (modelId.includes("claude-opus-4-1")) {
    return {
      maxOutputTokens: 32e3,
      supportsStructuredOutput: true,
      isKnownModel: true
    };
  } else if (modelId.includes("claude-sonnet-4-") || modelId.includes("claude-3-7-sonnet")) {
    return {
      maxOutputTokens: 64e3,
      supportsStructuredOutput: false,
      isKnownModel: true
    };
  } else if (modelId.includes("claude-opus-4-")) {
    return {
      maxOutputTokens: 32e3,
      supportsStructuredOutput: false,
      isKnownModel: true
    };
  } else if (modelId.includes("claude-3-5-haiku")) {
    return {
      maxOutputTokens: 8192,
      supportsStructuredOutput: false,
      isKnownModel: true
    };
  } else if (modelId.includes("claude-3-haiku")) {
    return {
      maxOutputTokens: 4096,
      supportsStructuredOutput: false,
      isKnownModel: true
    };
  } else {
    return {
      maxOutputTokens: 4096,
      supportsStructuredOutput: false,
      isKnownModel: false
    };
  }
}
function mapAnthropicResponseContextManagement(contextManagement) {
  return contextManagement ? {
    appliedEdits: contextManagement.applied_edits.map((edit) => {
      const strategy = edit.type;
      switch (strategy) {
        case "clear_tool_uses_20250919":
          return {
            type: edit.type,
            clearedToolUses: edit.cleared_tool_uses,
            clearedInputTokens: edit.cleared_input_tokens
          };
        case "clear_thinking_20251015":
          return {
            type: edit.type,
            clearedThinkingTurns: edit.cleared_thinking_turns,
            clearedInputTokens: edit.cleared_input_tokens
          };
      }
    }).filter((edit) => edit !== void 0)
  } : null;
}
function createAnthropic(options = {}) {
  var _a25, _b18;
  const baseURL = (_a25 = withoutTrailingSlash(
    loadOptionalSetting({
      settingValue: options.baseURL,
      environmentVariableName: "ANTHROPIC_BASE_URL"
    })
  )) != null ? _a25 : "https://api.anthropic.com/v1";
  const providerName = (_b18 = options.name) != null ? _b18 : "anthropic.messages";
  if (options.apiKey && options.authToken) {
    throw new InvalidArgumentError2({
      argument: "apiKey/authToken",
      message: "Both apiKey and authToken were provided. Please use only one authentication method."
    });
  }
  const getHeaders = () => {
    const authHeaders = options.authToken ? { Authorization: `Bearer ${options.authToken}` } : {
      "x-api-key": loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "ANTHROPIC_API_KEY",
        description: "Anthropic"
      })
    };
    return withUserAgentSuffix(
      {
        "anthropic-version": "2023-06-01",
        ...authHeaders,
        ...options.headers
      },
      `ai-sdk/anthropic/${VERSION5}`
    );
  };
  const createChatModel = (modelId) => {
    var _a26;
    return new AnthropicMessagesLanguageModel(modelId, {
      provider: providerName,
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      generateId: (_a26 = options.generateId) != null ? _a26 : generateId,
      supportedUrls: () => ({
        "image/*": [/^https?:\/\/.*$/],
        "application/pdf": [/^https?:\/\/.*$/]
      })
    });
  };
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Anthropic model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  provider.specificationVersion = "v3";
  provider.languageModel = createChatModel;
  provider.chat = createChatModel;
  provider.messages = createChatModel;
  provider.embeddingModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "embeddingModel" });
  };
  provider.textEmbeddingModel = provider.embeddingModel;
  provider.imageModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  provider.tools = anthropicTools;
  return provider;
}
function forwardAnthropicContainerIdFromLastStep({
  steps
}) {
  var _a25, _b18, _c;
  for (let i = steps.length - 1; i >= 0; i--) {
    const containerId = (_c = (_b18 = (_a25 = steps[i].providerMetadata) == null ? void 0 : _a25.anthropic) == null ? void 0 : _b18.container) == null ? void 0 : _c.id;
    if (containerId) {
      return {
        providerOptions: {
          anthropic: {
            container: { id: containerId }
          }
        }
      };
    }
  }
  return void 0;
}
var VERSION5, anthropicErrorDataSchema, anthropicFailedResponseHandler, anthropicMessagesResponseSchema, anthropicMessagesChunkSchema, anthropicReasoningMetadataSchema, anthropicFilePartProviderOptions, anthropicProviderOptions, MAX_CACHE_BREAKPOINTS, CacheControlValidator, textEditor_20250728ArgsSchema, textEditor_20250728InputSchema, factory, textEditor_20250728, webSearch_20250305ArgsSchema, webSearch_20250305OutputSchema, webSearch_20250305InputSchema, factory2, webSearch_20250305, webFetch_20250910ArgsSchema, webFetch_20250910OutputSchema, webFetch_20250910InputSchema, factory3, webFetch_20250910, codeExecution_20250522OutputSchema, codeExecution_20250522InputSchema, factory4, codeExecution_20250522, codeExecution_20250825OutputSchema, codeExecution_20250825InputSchema, factory5, codeExecution_20250825, toolSearchRegex_20251119OutputSchema, toolSearchRegex_20251119InputSchema, factory6, toolSearchRegex_20251119, AnthropicMessagesLanguageModel, bash_20241022InputSchema, bash_20241022, bash_20250124InputSchema, bash_20250124, computer_20241022InputSchema, computer_20241022, computer_20250124InputSchema, computer_20250124, computer_20251124InputSchema, computer_20251124, memory_20250818InputSchema, memory_20250818, textEditor_20241022InputSchema, textEditor_20241022, textEditor_20250124InputSchema, textEditor_20250124, textEditor_20250429InputSchema, textEditor_20250429, toolSearchBm25_20251119OutputSchema, toolSearchBm25_20251119InputSchema, factory7, toolSearchBm25_20251119, anthropicTools, anthropic;
var init_dist11 = __esm({
  "node_modules/@ai-sdk/anthropic/dist/index.mjs"() {
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    VERSION5 = true ? "3.0.37" : "0.0.0-test";
    anthropicErrorDataSchema = lazySchema(
      () => zodSchema(
        z18.object({
          type: z18.literal("error"),
          error: z18.object({
            type: z18.string(),
            message: z18.string()
          })
        })
      )
    );
    anthropicFailedResponseHandler = createJsonErrorResponseHandler({
      errorSchema: anthropicErrorDataSchema,
      errorToMessage: (data) => data.error.message
    });
    anthropicMessagesResponseSchema = lazySchema(
      () => zodSchema(
        z24.object({
          type: z24.literal("message"),
          id: z24.string().nullish(),
          model: z24.string().nullish(),
          content: z24.array(
            z24.discriminatedUnion("type", [
              z24.object({
                type: z24.literal("text"),
                text: z24.string(),
                citations: z24.array(
                  z24.discriminatedUnion("type", [
                    z24.object({
                      type: z24.literal("web_search_result_location"),
                      cited_text: z24.string(),
                      url: z24.string(),
                      title: z24.string(),
                      encrypted_index: z24.string()
                    }),
                    z24.object({
                      type: z24.literal("page_location"),
                      cited_text: z24.string(),
                      document_index: z24.number(),
                      document_title: z24.string().nullable(),
                      start_page_number: z24.number(),
                      end_page_number: z24.number()
                    }),
                    z24.object({
                      type: z24.literal("char_location"),
                      cited_text: z24.string(),
                      document_index: z24.number(),
                      document_title: z24.string().nullable(),
                      start_char_index: z24.number(),
                      end_char_index: z24.number()
                    })
                  ])
                ).optional()
              }),
              z24.object({
                type: z24.literal("thinking"),
                thinking: z24.string(),
                signature: z24.string()
              }),
              z24.object({
                type: z24.literal("redacted_thinking"),
                data: z24.string()
              }),
              z24.object({
                type: z24.literal("tool_use"),
                id: z24.string(),
                name: z24.string(),
                input: z24.unknown(),
                // Programmatic tool calling: caller info when triggered from code execution
                caller: z24.union([
                  z24.object({
                    type: z24.literal("code_execution_20250825"),
                    tool_id: z24.string()
                  }),
                  z24.object({
                    type: z24.literal("direct")
                  })
                ]).optional()
              }),
              z24.object({
                type: z24.literal("server_tool_use"),
                id: z24.string(),
                name: z24.string(),
                input: z24.record(z24.string(), z24.unknown()).nullish()
              }),
              z24.object({
                type: z24.literal("mcp_tool_use"),
                id: z24.string(),
                name: z24.string(),
                input: z24.unknown(),
                server_name: z24.string()
              }),
              z24.object({
                type: z24.literal("mcp_tool_result"),
                tool_use_id: z24.string(),
                is_error: z24.boolean(),
                content: z24.array(
                  z24.union([
                    z24.string(),
                    z24.object({ type: z24.literal("text"), text: z24.string() })
                  ])
                )
              }),
              z24.object({
                type: z24.literal("web_fetch_tool_result"),
                tool_use_id: z24.string(),
                content: z24.union([
                  z24.object({
                    type: z24.literal("web_fetch_result"),
                    url: z24.string(),
                    retrieved_at: z24.string(),
                    content: z24.object({
                      type: z24.literal("document"),
                      title: z24.string().nullable(),
                      citations: z24.object({ enabled: z24.boolean() }).optional(),
                      source: z24.union([
                        z24.object({
                          type: z24.literal("base64"),
                          media_type: z24.literal("application/pdf"),
                          data: z24.string()
                        }),
                        z24.object({
                          type: z24.literal("text"),
                          media_type: z24.literal("text/plain"),
                          data: z24.string()
                        })
                      ])
                    })
                  }),
                  z24.object({
                    type: z24.literal("web_fetch_tool_result_error"),
                    error_code: z24.string()
                  })
                ])
              }),
              z24.object({
                type: z24.literal("web_search_tool_result"),
                tool_use_id: z24.string(),
                content: z24.union([
                  z24.array(
                    z24.object({
                      type: z24.literal("web_search_result"),
                      url: z24.string(),
                      title: z24.string(),
                      encrypted_content: z24.string(),
                      page_age: z24.string().nullish()
                    })
                  ),
                  z24.object({
                    type: z24.literal("web_search_tool_result_error"),
                    error_code: z24.string()
                  })
                ])
              }),
              // code execution results for code_execution_20250522 tool:
              z24.object({
                type: z24.literal("code_execution_tool_result"),
                tool_use_id: z24.string(),
                content: z24.union([
                  z24.object({
                    type: z24.literal("code_execution_result"),
                    stdout: z24.string(),
                    stderr: z24.string(),
                    return_code: z24.number(),
                    content: z24.array(
                      z24.object({
                        type: z24.literal("code_execution_output"),
                        file_id: z24.string()
                      })
                    ).optional().default([])
                  }),
                  z24.object({
                    type: z24.literal("code_execution_tool_result_error"),
                    error_code: z24.string()
                  })
                ])
              }),
              // bash code execution results for code_execution_20250825 tool:
              z24.object({
                type: z24.literal("bash_code_execution_tool_result"),
                tool_use_id: z24.string(),
                content: z24.discriminatedUnion("type", [
                  z24.object({
                    type: z24.literal("bash_code_execution_result"),
                    content: z24.array(
                      z24.object({
                        type: z24.literal("bash_code_execution_output"),
                        file_id: z24.string()
                      })
                    ),
                    stdout: z24.string(),
                    stderr: z24.string(),
                    return_code: z24.number()
                  }),
                  z24.object({
                    type: z24.literal("bash_code_execution_tool_result_error"),
                    error_code: z24.string()
                  })
                ])
              }),
              // text editor code execution results for code_execution_20250825 tool:
              z24.object({
                type: z24.literal("text_editor_code_execution_tool_result"),
                tool_use_id: z24.string(),
                content: z24.discriminatedUnion("type", [
                  z24.object({
                    type: z24.literal("text_editor_code_execution_tool_result_error"),
                    error_code: z24.string()
                  }),
                  z24.object({
                    type: z24.literal("text_editor_code_execution_view_result"),
                    content: z24.string(),
                    file_type: z24.string(),
                    num_lines: z24.number().nullable(),
                    start_line: z24.number().nullable(),
                    total_lines: z24.number().nullable()
                  }),
                  z24.object({
                    type: z24.literal("text_editor_code_execution_create_result"),
                    is_file_update: z24.boolean()
                  }),
                  z24.object({
                    type: z24.literal(
                      "text_editor_code_execution_str_replace_result"
                    ),
                    lines: z24.array(z24.string()).nullable(),
                    new_lines: z24.number().nullable(),
                    new_start: z24.number().nullable(),
                    old_lines: z24.number().nullable(),
                    old_start: z24.number().nullable()
                  })
                ])
              }),
              // tool search tool results for tool_search_tool_regex_20251119 and tool_search_tool_bm25_20251119:
              z24.object({
                type: z24.literal("tool_search_tool_result"),
                tool_use_id: z24.string(),
                content: z24.union([
                  z24.object({
                    type: z24.literal("tool_search_tool_search_result"),
                    tool_references: z24.array(
                      z24.object({
                        type: z24.literal("tool_reference"),
                        tool_name: z24.string()
                      })
                    )
                  }),
                  z24.object({
                    type: z24.literal("tool_search_tool_result_error"),
                    error_code: z24.string()
                  })
                ])
              })
            ])
          ),
          stop_reason: z24.string().nullish(),
          stop_sequence: z24.string().nullish(),
          usage: z24.looseObject({
            input_tokens: z24.number(),
            output_tokens: z24.number(),
            cache_creation_input_tokens: z24.number().nullish(),
            cache_read_input_tokens: z24.number().nullish()
          }),
          container: z24.object({
            expires_at: z24.string(),
            id: z24.string(),
            skills: z24.array(
              z24.object({
                type: z24.union([z24.literal("anthropic"), z24.literal("custom")]),
                skill_id: z24.string(),
                version: z24.string()
              })
            ).nullish()
          }).nullish(),
          context_management: z24.object({
            applied_edits: z24.array(
              z24.union([
                z24.object({
                  type: z24.literal("clear_tool_uses_20250919"),
                  cleared_tool_uses: z24.number(),
                  cleared_input_tokens: z24.number()
                }),
                z24.object({
                  type: z24.literal("clear_thinking_20251015"),
                  cleared_thinking_turns: z24.number(),
                  cleared_input_tokens: z24.number()
                })
              ])
            )
          }).nullish()
        })
      )
    );
    anthropicMessagesChunkSchema = lazySchema(
      () => zodSchema(
        z24.discriminatedUnion("type", [
          z24.object({
            type: z24.literal("message_start"),
            message: z24.object({
              id: z24.string().nullish(),
              model: z24.string().nullish(),
              role: z24.string().nullish(),
              usage: z24.looseObject({
                input_tokens: z24.number(),
                cache_creation_input_tokens: z24.number().nullish(),
                cache_read_input_tokens: z24.number().nullish()
              }),
              // Programmatic tool calling: content may be pre-populated for deferred tool calls
              content: z24.array(
                z24.discriminatedUnion("type", [
                  z24.object({
                    type: z24.literal("tool_use"),
                    id: z24.string(),
                    name: z24.string(),
                    input: z24.unknown(),
                    caller: z24.union([
                      z24.object({
                        type: z24.literal("code_execution_20250825"),
                        tool_id: z24.string()
                      }),
                      z24.object({
                        type: z24.literal("direct")
                      })
                    ]).optional()
                  })
                ])
              ).nullish(),
              stop_reason: z24.string().nullish(),
              container: z24.object({
                expires_at: z24.string(),
                id: z24.string()
              }).nullish()
            })
          }),
          z24.object({
            type: z24.literal("content_block_start"),
            index: z24.number(),
            content_block: z24.discriminatedUnion("type", [
              z24.object({
                type: z24.literal("text"),
                text: z24.string()
              }),
              z24.object({
                type: z24.literal("thinking"),
                thinking: z24.string()
              }),
              z24.object({
                type: z24.literal("tool_use"),
                id: z24.string(),
                name: z24.string(),
                // Programmatic tool calling: input may be present directly for deferred tool calls
                input: z24.record(z24.string(), z24.unknown()).optional(),
                // Programmatic tool calling: caller info when triggered from code execution
                caller: z24.union([
                  z24.object({
                    type: z24.literal("code_execution_20250825"),
                    tool_id: z24.string()
                  }),
                  z24.object({
                    type: z24.literal("direct")
                  })
                ]).optional()
              }),
              z24.object({
                type: z24.literal("redacted_thinking"),
                data: z24.string()
              }),
              z24.object({
                type: z24.literal("server_tool_use"),
                id: z24.string(),
                name: z24.string(),
                input: z24.record(z24.string(), z24.unknown()).nullish()
              }),
              z24.object({
                type: z24.literal("mcp_tool_use"),
                id: z24.string(),
                name: z24.string(),
                input: z24.unknown(),
                server_name: z24.string()
              }),
              z24.object({
                type: z24.literal("mcp_tool_result"),
                tool_use_id: z24.string(),
                is_error: z24.boolean(),
                content: z24.array(
                  z24.union([
                    z24.string(),
                    z24.object({ type: z24.literal("text"), text: z24.string() })
                  ])
                )
              }),
              z24.object({
                type: z24.literal("web_fetch_tool_result"),
                tool_use_id: z24.string(),
                content: z24.union([
                  z24.object({
                    type: z24.literal("web_fetch_result"),
                    url: z24.string(),
                    retrieved_at: z24.string(),
                    content: z24.object({
                      type: z24.literal("document"),
                      title: z24.string().nullable(),
                      citations: z24.object({ enabled: z24.boolean() }).optional(),
                      source: z24.union([
                        z24.object({
                          type: z24.literal("base64"),
                          media_type: z24.literal("application/pdf"),
                          data: z24.string()
                        }),
                        z24.object({
                          type: z24.literal("text"),
                          media_type: z24.literal("text/plain"),
                          data: z24.string()
                        })
                      ])
                    })
                  }),
                  z24.object({
                    type: z24.literal("web_fetch_tool_result_error"),
                    error_code: z24.string()
                  })
                ])
              }),
              z24.object({
                type: z24.literal("web_search_tool_result"),
                tool_use_id: z24.string(),
                content: z24.union([
                  z24.array(
                    z24.object({
                      type: z24.literal("web_search_result"),
                      url: z24.string(),
                      title: z24.string(),
                      encrypted_content: z24.string(),
                      page_age: z24.string().nullish()
                    })
                  ),
                  z24.object({
                    type: z24.literal("web_search_tool_result_error"),
                    error_code: z24.string()
                  })
                ])
              }),
              // code execution results for code_execution_20250522 tool:
              z24.object({
                type: z24.literal("code_execution_tool_result"),
                tool_use_id: z24.string(),
                content: z24.union([
                  z24.object({
                    type: z24.literal("code_execution_result"),
                    stdout: z24.string(),
                    stderr: z24.string(),
                    return_code: z24.number(),
                    content: z24.array(
                      z24.object({
                        type: z24.literal("code_execution_output"),
                        file_id: z24.string()
                      })
                    ).optional().default([])
                  }),
                  z24.object({
                    type: z24.literal("code_execution_tool_result_error"),
                    error_code: z24.string()
                  })
                ])
              }),
              // bash code execution results for code_execution_20250825 tool:
              z24.object({
                type: z24.literal("bash_code_execution_tool_result"),
                tool_use_id: z24.string(),
                content: z24.discriminatedUnion("type", [
                  z24.object({
                    type: z24.literal("bash_code_execution_result"),
                    content: z24.array(
                      z24.object({
                        type: z24.literal("bash_code_execution_output"),
                        file_id: z24.string()
                      })
                    ),
                    stdout: z24.string(),
                    stderr: z24.string(),
                    return_code: z24.number()
                  }),
                  z24.object({
                    type: z24.literal("bash_code_execution_tool_result_error"),
                    error_code: z24.string()
                  })
                ])
              }),
              // text editor code execution results for code_execution_20250825 tool:
              z24.object({
                type: z24.literal("text_editor_code_execution_tool_result"),
                tool_use_id: z24.string(),
                content: z24.discriminatedUnion("type", [
                  z24.object({
                    type: z24.literal("text_editor_code_execution_tool_result_error"),
                    error_code: z24.string()
                  }),
                  z24.object({
                    type: z24.literal("text_editor_code_execution_view_result"),
                    content: z24.string(),
                    file_type: z24.string(),
                    num_lines: z24.number().nullable(),
                    start_line: z24.number().nullable(),
                    total_lines: z24.number().nullable()
                  }),
                  z24.object({
                    type: z24.literal("text_editor_code_execution_create_result"),
                    is_file_update: z24.boolean()
                  }),
                  z24.object({
                    type: z24.literal(
                      "text_editor_code_execution_str_replace_result"
                    ),
                    lines: z24.array(z24.string()).nullable(),
                    new_lines: z24.number().nullable(),
                    new_start: z24.number().nullable(),
                    old_lines: z24.number().nullable(),
                    old_start: z24.number().nullable()
                  })
                ])
              }),
              // tool search tool results for tool_search_tool_regex_20251119 and tool_search_tool_bm25_20251119:
              z24.object({
                type: z24.literal("tool_search_tool_result"),
                tool_use_id: z24.string(),
                content: z24.union([
                  z24.object({
                    type: z24.literal("tool_search_tool_search_result"),
                    tool_references: z24.array(
                      z24.object({
                        type: z24.literal("tool_reference"),
                        tool_name: z24.string()
                      })
                    )
                  }),
                  z24.object({
                    type: z24.literal("tool_search_tool_result_error"),
                    error_code: z24.string()
                  })
                ])
              })
            ])
          }),
          z24.object({
            type: z24.literal("content_block_delta"),
            index: z24.number(),
            delta: z24.discriminatedUnion("type", [
              z24.object({
                type: z24.literal("input_json_delta"),
                partial_json: z24.string()
              }),
              z24.object({
                type: z24.literal("text_delta"),
                text: z24.string()
              }),
              z24.object({
                type: z24.literal("thinking_delta"),
                thinking: z24.string()
              }),
              z24.object({
                type: z24.literal("signature_delta"),
                signature: z24.string()
              }),
              z24.object({
                type: z24.literal("citations_delta"),
                citation: z24.discriminatedUnion("type", [
                  z24.object({
                    type: z24.literal("web_search_result_location"),
                    cited_text: z24.string(),
                    url: z24.string(),
                    title: z24.string(),
                    encrypted_index: z24.string()
                  }),
                  z24.object({
                    type: z24.literal("page_location"),
                    cited_text: z24.string(),
                    document_index: z24.number(),
                    document_title: z24.string().nullable(),
                    start_page_number: z24.number(),
                    end_page_number: z24.number()
                  }),
                  z24.object({
                    type: z24.literal("char_location"),
                    cited_text: z24.string(),
                    document_index: z24.number(),
                    document_title: z24.string().nullable(),
                    start_char_index: z24.number(),
                    end_char_index: z24.number()
                  })
                ])
              })
            ])
          }),
          z24.object({
            type: z24.literal("content_block_stop"),
            index: z24.number()
          }),
          z24.object({
            type: z24.literal("error"),
            error: z24.object({
              type: z24.string(),
              message: z24.string()
            })
          }),
          z24.object({
            type: z24.literal("message_delta"),
            delta: z24.object({
              stop_reason: z24.string().nullish(),
              stop_sequence: z24.string().nullish(),
              container: z24.object({
                expires_at: z24.string(),
                id: z24.string(),
                skills: z24.array(
                  z24.object({
                    type: z24.union([
                      z24.literal("anthropic"),
                      z24.literal("custom")
                    ]),
                    skill_id: z24.string(),
                    version: z24.string()
                  })
                ).nullish()
              }).nullish()
            }),
            usage: z24.looseObject({
              input_tokens: z24.number().nullish(),
              output_tokens: z24.number(),
              cache_creation_input_tokens: z24.number().nullish(),
              cache_read_input_tokens: z24.number().nullish()
            }),
            context_management: z24.object({
              applied_edits: z24.array(
                z24.union([
                  z24.object({
                    type: z24.literal("clear_tool_uses_20250919"),
                    cleared_tool_uses: z24.number(),
                    cleared_input_tokens: z24.number()
                  }),
                  z24.object({
                    type: z24.literal("clear_thinking_20251015"),
                    cleared_thinking_turns: z24.number(),
                    cleared_input_tokens: z24.number()
                  })
                ])
              )
            }).nullish()
          }),
          z24.object({
            type: z24.literal("message_stop")
          }),
          z24.object({
            type: z24.literal("ping")
          })
        ])
      )
    );
    anthropicReasoningMetadataSchema = lazySchema(
      () => zodSchema(
        z24.object({
          signature: z24.string().optional(),
          redactedData: z24.string().optional()
        })
      )
    );
    anthropicFilePartProviderOptions = z34.object({
      /**
       * Citation configuration for this document.
       * When enabled, this document will generate citations in the response.
       */
      citations: z34.object({
        /**
         * Enable citations for this document
         */
        enabled: z34.boolean()
      }).optional(),
      /**
       * Custom title for the document.
       * If not provided, the filename will be used.
       */
      title: z34.string().optional(),
      /**
       * Context about the document that will be passed to the model
       * but not used towards cited content.
       * Useful for storing document metadata as text or stringified JSON.
       */
      context: z34.string().optional()
    });
    anthropicProviderOptions = z34.object({
      /**
       * Whether to send reasoning to the model.
       *
       * This allows you to deactivate reasoning inputs for models that do not support them.
       */
      sendReasoning: z34.boolean().optional(),
      /**
       * Determines how structured outputs are generated.
       *
       * - `outputFormat`: Use the `output_format` parameter to specify the structured output format.
       * - `jsonTool`: Use a special 'json' tool to specify the structured output format.
       * - `auto`: Use 'outputFormat' when supported, otherwise use 'jsonTool' (default).
       */
      structuredOutputMode: z34.enum(["outputFormat", "jsonTool", "auto"]).optional(),
      /**
       * Configuration for enabling Claude's extended thinking.
       *
       * When enabled, responses include thinking content blocks showing Claude's thinking process before the final answer.
       * Requires a minimum budget of 1,024 tokens and counts towards the `max_tokens` limit.
       */
      thinking: z34.discriminatedUnion("type", [
        z34.object({
          /** for Opus 4.6 and newer models */
          type: z34.literal("adaptive")
        }),
        z34.object({
          /** for models before Opus 4.6 */
          type: z34.literal("enabled"),
          budgetTokens: z34.number().optional()
        }),
        z34.object({
          type: z34.literal("disabled")
        })
      ]).optional(),
      /**
       * Whether to disable parallel function calling during tool use. Default is false.
       * When set to true, Claude will use at most one tool per response.
       */
      disableParallelToolUse: z34.boolean().optional(),
      /**
       * Cache control settings for this message.
       * See https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching
       */
      cacheControl: z34.object({
        type: z34.literal("ephemeral"),
        ttl: z34.union([z34.literal("5m"), z34.literal("1h")]).optional()
      }).optional(),
      /**
       * MCP servers to be utilized in this request.
       */
      mcpServers: z34.array(
        z34.object({
          type: z34.literal("url"),
          name: z34.string(),
          url: z34.string(),
          authorizationToken: z34.string().nullish(),
          toolConfiguration: z34.object({
            enabled: z34.boolean().nullish(),
            allowedTools: z34.array(z34.string()).nullish()
          }).nullish()
        })
      ).optional(),
      /**
       * Agent Skills configuration. Skills enable Claude to perform specialized tasks
       * like document processing (PPTX, DOCX, PDF, XLSX) and data analysis.
       * Requires code execution tool to be enabled.
       */
      container: z34.object({
        id: z34.string().optional(),
        skills: z34.array(
          z34.object({
            type: z34.union([z34.literal("anthropic"), z34.literal("custom")]),
            skillId: z34.string(),
            version: z34.string().optional()
          })
        ).optional()
      }).optional(),
      /**
       * Whether to enable tool streaming (and structured output streaming).
       *
       * When set to false, the model will return all tool calls and results
       * at once after a delay.
       *
       * @default true
       */
      toolStreaming: z34.boolean().optional(),
      /**
       * @default 'high'
       */
      effort: z34.enum(["low", "medium", "high", "max"]).optional(),
      contextManagement: z34.object({
        edits: z34.array(
          z34.discriminatedUnion("type", [
            z34.object({
              type: z34.literal("clear_tool_uses_20250919"),
              trigger: z34.discriminatedUnion("type", [
                z34.object({
                  type: z34.literal("input_tokens"),
                  value: z34.number()
                }),
                z34.object({
                  type: z34.literal("tool_uses"),
                  value: z34.number()
                })
              ]).optional(),
              keep: z34.object({
                type: z34.literal("tool_uses"),
                value: z34.number()
              }).optional(),
              clearAtLeast: z34.object({
                type: z34.literal("input_tokens"),
                value: z34.number()
              }).optional(),
              clearToolInputs: z34.boolean().optional(),
              excludeTools: z34.array(z34.string()).optional()
            }),
            z34.object({
              type: z34.literal("clear_thinking_20251015"),
              keep: z34.union([
                z34.literal("all"),
                z34.object({
                  type: z34.literal("thinking_turns"),
                  value: z34.number()
                })
              ]).optional()
            })
          ])
        )
      }).optional()
    });
    MAX_CACHE_BREAKPOINTS = 4;
    CacheControlValidator = class {
      constructor() {
        this.breakpointCount = 0;
        this.warnings = [];
      }
      getCacheControl(providerMetadata, context2) {
        const cacheControlValue = getCacheControl(providerMetadata);
        if (!cacheControlValue) {
          return void 0;
        }
        if (!context2.canCache) {
          this.warnings.push({
            type: "unsupported",
            feature: "cache_control on non-cacheable context",
            details: `cache_control cannot be set on ${context2.type}. It will be ignored.`
          });
          return void 0;
        }
        this.breakpointCount++;
        if (this.breakpointCount > MAX_CACHE_BREAKPOINTS) {
          this.warnings.push({
            type: "unsupported",
            feature: "cacheControl breakpoint limit",
            details: `Maximum ${MAX_CACHE_BREAKPOINTS} cache breakpoints exceeded (found ${this.breakpointCount}). This breakpoint will be ignored.`
          });
          return void 0;
        }
        return cacheControlValue;
      }
      getWarnings() {
        return this.warnings;
      }
    };
    textEditor_20250728ArgsSchema = lazySchema(
      () => zodSchema(
        z45.object({
          maxCharacters: z45.number().optional()
        })
      )
    );
    textEditor_20250728InputSchema = lazySchema(
      () => zodSchema(
        z45.object({
          command: z45.enum(["view", "create", "str_replace", "insert"]),
          path: z45.string(),
          file_text: z45.string().optional(),
          insert_line: z45.number().int().optional(),
          new_str: z45.string().optional(),
          insert_text: z45.string().optional(),
          old_str: z45.string().optional(),
          view_range: z45.array(z45.number().int()).optional()
        })
      )
    );
    factory = createProviderToolFactory({
      id: "anthropic.text_editor_20250728",
      inputSchema: textEditor_20250728InputSchema
    });
    textEditor_20250728 = (args2 = {}) => {
      return factory(args2);
    };
    webSearch_20250305ArgsSchema = lazySchema(
      () => zodSchema(
        z54.object({
          maxUses: z54.number().optional(),
          allowedDomains: z54.array(z54.string()).optional(),
          blockedDomains: z54.array(z54.string()).optional(),
          userLocation: z54.object({
            type: z54.literal("approximate"),
            city: z54.string().optional(),
            region: z54.string().optional(),
            country: z54.string().optional(),
            timezone: z54.string().optional()
          }).optional()
        })
      )
    );
    webSearch_20250305OutputSchema = lazySchema(
      () => zodSchema(
        z54.array(
          z54.object({
            url: z54.string(),
            title: z54.string().nullable(),
            pageAge: z54.string().nullable(),
            encryptedContent: z54.string(),
            type: z54.literal("web_search_result")
          })
        )
      )
    );
    webSearch_20250305InputSchema = lazySchema(
      () => zodSchema(
        z54.object({
          query: z54.string()
        })
      )
    );
    factory2 = createProviderToolFactoryWithOutputSchema({
      id: "anthropic.web_search_20250305",
      inputSchema: webSearch_20250305InputSchema,
      outputSchema: webSearch_20250305OutputSchema,
      supportsDeferredResults: true
    });
    webSearch_20250305 = (args2 = {}) => {
      return factory2(args2);
    };
    webFetch_20250910ArgsSchema = lazySchema(
      () => zodSchema(
        z64.object({
          maxUses: z64.number().optional(),
          allowedDomains: z64.array(z64.string()).optional(),
          blockedDomains: z64.array(z64.string()).optional(),
          citations: z64.object({ enabled: z64.boolean() }).optional(),
          maxContentTokens: z64.number().optional()
        })
      )
    );
    webFetch_20250910OutputSchema = lazySchema(
      () => zodSchema(
        z64.object({
          type: z64.literal("web_fetch_result"),
          url: z64.string(),
          content: z64.object({
            type: z64.literal("document"),
            title: z64.string().nullable(),
            citations: z64.object({ enabled: z64.boolean() }).optional(),
            source: z64.union([
              z64.object({
                type: z64.literal("base64"),
                mediaType: z64.literal("application/pdf"),
                data: z64.string()
              }),
              z64.object({
                type: z64.literal("text"),
                mediaType: z64.literal("text/plain"),
                data: z64.string()
              })
            ])
          }),
          retrievedAt: z64.string().nullable()
        })
      )
    );
    webFetch_20250910InputSchema = lazySchema(
      () => zodSchema(
        z64.object({
          url: z64.string()
        })
      )
    );
    factory3 = createProviderToolFactoryWithOutputSchema({
      id: "anthropic.web_fetch_20250910",
      inputSchema: webFetch_20250910InputSchema,
      outputSchema: webFetch_20250910OutputSchema,
      supportsDeferredResults: true
    });
    webFetch_20250910 = (args2 = {}) => {
      return factory3(args2);
    };
    codeExecution_20250522OutputSchema = lazySchema(
      () => zodSchema(
        z74.object({
          type: z74.literal("code_execution_result"),
          stdout: z74.string(),
          stderr: z74.string(),
          return_code: z74.number(),
          content: z74.array(
            z74.object({
              type: z74.literal("code_execution_output"),
              file_id: z74.string()
            })
          ).optional().default([])
        })
      )
    );
    codeExecution_20250522InputSchema = lazySchema(
      () => zodSchema(
        z74.object({
          code: z74.string()
        })
      )
    );
    factory4 = createProviderToolFactoryWithOutputSchema({
      id: "anthropic.code_execution_20250522",
      inputSchema: codeExecution_20250522InputSchema,
      outputSchema: codeExecution_20250522OutputSchema
    });
    codeExecution_20250522 = (args2 = {}) => {
      return factory4(args2);
    };
    codeExecution_20250825OutputSchema = lazySchema(
      () => zodSchema(
        z84.discriminatedUnion("type", [
          z84.object({
            type: z84.literal("code_execution_result"),
            stdout: z84.string(),
            stderr: z84.string(),
            return_code: z84.number(),
            content: z84.array(
              z84.object({
                type: z84.literal("code_execution_output"),
                file_id: z84.string()
              })
            ).optional().default([])
          }),
          z84.object({
            type: z84.literal("bash_code_execution_result"),
            content: z84.array(
              z84.object({
                type: z84.literal("bash_code_execution_output"),
                file_id: z84.string()
              })
            ),
            stdout: z84.string(),
            stderr: z84.string(),
            return_code: z84.number()
          }),
          z84.object({
            type: z84.literal("bash_code_execution_tool_result_error"),
            error_code: z84.string()
          }),
          z84.object({
            type: z84.literal("text_editor_code_execution_tool_result_error"),
            error_code: z84.string()
          }),
          z84.object({
            type: z84.literal("text_editor_code_execution_view_result"),
            content: z84.string(),
            file_type: z84.string(),
            num_lines: z84.number().nullable(),
            start_line: z84.number().nullable(),
            total_lines: z84.number().nullable()
          }),
          z84.object({
            type: z84.literal("text_editor_code_execution_create_result"),
            is_file_update: z84.boolean()
          }),
          z84.object({
            type: z84.literal("text_editor_code_execution_str_replace_result"),
            lines: z84.array(z84.string()).nullable(),
            new_lines: z84.number().nullable(),
            new_start: z84.number().nullable(),
            old_lines: z84.number().nullable(),
            old_start: z84.number().nullable()
          })
        ])
      )
    );
    codeExecution_20250825InputSchema = lazySchema(
      () => zodSchema(
        z84.discriminatedUnion("type", [
          // Programmatic tool calling format (mapped from { code } by AI SDK)
          z84.object({
            type: z84.literal("programmatic-tool-call"),
            code: z84.string()
          }),
          z84.object({
            type: z84.literal("bash_code_execution"),
            command: z84.string()
          }),
          z84.discriminatedUnion("command", [
            z84.object({
              type: z84.literal("text_editor_code_execution"),
              command: z84.literal("view"),
              path: z84.string()
            }),
            z84.object({
              type: z84.literal("text_editor_code_execution"),
              command: z84.literal("create"),
              path: z84.string(),
              file_text: z84.string().nullish()
            }),
            z84.object({
              type: z84.literal("text_editor_code_execution"),
              command: z84.literal("str_replace"),
              path: z84.string(),
              old_str: z84.string(),
              new_str: z84.string()
            })
          ])
        ])
      )
    );
    factory5 = createProviderToolFactoryWithOutputSchema({
      id: "anthropic.code_execution_20250825",
      inputSchema: codeExecution_20250825InputSchema,
      outputSchema: codeExecution_20250825OutputSchema,
      // Programmatic tool calling: tool results may be deferred to a later turn
      // when code execution triggers a client-executed tool that needs to be
      // resolved before the code execution result can be returned.
      supportsDeferredResults: true
    });
    codeExecution_20250825 = (args2 = {}) => {
      return factory5(args2);
    };
    toolSearchRegex_20251119OutputSchema = lazySchema(
      () => zodSchema(
        z93.array(
          z93.object({
            type: z93.literal("tool_reference"),
            toolName: z93.string()
          })
        )
      )
    );
    toolSearchRegex_20251119InputSchema = lazySchema(
      () => zodSchema(
        z93.object({
          /**
           * A regex pattern to search for tools.
           * Uses Python re.search() syntax. Maximum 200 characters.
           *
           * Examples:
           * - "weather" - matches tool names/descriptions containing "weather"
           * - "get_.*_data" - matches tools like get_user_data, get_weather_data
           * - "database.*query|query.*database" - OR patterns for flexibility
           * - "(?i)slack" - case-insensitive search
           */
          pattern: z93.string(),
          /**
           * Maximum number of tools to return. Optional.
           */
          limit: z93.number().optional()
        })
      )
    );
    factory6 = createProviderToolFactoryWithOutputSchema({
      id: "anthropic.tool_search_regex_20251119",
      inputSchema: toolSearchRegex_20251119InputSchema,
      outputSchema: toolSearchRegex_20251119OutputSchema,
      supportsDeferredResults: true
    });
    toolSearchRegex_20251119 = (args2 = {}) => {
      return factory6(args2);
    };
    AnthropicMessagesLanguageModel = class {
      constructor(modelId, config2) {
        this.specificationVersion = "v3";
        var _a25;
        this.modelId = modelId;
        this.config = config2;
        this.generateId = (_a25 = config2.generateId) != null ? _a25 : generateId;
      }
      supportsUrl(url) {
        return url.protocol === "https:";
      }
      get provider() {
        return this.config.provider;
      }
      /**
       * Extracts the dynamic provider name from the config.provider string.
       * e.g., 'my-custom-anthropic.messages' -> 'my-custom-anthropic'
       */
      get providerOptionsName() {
        const provider = this.config.provider;
        const dotIndex = provider.indexOf(".");
        return dotIndex === -1 ? provider : provider.substring(0, dotIndex);
      }
      get supportedUrls() {
        var _a25, _b18, _c;
        return (_c = (_b18 = (_a25 = this.config).supportedUrls) == null ? void 0 : _b18.call(_a25)) != null ? _c : {};
      }
      async getArgs({
        userSuppliedBetas,
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        stopSequences,
        responseFormat,
        seed,
        tools,
        toolChoice,
        providerOptions,
        stream
      }) {
        var _a25, _b18, _c, _d, _e, _f;
        const warnings = [];
        if (frequencyPenalty != null) {
          warnings.push({ type: "unsupported", feature: "frequencyPenalty" });
        }
        if (presencePenalty != null) {
          warnings.push({ type: "unsupported", feature: "presencePenalty" });
        }
        if (seed != null) {
          warnings.push({ type: "unsupported", feature: "seed" });
        }
        if (temperature != null && temperature > 1) {
          warnings.push({
            type: "unsupported",
            feature: "temperature",
            details: `${temperature} exceeds anthropic maximum of 1.0. clamped to 1.0`
          });
          temperature = 1;
        } else if (temperature != null && temperature < 0) {
          warnings.push({
            type: "unsupported",
            feature: "temperature",
            details: `${temperature} is below anthropic minimum of 0. clamped to 0`
          });
          temperature = 0;
        }
        if ((responseFormat == null ? void 0 : responseFormat.type) === "json") {
          if (responseFormat.schema == null) {
            warnings.push({
              type: "unsupported",
              feature: "responseFormat",
              details: "JSON response format requires a schema. The response format is ignored."
            });
          }
        }
        const providerOptionsName = this.providerOptionsName;
        const canonicalOptions = await parseProviderOptions({
          provider: "anthropic",
          providerOptions,
          schema: anthropicProviderOptions
        });
        const customProviderOptions = providerOptionsName !== "anthropic" ? await parseProviderOptions({
          provider: providerOptionsName,
          providerOptions,
          schema: anthropicProviderOptions
        }) : null;
        const usedCustomProviderKey = customProviderOptions != null;
        const anthropicOptions = Object.assign(
          {},
          canonicalOptions != null ? canonicalOptions : {},
          customProviderOptions != null ? customProviderOptions : {}
        );
        const {
          maxOutputTokens: maxOutputTokensForModel,
          supportsStructuredOutput: modelSupportsStructuredOutput,
          isKnownModel
        } = getModelCapabilities(this.modelId);
        const supportsStructuredOutput = ((_a25 = this.config.supportsNativeStructuredOutput) != null ? _a25 : true) && modelSupportsStructuredOutput;
        const structureOutputMode = (_b18 = anthropicOptions == null ? void 0 : anthropicOptions.structuredOutputMode) != null ? _b18 : "auto";
        const useStructuredOutput = structureOutputMode === "outputFormat" || structureOutputMode === "auto" && supportsStructuredOutput;
        const jsonResponseTool = (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !useStructuredOutput ? {
          type: "function",
          name: "json",
          description: "Respond with a JSON object.",
          inputSchema: responseFormat.schema
        } : void 0;
        const contextManagement = anthropicOptions == null ? void 0 : anthropicOptions.contextManagement;
        const cacheControlValidator = new CacheControlValidator();
        const toolNameMapping = createToolNameMapping({
          tools,
          providerToolNames: {
            "anthropic.code_execution_20250522": "code_execution",
            "anthropic.code_execution_20250825": "code_execution",
            "anthropic.computer_20241022": "computer",
            "anthropic.computer_20250124": "computer",
            "anthropic.text_editor_20241022": "str_replace_editor",
            "anthropic.text_editor_20250124": "str_replace_editor",
            "anthropic.text_editor_20250429": "str_replace_based_edit_tool",
            "anthropic.text_editor_20250728": "str_replace_based_edit_tool",
            "anthropic.bash_20241022": "bash",
            "anthropic.bash_20250124": "bash",
            "anthropic.memory_20250818": "memory",
            "anthropic.web_search_20250305": "web_search",
            "anthropic.web_fetch_20250910": "web_fetch",
            "anthropic.tool_search_regex_20251119": "tool_search_tool_regex",
            "anthropic.tool_search_bm25_20251119": "tool_search_tool_bm25"
          }
        });
        const { prompt: messagesPrompt, betas } = await convertToAnthropicMessagesPrompt({
          prompt,
          sendReasoning: (_c = anthropicOptions == null ? void 0 : anthropicOptions.sendReasoning) != null ? _c : true,
          warnings,
          cacheControlValidator,
          toolNameMapping
        });
        const thinkingType = (_d = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _d.type;
        const isThinking = thinkingType === "enabled" || thinkingType === "adaptive";
        let thinkingBudget = thinkingType === "enabled" ? (_e = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _e.budgetTokens : void 0;
        const maxTokens = maxOutputTokens != null ? maxOutputTokens : maxOutputTokensForModel;
        const baseArgs = {
          // model id:
          model: this.modelId,
          // standardized settings:
          max_tokens: maxTokens,
          temperature,
          top_k: topK,
          top_p: topP,
          stop_sequences: stopSequences,
          // provider specific settings:
          ...isThinking && {
            thinking: {
              type: thinkingType,
              ...thinkingBudget != null && { budget_tokens: thinkingBudget }
            }
          },
          ...(anthropicOptions == null ? void 0 : anthropicOptions.effort) && {
            output_config: { effort: anthropicOptions.effort }
          },
          // structured output:
          ...useStructuredOutput && (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && {
            output_format: {
              type: "json_schema",
              schema: responseFormat.schema
            }
          },
          // mcp servers:
          ...(anthropicOptions == null ? void 0 : anthropicOptions.mcpServers) && anthropicOptions.mcpServers.length > 0 && {
            mcp_servers: anthropicOptions.mcpServers.map((server2) => ({
              type: server2.type,
              name: server2.name,
              url: server2.url,
              authorization_token: server2.authorizationToken,
              tool_configuration: server2.toolConfiguration ? {
                allowed_tools: server2.toolConfiguration.allowedTools,
                enabled: server2.toolConfiguration.enabled
              } : void 0
            }))
          },
          // container: For programmatic tool calling (just an ID string) or agent skills (object with id and skills)
          ...(anthropicOptions == null ? void 0 : anthropicOptions.container) && {
            container: anthropicOptions.container.skills && anthropicOptions.container.skills.length > 0 ? (
              // Object format when skills are provided (agent skills feature)
              {
                id: anthropicOptions.container.id,
                skills: anthropicOptions.container.skills.map((skill) => ({
                  type: skill.type,
                  skill_id: skill.skillId,
                  version: skill.version
                }))
              }
            ) : (
              // String format for container ID only (programmatic tool calling)
              anthropicOptions.container.id
            )
          },
          // prompt:
          system: messagesPrompt.system,
          messages: messagesPrompt.messages,
          ...contextManagement && {
            context_management: {
              edits: contextManagement.edits.map((edit) => {
                const strategy = edit.type;
                switch (strategy) {
                  case "clear_tool_uses_20250919":
                    return {
                      type: edit.type,
                      ...edit.trigger !== void 0 && {
                        trigger: edit.trigger
                      },
                      ...edit.keep !== void 0 && { keep: edit.keep },
                      ...edit.clearAtLeast !== void 0 && {
                        clear_at_least: edit.clearAtLeast
                      },
                      ...edit.clearToolInputs !== void 0 && {
                        clear_tool_inputs: edit.clearToolInputs
                      },
                      ...edit.excludeTools !== void 0 && {
                        exclude_tools: edit.excludeTools
                      }
                    };
                  case "clear_thinking_20251015":
                    return {
                      type: edit.type,
                      ...edit.keep !== void 0 && { keep: edit.keep }
                    };
                  default:
                    warnings.push({
                      type: "other",
                      message: `Unknown context management strategy: ${strategy}`
                    });
                    return void 0;
                }
              }).filter((edit) => edit !== void 0)
            }
          }
        };
        if (isThinking) {
          if (thinkingType === "enabled" && thinkingBudget == null) {
            warnings.push({
              type: "compatibility",
              feature: "extended thinking",
              details: "thinking budget is required when thinking is enabled. using default budget of 1024 tokens."
            });
            baseArgs.thinking = {
              type: "enabled",
              budget_tokens: 1024
            };
            thinkingBudget = 1024;
          }
          if (baseArgs.temperature != null) {
            baseArgs.temperature = void 0;
            warnings.push({
              type: "unsupported",
              feature: "temperature",
              details: "temperature is not supported when thinking is enabled"
            });
          }
          if (topK != null) {
            baseArgs.top_k = void 0;
            warnings.push({
              type: "unsupported",
              feature: "topK",
              details: "topK is not supported when thinking is enabled"
            });
          }
          if (topP != null) {
            baseArgs.top_p = void 0;
            warnings.push({
              type: "unsupported",
              feature: "topP",
              details: "topP is not supported when thinking is enabled"
            });
          }
          baseArgs.max_tokens = maxTokens + (thinkingBudget != null ? thinkingBudget : 0);
        } else {
          if (topP != null && temperature != null) {
            warnings.push({
              type: "unsupported",
              feature: "topP",
              details: `topP is not supported when temperature is set. topP is ignored.`
            });
            baseArgs.top_p = void 0;
          }
        }
        if (isKnownModel && baseArgs.max_tokens > maxOutputTokensForModel) {
          if (maxOutputTokens != null) {
            warnings.push({
              type: "unsupported",
              feature: "maxOutputTokens",
              details: `${baseArgs.max_tokens} (maxOutputTokens + thinkingBudget) is greater than ${this.modelId} ${maxOutputTokensForModel} max output tokens. The max output tokens have been limited to ${maxOutputTokensForModel}.`
            });
          }
          baseArgs.max_tokens = maxOutputTokensForModel;
        }
        if ((anthropicOptions == null ? void 0 : anthropicOptions.mcpServers) && anthropicOptions.mcpServers.length > 0) {
          betas.add("mcp-client-2025-04-04");
        }
        if (contextManagement) {
          betas.add("context-management-2025-06-27");
        }
        if ((anthropicOptions == null ? void 0 : anthropicOptions.container) && anthropicOptions.container.skills && anthropicOptions.container.skills.length > 0) {
          betas.add("code-execution-2025-08-25");
          betas.add("skills-2025-10-02");
          betas.add("files-api-2025-04-14");
          if (!(tools == null ? void 0 : tools.some(
            (tool2) => tool2.type === "provider" && tool2.id === "anthropic.code_execution_20250825"
          ))) {
            warnings.push({
              type: "other",
              message: "code execution tool is required when using skills"
            });
          }
        }
        if (anthropicOptions == null ? void 0 : anthropicOptions.effort) {
          betas.add("effort-2025-11-24");
        }
        if (stream && ((_f = anthropicOptions == null ? void 0 : anthropicOptions.toolStreaming) != null ? _f : true)) {
          betas.add("fine-grained-tool-streaming-2025-05-14");
        }
        const usingNativeOutputFormat = useStructuredOutput && (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null;
        if (usingNativeOutputFormat) {
          betas.add("structured-outputs-2025-11-13");
        }
        const {
          tools: anthropicTools22,
          toolChoice: anthropicToolChoice,
          toolWarnings,
          betas: toolsBetas
        } = await prepareTools(
          jsonResponseTool != null ? {
            tools: [...tools != null ? tools : [], jsonResponseTool],
            toolChoice: { type: "required" },
            disableParallelToolUse: true,
            cacheControlValidator,
            supportsStructuredOutput: false
          } : {
            tools: tools != null ? tools : [],
            toolChoice,
            disableParallelToolUse: anthropicOptions == null ? void 0 : anthropicOptions.disableParallelToolUse,
            cacheControlValidator,
            supportsStructuredOutput
          }
        );
        const cacheWarnings = cacheControlValidator.getWarnings();
        return {
          args: {
            ...baseArgs,
            tools: anthropicTools22,
            tool_choice: anthropicToolChoice,
            stream: stream === true ? true : void 0
            // do not send when not streaming
          },
          warnings: [...warnings, ...toolWarnings, ...cacheWarnings],
          betas: /* @__PURE__ */ new Set([...betas, ...toolsBetas, ...userSuppliedBetas]),
          usesJsonResponseTool: jsonResponseTool != null,
          toolNameMapping,
          providerOptionsName,
          usedCustomProviderKey
        };
      }
      async getHeaders({
        betas,
        headers
      }) {
        return combineHeaders(
          await resolve(this.config.headers),
          headers,
          betas.size > 0 ? { "anthropic-beta": Array.from(betas).join(",") } : {}
        );
      }
      async getBetasFromHeaders(requestHeaders) {
        var _a25, _b18;
        const configHeaders = await resolve(this.config.headers);
        const configBetaHeader = (_a25 = configHeaders["anthropic-beta"]) != null ? _a25 : "";
        const requestBetaHeader = (_b18 = requestHeaders == null ? void 0 : requestHeaders["anthropic-beta"]) != null ? _b18 : "";
        return new Set(
          [
            ...configBetaHeader.toLowerCase().split(","),
            ...requestBetaHeader.toLowerCase().split(",")
          ].map((beta) => beta.trim()).filter((beta) => beta !== "")
        );
      }
      buildRequestUrl(isStreaming) {
        var _a25, _b18, _c;
        return (_c = (_b18 = (_a25 = this.config).buildRequestUrl) == null ? void 0 : _b18.call(_a25, this.config.baseURL, isStreaming)) != null ? _c : `${this.config.baseURL}/messages`;
      }
      transformRequestBody(args2) {
        var _a25, _b18, _c;
        return (_c = (_b18 = (_a25 = this.config).transformRequestBody) == null ? void 0 : _b18.call(_a25, args2)) != null ? _c : args2;
      }
      extractCitationDocuments(prompt) {
        const isCitationPart = (part) => {
          var _a25, _b18;
          if (part.type !== "file") {
            return false;
          }
          if (part.mediaType !== "application/pdf" && part.mediaType !== "text/plain") {
            return false;
          }
          const anthropic2 = (_a25 = part.providerOptions) == null ? void 0 : _a25.anthropic;
          const citationsConfig = anthropic2 == null ? void 0 : anthropic2.citations;
          return (_b18 = citationsConfig == null ? void 0 : citationsConfig.enabled) != null ? _b18 : false;
        };
        return prompt.filter((message) => message.role === "user").flatMap((message) => message.content).filter(isCitationPart).map((part) => {
          var _a25;
          const filePart = part;
          return {
            title: (_a25 = filePart.filename) != null ? _a25 : "Untitled Document",
            filename: filePart.filename,
            mediaType: filePart.mediaType
          };
        });
      }
      async doGenerate(options) {
        var _a25, _b18, _c, _d, _e, _f;
        const {
          args: args2,
          warnings,
          betas,
          usesJsonResponseTool,
          toolNameMapping,
          providerOptionsName,
          usedCustomProviderKey
        } = await this.getArgs({
          ...options,
          stream: false,
          userSuppliedBetas: await this.getBetasFromHeaders(options.headers)
        });
        const citationDocuments = [
          ...this.extractCitationDocuments(options.prompt)
        ];
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi({
          url: this.buildRequestUrl(false),
          headers: await this.getHeaders({ betas, headers: options.headers }),
          body: this.transformRequestBody(args2),
          failedResponseHandler: anthropicFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            anthropicMessagesResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const content = [];
        const mcpToolCalls = {};
        const serverToolCalls = {};
        let isJsonResponseFromTool = false;
        for (const part of response.content) {
          switch (part.type) {
            case "text": {
              if (!usesJsonResponseTool) {
                content.push({ type: "text", text: part.text });
                if (part.citations) {
                  for (const citation of part.citations) {
                    const source = createCitationSource(
                      citation,
                      citationDocuments,
                      this.generateId
                    );
                    if (source) {
                      content.push(source);
                    }
                  }
                }
              }
              break;
            }
            case "thinking": {
              content.push({
                type: "reasoning",
                text: part.thinking,
                providerMetadata: {
                  anthropic: {
                    signature: part.signature
                  }
                }
              });
              break;
            }
            case "redacted_thinking": {
              content.push({
                type: "reasoning",
                text: "",
                providerMetadata: {
                  anthropic: {
                    redactedData: part.data
                  }
                }
              });
              break;
            }
            case "tool_use": {
              const isJsonResponseTool = usesJsonResponseTool && part.name === "json";
              if (isJsonResponseTool) {
                isJsonResponseFromTool = true;
                content.push({
                  type: "text",
                  text: JSON.stringify(part.input)
                });
              } else {
                const caller = part.caller;
                const callerInfo = caller ? {
                  type: caller.type,
                  toolId: "tool_id" in caller ? caller.tool_id : void 0
                } : void 0;
                content.push({
                  type: "tool-call",
                  toolCallId: part.id,
                  toolName: part.name,
                  input: JSON.stringify(part.input),
                  ...callerInfo && {
                    providerMetadata: {
                      anthropic: {
                        caller: callerInfo
                      }
                    }
                  }
                });
              }
              break;
            }
            case "server_tool_use": {
              if (part.name === "text_editor_code_execution" || part.name === "bash_code_execution") {
                content.push({
                  type: "tool-call",
                  toolCallId: part.id,
                  toolName: toolNameMapping.toCustomToolName("code_execution"),
                  input: JSON.stringify({ type: part.name, ...part.input }),
                  providerExecuted: true
                });
              } else if (part.name === "web_search" || part.name === "code_execution" || part.name === "web_fetch") {
                const inputToSerialize = part.name === "code_execution" && part.input != null && typeof part.input === "object" && "code" in part.input && !("type" in part.input) ? { type: "programmatic-tool-call", ...part.input } : part.input;
                content.push({
                  type: "tool-call",
                  toolCallId: part.id,
                  toolName: toolNameMapping.toCustomToolName(part.name),
                  input: JSON.stringify(inputToSerialize),
                  providerExecuted: true
                });
              } else if (part.name === "tool_search_tool_regex" || part.name === "tool_search_tool_bm25") {
                serverToolCalls[part.id] = part.name;
                content.push({
                  type: "tool-call",
                  toolCallId: part.id,
                  toolName: toolNameMapping.toCustomToolName(part.name),
                  input: JSON.stringify(part.input),
                  providerExecuted: true
                });
              }
              break;
            }
            case "mcp_tool_use": {
              mcpToolCalls[part.id] = {
                type: "tool-call",
                toolCallId: part.id,
                toolName: part.name,
                input: JSON.stringify(part.input),
                providerExecuted: true,
                dynamic: true,
                providerMetadata: {
                  anthropic: {
                    type: "mcp-tool-use",
                    serverName: part.server_name
                  }
                }
              };
              content.push(mcpToolCalls[part.id]);
              break;
            }
            case "mcp_tool_result": {
              content.push({
                type: "tool-result",
                toolCallId: part.tool_use_id,
                toolName: mcpToolCalls[part.tool_use_id].toolName,
                isError: part.is_error,
                result: part.content,
                dynamic: true,
                providerMetadata: mcpToolCalls[part.tool_use_id].providerMetadata
              });
              break;
            }
            case "web_fetch_tool_result": {
              if (part.content.type === "web_fetch_result") {
                citationDocuments.push({
                  title: (_a25 = part.content.content.title) != null ? _a25 : part.content.url,
                  mediaType: part.content.content.source.media_type
                });
                content.push({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: toolNameMapping.toCustomToolName("web_fetch"),
                  result: {
                    type: "web_fetch_result",
                    url: part.content.url,
                    retrievedAt: part.content.retrieved_at,
                    content: {
                      type: part.content.content.type,
                      title: part.content.content.title,
                      citations: part.content.content.citations,
                      source: {
                        type: part.content.content.source.type,
                        mediaType: part.content.content.source.media_type,
                        data: part.content.content.source.data
                      }
                    }
                  }
                });
              } else if (part.content.type === "web_fetch_tool_result_error") {
                content.push({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: toolNameMapping.toCustomToolName("web_fetch"),
                  isError: true,
                  result: {
                    type: "web_fetch_tool_result_error",
                    errorCode: part.content.error_code
                  }
                });
              }
              break;
            }
            case "web_search_tool_result": {
              if (Array.isArray(part.content)) {
                content.push({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: toolNameMapping.toCustomToolName("web_search"),
                  result: part.content.map((result) => {
                    var _a26;
                    return {
                      url: result.url,
                      title: result.title,
                      pageAge: (_a26 = result.page_age) != null ? _a26 : null,
                      encryptedContent: result.encrypted_content,
                      type: result.type
                    };
                  })
                });
                for (const result of part.content) {
                  content.push({
                    type: "source",
                    sourceType: "url",
                    id: this.generateId(),
                    url: result.url,
                    title: result.title,
                    providerMetadata: {
                      anthropic: {
                        pageAge: (_b18 = result.page_age) != null ? _b18 : null
                      }
                    }
                  });
                }
              } else {
                content.push({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: toolNameMapping.toCustomToolName("web_search"),
                  isError: true,
                  result: {
                    type: "web_search_tool_result_error",
                    errorCode: part.content.error_code
                  }
                });
              }
              break;
            }
            // code execution 20250522:
            case "code_execution_tool_result": {
              if (part.content.type === "code_execution_result") {
                content.push({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: toolNameMapping.toCustomToolName("code_execution"),
                  result: {
                    type: part.content.type,
                    stdout: part.content.stdout,
                    stderr: part.content.stderr,
                    return_code: part.content.return_code,
                    content: (_c = part.content.content) != null ? _c : []
                  }
                });
              } else if (part.content.type === "code_execution_tool_result_error") {
                content.push({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: toolNameMapping.toCustomToolName("code_execution"),
                  isError: true,
                  result: {
                    type: "code_execution_tool_result_error",
                    errorCode: part.content.error_code
                  }
                });
              }
              break;
            }
            // code execution 20250825:
            case "bash_code_execution_tool_result":
            case "text_editor_code_execution_tool_result": {
              content.push({
                type: "tool-result",
                toolCallId: part.tool_use_id,
                toolName: toolNameMapping.toCustomToolName("code_execution"),
                result: part.content
              });
              break;
            }
            // tool search tool results:
            case "tool_search_tool_result": {
              let providerToolName = serverToolCalls[part.tool_use_id];
              if (providerToolName == null) {
                const bm25CustomName = toolNameMapping.toCustomToolName(
                  "tool_search_tool_bm25"
                );
                const regexCustomName = toolNameMapping.toCustomToolName(
                  "tool_search_tool_regex"
                );
                if (bm25CustomName !== "tool_search_tool_bm25") {
                  providerToolName = "tool_search_tool_bm25";
                } else if (regexCustomName !== "tool_search_tool_regex") {
                  providerToolName = "tool_search_tool_regex";
                } else {
                  providerToolName = "tool_search_tool_regex";
                }
              }
              if (part.content.type === "tool_search_tool_search_result") {
                content.push({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: toolNameMapping.toCustomToolName(providerToolName),
                  result: part.content.tool_references.map((ref) => ({
                    type: ref.type,
                    toolName: ref.tool_name
                  }))
                });
              } else {
                content.push({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: toolNameMapping.toCustomToolName(providerToolName),
                  isError: true,
                  result: {
                    type: "tool_search_tool_result_error",
                    errorCode: part.content.error_code
                  }
                });
              }
              break;
            }
          }
        }
        return {
          content,
          finishReason: {
            unified: mapAnthropicStopReason({
              finishReason: response.stop_reason,
              isJsonResponseFromTool
            }),
            raw: (_d = response.stop_reason) != null ? _d : void 0
          },
          usage: convertAnthropicMessagesUsage(response.usage),
          request: { body: args2 },
          response: {
            id: (_e = response.id) != null ? _e : void 0,
            modelId: (_f = response.model) != null ? _f : void 0,
            headers: responseHeaders,
            body: rawResponse
          },
          warnings,
          providerMetadata: (() => {
            var _a26, _b24, _c2, _d2, _e2;
            const anthropicMetadata = {
              usage: response.usage,
              cacheCreationInputTokens: (_a26 = response.usage.cache_creation_input_tokens) != null ? _a26 : null,
              stopSequence: (_b24 = response.stop_sequence) != null ? _b24 : null,
              container: response.container ? {
                expiresAt: response.container.expires_at,
                id: response.container.id,
                skills: (_d2 = (_c2 = response.container.skills) == null ? void 0 : _c2.map((skill) => ({
                  type: skill.type,
                  skillId: skill.skill_id,
                  version: skill.version
                }))) != null ? _d2 : null
              } : null,
              contextManagement: (_e2 = mapAnthropicResponseContextManagement(
                response.context_management
              )) != null ? _e2 : null
            };
            const providerMetadata = {
              anthropic: anthropicMetadata
            };
            if (usedCustomProviderKey && providerOptionsName !== "anthropic") {
              providerMetadata[providerOptionsName] = anthropicMetadata;
            }
            return providerMetadata;
          })()
        };
      }
      async doStream(options) {
        var _a25, _b18;
        const {
          args: body,
          warnings,
          betas,
          usesJsonResponseTool,
          toolNameMapping,
          providerOptionsName,
          usedCustomProviderKey
        } = await this.getArgs({
          ...options,
          stream: true,
          userSuppliedBetas: await this.getBetasFromHeaders(options.headers)
        });
        const citationDocuments = [
          ...this.extractCitationDocuments(options.prompt)
        ];
        const url = this.buildRequestUrl(true);
        const { responseHeaders, value: response } = await postJsonToApi({
          url,
          headers: await this.getHeaders({ betas, headers: options.headers }),
          body: this.transformRequestBody(body),
          failedResponseHandler: anthropicFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler(
            anthropicMessagesChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        let finishReason = {
          unified: "other",
          raw: void 0
        };
        const usage = {
          input_tokens: 0,
          output_tokens: 0,
          cache_creation_input_tokens: 0,
          cache_read_input_tokens: 0
        };
        const contentBlocks = {};
        const mcpToolCalls = {};
        const serverToolCalls = {};
        let contextManagement = null;
        let rawUsage = void 0;
        let cacheCreationInputTokens = null;
        let stopSequence = null;
        let container = null;
        let isJsonResponseFromTool = false;
        let blockType = void 0;
        const generateId3 = this.generateId;
        const transformedStream = response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a26, _b24, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value2 = chunk.value;
              switch (value2.type) {
                case "ping": {
                  return;
                }
                case "content_block_start": {
                  const part = value2.content_block;
                  const contentBlockType = part.type;
                  blockType = contentBlockType;
                  switch (contentBlockType) {
                    case "text": {
                      if (usesJsonResponseTool) {
                        return;
                      }
                      contentBlocks[value2.index] = { type: "text" };
                      controller.enqueue({
                        type: "text-start",
                        id: String(value2.index)
                      });
                      return;
                    }
                    case "thinking": {
                      contentBlocks[value2.index] = { type: "reasoning" };
                      controller.enqueue({
                        type: "reasoning-start",
                        id: String(value2.index)
                      });
                      return;
                    }
                    case "redacted_thinking": {
                      contentBlocks[value2.index] = { type: "reasoning" };
                      controller.enqueue({
                        type: "reasoning-start",
                        id: String(value2.index),
                        providerMetadata: {
                          anthropic: {
                            redactedData: part.data
                          }
                        }
                      });
                      return;
                    }
                    case "tool_use": {
                      const isJsonResponseTool = usesJsonResponseTool && part.name === "json";
                      if (isJsonResponseTool) {
                        isJsonResponseFromTool = true;
                        contentBlocks[value2.index] = { type: "text" };
                        controller.enqueue({
                          type: "text-start",
                          id: String(value2.index)
                        });
                      } else {
                        const caller = part.caller;
                        const callerInfo = caller ? {
                          type: caller.type,
                          toolId: "tool_id" in caller ? caller.tool_id : void 0
                        } : void 0;
                        const hasNonEmptyInput = part.input && Object.keys(part.input).length > 0;
                        const initialInput = hasNonEmptyInput ? JSON.stringify(part.input) : "";
                        contentBlocks[value2.index] = {
                          type: "tool-call",
                          toolCallId: part.id,
                          toolName: part.name,
                          input: initialInput,
                          firstDelta: initialInput.length === 0,
                          ...callerInfo && { caller: callerInfo }
                        };
                        controller.enqueue({
                          type: "tool-input-start",
                          id: part.id,
                          toolName: part.name
                        });
                      }
                      return;
                    }
                    case "server_tool_use": {
                      if ([
                        "web_fetch",
                        "web_search",
                        // code execution 20250825:
                        "code_execution",
                        // code execution 20250825 text editor:
                        "text_editor_code_execution",
                        // code execution 20250825 bash:
                        "bash_code_execution"
                      ].includes(part.name)) {
                        const providerToolName = part.name === "text_editor_code_execution" || part.name === "bash_code_execution" ? "code_execution" : part.name;
                        const customToolName = toolNameMapping.toCustomToolName(providerToolName);
                        contentBlocks[value2.index] = {
                          type: "tool-call",
                          toolCallId: part.id,
                          toolName: customToolName,
                          input: "",
                          providerExecuted: true,
                          firstDelta: true,
                          providerToolName: part.name
                        };
                        controller.enqueue({
                          type: "tool-input-start",
                          id: part.id,
                          toolName: customToolName,
                          providerExecuted: true
                        });
                      } else if (part.name === "tool_search_tool_regex" || part.name === "tool_search_tool_bm25") {
                        serverToolCalls[part.id] = part.name;
                        const customToolName = toolNameMapping.toCustomToolName(
                          part.name
                        );
                        contentBlocks[value2.index] = {
                          type: "tool-call",
                          toolCallId: part.id,
                          toolName: customToolName,
                          input: "",
                          providerExecuted: true,
                          firstDelta: true,
                          providerToolName: part.name
                        };
                        controller.enqueue({
                          type: "tool-input-start",
                          id: part.id,
                          toolName: customToolName,
                          providerExecuted: true
                        });
                      }
                      return;
                    }
                    case "web_fetch_tool_result": {
                      if (part.content.type === "web_fetch_result") {
                        citationDocuments.push({
                          title: (_a26 = part.content.content.title) != null ? _a26 : part.content.url,
                          mediaType: part.content.content.source.media_type
                        });
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: part.tool_use_id,
                          toolName: toolNameMapping.toCustomToolName("web_fetch"),
                          result: {
                            type: "web_fetch_result",
                            url: part.content.url,
                            retrievedAt: part.content.retrieved_at,
                            content: {
                              type: part.content.content.type,
                              title: part.content.content.title,
                              citations: part.content.content.citations,
                              source: {
                                type: part.content.content.source.type,
                                mediaType: part.content.content.source.media_type,
                                data: part.content.content.source.data
                              }
                            }
                          }
                        });
                      } else if (part.content.type === "web_fetch_tool_result_error") {
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: part.tool_use_id,
                          toolName: toolNameMapping.toCustomToolName("web_fetch"),
                          isError: true,
                          result: {
                            type: "web_fetch_tool_result_error",
                            errorCode: part.content.error_code
                          }
                        });
                      }
                      return;
                    }
                    case "web_search_tool_result": {
                      if (Array.isArray(part.content)) {
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: part.tool_use_id,
                          toolName: toolNameMapping.toCustomToolName("web_search"),
                          result: part.content.map((result) => {
                            var _a35;
                            return {
                              url: result.url,
                              title: result.title,
                              pageAge: (_a35 = result.page_age) != null ? _a35 : null,
                              encryptedContent: result.encrypted_content,
                              type: result.type
                            };
                          })
                        });
                        for (const result of part.content) {
                          controller.enqueue({
                            type: "source",
                            sourceType: "url",
                            id: generateId3(),
                            url: result.url,
                            title: result.title,
                            providerMetadata: {
                              anthropic: {
                                pageAge: (_b24 = result.page_age) != null ? _b24 : null
                              }
                            }
                          });
                        }
                      } else {
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: part.tool_use_id,
                          toolName: toolNameMapping.toCustomToolName("web_search"),
                          isError: true,
                          result: {
                            type: "web_search_tool_result_error",
                            errorCode: part.content.error_code
                          }
                        });
                      }
                      return;
                    }
                    // code execution 20250522:
                    case "code_execution_tool_result": {
                      if (part.content.type === "code_execution_result") {
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: part.tool_use_id,
                          toolName: toolNameMapping.toCustomToolName("code_execution"),
                          result: {
                            type: part.content.type,
                            stdout: part.content.stdout,
                            stderr: part.content.stderr,
                            return_code: part.content.return_code,
                            content: (_c = part.content.content) != null ? _c : []
                          }
                        });
                      } else if (part.content.type === "code_execution_tool_result_error") {
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: part.tool_use_id,
                          toolName: toolNameMapping.toCustomToolName("code_execution"),
                          isError: true,
                          result: {
                            type: "code_execution_tool_result_error",
                            errorCode: part.content.error_code
                          }
                        });
                      }
                      return;
                    }
                    // code execution 20250825:
                    case "bash_code_execution_tool_result":
                    case "text_editor_code_execution_tool_result": {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: toolNameMapping.toCustomToolName("code_execution"),
                        result: part.content
                      });
                      return;
                    }
                    // tool search tool results:
                    case "tool_search_tool_result": {
                      let providerToolName = serverToolCalls[part.tool_use_id];
                      if (providerToolName == null) {
                        const bm25CustomName = toolNameMapping.toCustomToolName(
                          "tool_search_tool_bm25"
                        );
                        const regexCustomName = toolNameMapping.toCustomToolName(
                          "tool_search_tool_regex"
                        );
                        if (bm25CustomName !== "tool_search_tool_bm25") {
                          providerToolName = "tool_search_tool_bm25";
                        } else if (regexCustomName !== "tool_search_tool_regex") {
                          providerToolName = "tool_search_tool_regex";
                        } else {
                          providerToolName = "tool_search_tool_regex";
                        }
                      }
                      if (part.content.type === "tool_search_tool_search_result") {
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: part.tool_use_id,
                          toolName: toolNameMapping.toCustomToolName(providerToolName),
                          result: part.content.tool_references.map((ref) => ({
                            type: ref.type,
                            toolName: ref.tool_name
                          }))
                        });
                      } else {
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: part.tool_use_id,
                          toolName: toolNameMapping.toCustomToolName(providerToolName),
                          isError: true,
                          result: {
                            type: "tool_search_tool_result_error",
                            errorCode: part.content.error_code
                          }
                        });
                      }
                      return;
                    }
                    case "mcp_tool_use": {
                      mcpToolCalls[part.id] = {
                        type: "tool-call",
                        toolCallId: part.id,
                        toolName: part.name,
                        input: JSON.stringify(part.input),
                        providerExecuted: true,
                        dynamic: true,
                        providerMetadata: {
                          anthropic: {
                            type: "mcp-tool-use",
                            serverName: part.server_name
                          }
                        }
                      };
                      controller.enqueue(mcpToolCalls[part.id]);
                      return;
                    }
                    case "mcp_tool_result": {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: mcpToolCalls[part.tool_use_id].toolName,
                        isError: part.is_error,
                        result: part.content,
                        dynamic: true,
                        providerMetadata: mcpToolCalls[part.tool_use_id].providerMetadata
                      });
                      return;
                    }
                    default: {
                      const _exhaustiveCheck = contentBlockType;
                      throw new Error(
                        `Unsupported content block type: ${_exhaustiveCheck}`
                      );
                    }
                  }
                }
                case "content_block_stop": {
                  if (contentBlocks[value2.index] != null) {
                    const contentBlock = contentBlocks[value2.index];
                    switch (contentBlock.type) {
                      case "text": {
                        controller.enqueue({
                          type: "text-end",
                          id: String(value2.index)
                        });
                        break;
                      }
                      case "reasoning": {
                        controller.enqueue({
                          type: "reasoning-end",
                          id: String(value2.index)
                        });
                        break;
                      }
                      case "tool-call":
                        const isJsonResponseTool = usesJsonResponseTool && contentBlock.toolName === "json";
                        if (!isJsonResponseTool) {
                          controller.enqueue({
                            type: "tool-input-end",
                            id: contentBlock.toolCallId
                          });
                          let finalInput = contentBlock.input === "" ? "{}" : contentBlock.input;
                          if (contentBlock.providerToolName === "code_execution") {
                            try {
                              const parsed = JSON.parse(finalInput);
                              if (parsed != null && typeof parsed === "object" && "code" in parsed && !("type" in parsed)) {
                                finalInput = JSON.stringify({
                                  type: "programmatic-tool-call",
                                  ...parsed
                                });
                              }
                            } catch (e) {
                            }
                          }
                          controller.enqueue({
                            type: "tool-call",
                            toolCallId: contentBlock.toolCallId,
                            toolName: contentBlock.toolName,
                            input: finalInput,
                            providerExecuted: contentBlock.providerExecuted,
                            ...contentBlock.caller && {
                              providerMetadata: {
                                anthropic: {
                                  caller: contentBlock.caller
                                }
                              }
                            }
                          });
                        }
                        break;
                    }
                    delete contentBlocks[value2.index];
                  }
                  blockType = void 0;
                  return;
                }
                case "content_block_delta": {
                  const deltaType = value2.delta.type;
                  switch (deltaType) {
                    case "text_delta": {
                      if (usesJsonResponseTool) {
                        return;
                      }
                      controller.enqueue({
                        type: "text-delta",
                        id: String(value2.index),
                        delta: value2.delta.text
                      });
                      return;
                    }
                    case "thinking_delta": {
                      controller.enqueue({
                        type: "reasoning-delta",
                        id: String(value2.index),
                        delta: value2.delta.thinking
                      });
                      return;
                    }
                    case "signature_delta": {
                      if (blockType === "thinking") {
                        controller.enqueue({
                          type: "reasoning-delta",
                          id: String(value2.index),
                          delta: "",
                          providerMetadata: {
                            anthropic: {
                              signature: value2.delta.signature
                            }
                          }
                        });
                      }
                      return;
                    }
                    case "input_json_delta": {
                      const contentBlock = contentBlocks[value2.index];
                      let delta = value2.delta.partial_json;
                      if (delta.length === 0) {
                        return;
                      }
                      if (isJsonResponseFromTool) {
                        if ((contentBlock == null ? void 0 : contentBlock.type) !== "text") {
                          return;
                        }
                        controller.enqueue({
                          type: "text-delta",
                          id: String(value2.index),
                          delta
                        });
                      } else {
                        if ((contentBlock == null ? void 0 : contentBlock.type) !== "tool-call") {
                          return;
                        }
                        if (contentBlock.firstDelta && (contentBlock.providerToolName === "bash_code_execution" || contentBlock.providerToolName === "text_editor_code_execution")) {
                          delta = `{"type": "${contentBlock.providerToolName}",${delta.substring(1)}`;
                        }
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: contentBlock.toolCallId,
                          delta
                        });
                        contentBlock.input += delta;
                        contentBlock.firstDelta = false;
                      }
                      return;
                    }
                    case "citations_delta": {
                      const citation = value2.delta.citation;
                      const source = createCitationSource(
                        citation,
                        citationDocuments,
                        generateId3
                      );
                      if (source) {
                        controller.enqueue(source);
                      }
                      return;
                    }
                    default: {
                      const _exhaustiveCheck = deltaType;
                      throw new Error(
                        `Unsupported delta type: ${_exhaustiveCheck}`
                      );
                    }
                  }
                }
                case "message_start": {
                  usage.input_tokens = value2.message.usage.input_tokens;
                  usage.cache_read_input_tokens = (_d = value2.message.usage.cache_read_input_tokens) != null ? _d : 0;
                  usage.cache_creation_input_tokens = (_e = value2.message.usage.cache_creation_input_tokens) != null ? _e : 0;
                  rawUsage = {
                    ...value2.message.usage
                  };
                  cacheCreationInputTokens = (_f = value2.message.usage.cache_creation_input_tokens) != null ? _f : null;
                  if (value2.message.container != null) {
                    container = {
                      expiresAt: value2.message.container.expires_at,
                      id: value2.message.container.id,
                      skills: null
                    };
                  }
                  if (value2.message.stop_reason != null) {
                    finishReason = {
                      unified: mapAnthropicStopReason({
                        finishReason: value2.message.stop_reason,
                        isJsonResponseFromTool
                      }),
                      raw: value2.message.stop_reason
                    };
                  }
                  controller.enqueue({
                    type: "response-metadata",
                    id: (_g = value2.message.id) != null ? _g : void 0,
                    modelId: (_h = value2.message.model) != null ? _h : void 0
                  });
                  if (value2.message.content != null) {
                    for (let contentIndex = 0; contentIndex < value2.message.content.length; contentIndex++) {
                      const part = value2.message.content[contentIndex];
                      if (part.type === "tool_use") {
                        const caller = part.caller;
                        const callerInfo = caller ? {
                          type: caller.type,
                          toolId: "tool_id" in caller ? caller.tool_id : void 0
                        } : void 0;
                        controller.enqueue({
                          type: "tool-input-start",
                          id: part.id,
                          toolName: part.name
                        });
                        const inputStr = JSON.stringify((_i = part.input) != null ? _i : {});
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: part.id,
                          delta: inputStr
                        });
                        controller.enqueue({
                          type: "tool-input-end",
                          id: part.id
                        });
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: part.id,
                          toolName: part.name,
                          input: inputStr,
                          ...callerInfo && {
                            providerMetadata: {
                              anthropic: {
                                caller: callerInfo
                              }
                            }
                          }
                        });
                      }
                    }
                  }
                  return;
                }
                case "message_delta": {
                  if (value2.usage.input_tokens != null && usage.input_tokens !== value2.usage.input_tokens) {
                    usage.input_tokens = value2.usage.input_tokens;
                  }
                  usage.output_tokens = value2.usage.output_tokens;
                  if (value2.usage.cache_read_input_tokens != null) {
                    usage.cache_read_input_tokens = value2.usage.cache_read_input_tokens;
                  }
                  if (value2.usage.cache_creation_input_tokens != null) {
                    usage.cache_creation_input_tokens = value2.usage.cache_creation_input_tokens;
                    cacheCreationInputTokens = value2.usage.cache_creation_input_tokens;
                  }
                  finishReason = {
                    unified: mapAnthropicStopReason({
                      finishReason: value2.delta.stop_reason,
                      isJsonResponseFromTool
                    }),
                    raw: (_j = value2.delta.stop_reason) != null ? _j : void 0
                  };
                  stopSequence = (_k = value2.delta.stop_sequence) != null ? _k : null;
                  container = value2.delta.container != null ? {
                    expiresAt: value2.delta.container.expires_at,
                    id: value2.delta.container.id,
                    skills: (_m = (_l = value2.delta.container.skills) == null ? void 0 : _l.map((skill) => ({
                      type: skill.type,
                      skillId: skill.skill_id,
                      version: skill.version
                    }))) != null ? _m : null
                  } : null;
                  if (value2.context_management) {
                    contextManagement = mapAnthropicResponseContextManagement(
                      value2.context_management
                    );
                  }
                  rawUsage = {
                    ...rawUsage,
                    ...value2.usage
                  };
                  return;
                }
                case "message_stop": {
                  const anthropicMetadata = {
                    usage: rawUsage != null ? rawUsage : null,
                    cacheCreationInputTokens,
                    stopSequence,
                    container,
                    contextManagement
                  };
                  const providerMetadata = {
                    anthropic: anthropicMetadata
                  };
                  if (usedCustomProviderKey && providerOptionsName !== "anthropic") {
                    providerMetadata[providerOptionsName] = anthropicMetadata;
                  }
                  controller.enqueue({
                    type: "finish",
                    finishReason,
                    usage: convertAnthropicMessagesUsage(usage),
                    providerMetadata
                  });
                  return;
                }
                case "error": {
                  controller.enqueue({ type: "error", error: value2.error });
                  return;
                }
                default: {
                  const _exhaustiveCheck = value2;
                  throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
                }
              }
            }
          })
        );
        const [streamForFirstChunk, streamForConsumer] = transformedStream.tee();
        const firstChunkReader = streamForFirstChunk.getReader();
        try {
          await firstChunkReader.read();
          let result = await firstChunkReader.read();
          if (((_a25 = result.value) == null ? void 0 : _a25.type) === "raw") {
            result = await firstChunkReader.read();
          }
          if (((_b18 = result.value) == null ? void 0 : _b18.type) === "error") {
            const error = result.value.error;
            throw new APICallError({
              message: error.message,
              url,
              requestBodyValues: body,
              statusCode: error.type === "overloaded_error" ? 529 : 500,
              responseHeaders,
              responseBody: JSON.stringify(error),
              isRetryable: error.type === "overloaded_error"
            });
          }
        } finally {
          firstChunkReader.cancel().catch(() => {
          });
          firstChunkReader.releaseLock();
        }
        return {
          stream: streamForConsumer,
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    bash_20241022InputSchema = lazySchema(
      () => zodSchema(
        z103.object({
          command: z103.string(),
          restart: z103.boolean().optional()
        })
      )
    );
    bash_20241022 = createProviderToolFactory({
      id: "anthropic.bash_20241022",
      inputSchema: bash_20241022InputSchema
    });
    bash_20250124InputSchema = lazySchema(
      () => zodSchema(
        z112.object({
          command: z112.string(),
          restart: z112.boolean().optional()
        })
      )
    );
    bash_20250124 = createProviderToolFactory({
      id: "anthropic.bash_20250124",
      inputSchema: bash_20250124InputSchema
    });
    computer_20241022InputSchema = lazySchema(
      () => zodSchema(
        z122.object({
          action: z122.enum([
            "key",
            "type",
            "mouse_move",
            "left_click",
            "left_click_drag",
            "right_click",
            "middle_click",
            "double_click",
            "screenshot",
            "cursor_position"
          ]),
          coordinate: z122.array(z122.number().int()).optional(),
          text: z122.string().optional()
        })
      )
    );
    computer_20241022 = createProviderToolFactory({
      id: "anthropic.computer_20241022",
      inputSchema: computer_20241022InputSchema
    });
    computer_20250124InputSchema = lazySchema(
      () => zodSchema(
        z132.object({
          action: z132.enum([
            "key",
            "hold_key",
            "type",
            "cursor_position",
            "mouse_move",
            "left_mouse_down",
            "left_mouse_up",
            "left_click",
            "left_click_drag",
            "right_click",
            "middle_click",
            "double_click",
            "triple_click",
            "scroll",
            "wait",
            "screenshot"
          ]),
          coordinate: z132.tuple([z132.number().int(), z132.number().int()]).optional(),
          duration: z132.number().optional(),
          scroll_amount: z132.number().optional(),
          scroll_direction: z132.enum(["up", "down", "left", "right"]).optional(),
          start_coordinate: z132.tuple([z132.number().int(), z132.number().int()]).optional(),
          text: z132.string().optional()
        })
      )
    );
    computer_20250124 = createProviderToolFactory({
      id: "anthropic.computer_20250124",
      inputSchema: computer_20250124InputSchema
    });
    computer_20251124InputSchema = lazySchema(
      () => zodSchema(
        z142.object({
          action: z142.enum([
            "key",
            "hold_key",
            "type",
            "cursor_position",
            "mouse_move",
            "left_mouse_down",
            "left_mouse_up",
            "left_click",
            "left_click_drag",
            "right_click",
            "middle_click",
            "double_click",
            "triple_click",
            "scroll",
            "wait",
            "screenshot",
            "zoom"
          ]),
          coordinate: z142.tuple([z142.number().int(), z142.number().int()]).optional(),
          duration: z142.number().optional(),
          region: z142.tuple([
            z142.number().int(),
            z142.number().int(),
            z142.number().int(),
            z142.number().int()
          ]).optional(),
          scroll_amount: z142.number().optional(),
          scroll_direction: z142.enum(["up", "down", "left", "right"]).optional(),
          start_coordinate: z142.tuple([z142.number().int(), z142.number().int()]).optional(),
          text: z142.string().optional()
        })
      )
    );
    computer_20251124 = createProviderToolFactory({
      id: "anthropic.computer_20251124",
      inputSchema: computer_20251124InputSchema
    });
    memory_20250818InputSchema = lazySchema(
      () => zodSchema(
        z152.discriminatedUnion("command", [
          z152.object({
            command: z152.literal("view"),
            path: z152.string(),
            view_range: z152.tuple([z152.number(), z152.number()]).optional()
          }),
          z152.object({
            command: z152.literal("create"),
            path: z152.string(),
            file_text: z152.string()
          }),
          z152.object({
            command: z152.literal("str_replace"),
            path: z152.string(),
            old_str: z152.string(),
            new_str: z152.string()
          }),
          z152.object({
            command: z152.literal("insert"),
            path: z152.string(),
            insert_line: z152.number(),
            insert_text: z152.string()
          }),
          z152.object({
            command: z152.literal("delete"),
            path: z152.string()
          }),
          z152.object({
            command: z152.literal("rename"),
            old_path: z152.string(),
            new_path: z152.string()
          })
        ])
      )
    );
    memory_20250818 = createProviderToolFactory({
      id: "anthropic.memory_20250818",
      inputSchema: memory_20250818InputSchema
    });
    textEditor_20241022InputSchema = lazySchema(
      () => zodSchema(
        z162.object({
          command: z162.enum(["view", "create", "str_replace", "insert", "undo_edit"]),
          path: z162.string(),
          file_text: z162.string().optional(),
          insert_line: z162.number().int().optional(),
          new_str: z162.string().optional(),
          insert_text: z162.string().optional(),
          old_str: z162.string().optional(),
          view_range: z162.array(z162.number().int()).optional()
        })
      )
    );
    textEditor_20241022 = createProviderToolFactory({
      id: "anthropic.text_editor_20241022",
      inputSchema: textEditor_20241022InputSchema
    });
    textEditor_20250124InputSchema = lazySchema(
      () => zodSchema(
        z172.object({
          command: z172.enum(["view", "create", "str_replace", "insert", "undo_edit"]),
          path: z172.string(),
          file_text: z172.string().optional(),
          insert_line: z172.number().int().optional(),
          new_str: z172.string().optional(),
          insert_text: z172.string().optional(),
          old_str: z172.string().optional(),
          view_range: z172.array(z172.number().int()).optional()
        })
      )
    );
    textEditor_20250124 = createProviderToolFactory({
      id: "anthropic.text_editor_20250124",
      inputSchema: textEditor_20250124InputSchema
    });
    textEditor_20250429InputSchema = lazySchema(
      () => zodSchema(
        z182.object({
          command: z182.enum(["view", "create", "str_replace", "insert"]),
          path: z182.string(),
          file_text: z182.string().optional(),
          insert_line: z182.number().int().optional(),
          new_str: z182.string().optional(),
          insert_text: z182.string().optional(),
          old_str: z182.string().optional(),
          view_range: z182.array(z182.number().int()).optional()
        })
      )
    );
    textEditor_20250429 = createProviderToolFactory({
      id: "anthropic.text_editor_20250429",
      inputSchema: textEditor_20250429InputSchema
    });
    toolSearchBm25_20251119OutputSchema = lazySchema(
      () => zodSchema(
        z19.array(
          z19.object({
            type: z19.literal("tool_reference"),
            toolName: z19.string()
          })
        )
      )
    );
    toolSearchBm25_20251119InputSchema = lazySchema(
      () => zodSchema(
        z19.object({
          /**
           * A natural language query to search for tools.
           * Claude will use BM25 text search to find relevant tools.
           */
          query: z19.string(),
          /**
           * Maximum number of tools to return. Optional.
           */
          limit: z19.number().optional()
        })
      )
    );
    factory7 = createProviderToolFactoryWithOutputSchema({
      id: "anthropic.tool_search_bm25_20251119",
      inputSchema: toolSearchBm25_20251119InputSchema,
      outputSchema: toolSearchBm25_20251119OutputSchema,
      supportsDeferredResults: true
    });
    toolSearchBm25_20251119 = (args2 = {}) => {
      return factory7(args2);
    };
    anthropicTools = {
      /**
       * The bash tool enables Claude to execute shell commands in a persistent bash session,
       * allowing system operations, script execution, and command-line automation.
       *
       * Image results are supported.
       */
      bash_20241022,
      /**
       * The bash tool enables Claude to execute shell commands in a persistent bash session,
       * allowing system operations, script execution, and command-line automation.
       *
       * Image results are supported.
       */
      bash_20250124,
      /**
       * Claude can analyze data, create visualizations, perform complex calculations,
       * run system commands, create and edit files, and process uploaded files directly within
       * the API conversation.
       *
       * The code execution tool allows Claude to run Bash commands and manipulate files,
       * including writing code, in a secure, sandboxed environment.
       */
      codeExecution_20250522,
      /**
       * Claude can analyze data, create visualizations, perform complex calculations,
       * run system commands, create and edit files, and process uploaded files directly within
       * the API conversation.
       *
       * The code execution tool allows Claude to run both Python and Bash commands and manipulate files,
       * including writing code, in a secure, sandboxed environment.
       *
       * This is the latest version with enhanced Bash support and file operations.
       */
      codeExecution_20250825,
      /**
       * Claude can interact with computer environments through the computer use tool, which
       * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
       *
       * Image results are supported.
       *
       * @param displayWidthPx - The width of the display being controlled by the model in pixels.
       * @param displayHeightPx - The height of the display being controlled by the model in pixels.
       * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
       */
      computer_20241022,
      /**
       * Claude can interact with computer environments through the computer use tool, which
       * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
       *
       * Image results are supported.
       *
       * @param displayWidthPx - The width of the display being controlled by the model in pixels.
       * @param displayHeightPx - The height of the display being controlled by the model in pixels.
       * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
       */
      computer_20250124,
      /**
       * Claude can interact with computer environments through the computer use tool, which
       * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
       *
       * This version adds the zoom action for detailed screen region inspection.
       *
       * Image results are supported.
       *
       * Supported models: Claude Opus 4.5
       *
       * @param displayWidthPx - The width of the display being controlled by the model in pixels.
       * @param displayHeightPx - The height of the display being controlled by the model in pixels.
       * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
       * @param enableZoom - Enable zoom action. Set to true to allow Claude to zoom into specific screen regions. Default: false.
       */
      computer_20251124,
      /**
       * The memory tool enables Claude to store and retrieve information across conversations through a memory file directory.
       * Claude can create, read, update, and delete files that persist between sessions,
       * allowing it to build knowledge over time without keeping everything in the context window.
       * The memory tool operates client-sideyou control where and how the data is stored through your own infrastructure.
       *
       * Supported models: Claude Sonnet 4.5, Claude Sonnet 4, Claude Opus 4.1, Claude Opus 4.
       */
      memory_20250818,
      /**
       * Claude can use an Anthropic-defined text editor tool to view and modify text files,
       * helping you debug, fix, and improve your code or other text documents. This allows Claude
       * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
       *
       * Supported models: Claude Sonnet 3.5
       */
      textEditor_20241022,
      /**
       * Claude can use an Anthropic-defined text editor tool to view and modify text files,
       * helping you debug, fix, and improve your code or other text documents. This allows Claude
       * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
       *
       * Supported models: Claude Sonnet 3.7
       */
      textEditor_20250124,
      /**
       * Claude can use an Anthropic-defined text editor tool to view and modify text files,
       * helping you debug, fix, and improve your code or other text documents. This allows Claude
       * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
       *
       * Note: This version does not support the "undo_edit" command.
       *
       * @deprecated Use textEditor_20250728 instead
       */
      textEditor_20250429,
      /**
       * Claude can use an Anthropic-defined text editor tool to view and modify text files,
       * helping you debug, fix, and improve your code or other text documents. This allows Claude
       * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
       *
       * Note: This version does not support the "undo_edit" command and adds optional max_characters parameter.
       *
       * Supported models: Claude Sonnet 4, Opus 4, and Opus 4.1
       *
       * @param maxCharacters - Optional maximum number of characters to view in the file
       */
      textEditor_20250728,
      /**
       * Creates a web fetch tool that gives Claude direct access to real-time web content.
       *
       * @param maxUses - The max_uses parameter limits the number of web fetches performed
       * @param allowedDomains - Only fetch from these domains
       * @param blockedDomains - Never fetch from these domains
       * @param citations - Unlike web search where citations are always enabled, citations are optional for web fetch. Set "citations": {"enabled": true} to enable Claude to cite specific passages from fetched documents.
       * @param maxContentTokens - The max_content_tokens parameter limits the amount of content that will be included in the context.
       */
      webFetch_20250910,
      /**
       * Creates a web search tool that gives Claude direct access to real-time web content.
       *
       * @param maxUses - Maximum number of web searches Claude can perform during the conversation.
       * @param allowedDomains - Optional list of domains that Claude is allowed to search.
       * @param blockedDomains - Optional list of domains that Claude should avoid when searching.
       * @param userLocation - Optional user location information to provide geographically relevant search results.
       */
      webSearch_20250305,
      /**
       * Creates a tool search tool that uses regex patterns to find tools.
       *
       * The tool search tool enables Claude to work with hundreds or thousands of tools
       * by dynamically discovering and loading them on-demand. Instead of loading all
       * tool definitions into the context window upfront, Claude searches your tool
       * catalog and loads only the tools it needs.
       *
       * Use `providerOptions: { anthropic: { deferLoading: true } }` on other tools
       * to mark them for deferred loading.
       *
       * Supported models: Claude Opus 4.5, Claude Sonnet 4.5
       */
      toolSearchRegex_20251119,
      /**
       * Creates a tool search tool that uses BM25 (natural language) to find tools.
       *
       * The tool search tool enables Claude to work with hundreds or thousands of tools
       * by dynamically discovering and loading them on-demand. Instead of loading all
       * tool definitions into the context window upfront, Claude searches your tool
       * catalog and loads only the tools it needs.
       *
       * Use `providerOptions: { anthropic: { deferLoading: true } }` on other tools
       * to mark them for deferred loading.
       *
       * Supported models: Claude Opus 4.5, Claude Sonnet 4.5
       */
      toolSearchBm25_20251119
    };
    anthropic = createAnthropic();
  }
});

// node_modules/@ai-sdk/openai/dist/index.mjs
var dist_exports4 = {};
__export(dist_exports4, {
  VERSION: () => VERSION6,
  createOpenAI: () => createOpenAI,
  openai: () => openai
});
import { z as z20 } from "zod/v4";
import { z as z25 } from "zod/v4";
import { z as z35 } from "zod/v4";
import { z as z46 } from "zod/v4";
import { z as z55 } from "zod/v4";
import { z as z65 } from "zod/v4";
import { z as z75 } from "zod/v4";
import { z as z85 } from "zod/v4";
import { z as z94 } from "zod/v4";
import { z as z104 } from "zod/v4";
import { z as z113 } from "zod/v4";
import { z as z123 } from "zod/v4";
import { z as z133 } from "zod/v4";
import { z as z143 } from "zod/v4";
import { z as z153 } from "zod/v4";
import { z as z163 } from "zod/v4";
import { z as z173 } from "zod/v4";
import { z as z183 } from "zod/v4";
import { z as z192 } from "zod/v4";
import { z as z202 } from "zod/v4";
import { z as z21 } from "zod/v4";
import { z as z222 } from "zod/v4";
import { z as z232 } from "zod/v4";
function getOpenAILanguageModelCapabilities(modelId) {
  const supportsFlexProcessing = modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
  const supportsPriorityProcessing = modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
  const isReasoningModel = modelId.startsWith("o1") || modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("codex-mini") || modelId.startsWith("computer-use-preview") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
  const supportsNonReasoningParameters = modelId.startsWith("gpt-5.1") || modelId.startsWith("gpt-5.2");
  const systemMessageMode = isReasoningModel ? "developer" : "system";
  return {
    supportsFlexProcessing,
    supportsPriorityProcessing,
    isReasoningModel,
    systemMessageMode,
    supportsNonReasoningParameters
  };
}
function convertOpenAIChatUsage(usage) {
  var _a25, _b18, _c, _d, _e, _f;
  if (usage == null) {
    return {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
  }
  const promptTokens = (_a25 = usage.prompt_tokens) != null ? _a25 : 0;
  const completionTokens = (_b18 = usage.completion_tokens) != null ? _b18 : 0;
  const cachedTokens = (_d = (_c = usage.prompt_tokens_details) == null ? void 0 : _c.cached_tokens) != null ? _d : 0;
  const reasoningTokens = (_f = (_e = usage.completion_tokens_details) == null ? void 0 : _e.reasoning_tokens) != null ? _f : 0;
  return {
    inputTokens: {
      total: promptTokens,
      noCache: promptTokens - cachedTokens,
      cacheRead: cachedTokens,
      cacheWrite: void 0
    },
    outputTokens: {
      total: completionTokens,
      text: completionTokens - reasoningTokens,
      reasoning: reasoningTokens
    },
    raw: usage
  };
}
function convertToOpenAIChatMessages({
  prompt,
  systemMessageMode = "system"
}) {
  var _a25;
  const messages = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            messages.push({ role: "system", content });
            break;
          }
          case "developer": {
            messages.push({ role: "developer", content });
            break;
          }
          case "remove": {
            warnings.push({
              type: "other",
              message: "system messages are removed for this model"
            });
            break;
          }
          default: {
            const _exhaustiveCheck = systemMessageMode;
            throw new Error(
              `Unsupported system message mode: ${_exhaustiveCheck}`
            );
          }
        }
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part, index) => {
            var _a26, _b18, _c;
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`,
                      // OpenAI specific extension: image detail
                      detail: (_b18 = (_a26 = part.providerOptions) == null ? void 0 : _a26.openai) == null ? void 0 : _b18.imageDetail
                    }
                  };
                } else if (part.mediaType.startsWith("audio/")) {
                  if (part.data instanceof URL) {
                    throw new UnsupportedFunctionalityError({
                      functionality: "audio file parts with URLs"
                    });
                  }
                  switch (part.mediaType) {
                    case "audio/wav": {
                      return {
                        type: "input_audio",
                        input_audio: {
                          data: convertToBase64(part.data),
                          format: "wav"
                        }
                      };
                    }
                    case "audio/mp3":
                    case "audio/mpeg": {
                      return {
                        type: "input_audio",
                        input_audio: {
                          data: convertToBase64(part.data),
                          format: "mp3"
                        }
                      };
                    }
                    default: {
                      throw new UnsupportedFunctionalityError({
                        functionality: `audio content parts with media type ${part.mediaType}`
                      });
                    }
                  }
                } else if (part.mediaType === "application/pdf") {
                  if (part.data instanceof URL) {
                    throw new UnsupportedFunctionalityError({
                      functionality: "PDF file parts with URLs"
                    });
                  }
                  return {
                    type: "file",
                    file: typeof part.data === "string" && part.data.startsWith("file-") ? { file_id: part.data } : {
                      filename: (_c = part.filename) != null ? _c : `part-${index}.pdf`,
                      file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                    }
                  };
                } else {
                  throw new UnsupportedFunctionalityError({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text2 = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text2 += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text2,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          if (toolResponse.type === "tool-approval-response") {
            continue;
          }
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "execution-denied":
              contentValue = (_a25 = output.reason) != null ? _a25 : "Tool execution denied.";
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { messages, warnings };
}
function getResponseMetadata({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created ? new Date(created * 1e3) : void 0
  };
}
function mapOpenAIFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "other";
  }
}
function prepareChatTools({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const openaiTools2 = [];
  for (const tool2 of tools) {
    switch (tool2.type) {
      case "function":
        openaiTools2.push({
          type: "function",
          function: {
            name: tool2.name,
            description: tool2.description,
            parameters: tool2.inputSchema,
            ...tool2.strict != null ? { strict: tool2.strict } : {}
          }
        });
        break;
      default:
        toolWarnings.push({
          type: "unsupported",
          feature: `tool type: ${tool2.type}`
        });
        break;
    }
  }
  if (toolChoice == null) {
    return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
  }
  const type2 = toolChoice.type;
  switch (type2) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiTools2, toolChoice: type2, toolWarnings };
    case "tool":
      return {
        tools: openaiTools2,
        toolChoice: {
          type: "function",
          function: {
            name: toolChoice.toolName
          }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type2;
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function convertOpenAICompletionUsage(usage) {
  var _a25, _b18, _c, _d;
  if (usage == null) {
    return {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
  }
  const promptTokens = (_a25 = usage.prompt_tokens) != null ? _a25 : 0;
  const completionTokens = (_b18 = usage.completion_tokens) != null ? _b18 : 0;
  return {
    inputTokens: {
      total: (_c = usage.prompt_tokens) != null ? _c : void 0,
      noCache: promptTokens,
      cacheRead: void 0,
      cacheWrite: void 0
    },
    outputTokens: {
      total: (_d = usage.completion_tokens) != null ? _d : void 0,
      text: completionTokens,
      reasoning: void 0
    },
    raw: usage
  };
}
function convertToOpenAICompletionPrompt({
  prompt,
  user = "user",
  assistant = "assistant"
}) {
  let text2 = "";
  if (prompt[0].role === "system") {
    text2 += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new InvalidPromptError({
          message: "Unexpected system message in prompt: ${content}",
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
          }
        }).filter(Boolean).join("");
        text2 += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "tool-call": {
              throw new UnsupportedFunctionalityError({
                functionality: "tool-call messages"
              });
            }
          }
        }).join("");
        text2 += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new UnsupportedFunctionalityError({
          functionality: "tool messages"
        });
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  text2 += `${assistant}:
`;
  return {
    prompt: text2,
    stopSequences: [`
${user}:`]
  };
}
function getResponseMetadata2({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapOpenAIFinishReason2(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "other";
  }
}
function hasDefaultResponseFormat(modelId) {
  return defaultResponseFormatPrefixes.some(
    (prefix) => modelId.startsWith(prefix)
  );
}
async function fileToBlob(file) {
  if (!file) return void 0;
  if (file.type === "url") {
    return downloadBlob(file.url);
  }
  const data = file.data instanceof Uint8Array ? file.data : convertBase64ToUint8Array(file.data);
  return new Blob([data], { type: file.mediaType });
}
function convertOpenAIResponsesUsage(usage) {
  var _a25, _b18, _c, _d;
  if (usage == null) {
    return {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
  }
  const inputTokens = usage.input_tokens;
  const outputTokens = usage.output_tokens;
  const cachedTokens = (_b18 = (_a25 = usage.input_tokens_details) == null ? void 0 : _a25.cached_tokens) != null ? _b18 : 0;
  const reasoningTokens = (_d = (_c = usage.output_tokens_details) == null ? void 0 : _c.reasoning_tokens) != null ? _d : 0;
  return {
    inputTokens: {
      total: inputTokens,
      noCache: inputTokens - cachedTokens,
      cacheRead: cachedTokens,
      cacheWrite: void 0
    },
    outputTokens: {
      total: outputTokens,
      text: outputTokens - reasoningTokens,
      reasoning: reasoningTokens
    },
    raw: usage
  };
}
function isFileId(data, prefixes) {
  if (!prefixes) return false;
  return prefixes.some((prefix) => data.startsWith(prefix));
}
async function convertToOpenAIResponsesInput({
  prompt,
  toolNameMapping,
  systemMessageMode,
  providerOptionsName,
  fileIdPrefixes,
  store,
  hasConversation = false,
  hasLocalShellTool = false,
  hasShellTool = false,
  hasApplyPatchTool = false
}) {
  var _a25, _b18, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
  const input = [];
  const warnings = [];
  const processedApprovalIds = /* @__PURE__ */ new Set();
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            input.push({ role: "system", content });
            break;
          }
          case "developer": {
            input.push({ role: "developer", content });
            break;
          }
          case "remove": {
            warnings.push({
              type: "other",
              message: "system messages are removed for this model"
            });
            break;
          }
          default: {
            const _exhaustiveCheck = systemMessageMode;
            throw new Error(
              `Unsupported system message mode: ${_exhaustiveCheck}`
            );
          }
        }
        break;
      }
      case "user": {
        input.push({
          role: "user",
          content: content.map((part, index) => {
            var _a26, _b24, _c2;
            switch (part.type) {
              case "text": {
                return { type: "input_text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "input_image",
                    ...part.data instanceof URL ? { image_url: part.data.toString() } : typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                      image_url: `data:${mediaType};base64,${convertToBase64(part.data)}`
                    },
                    detail: (_b24 = (_a26 = part.providerOptions) == null ? void 0 : _a26[providerOptionsName]) == null ? void 0 : _b24.imageDetail
                  };
                } else if (part.mediaType === "application/pdf") {
                  if (part.data instanceof URL) {
                    return {
                      type: "input_file",
                      file_url: part.data.toString()
                    };
                  }
                  return {
                    type: "input_file",
                    ...typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                      filename: (_c2 = part.filename) != null ? _c2 : `part-${index}.pdf`,
                      file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                    }
                  };
                } else {
                  throw new UnsupportedFunctionalityError({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        const reasoningMessages = {};
        for (const part of content) {
          switch (part.type) {
            case "text": {
              const id = (_b18 = (_a25 = part.providerOptions) == null ? void 0 : _a25[providerOptionsName]) == null ? void 0 : _b18.itemId;
              if (hasConversation && id != null) {
                break;
              }
              if (store && id != null) {
                input.push({ type: "item_reference", id });
                break;
              }
              input.push({
                role: "assistant",
                content: [{ type: "output_text", text: part.text }],
                id
              });
              break;
            }
            case "tool-call": {
              const id = (_g = (_d = (_c = part.providerOptions) == null ? void 0 : _c[providerOptionsName]) == null ? void 0 : _d.itemId) != null ? _g : (_f = (_e = part.providerMetadata) == null ? void 0 : _e[providerOptionsName]) == null ? void 0 : _f.itemId;
              if (hasConversation && id != null) {
                break;
              }
              if (part.providerExecuted) {
                if (store && id != null) {
                  input.push({ type: "item_reference", id });
                }
                break;
              }
              if (store && id != null) {
                input.push({ type: "item_reference", id });
                break;
              }
              const resolvedToolName = toolNameMapping.toProviderToolName(
                part.toolName
              );
              if (hasLocalShellTool && resolvedToolName === "local_shell") {
                const parsedInput = await validateTypes({
                  value: part.input,
                  schema: localShellInputSchema
                });
                input.push({
                  type: "local_shell_call",
                  call_id: part.toolCallId,
                  id,
                  action: {
                    type: "exec",
                    command: parsedInput.action.command,
                    timeout_ms: parsedInput.action.timeoutMs,
                    user: parsedInput.action.user,
                    working_directory: parsedInput.action.workingDirectory,
                    env: parsedInput.action.env
                  }
                });
                break;
              }
              if (hasShellTool && resolvedToolName === "shell") {
                const parsedInput = await validateTypes({
                  value: part.input,
                  schema: shellInputSchema
                });
                input.push({
                  type: "shell_call",
                  call_id: part.toolCallId,
                  id,
                  status: "completed",
                  action: {
                    commands: parsedInput.action.commands,
                    timeout_ms: parsedInput.action.timeoutMs,
                    max_output_length: parsedInput.action.maxOutputLength
                  }
                });
                break;
              }
              if (hasApplyPatchTool && resolvedToolName === "apply_patch") {
                const parsedInput = await validateTypes({
                  value: part.input,
                  schema: applyPatchInputSchema
                });
                input.push({
                  type: "apply_patch_call",
                  call_id: parsedInput.callId,
                  id,
                  status: "completed",
                  operation: parsedInput.operation
                });
                break;
              }
              input.push({
                type: "function_call",
                call_id: part.toolCallId,
                name: resolvedToolName,
                arguments: JSON.stringify(part.input),
                id
              });
              break;
            }
            // assistant tool result parts are from provider-executed tools:
            case "tool-result": {
              if (part.output.type === "execution-denied" || part.output.type === "json" && typeof part.output.value === "object" && part.output.value != null && "type" in part.output.value && part.output.value.type === "execution-denied") {
                break;
              }
              if (hasConversation) {
                break;
              }
              if (store) {
                const itemId = (_j = (_i = (_h = part.providerMetadata) == null ? void 0 : _h[providerOptionsName]) == null ? void 0 : _i.itemId) != null ? _j : part.toolCallId;
                input.push({ type: "item_reference", id: itemId });
              } else {
                warnings.push({
                  type: "other",
                  message: `Results for OpenAI tool ${part.toolName} are not sent to the API when store is false`
                });
              }
              break;
            }
            case "reasoning": {
              const providerOptions = await parseProviderOptions({
                provider: providerOptionsName,
                providerOptions: part.providerOptions,
                schema: openaiResponsesReasoningProviderOptionsSchema
              });
              const reasoningId = providerOptions == null ? void 0 : providerOptions.itemId;
              if (hasConversation && reasoningId != null) {
                break;
              }
              if (reasoningId != null) {
                const reasoningMessage = reasoningMessages[reasoningId];
                if (store) {
                  if (reasoningMessage === void 0) {
                    input.push({ type: "item_reference", id: reasoningId });
                    reasoningMessages[reasoningId] = {
                      type: "reasoning",
                      id: reasoningId,
                      summary: []
                    };
                  }
                } else {
                  const summaryParts = [];
                  if (part.text.length > 0) {
                    summaryParts.push({
                      type: "summary_text",
                      text: part.text
                    });
                  } else if (reasoningMessage !== void 0) {
                    warnings.push({
                      type: "other",
                      message: `Cannot append empty reasoning part to existing reasoning sequence. Skipping reasoning part: ${JSON.stringify(part)}.`
                    });
                  }
                  if (reasoningMessage === void 0) {
                    reasoningMessages[reasoningId] = {
                      type: "reasoning",
                      id: reasoningId,
                      encrypted_content: providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent,
                      summary: summaryParts
                    };
                    input.push(reasoningMessages[reasoningId]);
                  } else {
                    reasoningMessage.summary.push(...summaryParts);
                    if ((providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent) != null) {
                      reasoningMessage.encrypted_content = providerOptions.reasoningEncryptedContent;
                    }
                  }
                }
              } else {
                warnings.push({
                  type: "other",
                  message: `Non-OpenAI reasoning parts are not supported. Skipping reasoning part: ${JSON.stringify(part)}.`
                });
              }
              break;
            }
          }
        }
        break;
      }
      case "tool": {
        for (const part of content) {
          if (part.type === "tool-approval-response") {
            const approvalResponse = part;
            if (processedApprovalIds.has(approvalResponse.approvalId)) {
              continue;
            }
            processedApprovalIds.add(approvalResponse.approvalId);
            if (store) {
              input.push({
                type: "item_reference",
                id: approvalResponse.approvalId
              });
            }
            input.push({
              type: "mcp_approval_response",
              approval_request_id: approvalResponse.approvalId,
              approve: approvalResponse.approved
            });
            continue;
          }
          const output = part.output;
          if (output.type === "execution-denied") {
            const approvalId = (_l = (_k = output.providerOptions) == null ? void 0 : _k.openai) == null ? void 0 : _l.approvalId;
            if (approvalId) {
              continue;
            }
          }
          const resolvedToolName = toolNameMapping.toProviderToolName(
            part.toolName
          );
          if (hasLocalShellTool && resolvedToolName === "local_shell" && output.type === "json") {
            const parsedOutput = await validateTypes({
              value: output.value,
              schema: localShellOutputSchema
            });
            input.push({
              type: "local_shell_call_output",
              call_id: part.toolCallId,
              output: parsedOutput.output
            });
            continue;
          }
          if (hasShellTool && resolvedToolName === "shell" && output.type === "json") {
            const parsedOutput = await validateTypes({
              value: output.value,
              schema: shellOutputSchema
            });
            input.push({
              type: "shell_call_output",
              call_id: part.toolCallId,
              output: parsedOutput.output.map((item) => ({
                stdout: item.stdout,
                stderr: item.stderr,
                outcome: item.outcome.type === "timeout" ? { type: "timeout" } : {
                  type: "exit",
                  exit_code: item.outcome.exitCode
                }
              }))
            });
            continue;
          }
          if (hasApplyPatchTool && part.toolName === "apply_patch" && output.type === "json") {
            const parsedOutput = await validateTypes({
              value: output.value,
              schema: applyPatchOutputSchema
            });
            input.push({
              type: "apply_patch_call_output",
              call_id: part.toolCallId,
              status: parsedOutput.status,
              output: parsedOutput.output
            });
            continue;
          }
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "execution-denied":
              contentValue = (_m = output.reason) != null ? _m : "Tool execution denied.";
              break;
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
            case "content":
              contentValue = output.value.map((item) => {
                var _a26;
                switch (item.type) {
                  case "text": {
                    return { type: "input_text", text: item.text };
                  }
                  case "image-data": {
                    return {
                      type: "input_image",
                      image_url: `data:${item.mediaType};base64,${item.data}`
                    };
                  }
                  case "image-url": {
                    return {
                      type: "input_image",
                      image_url: item.url
                    };
                  }
                  case "file-data": {
                    return {
                      type: "input_file",
                      filename: (_a26 = item.filename) != null ? _a26 : "data",
                      file_data: `data:${item.mediaType};base64,${item.data}`
                    };
                  }
                  default: {
                    warnings.push({
                      type: "other",
                      message: `unsupported tool content part type: ${item.type}`
                    });
                    return void 0;
                  }
                }
              }).filter(isNonNullable);
              break;
          }
          input.push({
            type: "function_call_output",
            call_id: part.toolCallId,
            output: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { input, warnings };
}
function mapOpenAIResponseFinishReason({
  finishReason,
  hasFunctionCall
}) {
  switch (finishReason) {
    case void 0:
    case null:
      return hasFunctionCall ? "tool-calls" : "stop";
    case "max_output_tokens":
      return "length";
    case "content_filter":
      return "content-filter";
    default:
      return hasFunctionCall ? "tool-calls" : "other";
  }
}
async function prepareResponsesTools({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const openaiTools2 = [];
  for (const tool2 of tools) {
    switch (tool2.type) {
      case "function":
        openaiTools2.push({
          type: "function",
          name: tool2.name,
          description: tool2.description,
          parameters: tool2.inputSchema,
          ...tool2.strict != null ? { strict: tool2.strict } : {}
        });
        break;
      case "provider": {
        switch (tool2.id) {
          case "openai.file_search": {
            const args2 = await validateTypes({
              value: tool2.args,
              schema: fileSearchArgsSchema
            });
            openaiTools2.push({
              type: "file_search",
              vector_store_ids: args2.vectorStoreIds,
              max_num_results: args2.maxNumResults,
              ranking_options: args2.ranking ? {
                ranker: args2.ranking.ranker,
                score_threshold: args2.ranking.scoreThreshold
              } : void 0,
              filters: args2.filters
            });
            break;
          }
          case "openai.local_shell": {
            openaiTools2.push({
              type: "local_shell"
            });
            break;
          }
          case "openai.shell": {
            openaiTools2.push({
              type: "shell"
            });
            break;
          }
          case "openai.apply_patch": {
            openaiTools2.push({
              type: "apply_patch"
            });
            break;
          }
          case "openai.web_search_preview": {
            const args2 = await validateTypes({
              value: tool2.args,
              schema: webSearchPreviewArgsSchema
            });
            openaiTools2.push({
              type: "web_search_preview",
              search_context_size: args2.searchContextSize,
              user_location: args2.userLocation
            });
            break;
          }
          case "openai.web_search": {
            const args2 = await validateTypes({
              value: tool2.args,
              schema: webSearchArgsSchema
            });
            openaiTools2.push({
              type: "web_search",
              filters: args2.filters != null ? { allowed_domains: args2.filters.allowedDomains } : void 0,
              external_web_access: args2.externalWebAccess,
              search_context_size: args2.searchContextSize,
              user_location: args2.userLocation
            });
            break;
          }
          case "openai.code_interpreter": {
            const args2 = await validateTypes({
              value: tool2.args,
              schema: codeInterpreterArgsSchema
            });
            openaiTools2.push({
              type: "code_interpreter",
              container: args2.container == null ? { type: "auto", file_ids: void 0 } : typeof args2.container === "string" ? args2.container : { type: "auto", file_ids: args2.container.fileIds }
            });
            break;
          }
          case "openai.image_generation": {
            const args2 = await validateTypes({
              value: tool2.args,
              schema: imageGenerationArgsSchema
            });
            openaiTools2.push({
              type: "image_generation",
              background: args2.background,
              input_fidelity: args2.inputFidelity,
              input_image_mask: args2.inputImageMask ? {
                file_id: args2.inputImageMask.fileId,
                image_url: args2.inputImageMask.imageUrl
              } : void 0,
              model: args2.model,
              moderation: args2.moderation,
              partial_images: args2.partialImages,
              quality: args2.quality,
              output_compression: args2.outputCompression,
              output_format: args2.outputFormat,
              size: args2.size
            });
            break;
          }
          case "openai.mcp": {
            const args2 = await validateTypes({
              value: tool2.args,
              schema: mcpArgsSchema
            });
            const mapApprovalFilter = (filter3) => ({
              tool_names: filter3.toolNames
            });
            const requireApproval = args2.requireApproval;
            const requireApprovalParam = requireApproval == null ? void 0 : typeof requireApproval === "string" ? requireApproval : requireApproval.never != null ? { never: mapApprovalFilter(requireApproval.never) } : void 0;
            openaiTools2.push({
              type: "mcp",
              server_label: args2.serverLabel,
              allowed_tools: Array.isArray(args2.allowedTools) ? args2.allowedTools : args2.allowedTools ? {
                read_only: args2.allowedTools.readOnly,
                tool_names: args2.allowedTools.toolNames
              } : void 0,
              authorization: args2.authorization,
              connector_id: args2.connectorId,
              headers: args2.headers,
              require_approval: requireApprovalParam != null ? requireApprovalParam : "never",
              server_description: args2.serverDescription,
              server_url: args2.serverUrl
            });
            break;
          }
        }
        break;
      }
      default:
        toolWarnings.push({
          type: "unsupported",
          feature: `function tool ${tool2}`
        });
        break;
    }
  }
  if (toolChoice == null) {
    return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
  }
  const type2 = toolChoice.type;
  switch (type2) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiTools2, toolChoice: type2, toolWarnings };
    case "tool":
      return {
        tools: openaiTools2,
        toolChoice: toolChoice.toolName === "code_interpreter" || toolChoice.toolName === "file_search" || toolChoice.toolName === "image_generation" || toolChoice.toolName === "web_search_preview" || toolChoice.toolName === "web_search" || toolChoice.toolName === "mcp" || toolChoice.toolName === "apply_patch" ? { type: toolChoice.toolName } : { type: "function", name: toolChoice.toolName },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type2;
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function extractApprovalRequestIdToToolCallIdMapping(prompt) {
  var _a25, _b18;
  const mapping = {};
  for (const message of prompt) {
    if (message.role !== "assistant") continue;
    for (const part of message.content) {
      if (part.type !== "tool-call") continue;
      const approvalRequestId = (_b18 = (_a25 = part.providerOptions) == null ? void 0 : _a25.openai) == null ? void 0 : _b18.approvalRequestId;
      if (approvalRequestId != null) {
        mapping[approvalRequestId] = part.toolCallId;
      }
    }
  }
  return mapping;
}
function isTextDeltaChunk(chunk) {
  return chunk.type === "response.output_text.delta";
}
function isResponseOutputItemDoneChunk(chunk) {
  return chunk.type === "response.output_item.done";
}
function isResponseFinishedChunk(chunk) {
  return chunk.type === "response.completed" || chunk.type === "response.incomplete";
}
function isResponseCreatedChunk(chunk) {
  return chunk.type === "response.created";
}
function isResponseFunctionCallArgumentsDeltaChunk(chunk) {
  return chunk.type === "response.function_call_arguments.delta";
}
function isResponseImageGenerationCallPartialImageChunk(chunk) {
  return chunk.type === "response.image_generation_call.partial_image";
}
function isResponseCodeInterpreterCallCodeDeltaChunk(chunk) {
  return chunk.type === "response.code_interpreter_call_code.delta";
}
function isResponseCodeInterpreterCallCodeDoneChunk(chunk) {
  return chunk.type === "response.code_interpreter_call_code.done";
}
function isResponseApplyPatchCallOperationDiffDeltaChunk(chunk) {
  return chunk.type === "response.apply_patch_call_operation_diff.delta";
}
function isResponseApplyPatchCallOperationDiffDoneChunk(chunk) {
  return chunk.type === "response.apply_patch_call_operation_diff.done";
}
function isResponseOutputItemAddedChunk(chunk) {
  return chunk.type === "response.output_item.added";
}
function isResponseAnnotationAddedChunk(chunk) {
  return chunk.type === "response.output_text.annotation.added";
}
function isErrorChunk(chunk) {
  return chunk.type === "error";
}
function mapWebSearchOutput(action) {
  var _a25;
  switch (action.type) {
    case "search":
      return {
        action: { type: "search", query: (_a25 = action.query) != null ? _a25 : void 0 },
        // include sources when provided by the Responses API (behind include flag)
        ...action.sources != null && { sources: action.sources }
      };
    case "open_page":
      return { action: { type: "openPage", url: action.url } };
    case "find_in_page":
      return {
        action: {
          type: "findInPage",
          url: action.url,
          pattern: action.pattern
        }
      };
  }
}
function escapeJSONDelta(delta) {
  return JSON.stringify(delta).slice(1, -1);
}
function createOpenAI(options = {}) {
  var _a25, _b18;
  const baseURL = (_a25 = withoutTrailingSlash(
    loadOptionalSetting({
      settingValue: options.baseURL,
      environmentVariableName: "OPENAI_BASE_URL"
    })
  )) != null ? _a25 : "https://api.openai.com/v1";
  const providerName = (_b18 = options.name) != null ? _b18 : "openai";
  const getHeaders = () => withUserAgentSuffix(
    {
      Authorization: `Bearer ${loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "OPENAI_API_KEY",
        description: "OpenAI"
      })}`,
      "OpenAI-Organization": options.organization,
      "OpenAI-Project": options.project,
      ...options.headers
    },
    `ai-sdk/openai/${VERSION6}`
  );
  const createChatModel = (modelId) => new OpenAIChatLanguageModel(modelId, {
    provider: `${providerName}.chat`,
    url: ({ path: path24 }) => `${baseURL}${path24}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createCompletionModel = (modelId) => new OpenAICompletionLanguageModel(modelId, {
    provider: `${providerName}.completion`,
    url: ({ path: path24 }) => `${baseURL}${path24}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createEmbeddingModel = (modelId) => new OpenAIEmbeddingModel(modelId, {
    provider: `${providerName}.embedding`,
    url: ({ path: path24 }) => `${baseURL}${path24}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createImageModel = (modelId) => new OpenAIImageModel(modelId, {
    provider: `${providerName}.image`,
    url: ({ path: path24 }) => `${baseURL}${path24}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createTranscriptionModel = (modelId) => new OpenAITranscriptionModel(modelId, {
    provider: `${providerName}.transcription`,
    url: ({ path: path24 }) => `${baseURL}${path24}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createSpeechModel = (modelId) => new OpenAISpeechModel(modelId, {
    provider: `${providerName}.speech`,
    url: ({ path: path24 }) => `${baseURL}${path24}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createLanguageModel = (modelId) => {
    if (new.target) {
      throw new Error(
        "The OpenAI model function cannot be called with the new keyword."
      );
    }
    return createResponsesModel(modelId);
  };
  const createResponsesModel = (modelId) => {
    return new OpenAIResponsesLanguageModel(modelId, {
      provider: `${providerName}.responses`,
      url: ({ path: path24 }) => `${baseURL}${path24}`,
      headers: getHeaders,
      fetch: options.fetch,
      fileIdPrefixes: ["file-"]
    });
  };
  const provider = function(modelId) {
    return createLanguageModel(modelId);
  };
  provider.specificationVersion = "v3";
  provider.languageModel = createLanguageModel;
  provider.chat = createChatModel;
  provider.completion = createCompletionModel;
  provider.responses = createResponsesModel;
  provider.embedding = createEmbeddingModel;
  provider.embeddingModel = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  provider.transcription = createTranscriptionModel;
  provider.transcriptionModel = createTranscriptionModel;
  provider.speech = createSpeechModel;
  provider.speechModel = createSpeechModel;
  provider.tools = openaiTools;
  return provider;
}
var openaiErrorDataSchema, openaiFailedResponseHandler, openaiChatResponseSchema, openaiChatChunkSchema, openaiChatLanguageModelOptions, OpenAIChatLanguageModel, openaiCompletionResponseSchema, openaiCompletionChunkSchema, openaiCompletionProviderOptions, OpenAICompletionLanguageModel, openaiEmbeddingProviderOptions, openaiTextEmbeddingResponseSchema, OpenAIEmbeddingModel, openaiImageResponseSchema, modelMaxImagesPerCall, defaultResponseFormatPrefixes, OpenAIImageModel, applyPatchInputSchema, applyPatchOutputSchema, applyPatchArgsSchema, applyPatchToolFactory, applyPatch, codeInterpreterInputSchema, codeInterpreterOutputSchema, codeInterpreterArgsSchema, codeInterpreterToolFactory, codeInterpreter, comparisonFilterSchema, compoundFilterSchema, fileSearchArgsSchema, fileSearchOutputSchema, fileSearch, imageGenerationArgsSchema, imageGenerationInputSchema, imageGenerationOutputSchema, imageGenerationToolFactory, imageGeneration, localShellInputSchema, localShellOutputSchema, localShell, shellInputSchema, shellOutputSchema, shell, webSearchArgsSchema, webSearchInputSchema, webSearchOutputSchema, webSearchToolFactory, webSearch, webSearchPreviewArgsSchema, webSearchPreviewInputSchema, webSearchPreviewOutputSchema, webSearchPreview, jsonValueSchema2, mcpArgsSchema, mcpInputSchema, mcpOutputSchema, mcpToolFactory, mcp, openaiTools, openaiResponsesReasoningProviderOptionsSchema, openaiResponsesChunkSchema, openaiResponsesResponseSchema, TOP_LOGPROBS_MAX, openaiResponsesReasoningModelIds, openaiResponsesModelIds, openaiResponsesProviderOptionsSchema, OpenAIResponsesLanguageModel, openaiSpeechProviderOptionsSchema, OpenAISpeechModel, openaiTranscriptionResponseSchema, openAITranscriptionProviderOptions, languageMap, OpenAITranscriptionModel, VERSION6, openai;
var init_dist12 = __esm({
  "node_modules/@ai-sdk/openai/dist/index.mjs"() {
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    openaiErrorDataSchema = z20.object({
      error: z20.object({
        message: z20.string(),
        // The additional information below is handled loosely to support
        // OpenAI-compatible providers that have slightly different error
        // responses:
        type: z20.string().nullish(),
        param: z20.any().nullish(),
        code: z20.union([z20.string(), z20.number()]).nullish()
      })
    });
    openaiFailedResponseHandler = createJsonErrorResponseHandler({
      errorSchema: openaiErrorDataSchema,
      errorToMessage: (data) => data.error.message
    });
    openaiChatResponseSchema = lazySchema(
      () => zodSchema(
        z25.object({
          id: z25.string().nullish(),
          created: z25.number().nullish(),
          model: z25.string().nullish(),
          choices: z25.array(
            z25.object({
              message: z25.object({
                role: z25.literal("assistant").nullish(),
                content: z25.string().nullish(),
                tool_calls: z25.array(
                  z25.object({
                    id: z25.string().nullish(),
                    type: z25.literal("function"),
                    function: z25.object({
                      name: z25.string(),
                      arguments: z25.string()
                    })
                  })
                ).nullish(),
                annotations: z25.array(
                  z25.object({
                    type: z25.literal("url_citation"),
                    url_citation: z25.object({
                      start_index: z25.number(),
                      end_index: z25.number(),
                      url: z25.string(),
                      title: z25.string()
                    })
                  })
                ).nullish()
              }),
              index: z25.number(),
              logprobs: z25.object({
                content: z25.array(
                  z25.object({
                    token: z25.string(),
                    logprob: z25.number(),
                    top_logprobs: z25.array(
                      z25.object({
                        token: z25.string(),
                        logprob: z25.number()
                      })
                    )
                  })
                ).nullish()
              }).nullish(),
              finish_reason: z25.string().nullish()
            })
          ),
          usage: z25.object({
            prompt_tokens: z25.number().nullish(),
            completion_tokens: z25.number().nullish(),
            total_tokens: z25.number().nullish(),
            prompt_tokens_details: z25.object({
              cached_tokens: z25.number().nullish()
            }).nullish(),
            completion_tokens_details: z25.object({
              reasoning_tokens: z25.number().nullish(),
              accepted_prediction_tokens: z25.number().nullish(),
              rejected_prediction_tokens: z25.number().nullish()
            }).nullish()
          }).nullish()
        })
      )
    );
    openaiChatChunkSchema = lazySchema(
      () => zodSchema(
        z25.union([
          z25.object({
            id: z25.string().nullish(),
            created: z25.number().nullish(),
            model: z25.string().nullish(),
            choices: z25.array(
              z25.object({
                delta: z25.object({
                  role: z25.enum(["assistant"]).nullish(),
                  content: z25.string().nullish(),
                  tool_calls: z25.array(
                    z25.object({
                      index: z25.number(),
                      id: z25.string().nullish(),
                      type: z25.literal("function").nullish(),
                      function: z25.object({
                        name: z25.string().nullish(),
                        arguments: z25.string().nullish()
                      })
                    })
                  ).nullish(),
                  annotations: z25.array(
                    z25.object({
                      type: z25.literal("url_citation"),
                      url_citation: z25.object({
                        start_index: z25.number(),
                        end_index: z25.number(),
                        url: z25.string(),
                        title: z25.string()
                      })
                    })
                  ).nullish()
                }).nullish(),
                logprobs: z25.object({
                  content: z25.array(
                    z25.object({
                      token: z25.string(),
                      logprob: z25.number(),
                      top_logprobs: z25.array(
                        z25.object({
                          token: z25.string(),
                          logprob: z25.number()
                        })
                      )
                    })
                  ).nullish()
                }).nullish(),
                finish_reason: z25.string().nullish(),
                index: z25.number()
              })
            ),
            usage: z25.object({
              prompt_tokens: z25.number().nullish(),
              completion_tokens: z25.number().nullish(),
              total_tokens: z25.number().nullish(),
              prompt_tokens_details: z25.object({
                cached_tokens: z25.number().nullish()
              }).nullish(),
              completion_tokens_details: z25.object({
                reasoning_tokens: z25.number().nullish(),
                accepted_prediction_tokens: z25.number().nullish(),
                rejected_prediction_tokens: z25.number().nullish()
              }).nullish()
            }).nullish()
          }),
          openaiErrorDataSchema
        ])
      )
    );
    openaiChatLanguageModelOptions = lazySchema(
      () => zodSchema(
        z35.object({
          /**
           * Modify the likelihood of specified tokens appearing in the completion.
           *
           * Accepts a JSON object that maps tokens (specified by their token ID in
           * the GPT tokenizer) to an associated bias value from -100 to 100.
           */
          logitBias: z35.record(z35.coerce.number(), z35.number()).optional(),
          /**
           * Return the log probabilities of the tokens.
           *
           * Setting to true will return the log probabilities of the tokens that
           * were generated.
           *
           * Setting to a number will return the log probabilities of the top n
           * tokens that were generated.
           */
          logprobs: z35.union([z35.boolean(), z35.number()]).optional(),
          /**
           * Whether to enable parallel function calling during tool use. Default to true.
           */
          parallelToolCalls: z35.boolean().optional(),
          /**
           * A unique identifier representing your end-user, which can help OpenAI to
           * monitor and detect abuse.
           */
          user: z35.string().optional(),
          /**
           * Reasoning effort for reasoning models. Defaults to `medium`.
           */
          reasoningEffort: z35.enum(["none", "minimal", "low", "medium", "high", "xhigh"]).optional(),
          /**
           * Maximum number of completion tokens to generate. Useful for reasoning models.
           */
          maxCompletionTokens: z35.number().optional(),
          /**
           * Whether to enable persistence in responses API.
           */
          store: z35.boolean().optional(),
          /**
           * Metadata to associate with the request.
           */
          metadata: z35.record(z35.string().max(64), z35.string().max(512)).optional(),
          /**
           * Parameters for prediction mode.
           */
          prediction: z35.record(z35.string(), z35.any()).optional(),
          /**
           * Service tier for the request.
           * - 'auto': Default service tier. The request will be processed with the service tier configured in the
           *           Project settings. Unless otherwise configured, the Project will use 'default'.
           * - 'flex': 50% cheaper processing at the cost of increased latency. Only available for o3 and o4-mini models.
           * - 'priority': Higher-speed processing with predictably low latency at premium cost. Available for Enterprise customers.
           * - 'default': The request will be processed with the standard pricing and performance for the selected model.
           *
           * @default 'auto'
           */
          serviceTier: z35.enum(["auto", "flex", "priority", "default"]).optional(),
          /**
           * Whether to use strict JSON schema validation.
           *
           * @default true
           */
          strictJsonSchema: z35.boolean().optional(),
          /**
           * Controls the verbosity of the model's responses.
           * Lower values will result in more concise responses, while higher values will result in more verbose responses.
           */
          textVerbosity: z35.enum(["low", "medium", "high"]).optional(),
          /**
           * A cache key for prompt caching. Allows manual control over prompt caching behavior.
           * Useful for improving cache hit rates and working around automatic caching issues.
           */
          promptCacheKey: z35.string().optional(),
          /**
           * The retention policy for the prompt cache.
           * - 'in_memory': Default. Standard prompt caching behavior.
           * - '24h': Extended prompt caching that keeps cached prefixes active for up to 24 hours.
           *          Currently only available for 5.1 series models.
           *
           * @default 'in_memory'
           */
          promptCacheRetention: z35.enum(["in_memory", "24h"]).optional(),
          /**
           * A stable identifier used to help detect users of your application
           * that may be violating OpenAI's usage policies. The IDs should be a
           * string that uniquely identifies each user. We recommend hashing their
           * username or email address, in order to avoid sending us any identifying
           * information.
           */
          safetyIdentifier: z35.string().optional(),
          /**
           * Override the system message mode for this model.
           * - 'system': Use the 'system' role for system messages (default for most models)
           * - 'developer': Use the 'developer' role for system messages (used by reasoning models)
           * - 'remove': Remove system messages entirely
           *
           * If not specified, the mode is automatically determined based on the model.
           */
          systemMessageMode: z35.enum(["system", "developer", "remove"]).optional(),
          /**
           * Force treating this model as a reasoning model.
           *
           * This is useful for "stealth" reasoning models (e.g. via a custom baseURL)
           * where the model ID is not recognized by the SDK's allowlist.
           *
           * When enabled, the SDK applies reasoning-model parameter compatibility rules
           * and defaults `systemMessageMode` to `developer` unless overridden.
           */
          forceReasoning: z35.boolean().optional()
        })
      )
    );
    OpenAIChatLanguageModel = class {
      constructor(modelId, config2) {
        this.specificationVersion = "v3";
        this.supportedUrls = {
          "image/*": [/^https?:\/\/.*$/]
        };
        this.modelId = modelId;
        this.config = config2;
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        stopSequences,
        responseFormat,
        seed,
        tools,
        toolChoice,
        providerOptions
      }) {
        var _a25, _b18, _c, _d, _e;
        const warnings = [];
        const openaiOptions = (_a25 = await parseProviderOptions({
          provider: "openai",
          providerOptions,
          schema: openaiChatLanguageModelOptions
        })) != null ? _a25 : {};
        const modelCapabilities = getOpenAILanguageModelCapabilities(this.modelId);
        const isReasoningModel = (_b18 = openaiOptions.forceReasoning) != null ? _b18 : modelCapabilities.isReasoningModel;
        if (topK != null) {
          warnings.push({ type: "unsupported", feature: "topK" });
        }
        const { messages, warnings: messageWarnings } = convertToOpenAIChatMessages(
          {
            prompt,
            systemMessageMode: (_c = openaiOptions.systemMessageMode) != null ? _c : isReasoningModel ? "developer" : modelCapabilities.systemMessageMode
          }
        );
        warnings.push(...messageWarnings);
        const strictJsonSchema = (_d = openaiOptions.strictJsonSchema) != null ? _d : true;
        const baseArgs = {
          // model id:
          model: this.modelId,
          // model specific settings:
          logit_bias: openaiOptions.logitBias,
          logprobs: openaiOptions.logprobs === true || typeof openaiOptions.logprobs === "number" ? true : void 0,
          top_logprobs: typeof openaiOptions.logprobs === "number" ? openaiOptions.logprobs : typeof openaiOptions.logprobs === "boolean" ? openaiOptions.logprobs ? 0 : void 0 : void 0,
          user: openaiOptions.user,
          parallel_tool_calls: openaiOptions.parallelToolCalls,
          // standardized settings:
          max_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          frequency_penalty: frequencyPenalty,
          presence_penalty: presencePenalty,
          response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? responseFormat.schema != null ? {
            type: "json_schema",
            json_schema: {
              schema: responseFormat.schema,
              strict: strictJsonSchema,
              name: (_e = responseFormat.name) != null ? _e : "response",
              description: responseFormat.description
            }
          } : { type: "json_object" } : void 0,
          stop: stopSequences,
          seed,
          verbosity: openaiOptions.textVerbosity,
          // openai specific settings:
          // TODO AI SDK 6: remove, we auto-map maxOutputTokens now
          max_completion_tokens: openaiOptions.maxCompletionTokens,
          store: openaiOptions.store,
          metadata: openaiOptions.metadata,
          prediction: openaiOptions.prediction,
          reasoning_effort: openaiOptions.reasoningEffort,
          service_tier: openaiOptions.serviceTier,
          prompt_cache_key: openaiOptions.promptCacheKey,
          prompt_cache_retention: openaiOptions.promptCacheRetention,
          safety_identifier: openaiOptions.safetyIdentifier,
          // messages:
          messages
        };
        if (isReasoningModel) {
          if (openaiOptions.reasoningEffort !== "none" || !modelCapabilities.supportsNonReasoningParameters) {
            if (baseArgs.temperature != null) {
              baseArgs.temperature = void 0;
              warnings.push({
                type: "unsupported",
                feature: "temperature",
                details: "temperature is not supported for reasoning models"
              });
            }
            if (baseArgs.top_p != null) {
              baseArgs.top_p = void 0;
              warnings.push({
                type: "unsupported",
                feature: "topP",
                details: "topP is not supported for reasoning models"
              });
            }
            if (baseArgs.logprobs != null) {
              baseArgs.logprobs = void 0;
              warnings.push({
                type: "other",
                message: "logprobs is not supported for reasoning models"
              });
            }
          }
          if (baseArgs.frequency_penalty != null) {
            baseArgs.frequency_penalty = void 0;
            warnings.push({
              type: "unsupported",
              feature: "frequencyPenalty",
              details: "frequencyPenalty is not supported for reasoning models"
            });
          }
          if (baseArgs.presence_penalty != null) {
            baseArgs.presence_penalty = void 0;
            warnings.push({
              type: "unsupported",
              feature: "presencePenalty",
              details: "presencePenalty is not supported for reasoning models"
            });
          }
          if (baseArgs.logit_bias != null) {
            baseArgs.logit_bias = void 0;
            warnings.push({
              type: "other",
              message: "logitBias is not supported for reasoning models"
            });
          }
          if (baseArgs.top_logprobs != null) {
            baseArgs.top_logprobs = void 0;
            warnings.push({
              type: "other",
              message: "topLogprobs is not supported for reasoning models"
            });
          }
          if (baseArgs.max_tokens != null) {
            if (baseArgs.max_completion_tokens == null) {
              baseArgs.max_completion_tokens = baseArgs.max_tokens;
            }
            baseArgs.max_tokens = void 0;
          }
        } else if (this.modelId.startsWith("gpt-4o-search-preview") || this.modelId.startsWith("gpt-4o-mini-search-preview")) {
          if (baseArgs.temperature != null) {
            baseArgs.temperature = void 0;
            warnings.push({
              type: "unsupported",
              feature: "temperature",
              details: "temperature is not supported for the search preview models and has been removed."
            });
          }
        }
        if (openaiOptions.serviceTier === "flex" && !modelCapabilities.supportsFlexProcessing) {
          warnings.push({
            type: "unsupported",
            feature: "serviceTier",
            details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
          });
          baseArgs.service_tier = void 0;
        }
        if (openaiOptions.serviceTier === "priority" && !modelCapabilities.supportsPriorityProcessing) {
          warnings.push({
            type: "unsupported",
            feature: "serviceTier",
            details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
          });
          baseArgs.service_tier = void 0;
        }
        const {
          tools: openaiTools2,
          toolChoice: openaiToolChoice,
          toolWarnings
        } = prepareChatTools({
          tools,
          toolChoice
        });
        return {
          args: {
            ...baseArgs,
            tools: openaiTools2,
            tool_choice: openaiToolChoice
          },
          warnings: [...warnings, ...toolWarnings]
        };
      }
      async doGenerate(options) {
        var _a25, _b18, _c, _d, _e, _f, _g;
        const { args: body, warnings } = await this.getArgs(options);
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi({
          url: this.config.url({
            path: "/chat/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body,
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            openaiChatResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const choice2 = response.choices[0];
        const content = [];
        const text2 = choice2.message.content;
        if (text2 != null && text2.length > 0) {
          content.push({ type: "text", text: text2 });
        }
        for (const toolCall of (_a25 = choice2.message.tool_calls) != null ? _a25 : []) {
          content.push({
            type: "tool-call",
            toolCallId: (_b18 = toolCall.id) != null ? _b18 : generateId(),
            toolName: toolCall.function.name,
            input: toolCall.function.arguments
          });
        }
        for (const annotation of (_c = choice2.message.annotations) != null ? _c : []) {
          content.push({
            type: "source",
            sourceType: "url",
            id: generateId(),
            url: annotation.url_citation.url,
            title: annotation.url_citation.title
          });
        }
        const completionTokenDetails = (_d = response.usage) == null ? void 0 : _d.completion_tokens_details;
        const promptTokenDetails = (_e = response.usage) == null ? void 0 : _e.prompt_tokens_details;
        const providerMetadata = { openai: {} };
        if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
          providerMetadata.openai.acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
        }
        if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
          providerMetadata.openai.rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
        }
        if (((_f = choice2.logprobs) == null ? void 0 : _f.content) != null) {
          providerMetadata.openai.logprobs = choice2.logprobs.content;
        }
        return {
          content,
          finishReason: {
            unified: mapOpenAIFinishReason(choice2.finish_reason),
            raw: (_g = choice2.finish_reason) != null ? _g : void 0
          },
          usage: convertOpenAIChatUsage(response.usage),
          request: { body },
          response: {
            ...getResponseMetadata(response),
            headers: responseHeaders,
            body: rawResponse
          },
          warnings,
          providerMetadata
        };
      }
      async doStream(options) {
        const { args: args2, warnings } = await this.getArgs(options);
        const body = {
          ...args2,
          stream: true,
          stream_options: {
            include_usage: true
          }
        };
        const { responseHeaders, value: response } = await postJsonToApi({
          url: this.config.url({
            path: "/chat/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body,
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler(
            openaiChatChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const toolCalls = [];
        let finishReason = {
          unified: "other",
          raw: void 0
        };
        let usage = void 0;
        let metadataExtracted = false;
        let isActiveText = false;
        const providerMetadata = { openai: {} };
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                var _a25, _b18, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  finishReason = { unified: "error", raw: void 0 };
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value2 = chunk.value;
                if ("error" in value2) {
                  finishReason = { unified: "error", raw: void 0 };
                  controller.enqueue({ type: "error", error: value2.error });
                  return;
                }
                if (!metadataExtracted) {
                  const metadata = getResponseMetadata(value2);
                  if (Object.values(metadata).some(Boolean)) {
                    metadataExtracted = true;
                    controller.enqueue({
                      type: "response-metadata",
                      ...getResponseMetadata(value2)
                    });
                  }
                }
                if (value2.usage != null) {
                  usage = value2.usage;
                  if (((_a25 = value2.usage.completion_tokens_details) == null ? void 0 : _a25.accepted_prediction_tokens) != null) {
                    providerMetadata.openai.acceptedPredictionTokens = (_b18 = value2.usage.completion_tokens_details) == null ? void 0 : _b18.accepted_prediction_tokens;
                  }
                  if (((_c = value2.usage.completion_tokens_details) == null ? void 0 : _c.rejected_prediction_tokens) != null) {
                    providerMetadata.openai.rejectedPredictionTokens = (_d = value2.usage.completion_tokens_details) == null ? void 0 : _d.rejected_prediction_tokens;
                  }
                }
                const choice2 = value2.choices[0];
                if ((choice2 == null ? void 0 : choice2.finish_reason) != null) {
                  finishReason = {
                    unified: mapOpenAIFinishReason(choice2.finish_reason),
                    raw: choice2.finish_reason
                  };
                }
                if (((_e = choice2 == null ? void 0 : choice2.logprobs) == null ? void 0 : _e.content) != null) {
                  providerMetadata.openai.logprobs = choice2.logprobs.content;
                }
                if ((choice2 == null ? void 0 : choice2.delta) == null) {
                  return;
                }
                const delta = choice2.delta;
                if (delta.content != null) {
                  if (!isActiveText) {
                    controller.enqueue({ type: "text-start", id: "0" });
                    isActiveText = true;
                  }
                  controller.enqueue({
                    type: "text-delta",
                    id: "0",
                    delta: delta.content
                  });
                }
                if (delta.tool_calls != null) {
                  for (const toolCallDelta of delta.tool_calls) {
                    const index = toolCallDelta.index;
                    if (toolCalls[index] == null) {
                      if (toolCallDelta.type !== "function") {
                        throw new InvalidResponseDataError({
                          data: toolCallDelta,
                          message: `Expected 'function' type.`
                        });
                      }
                      if (toolCallDelta.id == null) {
                        throw new InvalidResponseDataError({
                          data: toolCallDelta,
                          message: `Expected 'id' to be a string.`
                        });
                      }
                      if (((_f = toolCallDelta.function) == null ? void 0 : _f.name) == null) {
                        throw new InvalidResponseDataError({
                          data: toolCallDelta,
                          message: `Expected 'function.name' to be a string.`
                        });
                      }
                      controller.enqueue({
                        type: "tool-input-start",
                        id: toolCallDelta.id,
                        toolName: toolCallDelta.function.name
                      });
                      toolCalls[index] = {
                        id: toolCallDelta.id,
                        type: "function",
                        function: {
                          name: toolCallDelta.function.name,
                          arguments: (_g = toolCallDelta.function.arguments) != null ? _g : ""
                        },
                        hasFinished: false
                      };
                      const toolCall2 = toolCalls[index];
                      if (((_h = toolCall2.function) == null ? void 0 : _h.name) != null && ((_i = toolCall2.function) == null ? void 0 : _i.arguments) != null) {
                        if (toolCall2.function.arguments.length > 0) {
                          controller.enqueue({
                            type: "tool-input-delta",
                            id: toolCall2.id,
                            delta: toolCall2.function.arguments
                          });
                        }
                        if (isParsableJson(toolCall2.function.arguments)) {
                          controller.enqueue({
                            type: "tool-input-end",
                            id: toolCall2.id
                          });
                          controller.enqueue({
                            type: "tool-call",
                            toolCallId: (_j = toolCall2.id) != null ? _j : generateId(),
                            toolName: toolCall2.function.name,
                            input: toolCall2.function.arguments
                          });
                          toolCall2.hasFinished = true;
                        }
                      }
                      continue;
                    }
                    const toolCall = toolCalls[index];
                    if (toolCall.hasFinished) {
                      continue;
                    }
                    if (((_k = toolCallDelta.function) == null ? void 0 : _k.arguments) != null) {
                      toolCall.function.arguments += (_m = (_l = toolCallDelta.function) == null ? void 0 : _l.arguments) != null ? _m : "";
                    }
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.id,
                      delta: (_n = toolCallDelta.function.arguments) != null ? _n : ""
                    });
                    if (((_o = toolCall.function) == null ? void 0 : _o.name) != null && ((_p = toolCall.function) == null ? void 0 : _p.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                      controller.enqueue({
                        type: "tool-input-end",
                        id: toolCall.id
                      });
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: (_q = toolCall.id) != null ? _q : generateId(),
                        toolName: toolCall.function.name,
                        input: toolCall.function.arguments
                      });
                      toolCall.hasFinished = true;
                    }
                  }
                }
                if (delta.annotations != null) {
                  for (const annotation of delta.annotations) {
                    controller.enqueue({
                      type: "source",
                      sourceType: "url",
                      id: generateId(),
                      url: annotation.url_citation.url,
                      title: annotation.url_citation.title
                    });
                  }
                }
              },
              flush(controller) {
                if (isActiveText) {
                  controller.enqueue({ type: "text-end", id: "0" });
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage: convertOpenAIChatUsage(usage),
                  ...providerMetadata != null ? { providerMetadata } : {}
                });
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    openaiCompletionResponseSchema = lazySchema(
      () => zodSchema(
        z46.object({
          id: z46.string().nullish(),
          created: z46.number().nullish(),
          model: z46.string().nullish(),
          choices: z46.array(
            z46.object({
              text: z46.string(),
              finish_reason: z46.string(),
              logprobs: z46.object({
                tokens: z46.array(z46.string()),
                token_logprobs: z46.array(z46.number()),
                top_logprobs: z46.array(z46.record(z46.string(), z46.number())).nullish()
              }).nullish()
            })
          ),
          usage: z46.object({
            prompt_tokens: z46.number(),
            completion_tokens: z46.number(),
            total_tokens: z46.number()
          }).nullish()
        })
      )
    );
    openaiCompletionChunkSchema = lazySchema(
      () => zodSchema(
        z46.union([
          z46.object({
            id: z46.string().nullish(),
            created: z46.number().nullish(),
            model: z46.string().nullish(),
            choices: z46.array(
              z46.object({
                text: z46.string(),
                finish_reason: z46.string().nullish(),
                index: z46.number(),
                logprobs: z46.object({
                  tokens: z46.array(z46.string()),
                  token_logprobs: z46.array(z46.number()),
                  top_logprobs: z46.array(z46.record(z46.string(), z46.number())).nullish()
                }).nullish()
              })
            ),
            usage: z46.object({
              prompt_tokens: z46.number(),
              completion_tokens: z46.number(),
              total_tokens: z46.number()
            }).nullish()
          }),
          openaiErrorDataSchema
        ])
      )
    );
    openaiCompletionProviderOptions = lazySchema(
      () => zodSchema(
        z55.object({
          /**
           * Echo back the prompt in addition to the completion.
           */
          echo: z55.boolean().optional(),
          /**
           * Modify the likelihood of specified tokens appearing in the completion.
           *
           * Accepts a JSON object that maps tokens (specified by their token ID in
           * the GPT tokenizer) to an associated bias value from -100 to 100. You
           * can use this tokenizer tool to convert text to token IDs. Mathematically,
           * the bias is added to the logits generated by the model prior to sampling.
           * The exact effect will vary per model, but values between -1 and 1 should
           * decrease or increase likelihood of selection; values like -100 or 100
           * should result in a ban or exclusive selection of the relevant token.
           *
           * As an example, you can pass {"50256": -100} to prevent the <|endoftext|>
           * token from being generated.
           */
          logitBias: z55.record(z55.string(), z55.number()).optional(),
          /**
           * The suffix that comes after a completion of inserted text.
           */
          suffix: z55.string().optional(),
          /**
           * A unique identifier representing your end-user, which can help OpenAI to
           * monitor and detect abuse. Learn more.
           */
          user: z55.string().optional(),
          /**
           * Return the log probabilities of the tokens. Including logprobs will increase
           * the response size and can slow down response times. However, it can
           * be useful to better understand how the model is behaving.
           * Setting to true will return the log probabilities of the tokens that
           * were generated.
           * Setting to a number will return the log probabilities of the top n
           * tokens that were generated.
           */
          logprobs: z55.union([z55.boolean(), z55.number()]).optional()
        })
      )
    );
    OpenAICompletionLanguageModel = class {
      constructor(modelId, config2) {
        this.specificationVersion = "v3";
        this.supportedUrls = {
          // No URLs are supported for completion models.
        };
        this.modelId = modelId;
        this.config = config2;
      }
      get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        stopSequences: userStopSequences,
        responseFormat,
        tools,
        toolChoice,
        seed,
        providerOptions
      }) {
        const warnings = [];
        const openaiOptions = {
          ...await parseProviderOptions({
            provider: "openai",
            providerOptions,
            schema: openaiCompletionProviderOptions
          }),
          ...await parseProviderOptions({
            provider: this.providerOptionsName,
            providerOptions,
            schema: openaiCompletionProviderOptions
          })
        };
        if (topK != null) {
          warnings.push({ type: "unsupported", feature: "topK" });
        }
        if (tools == null ? void 0 : tools.length) {
          warnings.push({ type: "unsupported", feature: "tools" });
        }
        if (toolChoice != null) {
          warnings.push({ type: "unsupported", feature: "toolChoice" });
        }
        if (responseFormat != null && responseFormat.type !== "text") {
          warnings.push({
            type: "unsupported",
            feature: "responseFormat",
            details: "JSON response format is not supported."
          });
        }
        const { prompt: completionPrompt, stopSequences } = convertToOpenAICompletionPrompt({ prompt });
        const stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
        return {
          args: {
            // model id:
            model: this.modelId,
            // model specific settings:
            echo: openaiOptions.echo,
            logit_bias: openaiOptions.logitBias,
            logprobs: (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? 0 : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === false ? void 0 : openaiOptions == null ? void 0 : openaiOptions.logprobs,
            suffix: openaiOptions.suffix,
            user: openaiOptions.user,
            // standardized settings:
            max_tokens: maxOutputTokens,
            temperature,
            top_p: topP,
            frequency_penalty: frequencyPenalty,
            presence_penalty: presencePenalty,
            seed,
            // prompt:
            prompt: completionPrompt,
            // stop sequences:
            stop: stop.length > 0 ? stop : void 0
          },
          warnings
        };
      }
      async doGenerate(options) {
        var _a25;
        const { args: args2, warnings } = await this.getArgs(options);
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi({
          url: this.config.url({
            path: "/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body: args2,
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            openaiCompletionResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const choice2 = response.choices[0];
        const providerMetadata = { openai: {} };
        if (choice2.logprobs != null) {
          providerMetadata.openai.logprobs = choice2.logprobs;
        }
        return {
          content: [{ type: "text", text: choice2.text }],
          usage: convertOpenAICompletionUsage(response.usage),
          finishReason: {
            unified: mapOpenAIFinishReason2(choice2.finish_reason),
            raw: (_a25 = choice2.finish_reason) != null ? _a25 : void 0
          },
          request: { body: args2 },
          response: {
            ...getResponseMetadata2(response),
            headers: responseHeaders,
            body: rawResponse
          },
          providerMetadata,
          warnings
        };
      }
      async doStream(options) {
        const { args: args2, warnings } = await this.getArgs(options);
        const body = {
          ...args2,
          stream: true,
          stream_options: {
            include_usage: true
          }
        };
        const { responseHeaders, value: response } = await postJsonToApi({
          url: this.config.url({
            path: "/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body,
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler(
            openaiCompletionChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        let finishReason = {
          unified: "other",
          raw: void 0
        };
        const providerMetadata = { openai: {} };
        let usage = void 0;
        let isFirstChunk = true;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  finishReason = { unified: "error", raw: void 0 };
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value2 = chunk.value;
                if ("error" in value2) {
                  finishReason = { unified: "error", raw: void 0 };
                  controller.enqueue({ type: "error", error: value2.error });
                  return;
                }
                if (isFirstChunk) {
                  isFirstChunk = false;
                  controller.enqueue({
                    type: "response-metadata",
                    ...getResponseMetadata2(value2)
                  });
                  controller.enqueue({ type: "text-start", id: "0" });
                }
                if (value2.usage != null) {
                  usage = value2.usage;
                }
                const choice2 = value2.choices[0];
                if ((choice2 == null ? void 0 : choice2.finish_reason) != null) {
                  finishReason = {
                    unified: mapOpenAIFinishReason2(choice2.finish_reason),
                    raw: choice2.finish_reason
                  };
                }
                if ((choice2 == null ? void 0 : choice2.logprobs) != null) {
                  providerMetadata.openai.logprobs = choice2.logprobs;
                }
                if ((choice2 == null ? void 0 : choice2.text) != null && choice2.text.length > 0) {
                  controller.enqueue({
                    type: "text-delta",
                    id: "0",
                    delta: choice2.text
                  });
                }
              },
              flush(controller) {
                if (!isFirstChunk) {
                  controller.enqueue({ type: "text-end", id: "0" });
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  providerMetadata,
                  usage: convertOpenAICompletionUsage(usage)
                });
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    openaiEmbeddingProviderOptions = lazySchema(
      () => zodSchema(
        z65.object({
          /**
           * The number of dimensions the resulting output embeddings should have.
           * Only supported in text-embedding-3 and later models.
           */
          dimensions: z65.number().optional(),
          /**
           * A unique identifier representing your end-user, which can help OpenAI to
           * monitor and detect abuse. Learn more.
           */
          user: z65.string().optional()
        })
      )
    );
    openaiTextEmbeddingResponseSchema = lazySchema(
      () => zodSchema(
        z75.object({
          data: z75.array(z75.object({ embedding: z75.array(z75.number()) })),
          usage: z75.object({ prompt_tokens: z75.number() }).nullish()
        })
      )
    );
    OpenAIEmbeddingModel = class {
      constructor(modelId, config2) {
        this.specificationVersion = "v3";
        this.maxEmbeddingsPerCall = 2048;
        this.supportsParallelCalls = true;
        this.modelId = modelId;
        this.config = config2;
      }
      get provider() {
        return this.config.provider;
      }
      async doEmbed({
        values,
        headers,
        abortSignal,
        providerOptions
      }) {
        var _a25;
        if (values.length > this.maxEmbeddingsPerCall) {
          throw new TooManyEmbeddingValuesForCallError({
            provider: this.provider,
            modelId: this.modelId,
            maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
            values
          });
        }
        const openaiOptions = (_a25 = await parseProviderOptions({
          provider: "openai",
          providerOptions,
          schema: openaiEmbeddingProviderOptions
        })) != null ? _a25 : {};
        const {
          responseHeaders,
          value: response,
          rawValue
        } = await postJsonToApi({
          url: this.config.url({
            path: "/embeddings",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), headers),
          body: {
            model: this.modelId,
            input: values,
            encoding_format: "float",
            dimensions: openaiOptions.dimensions,
            user: openaiOptions.user
          },
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            openaiTextEmbeddingResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          warnings: [],
          embeddings: response.data.map((item) => item.embedding),
          usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
          response: { headers: responseHeaders, body: rawValue }
        };
      }
    };
    openaiImageResponseSchema = lazySchema(
      () => zodSchema(
        z85.object({
          created: z85.number().nullish(),
          data: z85.array(
            z85.object({
              b64_json: z85.string(),
              revised_prompt: z85.string().nullish()
            })
          ),
          background: z85.string().nullish(),
          output_format: z85.string().nullish(),
          size: z85.string().nullish(),
          quality: z85.string().nullish(),
          usage: z85.object({
            input_tokens: z85.number().nullish(),
            output_tokens: z85.number().nullish(),
            total_tokens: z85.number().nullish(),
            input_tokens_details: z85.object({
              image_tokens: z85.number().nullish(),
              text_tokens: z85.number().nullish()
            }).nullish()
          }).nullish()
        })
      )
    );
    modelMaxImagesPerCall = {
      "dall-e-3": 1,
      "dall-e-2": 10,
      "gpt-image-1": 10,
      "gpt-image-1-mini": 10,
      "gpt-image-1.5": 10
    };
    defaultResponseFormatPrefixes = [
      "gpt-image-1-mini",
      "gpt-image-1.5",
      "gpt-image-1"
    ];
    OpenAIImageModel = class {
      constructor(modelId, config2) {
        this.modelId = modelId;
        this.config = config2;
        this.specificationVersion = "v3";
      }
      get maxImagesPerCall() {
        var _a25;
        return (_a25 = modelMaxImagesPerCall[this.modelId]) != null ? _a25 : 1;
      }
      get provider() {
        return this.config.provider;
      }
      async doGenerate({
        prompt,
        files,
        mask,
        n,
        size,
        aspectRatio,
        seed,
        providerOptions,
        headers,
        abortSignal
      }) {
        var _a25, _b18, _c, _d, _e, _f, _g, _h, _i, _j, _k;
        const warnings = [];
        if (aspectRatio != null) {
          warnings.push({
            type: "unsupported",
            feature: "aspectRatio",
            details: "This model does not support aspect ratio. Use `size` instead."
          });
        }
        if (seed != null) {
          warnings.push({ type: "unsupported", feature: "seed" });
        }
        const currentDate = (_c = (_b18 = (_a25 = this.config._internal) == null ? void 0 : _a25.currentDate) == null ? void 0 : _b18.call(_a25)) != null ? _c : /* @__PURE__ */ new Date();
        if (files != null) {
          const { value: response2, responseHeaders: responseHeaders2 } = await postFormDataToApi({
            url: this.config.url({
              path: "/images/edits",
              modelId: this.modelId
            }),
            headers: combineHeaders(this.config.headers(), headers),
            formData: convertToFormData({
              model: this.modelId,
              prompt,
              image: await Promise.all(
                files.map(
                  (file) => file.type === "file" ? new Blob(
                    [
                      file.data instanceof Uint8Array ? new Blob([file.data], {
                        type: file.mediaType
                      }) : new Blob([convertBase64ToUint8Array(file.data)], {
                        type: file.mediaType
                      })
                    ],
                    { type: file.mediaType }
                  ) : downloadBlob(file.url)
                )
              ),
              mask: mask != null ? await fileToBlob(mask) : void 0,
              n,
              size,
              ...(_d = providerOptions.openai) != null ? _d : {}
            }),
            failedResponseHandler: openaiFailedResponseHandler,
            successfulResponseHandler: createJsonResponseHandler(
              openaiImageResponseSchema
            ),
            abortSignal,
            fetch: this.config.fetch
          });
          return {
            images: response2.data.map((item) => item.b64_json),
            warnings,
            usage: response2.usage != null ? {
              inputTokens: (_e = response2.usage.input_tokens) != null ? _e : void 0,
              outputTokens: (_f = response2.usage.output_tokens) != null ? _f : void 0,
              totalTokens: (_g = response2.usage.total_tokens) != null ? _g : void 0
            } : void 0,
            response: {
              timestamp: currentDate,
              modelId: this.modelId,
              headers: responseHeaders2
            },
            providerMetadata: {
              openai: {
                images: response2.data.map((item) => {
                  var _a26, _b24, _c2, _d2, _e2;
                  return {
                    ...item.revised_prompt ? { revisedPrompt: item.revised_prompt } : {},
                    created: (_a26 = response2.created) != null ? _a26 : void 0,
                    size: (_b24 = response2.size) != null ? _b24 : void 0,
                    quality: (_c2 = response2.quality) != null ? _c2 : void 0,
                    background: (_d2 = response2.background) != null ? _d2 : void 0,
                    outputFormat: (_e2 = response2.output_format) != null ? _e2 : void 0
                  };
                })
              }
            }
          };
        }
        const { value: response, responseHeaders } = await postJsonToApi({
          url: this.config.url({
            path: "/images/generations",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), headers),
          body: {
            model: this.modelId,
            prompt,
            n,
            size,
            ...(_h = providerOptions.openai) != null ? _h : {},
            ...!hasDefaultResponseFormat(this.modelId) ? { response_format: "b64_json" } : {}
          },
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            openaiImageResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          images: response.data.map((item) => item.b64_json),
          warnings,
          usage: response.usage != null ? {
            inputTokens: (_i = response.usage.input_tokens) != null ? _i : void 0,
            outputTokens: (_j = response.usage.output_tokens) != null ? _j : void 0,
            totalTokens: (_k = response.usage.total_tokens) != null ? _k : void 0
          } : void 0,
          response: {
            timestamp: currentDate,
            modelId: this.modelId,
            headers: responseHeaders
          },
          providerMetadata: {
            openai: {
              images: response.data.map((item) => {
                var _a26, _b24, _c2, _d2, _e2;
                return {
                  ...item.revised_prompt ? { revisedPrompt: item.revised_prompt } : {},
                  created: (_a26 = response.created) != null ? _a26 : void 0,
                  size: (_b24 = response.size) != null ? _b24 : void 0,
                  quality: (_c2 = response.quality) != null ? _c2 : void 0,
                  background: (_d2 = response.background) != null ? _d2 : void 0,
                  outputFormat: (_e2 = response.output_format) != null ? _e2 : void 0
                };
              })
            }
          }
        };
      }
    };
    applyPatchInputSchema = lazySchema(
      () => zodSchema(
        z94.object({
          callId: z94.string(),
          operation: z94.discriminatedUnion("type", [
            z94.object({
              type: z94.literal("create_file"),
              path: z94.string(),
              diff: z94.string()
            }),
            z94.object({
              type: z94.literal("delete_file"),
              path: z94.string()
            }),
            z94.object({
              type: z94.literal("update_file"),
              path: z94.string(),
              diff: z94.string()
            })
          ])
        })
      )
    );
    applyPatchOutputSchema = lazySchema(
      () => zodSchema(
        z94.object({
          status: z94.enum(["completed", "failed"]),
          output: z94.string().optional()
        })
      )
    );
    applyPatchArgsSchema = lazySchema(() => zodSchema(z94.object({})));
    applyPatchToolFactory = createProviderToolFactoryWithOutputSchema({
      id: "openai.apply_patch",
      inputSchema: applyPatchInputSchema,
      outputSchema: applyPatchOutputSchema
    });
    applyPatch = applyPatchToolFactory;
    codeInterpreterInputSchema = lazySchema(
      () => zodSchema(
        z104.object({
          code: z104.string().nullish(),
          containerId: z104.string()
        })
      )
    );
    codeInterpreterOutputSchema = lazySchema(
      () => zodSchema(
        z104.object({
          outputs: z104.array(
            z104.discriminatedUnion("type", [
              z104.object({ type: z104.literal("logs"), logs: z104.string() }),
              z104.object({ type: z104.literal("image"), url: z104.string() })
            ])
          ).nullish()
        })
      )
    );
    codeInterpreterArgsSchema = lazySchema(
      () => zodSchema(
        z104.object({
          container: z104.union([
            z104.string(),
            z104.object({
              fileIds: z104.array(z104.string()).optional()
            })
          ]).optional()
        })
      )
    );
    codeInterpreterToolFactory = createProviderToolFactoryWithOutputSchema({
      id: "openai.code_interpreter",
      inputSchema: codeInterpreterInputSchema,
      outputSchema: codeInterpreterOutputSchema
    });
    codeInterpreter = (args2 = {}) => {
      return codeInterpreterToolFactory(args2);
    };
    comparisonFilterSchema = z113.object({
      key: z113.string(),
      type: z113.enum(["eq", "ne", "gt", "gte", "lt", "lte", "in", "nin"]),
      value: z113.union([z113.string(), z113.number(), z113.boolean(), z113.array(z113.string())])
    });
    compoundFilterSchema = z113.object({
      type: z113.enum(["and", "or"]),
      filters: z113.array(
        z113.union([comparisonFilterSchema, z113.lazy(() => compoundFilterSchema)])
      )
    });
    fileSearchArgsSchema = lazySchema(
      () => zodSchema(
        z113.object({
          vectorStoreIds: z113.array(z113.string()),
          maxNumResults: z113.number().optional(),
          ranking: z113.object({
            ranker: z113.string().optional(),
            scoreThreshold: z113.number().optional()
          }).optional(),
          filters: z113.union([comparisonFilterSchema, compoundFilterSchema]).optional()
        })
      )
    );
    fileSearchOutputSchema = lazySchema(
      () => zodSchema(
        z113.object({
          queries: z113.array(z113.string()),
          results: z113.array(
            z113.object({
              attributes: z113.record(z113.string(), z113.unknown()),
              fileId: z113.string(),
              filename: z113.string(),
              score: z113.number(),
              text: z113.string()
            })
          ).nullable()
        })
      )
    );
    fileSearch = createProviderToolFactoryWithOutputSchema({
      id: "openai.file_search",
      inputSchema: z113.object({}),
      outputSchema: fileSearchOutputSchema
    });
    imageGenerationArgsSchema = lazySchema(
      () => zodSchema(
        z123.object({
          background: z123.enum(["auto", "opaque", "transparent"]).optional(),
          inputFidelity: z123.enum(["low", "high"]).optional(),
          inputImageMask: z123.object({
            fileId: z123.string().optional(),
            imageUrl: z123.string().optional()
          }).optional(),
          model: z123.string().optional(),
          moderation: z123.enum(["auto"]).optional(),
          outputCompression: z123.number().int().min(0).max(100).optional(),
          outputFormat: z123.enum(["png", "jpeg", "webp"]).optional(),
          partialImages: z123.number().int().min(0).max(3).optional(),
          quality: z123.enum(["auto", "low", "medium", "high"]).optional(),
          size: z123.enum(["1024x1024", "1024x1536", "1536x1024", "auto"]).optional()
        }).strict()
      )
    );
    imageGenerationInputSchema = lazySchema(() => zodSchema(z123.object({})));
    imageGenerationOutputSchema = lazySchema(
      () => zodSchema(z123.object({ result: z123.string() }))
    );
    imageGenerationToolFactory = createProviderToolFactoryWithOutputSchema({
      id: "openai.image_generation",
      inputSchema: imageGenerationInputSchema,
      outputSchema: imageGenerationOutputSchema
    });
    imageGeneration = (args2 = {}) => {
      return imageGenerationToolFactory(args2);
    };
    localShellInputSchema = lazySchema(
      () => zodSchema(
        z133.object({
          action: z133.object({
            type: z133.literal("exec"),
            command: z133.array(z133.string()),
            timeoutMs: z133.number().optional(),
            user: z133.string().optional(),
            workingDirectory: z133.string().optional(),
            env: z133.record(z133.string(), z133.string()).optional()
          })
        })
      )
    );
    localShellOutputSchema = lazySchema(
      () => zodSchema(z133.object({ output: z133.string() }))
    );
    localShell = createProviderToolFactoryWithOutputSchema({
      id: "openai.local_shell",
      inputSchema: localShellInputSchema,
      outputSchema: localShellOutputSchema
    });
    shellInputSchema = lazySchema(
      () => zodSchema(
        z143.object({
          action: z143.object({
            commands: z143.array(z143.string()),
            timeoutMs: z143.number().optional(),
            maxOutputLength: z143.number().optional()
          })
        })
      )
    );
    shellOutputSchema = lazySchema(
      () => zodSchema(
        z143.object({
          output: z143.array(
            z143.object({
              stdout: z143.string(),
              stderr: z143.string(),
              outcome: z143.discriminatedUnion("type", [
                z143.object({ type: z143.literal("timeout") }),
                z143.object({ type: z143.literal("exit"), exitCode: z143.number() })
              ])
            })
          )
        })
      )
    );
    shell = createProviderToolFactoryWithOutputSchema({
      id: "openai.shell",
      inputSchema: shellInputSchema,
      outputSchema: shellOutputSchema
    });
    webSearchArgsSchema = lazySchema(
      () => zodSchema(
        z153.object({
          externalWebAccess: z153.boolean().optional(),
          filters: z153.object({ allowedDomains: z153.array(z153.string()).optional() }).optional(),
          searchContextSize: z153.enum(["low", "medium", "high"]).optional(),
          userLocation: z153.object({
            type: z153.literal("approximate"),
            country: z153.string().optional(),
            city: z153.string().optional(),
            region: z153.string().optional(),
            timezone: z153.string().optional()
          }).optional()
        })
      )
    );
    webSearchInputSchema = lazySchema(() => zodSchema(z153.object({})));
    webSearchOutputSchema = lazySchema(
      () => zodSchema(
        z153.object({
          action: z153.discriminatedUnion("type", [
            z153.object({
              type: z153.literal("search"),
              query: z153.string().optional()
            }),
            z153.object({
              type: z153.literal("openPage"),
              url: z153.string().nullish()
            }),
            z153.object({
              type: z153.literal("findInPage"),
              url: z153.string().nullish(),
              pattern: z153.string().nullish()
            })
          ]),
          sources: z153.array(
            z153.discriminatedUnion("type", [
              z153.object({ type: z153.literal("url"), url: z153.string() }),
              z153.object({ type: z153.literal("api"), name: z153.string() })
            ])
          ).optional()
        })
      )
    );
    webSearchToolFactory = createProviderToolFactoryWithOutputSchema({
      id: "openai.web_search",
      inputSchema: webSearchInputSchema,
      outputSchema: webSearchOutputSchema
    });
    webSearch = (args2 = {}) => webSearchToolFactory(args2);
    webSearchPreviewArgsSchema = lazySchema(
      () => zodSchema(
        z163.object({
          searchContextSize: z163.enum(["low", "medium", "high"]).optional(),
          userLocation: z163.object({
            type: z163.literal("approximate"),
            country: z163.string().optional(),
            city: z163.string().optional(),
            region: z163.string().optional(),
            timezone: z163.string().optional()
          }).optional()
        })
      )
    );
    webSearchPreviewInputSchema = lazySchema(
      () => zodSchema(z163.object({}))
    );
    webSearchPreviewOutputSchema = lazySchema(
      () => zodSchema(
        z163.object({
          action: z163.discriminatedUnion("type", [
            z163.object({
              type: z163.literal("search"),
              query: z163.string().optional()
            }),
            z163.object({
              type: z163.literal("openPage"),
              url: z163.string().nullish()
            }),
            z163.object({
              type: z163.literal("findInPage"),
              url: z163.string().nullish(),
              pattern: z163.string().nullish()
            })
          ])
        })
      )
    );
    webSearchPreview = createProviderToolFactoryWithOutputSchema({
      id: "openai.web_search_preview",
      inputSchema: webSearchPreviewInputSchema,
      outputSchema: webSearchPreviewOutputSchema
    });
    jsonValueSchema2 = z173.lazy(
      () => z173.union([
        z173.string(),
        z173.number(),
        z173.boolean(),
        z173.null(),
        z173.array(jsonValueSchema2),
        z173.record(z173.string(), jsonValueSchema2)
      ])
    );
    mcpArgsSchema = lazySchema(
      () => zodSchema(
        z173.object({
          serverLabel: z173.string(),
          allowedTools: z173.union([
            z173.array(z173.string()),
            z173.object({
              readOnly: z173.boolean().optional(),
              toolNames: z173.array(z173.string()).optional()
            })
          ]).optional(),
          authorization: z173.string().optional(),
          connectorId: z173.string().optional(),
          headers: z173.record(z173.string(), z173.string()).optional(),
          requireApproval: z173.union([
            z173.enum(["always", "never"]),
            z173.object({
              never: z173.object({
                toolNames: z173.array(z173.string()).optional()
              }).optional()
            })
          ]).optional(),
          serverDescription: z173.string().optional(),
          serverUrl: z173.string().optional()
        }).refine(
          (v) => v.serverUrl != null || v.connectorId != null,
          "One of serverUrl or connectorId must be provided."
        )
      )
    );
    mcpInputSchema = lazySchema(() => zodSchema(z173.object({})));
    mcpOutputSchema = lazySchema(
      () => zodSchema(
        z173.object({
          type: z173.literal("call"),
          serverLabel: z173.string(),
          name: z173.string(),
          arguments: z173.string(),
          output: z173.string().nullish(),
          error: z173.union([z173.string(), jsonValueSchema2]).optional()
        })
      )
    );
    mcpToolFactory = createProviderToolFactoryWithOutputSchema({
      id: "openai.mcp",
      inputSchema: mcpInputSchema,
      outputSchema: mcpOutputSchema
    });
    mcp = (args2) => mcpToolFactory(args2);
    openaiTools = {
      /**
       * The apply_patch tool lets GPT-5.1 create, update, and delete files in your
       * codebase using structured diffs. Instead of just suggesting edits, the model
       * emits patch operations that your application applies and then reports back on,
       * enabling iterative, multi-step code editing workflows.
       *
       */
      applyPatch,
      /**
       * The Code Interpreter tool allows models to write and run Python code in a
       * sandboxed environment to solve complex problems in domains like data analysis,
       * coding, and math.
       *
       * @param container - The container to use for the code interpreter.
       */
      codeInterpreter,
      /**
       * File search is a tool available in the Responses API. It enables models to
       * retrieve information in a knowledge base of previously uploaded files through
       * semantic and keyword search.
       *
       * @param vectorStoreIds - The vector store IDs to use for the file search.
       * @param maxNumResults - The maximum number of results to return.
       * @param ranking - The ranking options to use for the file search.
       * @param filters - The filters to use for the file search.
       */
      fileSearch,
      /**
       * The image generation tool allows you to generate images using a text prompt,
       * and optionally image inputs. It leverages the GPT Image model,
       * and automatically optimizes text inputs for improved performance.
       *
       * @param background - Background type for the generated image. One of 'auto', 'opaque', or 'transparent'.
       * @param inputFidelity - Input fidelity for the generated image. One of 'low' or 'high'.
       * @param inputImageMask - Optional mask for inpainting. Contains fileId and/or imageUrl.
       * @param model - The image generation model to use. Default: gpt-image-1.
       * @param moderation - Moderation level for the generated image. Default: 'auto'.
       * @param outputCompression - Compression level for the output image (0-100).
       * @param outputFormat - The output format of the generated image. One of 'png', 'jpeg', or 'webp'.
       * @param partialImages - Number of partial images to generate in streaming mode (0-3).
       * @param quality - The quality of the generated image. One of 'auto', 'low', 'medium', or 'high'.
       * @param size - The size of the generated image. One of 'auto', '1024x1024', '1024x1536', or '1536x1024'.
       */
      imageGeneration,
      /**
       * Local shell is a tool that allows agents to run shell commands locally
       * on a machine you or the user provides.
       *
       * Supported models: `gpt-5-codex` and `codex-mini-latest`
       */
      localShell,
      /**
       * The shell tool allows the model to interact with your local computer through
       * a controlled command-line interface. The model proposes shell commands; your
       * integration executes them and returns the outputs.
       *
       * Available through the Responses API for use with GPT-5.1.
       *
       * WARNING: Running arbitrary shell commands can be dangerous. Always sandbox
       * execution or add strict allow-/deny-lists before forwarding a command to
       * the system shell.
       */
      shell,
      /**
       * Web search allows models to access up-to-date information from the internet
       * and provide answers with sourced citations.
       *
       * @param searchContextSize - The search context size to use for the web search.
       * @param userLocation - The user location to use for the web search.
       */
      webSearchPreview,
      /**
       * Web search allows models to access up-to-date information from the internet
       * and provide answers with sourced citations.
       *
       * @param filters - The filters to use for the web search.
       * @param searchContextSize - The search context size to use for the web search.
       * @param userLocation - The user location to use for the web search.
       */
      webSearch,
      /**
       * MCP (Model Context Protocol) allows models to call tools exposed by
       * remote MCP servers or service connectors.
       *
       * @param serverLabel - Label to identify the MCP server.
       * @param allowedTools - Allowed tool names or filter object.
       * @param authorization - OAuth access token for the MCP server/connector.
       * @param connectorId - Identifier for a service connector.
       * @param headers - Optional headers to include in MCP requests.
       * // param requireApproval - Approval policy ('always'|'never'|filter object). (Removed - always 'never')
       * @param serverDescription - Optional description of the server.
       * @param serverUrl - URL for the MCP server.
       */
      mcp
    };
    openaiResponsesReasoningProviderOptionsSchema = z183.object({
      itemId: z183.string().nullish(),
      reasoningEncryptedContent: z183.string().nullish()
    });
    openaiResponsesChunkSchema = lazySchema(
      () => zodSchema(
        z192.union([
          z192.object({
            type: z192.literal("response.output_text.delta"),
            item_id: z192.string(),
            delta: z192.string(),
            logprobs: z192.array(
              z192.object({
                token: z192.string(),
                logprob: z192.number(),
                top_logprobs: z192.array(
                  z192.object({
                    token: z192.string(),
                    logprob: z192.number()
                  })
                )
              })
            ).nullish()
          }),
          z192.object({
            type: z192.enum(["response.completed", "response.incomplete"]),
            response: z192.object({
              incomplete_details: z192.object({ reason: z192.string() }).nullish(),
              usage: z192.object({
                input_tokens: z192.number(),
                input_tokens_details: z192.object({ cached_tokens: z192.number().nullish() }).nullish(),
                output_tokens: z192.number(),
                output_tokens_details: z192.object({ reasoning_tokens: z192.number().nullish() }).nullish()
              }),
              service_tier: z192.string().nullish()
            })
          }),
          z192.object({
            type: z192.literal("response.created"),
            response: z192.object({
              id: z192.string(),
              created_at: z192.number(),
              model: z192.string(),
              service_tier: z192.string().nullish()
            })
          }),
          z192.object({
            type: z192.literal("response.output_item.added"),
            output_index: z192.number(),
            item: z192.discriminatedUnion("type", [
              z192.object({
                type: z192.literal("message"),
                id: z192.string()
              }),
              z192.object({
                type: z192.literal("reasoning"),
                id: z192.string(),
                encrypted_content: z192.string().nullish()
              }),
              z192.object({
                type: z192.literal("function_call"),
                id: z192.string(),
                call_id: z192.string(),
                name: z192.string(),
                arguments: z192.string()
              }),
              z192.object({
                type: z192.literal("web_search_call"),
                id: z192.string(),
                status: z192.string()
              }),
              z192.object({
                type: z192.literal("computer_call"),
                id: z192.string(),
                status: z192.string()
              }),
              z192.object({
                type: z192.literal("file_search_call"),
                id: z192.string()
              }),
              z192.object({
                type: z192.literal("image_generation_call"),
                id: z192.string()
              }),
              z192.object({
                type: z192.literal("code_interpreter_call"),
                id: z192.string(),
                container_id: z192.string(),
                code: z192.string().nullable(),
                outputs: z192.array(
                  z192.discriminatedUnion("type", [
                    z192.object({ type: z192.literal("logs"), logs: z192.string() }),
                    z192.object({ type: z192.literal("image"), url: z192.string() })
                  ])
                ).nullable(),
                status: z192.string()
              }),
              z192.object({
                type: z192.literal("mcp_call"),
                id: z192.string(),
                status: z192.string(),
                approval_request_id: z192.string().nullish()
              }),
              z192.object({
                type: z192.literal("mcp_list_tools"),
                id: z192.string()
              }),
              z192.object({
                type: z192.literal("mcp_approval_request"),
                id: z192.string()
              }),
              z192.object({
                type: z192.literal("apply_patch_call"),
                id: z192.string(),
                call_id: z192.string(),
                status: z192.enum(["in_progress", "completed"]),
                operation: z192.discriminatedUnion("type", [
                  z192.object({
                    type: z192.literal("create_file"),
                    path: z192.string(),
                    diff: z192.string()
                  }),
                  z192.object({
                    type: z192.literal("delete_file"),
                    path: z192.string()
                  }),
                  z192.object({
                    type: z192.literal("update_file"),
                    path: z192.string(),
                    diff: z192.string()
                  })
                ])
              }),
              z192.object({
                type: z192.literal("shell_call"),
                id: z192.string(),
                call_id: z192.string(),
                status: z192.enum(["in_progress", "completed", "incomplete"]),
                action: z192.object({
                  commands: z192.array(z192.string())
                })
              })
            ])
          }),
          z192.object({
            type: z192.literal("response.output_item.done"),
            output_index: z192.number(),
            item: z192.discriminatedUnion("type", [
              z192.object({
                type: z192.literal("message"),
                id: z192.string()
              }),
              z192.object({
                type: z192.literal("reasoning"),
                id: z192.string(),
                encrypted_content: z192.string().nullish()
              }),
              z192.object({
                type: z192.literal("function_call"),
                id: z192.string(),
                call_id: z192.string(),
                name: z192.string(),
                arguments: z192.string(),
                status: z192.literal("completed")
              }),
              z192.object({
                type: z192.literal("code_interpreter_call"),
                id: z192.string(),
                code: z192.string().nullable(),
                container_id: z192.string(),
                outputs: z192.array(
                  z192.discriminatedUnion("type", [
                    z192.object({ type: z192.literal("logs"), logs: z192.string() }),
                    z192.object({ type: z192.literal("image"), url: z192.string() })
                  ])
                ).nullable()
              }),
              z192.object({
                type: z192.literal("image_generation_call"),
                id: z192.string(),
                result: z192.string()
              }),
              z192.object({
                type: z192.literal("web_search_call"),
                id: z192.string(),
                status: z192.string(),
                action: z192.discriminatedUnion("type", [
                  z192.object({
                    type: z192.literal("search"),
                    query: z192.string().nullish(),
                    sources: z192.array(
                      z192.discriminatedUnion("type", [
                        z192.object({ type: z192.literal("url"), url: z192.string() }),
                        z192.object({ type: z192.literal("api"), name: z192.string() })
                      ])
                    ).nullish()
                  }),
                  z192.object({
                    type: z192.literal("open_page"),
                    url: z192.string().nullish()
                  }),
                  z192.object({
                    type: z192.literal("find_in_page"),
                    url: z192.string().nullish(),
                    pattern: z192.string().nullish()
                  })
                ])
              }),
              z192.object({
                type: z192.literal("file_search_call"),
                id: z192.string(),
                queries: z192.array(z192.string()),
                results: z192.array(
                  z192.object({
                    attributes: z192.record(
                      z192.string(),
                      z192.union([z192.string(), z192.number(), z192.boolean()])
                    ),
                    file_id: z192.string(),
                    filename: z192.string(),
                    score: z192.number(),
                    text: z192.string()
                  })
                ).nullish()
              }),
              z192.object({
                type: z192.literal("local_shell_call"),
                id: z192.string(),
                call_id: z192.string(),
                action: z192.object({
                  type: z192.literal("exec"),
                  command: z192.array(z192.string()),
                  timeout_ms: z192.number().optional(),
                  user: z192.string().optional(),
                  working_directory: z192.string().optional(),
                  env: z192.record(z192.string(), z192.string()).optional()
                })
              }),
              z192.object({
                type: z192.literal("computer_call"),
                id: z192.string(),
                status: z192.literal("completed")
              }),
              z192.object({
                type: z192.literal("mcp_call"),
                id: z192.string(),
                status: z192.string(),
                arguments: z192.string(),
                name: z192.string(),
                server_label: z192.string(),
                output: z192.string().nullish(),
                error: z192.union([
                  z192.string(),
                  z192.object({
                    type: z192.string().optional(),
                    code: z192.union([z192.number(), z192.string()]).optional(),
                    message: z192.string().optional()
                  }).loose()
                ]).nullish(),
                approval_request_id: z192.string().nullish()
              }),
              z192.object({
                type: z192.literal("mcp_list_tools"),
                id: z192.string(),
                server_label: z192.string(),
                tools: z192.array(
                  z192.object({
                    name: z192.string(),
                    description: z192.string().optional(),
                    input_schema: z192.any(),
                    annotations: z192.record(z192.string(), z192.unknown()).optional()
                  })
                ),
                error: z192.union([
                  z192.string(),
                  z192.object({
                    type: z192.string().optional(),
                    code: z192.union([z192.number(), z192.string()]).optional(),
                    message: z192.string().optional()
                  }).loose()
                ]).optional()
              }),
              z192.object({
                type: z192.literal("mcp_approval_request"),
                id: z192.string(),
                server_label: z192.string(),
                name: z192.string(),
                arguments: z192.string(),
                approval_request_id: z192.string().optional()
              }),
              z192.object({
                type: z192.literal("apply_patch_call"),
                id: z192.string(),
                call_id: z192.string(),
                status: z192.enum(["in_progress", "completed"]),
                operation: z192.discriminatedUnion("type", [
                  z192.object({
                    type: z192.literal("create_file"),
                    path: z192.string(),
                    diff: z192.string()
                  }),
                  z192.object({
                    type: z192.literal("delete_file"),
                    path: z192.string()
                  }),
                  z192.object({
                    type: z192.literal("update_file"),
                    path: z192.string(),
                    diff: z192.string()
                  })
                ])
              }),
              z192.object({
                type: z192.literal("shell_call"),
                id: z192.string(),
                call_id: z192.string(),
                status: z192.enum(["in_progress", "completed", "incomplete"]),
                action: z192.object({
                  commands: z192.array(z192.string())
                })
              })
            ])
          }),
          z192.object({
            type: z192.literal("response.function_call_arguments.delta"),
            item_id: z192.string(),
            output_index: z192.number(),
            delta: z192.string()
          }),
          z192.object({
            type: z192.literal("response.image_generation_call.partial_image"),
            item_id: z192.string(),
            output_index: z192.number(),
            partial_image_b64: z192.string()
          }),
          z192.object({
            type: z192.literal("response.code_interpreter_call_code.delta"),
            item_id: z192.string(),
            output_index: z192.number(),
            delta: z192.string()
          }),
          z192.object({
            type: z192.literal("response.code_interpreter_call_code.done"),
            item_id: z192.string(),
            output_index: z192.number(),
            code: z192.string()
          }),
          z192.object({
            type: z192.literal("response.output_text.annotation.added"),
            annotation: z192.discriminatedUnion("type", [
              z192.object({
                type: z192.literal("url_citation"),
                start_index: z192.number(),
                end_index: z192.number(),
                url: z192.string(),
                title: z192.string()
              }),
              z192.object({
                type: z192.literal("file_citation"),
                file_id: z192.string(),
                filename: z192.string(),
                index: z192.number()
              }),
              z192.object({
                type: z192.literal("container_file_citation"),
                container_id: z192.string(),
                file_id: z192.string(),
                filename: z192.string(),
                start_index: z192.number(),
                end_index: z192.number()
              }),
              z192.object({
                type: z192.literal("file_path"),
                file_id: z192.string(),
                index: z192.number()
              })
            ])
          }),
          z192.object({
            type: z192.literal("response.reasoning_summary_part.added"),
            item_id: z192.string(),
            summary_index: z192.number()
          }),
          z192.object({
            type: z192.literal("response.reasoning_summary_text.delta"),
            item_id: z192.string(),
            summary_index: z192.number(),
            delta: z192.string()
          }),
          z192.object({
            type: z192.literal("response.reasoning_summary_part.done"),
            item_id: z192.string(),
            summary_index: z192.number()
          }),
          z192.object({
            type: z192.literal("response.apply_patch_call_operation_diff.delta"),
            item_id: z192.string(),
            output_index: z192.number(),
            delta: z192.string(),
            obfuscation: z192.string().nullish()
          }),
          z192.object({
            type: z192.literal("response.apply_patch_call_operation_diff.done"),
            item_id: z192.string(),
            output_index: z192.number(),
            diff: z192.string()
          }),
          z192.object({
            type: z192.literal("error"),
            sequence_number: z192.number(),
            error: z192.object({
              type: z192.string(),
              code: z192.string(),
              message: z192.string(),
              param: z192.string().nullish()
            })
          }),
          z192.object({ type: z192.string() }).loose().transform((value2) => ({
            type: "unknown_chunk",
            message: value2.type
          }))
          // fallback for unknown chunks
        ])
      )
    );
    openaiResponsesResponseSchema = lazySchema(
      () => zodSchema(
        z192.object({
          id: z192.string().optional(),
          created_at: z192.number().optional(),
          error: z192.object({
            message: z192.string(),
            type: z192.string(),
            param: z192.string().nullish(),
            code: z192.string()
          }).nullish(),
          model: z192.string().optional(),
          output: z192.array(
            z192.discriminatedUnion("type", [
              z192.object({
                type: z192.literal("message"),
                role: z192.literal("assistant"),
                id: z192.string(),
                content: z192.array(
                  z192.object({
                    type: z192.literal("output_text"),
                    text: z192.string(),
                    logprobs: z192.array(
                      z192.object({
                        token: z192.string(),
                        logprob: z192.number(),
                        top_logprobs: z192.array(
                          z192.object({
                            token: z192.string(),
                            logprob: z192.number()
                          })
                        )
                      })
                    ).nullish(),
                    annotations: z192.array(
                      z192.discriminatedUnion("type", [
                        z192.object({
                          type: z192.literal("url_citation"),
                          start_index: z192.number(),
                          end_index: z192.number(),
                          url: z192.string(),
                          title: z192.string()
                        }),
                        z192.object({
                          type: z192.literal("file_citation"),
                          file_id: z192.string(),
                          filename: z192.string(),
                          index: z192.number()
                        }),
                        z192.object({
                          type: z192.literal("container_file_citation"),
                          container_id: z192.string(),
                          file_id: z192.string(),
                          filename: z192.string(),
                          start_index: z192.number(),
                          end_index: z192.number()
                        }),
                        z192.object({
                          type: z192.literal("file_path"),
                          file_id: z192.string(),
                          index: z192.number()
                        })
                      ])
                    )
                  })
                )
              }),
              z192.object({
                type: z192.literal("web_search_call"),
                id: z192.string(),
                status: z192.string(),
                action: z192.discriminatedUnion("type", [
                  z192.object({
                    type: z192.literal("search"),
                    query: z192.string().nullish(),
                    sources: z192.array(
                      z192.discriminatedUnion("type", [
                        z192.object({ type: z192.literal("url"), url: z192.string() }),
                        z192.object({ type: z192.literal("api"), name: z192.string() })
                      ])
                    ).nullish()
                  }),
                  z192.object({
                    type: z192.literal("open_page"),
                    url: z192.string().nullish()
                  }),
                  z192.object({
                    type: z192.literal("find_in_page"),
                    url: z192.string().nullish(),
                    pattern: z192.string().nullish()
                  })
                ])
              }),
              z192.object({
                type: z192.literal("file_search_call"),
                id: z192.string(),
                queries: z192.array(z192.string()),
                results: z192.array(
                  z192.object({
                    attributes: z192.record(
                      z192.string(),
                      z192.union([z192.string(), z192.number(), z192.boolean()])
                    ),
                    file_id: z192.string(),
                    filename: z192.string(),
                    score: z192.number(),
                    text: z192.string()
                  })
                ).nullish()
              }),
              z192.object({
                type: z192.literal("code_interpreter_call"),
                id: z192.string(),
                code: z192.string().nullable(),
                container_id: z192.string(),
                outputs: z192.array(
                  z192.discriminatedUnion("type", [
                    z192.object({ type: z192.literal("logs"), logs: z192.string() }),
                    z192.object({ type: z192.literal("image"), url: z192.string() })
                  ])
                ).nullable()
              }),
              z192.object({
                type: z192.literal("image_generation_call"),
                id: z192.string(),
                result: z192.string()
              }),
              z192.object({
                type: z192.literal("local_shell_call"),
                id: z192.string(),
                call_id: z192.string(),
                action: z192.object({
                  type: z192.literal("exec"),
                  command: z192.array(z192.string()),
                  timeout_ms: z192.number().optional(),
                  user: z192.string().optional(),
                  working_directory: z192.string().optional(),
                  env: z192.record(z192.string(), z192.string()).optional()
                })
              }),
              z192.object({
                type: z192.literal("function_call"),
                call_id: z192.string(),
                name: z192.string(),
                arguments: z192.string(),
                id: z192.string()
              }),
              z192.object({
                type: z192.literal("computer_call"),
                id: z192.string(),
                status: z192.string().optional()
              }),
              z192.object({
                type: z192.literal("reasoning"),
                id: z192.string(),
                encrypted_content: z192.string().nullish(),
                summary: z192.array(
                  z192.object({
                    type: z192.literal("summary_text"),
                    text: z192.string()
                  })
                )
              }),
              z192.object({
                type: z192.literal("mcp_call"),
                id: z192.string(),
                status: z192.string(),
                arguments: z192.string(),
                name: z192.string(),
                server_label: z192.string(),
                output: z192.string().nullish(),
                error: z192.union([
                  z192.string(),
                  z192.object({
                    type: z192.string().optional(),
                    code: z192.union([z192.number(), z192.string()]).optional(),
                    message: z192.string().optional()
                  }).loose()
                ]).nullish(),
                approval_request_id: z192.string().nullish()
              }),
              z192.object({
                type: z192.literal("mcp_list_tools"),
                id: z192.string(),
                server_label: z192.string(),
                tools: z192.array(
                  z192.object({
                    name: z192.string(),
                    description: z192.string().optional(),
                    input_schema: z192.any(),
                    annotations: z192.record(z192.string(), z192.unknown()).optional()
                  })
                ),
                error: z192.union([
                  z192.string(),
                  z192.object({
                    type: z192.string().optional(),
                    code: z192.union([z192.number(), z192.string()]).optional(),
                    message: z192.string().optional()
                  }).loose()
                ]).optional()
              }),
              z192.object({
                type: z192.literal("mcp_approval_request"),
                id: z192.string(),
                server_label: z192.string(),
                name: z192.string(),
                arguments: z192.string(),
                approval_request_id: z192.string().optional()
              }),
              z192.object({
                type: z192.literal("apply_patch_call"),
                id: z192.string(),
                call_id: z192.string(),
                status: z192.enum(["in_progress", "completed"]),
                operation: z192.discriminatedUnion("type", [
                  z192.object({
                    type: z192.literal("create_file"),
                    path: z192.string(),
                    diff: z192.string()
                  }),
                  z192.object({
                    type: z192.literal("delete_file"),
                    path: z192.string()
                  }),
                  z192.object({
                    type: z192.literal("update_file"),
                    path: z192.string(),
                    diff: z192.string()
                  })
                ])
              }),
              z192.object({
                type: z192.literal("shell_call"),
                id: z192.string(),
                call_id: z192.string(),
                status: z192.enum(["in_progress", "completed", "incomplete"]),
                action: z192.object({
                  commands: z192.array(z192.string())
                })
              })
            ])
          ).optional(),
          service_tier: z192.string().nullish(),
          incomplete_details: z192.object({ reason: z192.string() }).nullish(),
          usage: z192.object({
            input_tokens: z192.number(),
            input_tokens_details: z192.object({ cached_tokens: z192.number().nullish() }).nullish(),
            output_tokens: z192.number(),
            output_tokens_details: z192.object({ reasoning_tokens: z192.number().nullish() }).nullish()
          }).optional()
        })
      )
    );
    TOP_LOGPROBS_MAX = 20;
    openaiResponsesReasoningModelIds = [
      "o1",
      "o1-2024-12-17",
      "o3",
      "o3-2025-04-16",
      "o3-deep-research",
      "o3-deep-research-2025-06-26",
      "o3-mini",
      "o3-mini-2025-01-31",
      "o4-mini",
      "o4-mini-2025-04-16",
      "o4-mini-deep-research",
      "o4-mini-deep-research-2025-06-26",
      "codex-mini-latest",
      "computer-use-preview",
      "gpt-5",
      "gpt-5-2025-08-07",
      "gpt-5-codex",
      "gpt-5-mini",
      "gpt-5-mini-2025-08-07",
      "gpt-5-nano",
      "gpt-5-nano-2025-08-07",
      "gpt-5-pro",
      "gpt-5-pro-2025-10-06",
      "gpt-5.1",
      "gpt-5.1-chat-latest",
      "gpt-5.1-codex-mini",
      "gpt-5.1-codex",
      "gpt-5.1-codex-max",
      "gpt-5.2",
      "gpt-5.2-chat-latest",
      "gpt-5.2-pro"
    ];
    openaiResponsesModelIds = [
      "gpt-4.1",
      "gpt-4.1-2025-04-14",
      "gpt-4.1-mini",
      "gpt-4.1-mini-2025-04-14",
      "gpt-4.1-nano",
      "gpt-4.1-nano-2025-04-14",
      "gpt-4o",
      "gpt-4o-2024-05-13",
      "gpt-4o-2024-08-06",
      "gpt-4o-2024-11-20",
      "gpt-4o-audio-preview",
      "gpt-4o-audio-preview-2024-10-01",
      "gpt-4o-audio-preview-2024-12-17",
      "gpt-4o-search-preview",
      "gpt-4o-search-preview-2025-03-11",
      "gpt-4o-mini-search-preview",
      "gpt-4o-mini-search-preview-2025-03-11",
      "gpt-4o-mini",
      "gpt-4o-mini-2024-07-18",
      "gpt-4-turbo",
      "gpt-4-turbo-2024-04-09",
      "gpt-4-turbo-preview",
      "gpt-4-0125-preview",
      "gpt-4-1106-preview",
      "gpt-4",
      "gpt-4-0613",
      "gpt-4.5-preview",
      "gpt-4.5-preview-2025-02-27",
      "gpt-3.5-turbo-0125",
      "gpt-3.5-turbo",
      "gpt-3.5-turbo-1106",
      "chatgpt-4o-latest",
      "gpt-5-chat-latest",
      ...openaiResponsesReasoningModelIds
    ];
    openaiResponsesProviderOptionsSchema = lazySchema(
      () => zodSchema(
        z202.object({
          /**
           * The ID of the OpenAI Conversation to continue.
           * You must create a conversation first via the OpenAI API.
           * Cannot be used in conjunction with `previousResponseId`.
           * Defaults to `undefined`.
           * @see https://platform.openai.com/docs/api-reference/conversations/create
           */
          conversation: z202.string().nullish(),
          /**
           * The set of extra fields to include in the response (advanced, usually not needed).
           * Example values: 'reasoning.encrypted_content', 'file_search_call.results', 'message.output_text.logprobs'.
           */
          include: z202.array(
            z202.enum([
              "reasoning.encrypted_content",
              // handled internally by default, only needed for unknown reasoning models
              "file_search_call.results",
              "message.output_text.logprobs"
            ])
          ).nullish(),
          /**
           * Instructions for the model.
           * They can be used to change the system or developer message when continuing a conversation using the `previousResponseId` option.
           * Defaults to `undefined`.
           */
          instructions: z202.string().nullish(),
          /**
           * Return the log probabilities of the tokens. Including logprobs will increase
           * the response size and can slow down response times. However, it can
           * be useful to better understand how the model is behaving.
           *
           * Setting to true will return the log probabilities of the tokens that
           * were generated.
           *
           * Setting to a number will return the log probabilities of the top n
           * tokens that were generated.
           *
           * @see https://platform.openai.com/docs/api-reference/responses/create
           * @see https://cookbook.openai.com/examples/using_logprobs
           */
          logprobs: z202.union([z202.boolean(), z202.number().min(1).max(TOP_LOGPROBS_MAX)]).optional(),
          /**
           * The maximum number of total calls to built-in tools that can be processed in a response.
           * This maximum number applies across all built-in tool calls, not per individual tool.
           * Any further attempts to call a tool by the model will be ignored.
           */
          maxToolCalls: z202.number().nullish(),
          /**
           * Additional metadata to store with the generation.
           */
          metadata: z202.any().nullish(),
          /**
           * Whether to use parallel tool calls. Defaults to `true`.
           */
          parallelToolCalls: z202.boolean().nullish(),
          /**
           * The ID of the previous response. You can use it to continue a conversation.
           * Defaults to `undefined`.
           */
          previousResponseId: z202.string().nullish(),
          /**
           * Sets a cache key to tie this prompt to cached prefixes for better caching performance.
           */
          promptCacheKey: z202.string().nullish(),
          /**
           * The retention policy for the prompt cache.
           * - 'in_memory': Default. Standard prompt caching behavior.
           * - '24h': Extended prompt caching that keeps cached prefixes active for up to 24 hours.
           *          Currently only available for 5.1 series models.
           *
           * @default 'in_memory'
           */
          promptCacheRetention: z202.enum(["in_memory", "24h"]).nullish(),
          /**
           * Reasoning effort for reasoning models. Defaults to `medium`. If you use
           * `providerOptions` to set the `reasoningEffort` option, this model setting will be ignored.
           * Valid values: 'none' | 'minimal' | 'low' | 'medium' | 'high' | 'xhigh'
           *
           * The 'none' type for `reasoningEffort` is only available for OpenAI's GPT-5.1
           * models. Also, the 'xhigh' type for `reasoningEffort` is only available for
           * OpenAI's GPT-5.1-Codex-Max model. Setting `reasoningEffort` to 'none' or 'xhigh' with unsupported models will result in
           * an error.
           */
          reasoningEffort: z202.string().nullish(),
          /**
           * Controls reasoning summary output from the model.
           * Set to "auto" to automatically receive the richest level available,
           * or "detailed" for comprehensive summaries.
           */
          reasoningSummary: z202.string().nullish(),
          /**
           * The identifier for safety monitoring and tracking.
           */
          safetyIdentifier: z202.string().nullish(),
          /**
           * Service tier for the request.
           * Set to 'flex' for 50% cheaper processing at the cost of increased latency (available for o3, o4-mini, and gpt-5 models).
           * Set to 'priority' for faster processing with Enterprise access (available for gpt-4, gpt-5, gpt-5-mini, o3, o4-mini; gpt-5-nano is not supported).
           *
           * Defaults to 'auto'.
           */
          serviceTier: z202.enum(["auto", "flex", "priority", "default"]).nullish(),
          /**
           * Whether to store the generation. Defaults to `true`.
           */
          store: z202.boolean().nullish(),
          /**
           * Whether to use strict JSON schema validation.
           * Defaults to `true`.
           */
          strictJsonSchema: z202.boolean().nullish(),
          /**
           * Controls the verbosity of the model's responses. Lower values ('low') will result
           * in more concise responses, while higher values ('high') will result in more verbose responses.
           * Valid values: 'low', 'medium', 'high'.
           */
          textVerbosity: z202.enum(["low", "medium", "high"]).nullish(),
          /**
           * Controls output truncation. 'auto' (default) performs truncation automatically;
           * 'disabled' turns truncation off.
           */
          truncation: z202.enum(["auto", "disabled"]).nullish(),
          /**
           * A unique identifier representing your end-user, which can help OpenAI to
           * monitor and detect abuse.
           * Defaults to `undefined`.
           * @see https://platform.openai.com/docs/guides/safety-best-practices/end-user-ids
           */
          user: z202.string().nullish(),
          /**
           * Override the system message mode for this model.
           * - 'system': Use the 'system' role for system messages (default for most models)
           * - 'developer': Use the 'developer' role for system messages (used by reasoning models)
           * - 'remove': Remove system messages entirely
           *
           * If not specified, the mode is automatically determined based on the model.
           */
          systemMessageMode: z202.enum(["system", "developer", "remove"]).optional(),
          /**
           * Force treating this model as a reasoning model.
           *
           * This is useful for "stealth" reasoning models (e.g. via a custom baseURL)
           * where the model ID is not recognized by the SDK's allowlist.
           *
           * When enabled, the SDK applies reasoning-model parameter compatibility rules
           * and defaults `systemMessageMode` to `developer` unless overridden.
           */
          forceReasoning: z202.boolean().optional()
        })
      )
    );
    OpenAIResponsesLanguageModel = class {
      constructor(modelId, config2) {
        this.specificationVersion = "v3";
        this.supportedUrls = {
          "image/*": [/^https?:\/\/.*$/],
          "application/pdf": [/^https?:\/\/.*$/]
        };
        this.modelId = modelId;
        this.config = config2;
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        maxOutputTokens,
        temperature,
        stopSequences,
        topP,
        topK,
        presencePenalty,
        frequencyPenalty,
        seed,
        prompt,
        providerOptions,
        tools,
        toolChoice,
        responseFormat
      }) {
        var _a25, _b18, _c, _d, _e, _f;
        const warnings = [];
        const modelCapabilities = getOpenAILanguageModelCapabilities(this.modelId);
        if (topK != null) {
          warnings.push({ type: "unsupported", feature: "topK" });
        }
        if (seed != null) {
          warnings.push({ type: "unsupported", feature: "seed" });
        }
        if (presencePenalty != null) {
          warnings.push({ type: "unsupported", feature: "presencePenalty" });
        }
        if (frequencyPenalty != null) {
          warnings.push({ type: "unsupported", feature: "frequencyPenalty" });
        }
        if (stopSequences != null) {
          warnings.push({ type: "unsupported", feature: "stopSequences" });
        }
        const providerOptionsName = this.config.provider.includes("azure") ? "azure" : "openai";
        let openaiOptions = await parseProviderOptions({
          provider: providerOptionsName,
          providerOptions,
          schema: openaiResponsesProviderOptionsSchema
        });
        if (openaiOptions == null && providerOptionsName !== "openai") {
          openaiOptions = await parseProviderOptions({
            provider: "openai",
            providerOptions,
            schema: openaiResponsesProviderOptionsSchema
          });
        }
        const isReasoningModel = (_a25 = openaiOptions == null ? void 0 : openaiOptions.forceReasoning) != null ? _a25 : modelCapabilities.isReasoningModel;
        if ((openaiOptions == null ? void 0 : openaiOptions.conversation) && (openaiOptions == null ? void 0 : openaiOptions.previousResponseId)) {
          warnings.push({
            type: "unsupported",
            feature: "conversation",
            details: "conversation and previousResponseId cannot be used together"
          });
        }
        const toolNameMapping = createToolNameMapping({
          tools,
          providerToolNames: {
            "openai.code_interpreter": "code_interpreter",
            "openai.file_search": "file_search",
            "openai.image_generation": "image_generation",
            "openai.local_shell": "local_shell",
            "openai.shell": "shell",
            "openai.web_search": "web_search",
            "openai.web_search_preview": "web_search_preview",
            "openai.mcp": "mcp",
            "openai.apply_patch": "apply_patch"
          }
        });
        const { input, warnings: inputWarnings } = await convertToOpenAIResponsesInput({
          prompt,
          toolNameMapping,
          systemMessageMode: (_b18 = openaiOptions == null ? void 0 : openaiOptions.systemMessageMode) != null ? _b18 : isReasoningModel ? "developer" : modelCapabilities.systemMessageMode,
          providerOptionsName,
          fileIdPrefixes: this.config.fileIdPrefixes,
          store: (_c = openaiOptions == null ? void 0 : openaiOptions.store) != null ? _c : true,
          hasConversation: (openaiOptions == null ? void 0 : openaiOptions.conversation) != null,
          hasLocalShellTool: hasOpenAITool("openai.local_shell"),
          hasShellTool: hasOpenAITool("openai.shell"),
          hasApplyPatchTool: hasOpenAITool("openai.apply_patch")
        });
        warnings.push(...inputWarnings);
        const strictJsonSchema = (_d = openaiOptions == null ? void 0 : openaiOptions.strictJsonSchema) != null ? _d : true;
        let include = openaiOptions == null ? void 0 : openaiOptions.include;
        function addInclude(key) {
          if (include == null) {
            include = [key];
          } else if (!include.includes(key)) {
            include = [...include, key];
          }
        }
        function hasOpenAITool(id) {
          return (tools == null ? void 0 : tools.find((tool2) => tool2.type === "provider" && tool2.id === id)) != null;
        }
        const topLogprobs = typeof (openaiOptions == null ? void 0 : openaiOptions.logprobs) === "number" ? openaiOptions == null ? void 0 : openaiOptions.logprobs : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? TOP_LOGPROBS_MAX : void 0;
        if (topLogprobs) {
          addInclude("message.output_text.logprobs");
        }
        const webSearchToolName = (_e = tools == null ? void 0 : tools.find(
          (tool2) => tool2.type === "provider" && (tool2.id === "openai.web_search" || tool2.id === "openai.web_search_preview")
        )) == null ? void 0 : _e.name;
        if (webSearchToolName) {
          addInclude("web_search_call.action.sources");
        }
        if (hasOpenAITool("openai.code_interpreter")) {
          addInclude("code_interpreter_call.outputs");
        }
        const store = openaiOptions == null ? void 0 : openaiOptions.store;
        if (store === false && isReasoningModel) {
          addInclude("reasoning.encrypted_content");
        }
        const baseArgs = {
          model: this.modelId,
          input,
          temperature,
          top_p: topP,
          max_output_tokens: maxOutputTokens,
          ...((responseFormat == null ? void 0 : responseFormat.type) === "json" || (openaiOptions == null ? void 0 : openaiOptions.textVerbosity)) && {
            text: {
              ...(responseFormat == null ? void 0 : responseFormat.type) === "json" && {
                format: responseFormat.schema != null ? {
                  type: "json_schema",
                  strict: strictJsonSchema,
                  name: (_f = responseFormat.name) != null ? _f : "response",
                  description: responseFormat.description,
                  schema: responseFormat.schema
                } : { type: "json_object" }
              },
              ...(openaiOptions == null ? void 0 : openaiOptions.textVerbosity) && {
                verbosity: openaiOptions.textVerbosity
              }
            }
          },
          // provider options:
          conversation: openaiOptions == null ? void 0 : openaiOptions.conversation,
          max_tool_calls: openaiOptions == null ? void 0 : openaiOptions.maxToolCalls,
          metadata: openaiOptions == null ? void 0 : openaiOptions.metadata,
          parallel_tool_calls: openaiOptions == null ? void 0 : openaiOptions.parallelToolCalls,
          previous_response_id: openaiOptions == null ? void 0 : openaiOptions.previousResponseId,
          store,
          user: openaiOptions == null ? void 0 : openaiOptions.user,
          instructions: openaiOptions == null ? void 0 : openaiOptions.instructions,
          service_tier: openaiOptions == null ? void 0 : openaiOptions.serviceTier,
          include,
          prompt_cache_key: openaiOptions == null ? void 0 : openaiOptions.promptCacheKey,
          prompt_cache_retention: openaiOptions == null ? void 0 : openaiOptions.promptCacheRetention,
          safety_identifier: openaiOptions == null ? void 0 : openaiOptions.safetyIdentifier,
          top_logprobs: topLogprobs,
          truncation: openaiOptions == null ? void 0 : openaiOptions.truncation,
          // model-specific settings:
          ...isReasoningModel && ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null || (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) && {
            reasoning: {
              ...(openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null && {
                effort: openaiOptions.reasoningEffort
              },
              ...(openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null && {
                summary: openaiOptions.reasoningSummary
              }
            }
          }
        };
        if (isReasoningModel) {
          if (!((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) === "none" && modelCapabilities.supportsNonReasoningParameters)) {
            if (baseArgs.temperature != null) {
              baseArgs.temperature = void 0;
              warnings.push({
                type: "unsupported",
                feature: "temperature",
                details: "temperature is not supported for reasoning models"
              });
            }
            if (baseArgs.top_p != null) {
              baseArgs.top_p = void 0;
              warnings.push({
                type: "unsupported",
                feature: "topP",
                details: "topP is not supported for reasoning models"
              });
            }
          }
        } else {
          if ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null) {
            warnings.push({
              type: "unsupported",
              feature: "reasoningEffort",
              details: "reasoningEffort is not supported for non-reasoning models"
            });
          }
          if ((openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) {
            warnings.push({
              type: "unsupported",
              feature: "reasoningSummary",
              details: "reasoningSummary is not supported for non-reasoning models"
            });
          }
        }
        if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "flex" && !modelCapabilities.supportsFlexProcessing) {
          warnings.push({
            type: "unsupported",
            feature: "serviceTier",
            details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
          });
          delete baseArgs.service_tier;
        }
        if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "priority" && !modelCapabilities.supportsPriorityProcessing) {
          warnings.push({
            type: "unsupported",
            feature: "serviceTier",
            details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
          });
          delete baseArgs.service_tier;
        }
        const {
          tools: openaiTools2,
          toolChoice: openaiToolChoice,
          toolWarnings
        } = await prepareResponsesTools({
          tools,
          toolChoice
        });
        return {
          webSearchToolName,
          args: {
            ...baseArgs,
            tools: openaiTools2,
            tool_choice: openaiToolChoice
          },
          warnings: [...warnings, ...toolWarnings],
          store,
          toolNameMapping,
          providerOptionsName
        };
      }
      async doGenerate(options) {
        var _a25, _b18, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
        const {
          args: body,
          warnings,
          webSearchToolName,
          toolNameMapping,
          providerOptionsName
        } = await this.getArgs(options);
        const url = this.config.url({
          path: "/responses",
          modelId: this.modelId
        });
        const approvalRequestIdToDummyToolCallIdFromPrompt = extractApprovalRequestIdToToolCallIdMapping(options.prompt);
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi({
          url,
          headers: combineHeaders(this.config.headers(), options.headers),
          body,
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            openaiResponsesResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        if (response.error) {
          throw new APICallError({
            message: response.error.message,
            url,
            requestBodyValues: body,
            statusCode: 400,
            responseHeaders,
            responseBody: rawResponse,
            isRetryable: false
          });
        }
        const content = [];
        const logprobs = [];
        let hasFunctionCall = false;
        for (const part of response.output) {
          switch (part.type) {
            case "reasoning": {
              if (part.summary.length === 0) {
                part.summary.push({ type: "summary_text", text: "" });
              }
              for (const summary of part.summary) {
                content.push({
                  type: "reasoning",
                  text: summary.text,
                  providerMetadata: {
                    [providerOptionsName]: {
                      itemId: part.id,
                      reasoningEncryptedContent: (_a25 = part.encrypted_content) != null ? _a25 : null
                    }
                  }
                });
              }
              break;
            }
            case "image_generation_call": {
              content.push({
                type: "tool-call",
                toolCallId: part.id,
                toolName: toolNameMapping.toCustomToolName("image_generation"),
                input: "{}",
                providerExecuted: true
              });
              content.push({
                type: "tool-result",
                toolCallId: part.id,
                toolName: toolNameMapping.toCustomToolName("image_generation"),
                result: {
                  result: part.result
                }
              });
              break;
            }
            case "local_shell_call": {
              content.push({
                type: "tool-call",
                toolCallId: part.call_id,
                toolName: toolNameMapping.toCustomToolName("local_shell"),
                input: JSON.stringify({
                  action: part.action
                }),
                providerMetadata: {
                  [providerOptionsName]: {
                    itemId: part.id
                  }
                }
              });
              break;
            }
            case "shell_call": {
              content.push({
                type: "tool-call",
                toolCallId: part.call_id,
                toolName: toolNameMapping.toCustomToolName("shell"),
                input: JSON.stringify({
                  action: {
                    commands: part.action.commands
                  }
                }),
                providerMetadata: {
                  [providerOptionsName]: {
                    itemId: part.id
                  }
                }
              });
              break;
            }
            case "message": {
              for (const contentPart of part.content) {
                if (((_c = (_b18 = options.providerOptions) == null ? void 0 : _b18[providerOptionsName]) == null ? void 0 : _c.logprobs) && contentPart.logprobs) {
                  logprobs.push(contentPart.logprobs);
                }
                const providerMetadata2 = {
                  itemId: part.id,
                  ...contentPart.annotations.length > 0 && {
                    annotations: contentPart.annotations
                  }
                };
                content.push({
                  type: "text",
                  text: contentPart.text,
                  providerMetadata: {
                    [providerOptionsName]: providerMetadata2
                  }
                });
                for (const annotation of contentPart.annotations) {
                  if (annotation.type === "url_citation") {
                    content.push({
                      type: "source",
                      sourceType: "url",
                      id: (_f = (_e = (_d = this.config).generateId) == null ? void 0 : _e.call(_d)) != null ? _f : generateId(),
                      url: annotation.url,
                      title: annotation.title
                    });
                  } else if (annotation.type === "file_citation") {
                    content.push({
                      type: "source",
                      sourceType: "document",
                      id: (_i = (_h = (_g = this.config).generateId) == null ? void 0 : _h.call(_g)) != null ? _i : generateId(),
                      mediaType: "text/plain",
                      title: annotation.filename,
                      filename: annotation.filename,
                      providerMetadata: {
                        [providerOptionsName]: {
                          type: annotation.type,
                          fileId: annotation.file_id,
                          index: annotation.index
                        }
                      }
                    });
                  } else if (annotation.type === "container_file_citation") {
                    content.push({
                      type: "source",
                      sourceType: "document",
                      id: (_l = (_k = (_j = this.config).generateId) == null ? void 0 : _k.call(_j)) != null ? _l : generateId(),
                      mediaType: "text/plain",
                      title: annotation.filename,
                      filename: annotation.filename,
                      providerMetadata: {
                        [providerOptionsName]: {
                          type: annotation.type,
                          fileId: annotation.file_id,
                          containerId: annotation.container_id
                        }
                      }
                    });
                  } else if (annotation.type === "file_path") {
                    content.push({
                      type: "source",
                      sourceType: "document",
                      id: (_o = (_n = (_m = this.config).generateId) == null ? void 0 : _n.call(_m)) != null ? _o : generateId(),
                      mediaType: "application/octet-stream",
                      title: annotation.file_id,
                      filename: annotation.file_id,
                      providerMetadata: {
                        [providerOptionsName]: {
                          type: annotation.type,
                          fileId: annotation.file_id,
                          index: annotation.index
                        }
                      }
                    });
                  }
                }
              }
              break;
            }
            case "function_call": {
              hasFunctionCall = true;
              content.push({
                type: "tool-call",
                toolCallId: part.call_id,
                toolName: part.name,
                input: part.arguments,
                providerMetadata: {
                  [providerOptionsName]: {
                    itemId: part.id
                  }
                }
              });
              break;
            }
            case "web_search_call": {
              content.push({
                type: "tool-call",
                toolCallId: part.id,
                toolName: toolNameMapping.toCustomToolName(
                  webSearchToolName != null ? webSearchToolName : "web_search"
                ),
                input: JSON.stringify({}),
                providerExecuted: true
              });
              content.push({
                type: "tool-result",
                toolCallId: part.id,
                toolName: toolNameMapping.toCustomToolName(
                  webSearchToolName != null ? webSearchToolName : "web_search"
                ),
                result: mapWebSearchOutput(part.action)
              });
              break;
            }
            case "mcp_call": {
              const toolCallId = part.approval_request_id != null ? (_p = approvalRequestIdToDummyToolCallIdFromPrompt[part.approval_request_id]) != null ? _p : part.id : part.id;
              const toolName = `mcp.${part.name}`;
              content.push({
                type: "tool-call",
                toolCallId,
                toolName,
                input: part.arguments,
                providerExecuted: true,
                dynamic: true
              });
              content.push({
                type: "tool-result",
                toolCallId,
                toolName,
                result: {
                  type: "call",
                  serverLabel: part.server_label,
                  name: part.name,
                  arguments: part.arguments,
                  ...part.output != null ? { output: part.output } : {},
                  ...part.error != null ? { error: part.error } : {}
                },
                providerMetadata: {
                  [providerOptionsName]: {
                    itemId: part.id
                  }
                }
              });
              break;
            }
            case "mcp_list_tools": {
              break;
            }
            case "mcp_approval_request": {
              const approvalRequestId = (_q = part.approval_request_id) != null ? _q : part.id;
              const dummyToolCallId = (_t = (_s = (_r = this.config).generateId) == null ? void 0 : _s.call(_r)) != null ? _t : generateId();
              const toolName = `mcp.${part.name}`;
              content.push({
                type: "tool-call",
                toolCallId: dummyToolCallId,
                toolName,
                input: part.arguments,
                providerExecuted: true,
                dynamic: true
              });
              content.push({
                type: "tool-approval-request",
                approvalId: approvalRequestId,
                toolCallId: dummyToolCallId
              });
              break;
            }
            case "computer_call": {
              content.push({
                type: "tool-call",
                toolCallId: part.id,
                toolName: toolNameMapping.toCustomToolName("computer_use"),
                input: "",
                providerExecuted: true
              });
              content.push({
                type: "tool-result",
                toolCallId: part.id,
                toolName: toolNameMapping.toCustomToolName("computer_use"),
                result: {
                  type: "computer_use_tool_result",
                  status: part.status || "completed"
                }
              });
              break;
            }
            case "file_search_call": {
              content.push({
                type: "tool-call",
                toolCallId: part.id,
                toolName: toolNameMapping.toCustomToolName("file_search"),
                input: "{}",
                providerExecuted: true
              });
              content.push({
                type: "tool-result",
                toolCallId: part.id,
                toolName: toolNameMapping.toCustomToolName("file_search"),
                result: {
                  queries: part.queries,
                  results: (_v = (_u = part.results) == null ? void 0 : _u.map((result) => ({
                    attributes: result.attributes,
                    fileId: result.file_id,
                    filename: result.filename,
                    score: result.score,
                    text: result.text
                  }))) != null ? _v : null
                }
              });
              break;
            }
            case "code_interpreter_call": {
              content.push({
                type: "tool-call",
                toolCallId: part.id,
                toolName: toolNameMapping.toCustomToolName("code_interpreter"),
                input: JSON.stringify({
                  code: part.code,
                  containerId: part.container_id
                }),
                providerExecuted: true
              });
              content.push({
                type: "tool-result",
                toolCallId: part.id,
                toolName: toolNameMapping.toCustomToolName("code_interpreter"),
                result: {
                  outputs: part.outputs
                }
              });
              break;
            }
            case "apply_patch_call": {
              content.push({
                type: "tool-call",
                toolCallId: part.call_id,
                toolName: toolNameMapping.toCustomToolName("apply_patch"),
                input: JSON.stringify({
                  callId: part.call_id,
                  operation: part.operation
                }),
                providerMetadata: {
                  [providerOptionsName]: {
                    itemId: part.id
                  }
                }
              });
              break;
            }
          }
        }
        const providerMetadata = {
          [providerOptionsName]: {
            responseId: response.id,
            ...logprobs.length > 0 ? { logprobs } : {},
            ...typeof response.service_tier === "string" ? { serviceTier: response.service_tier } : {}
          }
        };
        const usage = response.usage;
        return {
          content,
          finishReason: {
            unified: mapOpenAIResponseFinishReason({
              finishReason: (_w = response.incomplete_details) == null ? void 0 : _w.reason,
              hasFunctionCall
            }),
            raw: (_y = (_x = response.incomplete_details) == null ? void 0 : _x.reason) != null ? _y : void 0
          },
          usage: convertOpenAIResponsesUsage(usage),
          request: { body },
          response: {
            id: response.id,
            timestamp: new Date(response.created_at * 1e3),
            modelId: response.model,
            headers: responseHeaders,
            body: rawResponse
          },
          providerMetadata,
          warnings
        };
      }
      async doStream(options) {
        const {
          args: body,
          warnings,
          webSearchToolName,
          toolNameMapping,
          store,
          providerOptionsName
        } = await this.getArgs(options);
        const { responseHeaders, value: response } = await postJsonToApi({
          url: this.config.url({
            path: "/responses",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body: {
            ...body,
            stream: true
          },
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler(
            openaiResponsesChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const self = this;
        const approvalRequestIdToDummyToolCallIdFromPrompt = extractApprovalRequestIdToToolCallIdMapping(options.prompt);
        const approvalRequestIdToDummyToolCallIdFromStream = /* @__PURE__ */ new Map();
        let finishReason = {
          unified: "other",
          raw: void 0
        };
        let usage = void 0;
        const logprobs = [];
        let responseId = null;
        const ongoingToolCalls = {};
        const ongoingAnnotations = [];
        let hasFunctionCall = false;
        const activeReasoning = {};
        let serviceTier;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                var _a25, _b18, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  finishReason = { unified: "error", raw: void 0 };
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value2 = chunk.value;
                if (isResponseOutputItemAddedChunk(value2)) {
                  if (value2.item.type === "function_call") {
                    ongoingToolCalls[value2.output_index] = {
                      toolName: value2.item.name,
                      toolCallId: value2.item.call_id
                    };
                    controller.enqueue({
                      type: "tool-input-start",
                      id: value2.item.call_id,
                      toolName: value2.item.name
                    });
                  } else if (value2.item.type === "web_search_call") {
                    ongoingToolCalls[value2.output_index] = {
                      toolName: toolNameMapping.toCustomToolName(
                        webSearchToolName != null ? webSearchToolName : "web_search"
                      ),
                      toolCallId: value2.item.id
                    };
                    controller.enqueue({
                      type: "tool-input-start",
                      id: value2.item.id,
                      toolName: toolNameMapping.toCustomToolName(
                        webSearchToolName != null ? webSearchToolName : "web_search"
                      ),
                      providerExecuted: true
                    });
                    controller.enqueue({
                      type: "tool-input-end",
                      id: value2.item.id
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: value2.item.id,
                      toolName: toolNameMapping.toCustomToolName(
                        webSearchToolName != null ? webSearchToolName : "web_search"
                      ),
                      input: JSON.stringify({}),
                      providerExecuted: true
                    });
                  } else if (value2.item.type === "computer_call") {
                    ongoingToolCalls[value2.output_index] = {
                      toolName: toolNameMapping.toCustomToolName("computer_use"),
                      toolCallId: value2.item.id
                    };
                    controller.enqueue({
                      type: "tool-input-start",
                      id: value2.item.id,
                      toolName: toolNameMapping.toCustomToolName("computer_use"),
                      providerExecuted: true
                    });
                  } else if (value2.item.type === "code_interpreter_call") {
                    ongoingToolCalls[value2.output_index] = {
                      toolName: toolNameMapping.toCustomToolName("code_interpreter"),
                      toolCallId: value2.item.id,
                      codeInterpreter: {
                        containerId: value2.item.container_id
                      }
                    };
                    controller.enqueue({
                      type: "tool-input-start",
                      id: value2.item.id,
                      toolName: toolNameMapping.toCustomToolName("code_interpreter"),
                      providerExecuted: true
                    });
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: value2.item.id,
                      delta: `{"containerId":"${value2.item.container_id}","code":"`
                    });
                  } else if (value2.item.type === "file_search_call") {
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: value2.item.id,
                      toolName: toolNameMapping.toCustomToolName("file_search"),
                      input: "{}",
                      providerExecuted: true
                    });
                  } else if (value2.item.type === "image_generation_call") {
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: value2.item.id,
                      toolName: toolNameMapping.toCustomToolName("image_generation"),
                      input: "{}",
                      providerExecuted: true
                    });
                  } else if (value2.item.type === "mcp_call" || value2.item.type === "mcp_list_tools" || value2.item.type === "mcp_approval_request") {
                  } else if (value2.item.type === "apply_patch_call") {
                    const { call_id: callId, operation } = value2.item;
                    ongoingToolCalls[value2.output_index] = {
                      toolName: toolNameMapping.toCustomToolName("apply_patch"),
                      toolCallId: callId,
                      applyPatch: {
                        // delete_file doesn't have diff
                        hasDiff: operation.type === "delete_file",
                        endEmitted: operation.type === "delete_file"
                      }
                    };
                    controller.enqueue({
                      type: "tool-input-start",
                      id: callId,
                      toolName: toolNameMapping.toCustomToolName("apply_patch")
                    });
                    if (operation.type === "delete_file") {
                      const inputString = JSON.stringify({
                        callId,
                        operation
                      });
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: callId,
                        delta: inputString
                      });
                      controller.enqueue({
                        type: "tool-input-end",
                        id: callId
                      });
                    } else {
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: callId,
                        delta: `{"callId":"${escapeJSONDelta(callId)}","operation":{"type":"${escapeJSONDelta(operation.type)}","path":"${escapeJSONDelta(operation.path)}","diff":"`
                      });
                    }
                  } else if (value2.item.type === "shell_call") {
                    ongoingToolCalls[value2.output_index] = {
                      toolName: toolNameMapping.toCustomToolName("shell"),
                      toolCallId: value2.item.call_id
                    };
                  } else if (value2.item.type === "message") {
                    ongoingAnnotations.splice(0, ongoingAnnotations.length);
                    controller.enqueue({
                      type: "text-start",
                      id: value2.item.id,
                      providerMetadata: {
                        [providerOptionsName]: {
                          itemId: value2.item.id
                        }
                      }
                    });
                  } else if (isResponseOutputItemAddedChunk(value2) && value2.item.type === "reasoning") {
                    activeReasoning[value2.item.id] = {
                      encryptedContent: value2.item.encrypted_content,
                      summaryParts: { 0: "active" }
                    };
                    controller.enqueue({
                      type: "reasoning-start",
                      id: `${value2.item.id}:0`,
                      providerMetadata: {
                        [providerOptionsName]: {
                          itemId: value2.item.id,
                          reasoningEncryptedContent: (_a25 = value2.item.encrypted_content) != null ? _a25 : null
                        }
                      }
                    });
                  }
                } else if (isResponseOutputItemDoneChunk(value2)) {
                  if (value2.item.type === "message") {
                    controller.enqueue({
                      type: "text-end",
                      id: value2.item.id,
                      providerMetadata: {
                        [providerOptionsName]: {
                          itemId: value2.item.id,
                          ...ongoingAnnotations.length > 0 && {
                            annotations: ongoingAnnotations
                          }
                        }
                      }
                    });
                  } else if (value2.item.type === "function_call") {
                    ongoingToolCalls[value2.output_index] = void 0;
                    hasFunctionCall = true;
                    controller.enqueue({
                      type: "tool-input-end",
                      id: value2.item.call_id
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: value2.item.call_id,
                      toolName: value2.item.name,
                      input: value2.item.arguments,
                      providerMetadata: {
                        [providerOptionsName]: {
                          itemId: value2.item.id
                        }
                      }
                    });
                  } else if (value2.item.type === "web_search_call") {
                    ongoingToolCalls[value2.output_index] = void 0;
                    controller.enqueue({
                      type: "tool-result",
                      toolCallId: value2.item.id,
                      toolName: toolNameMapping.toCustomToolName(
                        webSearchToolName != null ? webSearchToolName : "web_search"
                      ),
                      result: mapWebSearchOutput(value2.item.action)
                    });
                  } else if (value2.item.type === "computer_call") {
                    ongoingToolCalls[value2.output_index] = void 0;
                    controller.enqueue({
                      type: "tool-input-end",
                      id: value2.item.id
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: value2.item.id,
                      toolName: toolNameMapping.toCustomToolName("computer_use"),
                      input: "",
                      providerExecuted: true
                    });
                    controller.enqueue({
                      type: "tool-result",
                      toolCallId: value2.item.id,
                      toolName: toolNameMapping.toCustomToolName("computer_use"),
                      result: {
                        type: "computer_use_tool_result",
                        status: value2.item.status || "completed"
                      }
                    });
                  } else if (value2.item.type === "file_search_call") {
                    ongoingToolCalls[value2.output_index] = void 0;
                    controller.enqueue({
                      type: "tool-result",
                      toolCallId: value2.item.id,
                      toolName: toolNameMapping.toCustomToolName("file_search"),
                      result: {
                        queries: value2.item.queries,
                        results: (_c = (_b18 = value2.item.results) == null ? void 0 : _b18.map((result) => ({
                          attributes: result.attributes,
                          fileId: result.file_id,
                          filename: result.filename,
                          score: result.score,
                          text: result.text
                        }))) != null ? _c : null
                      }
                    });
                  } else if (value2.item.type === "code_interpreter_call") {
                    ongoingToolCalls[value2.output_index] = void 0;
                    controller.enqueue({
                      type: "tool-result",
                      toolCallId: value2.item.id,
                      toolName: toolNameMapping.toCustomToolName("code_interpreter"),
                      result: {
                        outputs: value2.item.outputs
                      }
                    });
                  } else if (value2.item.type === "image_generation_call") {
                    controller.enqueue({
                      type: "tool-result",
                      toolCallId: value2.item.id,
                      toolName: toolNameMapping.toCustomToolName("image_generation"),
                      result: {
                        result: value2.item.result
                      }
                    });
                  } else if (value2.item.type === "mcp_call") {
                    ongoingToolCalls[value2.output_index] = void 0;
                    const approvalRequestId = (_d = value2.item.approval_request_id) != null ? _d : void 0;
                    const aliasedToolCallId = approvalRequestId != null ? (_f = (_e = approvalRequestIdToDummyToolCallIdFromStream.get(
                      approvalRequestId
                    )) != null ? _e : approvalRequestIdToDummyToolCallIdFromPrompt[approvalRequestId]) != null ? _f : value2.item.id : value2.item.id;
                    const toolName = `mcp.${value2.item.name}`;
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: aliasedToolCallId,
                      toolName,
                      input: value2.item.arguments,
                      providerExecuted: true,
                      dynamic: true
                    });
                    controller.enqueue({
                      type: "tool-result",
                      toolCallId: aliasedToolCallId,
                      toolName,
                      result: {
                        type: "call",
                        serverLabel: value2.item.server_label,
                        name: value2.item.name,
                        arguments: value2.item.arguments,
                        ...value2.item.output != null ? { output: value2.item.output } : {},
                        ...value2.item.error != null ? { error: value2.item.error } : {}
                      },
                      providerMetadata: {
                        [providerOptionsName]: {
                          itemId: value2.item.id
                        }
                      }
                    });
                  } else if (value2.item.type === "mcp_list_tools") {
                    ongoingToolCalls[value2.output_index] = void 0;
                  } else if (value2.item.type === "apply_patch_call") {
                    const toolCall = ongoingToolCalls[value2.output_index];
                    if ((toolCall == null ? void 0 : toolCall.applyPatch) && !toolCall.applyPatch.endEmitted && value2.item.operation.type !== "delete_file") {
                      if (!toolCall.applyPatch.hasDiff) {
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: toolCall.toolCallId,
                          delta: escapeJSONDelta(value2.item.operation.diff)
                        });
                      }
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: toolCall.toolCallId,
                        delta: '"}}'
                      });
                      controller.enqueue({
                        type: "tool-input-end",
                        id: toolCall.toolCallId
                      });
                      toolCall.applyPatch.endEmitted = true;
                    }
                    if (toolCall && value2.item.status === "completed") {
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: toolCall.toolCallId,
                        toolName: toolNameMapping.toCustomToolName("apply_patch"),
                        input: JSON.stringify({
                          callId: value2.item.call_id,
                          operation: value2.item.operation
                        }),
                        providerMetadata: {
                          [providerOptionsName]: {
                            itemId: value2.item.id
                          }
                        }
                      });
                    }
                    ongoingToolCalls[value2.output_index] = void 0;
                  } else if (value2.item.type === "mcp_approval_request") {
                    ongoingToolCalls[value2.output_index] = void 0;
                    const dummyToolCallId = (_i = (_h = (_g = self.config).generateId) == null ? void 0 : _h.call(_g)) != null ? _i : generateId();
                    const approvalRequestId = (_j = value2.item.approval_request_id) != null ? _j : value2.item.id;
                    approvalRequestIdToDummyToolCallIdFromStream.set(
                      approvalRequestId,
                      dummyToolCallId
                    );
                    const toolName = `mcp.${value2.item.name}`;
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: dummyToolCallId,
                      toolName,
                      input: value2.item.arguments,
                      providerExecuted: true,
                      dynamic: true
                    });
                    controller.enqueue({
                      type: "tool-approval-request",
                      approvalId: approvalRequestId,
                      toolCallId: dummyToolCallId
                    });
                  } else if (value2.item.type === "local_shell_call") {
                    ongoingToolCalls[value2.output_index] = void 0;
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: value2.item.call_id,
                      toolName: toolNameMapping.toCustomToolName("local_shell"),
                      input: JSON.stringify({
                        action: {
                          type: "exec",
                          command: value2.item.action.command,
                          timeoutMs: value2.item.action.timeout_ms,
                          user: value2.item.action.user,
                          workingDirectory: value2.item.action.working_directory,
                          env: value2.item.action.env
                        }
                      }),
                      providerMetadata: {
                        [providerOptionsName]: { itemId: value2.item.id }
                      }
                    });
                  } else if (value2.item.type === "shell_call") {
                    ongoingToolCalls[value2.output_index] = void 0;
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: value2.item.call_id,
                      toolName: toolNameMapping.toCustomToolName("shell"),
                      input: JSON.stringify({
                        action: {
                          commands: value2.item.action.commands
                        }
                      }),
                      providerMetadata: {
                        [providerOptionsName]: { itemId: value2.item.id }
                      }
                    });
                  } else if (value2.item.type === "reasoning") {
                    const activeReasoningPart = activeReasoning[value2.item.id];
                    const summaryPartIndices = Object.entries(
                      activeReasoningPart.summaryParts
                    ).filter(
                      ([_, status]) => status === "active" || status === "can-conclude"
                    ).map(([summaryIndex]) => summaryIndex);
                    for (const summaryIndex of summaryPartIndices) {
                      controller.enqueue({
                        type: "reasoning-end",
                        id: `${value2.item.id}:${summaryIndex}`,
                        providerMetadata: {
                          [providerOptionsName]: {
                            itemId: value2.item.id,
                            reasoningEncryptedContent: (_k = value2.item.encrypted_content) != null ? _k : null
                          }
                        }
                      });
                    }
                    delete activeReasoning[value2.item.id];
                  }
                } else if (isResponseFunctionCallArgumentsDeltaChunk(value2)) {
                  const toolCall = ongoingToolCalls[value2.output_index];
                  if (toolCall != null) {
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.toolCallId,
                      delta: value2.delta
                    });
                  }
                } else if (isResponseApplyPatchCallOperationDiffDeltaChunk(value2)) {
                  const toolCall = ongoingToolCalls[value2.output_index];
                  if (toolCall == null ? void 0 : toolCall.applyPatch) {
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.toolCallId,
                      delta: escapeJSONDelta(value2.delta)
                    });
                    toolCall.applyPatch.hasDiff = true;
                  }
                } else if (isResponseApplyPatchCallOperationDiffDoneChunk(value2)) {
                  const toolCall = ongoingToolCalls[value2.output_index];
                  if ((toolCall == null ? void 0 : toolCall.applyPatch) && !toolCall.applyPatch.endEmitted) {
                    if (!toolCall.applyPatch.hasDiff) {
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: toolCall.toolCallId,
                        delta: escapeJSONDelta(value2.diff)
                      });
                      toolCall.applyPatch.hasDiff = true;
                    }
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.toolCallId,
                      delta: '"}}'
                    });
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall.toolCallId
                    });
                    toolCall.applyPatch.endEmitted = true;
                  }
                } else if (isResponseImageGenerationCallPartialImageChunk(value2)) {
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: value2.item_id,
                    toolName: toolNameMapping.toCustomToolName("image_generation"),
                    result: {
                      result: value2.partial_image_b64
                    },
                    preliminary: true
                  });
                } else if (isResponseCodeInterpreterCallCodeDeltaChunk(value2)) {
                  const toolCall = ongoingToolCalls[value2.output_index];
                  if (toolCall != null) {
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.toolCallId,
                      delta: escapeJSONDelta(value2.delta)
                    });
                  }
                } else if (isResponseCodeInterpreterCallCodeDoneChunk(value2)) {
                  const toolCall = ongoingToolCalls[value2.output_index];
                  if (toolCall != null) {
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.toolCallId,
                      delta: '"}'
                    });
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall.toolCallId
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: toolCall.toolCallId,
                      toolName: toolNameMapping.toCustomToolName("code_interpreter"),
                      input: JSON.stringify({
                        code: value2.code,
                        containerId: toolCall.codeInterpreter.containerId
                      }),
                      providerExecuted: true
                    });
                  }
                } else if (isResponseCreatedChunk(value2)) {
                  responseId = value2.response.id;
                  controller.enqueue({
                    type: "response-metadata",
                    id: value2.response.id,
                    timestamp: new Date(value2.response.created_at * 1e3),
                    modelId: value2.response.model
                  });
                } else if (isTextDeltaChunk(value2)) {
                  controller.enqueue({
                    type: "text-delta",
                    id: value2.item_id,
                    delta: value2.delta
                  });
                  if (((_m = (_l = options.providerOptions) == null ? void 0 : _l[providerOptionsName]) == null ? void 0 : _m.logprobs) && value2.logprobs) {
                    logprobs.push(value2.logprobs);
                  }
                } else if (value2.type === "response.reasoning_summary_part.added") {
                  if (value2.summary_index > 0) {
                    const activeReasoningPart = activeReasoning[value2.item_id];
                    activeReasoningPart.summaryParts[value2.summary_index] = "active";
                    for (const summaryIndex of Object.keys(
                      activeReasoningPart.summaryParts
                    )) {
                      if (activeReasoningPart.summaryParts[summaryIndex] === "can-conclude") {
                        controller.enqueue({
                          type: "reasoning-end",
                          id: `${value2.item_id}:${summaryIndex}`,
                          providerMetadata: {
                            [providerOptionsName]: {
                              itemId: value2.item_id
                            }
                          }
                        });
                        activeReasoningPart.summaryParts[summaryIndex] = "concluded";
                      }
                    }
                    controller.enqueue({
                      type: "reasoning-start",
                      id: `${value2.item_id}:${value2.summary_index}`,
                      providerMetadata: {
                        [providerOptionsName]: {
                          itemId: value2.item_id,
                          reasoningEncryptedContent: (_o = (_n = activeReasoning[value2.item_id]) == null ? void 0 : _n.encryptedContent) != null ? _o : null
                        }
                      }
                    });
                  }
                } else if (value2.type === "response.reasoning_summary_text.delta") {
                  controller.enqueue({
                    type: "reasoning-delta",
                    id: `${value2.item_id}:${value2.summary_index}`,
                    delta: value2.delta,
                    providerMetadata: {
                      [providerOptionsName]: {
                        itemId: value2.item_id
                      }
                    }
                  });
                } else if (value2.type === "response.reasoning_summary_part.done") {
                  if (store) {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: `${value2.item_id}:${value2.summary_index}`,
                      providerMetadata: {
                        [providerOptionsName]: {
                          itemId: value2.item_id
                        }
                      }
                    });
                    activeReasoning[value2.item_id].summaryParts[value2.summary_index] = "concluded";
                  } else {
                    activeReasoning[value2.item_id].summaryParts[value2.summary_index] = "can-conclude";
                  }
                } else if (isResponseFinishedChunk(value2)) {
                  finishReason = {
                    unified: mapOpenAIResponseFinishReason({
                      finishReason: (_p = value2.response.incomplete_details) == null ? void 0 : _p.reason,
                      hasFunctionCall
                    }),
                    raw: (_r = (_q = value2.response.incomplete_details) == null ? void 0 : _q.reason) != null ? _r : void 0
                  };
                  usage = value2.response.usage;
                  if (typeof value2.response.service_tier === "string") {
                    serviceTier = value2.response.service_tier;
                  }
                } else if (isResponseAnnotationAddedChunk(value2)) {
                  ongoingAnnotations.push(value2.annotation);
                  if (value2.annotation.type === "url_citation") {
                    controller.enqueue({
                      type: "source",
                      sourceType: "url",
                      id: (_u = (_t = (_s = self.config).generateId) == null ? void 0 : _t.call(_s)) != null ? _u : generateId(),
                      url: value2.annotation.url,
                      title: value2.annotation.title
                    });
                  } else if (value2.annotation.type === "file_citation") {
                    controller.enqueue({
                      type: "source",
                      sourceType: "document",
                      id: (_x = (_w = (_v = self.config).generateId) == null ? void 0 : _w.call(_v)) != null ? _x : generateId(),
                      mediaType: "text/plain",
                      title: value2.annotation.filename,
                      filename: value2.annotation.filename,
                      providerMetadata: {
                        [providerOptionsName]: {
                          type: value2.annotation.type,
                          fileId: value2.annotation.file_id,
                          index: value2.annotation.index
                        }
                      }
                    });
                  } else if (value2.annotation.type === "container_file_citation") {
                    controller.enqueue({
                      type: "source",
                      sourceType: "document",
                      id: (_A = (_z = (_y = self.config).generateId) == null ? void 0 : _z.call(_y)) != null ? _A : generateId(),
                      mediaType: "text/plain",
                      title: value2.annotation.filename,
                      filename: value2.annotation.filename,
                      providerMetadata: {
                        [providerOptionsName]: {
                          type: value2.annotation.type,
                          fileId: value2.annotation.file_id,
                          containerId: value2.annotation.container_id
                        }
                      }
                    });
                  } else if (value2.annotation.type === "file_path") {
                    controller.enqueue({
                      type: "source",
                      sourceType: "document",
                      id: (_D = (_C = (_B = self.config).generateId) == null ? void 0 : _C.call(_B)) != null ? _D : generateId(),
                      mediaType: "application/octet-stream",
                      title: value2.annotation.file_id,
                      filename: value2.annotation.file_id,
                      providerMetadata: {
                        [providerOptionsName]: {
                          type: value2.annotation.type,
                          fileId: value2.annotation.file_id,
                          index: value2.annotation.index
                        }
                      }
                    });
                  }
                } else if (isErrorChunk(value2)) {
                  controller.enqueue({ type: "error", error: value2 });
                }
              },
              flush(controller) {
                const providerMetadata = {
                  [providerOptionsName]: {
                    responseId,
                    ...logprobs.length > 0 ? { logprobs } : {},
                    ...serviceTier !== void 0 ? { serviceTier } : {}
                  }
                };
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage: convertOpenAIResponsesUsage(usage),
                  providerMetadata
                });
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    openaiSpeechProviderOptionsSchema = lazySchema(
      () => zodSchema(
        z21.object({
          instructions: z21.string().nullish(),
          speed: z21.number().min(0.25).max(4).default(1).nullish()
        })
      )
    );
    OpenAISpeechModel = class {
      constructor(modelId, config2) {
        this.modelId = modelId;
        this.config = config2;
        this.specificationVersion = "v3";
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        text: text2,
        voice: voice2 = "alloy",
        outputFormat = "mp3",
        speed,
        instructions,
        language,
        providerOptions
      }) {
        const warnings = [];
        const openAIOptions = await parseProviderOptions({
          provider: "openai",
          providerOptions,
          schema: openaiSpeechProviderOptionsSchema
        });
        const requestBody = {
          model: this.modelId,
          input: text2,
          voice: voice2,
          response_format: "mp3",
          speed,
          instructions
        };
        if (outputFormat) {
          if (["mp3", "opus", "aac", "flac", "wav", "pcm"].includes(outputFormat)) {
            requestBody.response_format = outputFormat;
          } else {
            warnings.push({
              type: "unsupported",
              feature: "outputFormat",
              details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`
            });
          }
        }
        if (openAIOptions) {
          const speechModelOptions = {};
          for (const key in speechModelOptions) {
            const value2 = speechModelOptions[key];
            if (value2 !== void 0) {
              requestBody[key] = value2;
            }
          }
        }
        if (language) {
          warnings.push({
            type: "unsupported",
            feature: "language",
            details: `OpenAI speech models do not support language selection. Language parameter "${language}" was ignored.`
          });
        }
        return {
          requestBody,
          warnings
        };
      }
      async doGenerate(options) {
        var _a25, _b18, _c;
        const currentDate = (_c = (_b18 = (_a25 = this.config._internal) == null ? void 0 : _a25.currentDate) == null ? void 0 : _b18.call(_a25)) != null ? _c : /* @__PURE__ */ new Date();
        const { requestBody, warnings } = await this.getArgs(options);
        const {
          value: audio,
          responseHeaders,
          rawValue: rawResponse
        } = await postJsonToApi({
          url: this.config.url({
            path: "/audio/speech",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body: requestBody,
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createBinaryResponseHandler(),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        return {
          audio,
          warnings,
          request: {
            body: JSON.stringify(requestBody)
          },
          response: {
            timestamp: currentDate,
            modelId: this.modelId,
            headers: responseHeaders,
            body: rawResponse
          }
        };
      }
    };
    openaiTranscriptionResponseSchema = lazySchema(
      () => zodSchema(
        z222.object({
          text: z222.string(),
          language: z222.string().nullish(),
          duration: z222.number().nullish(),
          words: z222.array(
            z222.object({
              word: z222.string(),
              start: z222.number(),
              end: z222.number()
            })
          ).nullish(),
          segments: z222.array(
            z222.object({
              id: z222.number(),
              seek: z222.number(),
              start: z222.number(),
              end: z222.number(),
              text: z222.string(),
              tokens: z222.array(z222.number()),
              temperature: z222.number(),
              avg_logprob: z222.number(),
              compression_ratio: z222.number(),
              no_speech_prob: z222.number()
            })
          ).nullish()
        })
      )
    );
    openAITranscriptionProviderOptions = lazySchema(
      () => zodSchema(
        z232.object({
          /**
           * Additional information to include in the transcription response.
           */
          include: z232.array(z232.string()).optional(),
          /**
           * The language of the input audio in ISO-639-1 format.
           */
          language: z232.string().optional(),
          /**
           * An optional text to guide the model's style or continue a previous audio segment.
           */
          prompt: z232.string().optional(),
          /**
           * The sampling temperature, between 0 and 1.
           * @default 0
           */
          temperature: z232.number().min(0).max(1).default(0).optional(),
          /**
           * The timestamp granularities to populate for this transcription.
           * @default ['segment']
           */
          timestampGranularities: z232.array(z232.enum(["word", "segment"])).default(["segment"]).optional()
        })
      )
    );
    languageMap = {
      afrikaans: "af",
      arabic: "ar",
      armenian: "hy",
      azerbaijani: "az",
      belarusian: "be",
      bosnian: "bs",
      bulgarian: "bg",
      catalan: "ca",
      chinese: "zh",
      croatian: "hr",
      czech: "cs",
      danish: "da",
      dutch: "nl",
      english: "en",
      estonian: "et",
      finnish: "fi",
      french: "fr",
      galician: "gl",
      german: "de",
      greek: "el",
      hebrew: "he",
      hindi: "hi",
      hungarian: "hu",
      icelandic: "is",
      indonesian: "id",
      italian: "it",
      japanese: "ja",
      kannada: "kn",
      kazakh: "kk",
      korean: "ko",
      latvian: "lv",
      lithuanian: "lt",
      macedonian: "mk",
      malay: "ms",
      marathi: "mr",
      maori: "mi",
      nepali: "ne",
      norwegian: "no",
      persian: "fa",
      polish: "pl",
      portuguese: "pt",
      romanian: "ro",
      russian: "ru",
      serbian: "sr",
      slovak: "sk",
      slovenian: "sl",
      spanish: "es",
      swahili: "sw",
      swedish: "sv",
      tagalog: "tl",
      tamil: "ta",
      thai: "th",
      turkish: "tr",
      ukrainian: "uk",
      urdu: "ur",
      vietnamese: "vi",
      welsh: "cy"
    };
    OpenAITranscriptionModel = class {
      constructor(modelId, config2) {
        this.modelId = modelId;
        this.config = config2;
        this.specificationVersion = "v3";
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        audio,
        mediaType,
        providerOptions
      }) {
        const warnings = [];
        const openAIOptions = await parseProviderOptions({
          provider: "openai",
          providerOptions,
          schema: openAITranscriptionProviderOptions
        });
        const formData = new FormData();
        const blob = audio instanceof Uint8Array ? new Blob([audio]) : new Blob([convertBase64ToUint8Array(audio)]);
        formData.append("model", this.modelId);
        const fileExtension = mediaTypeToExtension(mediaType);
        formData.append(
          "file",
          new File([blob], "audio", { type: mediaType }),
          `audio.${fileExtension}`
        );
        if (openAIOptions) {
          const transcriptionModelOptions = {
            include: openAIOptions.include,
            language: openAIOptions.language,
            prompt: openAIOptions.prompt,
            // https://platform.openai.com/docs/api-reference/audio/createTranscription#audio_createtranscription-response_format
            // prefer verbose_json to get segments for models that support it
            response_format: [
              "gpt-4o-transcribe",
              "gpt-4o-mini-transcribe"
            ].includes(this.modelId) ? "json" : "verbose_json",
            temperature: openAIOptions.temperature,
            timestamp_granularities: openAIOptions.timestampGranularities
          };
          for (const [key, value2] of Object.entries(transcriptionModelOptions)) {
            if (value2 != null) {
              if (Array.isArray(value2)) {
                for (const item of value2) {
                  formData.append(`${key}[]`, String(item));
                }
              } else {
                formData.append(key, String(value2));
              }
            }
          }
        }
        return {
          formData,
          warnings
        };
      }
      async doGenerate(options) {
        var _a25, _b18, _c, _d, _e, _f, _g, _h;
        const currentDate = (_c = (_b18 = (_a25 = this.config._internal) == null ? void 0 : _a25.currentDate) == null ? void 0 : _b18.call(_a25)) != null ? _c : /* @__PURE__ */ new Date();
        const { formData, warnings } = await this.getArgs(options);
        const {
          value: response,
          responseHeaders,
          rawValue: rawResponse
        } = await postFormDataToApi({
          url: this.config.url({
            path: "/audio/transcriptions",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          formData,
          failedResponseHandler: openaiFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            openaiTranscriptionResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const language = response.language != null && response.language in languageMap ? languageMap[response.language] : void 0;
        return {
          text: response.text,
          segments: (_g = (_f = (_d = response.segments) == null ? void 0 : _d.map((segment) => ({
            text: segment.text,
            startSecond: segment.start,
            endSecond: segment.end
          }))) != null ? _f : (_e = response.words) == null ? void 0 : _e.map((word) => ({
            text: word.word,
            startSecond: word.start,
            endSecond: word.end
          }))) != null ? _g : [],
          language,
          durationInSeconds: (_h = response.duration) != null ? _h : void 0,
          warnings,
          response: {
            timestamp: currentDate,
            modelId: this.modelId,
            headers: responseHeaders,
            body: rawResponse
          }
        };
      }
    };
    VERSION6 = true ? "3.0.25" : "0.0.0-test";
    openai = createOpenAI();
  }
});

// node_modules/@ai-sdk/google/dist/index.mjs
var dist_exports5 = {};
__export(dist_exports5, {
  VERSION: () => VERSION7,
  createGoogleGenerativeAI: () => createGoogleGenerativeAI,
  google: () => google
});
import { z as z36 } from "zod/v4";
import { z as z26 } from "zod/v4";
import { z as z27 } from "zod/v4";
import { z as z56 } from "zod/v4";
import { z as z47 } from "zod/v4";
import { z as z66 } from "zod/v4";
import { z as z76 } from "zod/v4";
import { z as z86 } from "zod/v4";
import { z as z95 } from "zod/v4";
import { z as z105 } from "zod/v4";
import { z as z114 } from "zod/v4";
import { z as z124 } from "zod/v4";
import { z as z134 } from "zod/v4";
import { z as z144 } from "zod/v4";
function convertGoogleGenerativeAIUsage(usage) {
  var _a25, _b18, _c, _d;
  if (usage == null) {
    return {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
  }
  const promptTokens = (_a25 = usage.promptTokenCount) != null ? _a25 : 0;
  const candidatesTokens = (_b18 = usage.candidatesTokenCount) != null ? _b18 : 0;
  const cachedContentTokens = (_c = usage.cachedContentTokenCount) != null ? _c : 0;
  const thoughtsTokens = (_d = usage.thoughtsTokenCount) != null ? _d : 0;
  return {
    inputTokens: {
      total: promptTokens,
      noCache: promptTokens - cachedContentTokens,
      cacheRead: cachedContentTokens,
      cacheWrite: void 0
    },
    outputTokens: {
      total: candidatesTokens + thoughtsTokens,
      text: candidatesTokens,
      reasoning: thoughtsTokens
    },
    raw: usage
  };
}
function convertJSONSchemaToOpenAPISchema(jsonSchema3, isRoot = true) {
  if (jsonSchema3 == null) {
    return void 0;
  }
  if (isEmptyObjectSchema(jsonSchema3)) {
    if (isRoot) {
      return void 0;
    }
    if (typeof jsonSchema3 === "object" && jsonSchema3.description) {
      return { type: "object", description: jsonSchema3.description };
    }
    return { type: "object" };
  }
  if (typeof jsonSchema3 === "boolean") {
    return { type: "boolean", properties: {} };
  }
  const {
    type: type2,
    description,
    required,
    properties,
    items,
    allOf,
    anyOf,
    oneOf,
    format,
    const: constValue,
    minLength,
    enum: enumValues
  } = jsonSchema3;
  const result = {};
  if (description) result.description = description;
  if (required) result.required = required;
  if (format) result.format = format;
  if (constValue !== void 0) {
    result.enum = [constValue];
  }
  if (type2) {
    if (Array.isArray(type2)) {
      const hasNull = type2.includes("null");
      const nonNullTypes = type2.filter((t) => t !== "null");
      if (nonNullTypes.length === 0) {
        result.type = "null";
      } else {
        result.anyOf = nonNullTypes.map((t) => ({ type: t }));
        if (hasNull) {
          result.nullable = true;
        }
      }
    } else {
      result.type = type2;
    }
  }
  if (enumValues !== void 0) {
    result.enum = enumValues;
  }
  if (properties != null) {
    result.properties = Object.entries(properties).reduce(
      (acc, [key, value2]) => {
        acc[key] = convertJSONSchemaToOpenAPISchema(value2, false);
        return acc;
      },
      {}
    );
  }
  if (items) {
    result.items = Array.isArray(items) ? items.map((item) => convertJSONSchemaToOpenAPISchema(item, false)) : convertJSONSchemaToOpenAPISchema(items, false);
  }
  if (allOf) {
    result.allOf = allOf.map(
      (item) => convertJSONSchemaToOpenAPISchema(item, false)
    );
  }
  if (anyOf) {
    if (anyOf.some(
      (schema) => typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null"
    )) {
      const nonNullSchemas = anyOf.filter(
        (schema) => !(typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null")
      );
      if (nonNullSchemas.length === 1) {
        const converted = convertJSONSchemaToOpenAPISchema(
          nonNullSchemas[0],
          false
        );
        if (typeof converted === "object") {
          result.nullable = true;
          Object.assign(result, converted);
        }
      } else {
        result.anyOf = nonNullSchemas.map(
          (item) => convertJSONSchemaToOpenAPISchema(item, false)
        );
        result.nullable = true;
      }
    } else {
      result.anyOf = anyOf.map(
        (item) => convertJSONSchemaToOpenAPISchema(item, false)
      );
    }
  }
  if (oneOf) {
    result.oneOf = oneOf.map(
      (item) => convertJSONSchemaToOpenAPISchema(item, false)
    );
  }
  if (minLength !== void 0) {
    result.minLength = minLength;
  }
  return result;
}
function isEmptyObjectSchema(jsonSchema3) {
  return jsonSchema3 != null && typeof jsonSchema3 === "object" && jsonSchema3.type === "object" && (jsonSchema3.properties == null || Object.keys(jsonSchema3.properties).length === 0) && !jsonSchema3.additionalProperties;
}
function convertToGoogleGenerativeAIMessages(prompt, options) {
  var _a25, _b18, _c;
  const systemInstructionParts = [];
  const contents = [];
  let systemMessagesAllowed = true;
  const isGemmaModel = (_a25 = options == null ? void 0 : options.isGemmaModel) != null ? _a25 : false;
  const providerOptionsName = (_b18 = options == null ? void 0 : options.providerOptionsName) != null ? _b18 : "google";
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        if (!systemMessagesAllowed) {
          throw new UnsupportedFunctionalityError({
            functionality: "system messages are only supported at the beginning of the conversation"
          });
        }
        systemInstructionParts.push({ text: content });
        break;
      }
      case "user": {
        systemMessagesAllowed = false;
        const parts = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              parts.push({ text: part.text });
              break;
            }
            case "file": {
              const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
              parts.push(
                part.data instanceof URL ? {
                  fileData: {
                    mimeType: mediaType,
                    fileUri: part.data.toString()
                  }
                } : {
                  inlineData: {
                    mimeType: mediaType,
                    data: convertToBase64(part.data)
                  }
                }
              );
              break;
            }
          }
        }
        contents.push({ role: "user", parts });
        break;
      }
      case "assistant": {
        systemMessagesAllowed = false;
        contents.push({
          role: "model",
          parts: content.map((part) => {
            var _a26;
            const providerOpts = (_a26 = part.providerOptions) == null ? void 0 : _a26[providerOptionsName];
            const thoughtSignature = (providerOpts == null ? void 0 : providerOpts.thoughtSignature) != null ? String(providerOpts.thoughtSignature) : void 0;
            switch (part.type) {
              case "text": {
                return part.text.length === 0 ? void 0 : {
                  text: part.text,
                  thoughtSignature
                };
              }
              case "reasoning": {
                return part.text.length === 0 ? void 0 : {
                  text: part.text,
                  thought: true,
                  thoughtSignature
                };
              }
              case "file": {
                if (part.data instanceof URL) {
                  throw new UnsupportedFunctionalityError({
                    functionality: "File data URLs in assistant messages are not supported"
                  });
                }
                return {
                  inlineData: {
                    mimeType: part.mediaType,
                    data: convertToBase64(part.data)
                  },
                  thoughtSignature
                };
              }
              case "tool-call": {
                return {
                  functionCall: {
                    name: part.toolName,
                    args: part.input
                  },
                  thoughtSignature
                };
              }
            }
          }).filter((part) => part !== void 0)
        });
        break;
      }
      case "tool": {
        systemMessagesAllowed = false;
        const parts = [];
        for (const part of content) {
          if (part.type === "tool-approval-response") {
            continue;
          }
          const output = part.output;
          if (output.type === "content") {
            for (const contentPart of output.value) {
              switch (contentPart.type) {
                case "text":
                  parts.push({
                    functionResponse: {
                      name: part.toolName,
                      response: {
                        name: part.toolName,
                        content: contentPart.text
                      }
                    }
                  });
                  break;
                case "image-data":
                  parts.push(
                    {
                      inlineData: {
                        mimeType: contentPart.mediaType,
                        data: contentPart.data
                      }
                    },
                    {
                      text: "Tool executed successfully and returned this image as a response"
                    }
                  );
                  break;
                default:
                  parts.push({ text: JSON.stringify(contentPart) });
                  break;
              }
            }
          } else {
            parts.push({
              functionResponse: {
                name: part.toolName,
                response: {
                  name: part.toolName,
                  content: output.type === "execution-denied" ? (_c = output.reason) != null ? _c : "Tool execution denied." : output.value
                }
              }
            });
          }
        }
        contents.push({
          role: "user",
          parts
        });
        break;
      }
    }
  }
  if (isGemmaModel && systemInstructionParts.length > 0 && contents.length > 0 && contents[0].role === "user") {
    const systemText = systemInstructionParts.map((part) => part.text).join("\n\n");
    contents[0].parts.unshift({ text: systemText + "\n\n" });
  }
  return {
    systemInstruction: systemInstructionParts.length > 0 && !isGemmaModel ? { parts: systemInstructionParts } : void 0,
    contents
  };
}
function getModelPath(modelId) {
  return modelId.includes("/") ? modelId : `models/${modelId}`;
}
function prepareTools2({
  tools,
  toolChoice,
  modelId
}) {
  var _a25;
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  const isLatest = [
    "gemini-flash-latest",
    "gemini-flash-lite-latest",
    "gemini-pro-latest"
  ].some((id) => id === modelId);
  const isGemini2orNewer = modelId.includes("gemini-2") || modelId.includes("gemini-3") || isLatest;
  const supportsDynamicRetrieval = modelId.includes("gemini-1.5-flash") && !modelId.includes("-8b");
  const supportsFileSearch = modelId.includes("gemini-2.5") || modelId.includes("gemini-3");
  if (tools == null) {
    return { tools: void 0, toolConfig: void 0, toolWarnings };
  }
  const hasFunctionTools = tools.some((tool2) => tool2.type === "function");
  const hasProviderTools = tools.some((tool2) => tool2.type === "provider");
  if (hasFunctionTools && hasProviderTools) {
    toolWarnings.push({
      type: "unsupported",
      feature: `combination of function and provider-defined tools`
    });
  }
  if (hasProviderTools) {
    const googleTools2 = [];
    const ProviderTools = tools.filter((tool2) => tool2.type === "provider");
    ProviderTools.forEach((tool2) => {
      switch (tool2.id) {
        case "google.google_search":
          if (isGemini2orNewer) {
            googleTools2.push({ googleSearch: {} });
          } else if (supportsDynamicRetrieval) {
            googleTools2.push({
              googleSearchRetrieval: {
                dynamicRetrievalConfig: {
                  mode: tool2.args.mode,
                  dynamicThreshold: tool2.args.dynamicThreshold
                }
              }
            });
          } else {
            googleTools2.push({ googleSearchRetrieval: {} });
          }
          break;
        case "google.enterprise_web_search":
          if (isGemini2orNewer) {
            googleTools2.push({ enterpriseWebSearch: {} });
          } else {
            toolWarnings.push({
              type: "unsupported",
              feature: `provider-defined tool ${tool2.id}`,
              details: "Enterprise Web Search requires Gemini 2.0 or newer."
            });
          }
          break;
        case "google.url_context":
          if (isGemini2orNewer) {
            googleTools2.push({ urlContext: {} });
          } else {
            toolWarnings.push({
              type: "unsupported",
              feature: `provider-defined tool ${tool2.id}`,
              details: "The URL context tool is not supported with other Gemini models than Gemini 2."
            });
          }
          break;
        case "google.code_execution":
          if (isGemini2orNewer) {
            googleTools2.push({ codeExecution: {} });
          } else {
            toolWarnings.push({
              type: "unsupported",
              feature: `provider-defined tool ${tool2.id}`,
              details: "The code execution tools is not supported with other Gemini models than Gemini 2."
            });
          }
          break;
        case "google.file_search":
          if (supportsFileSearch) {
            googleTools2.push({ fileSearch: { ...tool2.args } });
          } else {
            toolWarnings.push({
              type: "unsupported",
              feature: `provider-defined tool ${tool2.id}`,
              details: "The file search tool is only supported with Gemini 2.5 models and Gemini 3 models."
            });
          }
          break;
        case "google.vertex_rag_store":
          if (isGemini2orNewer) {
            googleTools2.push({
              retrieval: {
                vertex_rag_store: {
                  rag_resources: {
                    rag_corpus: tool2.args.ragCorpus
                  },
                  similarity_top_k: tool2.args.topK
                }
              }
            });
          } else {
            toolWarnings.push({
              type: "unsupported",
              feature: `provider-defined tool ${tool2.id}`,
              details: "The RAG store tool is not supported with other Gemini models than Gemini 2."
            });
          }
          break;
        case "google.google_maps":
          if (isGemini2orNewer) {
            googleTools2.push({ googleMaps: {} });
          } else {
            toolWarnings.push({
              type: "unsupported",
              feature: `provider-defined tool ${tool2.id}`,
              details: "The Google Maps grounding tool is not supported with Gemini models other than Gemini 2 or newer."
            });
          }
          break;
        default:
          toolWarnings.push({
            type: "unsupported",
            feature: `provider-defined tool ${tool2.id}`
          });
          break;
      }
    });
    return {
      tools: googleTools2.length > 0 ? googleTools2 : void 0,
      toolConfig: void 0,
      toolWarnings
    };
  }
  const functionDeclarations = [];
  for (const tool2 of tools) {
    switch (tool2.type) {
      case "function":
        functionDeclarations.push({
          name: tool2.name,
          description: (_a25 = tool2.description) != null ? _a25 : "",
          parameters: convertJSONSchemaToOpenAPISchema(tool2.inputSchema)
        });
        break;
      default:
        toolWarnings.push({
          type: "unsupported",
          feature: `function tool ${tool2.name}`
        });
        break;
    }
  }
  if (toolChoice == null) {
    return {
      tools: [{ functionDeclarations }],
      toolConfig: void 0,
      toolWarnings
    };
  }
  const type2 = toolChoice.type;
  switch (type2) {
    case "auto":
      return {
        tools: [{ functionDeclarations }],
        toolConfig: { functionCallingConfig: { mode: "AUTO" } },
        toolWarnings
      };
    case "none":
      return {
        tools: [{ functionDeclarations }],
        toolConfig: { functionCallingConfig: { mode: "NONE" } },
        toolWarnings
      };
    case "required":
      return {
        tools: [{ functionDeclarations }],
        toolConfig: { functionCallingConfig: { mode: "ANY" } },
        toolWarnings
      };
    case "tool":
      return {
        tools: [{ functionDeclarations }],
        toolConfig: {
          functionCallingConfig: {
            mode: "ANY",
            allowedFunctionNames: [toolChoice.toolName]
          }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type2;
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function mapGoogleGenerativeAIFinishReason({
  finishReason,
  hasToolCalls
}) {
  switch (finishReason) {
    case "STOP":
      return hasToolCalls ? "tool-calls" : "stop";
    case "MAX_TOKENS":
      return "length";
    case "IMAGE_SAFETY":
    case "RECITATION":
    case "SAFETY":
    case "BLOCKLIST":
    case "PROHIBITED_CONTENT":
    case "SPII":
      return "content-filter";
    case "MALFORMED_FUNCTION_CALL":
      return "error";
    case "FINISH_REASON_UNSPECIFIED":
    case "OTHER":
    default:
      return "other";
  }
}
function getToolCallsFromParts({
  parts,
  generateId: generateId3,
  providerOptionsName
}) {
  const functionCallParts = parts == null ? void 0 : parts.filter(
    (part) => "functionCall" in part
  );
  return functionCallParts == null || functionCallParts.length === 0 ? void 0 : functionCallParts.map((part) => ({
    type: "tool-call",
    toolCallId: generateId3(),
    toolName: part.functionCall.name,
    args: JSON.stringify(part.functionCall.args),
    providerMetadata: part.thoughtSignature ? {
      [providerOptionsName]: {
        thoughtSignature: part.thoughtSignature
      }
    } : void 0
  }));
}
function extractSources({
  groundingMetadata,
  generateId: generateId3
}) {
  var _a25, _b18, _c, _d, _e;
  if (!(groundingMetadata == null ? void 0 : groundingMetadata.groundingChunks)) {
    return void 0;
  }
  const sources = [];
  for (const chunk of groundingMetadata.groundingChunks) {
    if (chunk.web != null) {
      sources.push({
        type: "source",
        sourceType: "url",
        id: generateId3(),
        url: chunk.web.uri,
        title: (_a25 = chunk.web.title) != null ? _a25 : void 0
      });
    } else if (chunk.retrievedContext != null) {
      const uri = chunk.retrievedContext.uri;
      const fileSearchStore = chunk.retrievedContext.fileSearchStore;
      if (uri && (uri.startsWith("http://") || uri.startsWith("https://"))) {
        sources.push({
          type: "source",
          sourceType: "url",
          id: generateId3(),
          url: uri,
          title: (_b18 = chunk.retrievedContext.title) != null ? _b18 : void 0
        });
      } else if (uri) {
        const title = (_c = chunk.retrievedContext.title) != null ? _c : "Unknown Document";
        let mediaType = "application/octet-stream";
        let filename = void 0;
        if (uri.endsWith(".pdf")) {
          mediaType = "application/pdf";
          filename = uri.split("/").pop();
        } else if (uri.endsWith(".txt")) {
          mediaType = "text/plain";
          filename = uri.split("/").pop();
        } else if (uri.endsWith(".docx")) {
          mediaType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
          filename = uri.split("/").pop();
        } else if (uri.endsWith(".doc")) {
          mediaType = "application/msword";
          filename = uri.split("/").pop();
        } else if (uri.match(/\.(md|markdown)$/)) {
          mediaType = "text/markdown";
          filename = uri.split("/").pop();
        } else {
          filename = uri.split("/").pop();
        }
        sources.push({
          type: "source",
          sourceType: "document",
          id: generateId3(),
          mediaType,
          title,
          filename
        });
      } else if (fileSearchStore) {
        const title = (_d = chunk.retrievedContext.title) != null ? _d : "Unknown Document";
        sources.push({
          type: "source",
          sourceType: "document",
          id: generateId3(),
          mediaType: "application/octet-stream",
          title,
          filename: fileSearchStore.split("/").pop()
        });
      }
    } else if (chunk.maps != null) {
      if (chunk.maps.uri) {
        sources.push({
          type: "source",
          sourceType: "url",
          id: generateId3(),
          url: chunk.maps.uri,
          title: (_e = chunk.maps.title) != null ? _e : void 0
        });
      }
    }
  }
  return sources.length > 0 ? sources : void 0;
}
function createGoogleGenerativeAI(options = {}) {
  var _a25, _b18;
  const baseURL = (_a25 = withoutTrailingSlash(options.baseURL)) != null ? _a25 : "https://generativelanguage.googleapis.com/v1beta";
  const providerName = (_b18 = options.name) != null ? _b18 : "google.generative-ai";
  const getHeaders = () => withUserAgentSuffix(
    {
      "x-goog-api-key": loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "GOOGLE_GENERATIVE_AI_API_KEY",
        description: "Google Generative AI"
      }),
      ...options.headers
    },
    `ai-sdk/google/${VERSION7}`
  );
  const createChatModel = (modelId) => {
    var _a26;
    return new GoogleGenerativeAILanguageModel(modelId, {
      provider: providerName,
      baseURL,
      headers: getHeaders,
      generateId: (_a26 = options.generateId) != null ? _a26 : generateId,
      supportedUrls: () => ({
        "*": [
          // Google Generative Language "files" endpoint
          // e.g. https://generativelanguage.googleapis.com/v1beta/files/...
          new RegExp(`^${baseURL}/files/.*$`),
          // YouTube URLs (public or unlisted videos)
          new RegExp(
            `^https://(?:www\\.)?youtube\\.com/watch\\?v=[\\w-]+(?:&[\\w=&.-]*)?$`
          ),
          new RegExp(`^https://youtu\\.be/[\\w-]+(?:\\?[\\w=&.-]*)?$`)
        ]
      }),
      fetch: options.fetch
    });
  };
  const createEmbeddingModel = (modelId) => new GoogleGenerativeAIEmbeddingModel(modelId, {
    provider: providerName,
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createImageModel = (modelId, settings = {}) => new GoogleGenerativeAIImageModel(modelId, settings, {
    provider: providerName,
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createVideoModel = (modelId) => {
    var _a26;
    return new GoogleGenerativeAIVideoModel(modelId, {
      provider: providerName,
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      generateId: (_a26 = options.generateId) != null ? _a26 : generateId
    });
  };
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Google Generative AI model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  provider.specificationVersion = "v3";
  provider.languageModel = createChatModel;
  provider.chat = createChatModel;
  provider.generativeAI = createChatModel;
  provider.embedding = createEmbeddingModel;
  provider.embeddingModel = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  provider.video = createVideoModel;
  provider.tools = googleTools;
  return provider;
}
var VERSION7, googleErrorDataSchema, googleFailedResponseHandler, googleGenerativeAIEmbeddingProviderOptions, GoogleGenerativeAIEmbeddingModel, googleGenerativeAITextEmbeddingResponseSchema, googleGenerativeAISingleEmbeddingResponseSchema, googleGenerativeAIProviderOptions, GoogleGenerativeAILanguageModel, getGroundingMetadataSchema, getContentSchema, getSafetyRatingSchema, usageSchema, getUrlContextMetadataSchema, responseSchema, chunkSchema, codeExecution, enterpriseWebSearch, fileSearchArgsBaseSchema, fileSearchArgsSchema2, fileSearch2, googleMaps, googleSearch, urlContext, vertexRagStore, googleTools, GoogleGenerativeAIImageModel, googleImageResponseSchema, googleImageProviderOptionsSchema, GoogleGenerativeAIVideoModel, googleOperationSchema, googleVideoProviderOptionsSchema, google;
var init_dist13 = __esm({
  "node_modules/@ai-sdk/google/dist/index.mjs"() {
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    VERSION7 = true ? "3.0.21" : "0.0.0-test";
    googleErrorDataSchema = lazySchema(
      () => zodSchema(
        z26.object({
          error: z26.object({
            code: z26.number().nullable(),
            message: z26.string(),
            status: z26.string()
          })
        })
      )
    );
    googleFailedResponseHandler = createJsonErrorResponseHandler({
      errorSchema: googleErrorDataSchema,
      errorToMessage: (data) => data.error.message
    });
    googleGenerativeAIEmbeddingProviderOptions = lazySchema(
      () => zodSchema(
        z27.object({
          /**
           * Optional. Optional reduced dimension for the output embedding.
           * If set, excessive values in the output embedding are truncated from the end.
           */
          outputDimensionality: z27.number().optional(),
          /**
           * Optional. Specifies the task type for generating embeddings.
           * Supported task types:
           * - SEMANTIC_SIMILARITY: Optimized for text similarity.
           * - CLASSIFICATION: Optimized for text classification.
           * - CLUSTERING: Optimized for clustering texts based on similarity.
           * - RETRIEVAL_DOCUMENT: Optimized for document retrieval.
           * - RETRIEVAL_QUERY: Optimized for query-based retrieval.
           * - QUESTION_ANSWERING: Optimized for answering questions.
           * - FACT_VERIFICATION: Optimized for verifying factual information.
           * - CODE_RETRIEVAL_QUERY: Optimized for retrieving code blocks based on natural language queries.
           */
          taskType: z27.enum([
            "SEMANTIC_SIMILARITY",
            "CLASSIFICATION",
            "CLUSTERING",
            "RETRIEVAL_DOCUMENT",
            "RETRIEVAL_QUERY",
            "QUESTION_ANSWERING",
            "FACT_VERIFICATION",
            "CODE_RETRIEVAL_QUERY"
          ]).optional()
        })
      )
    );
    GoogleGenerativeAIEmbeddingModel = class {
      constructor(modelId, config2) {
        this.specificationVersion = "v3";
        this.maxEmbeddingsPerCall = 2048;
        this.supportsParallelCalls = true;
        this.modelId = modelId;
        this.config = config2;
      }
      get provider() {
        return this.config.provider;
      }
      async doEmbed({
        values,
        headers,
        abortSignal,
        providerOptions
      }) {
        const googleOptions = await parseProviderOptions({
          provider: "google",
          providerOptions,
          schema: googleGenerativeAIEmbeddingProviderOptions
        });
        if (values.length > this.maxEmbeddingsPerCall) {
          throw new TooManyEmbeddingValuesForCallError({
            provider: this.provider,
            modelId: this.modelId,
            maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
            values
          });
        }
        const mergedHeaders = combineHeaders(
          await resolve(this.config.headers),
          headers
        );
        if (values.length === 1) {
          const {
            responseHeaders: responseHeaders2,
            value: response2,
            rawValue: rawValue2
          } = await postJsonToApi({
            url: `${this.config.baseURL}/models/${this.modelId}:embedContent`,
            headers: mergedHeaders,
            body: {
              model: `models/${this.modelId}`,
              content: {
                parts: [{ text: values[0] }]
              },
              outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
              taskType: googleOptions == null ? void 0 : googleOptions.taskType
            },
            failedResponseHandler: googleFailedResponseHandler,
            successfulResponseHandler: createJsonResponseHandler(
              googleGenerativeAISingleEmbeddingResponseSchema
            ),
            abortSignal,
            fetch: this.config.fetch
          });
          return {
            warnings: [],
            embeddings: [response2.embedding.values],
            usage: void 0,
            response: { headers: responseHeaders2, body: rawValue2 }
          };
        }
        const {
          responseHeaders,
          value: response,
          rawValue
        } = await postJsonToApi({
          url: `${this.config.baseURL}/models/${this.modelId}:batchEmbedContents`,
          headers: mergedHeaders,
          body: {
            requests: values.map((value2) => ({
              model: `models/${this.modelId}`,
              content: { role: "user", parts: [{ text: value2 }] },
              outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
              taskType: googleOptions == null ? void 0 : googleOptions.taskType
            }))
          },
          failedResponseHandler: googleFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            googleGenerativeAITextEmbeddingResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          warnings: [],
          embeddings: response.embeddings.map((item) => item.values),
          usage: void 0,
          response: { headers: responseHeaders, body: rawValue }
        };
      }
    };
    googleGenerativeAITextEmbeddingResponseSchema = lazySchema(
      () => zodSchema(
        z36.object({
          embeddings: z36.array(z36.object({ values: z36.array(z36.number()) }))
        })
      )
    );
    googleGenerativeAISingleEmbeddingResponseSchema = lazySchema(
      () => zodSchema(
        z36.object({
          embedding: z36.object({ values: z36.array(z36.number()) })
        })
      )
    );
    googleGenerativeAIProviderOptions = lazySchema(
      () => zodSchema(
        z47.object({
          responseModalities: z47.array(z47.enum(["TEXT", "IMAGE"])).optional(),
          thinkingConfig: z47.object({
            thinkingBudget: z47.number().optional(),
            includeThoughts: z47.boolean().optional(),
            // https://ai.google.dev/gemini-api/docs/gemini-3?thinking=high#thinking_level
            thinkingLevel: z47.enum(["minimal", "low", "medium", "high"]).optional()
          }).optional(),
          /**
           * Optional.
           * The name of the cached content used as context to serve the prediction.
           * Format: cachedContents/{cachedContent}
           */
          cachedContent: z47.string().optional(),
          /**
           * Optional. Enable structured output. Default is true.
           *
           * This is useful when the JSON Schema contains elements that are
           * not supported by the OpenAPI schema version that
           * Google Generative AI uses. You can use this to disable
           * structured outputs if you need to.
           */
          structuredOutputs: z47.boolean().optional(),
          /**
           * Optional. A list of unique safety settings for blocking unsafe content.
           */
          safetySettings: z47.array(
            z47.object({
              category: z47.enum([
                "HARM_CATEGORY_UNSPECIFIED",
                "HARM_CATEGORY_HATE_SPEECH",
                "HARM_CATEGORY_DANGEROUS_CONTENT",
                "HARM_CATEGORY_HARASSMENT",
                "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                "HARM_CATEGORY_CIVIC_INTEGRITY"
              ]),
              threshold: z47.enum([
                "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
                "BLOCK_LOW_AND_ABOVE",
                "BLOCK_MEDIUM_AND_ABOVE",
                "BLOCK_ONLY_HIGH",
                "BLOCK_NONE",
                "OFF"
              ])
            })
          ).optional(),
          threshold: z47.enum([
            "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
            "BLOCK_LOW_AND_ABOVE",
            "BLOCK_MEDIUM_AND_ABOVE",
            "BLOCK_ONLY_HIGH",
            "BLOCK_NONE",
            "OFF"
          ]).optional(),
          /**
           * Optional. Enables timestamp understanding for audio-only files.
           *
           * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/audio-understanding
           */
          audioTimestamp: z47.boolean().optional(),
          /**
           * Optional. Defines labels used in billing reports. Available on Vertex AI only.
           *
           * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/add-labels-to-api-calls
           */
          labels: z47.record(z47.string(), z47.string()).optional(),
          /**
           * Optional. If specified, the media resolution specified will be used.
           *
           * https://ai.google.dev/api/generate-content#MediaResolution
           */
          mediaResolution: z47.enum([
            "MEDIA_RESOLUTION_UNSPECIFIED",
            "MEDIA_RESOLUTION_LOW",
            "MEDIA_RESOLUTION_MEDIUM",
            "MEDIA_RESOLUTION_HIGH"
          ]).optional(),
          /**
           * Optional. Configures the image generation aspect ratio for Gemini models.
           *
           * https://ai.google.dev/gemini-api/docs/image-generation#aspect_ratios
           */
          imageConfig: z47.object({
            aspectRatio: z47.enum([
              "1:1",
              "2:3",
              "3:2",
              "3:4",
              "4:3",
              "4:5",
              "5:4",
              "9:16",
              "16:9",
              "21:9"
            ]).optional(),
            imageSize: z47.enum(["1K", "2K", "4K"]).optional()
          }).optional(),
          /**
           * Optional. Configuration for grounding retrieval.
           * Used to provide location context for Google Maps and Google Search grounding.
           *
           * https://cloud.google.com/vertex-ai/generative-ai/docs/grounding/grounding-with-google-maps
           */
          retrievalConfig: z47.object({
            latLng: z47.object({
              latitude: z47.number(),
              longitude: z47.number()
            }).optional()
          }).optional()
        })
      )
    );
    GoogleGenerativeAILanguageModel = class {
      constructor(modelId, config2) {
        this.specificationVersion = "v3";
        var _a25;
        this.modelId = modelId;
        this.config = config2;
        this.generateId = (_a25 = config2.generateId) != null ? _a25 : generateId;
      }
      get provider() {
        return this.config.provider;
      }
      get supportedUrls() {
        var _a25, _b18, _c;
        return (_c = (_b18 = (_a25 = this.config).supportedUrls) == null ? void 0 : _b18.call(_a25)) != null ? _c : {};
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        stopSequences,
        responseFormat,
        seed,
        tools,
        toolChoice,
        providerOptions
      }) {
        var _a25;
        const warnings = [];
        const providerOptionsName = this.config.provider.includes("vertex") ? "vertex" : "google";
        let googleOptions = await parseProviderOptions({
          provider: providerOptionsName,
          providerOptions,
          schema: googleGenerativeAIProviderOptions
        });
        if (googleOptions == null && providerOptionsName !== "google") {
          googleOptions = await parseProviderOptions({
            provider: "google",
            providerOptions,
            schema: googleGenerativeAIProviderOptions
          });
        }
        if ((tools == null ? void 0 : tools.some(
          (tool2) => tool2.type === "provider" && tool2.id === "google.vertex_rag_store"
        )) && !this.config.provider.startsWith("google.vertex.")) {
          warnings.push({
            type: "other",
            message: `The 'vertex_rag_store' tool is only supported with the Google Vertex provider and might not be supported or could behave unexpectedly with the current Google provider (${this.config.provider}).`
          });
        }
        const isGemmaModel = this.modelId.toLowerCase().startsWith("gemma-");
        const { contents, systemInstruction } = convertToGoogleGenerativeAIMessages(
          prompt,
          { isGemmaModel, providerOptionsName }
        );
        const {
          tools: googleTools2,
          toolConfig: googleToolConfig,
          toolWarnings
        } = prepareTools2({
          tools,
          toolChoice,
          modelId: this.modelId
        });
        return {
          args: {
            generationConfig: {
              // standardized settings:
              maxOutputTokens,
              temperature,
              topK,
              topP,
              frequencyPenalty,
              presencePenalty,
              stopSequences,
              seed,
              // response format:
              responseMimeType: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? "application/json" : void 0,
              responseSchema: (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && // Google GenAI does not support all OpenAPI Schema features,
              // so this is needed as an escape hatch:
              // TODO convert into provider option
              ((_a25 = googleOptions == null ? void 0 : googleOptions.structuredOutputs) != null ? _a25 : true) ? convertJSONSchemaToOpenAPISchema(responseFormat.schema) : void 0,
              ...(googleOptions == null ? void 0 : googleOptions.audioTimestamp) && {
                audioTimestamp: googleOptions.audioTimestamp
              },
              // provider options:
              responseModalities: googleOptions == null ? void 0 : googleOptions.responseModalities,
              thinkingConfig: googleOptions == null ? void 0 : googleOptions.thinkingConfig,
              ...(googleOptions == null ? void 0 : googleOptions.mediaResolution) && {
                mediaResolution: googleOptions.mediaResolution
              },
              ...(googleOptions == null ? void 0 : googleOptions.imageConfig) && {
                imageConfig: googleOptions.imageConfig
              }
            },
            contents,
            systemInstruction: isGemmaModel ? void 0 : systemInstruction,
            safetySettings: googleOptions == null ? void 0 : googleOptions.safetySettings,
            tools: googleTools2,
            toolConfig: (googleOptions == null ? void 0 : googleOptions.retrievalConfig) ? {
              ...googleToolConfig,
              retrievalConfig: googleOptions.retrievalConfig
            } : googleToolConfig,
            cachedContent: googleOptions == null ? void 0 : googleOptions.cachedContent,
            labels: googleOptions == null ? void 0 : googleOptions.labels
          },
          warnings: [...warnings, ...toolWarnings],
          providerOptionsName
        };
      }
      async doGenerate(options) {
        var _a25, _b18, _c, _d, _e, _f, _g, _h, _i;
        const { args: args2, warnings, providerOptionsName } = await this.getArgs(options);
        const mergedHeaders = combineHeaders(
          await resolve(this.config.headers),
          options.headers
        );
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi({
          url: `${this.config.baseURL}/${getModelPath(
            this.modelId
          )}:generateContent`,
          headers: mergedHeaders,
          body: args2,
          failedResponseHandler: googleFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(responseSchema),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const candidate = response.candidates[0];
        const content = [];
        const parts = (_b18 = (_a25 = candidate.content) == null ? void 0 : _a25.parts) != null ? _b18 : [];
        const usageMetadata = response.usageMetadata;
        let lastCodeExecutionToolCallId;
        for (const part of parts) {
          if ("executableCode" in part && ((_c = part.executableCode) == null ? void 0 : _c.code)) {
            const toolCallId = this.config.generateId();
            lastCodeExecutionToolCallId = toolCallId;
            content.push({
              type: "tool-call",
              toolCallId,
              toolName: "code_execution",
              input: JSON.stringify(part.executableCode),
              providerExecuted: true
            });
          } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
            content.push({
              type: "tool-result",
              // Assumes a result directly follows its corresponding call part.
              toolCallId: lastCodeExecutionToolCallId,
              toolName: "code_execution",
              result: {
                outcome: part.codeExecutionResult.outcome,
                output: part.codeExecutionResult.output
              }
            });
            lastCodeExecutionToolCallId = void 0;
          } else if ("text" in part && part.text != null && part.text.length > 0) {
            content.push({
              type: part.thought === true ? "reasoning" : "text",
              text: part.text,
              providerMetadata: part.thoughtSignature ? {
                [providerOptionsName]: {
                  thoughtSignature: part.thoughtSignature
                }
              } : void 0
            });
          } else if ("functionCall" in part) {
            content.push({
              type: "tool-call",
              toolCallId: this.config.generateId(),
              toolName: part.functionCall.name,
              input: JSON.stringify(part.functionCall.args),
              providerMetadata: part.thoughtSignature ? {
                [providerOptionsName]: {
                  thoughtSignature: part.thoughtSignature
                }
              } : void 0
            });
          } else if ("inlineData" in part) {
            content.push({
              type: "file",
              data: part.inlineData.data,
              mediaType: part.inlineData.mimeType,
              providerMetadata: part.thoughtSignature ? {
                [providerOptionsName]: {
                  thoughtSignature: part.thoughtSignature
                }
              } : void 0
            });
          }
        }
        const sources = (_d = extractSources({
          groundingMetadata: candidate.groundingMetadata,
          generateId: this.config.generateId
        })) != null ? _d : [];
        for (const source of sources) {
          content.push(source);
        }
        return {
          content,
          finishReason: {
            unified: mapGoogleGenerativeAIFinishReason({
              finishReason: candidate.finishReason,
              // Only count client-executed tool calls for finish reason determination.
              hasToolCalls: content.some(
                (part) => part.type === "tool-call" && !part.providerExecuted
              )
            }),
            raw: (_e = candidate.finishReason) != null ? _e : void 0
          },
          usage: convertGoogleGenerativeAIUsage(usageMetadata),
          warnings,
          providerMetadata: {
            [providerOptionsName]: {
              promptFeedback: (_f = response.promptFeedback) != null ? _f : null,
              groundingMetadata: (_g = candidate.groundingMetadata) != null ? _g : null,
              urlContextMetadata: (_h = candidate.urlContextMetadata) != null ? _h : null,
              safetyRatings: (_i = candidate.safetyRatings) != null ? _i : null,
              usageMetadata: usageMetadata != null ? usageMetadata : null
            }
          },
          request: { body: args2 },
          response: {
            // TODO timestamp, model id, id
            headers: responseHeaders,
            body: rawResponse
          }
        };
      }
      async doStream(options) {
        const { args: args2, warnings, providerOptionsName } = await this.getArgs(options);
        const headers = combineHeaders(
          await resolve(this.config.headers),
          options.headers
        );
        const { responseHeaders, value: response } = await postJsonToApi({
          url: `${this.config.baseURL}/${getModelPath(
            this.modelId
          )}:streamGenerateContent?alt=sse`,
          headers,
          body: args2,
          failedResponseHandler: googleFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler(chunkSchema),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        let finishReason = {
          unified: "other",
          raw: void 0
        };
        let usage = void 0;
        let providerMetadata = void 0;
        const generateId3 = this.config.generateId;
        let hasToolCalls = false;
        let currentTextBlockId = null;
        let currentReasoningBlockId = null;
        let blockCounter = 0;
        const emittedSourceUrls = /* @__PURE__ */ new Set();
        let lastCodeExecutionToolCallId;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                var _a25, _b18, _c, _d, _e, _f, _g;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value2 = chunk.value;
                const usageMetadata = value2.usageMetadata;
                if (usageMetadata != null) {
                  usage = usageMetadata;
                }
                const candidate = (_a25 = value2.candidates) == null ? void 0 : _a25[0];
                if (candidate == null) {
                  return;
                }
                const content = candidate.content;
                const sources = extractSources({
                  groundingMetadata: candidate.groundingMetadata,
                  generateId: generateId3
                });
                if (sources != null) {
                  for (const source of sources) {
                    if (source.sourceType === "url" && !emittedSourceUrls.has(source.url)) {
                      emittedSourceUrls.add(source.url);
                      controller.enqueue(source);
                    }
                  }
                }
                if (content != null) {
                  const parts = (_b18 = content.parts) != null ? _b18 : [];
                  for (const part of parts) {
                    if ("executableCode" in part && ((_c = part.executableCode) == null ? void 0 : _c.code)) {
                      const toolCallId = generateId3();
                      lastCodeExecutionToolCallId = toolCallId;
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId,
                        toolName: "code_execution",
                        input: JSON.stringify(part.executableCode),
                        providerExecuted: true
                      });
                    } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
                      const toolCallId = lastCodeExecutionToolCallId;
                      if (toolCallId) {
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId,
                          toolName: "code_execution",
                          result: {
                            outcome: part.codeExecutionResult.outcome,
                            output: part.codeExecutionResult.output
                          }
                        });
                        lastCodeExecutionToolCallId = void 0;
                      }
                    } else if ("text" in part && part.text != null && part.text.length > 0) {
                      if (part.thought === true) {
                        if (currentTextBlockId !== null) {
                          controller.enqueue({
                            type: "text-end",
                            id: currentTextBlockId
                          });
                          currentTextBlockId = null;
                        }
                        if (currentReasoningBlockId === null) {
                          currentReasoningBlockId = String(blockCounter++);
                          controller.enqueue({
                            type: "reasoning-start",
                            id: currentReasoningBlockId,
                            providerMetadata: part.thoughtSignature ? {
                              [providerOptionsName]: {
                                thoughtSignature: part.thoughtSignature
                              }
                            } : void 0
                          });
                        }
                        controller.enqueue({
                          type: "reasoning-delta",
                          id: currentReasoningBlockId,
                          delta: part.text,
                          providerMetadata: part.thoughtSignature ? {
                            [providerOptionsName]: {
                              thoughtSignature: part.thoughtSignature
                            }
                          } : void 0
                        });
                      } else {
                        if (currentReasoningBlockId !== null) {
                          controller.enqueue({
                            type: "reasoning-end",
                            id: currentReasoningBlockId
                          });
                          currentReasoningBlockId = null;
                        }
                        if (currentTextBlockId === null) {
                          currentTextBlockId = String(blockCounter++);
                          controller.enqueue({
                            type: "text-start",
                            id: currentTextBlockId,
                            providerMetadata: part.thoughtSignature ? {
                              [providerOptionsName]: {
                                thoughtSignature: part.thoughtSignature
                              }
                            } : void 0
                          });
                        }
                        controller.enqueue({
                          type: "text-delta",
                          id: currentTextBlockId,
                          delta: part.text,
                          providerMetadata: part.thoughtSignature ? {
                            [providerOptionsName]: {
                              thoughtSignature: part.thoughtSignature
                            }
                          } : void 0
                        });
                      }
                    } else if ("inlineData" in part) {
                      controller.enqueue({
                        type: "file",
                        mediaType: part.inlineData.mimeType,
                        data: part.inlineData.data
                      });
                    }
                  }
                  const toolCallDeltas = getToolCallsFromParts({
                    parts: content.parts,
                    generateId: generateId3,
                    providerOptionsName
                  });
                  if (toolCallDeltas != null) {
                    for (const toolCall of toolCallDeltas) {
                      controller.enqueue({
                        type: "tool-input-start",
                        id: toolCall.toolCallId,
                        toolName: toolCall.toolName,
                        providerMetadata: toolCall.providerMetadata
                      });
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: toolCall.toolCallId,
                        delta: toolCall.args,
                        providerMetadata: toolCall.providerMetadata
                      });
                      controller.enqueue({
                        type: "tool-input-end",
                        id: toolCall.toolCallId,
                        providerMetadata: toolCall.providerMetadata
                      });
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: toolCall.toolCallId,
                        toolName: toolCall.toolName,
                        input: toolCall.args,
                        providerMetadata: toolCall.providerMetadata
                      });
                      hasToolCalls = true;
                    }
                  }
                }
                if (candidate.finishReason != null) {
                  finishReason = {
                    unified: mapGoogleGenerativeAIFinishReason({
                      finishReason: candidate.finishReason,
                      hasToolCalls
                    }),
                    raw: candidate.finishReason
                  };
                  providerMetadata = {
                    [providerOptionsName]: {
                      promptFeedback: (_d = value2.promptFeedback) != null ? _d : null,
                      groundingMetadata: (_e = candidate.groundingMetadata) != null ? _e : null,
                      urlContextMetadata: (_f = candidate.urlContextMetadata) != null ? _f : null,
                      safetyRatings: (_g = candidate.safetyRatings) != null ? _g : null
                    }
                  };
                  if (usageMetadata != null) {
                    providerMetadata[providerOptionsName].usageMetadata = usageMetadata;
                  }
                }
              },
              flush(controller) {
                if (currentTextBlockId !== null) {
                  controller.enqueue({
                    type: "text-end",
                    id: currentTextBlockId
                  });
                }
                if (currentReasoningBlockId !== null) {
                  controller.enqueue({
                    type: "reasoning-end",
                    id: currentReasoningBlockId
                  });
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage: convertGoogleGenerativeAIUsage(usage),
                  providerMetadata
                });
              }
            })
          ),
          response: { headers: responseHeaders },
          request: { body: args2 }
        };
      }
    };
    getGroundingMetadataSchema = () => z56.object({
      webSearchQueries: z56.array(z56.string()).nullish(),
      retrievalQueries: z56.array(z56.string()).nullish(),
      searchEntryPoint: z56.object({ renderedContent: z56.string() }).nullish(),
      groundingChunks: z56.array(
        z56.object({
          web: z56.object({ uri: z56.string(), title: z56.string().nullish() }).nullish(),
          retrievedContext: z56.object({
            uri: z56.string().nullish(),
            title: z56.string().nullish(),
            text: z56.string().nullish(),
            fileSearchStore: z56.string().nullish()
          }).nullish(),
          maps: z56.object({
            uri: z56.string().nullish(),
            title: z56.string().nullish(),
            text: z56.string().nullish(),
            placeId: z56.string().nullish()
          }).nullish()
        })
      ).nullish(),
      groundingSupports: z56.array(
        z56.object({
          segment: z56.object({
            startIndex: z56.number().nullish(),
            endIndex: z56.number().nullish(),
            text: z56.string().nullish()
          }).nullish(),
          segment_text: z56.string().nullish(),
          groundingChunkIndices: z56.array(z56.number()).nullish(),
          supportChunkIndices: z56.array(z56.number()).nullish(),
          confidenceScores: z56.array(z56.number()).nullish(),
          confidenceScore: z56.array(z56.number()).nullish()
        })
      ).nullish(),
      retrievalMetadata: z56.union([
        z56.object({
          webDynamicRetrievalScore: z56.number()
        }),
        z56.object({})
      ]).nullish()
    });
    getContentSchema = () => z56.object({
      parts: z56.array(
        z56.union([
          // note: order matters since text can be fully empty
          z56.object({
            functionCall: z56.object({
              name: z56.string(),
              args: z56.unknown()
            }),
            thoughtSignature: z56.string().nullish()
          }),
          z56.object({
            inlineData: z56.object({
              mimeType: z56.string(),
              data: z56.string()
            }),
            thoughtSignature: z56.string().nullish()
          }),
          z56.object({
            executableCode: z56.object({
              language: z56.string(),
              code: z56.string()
            }).nullish(),
            codeExecutionResult: z56.object({
              outcome: z56.string(),
              output: z56.string()
            }).nullish(),
            text: z56.string().nullish(),
            thought: z56.boolean().nullish(),
            thoughtSignature: z56.string().nullish()
          })
        ])
      ).nullish()
    });
    getSafetyRatingSchema = () => z56.object({
      category: z56.string().nullish(),
      probability: z56.string().nullish(),
      probabilityScore: z56.number().nullish(),
      severity: z56.string().nullish(),
      severityScore: z56.number().nullish(),
      blocked: z56.boolean().nullish()
    });
    usageSchema = z56.object({
      cachedContentTokenCount: z56.number().nullish(),
      thoughtsTokenCount: z56.number().nullish(),
      promptTokenCount: z56.number().nullish(),
      candidatesTokenCount: z56.number().nullish(),
      totalTokenCount: z56.number().nullish(),
      // https://cloud.google.com/vertex-ai/generative-ai/docs/reference/rest/v1/GenerateContentResponse#TrafficType
      trafficType: z56.string().nullish()
    });
    getUrlContextMetadataSchema = () => z56.object({
      urlMetadata: z56.array(
        z56.object({
          retrievedUrl: z56.string(),
          urlRetrievalStatus: z56.string()
        })
      )
    });
    responseSchema = lazySchema(
      () => zodSchema(
        z56.object({
          candidates: z56.array(
            z56.object({
              content: getContentSchema().nullish().or(z56.object({}).strict()),
              finishReason: z56.string().nullish(),
              safetyRatings: z56.array(getSafetyRatingSchema()).nullish(),
              groundingMetadata: getGroundingMetadataSchema().nullish(),
              urlContextMetadata: getUrlContextMetadataSchema().nullish()
            })
          ),
          usageMetadata: usageSchema.nullish(),
          promptFeedback: z56.object({
            blockReason: z56.string().nullish(),
            safetyRatings: z56.array(getSafetyRatingSchema()).nullish()
          }).nullish()
        })
      )
    );
    chunkSchema = lazySchema(
      () => zodSchema(
        z56.object({
          candidates: z56.array(
            z56.object({
              content: getContentSchema().nullish(),
              finishReason: z56.string().nullish(),
              safetyRatings: z56.array(getSafetyRatingSchema()).nullish(),
              groundingMetadata: getGroundingMetadataSchema().nullish(),
              urlContextMetadata: getUrlContextMetadataSchema().nullish()
            })
          ).nullish(),
          usageMetadata: usageSchema.nullish(),
          promptFeedback: z56.object({
            blockReason: z56.string().nullish(),
            safetyRatings: z56.array(getSafetyRatingSchema()).nullish()
          }).nullish()
        })
      )
    );
    codeExecution = createProviderToolFactoryWithOutputSchema({
      id: "google.code_execution",
      inputSchema: z66.object({
        language: z66.string().describe("The programming language of the code."),
        code: z66.string().describe("The code to be executed.")
      }),
      outputSchema: z66.object({
        outcome: z66.string().describe('The outcome of the execution (e.g., "OUTCOME_OK").'),
        output: z66.string().describe("The output from the code execution.")
      })
    });
    enterpriseWebSearch = createProviderToolFactory({
      id: "google.enterprise_web_search",
      inputSchema: lazySchema(() => zodSchema(z76.object({})))
    });
    fileSearchArgsBaseSchema = z86.object({
      /** The names of the file_search_stores to retrieve from.
       *  Example: `fileSearchStores/my-file-search-store-123`
       */
      fileSearchStoreNames: z86.array(z86.string()).describe(
        "The names of the file_search_stores to retrieve from. Example: `fileSearchStores/my-file-search-store-123`"
      ),
      /** The number of file search retrieval chunks to retrieve. */
      topK: z86.number().int().positive().describe("The number of file search retrieval chunks to retrieve.").optional(),
      /** Metadata filter to apply to the file search retrieval documents.
       *  See https://google.aip.dev/160 for the syntax of the filter expression.
       */
      metadataFilter: z86.string().describe(
        "Metadata filter to apply to the file search retrieval documents. See https://google.aip.dev/160 for the syntax of the filter expression."
      ).optional()
    }).passthrough();
    fileSearchArgsSchema2 = lazySchema(
      () => zodSchema(fileSearchArgsBaseSchema)
    );
    fileSearch2 = createProviderToolFactory({
      id: "google.file_search",
      inputSchema: fileSearchArgsSchema2
    });
    googleMaps = createProviderToolFactory({
      id: "google.google_maps",
      inputSchema: lazySchema(() => zodSchema(z95.object({})))
    });
    googleSearch = createProviderToolFactory({
      id: "google.google_search",
      inputSchema: lazySchema(
        () => zodSchema(
          z105.object({
            mode: z105.enum(["MODE_DYNAMIC", "MODE_UNSPECIFIED"]).default("MODE_UNSPECIFIED"),
            dynamicThreshold: z105.number().default(1)
          })
        )
      )
    });
    urlContext = createProviderToolFactory({
      id: "google.url_context",
      inputSchema: lazySchema(() => zodSchema(z114.object({})))
    });
    vertexRagStore = createProviderToolFactory({
      id: "google.vertex_rag_store",
      inputSchema: z124.object({
        ragCorpus: z124.string(),
        topK: z124.number().optional()
      })
    });
    googleTools = {
      /**
       * Creates a Google search tool that gives Google direct access to real-time web content.
       * Must have name "google_search".
       */
      googleSearch,
      /**
       * Creates an Enterprise Web Search tool for grounding responses using a compliance-focused web index.
       * Designed for highly-regulated industries (finance, healthcare, public sector).
       * Does not log customer data and supports VPC service controls.
       * Must have name "enterprise_web_search".
       *
       * @note Only available on Vertex AI. Requires Gemini 2.0 or newer.
       *
       * @see https://cloud.google.com/vertex-ai/generative-ai/docs/grounding/web-grounding-enterprise
       */
      enterpriseWebSearch,
      /**
       * Creates a Google Maps grounding tool that gives the model access to Google Maps data.
       * Must have name "google_maps".
       *
       * @see https://ai.google.dev/gemini-api/docs/maps-grounding
       * @see https://cloud.google.com/vertex-ai/generative-ai/docs/grounding/grounding-with-google-maps
       */
      googleMaps,
      /**
       * Creates a URL context tool that gives Google direct access to real-time web content.
       * Must have name "url_context".
       */
      urlContext,
      /**
       * Enables Retrieval Augmented Generation (RAG) via the Gemini File Search tool.
       * Must have name "file_search".
       *
       * @param fileSearchStoreNames - Fully-qualified File Search store resource names.
       * @param metadataFilter - Optional filter expression to restrict the files that can be retrieved.
       * @param topK - Optional result limit for the number of chunks returned from File Search.
       *
       * @see https://ai.google.dev/gemini-api/docs/file-search
       */
      fileSearch: fileSearch2,
      /**
       * A tool that enables the model to generate and run Python code.
       * Must have name "code_execution".
       *
       * @note Ensure the selected model supports Code Execution.
       * Multi-tool usage with the code execution tool is typically compatible with Gemini >=2 models.
       *
       * @see https://ai.google.dev/gemini-api/docs/code-execution (Google AI)
       * @see https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/code-execution-api (Vertex AI)
       */
      codeExecution,
      /**
       * Creates a Vertex RAG Store tool that enables the model to perform RAG searches against a Vertex RAG Store.
       * Must have name "vertex_rag_store".
       */
      vertexRagStore
    };
    GoogleGenerativeAIImageModel = class {
      constructor(modelId, settings, config2) {
        this.modelId = modelId;
        this.settings = settings;
        this.config = config2;
        this.specificationVersion = "v3";
      }
      get maxImagesPerCall() {
        var _a25;
        return (_a25 = this.settings.maxImagesPerCall) != null ? _a25 : 4;
      }
      get provider() {
        return this.config.provider;
      }
      async doGenerate(options) {
        var _a25, _b18, _c;
        const {
          prompt,
          n = 1,
          size,
          aspectRatio = "1:1",
          seed,
          providerOptions,
          headers,
          abortSignal,
          files,
          mask
        } = options;
        const warnings = [];
        if (files != null && files.length > 0) {
          throw new Error(
            "Google Generative AI does not support image editing. Use Google Vertex AI (@ai-sdk/google-vertex) for image editing capabilities."
          );
        }
        if (mask != null) {
          throw new Error(
            "Google Generative AI does not support image editing with masks. Use Google Vertex AI (@ai-sdk/google-vertex) for image editing capabilities."
          );
        }
        if (size != null) {
          warnings.push({
            type: "unsupported",
            feature: "size",
            details: "This model does not support the `size` option. Use `aspectRatio` instead."
          });
        }
        if (seed != null) {
          warnings.push({
            type: "unsupported",
            feature: "seed",
            details: "This model does not support the `seed` option through this provider."
          });
        }
        const googleOptions = await parseProviderOptions({
          provider: "google",
          providerOptions,
          schema: googleImageProviderOptionsSchema
        });
        const currentDate = (_c = (_b18 = (_a25 = this.config._internal) == null ? void 0 : _a25.currentDate) == null ? void 0 : _b18.call(_a25)) != null ? _c : /* @__PURE__ */ new Date();
        const parameters = {
          sampleCount: n
        };
        if (aspectRatio != null) {
          parameters.aspectRatio = aspectRatio;
        }
        if (googleOptions) {
          Object.assign(parameters, googleOptions);
        }
        const body = {
          instances: [{ prompt }],
          parameters
        };
        const { responseHeaders, value: response } = await postJsonToApi({
          url: `${this.config.baseURL}/models/${this.modelId}:predict`,
          headers: combineHeaders(await resolve(this.config.headers), headers),
          body,
          failedResponseHandler: googleFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            googleImageResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          images: response.predictions.map(
            (p) => p.bytesBase64Encoded
          ),
          warnings: warnings != null ? warnings : [],
          providerMetadata: {
            google: {
              images: response.predictions.map((prediction) => ({
                // Add any prediction-specific metadata here
              }))
            }
          },
          response: {
            timestamp: currentDate,
            modelId: this.modelId,
            headers: responseHeaders
          }
        };
      }
    };
    googleImageResponseSchema = lazySchema(
      () => zodSchema(
        z134.object({
          predictions: z134.array(z134.object({ bytesBase64Encoded: z134.string() })).default([])
        })
      )
    );
    googleImageProviderOptionsSchema = lazySchema(
      () => zodSchema(
        z134.object({
          personGeneration: z134.enum(["dont_allow", "allow_adult", "allow_all"]).nullish(),
          aspectRatio: z134.enum(["1:1", "3:4", "4:3", "9:16", "16:9"]).nullish()
        })
      )
    );
    GoogleGenerativeAIVideoModel = class {
      constructor(modelId, config2) {
        this.modelId = modelId;
        this.config = config2;
        this.specificationVersion = "v3";
      }
      get provider() {
        return this.config.provider;
      }
      get maxVideosPerCall() {
        return 4;
      }
      async doGenerate(options) {
        var _a25, _b18, _c, _d, _e, _f, _g, _h;
        const currentDate = (_c = (_b18 = (_a25 = this.config._internal) == null ? void 0 : _a25.currentDate) == null ? void 0 : _b18.call(_a25)) != null ? _c : /* @__PURE__ */ new Date();
        const warnings = [];
        const googleOptions = await parseProviderOptions({
          provider: "google",
          providerOptions: options.providerOptions,
          schema: googleVideoProviderOptionsSchema
        });
        const instances = [{}];
        const instance = instances[0];
        if (options.prompt != null) {
          instance.prompt = options.prompt;
        }
        if (options.image != null) {
          if (options.image.type === "url") {
            warnings.push({
              type: "unsupported",
              feature: "URL-based image input",
              details: "Google Generative AI video models require base64-encoded images. URL will be ignored."
            });
          } else {
            const base64Data = typeof options.image.data === "string" ? options.image.data : convertUint8ArrayToBase64(options.image.data);
            instance.image = {
              inlineData: {
                mimeType: options.image.mediaType || "image/png",
                data: base64Data
              }
            };
          }
        }
        if ((googleOptions == null ? void 0 : googleOptions.referenceImages) != null) {
          instance.referenceImages = googleOptions.referenceImages.map((refImg) => {
            if (refImg.bytesBase64Encoded) {
              return {
                inlineData: {
                  mimeType: "image/png",
                  data: refImg.bytesBase64Encoded
                }
              };
            } else if (refImg.gcsUri) {
              return {
                gcsUri: refImg.gcsUri
              };
            }
            return refImg;
          });
        }
        const parameters = {
          sampleCount: options.n
        };
        if (options.aspectRatio) {
          parameters.aspectRatio = options.aspectRatio;
        }
        if (options.resolution) {
          const resolutionMap = {
            "1280x720": "720p",
            "1920x1080": "1080p",
            "3840x2160": "4k"
          };
          parameters.resolution = resolutionMap[options.resolution] || options.resolution;
        }
        if (options.duration) {
          parameters.durationSeconds = options.duration;
        }
        if (options.seed) {
          parameters.seed = options.seed;
        }
        if (googleOptions != null) {
          const opts = googleOptions;
          if (opts.personGeneration !== void 0 && opts.personGeneration !== null) {
            parameters.personGeneration = opts.personGeneration;
          }
          if (opts.negativePrompt !== void 0 && opts.negativePrompt !== null) {
            parameters.negativePrompt = opts.negativePrompt;
          }
          for (const [key, value2] of Object.entries(opts)) {
            if (![
              "pollIntervalMs",
              "pollTimeoutMs",
              "personGeneration",
              "negativePrompt",
              "referenceImages"
            ].includes(key)) {
              parameters[key] = value2;
            }
          }
        }
        const { value: operation } = await postJsonToApi({
          url: `${this.config.baseURL}/models/${this.modelId}:predictLongRunning`,
          headers: combineHeaders(
            await resolve(this.config.headers),
            options.headers
          ),
          body: {
            instances,
            parameters
          },
          successfulResponseHandler: createJsonResponseHandler(
            googleOperationSchema
          ),
          failedResponseHandler: googleFailedResponseHandler,
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const operationName = operation.name;
        if (!operationName) {
          throw new AISDKError({
            name: "GOOGLE_VIDEO_GENERATION_ERROR",
            message: "No operation name returned from API"
          });
        }
        const pollIntervalMs = (_d = googleOptions == null ? void 0 : googleOptions.pollIntervalMs) != null ? _d : 1e4;
        const pollTimeoutMs = (_e = googleOptions == null ? void 0 : googleOptions.pollTimeoutMs) != null ? _e : 6e5;
        const startTime = Date.now();
        let finalOperation = operation;
        let responseHeaders;
        while (!finalOperation.done) {
          if (Date.now() - startTime > pollTimeoutMs) {
            throw new AISDKError({
              name: "GOOGLE_VIDEO_GENERATION_TIMEOUT",
              message: `Video generation timed out after ${pollTimeoutMs}ms`
            });
          }
          await delay(pollIntervalMs);
          if ((_f = options.abortSignal) == null ? void 0 : _f.aborted) {
            throw new AISDKError({
              name: "GOOGLE_VIDEO_GENERATION_ABORTED",
              message: "Video generation request was aborted"
            });
          }
          const { value: statusOperation, responseHeaders: pollHeaders } = await getFromApi({
            url: `${this.config.baseURL}/${operationName}`,
            headers: combineHeaders(
              await resolve(this.config.headers),
              options.headers
            ),
            successfulResponseHandler: createJsonResponseHandler(
              googleOperationSchema
            ),
            failedResponseHandler: googleFailedResponseHandler,
            abortSignal: options.abortSignal,
            fetch: this.config.fetch
          });
          finalOperation = statusOperation;
          responseHeaders = pollHeaders;
        }
        if (finalOperation.error) {
          throw new AISDKError({
            name: "GOOGLE_VIDEO_GENERATION_FAILED",
            message: `Video generation failed: ${finalOperation.error.message}`
          });
        }
        const response = finalOperation.response;
        if (!((_g = response == null ? void 0 : response.generateVideoResponse) == null ? void 0 : _g.generatedSamples) || response.generateVideoResponse.generatedSamples.length === 0) {
          throw new AISDKError({
            name: "GOOGLE_VIDEO_GENERATION_ERROR",
            message: `No videos in response. Response: ${JSON.stringify(finalOperation)}`
          });
        }
        const videos = [];
        const videoMetadata = [];
        const resolvedHeaders = await resolve(this.config.headers);
        const apiKey = resolvedHeaders == null ? void 0 : resolvedHeaders["x-goog-api-key"];
        for (const generatedSample of response.generateVideoResponse.generatedSamples) {
          if ((_h = generatedSample.video) == null ? void 0 : _h.uri) {
            const urlWithAuth = apiKey ? `${generatedSample.video.uri}${generatedSample.video.uri.includes("?") ? "&" : "?"}key=${apiKey}` : generatedSample.video.uri;
            videos.push({
              type: "url",
              url: urlWithAuth,
              mediaType: "video/mp4"
            });
            videoMetadata.push({
              uri: generatedSample.video.uri
            });
          }
        }
        if (videos.length === 0) {
          throw new AISDKError({
            name: "GOOGLE_VIDEO_GENERATION_ERROR",
            message: "No valid videos in response"
          });
        }
        return {
          videos,
          warnings,
          response: {
            timestamp: currentDate,
            modelId: this.modelId,
            headers: responseHeaders
          },
          providerMetadata: {
            google: {
              videos: videoMetadata
            }
          }
        };
      }
    };
    googleOperationSchema = z144.object({
      name: z144.string().nullish(),
      done: z144.boolean().nullish(),
      error: z144.object({
        code: z144.number().nullish(),
        message: z144.string(),
        status: z144.string().nullish()
      }).nullish(),
      response: z144.object({
        generateVideoResponse: z144.object({
          generatedSamples: z144.array(
            z144.object({
              video: z144.object({
                uri: z144.string().nullish()
              }).nullish()
            })
          ).nullish()
        }).nullish()
      }).nullish()
    });
    googleVideoProviderOptionsSchema = lazySchema(
      () => zodSchema(
        z144.object({
          pollIntervalMs: z144.number().positive().nullish(),
          pollTimeoutMs: z144.number().positive().nullish(),
          personGeneration: z144.enum(["dont_allow", "allow_adult", "allow_all"]).nullish(),
          negativePrompt: z144.string().nullish(),
          referenceImages: z144.array(
            z144.object({
              bytesBase64Encoded: z144.string().nullish(),
              gcsUri: z144.string().nullish()
            })
          ).nullish()
        }).passthrough()
      )
    );
    google = createGoogleGenerativeAI();
  }
});

// node_modules/@ai-sdk/openai-compatible/dist/index.mjs
var dist_exports6 = {};
__export(dist_exports6, {
  OpenAICompatibleChatLanguageModel: () => OpenAICompatibleChatLanguageModel,
  OpenAICompatibleCompletionLanguageModel: () => OpenAICompatibleCompletionLanguageModel,
  OpenAICompatibleEmbeddingModel: () => OpenAICompatibleEmbeddingModel,
  OpenAICompatibleImageModel: () => OpenAICompatibleImageModel,
  VERSION: () => VERSION8,
  createOpenAICompatible: () => createOpenAICompatible
});
import { z as z37 } from "zod/v4";
import { z as z28 } from "zod/v4";
import { z as z29 } from "zod/v4";
import { z as z57 } from "zod/v4";
import { z as z48 } from "zod/v4";
import { z as z77 } from "zod/v4";
import { z as z67 } from "zod/v4";
import { z as z87 } from "zod/v4";
function convertOpenAICompatibleChatUsage(usage) {
  var _a25, _b18, _c, _d, _e, _f;
  if (usage == null) {
    return {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
  }
  const promptTokens = (_a25 = usage.prompt_tokens) != null ? _a25 : 0;
  const completionTokens = (_b18 = usage.completion_tokens) != null ? _b18 : 0;
  const cacheReadTokens = (_d = (_c = usage.prompt_tokens_details) == null ? void 0 : _c.cached_tokens) != null ? _d : 0;
  const reasoningTokens = (_f = (_e = usage.completion_tokens_details) == null ? void 0 : _e.reasoning_tokens) != null ? _f : 0;
  return {
    inputTokens: {
      total: promptTokens,
      noCache: promptTokens - cacheReadTokens,
      cacheRead: cacheReadTokens,
      cacheWrite: void 0
    },
    outputTokens: {
      total: completionTokens,
      text: completionTokens - reasoningTokens,
      reasoning: reasoningTokens
    },
    raw: usage
  };
}
function getOpenAIMetadata(message) {
  var _a25, _b18;
  return (_b18 = (_a25 = message == null ? void 0 : message.providerOptions) == null ? void 0 : _a25.openaiCompatible) != null ? _b18 : {};
}
function getAudioFormat(mediaType) {
  switch (mediaType) {
    case "audio/wav":
      return "wav";
    case "audio/mp3":
    case "audio/mpeg":
      return "mp3";
    default:
      return null;
  }
}
function convertToOpenAICompatibleChatMessages(prompt) {
  var _a25, _b18, _c;
  const messages = [];
  for (const { role, content, ...message } of prompt) {
    const metadata = getOpenAIMetadata({ ...message });
    switch (role) {
      case "system": {
        messages.push({ role: "system", content, ...metadata });
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({
            role: "user",
            content: content[0].text,
            ...getOpenAIMetadata(content[0])
          });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part) => {
            var _a26;
            const partMetadata = getOpenAIMetadata(part);
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text, ...partMetadata };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                    },
                    ...partMetadata
                  };
                }
                if (part.mediaType.startsWith("audio/")) {
                  if (part.data instanceof URL) {
                    throw new UnsupportedFunctionalityError({
                      functionality: "audio file parts with URLs"
                    });
                  }
                  const format = getAudioFormat(part.mediaType);
                  if (format === null) {
                    throw new UnsupportedFunctionalityError({
                      functionality: `audio media type ${part.mediaType}`
                    });
                  }
                  return {
                    type: "input_audio",
                    input_audio: {
                      data: convertToBase64(part.data),
                      format
                    },
                    ...partMetadata
                  };
                }
                if (part.mediaType === "application/pdf") {
                  if (part.data instanceof URL) {
                    throw new UnsupportedFunctionalityError({
                      functionality: "PDF file parts with URLs"
                    });
                  }
                  return {
                    type: "file",
                    file: {
                      filename: (_a26 = part.filename) != null ? _a26 : "document.pdf",
                      file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                    },
                    ...partMetadata
                  };
                }
                if (part.mediaType.startsWith("text/")) {
                  const textContent = part.data instanceof URL ? part.data.toString() : typeof part.data === "string" ? part.data : new TextDecoder().decode(part.data);
                  return {
                    type: "text",
                    text: textContent,
                    ...partMetadata
                  };
                }
                throw new UnsupportedFunctionalityError({
                  functionality: `file part media type ${part.mediaType}`
                });
              }
            }
          }),
          ...metadata
        });
        break;
      }
      case "assistant": {
        let text2 = "";
        let reasoning = "";
        const toolCalls = [];
        for (const part of content) {
          const partMetadata = getOpenAIMetadata(part);
          switch (part.type) {
            case "text": {
              text2 += part.text;
              break;
            }
            case "reasoning": {
              reasoning += part.text;
              break;
            }
            case "tool-call": {
              const thoughtSignature = (_b18 = (_a25 = part.providerOptions) == null ? void 0 : _a25.google) == null ? void 0 : _b18.thoughtSignature;
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                },
                ...partMetadata,
                // Include extra_content for Google Gemini thought signatures
                ...thoughtSignature ? {
                  extra_content: {
                    google: {
                      thought_signature: String(thoughtSignature)
                    }
                  }
                } : {}
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text2,
          ...reasoning.length > 0 ? { reasoning_content: reasoning } : {},
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
          ...metadata
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          if (toolResponse.type === "tool-approval-response") {
            continue;
          }
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "execution-denied":
              contentValue = (_c = output.reason) != null ? _c : "Tool execution denied.";
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          const toolResponseMetadata = getOpenAIMetadata(toolResponse);
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue,
            ...toolResponseMetadata
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return messages;
}
function getResponseMetadata3({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapOpenAICompatibleFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "other";
  }
}
function prepareTools3({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const openaiCompatTools = [];
  for (const tool2 of tools) {
    if (tool2.type === "provider") {
      toolWarnings.push({
        type: "unsupported",
        feature: `provider-defined tool ${tool2.id}`
      });
    } else {
      openaiCompatTools.push({
        type: "function",
        function: {
          name: tool2.name,
          description: tool2.description,
          parameters: tool2.inputSchema,
          ...tool2.strict != null ? { strict: tool2.strict } : {}
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: openaiCompatTools, toolChoice: void 0, toolWarnings };
  }
  const type2 = toolChoice.type;
  switch (type2) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiCompatTools, toolChoice: type2, toolWarnings };
    case "tool":
      return {
        tools: openaiCompatTools,
        toolChoice: {
          type: "function",
          function: { name: toolChoice.toolName }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type2;
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function convertOpenAICompatibleCompletionUsage(usage) {
  var _a25, _b18;
  if (usage == null) {
    return {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
  }
  const promptTokens = (_a25 = usage.prompt_tokens) != null ? _a25 : 0;
  const completionTokens = (_b18 = usage.completion_tokens) != null ? _b18 : 0;
  return {
    inputTokens: {
      total: promptTokens,
      noCache: promptTokens,
      cacheRead: void 0,
      cacheWrite: void 0
    },
    outputTokens: {
      total: completionTokens,
      text: completionTokens,
      reasoning: void 0
    },
    raw: usage
  };
}
function convertToOpenAICompatibleCompletionPrompt({
  prompt,
  user = "user",
  assistant = "assistant"
}) {
  let text2 = "";
  if (prompt[0].role === "system") {
    text2 += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new InvalidPromptError({
          message: "Unexpected system message in prompt: ${content}",
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
          }
        }).filter(Boolean).join("");
        text2 += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "tool-call": {
              throw new UnsupportedFunctionalityError({
                functionality: "tool-call messages"
              });
            }
          }
        }).join("");
        text2 += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new UnsupportedFunctionalityError({
          functionality: "tool messages"
        });
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  text2 += `${assistant}:
`;
  return {
    prompt: text2,
    stopSequences: [`
${user}:`]
  };
}
function getResponseMetadata22({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapOpenAICompatibleFinishReason2(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "other";
  }
}
async function fileToBlob2(file) {
  if (file.type === "url") {
    return downloadBlob(file.url);
  }
  const data = file.data instanceof Uint8Array ? file.data : convertBase64ToUint8Array(file.data);
  return new Blob([data], { type: file.mediaType });
}
function toCamelCase(str) {
  return str.replace(/[_-]([a-z])/g, (g) => g[1].toUpperCase());
}
function createOpenAICompatible(options) {
  const baseURL = withoutTrailingSlash(options.baseURL);
  const providerName = options.name;
  const headers = {
    ...options.apiKey && { Authorization: `Bearer ${options.apiKey}` },
    ...options.headers
  };
  const getHeaders = () => withUserAgentSuffix(headers, `ai-sdk/openai-compatible/${VERSION8}`);
  const getCommonModelConfig = (modelType) => ({
    provider: `${providerName}.${modelType}`,
    url: ({ path: path24 }) => {
      const url = new URL(`${baseURL}${path24}`);
      if (options.queryParams) {
        url.search = new URLSearchParams(options.queryParams).toString();
      }
      return url.toString();
    },
    headers: getHeaders,
    fetch: options.fetch
  });
  const createLanguageModel = (modelId) => createChatModel(modelId);
  const createChatModel = (modelId) => new OpenAICompatibleChatLanguageModel(modelId, {
    ...getCommonModelConfig("chat"),
    includeUsage: options.includeUsage,
    supportsStructuredOutputs: options.supportsStructuredOutputs,
    transformRequestBody: options.transformRequestBody,
    metadataExtractor: options.metadataExtractor
  });
  const createCompletionModel = (modelId) => new OpenAICompatibleCompletionLanguageModel(modelId, {
    ...getCommonModelConfig("completion"),
    includeUsage: options.includeUsage
  });
  const createEmbeddingModel = (modelId) => new OpenAICompatibleEmbeddingModel(modelId, {
    ...getCommonModelConfig("embedding")
  });
  const createImageModel = (modelId) => new OpenAICompatibleImageModel(modelId, getCommonModelConfig("image"));
  const provider = (modelId) => createLanguageModel(modelId);
  provider.specificationVersion = "v3";
  provider.languageModel = createLanguageModel;
  provider.chatModel = createChatModel;
  provider.completionModel = createCompletionModel;
  provider.embeddingModel = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.imageModel = createImageModel;
  return provider;
}
var openaiCompatibleErrorDataSchema, defaultOpenAICompatibleErrorStructure, openaiCompatibleProviderOptions, OpenAICompatibleChatLanguageModel, openaiCompatibleTokenUsageSchema, OpenAICompatibleChatResponseSchema, chunkBaseSchema, createOpenAICompatibleChatChunkSchema, openaiCompatibleCompletionProviderOptions, OpenAICompatibleCompletionLanguageModel, usageSchema2, openaiCompatibleCompletionResponseSchema, createOpenAICompatibleCompletionChunkSchema, openaiCompatibleEmbeddingProviderOptions, OpenAICompatibleEmbeddingModel, openaiTextEmbeddingResponseSchema2, OpenAICompatibleImageModel, openaiCompatibleImageResponseSchema, VERSION8;
var init_dist14 = __esm({
  "node_modules/@ai-sdk/openai-compatible/dist/index.mjs"() {
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    openaiCompatibleErrorDataSchema = z28.object({
      error: z28.object({
        message: z28.string(),
        // The additional information below is handled loosely to support
        // OpenAI-compatible providers that have slightly different error
        // responses:
        type: z28.string().nullish(),
        param: z28.any().nullish(),
        code: z28.union([z28.string(), z28.number()]).nullish()
      })
    });
    defaultOpenAICompatibleErrorStructure = {
      errorSchema: openaiCompatibleErrorDataSchema,
      errorToMessage: (data) => data.error.message
    };
    openaiCompatibleProviderOptions = z29.object({
      /**
       * A unique identifier representing your end-user, which can help the provider to
       * monitor and detect abuse.
       */
      user: z29.string().optional(),
      /**
       * Reasoning effort for reasoning models. Defaults to `medium`.
       */
      reasoningEffort: z29.string().optional(),
      /**
       * Controls the verbosity of the generated text. Defaults to `medium`.
       */
      textVerbosity: z29.string().optional(),
      /**
       * Whether to use strict JSON schema validation.
       * When true, the model uses constrained decoding to guarantee schema compliance.
       * Only used when the provider supports structured outputs and a schema is provided.
       *
       * @default true
       */
      strictJsonSchema: z29.boolean().optional()
    });
    OpenAICompatibleChatLanguageModel = class {
      // type inferred via constructor
      constructor(modelId, config2) {
        this.specificationVersion = "v3";
        var _a25, _b18;
        this.modelId = modelId;
        this.config = config2;
        const errorStructure = (_a25 = config2.errorStructure) != null ? _a25 : defaultOpenAICompatibleErrorStructure;
        this.chunkSchema = createOpenAICompatibleChatChunkSchema(
          errorStructure.errorSchema
        );
        this.failedResponseHandler = createJsonErrorResponseHandler(errorStructure);
        this.supportsStructuredOutputs = (_b18 = config2.supportsStructuredOutputs) != null ? _b18 : false;
      }
      get provider() {
        return this.config.provider;
      }
      get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
      }
      get supportedUrls() {
        var _a25, _b18, _c;
        return (_c = (_b18 = (_a25 = this.config).supportedUrls) == null ? void 0 : _b18.call(_a25)) != null ? _c : {};
      }
      transformRequestBody(args2) {
        var _a25, _b18, _c;
        return (_c = (_b18 = (_a25 = this.config).transformRequestBody) == null ? void 0 : _b18.call(_a25, args2)) != null ? _c : args2;
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        providerOptions,
        stopSequences,
        responseFormat,
        seed,
        toolChoice,
        tools
      }) {
        var _a25, _b18, _c, _d, _e;
        const warnings = [];
        const deprecatedOptions = await parseProviderOptions({
          provider: "openai-compatible",
          providerOptions,
          schema: openaiCompatibleProviderOptions
        });
        if (deprecatedOptions != null) {
          warnings.push({
            type: "other",
            message: `The 'openai-compatible' key in providerOptions is deprecated. Use 'openaiCompatible' instead.`
          });
        }
        const compatibleOptions = Object.assign(
          deprecatedOptions != null ? deprecatedOptions : {},
          (_a25 = await parseProviderOptions({
            provider: "openaiCompatible",
            providerOptions,
            schema: openaiCompatibleProviderOptions
          })) != null ? _a25 : {},
          (_b18 = await parseProviderOptions({
            provider: this.providerOptionsName,
            providerOptions,
            schema: openaiCompatibleProviderOptions
          })) != null ? _b18 : {}
        );
        const strictJsonSchema = (_c = compatibleOptions == null ? void 0 : compatibleOptions.strictJsonSchema) != null ? _c : true;
        if (topK != null) {
          warnings.push({ type: "unsupported", feature: "topK" });
        }
        if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !this.supportsStructuredOutputs) {
          warnings.push({
            type: "unsupported",
            feature: "responseFormat",
            details: "JSON response format schema is only supported with structuredOutputs"
          });
        }
        const {
          tools: openaiTools2,
          toolChoice: openaiToolChoice,
          toolWarnings
        } = prepareTools3({
          tools,
          toolChoice
        });
        return {
          args: {
            // model id:
            model: this.modelId,
            // model specific settings:
            user: compatibleOptions.user,
            // standardized settings:
            max_tokens: maxOutputTokens,
            temperature,
            top_p: topP,
            frequency_penalty: frequencyPenalty,
            presence_penalty: presencePenalty,
            response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? this.supportsStructuredOutputs === true && responseFormat.schema != null ? {
              type: "json_schema",
              json_schema: {
                schema: responseFormat.schema,
                strict: strictJsonSchema,
                name: (_d = responseFormat.name) != null ? _d : "response",
                description: responseFormat.description
              }
            } : { type: "json_object" } : void 0,
            stop: stopSequences,
            seed,
            ...Object.fromEntries(
              Object.entries(
                (_e = providerOptions == null ? void 0 : providerOptions[this.providerOptionsName]) != null ? _e : {}
              ).filter(
                ([key]) => !Object.keys(openaiCompatibleProviderOptions.shape).includes(key)
              )
            ),
            reasoning_effort: compatibleOptions.reasoningEffort,
            verbosity: compatibleOptions.textVerbosity,
            // messages:
            messages: convertToOpenAICompatibleChatMessages(prompt),
            // tools:
            tools: openaiTools2,
            tool_choice: openaiToolChoice
          },
          warnings: [...warnings, ...toolWarnings]
        };
      }
      async doGenerate(options) {
        var _a25, _b18, _c, _d, _e, _f, _g, _h;
        const { args: args2, warnings } = await this.getArgs({ ...options });
        const transformedBody = this.transformRequestBody(args2);
        const body = JSON.stringify(transformedBody);
        const {
          responseHeaders,
          value: responseBody,
          rawValue: rawResponse
        } = await postJsonToApi({
          url: this.config.url({
            path: "/chat/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body: transformedBody,
          failedResponseHandler: this.failedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            OpenAICompatibleChatResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const choice2 = responseBody.choices[0];
        const content = [];
        const text2 = choice2.message.content;
        if (text2 != null && text2.length > 0) {
          content.push({ type: "text", text: text2 });
        }
        const reasoning = (_a25 = choice2.message.reasoning_content) != null ? _a25 : choice2.message.reasoning;
        if (reasoning != null && reasoning.length > 0) {
          content.push({
            type: "reasoning",
            text: reasoning
          });
        }
        if (choice2.message.tool_calls != null) {
          for (const toolCall of choice2.message.tool_calls) {
            const thoughtSignature = (_c = (_b18 = toolCall.extra_content) == null ? void 0 : _b18.google) == null ? void 0 : _c.thought_signature;
            content.push({
              type: "tool-call",
              toolCallId: (_d = toolCall.id) != null ? _d : generateId(),
              toolName: toolCall.function.name,
              input: toolCall.function.arguments,
              ...thoughtSignature ? {
                providerMetadata: {
                  [this.providerOptionsName]: { thoughtSignature }
                }
              } : {}
            });
          }
        }
        const providerMetadata = {
          [this.providerOptionsName]: {},
          ...await ((_f = (_e = this.config.metadataExtractor) == null ? void 0 : _e.extractMetadata) == null ? void 0 : _f.call(_e, {
            parsedBody: rawResponse
          }))
        };
        const completionTokenDetails = (_g = responseBody.usage) == null ? void 0 : _g.completion_tokens_details;
        if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
          providerMetadata[this.providerOptionsName].acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
        }
        if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
          providerMetadata[this.providerOptionsName].rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
        }
        return {
          content,
          finishReason: {
            unified: mapOpenAICompatibleFinishReason(choice2.finish_reason),
            raw: (_h = choice2.finish_reason) != null ? _h : void 0
          },
          usage: convertOpenAICompatibleChatUsage(responseBody.usage),
          providerMetadata,
          request: { body },
          response: {
            ...getResponseMetadata3(responseBody),
            headers: responseHeaders,
            body: rawResponse
          },
          warnings
        };
      }
      async doStream(options) {
        var _a25;
        const { args: args2, warnings } = await this.getArgs({ ...options });
        const body = this.transformRequestBody({
          ...args2,
          stream: true,
          // only include stream_options when in strict compatibility mode:
          stream_options: this.config.includeUsage ? { include_usage: true } : void 0
        });
        const metadataExtractor = (_a25 = this.config.metadataExtractor) == null ? void 0 : _a25.createStreamExtractor();
        const { responseHeaders, value: response } = await postJsonToApi({
          url: this.config.url({
            path: "/chat/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body,
          failedResponseHandler: this.failedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler(
            this.chunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const toolCalls = [];
        let finishReason = {
          unified: "other",
          raw: void 0
        };
        let usage = void 0;
        let isFirstChunk = true;
        const providerOptionsName = this.providerOptionsName;
        let isActiveReasoning = false;
        let isActiveText = false;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                var _a26, _b18, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  finishReason = { unified: "error", raw: void 0 };
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                metadataExtractor == null ? void 0 : metadataExtractor.processChunk(chunk.rawValue);
                if ("error" in chunk.value) {
                  finishReason = { unified: "error", raw: void 0 };
                  controller.enqueue({
                    type: "error",
                    error: chunk.value.error.message
                  });
                  return;
                }
                const value2 = chunk.value;
                if (isFirstChunk) {
                  isFirstChunk = false;
                  controller.enqueue({
                    type: "response-metadata",
                    ...getResponseMetadata3(value2)
                  });
                }
                if (value2.usage != null) {
                  usage = value2.usage;
                }
                const choice2 = value2.choices[0];
                if ((choice2 == null ? void 0 : choice2.finish_reason) != null) {
                  finishReason = {
                    unified: mapOpenAICompatibleFinishReason(choice2.finish_reason),
                    raw: (_a26 = choice2.finish_reason) != null ? _a26 : void 0
                  };
                }
                if ((choice2 == null ? void 0 : choice2.delta) == null) {
                  return;
                }
                const delta = choice2.delta;
                const reasoningContent = (_b18 = delta.reasoning_content) != null ? _b18 : delta.reasoning;
                if (reasoningContent) {
                  if (!isActiveReasoning) {
                    controller.enqueue({
                      type: "reasoning-start",
                      id: "reasoning-0"
                    });
                    isActiveReasoning = true;
                  }
                  controller.enqueue({
                    type: "reasoning-delta",
                    id: "reasoning-0",
                    delta: reasoningContent
                  });
                }
                if (delta.content) {
                  if (isActiveReasoning) {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: "reasoning-0"
                    });
                    isActiveReasoning = false;
                  }
                  if (!isActiveText) {
                    controller.enqueue({ type: "text-start", id: "txt-0" });
                    isActiveText = true;
                  }
                  controller.enqueue({
                    type: "text-delta",
                    id: "txt-0",
                    delta: delta.content
                  });
                }
                if (delta.tool_calls != null) {
                  if (isActiveReasoning) {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: "reasoning-0"
                    });
                    isActiveReasoning = false;
                  }
                  for (const toolCallDelta of delta.tool_calls) {
                    const index = (_c = toolCallDelta.index) != null ? _c : toolCalls.length;
                    if (toolCalls[index] == null) {
                      if (toolCallDelta.id == null) {
                        throw new InvalidResponseDataError({
                          data: toolCallDelta,
                          message: `Expected 'id' to be a string.`
                        });
                      }
                      if (((_d = toolCallDelta.function) == null ? void 0 : _d.name) == null) {
                        throw new InvalidResponseDataError({
                          data: toolCallDelta,
                          message: `Expected 'function.name' to be a string.`
                        });
                      }
                      controller.enqueue({
                        type: "tool-input-start",
                        id: toolCallDelta.id,
                        toolName: toolCallDelta.function.name
                      });
                      toolCalls[index] = {
                        id: toolCallDelta.id,
                        type: "function",
                        function: {
                          name: toolCallDelta.function.name,
                          arguments: (_e = toolCallDelta.function.arguments) != null ? _e : ""
                        },
                        hasFinished: false,
                        thoughtSignature: (_h = (_g = (_f = toolCallDelta.extra_content) == null ? void 0 : _f.google) == null ? void 0 : _g.thought_signature) != null ? _h : void 0
                      };
                      const toolCall2 = toolCalls[index];
                      if (((_i = toolCall2.function) == null ? void 0 : _i.name) != null && ((_j = toolCall2.function) == null ? void 0 : _j.arguments) != null) {
                        if (toolCall2.function.arguments.length > 0) {
                          controller.enqueue({
                            type: "tool-input-delta",
                            id: toolCall2.id,
                            delta: toolCall2.function.arguments
                          });
                        }
                        if (isParsableJson(toolCall2.function.arguments)) {
                          controller.enqueue({
                            type: "tool-input-end",
                            id: toolCall2.id
                          });
                          controller.enqueue({
                            type: "tool-call",
                            toolCallId: (_k = toolCall2.id) != null ? _k : generateId(),
                            toolName: toolCall2.function.name,
                            input: toolCall2.function.arguments,
                            ...toolCall2.thoughtSignature ? {
                              providerMetadata: {
                                [providerOptionsName]: {
                                  thoughtSignature: toolCall2.thoughtSignature
                                }
                              }
                            } : {}
                          });
                          toolCall2.hasFinished = true;
                        }
                      }
                      continue;
                    }
                    const toolCall = toolCalls[index];
                    if (toolCall.hasFinished) {
                      continue;
                    }
                    if (((_l = toolCallDelta.function) == null ? void 0 : _l.arguments) != null) {
                      toolCall.function.arguments += (_n = (_m = toolCallDelta.function) == null ? void 0 : _m.arguments) != null ? _n : "";
                    }
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.id,
                      delta: (_o = toolCallDelta.function.arguments) != null ? _o : ""
                    });
                    if (((_p = toolCall.function) == null ? void 0 : _p.name) != null && ((_q = toolCall.function) == null ? void 0 : _q.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                      controller.enqueue({
                        type: "tool-input-end",
                        id: toolCall.id
                      });
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: (_r = toolCall.id) != null ? _r : generateId(),
                        toolName: toolCall.function.name,
                        input: toolCall.function.arguments,
                        ...toolCall.thoughtSignature ? {
                          providerMetadata: {
                            [providerOptionsName]: {
                              thoughtSignature: toolCall.thoughtSignature
                            }
                          }
                        } : {}
                      });
                      toolCall.hasFinished = true;
                    }
                  }
                }
              },
              flush(controller) {
                var _a26, _b18, _c, _d, _e;
                if (isActiveReasoning) {
                  controller.enqueue({ type: "reasoning-end", id: "reasoning-0" });
                }
                if (isActiveText) {
                  controller.enqueue({ type: "text-end", id: "txt-0" });
                }
                for (const toolCall of toolCalls.filter(
                  (toolCall2) => !toolCall2.hasFinished
                )) {
                  controller.enqueue({
                    type: "tool-input-end",
                    id: toolCall.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: (_a26 = toolCall.id) != null ? _a26 : generateId(),
                    toolName: toolCall.function.name,
                    input: toolCall.function.arguments,
                    ...toolCall.thoughtSignature ? {
                      providerMetadata: {
                        [providerOptionsName]: {
                          thoughtSignature: toolCall.thoughtSignature
                        }
                      }
                    } : {}
                  });
                }
                const providerMetadata = {
                  [providerOptionsName]: {},
                  ...metadataExtractor == null ? void 0 : metadataExtractor.buildMetadata()
                };
                if (((_b18 = usage == null ? void 0 : usage.completion_tokens_details) == null ? void 0 : _b18.accepted_prediction_tokens) != null) {
                  providerMetadata[providerOptionsName].acceptedPredictionTokens = (_c = usage == null ? void 0 : usage.completion_tokens_details) == null ? void 0 : _c.accepted_prediction_tokens;
                }
                if (((_d = usage == null ? void 0 : usage.completion_tokens_details) == null ? void 0 : _d.rejected_prediction_tokens) != null) {
                  providerMetadata[providerOptionsName].rejectedPredictionTokens = (_e = usage == null ? void 0 : usage.completion_tokens_details) == null ? void 0 : _e.rejected_prediction_tokens;
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage: convertOpenAICompatibleChatUsage(usage),
                  providerMetadata
                });
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    openaiCompatibleTokenUsageSchema = z37.looseObject({
      prompt_tokens: z37.number().nullish(),
      completion_tokens: z37.number().nullish(),
      total_tokens: z37.number().nullish(),
      prompt_tokens_details: z37.object({
        cached_tokens: z37.number().nullish()
      }).nullish(),
      completion_tokens_details: z37.object({
        reasoning_tokens: z37.number().nullish(),
        accepted_prediction_tokens: z37.number().nullish(),
        rejected_prediction_tokens: z37.number().nullish()
      }).nullish()
    }).nullish();
    OpenAICompatibleChatResponseSchema = z37.looseObject({
      id: z37.string().nullish(),
      created: z37.number().nullish(),
      model: z37.string().nullish(),
      choices: z37.array(
        z37.object({
          message: z37.object({
            role: z37.literal("assistant").nullish(),
            content: z37.string().nullish(),
            reasoning_content: z37.string().nullish(),
            reasoning: z37.string().nullish(),
            tool_calls: z37.array(
              z37.object({
                id: z37.string().nullish(),
                function: z37.object({
                  name: z37.string(),
                  arguments: z37.string()
                }),
                // Support for Google Gemini thought signatures via OpenAI compatibility
                extra_content: z37.object({
                  google: z37.object({
                    thought_signature: z37.string().nullish()
                  }).nullish()
                }).nullish()
              })
            ).nullish()
          }),
          finish_reason: z37.string().nullish()
        })
      ),
      usage: openaiCompatibleTokenUsageSchema
    });
    chunkBaseSchema = z37.looseObject({
      id: z37.string().nullish(),
      created: z37.number().nullish(),
      model: z37.string().nullish(),
      choices: z37.array(
        z37.object({
          delta: z37.object({
            role: z37.enum(["assistant"]).nullish(),
            content: z37.string().nullish(),
            // Most openai-compatible models set `reasoning_content`, but some
            // providers serving `gpt-oss` set `reasoning`. See #7866
            reasoning_content: z37.string().nullish(),
            reasoning: z37.string().nullish(),
            tool_calls: z37.array(
              z37.object({
                index: z37.number().nullish(),
                //google does not send index
                id: z37.string().nullish(),
                function: z37.object({
                  name: z37.string().nullish(),
                  arguments: z37.string().nullish()
                }),
                // Support for Google Gemini thought signatures via OpenAI compatibility
                extra_content: z37.object({
                  google: z37.object({
                    thought_signature: z37.string().nullish()
                  }).nullish()
                }).nullish()
              })
            ).nullish()
          }).nullish(),
          finish_reason: z37.string().nullish()
        })
      ),
      usage: openaiCompatibleTokenUsageSchema
    });
    createOpenAICompatibleChatChunkSchema = (errorSchema) => z37.union([chunkBaseSchema, errorSchema]);
    openaiCompatibleCompletionProviderOptions = z48.object({
      /**
       * Echo back the prompt in addition to the completion.
       */
      echo: z48.boolean().optional(),
      /**
       * Modify the likelihood of specified tokens appearing in the completion.
       *
       * Accepts a JSON object that maps tokens (specified by their token ID in
       * the GPT tokenizer) to an associated bias value from -100 to 100.
       */
      logitBias: z48.record(z48.string(), z48.number()).optional(),
      /**
       * The suffix that comes after a completion of inserted text.
       */
      suffix: z48.string().optional(),
      /**
       * A unique identifier representing your end-user, which can help providers to
       * monitor and detect abuse.
       */
      user: z48.string().optional()
    });
    OpenAICompatibleCompletionLanguageModel = class {
      // type inferred via constructor
      constructor(modelId, config2) {
        this.specificationVersion = "v3";
        var _a25;
        this.modelId = modelId;
        this.config = config2;
        const errorStructure = (_a25 = config2.errorStructure) != null ? _a25 : defaultOpenAICompatibleErrorStructure;
        this.chunkSchema = createOpenAICompatibleCompletionChunkSchema(
          errorStructure.errorSchema
        );
        this.failedResponseHandler = createJsonErrorResponseHandler(errorStructure);
      }
      get provider() {
        return this.config.provider;
      }
      get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
      }
      get supportedUrls() {
        var _a25, _b18, _c;
        return (_c = (_b18 = (_a25 = this.config).supportedUrls) == null ? void 0 : _b18.call(_a25)) != null ? _c : {};
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        stopSequences: userStopSequences,
        responseFormat,
        seed,
        providerOptions,
        tools,
        toolChoice
      }) {
        var _a25;
        const warnings = [];
        const completionOptions = (_a25 = await parseProviderOptions({
          provider: this.providerOptionsName,
          providerOptions,
          schema: openaiCompatibleCompletionProviderOptions
        })) != null ? _a25 : {};
        if (topK != null) {
          warnings.push({ type: "unsupported", feature: "topK" });
        }
        if (tools == null ? void 0 : tools.length) {
          warnings.push({ type: "unsupported", feature: "tools" });
        }
        if (toolChoice != null) {
          warnings.push({ type: "unsupported", feature: "toolChoice" });
        }
        if (responseFormat != null && responseFormat.type !== "text") {
          warnings.push({
            type: "unsupported",
            feature: "responseFormat",
            details: "JSON response format is not supported."
          });
        }
        const { prompt: completionPrompt, stopSequences } = convertToOpenAICompatibleCompletionPrompt({ prompt });
        const stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
        return {
          args: {
            // model id:
            model: this.modelId,
            // model specific settings:
            echo: completionOptions.echo,
            logit_bias: completionOptions.logitBias,
            suffix: completionOptions.suffix,
            user: completionOptions.user,
            // standardized settings:
            max_tokens: maxOutputTokens,
            temperature,
            top_p: topP,
            frequency_penalty: frequencyPenalty,
            presence_penalty: presencePenalty,
            seed,
            ...providerOptions == null ? void 0 : providerOptions[this.providerOptionsName],
            // prompt:
            prompt: completionPrompt,
            // stop sequences:
            stop: stop.length > 0 ? stop : void 0
          },
          warnings
        };
      }
      async doGenerate(options) {
        const { args: args2, warnings } = await this.getArgs(options);
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi({
          url: this.config.url({
            path: "/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body: args2,
          failedResponseHandler: this.failedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            openaiCompatibleCompletionResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const choice2 = response.choices[0];
        const content = [];
        if (choice2.text != null && choice2.text.length > 0) {
          content.push({ type: "text", text: choice2.text });
        }
        return {
          content,
          usage: convertOpenAICompatibleCompletionUsage(response.usage),
          finishReason: {
            unified: mapOpenAICompatibleFinishReason2(choice2.finish_reason),
            raw: choice2.finish_reason
          },
          request: { body: args2 },
          response: {
            ...getResponseMetadata22(response),
            headers: responseHeaders,
            body: rawResponse
          },
          warnings
        };
      }
      async doStream(options) {
        const { args: args2, warnings } = await this.getArgs(options);
        const body = {
          ...args2,
          stream: true,
          // only include stream_options when in strict compatibility mode:
          stream_options: this.config.includeUsage ? { include_usage: true } : void 0
        };
        const { responseHeaders, value: response } = await postJsonToApi({
          url: this.config.url({
            path: "/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body,
          failedResponseHandler: this.failedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler(
            this.chunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        let finishReason = {
          unified: "other",
          raw: void 0
        };
        let usage = void 0;
        let isFirstChunk = true;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                var _a25;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  finishReason = { unified: "error", raw: void 0 };
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value2 = chunk.value;
                if ("error" in value2) {
                  finishReason = { unified: "error", raw: void 0 };
                  controller.enqueue({ type: "error", error: value2.error });
                  return;
                }
                if (isFirstChunk) {
                  isFirstChunk = false;
                  controller.enqueue({
                    type: "response-metadata",
                    ...getResponseMetadata22(value2)
                  });
                  controller.enqueue({
                    type: "text-start",
                    id: "0"
                  });
                }
                if (value2.usage != null) {
                  usage = value2.usage;
                }
                const choice2 = value2.choices[0];
                if ((choice2 == null ? void 0 : choice2.finish_reason) != null) {
                  finishReason = {
                    unified: mapOpenAICompatibleFinishReason2(choice2.finish_reason),
                    raw: (_a25 = choice2.finish_reason) != null ? _a25 : void 0
                  };
                }
                if ((choice2 == null ? void 0 : choice2.text) != null) {
                  controller.enqueue({
                    type: "text-delta",
                    id: "0",
                    delta: choice2.text
                  });
                }
              },
              flush(controller) {
                if (!isFirstChunk) {
                  controller.enqueue({ type: "text-end", id: "0" });
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage: convertOpenAICompatibleCompletionUsage(usage)
                });
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    usageSchema2 = z57.object({
      prompt_tokens: z57.number(),
      completion_tokens: z57.number(),
      total_tokens: z57.number()
    });
    openaiCompatibleCompletionResponseSchema = z57.object({
      id: z57.string().nullish(),
      created: z57.number().nullish(),
      model: z57.string().nullish(),
      choices: z57.array(
        z57.object({
          text: z57.string(),
          finish_reason: z57.string()
        })
      ),
      usage: usageSchema2.nullish()
    });
    createOpenAICompatibleCompletionChunkSchema = (errorSchema) => z57.union([
      z57.object({
        id: z57.string().nullish(),
        created: z57.number().nullish(),
        model: z57.string().nullish(),
        choices: z57.array(
          z57.object({
            text: z57.string(),
            finish_reason: z57.string().nullish(),
            index: z57.number()
          })
        ),
        usage: usageSchema2.nullish()
      }),
      errorSchema
    ]);
    openaiCompatibleEmbeddingProviderOptions = z67.object({
      /**
       * The number of dimensions the resulting output embeddings should have.
       * Only supported in text-embedding-3 and later models.
       */
      dimensions: z67.number().optional(),
      /**
       * A unique identifier representing your end-user, which can help providers to
       * monitor and detect abuse.
       */
      user: z67.string().optional()
    });
    OpenAICompatibleEmbeddingModel = class {
      constructor(modelId, config2) {
        this.specificationVersion = "v3";
        this.modelId = modelId;
        this.config = config2;
      }
      get provider() {
        return this.config.provider;
      }
      get maxEmbeddingsPerCall() {
        var _a25;
        return (_a25 = this.config.maxEmbeddingsPerCall) != null ? _a25 : 2048;
      }
      get supportsParallelCalls() {
        var _a25;
        return (_a25 = this.config.supportsParallelCalls) != null ? _a25 : true;
      }
      get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
      }
      async doEmbed({
        values,
        headers,
        abortSignal,
        providerOptions
      }) {
        var _a25, _b18, _c;
        const warnings = [];
        const deprecatedOptions = await parseProviderOptions({
          provider: "openai-compatible",
          providerOptions,
          schema: openaiCompatibleEmbeddingProviderOptions
        });
        if (deprecatedOptions != null) {
          warnings.push({
            type: "other",
            message: `The 'openai-compatible' key in providerOptions is deprecated. Use 'openaiCompatible' instead.`
          });
        }
        const compatibleOptions = Object.assign(
          deprecatedOptions != null ? deprecatedOptions : {},
          (_a25 = await parseProviderOptions({
            provider: "openaiCompatible",
            providerOptions,
            schema: openaiCompatibleEmbeddingProviderOptions
          })) != null ? _a25 : {},
          (_b18 = await parseProviderOptions({
            provider: this.providerOptionsName,
            providerOptions,
            schema: openaiCompatibleEmbeddingProviderOptions
          })) != null ? _b18 : {}
        );
        if (values.length > this.maxEmbeddingsPerCall) {
          throw new TooManyEmbeddingValuesForCallError({
            provider: this.provider,
            modelId: this.modelId,
            maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
            values
          });
        }
        const {
          responseHeaders,
          value: response,
          rawValue
        } = await postJsonToApi({
          url: this.config.url({
            path: "/embeddings",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), headers),
          body: {
            model: this.modelId,
            input: values,
            encoding_format: "float",
            dimensions: compatibleOptions.dimensions,
            user: compatibleOptions.user
          },
          failedResponseHandler: createJsonErrorResponseHandler(
            (_c = this.config.errorStructure) != null ? _c : defaultOpenAICompatibleErrorStructure
          ),
          successfulResponseHandler: createJsonResponseHandler(
            openaiTextEmbeddingResponseSchema2
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          warnings,
          embeddings: response.data.map((item) => item.embedding),
          usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
          providerMetadata: response.providerMetadata,
          response: { headers: responseHeaders, body: rawValue }
        };
      }
    };
    openaiTextEmbeddingResponseSchema2 = z77.object({
      data: z77.array(z77.object({ embedding: z77.array(z77.number()) })),
      usage: z77.object({ prompt_tokens: z77.number() }).nullish(),
      providerMetadata: z77.record(z77.string(), z77.record(z77.string(), z77.any())).optional()
    });
    OpenAICompatibleImageModel = class {
      constructor(modelId, config2) {
        this.modelId = modelId;
        this.config = config2;
        this.specificationVersion = "v3";
        this.maxImagesPerCall = 10;
      }
      get provider() {
        return this.config.provider;
      }
      /**
       * The provider options key used to extract provider-specific options.
       */
      get providerOptionsKey() {
        return this.config.provider.split(".")[0].trim();
      }
      // TODO: deprecate non-camelCase keys and remove in future major version
      getArgs(providerOptions) {
        return {
          ...providerOptions[this.providerOptionsKey],
          ...providerOptions[toCamelCase(this.providerOptionsKey)]
        };
      }
      async doGenerate({
        prompt,
        n,
        size,
        aspectRatio,
        seed,
        providerOptions,
        headers,
        abortSignal,
        files,
        mask
      }) {
        var _a25, _b18, _c, _d, _e;
        const warnings = [];
        if (aspectRatio != null) {
          warnings.push({
            type: "unsupported",
            feature: "aspectRatio",
            details: "This model does not support aspect ratio. Use `size` instead."
          });
        }
        if (seed != null) {
          warnings.push({ type: "unsupported", feature: "seed" });
        }
        const currentDate = (_c = (_b18 = (_a25 = this.config._internal) == null ? void 0 : _a25.currentDate) == null ? void 0 : _b18.call(_a25)) != null ? _c : /* @__PURE__ */ new Date();
        const args2 = this.getArgs(providerOptions);
        if (files != null && files.length > 0) {
          const { value: response2, responseHeaders: responseHeaders2 } = await postFormDataToApi({
            url: this.config.url({
              path: "/images/edits",
              modelId: this.modelId
            }),
            headers: combineHeaders(this.config.headers(), headers),
            formData: convertToFormData({
              model: this.modelId,
              prompt,
              image: await Promise.all(files.map((file) => fileToBlob2(file))),
              mask: mask != null ? await fileToBlob2(mask) : void 0,
              n,
              size,
              ...args2
            }),
            failedResponseHandler: createJsonErrorResponseHandler(
              (_d = this.config.errorStructure) != null ? _d : defaultOpenAICompatibleErrorStructure
            ),
            successfulResponseHandler: createJsonResponseHandler(
              openaiCompatibleImageResponseSchema
            ),
            abortSignal,
            fetch: this.config.fetch
          });
          return {
            images: response2.data.map((item) => item.b64_json),
            warnings,
            response: {
              timestamp: currentDate,
              modelId: this.modelId,
              headers: responseHeaders2
            }
          };
        }
        const { value: response, responseHeaders } = await postJsonToApi({
          url: this.config.url({
            path: "/images/generations",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), headers),
          body: {
            model: this.modelId,
            prompt,
            n,
            size,
            ...args2,
            response_format: "b64_json"
          },
          failedResponseHandler: createJsonErrorResponseHandler(
            (_e = this.config.errorStructure) != null ? _e : defaultOpenAICompatibleErrorStructure
          ),
          successfulResponseHandler: createJsonResponseHandler(
            openaiCompatibleImageResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          images: response.data.map((item) => item.b64_json),
          warnings,
          response: {
            timestamp: currentDate,
            modelId: this.modelId,
            headers: responseHeaders
          }
        };
      }
    };
    openaiCompatibleImageResponseSchema = z87.object({
      data: z87.array(z87.object({ b64_json: z87.string() }))
    });
    VERSION8 = true ? "2.0.27" : "0.0.0-test";
  }
});

// node_modules/@ai-sdk/xai/dist/index.mjs
var dist_exports7 = {};
__export(dist_exports7, {
  VERSION: () => VERSION9,
  codeExecution: () => codeExecution2,
  createXai: () => createXai,
  mcpServer: () => mcpServer,
  viewImage: () => viewImage,
  viewXVideo: () => viewXVideo,
  webSearch: () => webSearch2,
  xSearch: () => xSearch,
  xai: () => xai,
  xaiTools: () => xaiTools
});
import { z as z38 } from "zod/v4";
import { z as z30 } from "zod/v4";
import { z as z210 } from "zod/v4";
import { z as z49 } from "zod/v4";
import { z as z58 } from "zod/v4";
import { z as z68 } from "zod/v4";
import { z as z78 } from "zod/v4";
import { z as z88 } from "zod/v4";
import { z as z96 } from "zod/v4";
import { z as z106 } from "zod/v4";
import { z as z115 } from "zod/v4";
import { z as z125 } from "zod/v4";
function convertToXaiChatMessages(prompt) {
  var _a25;
  const messages = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part) => {
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                    }
                  };
                } else {
                  throw new UnsupportedFunctionalityError({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text2 = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text2 += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text2,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          if (toolResponse.type === "tool-approval-response") {
            continue;
          }
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "execution-denied":
              contentValue = (_a25 = output.reason) != null ? _a25 : "Tool execution denied.";
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { messages, warnings };
}
function convertXaiChatUsage(usage) {
  var _a25, _b18, _c, _d;
  const cacheReadTokens = (_b18 = (_a25 = usage.prompt_tokens_details) == null ? void 0 : _a25.cached_tokens) != null ? _b18 : 0;
  const reasoningTokens = (_d = (_c = usage.completion_tokens_details) == null ? void 0 : _c.reasoning_tokens) != null ? _d : 0;
  return {
    inputTokens: {
      total: usage.prompt_tokens,
      noCache: usage.prompt_tokens - cacheReadTokens,
      cacheRead: cacheReadTokens,
      cacheWrite: void 0
    },
    outputTokens: {
      total: usage.completion_tokens,
      text: usage.completion_tokens - reasoningTokens,
      reasoning: reasoningTokens
    },
    raw: usage
  };
}
function getResponseMetadata4({
  id,
  model,
  created,
  created_at
}) {
  const unixTime = created != null ? created : created_at;
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: unixTime != null ? new Date(unixTime * 1e3) : void 0
  };
}
function mapXaiFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "tool_calls":
    case "function_call":
      return "tool-calls";
    case "content_filter":
      return "content-filter";
    default:
      return "other";
  }
}
function prepareTools4({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const xaiTools2 = [];
  for (const tool2 of tools) {
    if (tool2.type === "provider") {
      toolWarnings.push({
        type: "unsupported",
        feature: `provider-defined tool ${tool2.name}`
      });
    } else {
      xaiTools2.push({
        type: "function",
        function: {
          name: tool2.name,
          description: tool2.description,
          parameters: tool2.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: xaiTools2, toolChoice: void 0, toolWarnings };
  }
  const type2 = toolChoice.type;
  switch (type2) {
    case "auto":
    case "none":
      return { tools: xaiTools2, toolChoice: type2, toolWarnings };
    case "required":
      return { tools: xaiTools2, toolChoice: "required", toolWarnings };
    case "tool":
      return {
        tools: xaiTools2,
        toolChoice: {
          type: "function",
          function: { name: toolChoice.toolName }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type2;
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
async function convertToXaiResponsesInput({
  prompt
}) {
  var _a25, _b18, _c, _d, _e;
  const input = [];
  const inputWarnings = [];
  for (const message of prompt) {
    switch (message.role) {
      case "system": {
        input.push({
          role: "system",
          content: message.content
        });
        break;
      }
      case "user": {
        const contentParts = [];
        for (const block of message.content) {
          switch (block.type) {
            case "text": {
              contentParts.push({ type: "input_text", text: block.text });
              break;
            }
            case "file": {
              if (block.mediaType.startsWith("image/")) {
                const mediaType = block.mediaType === "image/*" ? "image/jpeg" : block.mediaType;
                const imageUrl = block.data instanceof URL ? block.data.toString() : `data:${mediaType};base64,${convertToBase64(block.data)}`;
                contentParts.push({ type: "input_image", image_url: imageUrl });
              } else {
                throw new UnsupportedFunctionalityError({
                  functionality: `file part media type ${block.mediaType}`
                });
              }
              break;
            }
            default: {
              const _exhaustiveCheck = block;
              inputWarnings.push({
                type: "other",
                message: "xAI Responses API does not support this content type in user messages"
              });
            }
          }
        }
        input.push({
          role: "user",
          content: contentParts
        });
        break;
      }
      case "assistant": {
        for (const part of message.content) {
          switch (part.type) {
            case "text": {
              const id = typeof ((_b18 = (_a25 = part.providerOptions) == null ? void 0 : _a25.xai) == null ? void 0 : _b18.itemId) === "string" ? part.providerOptions.xai.itemId : void 0;
              input.push({
                role: "assistant",
                content: part.text,
                id
              });
              break;
            }
            case "tool-call": {
              if (part.providerExecuted) {
                break;
              }
              const id = typeof ((_d = (_c = part.providerOptions) == null ? void 0 : _c.xai) == null ? void 0 : _d.itemId) === "string" ? part.providerOptions.xai.itemId : void 0;
              input.push({
                type: "function_call",
                id: id != null ? id : part.toolCallId,
                call_id: part.toolCallId,
                name: part.toolName,
                arguments: JSON.stringify(part.input),
                status: "completed"
              });
              break;
            }
            case "tool-result": {
              break;
            }
            case "reasoning":
            case "file": {
              inputWarnings.push({
                type: "other",
                message: `xAI Responses API does not support ${part.type} in assistant messages`
              });
              break;
            }
            default: {
              const _exhaustiveCheck = part;
              inputWarnings.push({
                type: "other",
                message: "xAI Responses API does not support this content type in assistant messages"
              });
            }
          }
        }
        break;
      }
      case "tool": {
        for (const part of message.content) {
          if (part.type === "tool-approval-response") {
            continue;
          }
          const output = part.output;
          let outputValue;
          switch (output.type) {
            case "text":
            case "error-text":
              outputValue = output.value;
              break;
            case "execution-denied":
              outputValue = (_e = output.reason) != null ? _e : "tool execution denied";
              break;
            case "json":
            case "error-json":
              outputValue = JSON.stringify(output.value);
              break;
            case "content":
              outputValue = output.value.map((item) => {
                if (item.type === "text") {
                  return item.text;
                }
                return "";
              }).join("");
              break;
            default: {
              const _exhaustiveCheck = output;
              outputValue = "";
            }
          }
          input.push({
            type: "function_call_output",
            call_id: part.toolCallId,
            output: outputValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = message;
        inputWarnings.push({
          type: "other",
          message: "unsupported message role"
        });
      }
    }
  }
  return { input, inputWarnings };
}
function convertXaiResponsesUsage(usage) {
  var _a25, _b18, _c, _d;
  const cacheReadTokens = (_b18 = (_a25 = usage.input_tokens_details) == null ? void 0 : _a25.cached_tokens) != null ? _b18 : 0;
  const reasoningTokens = (_d = (_c = usage.output_tokens_details) == null ? void 0 : _c.reasoning_tokens) != null ? _d : 0;
  return {
    inputTokens: {
      total: usage.input_tokens,
      noCache: usage.input_tokens - cacheReadTokens,
      cacheRead: cacheReadTokens,
      cacheWrite: void 0
    },
    outputTokens: {
      total: usage.output_tokens,
      text: usage.output_tokens - reasoningTokens,
      reasoning: reasoningTokens
    },
    raw: usage
  };
}
function mapXaiResponsesFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
    case "completed":
      return "stop";
    case "length":
      return "length";
    case "tool_calls":
    case "function_call":
      return "tool-calls";
    case "content_filter":
      return "content-filter";
    default:
      return "other";
  }
}
async function prepareResponsesTools2({
  tools,
  toolChoice
}) {
  const normalizedTools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (normalizedTools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const xaiTools2 = [];
  const toolByName = /* @__PURE__ */ new Map();
  for (const tool2 of normalizedTools) {
    toolByName.set(tool2.name, tool2);
    if (tool2.type === "provider") {
      switch (tool2.id) {
        case "xai.web_search": {
          const args2 = await validateTypes({
            value: tool2.args,
            schema: webSearchArgsSchema2
          });
          xaiTools2.push({
            type: "web_search",
            allowed_domains: args2.allowedDomains,
            excluded_domains: args2.excludedDomains,
            enable_image_understanding: args2.enableImageUnderstanding
          });
          break;
        }
        case "xai.x_search": {
          const args2 = await validateTypes({
            value: tool2.args,
            schema: xSearchArgsSchema
          });
          xaiTools2.push({
            type: "x_search",
            allowed_x_handles: args2.allowedXHandles,
            excluded_x_handles: args2.excludedXHandles,
            from_date: args2.fromDate,
            to_date: args2.toDate,
            enable_image_understanding: args2.enableImageUnderstanding,
            enable_video_understanding: args2.enableVideoUnderstanding
          });
          break;
        }
        case "xai.code_execution": {
          xaiTools2.push({
            type: "code_interpreter"
          });
          break;
        }
        case "xai.view_image": {
          xaiTools2.push({
            type: "view_image"
          });
          break;
        }
        case "xai.view_x_video": {
          xaiTools2.push({
            type: "view_x_video"
          });
          break;
        }
        case "xai.file_search": {
          const args2 = await validateTypes({
            value: tool2.args,
            schema: fileSearchArgsSchema3
          });
          xaiTools2.push({
            type: "file_search",
            vector_store_ids: args2.vectorStoreIds,
            max_num_results: args2.maxNumResults
          });
          break;
        }
        case "xai.mcp": {
          const args2 = await validateTypes({
            value: tool2.args,
            schema: mcpServerArgsSchema
          });
          xaiTools2.push({
            type: "mcp",
            server_url: args2.serverUrl,
            server_label: args2.serverLabel,
            server_description: args2.serverDescription,
            allowed_tools: args2.allowedTools,
            headers: args2.headers,
            authorization: args2.authorization
          });
          break;
        }
        default: {
          toolWarnings.push({
            type: "unsupported",
            feature: `provider-defined tool ${tool2.name}`
          });
          break;
        }
      }
    } else {
      xaiTools2.push({
        type: "function",
        name: tool2.name,
        description: tool2.description,
        parameters: tool2.inputSchema
      });
    }
  }
  if (toolChoice == null) {
    return { tools: xaiTools2, toolChoice: void 0, toolWarnings };
  }
  const type2 = toolChoice.type;
  switch (type2) {
    case "auto":
    case "none":
      return { tools: xaiTools2, toolChoice: type2, toolWarnings };
    case "required":
      return { tools: xaiTools2, toolChoice: "required", toolWarnings };
    case "tool": {
      const selectedTool = toolByName.get(toolChoice.toolName);
      if (selectedTool == null) {
        return {
          tools: xaiTools2,
          toolChoice: void 0,
          toolWarnings
        };
      }
      if (selectedTool.type === "provider") {
        toolWarnings.push({
          type: "unsupported",
          feature: `toolChoice for server-side tool "${selectedTool.name}"`
        });
        return { tools: xaiTools2, toolChoice: void 0, toolWarnings };
      }
      return {
        tools: xaiTools2,
        toolChoice: { type: "function", name: selectedTool.name },
        toolWarnings
      };
    }
    default: {
      const _exhaustiveCheck = type2;
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function createXai(options = {}) {
  var _a25;
  const baseURL = withoutTrailingSlash(
    (_a25 = options.baseURL) != null ? _a25 : "https://api.x.ai/v1"
  );
  const getHeaders = () => withUserAgentSuffix(
    {
      Authorization: `Bearer ${loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "XAI_API_KEY",
        description: "xAI API key"
      })}`,
      ...options.headers
    },
    `ai-sdk/xai/${VERSION9}`
  );
  const createChatLanguageModel = (modelId) => {
    return new XaiChatLanguageModel(modelId, {
      provider: "xai.chat",
      baseURL,
      headers: getHeaders,
      generateId,
      fetch: options.fetch
    });
  };
  const createResponsesLanguageModel = (modelId) => {
    return new XaiResponsesLanguageModel(modelId, {
      provider: "xai.responses",
      baseURL,
      headers: getHeaders,
      generateId,
      fetch: options.fetch
    });
  };
  const createImageModel = (modelId) => {
    return new OpenAICompatibleImageModel(modelId, {
      provider: "xai.image",
      url: ({ path: path24 }) => `${baseURL}${path24}`,
      headers: getHeaders,
      fetch: options.fetch,
      errorStructure: xaiErrorStructure
    });
  };
  const provider = (modelId) => createChatLanguageModel(modelId);
  provider.specificationVersion = "v3";
  provider.languageModel = createChatLanguageModel;
  provider.chat = createChatLanguageModel;
  provider.responses = createResponsesLanguageModel;
  provider.embeddingModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "embeddingModel" });
  };
  provider.textEmbeddingModel = provider.embeddingModel;
  provider.imageModel = createImageModel;
  provider.image = createImageModel;
  provider.tools = xaiTools;
  return provider;
}
var webSourceSchema, xSourceSchema, newsSourceSchema, rssSourceSchema, searchSourceSchema, xaiProviderOptions, xaiErrorDataSchema, xaiFailedResponseHandler, XaiChatLanguageModel, xaiUsageSchema, xaiChatResponseSchema, xaiChatChunkSchema, xaiStreamErrorSchema, annotationSchema, messageContentPartSchema, reasoningSummaryPartSchema, toolCallSchema, mcpCallSchema, outputItemSchema, xaiResponsesUsageSchema, xaiResponsesResponseSchema, xaiResponsesChunkSchema, xaiResponsesProviderOptions, fileSearchArgsSchema3, fileSearchOutputSchema2, fileSearchToolFactory, fileSearch3, mcpServerArgsSchema, mcpServerOutputSchema, mcpServerToolFactory, mcpServer, webSearchArgsSchema2, webSearchOutputSchema2, webSearchToolFactory2, webSearch2, xSearchArgsSchema, xSearchOutputSchema, xSearchToolFactory, xSearch, XaiResponsesLanguageModel, codeExecutionOutputSchema, codeExecutionToolFactory, codeExecution2, viewImageOutputSchema, viewImageToolFactory, viewImage, viewXVideoOutputSchema, viewXVideoToolFactory, viewXVideo, xaiTools, VERSION9, xaiErrorStructure, xai;
var init_dist15 = __esm({
  "node_modules/@ai-sdk/xai/dist/index.mjs"() {
    init_dist14();
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    webSourceSchema = z30.object({
      type: z30.literal("web"),
      country: z30.string().length(2).optional(),
      excludedWebsites: z30.array(z30.string()).max(5).optional(),
      allowedWebsites: z30.array(z30.string()).max(5).optional(),
      safeSearch: z30.boolean().optional()
    });
    xSourceSchema = z30.object({
      type: z30.literal("x"),
      excludedXHandles: z30.array(z30.string()).optional(),
      includedXHandles: z30.array(z30.string()).optional(),
      postFavoriteCount: z30.number().int().optional(),
      postViewCount: z30.number().int().optional(),
      /**
       * @deprecated use `includedXHandles` instead
       */
      xHandles: z30.array(z30.string()).optional()
    });
    newsSourceSchema = z30.object({
      type: z30.literal("news"),
      country: z30.string().length(2).optional(),
      excludedWebsites: z30.array(z30.string()).max(5).optional(),
      safeSearch: z30.boolean().optional()
    });
    rssSourceSchema = z30.object({
      type: z30.literal("rss"),
      links: z30.array(z30.string().url()).max(1)
      // currently only supports one RSS link
    });
    searchSourceSchema = z30.discriminatedUnion("type", [
      webSourceSchema,
      xSourceSchema,
      newsSourceSchema,
      rssSourceSchema
    ]);
    xaiProviderOptions = z30.object({
      reasoningEffort: z30.enum(["low", "high"]).optional(),
      /**
       * Whether to enable parallel function calling during tool use.
       * When true, the model can call multiple functions in parallel.
       * When false, the model will call functions sequentially.
       * Defaults to true.
       */
      parallel_function_calling: z30.boolean().optional(),
      searchParameters: z30.object({
        /**
         * search mode preference
         * - "off": disables search completely
         * - "auto": model decides whether to search (default)
         * - "on": always enables search
         */
        mode: z30.enum(["off", "auto", "on"]),
        /**
         * whether to return citations in the response
         * defaults to true
         */
        returnCitations: z30.boolean().optional(),
        /**
         * start date for search data (ISO8601 format: YYYY-MM-DD)
         */
        fromDate: z30.string().optional(),
        /**
         * end date for search data (ISO8601 format: YYYY-MM-DD)
         */
        toDate: z30.string().optional(),
        /**
         * maximum number of search results to consider
         * defaults to 20
         */
        maxSearchResults: z30.number().min(1).max(50).optional(),
        /**
         * data sources to search from.
         * defaults to [{ type: 'web' }, { type: 'x' }] if not specified.
         *
         * @example
         * sources: [{ type: 'web', country: 'US' }, { type: 'x' }]
         */
        sources: z30.array(searchSourceSchema).optional()
      }).optional()
    });
    xaiErrorDataSchema = z210.object({
      error: z210.object({
        message: z210.string(),
        type: z210.string().nullish(),
        param: z210.any().nullish(),
        code: z210.union([z210.string(), z210.number()]).nullish()
      })
    });
    xaiFailedResponseHandler = createJsonErrorResponseHandler({
      errorSchema: xaiErrorDataSchema,
      errorToMessage: (data) => data.error.message
    });
    XaiChatLanguageModel = class {
      constructor(modelId, config2) {
        this.specificationVersion = "v3";
        this.supportedUrls = {
          "image/*": [/^https?:\/\/.*$/]
        };
        this.modelId = modelId;
        this.config = config2;
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        stopSequences,
        seed,
        responseFormat,
        providerOptions,
        tools,
        toolChoice
      }) {
        var _a25, _b18, _c;
        const warnings = [];
        const options = (_a25 = await parseProviderOptions({
          provider: "xai",
          providerOptions,
          schema: xaiProviderOptions
        })) != null ? _a25 : {};
        if (topK != null) {
          warnings.push({ type: "unsupported", feature: "topK" });
        }
        if (frequencyPenalty != null) {
          warnings.push({ type: "unsupported", feature: "frequencyPenalty" });
        }
        if (presencePenalty != null) {
          warnings.push({ type: "unsupported", feature: "presencePenalty" });
        }
        if (stopSequences != null) {
          warnings.push({ type: "unsupported", feature: "stopSequences" });
        }
        const { messages, warnings: messageWarnings } = convertToXaiChatMessages(prompt);
        warnings.push(...messageWarnings);
        const {
          tools: xaiTools2,
          toolChoice: xaiToolChoice,
          toolWarnings
        } = prepareTools4({
          tools,
          toolChoice
        });
        warnings.push(...toolWarnings);
        const baseArgs = {
          // model id
          model: this.modelId,
          // standard generation settings
          max_completion_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          seed,
          reasoning_effort: options.reasoningEffort,
          // parallel function calling
          parallel_function_calling: options.parallel_function_calling,
          // response format
          response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? responseFormat.schema != null ? {
            type: "json_schema",
            json_schema: {
              name: (_b18 = responseFormat.name) != null ? _b18 : "response",
              schema: responseFormat.schema,
              strict: true
            }
          } : { type: "json_object" } : void 0,
          // search parameters
          search_parameters: options.searchParameters ? {
            mode: options.searchParameters.mode,
            return_citations: options.searchParameters.returnCitations,
            from_date: options.searchParameters.fromDate,
            to_date: options.searchParameters.toDate,
            max_search_results: options.searchParameters.maxSearchResults,
            sources: (_c = options.searchParameters.sources) == null ? void 0 : _c.map((source) => {
              var _a26;
              return {
                type: source.type,
                ...source.type === "web" && {
                  country: source.country,
                  excluded_websites: source.excludedWebsites,
                  allowed_websites: source.allowedWebsites,
                  safe_search: source.safeSearch
                },
                ...source.type === "x" && {
                  excluded_x_handles: source.excludedXHandles,
                  included_x_handles: (_a26 = source.includedXHandles) != null ? _a26 : source.xHandles,
                  post_favorite_count: source.postFavoriteCount,
                  post_view_count: source.postViewCount
                },
                ...source.type === "news" && {
                  country: source.country,
                  excluded_websites: source.excludedWebsites,
                  safe_search: source.safeSearch
                },
                ...source.type === "rss" && {
                  links: source.links
                }
              };
            })
          } : void 0,
          // messages in xai format
          messages,
          // tools in xai format
          tools: xaiTools2,
          tool_choice: xaiToolChoice
        };
        return {
          args: baseArgs,
          warnings
        };
      }
      async doGenerate(options) {
        var _a25, _b18;
        const { args: body, warnings } = await this.getArgs(options);
        const url = `${(_a25 = this.config.baseURL) != null ? _a25 : "https://api.x.ai/v1"}/chat/completions`;
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi({
          url,
          headers: combineHeaders(this.config.headers(), options.headers),
          body,
          failedResponseHandler: xaiFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            xaiChatResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        if (response.error != null) {
          throw new APICallError({
            message: response.error,
            url,
            requestBodyValues: body,
            statusCode: 200,
            responseHeaders,
            responseBody: JSON.stringify(rawResponse),
            isRetryable: response.code === "The service is currently unavailable"
          });
        }
        const choice2 = response.choices[0];
        const content = [];
        if (choice2.message.content != null && choice2.message.content.length > 0) {
          let text2 = choice2.message.content;
          const lastMessage = body.messages[body.messages.length - 1];
          if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && text2 === lastMessage.content) {
            text2 = "";
          }
          if (text2.length > 0) {
            content.push({ type: "text", text: text2 });
          }
        }
        if (choice2.message.reasoning_content != null && choice2.message.reasoning_content.length > 0) {
          content.push({
            type: "reasoning",
            text: choice2.message.reasoning_content
          });
        }
        if (choice2.message.tool_calls != null) {
          for (const toolCall of choice2.message.tool_calls) {
            content.push({
              type: "tool-call",
              toolCallId: toolCall.id,
              toolName: toolCall.function.name,
              input: toolCall.function.arguments
            });
          }
        }
        if (response.citations != null) {
          for (const url2 of response.citations) {
            content.push({
              type: "source",
              sourceType: "url",
              id: this.config.generateId(),
              url: url2
            });
          }
        }
        return {
          content,
          finishReason: {
            unified: mapXaiFinishReason(choice2.finish_reason),
            raw: (_b18 = choice2.finish_reason) != null ? _b18 : void 0
          },
          usage: convertXaiChatUsage(response.usage),
          // defined when there is no error
          request: { body },
          response: {
            ...getResponseMetadata4(response),
            headers: responseHeaders,
            body: rawResponse
          },
          warnings
        };
      }
      async doStream(options) {
        var _a25;
        const { args: args2, warnings } = await this.getArgs(options);
        const body = {
          ...args2,
          stream: true,
          stream_options: {
            include_usage: true
          }
        };
        const url = `${(_a25 = this.config.baseURL) != null ? _a25 : "https://api.x.ai/v1"}/chat/completions`;
        const { responseHeaders, value: response } = await postJsonToApi({
          url,
          headers: combineHeaders(this.config.headers(), options.headers),
          body,
          failedResponseHandler: xaiFailedResponseHandler,
          successfulResponseHandler: async ({ response: response2 }) => {
            const responseHeaders2 = extractResponseHeaders(response2);
            const contentType = response2.headers.get("content-type");
            if (contentType == null ? void 0 : contentType.includes("application/json")) {
              const responseBody = await response2.text();
              const parsedError = await safeParseJSON({
                text: responseBody,
                schema: xaiStreamErrorSchema
              });
              if (parsedError.success) {
                throw new APICallError({
                  message: parsedError.value.error,
                  url,
                  requestBodyValues: body,
                  statusCode: 200,
                  responseHeaders: responseHeaders2,
                  responseBody,
                  isRetryable: parsedError.value.code === "The service is currently unavailable"
                });
              }
              throw new APICallError({
                message: "Invalid JSON response",
                url,
                requestBodyValues: body,
                statusCode: 200,
                responseHeaders: responseHeaders2,
                responseBody
              });
            }
            return createEventSourceResponseHandler(xaiChatChunkSchema)({
              response: response2,
              url,
              requestBodyValues: body
            });
          },
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        let finishReason = {
          unified: "other",
          raw: void 0
        };
        let usage = void 0;
        let isFirstChunk = true;
        const contentBlocks = {};
        const lastReasoningDeltas = {};
        let activeReasoningBlockId = void 0;
        const self = this;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value2 = chunk.value;
                if (isFirstChunk) {
                  controller.enqueue({
                    type: "response-metadata",
                    ...getResponseMetadata4(value2)
                  });
                  isFirstChunk = false;
                }
                if (value2.citations != null) {
                  for (const url2 of value2.citations) {
                    controller.enqueue({
                      type: "source",
                      sourceType: "url",
                      id: self.config.generateId(),
                      url: url2
                    });
                  }
                }
                if (value2.usage != null) {
                  usage = convertXaiChatUsage(value2.usage);
                }
                const choice2 = value2.choices[0];
                if ((choice2 == null ? void 0 : choice2.finish_reason) != null) {
                  finishReason = {
                    unified: mapXaiFinishReason(choice2.finish_reason),
                    raw: choice2.finish_reason
                  };
                }
                if ((choice2 == null ? void 0 : choice2.delta) == null) {
                  return;
                }
                const delta = choice2.delta;
                const choiceIndex = choice2.index;
                if (delta.content != null && delta.content.length > 0) {
                  const textContent = delta.content;
                  if (activeReasoningBlockId != null && !contentBlocks[activeReasoningBlockId].ended) {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: activeReasoningBlockId
                    });
                    contentBlocks[activeReasoningBlockId].ended = true;
                    activeReasoningBlockId = void 0;
                  }
                  const lastMessage = body.messages[body.messages.length - 1];
                  if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && textContent === lastMessage.content) {
                    return;
                  }
                  const blockId = `text-${value2.id || choiceIndex}`;
                  if (contentBlocks[blockId] == null) {
                    contentBlocks[blockId] = { type: "text", ended: false };
                    controller.enqueue({
                      type: "text-start",
                      id: blockId
                    });
                  }
                  controller.enqueue({
                    type: "text-delta",
                    id: blockId,
                    delta: textContent
                  });
                }
                if (delta.reasoning_content != null && delta.reasoning_content.length > 0) {
                  const blockId = `reasoning-${value2.id || choiceIndex}`;
                  if (lastReasoningDeltas[blockId] === delta.reasoning_content) {
                    return;
                  }
                  lastReasoningDeltas[blockId] = delta.reasoning_content;
                  if (contentBlocks[blockId] == null) {
                    contentBlocks[blockId] = { type: "reasoning", ended: false };
                    activeReasoningBlockId = blockId;
                    controller.enqueue({
                      type: "reasoning-start",
                      id: blockId
                    });
                  }
                  controller.enqueue({
                    type: "reasoning-delta",
                    id: blockId,
                    delta: delta.reasoning_content
                  });
                }
                if (delta.tool_calls != null) {
                  if (activeReasoningBlockId != null && !contentBlocks[activeReasoningBlockId].ended) {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: activeReasoningBlockId
                    });
                    contentBlocks[activeReasoningBlockId].ended = true;
                    activeReasoningBlockId = void 0;
                  }
                  for (const toolCall of delta.tool_calls) {
                    const toolCallId = toolCall.id;
                    controller.enqueue({
                      type: "tool-input-start",
                      id: toolCallId,
                      toolName: toolCall.function.name
                    });
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCallId,
                      delta: toolCall.function.arguments
                    });
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCallId
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId,
                      toolName: toolCall.function.name,
                      input: toolCall.function.arguments
                    });
                  }
                }
              },
              flush(controller) {
                for (const [blockId, block] of Object.entries(contentBlocks)) {
                  if (!block.ended) {
                    controller.enqueue({
                      type: block.type === "text" ? "text-end" : "reasoning-end",
                      id: blockId
                    });
                  }
                }
                controller.enqueue({ type: "finish", finishReason, usage });
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    xaiUsageSchema = z38.object({
      prompt_tokens: z38.number(),
      completion_tokens: z38.number(),
      total_tokens: z38.number(),
      prompt_tokens_details: z38.object({
        text_tokens: z38.number().nullish(),
        audio_tokens: z38.number().nullish(),
        image_tokens: z38.number().nullish(),
        cached_tokens: z38.number().nullish()
      }).nullish(),
      completion_tokens_details: z38.object({
        reasoning_tokens: z38.number().nullish(),
        audio_tokens: z38.number().nullish(),
        accepted_prediction_tokens: z38.number().nullish(),
        rejected_prediction_tokens: z38.number().nullish()
      }).nullish()
    });
    xaiChatResponseSchema = z38.object({
      id: z38.string().nullish(),
      created: z38.number().nullish(),
      model: z38.string().nullish(),
      choices: z38.array(
        z38.object({
          message: z38.object({
            role: z38.literal("assistant"),
            content: z38.string().nullish(),
            reasoning_content: z38.string().nullish(),
            tool_calls: z38.array(
              z38.object({
                id: z38.string(),
                type: z38.literal("function"),
                function: z38.object({
                  name: z38.string(),
                  arguments: z38.string()
                })
              })
            ).nullish()
          }),
          index: z38.number(),
          finish_reason: z38.string().nullish()
        })
      ).nullish(),
      object: z38.literal("chat.completion").nullish(),
      usage: xaiUsageSchema.nullish(),
      citations: z38.array(z38.string().url()).nullish(),
      code: z38.string().nullish(),
      error: z38.string().nullish()
    });
    xaiChatChunkSchema = z38.object({
      id: z38.string().nullish(),
      created: z38.number().nullish(),
      model: z38.string().nullish(),
      choices: z38.array(
        z38.object({
          delta: z38.object({
            role: z38.enum(["assistant"]).optional(),
            content: z38.string().nullish(),
            reasoning_content: z38.string().nullish(),
            tool_calls: z38.array(
              z38.object({
                id: z38.string(),
                type: z38.literal("function"),
                function: z38.object({
                  name: z38.string(),
                  arguments: z38.string()
                })
              })
            ).nullish()
          }),
          finish_reason: z38.string().nullish(),
          index: z38.number()
        })
      ),
      usage: xaiUsageSchema.nullish(),
      citations: z38.array(z38.string().url()).nullish()
    });
    xaiStreamErrorSchema = z38.object({
      code: z38.string(),
      error: z38.string()
    });
    annotationSchema = z49.union([
      z49.object({
        type: z49.literal("url_citation"),
        url: z49.string(),
        title: z49.string().optional()
      }),
      z49.object({
        type: z49.string()
      })
    ]);
    messageContentPartSchema = z49.object({
      type: z49.string(),
      text: z49.string().optional(),
      logprobs: z49.array(z49.any()).optional(),
      annotations: z49.array(annotationSchema).optional()
    });
    reasoningSummaryPartSchema = z49.object({
      type: z49.string(),
      text: z49.string()
    });
    toolCallSchema = z49.object({
      name: z49.string().optional(),
      arguments: z49.string().optional(),
      input: z49.string().optional(),
      call_id: z49.string().optional(),
      id: z49.string(),
      status: z49.string(),
      action: z49.any().optional()
    });
    mcpCallSchema = z49.object({
      name: z49.string().optional(),
      arguments: z49.string().optional(),
      output: z49.string().optional(),
      error: z49.string().optional(),
      id: z49.string(),
      status: z49.string(),
      server_label: z49.string().optional()
    });
    outputItemSchema = z49.discriminatedUnion("type", [
      z49.object({
        type: z49.literal("web_search_call"),
        ...toolCallSchema.shape
      }),
      z49.object({
        type: z49.literal("x_search_call"),
        ...toolCallSchema.shape
      }),
      z49.object({
        type: z49.literal("code_interpreter_call"),
        ...toolCallSchema.shape
      }),
      z49.object({
        type: z49.literal("code_execution_call"),
        ...toolCallSchema.shape
      }),
      z49.object({
        type: z49.literal("view_image_call"),
        ...toolCallSchema.shape
      }),
      z49.object({
        type: z49.literal("view_x_video_call"),
        ...toolCallSchema.shape
      }),
      z49.object({
        type: z49.literal("file_search_call"),
        id: z49.string(),
        status: z49.string(),
        queries: z49.array(z49.string()).optional(),
        results: z49.array(
          z49.object({
            file_id: z49.string(),
            filename: z49.string(),
            score: z49.number(),
            text: z49.string()
          })
        ).nullish()
      }),
      z49.object({
        type: z49.literal("custom_tool_call"),
        ...toolCallSchema.shape
      }),
      z49.object({
        type: z49.literal("mcp_call"),
        ...mcpCallSchema.shape
      }),
      z49.object({
        type: z49.literal("message"),
        role: z49.string(),
        content: z49.array(messageContentPartSchema),
        id: z49.string(),
        status: z49.string()
      }),
      z49.object({
        type: z49.literal("function_call"),
        name: z49.string(),
        arguments: z49.string(),
        call_id: z49.string(),
        id: z49.string()
      }),
      z49.object({
        type: z49.literal("reasoning"),
        id: z49.string(),
        summary: z49.array(reasoningSummaryPartSchema),
        status: z49.string(),
        encrypted_content: z49.string().nullish()
      })
    ]);
    xaiResponsesUsageSchema = z49.object({
      input_tokens: z49.number(),
      output_tokens: z49.number(),
      total_tokens: z49.number().optional(),
      input_tokens_details: z49.object({
        cached_tokens: z49.number().optional()
      }).optional(),
      output_tokens_details: z49.object({
        reasoning_tokens: z49.number().optional()
      }).optional(),
      num_sources_used: z49.number().optional(),
      num_server_side_tools_used: z49.number().optional()
    });
    xaiResponsesResponseSchema = z49.object({
      id: z49.string().nullish(),
      created_at: z49.number().nullish(),
      model: z49.string().nullish(),
      object: z49.literal("response"),
      output: z49.array(outputItemSchema),
      usage: xaiResponsesUsageSchema.nullish(),
      status: z49.string()
    });
    xaiResponsesChunkSchema = z49.union([
      z49.object({
        type: z49.literal("response.created"),
        response: xaiResponsesResponseSchema.partial({ usage: true, status: true })
      }),
      z49.object({
        type: z49.literal("response.in_progress"),
        response: xaiResponsesResponseSchema.partial({ usage: true, status: true })
      }),
      z49.object({
        type: z49.literal("response.output_item.added"),
        item: outputItemSchema,
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.output_item.done"),
        item: outputItemSchema,
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.content_part.added"),
        item_id: z49.string(),
        output_index: z49.number(),
        content_index: z49.number(),
        part: messageContentPartSchema
      }),
      z49.object({
        type: z49.literal("response.content_part.done"),
        item_id: z49.string(),
        output_index: z49.number(),
        content_index: z49.number(),
        part: messageContentPartSchema
      }),
      z49.object({
        type: z49.literal("response.output_text.delta"),
        item_id: z49.string(),
        output_index: z49.number(),
        content_index: z49.number(),
        delta: z49.string(),
        logprobs: z49.array(z49.any()).optional()
      }),
      z49.object({
        type: z49.literal("response.output_text.done"),
        item_id: z49.string(),
        output_index: z49.number(),
        content_index: z49.number(),
        text: z49.string(),
        logprobs: z49.array(z49.any()).optional(),
        annotations: z49.array(annotationSchema).optional()
      }),
      z49.object({
        type: z49.literal("response.output_text.annotation.added"),
        item_id: z49.string(),
        output_index: z49.number(),
        content_index: z49.number(),
        annotation_index: z49.number(),
        annotation: annotationSchema
      }),
      z49.object({
        type: z49.literal("response.reasoning_summary_part.added"),
        item_id: z49.string(),
        output_index: z49.number(),
        summary_index: z49.number(),
        part: reasoningSummaryPartSchema
      }),
      z49.object({
        type: z49.literal("response.reasoning_summary_part.done"),
        item_id: z49.string(),
        output_index: z49.number(),
        summary_index: z49.number(),
        part: reasoningSummaryPartSchema
      }),
      z49.object({
        type: z49.literal("response.reasoning_summary_text.delta"),
        item_id: z49.string(),
        output_index: z49.number(),
        summary_index: z49.number(),
        delta: z49.string()
      }),
      z49.object({
        type: z49.literal("response.reasoning_summary_text.done"),
        item_id: z49.string(),
        output_index: z49.number(),
        summary_index: z49.number(),
        text: z49.string()
      }),
      z49.object({
        type: z49.literal("response.web_search_call.in_progress"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.web_search_call.searching"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.web_search_call.completed"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.x_search_call.in_progress"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.x_search_call.searching"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.x_search_call.completed"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.file_search_call.in_progress"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.file_search_call.searching"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.file_search_call.completed"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.code_execution_call.in_progress"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.code_execution_call.executing"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.code_execution_call.completed"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.code_interpreter_call.in_progress"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.code_interpreter_call.executing"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.code_interpreter_call.interpreting"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.code_interpreter_call.completed"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      // Code interpreter code streaming events
      z49.object({
        type: z49.literal("response.code_interpreter_call_code.delta"),
        item_id: z49.string(),
        output_index: z49.number(),
        delta: z49.string()
      }),
      z49.object({
        type: z49.literal("response.code_interpreter_call_code.done"),
        item_id: z49.string(),
        output_index: z49.number(),
        code: z49.string()
      }),
      z49.object({
        type: z49.literal("response.custom_tool_call_input.delta"),
        item_id: z49.string(),
        output_index: z49.number(),
        delta: z49.string()
      }),
      z49.object({
        type: z49.literal("response.custom_tool_call_input.done"),
        item_id: z49.string(),
        output_index: z49.number(),
        input: z49.string()
      }),
      z49.object({
        type: z49.literal("response.mcp_call.in_progress"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.mcp_call.executing"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.mcp_call.completed"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.mcp_call.failed"),
        item_id: z49.string(),
        output_index: z49.number()
      }),
      z49.object({
        type: z49.literal("response.mcp_call_arguments.delta"),
        item_id: z49.string(),
        output_index: z49.number(),
        delta: z49.string()
      }),
      z49.object({
        type: z49.literal("response.mcp_call_arguments.done"),
        item_id: z49.string(),
        output_index: z49.number(),
        arguments: z49.string().optional()
      }),
      z49.object({
        type: z49.literal("response.mcp_call_output.delta"),
        item_id: z49.string(),
        output_index: z49.number(),
        delta: z49.string()
      }),
      z49.object({
        type: z49.literal("response.mcp_call_output.done"),
        item_id: z49.string(),
        output_index: z49.number(),
        output: z49.string().optional()
      }),
      z49.object({
        type: z49.literal("response.done"),
        response: xaiResponsesResponseSchema
      }),
      z49.object({
        type: z49.literal("response.completed"),
        response: xaiResponsesResponseSchema
      })
    ]);
    xaiResponsesProviderOptions = z58.object({
      /**
       * Constrains how hard a reasoning model thinks before responding.
       * Possible values are `low` (uses fewer reasoning tokens), `medium` and `high` (uses more reasoning tokens).
       */
      reasoningEffort: z58.enum(["low", "medium", "high"]).optional(),
      /**
       * Whether to store the input message(s) and model response for later retrieval.
       * @default true
       */
      store: z58.boolean().optional(),
      /**
       * The ID of the previous response from the model.
       */
      previousResponseId: z58.string().optional(),
      /**
       * Specify additional output data to include in the model response.
       * Example values: 'file_search_call.results'.
       */
      include: z58.array(z58.enum(["file_search_call.results"])).nullish()
    });
    fileSearchArgsSchema3 = lazySchema(
      () => zodSchema(
        z68.object({
          vectorStoreIds: z68.array(z68.string()),
          maxNumResults: z68.number().optional()
        })
      )
    );
    fileSearchOutputSchema2 = lazySchema(
      () => zodSchema(
        z68.object({
          queries: z68.array(z68.string()),
          results: z68.array(
            z68.object({
              fileId: z68.string(),
              filename: z68.string(),
              score: z68.number().min(0).max(1),
              text: z68.string()
            })
          ).nullable()
        })
      )
    );
    fileSearchToolFactory = createProviderToolFactoryWithOutputSchema({
      id: "xai.file_search",
      inputSchema: lazySchema(() => zodSchema(z68.object({}))),
      outputSchema: fileSearchOutputSchema2
    });
    fileSearch3 = (args2) => fileSearchToolFactory(args2);
    mcpServerArgsSchema = lazySchema(
      () => zodSchema(
        z78.object({
          serverUrl: z78.string().describe("The URL of the MCP server"),
          serverLabel: z78.string().optional().describe("A label for the MCP server"),
          serverDescription: z78.string().optional().describe("Description of the MCP server"),
          allowedTools: z78.array(z78.string()).optional().describe("List of allowed tool names"),
          headers: z78.record(z78.string(), z78.string()).optional().describe("Custom headers to send"),
          authorization: z78.string().optional().describe("Authorization header value")
        })
      )
    );
    mcpServerOutputSchema = lazySchema(
      () => zodSchema(
        z78.object({
          name: z78.string(),
          arguments: z78.string(),
          result: z78.unknown()
        })
      )
    );
    mcpServerToolFactory = createProviderToolFactoryWithOutputSchema({
      id: "xai.mcp",
      inputSchema: lazySchema(() => zodSchema(z78.object({}))),
      outputSchema: mcpServerOutputSchema
    });
    mcpServer = (args2) => mcpServerToolFactory(args2);
    webSearchArgsSchema2 = lazySchema(
      () => zodSchema(
        z88.object({
          allowedDomains: z88.array(z88.string()).max(5).optional(),
          excludedDomains: z88.array(z88.string()).max(5).optional(),
          enableImageUnderstanding: z88.boolean().optional()
        })
      )
    );
    webSearchOutputSchema2 = lazySchema(
      () => zodSchema(
        z88.object({
          query: z88.string(),
          sources: z88.array(
            z88.object({
              title: z88.string(),
              url: z88.string(),
              snippet: z88.string()
            })
          )
        })
      )
    );
    webSearchToolFactory2 = createProviderToolFactoryWithOutputSchema({
      id: "xai.web_search",
      inputSchema: lazySchema(() => zodSchema(z88.object({}))),
      outputSchema: webSearchOutputSchema2
    });
    webSearch2 = (args2 = {}) => webSearchToolFactory2(args2);
    xSearchArgsSchema = lazySchema(
      () => zodSchema(
        z96.object({
          allowedXHandles: z96.array(z96.string()).max(10).optional(),
          excludedXHandles: z96.array(z96.string()).max(10).optional(),
          fromDate: z96.string().optional(),
          toDate: z96.string().optional(),
          enableImageUnderstanding: z96.boolean().optional(),
          enableVideoUnderstanding: z96.boolean().optional()
        })
      )
    );
    xSearchOutputSchema = lazySchema(
      () => zodSchema(
        z96.object({
          query: z96.string(),
          posts: z96.array(
            z96.object({
              author: z96.string(),
              text: z96.string(),
              url: z96.string(),
              likes: z96.number()
            })
          )
        })
      )
    );
    xSearchToolFactory = createProviderToolFactoryWithOutputSchema({
      id: "xai.x_search",
      inputSchema: lazySchema(() => zodSchema(z96.object({}))),
      outputSchema: xSearchOutputSchema
    });
    xSearch = (args2 = {}) => xSearchToolFactory(args2);
    XaiResponsesLanguageModel = class {
      constructor(modelId, config2) {
        this.specificationVersion = "v3";
        this.supportedUrls = {
          "image/*": [/^https?:\/\/.*$/]
        };
        this.modelId = modelId;
        this.config = config2;
      }
      get provider() {
        return this.config.provider;
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        stopSequences,
        seed,
        responseFormat,
        providerOptions,
        tools,
        toolChoice
      }) {
        var _a25, _b18, _c, _d, _e, _f, _g;
        const warnings = [];
        const options = (_a25 = await parseProviderOptions({
          provider: "xai",
          providerOptions,
          schema: xaiResponsesProviderOptions
        })) != null ? _a25 : {};
        if (stopSequences != null) {
          warnings.push({ type: "unsupported", feature: "stopSequences" });
        }
        const webSearchToolName = (_b18 = tools == null ? void 0 : tools.find(
          (tool2) => tool2.type === "provider" && tool2.id === "xai.web_search"
        )) == null ? void 0 : _b18.name;
        const xSearchToolName = (_c = tools == null ? void 0 : tools.find(
          (tool2) => tool2.type === "provider" && tool2.id === "xai.x_search"
        )) == null ? void 0 : _c.name;
        const codeExecutionToolName = (_d = tools == null ? void 0 : tools.find(
          (tool2) => tool2.type === "provider" && tool2.id === "xai.code_execution"
        )) == null ? void 0 : _d.name;
        const mcpToolName = (_e = tools == null ? void 0 : tools.find(
          (tool2) => tool2.type === "provider" && tool2.id === "xai.mcp"
        )) == null ? void 0 : _e.name;
        const fileSearchToolName = (_f = tools == null ? void 0 : tools.find(
          (tool2) => tool2.type === "provider" && tool2.id === "xai.file_search"
        )) == null ? void 0 : _f.name;
        const { input, inputWarnings } = await convertToXaiResponsesInput({
          prompt,
          store: true
        });
        warnings.push(...inputWarnings);
        const {
          tools: xaiTools2,
          toolChoice: xaiToolChoice,
          toolWarnings
        } = await prepareResponsesTools2({
          tools,
          toolChoice
        });
        warnings.push(...toolWarnings);
        let include = options.include ? [...options.include] : void 0;
        if (options.store === false) {
          if (include == null) {
            include = ["reasoning.encrypted_content"];
          } else {
            include = [...include, "reasoning.encrypted_content"];
          }
        }
        const baseArgs = {
          model: this.modelId,
          input,
          max_output_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          seed,
          ...(responseFormat == null ? void 0 : responseFormat.type) === "json" && {
            text: {
              format: responseFormat.schema != null ? {
                type: "json_schema",
                strict: true,
                name: (_g = responseFormat.name) != null ? _g : "response",
                description: responseFormat.description,
                schema: responseFormat.schema
              } : { type: "json_object" }
            }
          },
          ...options.reasoningEffort != null && {
            reasoning: { effort: options.reasoningEffort }
          },
          ...options.store === false && {
            store: options.store
          },
          ...include != null && {
            include
          },
          ...options.previousResponseId != null && {
            previous_response_id: options.previousResponseId
          }
        };
        if (xaiTools2 && xaiTools2.length > 0) {
          baseArgs.tools = xaiTools2;
        }
        if (xaiToolChoice != null) {
          baseArgs.tool_choice = xaiToolChoice;
        }
        return {
          args: baseArgs,
          warnings,
          webSearchToolName,
          xSearchToolName,
          codeExecutionToolName,
          mcpToolName,
          fileSearchToolName
        };
      }
      async doGenerate(options) {
        var _a25, _b18, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
        const {
          args: body,
          warnings,
          webSearchToolName,
          xSearchToolName,
          codeExecutionToolName,
          mcpToolName,
          fileSearchToolName
        } = await this.getArgs(options);
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi({
          url: `${(_a25 = this.config.baseURL) != null ? _a25 : "https://api.x.ai/v1"}/responses`,
          headers: combineHeaders(this.config.headers(), options.headers),
          body,
          failedResponseHandler: xaiFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            xaiResponsesResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const content = [];
        const webSearchSubTools = [
          "web_search",
          "web_search_with_snippets",
          "browse_page"
        ];
        const xSearchSubTools = [
          "x_user_search",
          "x_keyword_search",
          "x_semantic_search",
          "x_thread_fetch"
        ];
        for (const part of response.output) {
          if (part.type === "file_search_call") {
            const toolName = fileSearchToolName != null ? fileSearchToolName : "file_search";
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName,
              input: "",
              providerExecuted: true
            });
            content.push({
              type: "tool-result",
              toolCallId: part.id,
              toolName,
              result: {
                queries: (_b18 = part.queries) != null ? _b18 : [],
                results: (_d = (_c = part.results) == null ? void 0 : _c.map((result) => ({
                  fileId: result.file_id,
                  filename: result.filename,
                  score: result.score,
                  text: result.text
                }))) != null ? _d : null
              }
            });
            continue;
          }
          if (part.type === "web_search_call" || part.type === "x_search_call" || part.type === "code_interpreter_call" || part.type === "code_execution_call" || part.type === "view_image_call" || part.type === "view_x_video_call" || part.type === "custom_tool_call" || part.type === "mcp_call") {
            let toolName = (_e = part.name) != null ? _e : "";
            if (webSearchSubTools.includes((_f = part.name) != null ? _f : "") || part.type === "web_search_call") {
              toolName = webSearchToolName != null ? webSearchToolName : "web_search";
            } else if (xSearchSubTools.includes((_g = part.name) != null ? _g : "") || part.type === "x_search_call") {
              toolName = xSearchToolName != null ? xSearchToolName : "x_search";
            } else if (part.name === "code_execution" || part.type === "code_interpreter_call" || part.type === "code_execution_call") {
              toolName = codeExecutionToolName != null ? codeExecutionToolName : "code_execution";
            } else if (part.type === "mcp_call") {
              toolName = (_h = mcpToolName != null ? mcpToolName : part.name) != null ? _h : "mcp";
            }
            const toolInput = part.type === "custom_tool_call" ? (_i = part.input) != null ? _i : "" : part.type === "mcp_call" ? (_j = part.arguments) != null ? _j : "" : (_k = part.arguments) != null ? _k : "";
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName,
              input: toolInput,
              providerExecuted: true
            });
            continue;
          }
          switch (part.type) {
            case "message": {
              for (const contentPart of part.content) {
                if (contentPart.text) {
                  content.push({
                    type: "text",
                    text: contentPart.text
                  });
                }
                if (contentPart.annotations) {
                  for (const annotation of contentPart.annotations) {
                    if (annotation.type === "url_citation" && "url" in annotation) {
                      content.push({
                        type: "source",
                        sourceType: "url",
                        id: this.config.generateId(),
                        url: annotation.url,
                        title: (_l = annotation.title) != null ? _l : annotation.url
                      });
                    }
                  }
                }
              }
              break;
            }
            case "function_call": {
              content.push({
                type: "tool-call",
                toolCallId: part.call_id,
                toolName: part.name,
                input: part.arguments
              });
              break;
            }
            case "reasoning": {
              const summaryTexts = part.summary.map((s) => s.text).filter((text2) => text2 && text2.length > 0);
              if (summaryTexts.length > 0) {
                const reasoningText = summaryTexts.join("");
                if (part.encrypted_content || part.id) {
                  content.push({
                    type: "reasoning",
                    text: reasoningText,
                    providerMetadata: {
                      xai: {
                        ...part.encrypted_content && {
                          reasoningEncryptedContent: part.encrypted_content
                        },
                        ...part.id && { itemId: part.id }
                      }
                    }
                  });
                } else {
                  content.push({
                    type: "reasoning",
                    text: reasoningText
                  });
                }
              }
              break;
            }
            default: {
              break;
            }
          }
        }
        return {
          content,
          finishReason: {
            unified: mapXaiResponsesFinishReason(response.status),
            raw: (_m = response.status) != null ? _m : void 0
          },
          usage: response.usage ? convertXaiResponsesUsage(response.usage) : {
            inputTokens: { total: 0, noCache: 0, cacheRead: 0, cacheWrite: 0 },
            outputTokens: { total: 0, text: 0, reasoning: 0 }
          },
          request: { body },
          response: {
            ...getResponseMetadata4(response),
            headers: responseHeaders,
            body: rawResponse
          },
          warnings
        };
      }
      async doStream(options) {
        var _a25;
        const {
          args: args2,
          warnings,
          webSearchToolName,
          xSearchToolName,
          codeExecutionToolName,
          mcpToolName,
          fileSearchToolName
        } = await this.getArgs(options);
        const body = {
          ...args2,
          stream: true
        };
        const { responseHeaders, value: response } = await postJsonToApi({
          url: `${(_a25 = this.config.baseURL) != null ? _a25 : "https://api.x.ai/v1"}/responses`,
          headers: combineHeaders(this.config.headers(), options.headers),
          body,
          failedResponseHandler: xaiFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler(
            xaiResponsesChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        let finishReason = {
          unified: "other",
          raw: void 0
        };
        let usage = void 0;
        let isFirstChunk = true;
        const contentBlocks = {};
        const seenToolCalls = /* @__PURE__ */ new Set();
        const activeReasoning = {};
        const self = this;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                var _a26, _b18, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const event = chunk.value;
                if (event.type === "response.created" || event.type === "response.in_progress") {
                  if (isFirstChunk) {
                    controller.enqueue({
                      type: "response-metadata",
                      ...getResponseMetadata4(event.response)
                    });
                    isFirstChunk = false;
                  }
                  return;
                }
                if (event.type === "response.reasoning_summary_part.added") {
                  const blockId = `reasoning-${event.item_id}`;
                  activeReasoning[event.item_id] = {};
                  controller.enqueue({
                    type: "reasoning-start",
                    id: blockId,
                    providerMetadata: {
                      xai: {
                        itemId: event.item_id
                      }
                    }
                  });
                }
                if (event.type === "response.reasoning_summary_text.delta") {
                  const blockId = `reasoning-${event.item_id}`;
                  controller.enqueue({
                    type: "reasoning-delta",
                    id: blockId,
                    delta: event.delta,
                    providerMetadata: {
                      xai: {
                        itemId: event.item_id
                      }
                    }
                  });
                  return;
                }
                if (event.type === "response.reasoning_summary_text.done") {
                  return;
                }
                if (event.type === "response.output_text.delta") {
                  const blockId = `text-${event.item_id}`;
                  if (contentBlocks[blockId] == null) {
                    contentBlocks[blockId] = { type: "text" };
                    controller.enqueue({
                      type: "text-start",
                      id: blockId
                    });
                  }
                  controller.enqueue({
                    type: "text-delta",
                    id: blockId,
                    delta: event.delta
                  });
                  return;
                }
                if (event.type === "response.output_text.done") {
                  if (event.annotations) {
                    for (const annotation of event.annotations) {
                      if (annotation.type === "url_citation" && "url" in annotation) {
                        controller.enqueue({
                          type: "source",
                          sourceType: "url",
                          id: self.config.generateId(),
                          url: annotation.url,
                          title: (_a26 = annotation.title) != null ? _a26 : annotation.url
                        });
                      }
                    }
                  }
                  return;
                }
                if (event.type === "response.output_text.annotation.added") {
                  const annotation = event.annotation;
                  if (annotation.type === "url_citation" && "url" in annotation) {
                    controller.enqueue({
                      type: "source",
                      sourceType: "url",
                      id: self.config.generateId(),
                      url: annotation.url,
                      title: (_b18 = annotation.title) != null ? _b18 : annotation.url
                    });
                  }
                  return;
                }
                if (event.type === "response.done" || event.type === "response.completed") {
                  const response2 = event.response;
                  if (response2.usage) {
                    usage = convertXaiResponsesUsage(response2.usage);
                  }
                  if (response2.status) {
                    finishReason = {
                      unified: mapXaiResponsesFinishReason(response2.status),
                      raw: response2.status
                    };
                  }
                  return;
                }
                if (event.type === "response.custom_tool_call_input.delta" || event.type === "response.custom_tool_call_input.done") {
                  return;
                }
                if (event.type === "response.output_item.added" || event.type === "response.output_item.done") {
                  const part = event.item;
                  if (part.type === "reasoning") {
                    if (event.type === "response.output_item.done") {
                      const blockId = `reasoning-${part.id}`;
                      if (!(part.id in activeReasoning)) {
                        activeReasoning[part.id] = {};
                        controller.enqueue({
                          type: "reasoning-start",
                          id: blockId,
                          providerMetadata: {
                            xai: {
                              ...part.id && { itemId: part.id }
                            }
                          }
                        });
                      }
                      controller.enqueue({
                        type: "reasoning-end",
                        id: blockId,
                        providerMetadata: {
                          xai: {
                            ...part.encrypted_content && {
                              reasoningEncryptedContent: part.encrypted_content
                            },
                            ...part.id && { itemId: part.id }
                          }
                        }
                      });
                      delete activeReasoning[part.id];
                    }
                    return;
                  }
                  if (part.type === "file_search_call") {
                    const toolName = fileSearchToolName != null ? fileSearchToolName : "file_search";
                    if (!seenToolCalls.has(part.id)) {
                      seenToolCalls.add(part.id);
                      controller.enqueue({
                        type: "tool-input-start",
                        id: part.id,
                        toolName
                      });
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: part.id,
                        delta: ""
                      });
                      controller.enqueue({
                        type: "tool-input-end",
                        id: part.id
                      });
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: part.id,
                        toolName,
                        input: "",
                        providerExecuted: true
                      });
                    }
                    if (event.type === "response.output_item.done") {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.id,
                        toolName,
                        result: {
                          queries: (_c = part.queries) != null ? _c : [],
                          results: (_e = (_d = part.results) == null ? void 0 : _d.map((result) => ({
                            fileId: result.file_id,
                            filename: result.filename,
                            score: result.score,
                            text: result.text
                          }))) != null ? _e : null
                        }
                      });
                    }
                    return;
                  }
                  if (part.type === "web_search_call" || part.type === "x_search_call" || part.type === "code_interpreter_call" || part.type === "code_execution_call" || part.type === "view_image_call" || part.type === "view_x_video_call" || part.type === "custom_tool_call" || part.type === "mcp_call") {
                    const webSearchSubTools = [
                      "web_search",
                      "web_search_with_snippets",
                      "browse_page"
                    ];
                    const xSearchSubTools = [
                      "x_user_search",
                      "x_keyword_search",
                      "x_semantic_search",
                      "x_thread_fetch"
                    ];
                    let toolName = (_f = part.name) != null ? _f : "";
                    if (webSearchSubTools.includes((_g = part.name) != null ? _g : "") || part.type === "web_search_call") {
                      toolName = webSearchToolName != null ? webSearchToolName : "web_search";
                    } else if (xSearchSubTools.includes((_h = part.name) != null ? _h : "") || part.type === "x_search_call") {
                      toolName = xSearchToolName != null ? xSearchToolName : "x_search";
                    } else if (part.name === "code_execution" || part.type === "code_interpreter_call" || part.type === "code_execution_call") {
                      toolName = codeExecutionToolName != null ? codeExecutionToolName : "code_execution";
                    } else if (part.type === "mcp_call") {
                      toolName = (_i = mcpToolName != null ? mcpToolName : part.name) != null ? _i : "mcp";
                    }
                    const toolInput = part.type === "custom_tool_call" ? (_j = part.input) != null ? _j : "" : part.type === "mcp_call" ? (_k = part.arguments) != null ? _k : "" : (_l = part.arguments) != null ? _l : "";
                    const shouldEmit = part.type === "custom_tool_call" ? event.type === "response.output_item.done" : !seenToolCalls.has(part.id);
                    if (shouldEmit && !seenToolCalls.has(part.id)) {
                      seenToolCalls.add(part.id);
                      controller.enqueue({
                        type: "tool-input-start",
                        id: part.id,
                        toolName
                      });
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: part.id,
                        delta: toolInput
                      });
                      controller.enqueue({
                        type: "tool-input-end",
                        id: part.id
                      });
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: part.id,
                        toolName,
                        input: toolInput,
                        providerExecuted: true
                      });
                    }
                    return;
                  }
                  if (part.type === "message") {
                    for (const contentPart of part.content) {
                      if (contentPart.text && contentPart.text.length > 0) {
                        const blockId = `text-${part.id}`;
                        if (contentBlocks[blockId] == null) {
                          contentBlocks[blockId] = { type: "text" };
                          controller.enqueue({
                            type: "text-start",
                            id: blockId
                          });
                          controller.enqueue({
                            type: "text-delta",
                            id: blockId,
                            delta: contentPart.text
                          });
                        }
                      }
                      if (contentPart.annotations) {
                        for (const annotation of contentPart.annotations) {
                          if (annotation.type === "url_citation" && "url" in annotation) {
                            controller.enqueue({
                              type: "source",
                              sourceType: "url",
                              id: self.config.generateId(),
                              url: annotation.url,
                              title: (_m = annotation.title) != null ? _m : annotation.url
                            });
                          }
                        }
                      }
                    }
                  } else if (part.type === "function_call") {
                    if (!seenToolCalls.has(part.call_id)) {
                      seenToolCalls.add(part.call_id);
                      controller.enqueue({
                        type: "tool-input-start",
                        id: part.call_id,
                        toolName: part.name
                      });
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: part.call_id,
                        delta: part.arguments
                      });
                      controller.enqueue({
                        type: "tool-input-end",
                        id: part.call_id
                      });
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: part.call_id,
                        toolName: part.name,
                        input: part.arguments
                      });
                    }
                  }
                }
              },
              flush(controller) {
                for (const [blockId, block] of Object.entries(contentBlocks)) {
                  if (block.type === "text") {
                    controller.enqueue({
                      type: "text-end",
                      id: blockId
                    });
                  }
                }
                controller.enqueue({ type: "finish", finishReason, usage });
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    codeExecutionOutputSchema = z106.object({
      output: z106.string().describe("the output of the code execution"),
      error: z106.string().optional().describe("any error that occurred")
    });
    codeExecutionToolFactory = createProviderToolFactoryWithOutputSchema({
      id: "xai.code_execution",
      inputSchema: z106.object({}).describe("no input parameters"),
      outputSchema: codeExecutionOutputSchema
    });
    codeExecution2 = (args2 = {}) => codeExecutionToolFactory(args2);
    viewImageOutputSchema = z115.object({
      description: z115.string().describe("description of the image"),
      objects: z115.array(z115.string()).optional().describe("objects detected in the image")
    });
    viewImageToolFactory = createProviderToolFactoryWithOutputSchema({
      id: "xai.view_image",
      inputSchema: z115.object({}).describe("no input parameters"),
      outputSchema: viewImageOutputSchema
    });
    viewImage = (args2 = {}) => viewImageToolFactory(args2);
    viewXVideoOutputSchema = z125.object({
      transcript: z125.string().optional().describe("transcript of the video"),
      description: z125.string().describe("description of the video content"),
      duration: z125.number().optional().describe("duration in seconds")
    });
    viewXVideoToolFactory = createProviderToolFactoryWithOutputSchema({
      id: "xai.view_x_video",
      inputSchema: z125.object({}).describe("no input parameters"),
      outputSchema: viewXVideoOutputSchema
    });
    viewXVideo = (args2 = {}) => viewXVideoToolFactory(args2);
    xaiTools = {
      codeExecution: codeExecution2,
      fileSearch: fileSearch3,
      mcpServer,
      viewImage,
      viewXVideo,
      webSearch: webSearch2,
      xSearch
    };
    VERSION9 = true ? "3.0.47" : "0.0.0-test";
    xaiErrorStructure = {
      errorSchema: xaiErrorDataSchema,
      errorToMessage: (data) => data.error.message
    };
    xai = createXai();
  }
});

// node_modules/@ai-sdk/deepseek/dist/index.mjs
var dist_exports8 = {};
__export(dist_exports8, {
  VERSION: () => VERSION10,
  createDeepSeek: () => createDeepSeek,
  deepseek: () => deepseek
});
import { z as z31 } from "zod/v4";
import { z as z211 } from "zod/v4";
function convertToDeepSeekChatMessages({
  prompt,
  responseFormat
}) {
  var _a25;
  const messages = [];
  const warnings = [];
  if ((responseFormat == null ? void 0 : responseFormat.type) === "json") {
    if (responseFormat.schema == null) {
      messages.push({
        role: "system",
        content: "Return JSON."
      });
    } else {
      messages.push({
        role: "system",
        content: "Return JSON that conforms to the following schema: " + JSON.stringify(responseFormat.schema)
      });
      warnings.push({
        type: "compatibility",
        feature: "responseFormat JSON schema",
        details: "JSON response schema is injected into the system message."
      });
    }
  }
  let lastUserMessageIndex = -1;
  for (let i = prompt.length - 1; i >= 0; i--) {
    if (prompt[i].role === "user") {
      lastUserMessageIndex = i;
      break;
    }
  }
  let index = -1;
  for (const { role, content } of prompt) {
    index++;
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user": {
        let userContent = "";
        for (const part of content) {
          if (part.type === "text") {
            userContent += part.text;
          } else {
            warnings.push({
              type: "unsupported",
              feature: `user message part type: ${part.type}`
            });
          }
        }
        messages.push({
          role: "user",
          content: userContent
        });
        break;
      }
      case "assistant": {
        let text2 = "";
        let reasoning;
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text2 += part.text;
              break;
            }
            case "reasoning": {
              if (index <= lastUserMessageIndex) {
                break;
              }
              if (reasoning == null) {
                reasoning = part.text;
              } else {
                reasoning += part.text;
              }
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text2,
          reasoning_content: reasoning,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          if (toolResponse.type === "tool-approval-response") {
            continue;
          }
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "execution-denied":
              contentValue = (_a25 = output.reason) != null ? _a25 : "Tool execution denied.";
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        warnings.push({
          type: "unsupported",
          feature: `message role: ${role}`
        });
        break;
      }
    }
  }
  return { messages, warnings };
}
function convertDeepSeekUsage(usage) {
  var _a25, _b18, _c, _d, _e;
  if (usage == null) {
    return {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
  }
  const promptTokens = (_a25 = usage.prompt_tokens) != null ? _a25 : 0;
  const completionTokens = (_b18 = usage.completion_tokens) != null ? _b18 : 0;
  const cacheReadTokens = (_c = usage.prompt_cache_hit_tokens) != null ? _c : 0;
  const reasoningTokens = (_e = (_d = usage.completion_tokens_details) == null ? void 0 : _d.reasoning_tokens) != null ? _e : 0;
  return {
    inputTokens: {
      total: promptTokens,
      noCache: promptTokens - cacheReadTokens,
      cacheRead: cacheReadTokens,
      cacheWrite: void 0
    },
    outputTokens: {
      total: completionTokens,
      text: completionTokens - reasoningTokens,
      reasoning: reasoningTokens
    },
    raw: usage
  };
}
function prepareTools5({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const deepseekTools = [];
  for (const tool2 of tools) {
    if (tool2.type === "provider") {
      toolWarnings.push({
        type: "unsupported",
        feature: `provider-defined tool ${tool2.id}`
      });
    } else {
      deepseekTools.push({
        type: "function",
        function: {
          name: tool2.name,
          description: tool2.description,
          parameters: tool2.inputSchema,
          ...tool2.strict != null ? { strict: tool2.strict } : {}
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: deepseekTools, toolChoice: void 0, toolWarnings };
  }
  const type2 = toolChoice == null ? void 0 : toolChoice.type;
  switch (type2) {
    case "auto":
    case "none":
    case "required":
      return { tools: deepseekTools, toolChoice: type2, toolWarnings };
    case "tool":
      return {
        tools: deepseekTools,
        toolChoice: {
          type: "function",
          function: { name: toolChoice.toolName }
        },
        toolWarnings
      };
    default: {
      return {
        tools: deepseekTools,
        toolChoice: void 0,
        toolWarnings: [
          ...toolWarnings,
          {
            type: "unsupported",
            feature: `tool choice type: ${type2}`
          }
        ]
      };
    }
  }
}
function getResponseMetadata5({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapDeepSeekFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "tool_calls":
      return "tool-calls";
    case "insufficient_system_resource":
      return "error";
    default:
      return "other";
  }
}
function createDeepSeek(options = {}) {
  var _a25;
  const baseURL = withoutTrailingSlash(
    (_a25 = options.baseURL) != null ? _a25 : "https://api.deepseek.com"
  );
  const getHeaders = () => withUserAgentSuffix(
    {
      Authorization: `Bearer ${loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "DEEPSEEK_API_KEY",
        description: "DeepSeek API key"
      })}`,
      ...options.headers
    },
    `ai-sdk/deepseek/${VERSION10}`
  );
  const createLanguageModel = (modelId) => {
    return new DeepSeekChatLanguageModel(modelId, {
      provider: `deepseek.chat`,
      url: ({ path: path24 }) => `${baseURL}${path24}`,
      headers: getHeaders,
      fetch: options.fetch
    });
  };
  const provider = (modelId) => createLanguageModel(modelId);
  provider.specificationVersion = "v3";
  provider.languageModel = createLanguageModel;
  provider.chat = createLanguageModel;
  provider.embeddingModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "embeddingModel" });
  };
  provider.textEmbeddingModel = provider.embeddingModel;
  provider.imageModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  return provider;
}
var tokenUsageSchema, deepSeekErrorSchema, deepseekChatResponseSchema, deepseekChatChunkSchema, deepseekChatOptions, DeepSeekChatLanguageModel, VERSION10, deepseek;
var init_dist16 = __esm({
  "node_modules/@ai-sdk/deepseek/dist/index.mjs"() {
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    tokenUsageSchema = z31.object({
      prompt_tokens: z31.number().nullish(),
      completion_tokens: z31.number().nullish(),
      prompt_cache_hit_tokens: z31.number().nullish(),
      prompt_cache_miss_tokens: z31.number().nullish(),
      total_tokens: z31.number().nullish(),
      completion_tokens_details: z31.object({
        reasoning_tokens: z31.number().nullish()
      }).nullish()
    }).nullish();
    deepSeekErrorSchema = z31.object({
      error: z31.object({
        message: z31.string(),
        type: z31.string().nullish(),
        param: z31.any().nullish(),
        code: z31.union([z31.string(), z31.number()]).nullish()
      })
    });
    deepseekChatResponseSchema = z31.object({
      id: z31.string().nullish(),
      created: z31.number().nullish(),
      model: z31.string().nullish(),
      choices: z31.array(
        z31.object({
          message: z31.object({
            role: z31.literal("assistant").nullish(),
            content: z31.string().nullish(),
            reasoning_content: z31.string().nullish(),
            tool_calls: z31.array(
              z31.object({
                id: z31.string().nullish(),
                function: z31.object({
                  name: z31.string(),
                  arguments: z31.string()
                })
              })
            ).nullish()
          }),
          finish_reason: z31.string().nullish()
        })
      ),
      usage: tokenUsageSchema
    });
    deepseekChatChunkSchema = lazySchema(
      () => zodSchema(
        z31.union([
          z31.object({
            id: z31.string().nullish(),
            created: z31.number().nullish(),
            model: z31.string().nullish(),
            choices: z31.array(
              z31.object({
                delta: z31.object({
                  role: z31.enum(["assistant"]).nullish(),
                  content: z31.string().nullish(),
                  reasoning_content: z31.string().nullish(),
                  tool_calls: z31.array(
                    z31.object({
                      index: z31.number(),
                      id: z31.string().nullish(),
                      function: z31.object({
                        name: z31.string().nullish(),
                        arguments: z31.string().nullish()
                      })
                    })
                  ).nullish()
                }).nullish(),
                finish_reason: z31.string().nullish()
              })
            ),
            usage: tokenUsageSchema
          }),
          deepSeekErrorSchema
        ])
      )
    );
    deepseekChatOptions = z211.object({
      /**
       * Type of thinking to use. Defaults to `enabled`.
       */
      thinking: z211.object({
        type: z211.enum(["enabled", "disabled"]).optional()
      }).optional()
    });
    DeepSeekChatLanguageModel = class {
      constructor(modelId, config2) {
        this.specificationVersion = "v3";
        this.supportedUrls = {};
        this.modelId = modelId;
        this.config = config2;
        this.failedResponseHandler = createJsonErrorResponseHandler({
          errorSchema: deepSeekErrorSchema,
          errorToMessage: (error) => error.error.message
        });
      }
      get provider() {
        return this.config.provider;
      }
      get providerOptionsName() {
        return this.config.provider.split(".")[0].trim();
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        providerOptions,
        stopSequences,
        responseFormat,
        seed,
        toolChoice,
        tools
      }) {
        var _a25, _b18;
        const deepseekOptions = (_a25 = await parseProviderOptions({
          provider: this.providerOptionsName,
          providerOptions,
          schema: deepseekChatOptions
        })) != null ? _a25 : {};
        const { messages, warnings } = convertToDeepSeekChatMessages({
          prompt,
          responseFormat
        });
        if (topK != null) {
          warnings.push({ type: "unsupported", feature: "topK" });
        }
        if (seed != null) {
          warnings.push({ type: "unsupported", feature: "seed" });
        }
        const {
          tools: deepseekTools,
          toolChoice: deepseekToolChoices,
          toolWarnings
        } = prepareTools5({
          tools,
          toolChoice
        });
        return {
          args: {
            model: this.modelId,
            max_tokens: maxOutputTokens,
            temperature,
            top_p: topP,
            frequency_penalty: frequencyPenalty,
            presence_penalty: presencePenalty,
            response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? { type: "json_object" } : void 0,
            stop: stopSequences,
            messages,
            tools: deepseekTools,
            tool_choice: deepseekToolChoices,
            thinking: ((_b18 = deepseekOptions.thinking) == null ? void 0 : _b18.type) != null ? { type: deepseekOptions.thinking.type } : void 0
          },
          warnings: [...warnings, ...toolWarnings]
        };
      }
      async doGenerate(options) {
        var _a25, _b18, _c, _d;
        const { args: args2, warnings } = await this.getArgs({ ...options });
        const {
          responseHeaders,
          value: responseBody,
          rawValue: rawResponse
        } = await postJsonToApi({
          url: this.config.url({
            path: "/chat/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body: args2,
          failedResponseHandler: this.failedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            deepseekChatResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const choice2 = responseBody.choices[0];
        const content = [];
        const reasoning = choice2.message.reasoning_content;
        if (reasoning != null && reasoning.length > 0) {
          content.push({
            type: "reasoning",
            text: reasoning
          });
        }
        if (choice2.message.tool_calls != null) {
          for (const toolCall of choice2.message.tool_calls) {
            content.push({
              type: "tool-call",
              toolCallId: (_a25 = toolCall.id) != null ? _a25 : generateId(),
              toolName: toolCall.function.name,
              input: toolCall.function.arguments
            });
          }
        }
        const text2 = choice2.message.content;
        if (text2 != null && text2.length > 0) {
          content.push({ type: "text", text: text2 });
        }
        return {
          content,
          finishReason: {
            unified: mapDeepSeekFinishReason(choice2.finish_reason),
            raw: (_b18 = choice2.finish_reason) != null ? _b18 : void 0
          },
          usage: convertDeepSeekUsage(responseBody.usage),
          providerMetadata: {
            [this.providerOptionsName]: {
              promptCacheHitTokens: (_c = responseBody.usage) == null ? void 0 : _c.prompt_cache_hit_tokens,
              promptCacheMissTokens: (_d = responseBody.usage) == null ? void 0 : _d.prompt_cache_miss_tokens
            }
          },
          request: { body: args2 },
          response: {
            ...getResponseMetadata5(responseBody),
            headers: responseHeaders,
            body: rawResponse
          },
          warnings
        };
      }
      async doStream(options) {
        const { args: args2, warnings } = await this.getArgs({ ...options });
        const body = {
          ...args2,
          stream: true,
          stream_options: { include_usage: true }
        };
        const { responseHeaders, value: response } = await postJsonToApi({
          url: this.config.url({
            path: "/chat/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body,
          failedResponseHandler: this.failedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler(
            deepseekChatChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const toolCalls = [];
        let finishReason = {
          unified: "other",
          raw: void 0
        };
        let usage = void 0;
        let isFirstChunk = true;
        const providerOptionsName = this.providerOptionsName;
        let isActiveReasoning = false;
        let isActiveText = false;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                var _a25, _b18, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  finishReason = { unified: "error", raw: void 0 };
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value2 = chunk.value;
                if ("error" in value2) {
                  finishReason = { unified: "error", raw: void 0 };
                  controller.enqueue({ type: "error", error: value2.error.message });
                  return;
                }
                if (isFirstChunk) {
                  isFirstChunk = false;
                  controller.enqueue({
                    type: "response-metadata",
                    ...getResponseMetadata5(value2)
                  });
                }
                if (value2.usage != null) {
                  usage = value2.usage;
                }
                const choice2 = value2.choices[0];
                if ((choice2 == null ? void 0 : choice2.finish_reason) != null) {
                  finishReason = {
                    unified: mapDeepSeekFinishReason(choice2.finish_reason),
                    raw: choice2.finish_reason
                  };
                }
                if ((choice2 == null ? void 0 : choice2.delta) == null) {
                  return;
                }
                const delta = choice2.delta;
                const reasoningContent = delta.reasoning_content;
                if (reasoningContent) {
                  if (!isActiveReasoning) {
                    controller.enqueue({
                      type: "reasoning-start",
                      id: "reasoning-0"
                    });
                    isActiveReasoning = true;
                  }
                  controller.enqueue({
                    type: "reasoning-delta",
                    id: "reasoning-0",
                    delta: reasoningContent
                  });
                }
                if (delta.content) {
                  if (!isActiveText) {
                    controller.enqueue({ type: "text-start", id: "txt-0" });
                    isActiveText = true;
                  }
                  if (isActiveReasoning) {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: "reasoning-0"
                    });
                    isActiveReasoning = false;
                  }
                  controller.enqueue({
                    type: "text-delta",
                    id: "txt-0",
                    delta: delta.content
                  });
                }
                if (delta.tool_calls != null) {
                  if (isActiveReasoning) {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: "reasoning-0"
                    });
                    isActiveReasoning = false;
                  }
                  for (const toolCallDelta of delta.tool_calls) {
                    const index = toolCallDelta.index;
                    if (toolCalls[index] == null) {
                      if (toolCallDelta.id == null) {
                        throw new InvalidResponseDataError({
                          data: toolCallDelta,
                          message: `Expected 'id' to be a string.`
                        });
                      }
                      if (((_a25 = toolCallDelta.function) == null ? void 0 : _a25.name) == null) {
                        throw new InvalidResponseDataError({
                          data: toolCallDelta,
                          message: `Expected 'function.name' to be a string.`
                        });
                      }
                      controller.enqueue({
                        type: "tool-input-start",
                        id: toolCallDelta.id,
                        toolName: toolCallDelta.function.name
                      });
                      toolCalls[index] = {
                        id: toolCallDelta.id,
                        type: "function",
                        function: {
                          name: toolCallDelta.function.name,
                          arguments: (_b18 = toolCallDelta.function.arguments) != null ? _b18 : ""
                        },
                        hasFinished: false
                      };
                      const toolCall2 = toolCalls[index];
                      if (((_c = toolCall2.function) == null ? void 0 : _c.name) != null && ((_d = toolCall2.function) == null ? void 0 : _d.arguments) != null) {
                        if (toolCall2.function.arguments.length > 0) {
                          controller.enqueue({
                            type: "tool-input-delta",
                            id: toolCall2.id,
                            delta: toolCall2.function.arguments
                          });
                        }
                        if (isParsableJson(toolCall2.function.arguments)) {
                          controller.enqueue({
                            type: "tool-input-end",
                            id: toolCall2.id
                          });
                          controller.enqueue({
                            type: "tool-call",
                            toolCallId: (_e = toolCall2.id) != null ? _e : generateId(),
                            toolName: toolCall2.function.name,
                            input: toolCall2.function.arguments
                          });
                          toolCall2.hasFinished = true;
                        }
                      }
                      continue;
                    }
                    const toolCall = toolCalls[index];
                    if (toolCall.hasFinished) {
                      continue;
                    }
                    if (((_f = toolCallDelta.function) == null ? void 0 : _f.arguments) != null) {
                      toolCall.function.arguments += (_h = (_g = toolCallDelta.function) == null ? void 0 : _g.arguments) != null ? _h : "";
                    }
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.id,
                      delta: (_i = toolCallDelta.function.arguments) != null ? _i : ""
                    });
                    if (((_j = toolCall.function) == null ? void 0 : _j.name) != null && ((_k = toolCall.function) == null ? void 0 : _k.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                      controller.enqueue({
                        type: "tool-input-end",
                        id: toolCall.id
                      });
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: (_l = toolCall.id) != null ? _l : generateId(),
                        toolName: toolCall.function.name,
                        input: toolCall.function.arguments
                      });
                      toolCall.hasFinished = true;
                    }
                  }
                }
              },
              flush(controller) {
                var _a25, _b18, _c;
                if (isActiveReasoning) {
                  controller.enqueue({ type: "reasoning-end", id: "reasoning-0" });
                }
                if (isActiveText) {
                  controller.enqueue({ type: "text-end", id: "txt-0" });
                }
                for (const toolCall of toolCalls.filter(
                  (toolCall2) => !toolCall2.hasFinished
                )) {
                  controller.enqueue({
                    type: "tool-input-end",
                    id: toolCall.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: (_a25 = toolCall.id) != null ? _a25 : generateId(),
                    toolName: toolCall.function.name,
                    input: toolCall.function.arguments
                  });
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage: convertDeepSeekUsage(usage),
                  providerMetadata: {
                    [providerOptionsName]: {
                      promptCacheHitTokens: (_b18 = usage == null ? void 0 : usage.prompt_cache_hit_tokens) != null ? _b18 : void 0,
                      promptCacheMissTokens: (_c = usage == null ? void 0 : usage.prompt_cache_miss_tokens) != null ? _c : void 0
                    }
                  }
                });
              }
            })
          ),
          request: { body },
          response: { headers: responseHeaders }
        };
      }
    };
    VERSION10 = true ? "2.0.17" : "0.0.0-test";
    deepseek = createDeepSeek();
  }
});

// node_modules/@openrouter/ai-sdk-provider/dist/index.mjs
var dist_exports9 = {};
__export(dist_exports9, {
  OpenRouter: () => OpenRouter,
  createOpenRouter: () => createOpenRouter,
  openrouter: () => openrouter
});
import * as z410 from "zod/v4";
import { ZodFirstPartyTypeKind as ZodFirstPartyTypeKind32 } from "zod/v3";
import { ZodFirstPartyTypeKind as ZodFirstPartyTypeKind4 } from "zod/v3";
import {
  ZodFirstPartyTypeKind as ZodFirstPartyTypeKind23
} from "zod/v3";
import { z as z39 } from "zod/v4";
import { z as z212 } from "zod/v4";
import { z as z310 } from "zod/v4";
import { z as z59 } from "zod/v4";
import { z as z79 } from "zod/v4";
import { z as z69 } from "zod/v4";
import { z as z89 } from "zod/v4";
import { z as z97 } from "zod/v4";
import { z as z107 } from "zod/v4";
function getErrorMessage3(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
function noop2(_arg) {
}
function createParser2(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop2, onError: onError2 = noop2, onRetry = noop2, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines2(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value2 = line.slice(fieldSeparatorIndex + offset);
      processField(field, value2, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value2, line) {
    switch (field) {
      case "event":
        eventType = value2;
        break;
      case "data":
        data = `${data}${value2}
`;
        break;
      case "id":
        id = value2.includes("\0") ? void 0 : value2;
        break;
      case "retry":
        /^\d+$/.test(value2) ? onRetry(parseInt(value2, 10)) : onError2(
          new ParseError2(`Invalid \`retry\` value: "${value2}"`, {
            type: "invalid-retry",
            value: value2,
            line
          })
        );
        break;
      default:
        onError2(
          new ParseError2(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value: value2, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines2(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
function combineHeaders2(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => __spreadValues(__spreadValues({}, combinedHeaders), currentHeaders != null ? currentHeaders : {}),
    {}
  );
}
function extractResponseHeaders2(response) {
  return Object.fromEntries([...response.headers]);
}
function convertUint8ArrayToBase642(array2) {
  let latin1string = "";
  for (let i = 0; i < array2.length; i++) {
    latin1string += String.fromCodePoint(array2[i]);
  }
  return btoa3(latin1string);
}
function isAbortError2(error) {
  return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
  error.name === "TimeoutError");
}
function handleFetchError2({
  error,
  url,
  requestBodyValues
}) {
  if (isAbortError2(error)) {
    return error;
  }
  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES2.includes(error.message.toLowerCase())) {
    const cause = error.cause;
    if (cause != null) {
      return new APICallError2({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error;
}
function getRuntimeEnvironmentUserAgent2(globalThisAny = globalThis) {
  var _a222, _b222, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a222 = globalThisAny.navigator) == null ? void 0 : _a222.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b222 = globalThisAny.process) == null ? void 0 : _b222.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function normalizeHeaders2(headers) {
  if (headers == null) {
    return {};
  }
  const normalized = {};
  if (headers instanceof Headers) {
    headers.forEach((value2, key) => {
      normalized[key.toLowerCase()] = value2;
    });
  } else {
    if (!Array.isArray(headers)) {
      headers = Object.entries(headers);
    }
    for (const [key, value2] of headers) {
      if (value2 != null) {
        normalized[key.toLowerCase()] = value2;
      }
    }
  }
  return normalized;
}
function withUserAgentSuffix2(headers, ...userAgentSuffixParts) {
  const normalizedHeaders = new Headers(normalizeHeaders2(headers));
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders.entries());
}
function loadApiKey2({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new LoadAPIKeyError2({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadAPIKeyError2({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new LoadAPIKeyError2({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new LoadAPIKeyError2({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
function _parse2(text2) {
  const obj = JSON.parse(text2);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx2.test(text2) === false && suspectConstructorRx2.test(text2) === false) {
    return obj;
  }
  return filter2(obj);
}
function filter2(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value2 = node[key];
        if (value2 && typeof value2 === "object") {
          next.push(value2);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse2(text2) {
  const { stackTraceLimit } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch (e) {
    return _parse2(text2);
  }
  try {
    return _parse2(text2);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
function addAdditionalPropertiesToJsonSchema2(jsonSchema22) {
  if (jsonSchema22.type === "object") {
    jsonSchema22.additionalProperties = false;
    const properties = jsonSchema22.properties;
    if (properties != null) {
      for (const property in properties) {
        properties[property] = addAdditionalPropertiesToJsonSchema2(
          properties[property]
        );
      }
    }
  }
  if (jsonSchema22.type === "array" && jsonSchema22.items != null) {
    if (Array.isArray(jsonSchema22.items)) {
      jsonSchema22.items = jsonSchema22.items.map(
        (item) => addAdditionalPropertiesToJsonSchema2(item)
      );
    } else {
      jsonSchema22.items = addAdditionalPropertiesToJsonSchema2(
        jsonSchema22.items
      );
    }
  }
  return jsonSchema22;
}
function parseAnyDef3() {
  return {};
}
function parseArrayDef3(def, refs) {
  var _a222, _b222, _c;
  const res = {
    type: "array"
  };
  if (((_a222 = def.type) == null ? void 0 : _a222._def) && ((_c = (_b222 = def.type) == null ? void 0 : _b222._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind4.ZodAny) {
    res.items = parseDef3(def.type._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "items"]
    }));
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef3(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef3() {
  return { type: "boolean" };
}
function parseBrandedDef3(_def, refs) {
  return parseDef3(_def.type._def, refs);
}
function parseDateDef3(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef3(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser3(def);
  }
}
function parseDefaultDef3(_def, refs) {
  return __spreadProps(__spreadValues({}, parseDef3(_def.innerType._def, refs)), {
    default: _def.defaultValue()
  });
}
function parseEffectsDef3(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef3(_def.schema._def, refs) : parseAnyDef3();
}
function parseEnumDef3(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
function parseIntersectionDef3(def, refs) {
  const allOf = [
    parseDef3(def.left._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "0"]
    })),
    parseDef3(def.right._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "1"]
    }))
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType3(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const _a163 = schema, { additionalProperties } = _a163, rest = __objRest(_a163, ["additionalProperties"]);
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef3(def) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
function parseStringDef3(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat3(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat3(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern3(res, zodPatterns3.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat3(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat3(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern3(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern3(res, zodPatterns3.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern3(res, zodPatterns3.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern3(
            res,
            RegExp(`^${escapeLiteralCheckValue3(check.value, refs)}`),
            check.message,
            refs
          );
          break;
        case "endsWith":
          addPattern3(
            res,
            RegExp(`${escapeLiteralCheckValue3(check.value, refs)}$`),
            check.message,
            refs
          );
          break;
        case "datetime":
          addFormat3(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat3(res, "date", check.message, refs);
          break;
        case "time":
          addFormat3(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat3(res, "duration", check.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "includes": {
          addPattern3(
            res,
            RegExp(escapeLiteralCheckValue3(check.value, refs)),
            check.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat3(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat3(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern3(res, zodPatterns3.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern3(res, zodPatterns3.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern3(res, zodPatterns3.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern3(res, zodPatterns3.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern3(res, zodPatterns3.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern3(res, zodPatterns3.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat3(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern3(res, zodPatterns3.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern3(res, zodPatterns3.nanoid, check.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue3(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric3(literal) : literal;
}
function escapeNonAlphaNumeric3(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC3.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat3(schema, value2, message, refs) {
  var _a222;
  if (schema.format || ((_a222 = schema.anyOf) == null ? void 0 : _a222.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push(__spreadValues({
      format: value2
    }, message && refs.errorMessages && { errorMessage: { format: message } }));
  } else {
    schema.format = value2;
  }
}
function addPattern3(schema, regex, message, refs) {
  var _a222;
  if (schema.pattern || ((_a222 = schema.allOf) == null ? void 0 : _a222.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push(__spreadValues({
      pattern: stringifyRegExpWithFlags3(regex, refs)
    }, message && refs.errorMessages && { errorMessage: { pattern: message } }));
  } else {
    schema.pattern = stringifyRegExpWithFlags3(regex, refs);
  }
}
function stringifyRegExpWithFlags3(regex, refs) {
  var _a222;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a222 = source[i + 2]) == null ? void 0 : _a222.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch (e) {
    console.warn(
      `Could not convert regex pattern at ${refs.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    );
    return regex.source;
  }
  return pattern;
}
function parseRecordDef3(def, refs) {
  var _a222, _b222, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a222 = parseDef3(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }))) != null ? _a222 : refs.allowedAdditionalProperties
  };
  if (((_b222 = def.keyType) == null ? void 0 : _b222._def.typeName) === ZodFirstPartyTypeKind23.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const _a163 = parseStringDef3(def.keyType._def, refs), { type: type2 } = _a163, keyType = __objRest(_a163, ["type"]);
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: keyType
    });
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind23.ZodEnum) {
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: {
        enum: def.keyType._def.values
      }
    });
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind23.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind23.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const _b162 = parseBrandedDef3(
      def.keyType._def,
      refs
    ), { type: type2 } = _b162, keyType = __objRest(_b162, ["type"]);
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: keyType
    });
  }
  return schema;
}
function parseMapDef3(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef3(def, refs);
  }
  const keys = parseDef3(def.keyType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "0"]
  })) || parseAnyDef3();
  const values = parseDef3(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "1"]
  })) || parseAnyDef3();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef3(def) {
  const object2 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object2[object2[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object2[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef3() {
  return { not: parseAnyDef3() };
}
function parseNullDef3() {
  return {
    type: "null"
  };
}
function parseUnionDef3(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x) => x._def.typeName in primitiveMappings3 && (!x._def.checks || !x._def.checks.length)
  )) {
    const types = options.reduce((types2, x) => {
      const type2 = primitiveMappings3[x._def.typeName];
      return type2 && !types2.includes(type2) ? [...types2, type2] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce(
      (acc, x) => {
        const type2 = typeof x._def.value;
        switch (type2) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type2];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ],
        []
      )
    };
  }
  return asAnyOf3(def, refs);
}
function parseNullableDef3(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings3[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef3(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "anyOf", "0"]
  }));
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef3(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseObjectDef3(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional3(propDef);
    const parsedDef = parseDef3(propDef._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    }));
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties3(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties3(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef3(def.catchall._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }));
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional3(schema) {
  try {
    return schema.isOptional();
  } catch (e) {
    return true;
  }
}
function parsePromiseDef3(def, refs) {
  return parseDef3(def.type._def, refs);
}
function parseSetDef3(def, refs) {
  const items = parseDef3(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items"]
  }));
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef3(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef3(x._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i}`]
        }))
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      ),
      additionalItems: parseDef3(def.rest._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [...refs.currentPath, "additionalItems"]
      }))
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef3(x._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i}`]
        }))
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      )
    };
  }
}
function parseUndefinedDef3() {
  return {
    not: parseAnyDef3()
  };
}
function parseUnknownDef3() {
  return parseAnyDef3();
}
function parseDef3(def, refs, forceResolution = false) {
  var _a222;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a222 = refs.override) == null ? void 0 : _a222.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride3) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref3(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser3(def, def.typeName, refs);
  const jsonSchema22 = typeof jsonSchemaOrGetter === "function" ? parseDef3(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema22) {
    addMeta3(def, refs, jsonSchema22);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema22, def, refs);
    newItem.jsonSchema = jsonSchema22;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema22;
  return jsonSchema22;
}
function jsonSchema2(jsonSchema22, {
  validate
} = {}) {
  return {
    [schemaSymbol2]: true,
    _type: void 0,
    // should never be used directly
    get jsonSchema() {
      if (typeof jsonSchema22 === "function") {
        jsonSchema22 = jsonSchema22();
      }
      return jsonSchema22;
    },
    validate
  };
}
function isSchema2(value2) {
  return typeof value2 === "object" && value2 !== null && schemaSymbol2 in value2 && value2[schemaSymbol2] === true && "jsonSchema" in value2 && "validate" in value2;
}
function asSchema2(schema) {
  return schema == null ? jsonSchema2({ properties: {}, additionalProperties: false }) : isSchema2(schema) ? schema : "~standard" in schema ? schema["~standard"].vendor === "zod" ? zodSchema2(schema) : standardSchema2(schema) : schema();
}
function standardSchema2(standardSchema22) {
  return jsonSchema2(
    () => standardSchema22["~standard"].jsonSchema.input({
      target: "draft-07"
    }),
    {
      validate: async (value2) => {
        const result = await standardSchema22["~standard"].validate(value2);
        return "value" in result ? { success: true, value: result.value } : {
          success: false,
          error: new TypeValidationError2({
            value: value2,
            cause: result.issues
          })
        };
      }
    }
  );
}
function zod3Schema2(zodSchema22, options) {
  var _a222;
  const useReferences = (_a222 = options == null ? void 0 : options.useReferences) != null ? _a222 : false;
  return jsonSchema2(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod3ToJsonSchema2(zodSchema22, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: async (value2) => {
        const result = await zodSchema22.safeParseAsync(value2);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function zod4Schema2(zodSchema22, options) {
  var _a222;
  const useReferences = (_a222 = options == null ? void 0 : options.useReferences) != null ? _a222 : false;
  return jsonSchema2(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => addAdditionalPropertiesToJsonSchema2(
      z410.toJSONSchema(zodSchema22, {
        target: "draft-7",
        io: "input",
        reused: useReferences ? "ref" : "inline"
      })
    ),
    {
      validate: async (value2) => {
        const result = await z410.safeParseAsync(zodSchema22, value2);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function isZod4Schema2(zodSchema22) {
  return "_zod" in zodSchema22;
}
function zodSchema2(zodSchema22, options) {
  if (isZod4Schema2(zodSchema22)) {
    return zod4Schema2(zodSchema22, options);
  } else {
    return zod3Schema2(zodSchema22, options);
  }
}
async function validateTypes2({
  value: value2,
  schema
}) {
  const result = await safeValidateTypes2({ value: value2, schema });
  if (!result.success) {
    throw TypeValidationError2.wrap({ value: value2, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes2({
  value: value2,
  schema
}) {
  const actualSchema = asSchema2(schema);
  try {
    if (actualSchema.validate == null) {
      return { success: true, value: value2, rawValue: value2 };
    }
    const result = await actualSchema.validate(value2);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value2 };
    }
    return {
      success: false,
      error: TypeValidationError2.wrap({ value: value2, cause: result.error }),
      rawValue: value2
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError2.wrap({ value: value2, cause: error }),
      rawValue: value2
    };
  }
}
async function parseJSON2({
  text: text2,
  schema
}) {
  try {
    const value2 = secureJsonParse2(text2);
    if (schema == null) {
      return value2;
    }
    return validateTypes2({ value: value2, schema });
  } catch (error) {
    if (JSONParseError2.isInstance(error) || TypeValidationError2.isInstance(error)) {
      throw error;
    }
    throw new JSONParseError2({ text: text2, cause: error });
  }
}
async function safeParseJSON2({
  text: text2,
  schema
}) {
  try {
    const value2 = secureJsonParse2(text2);
    if (schema == null) {
      return { success: true, value: value2, rawValue: value2 };
    }
    return await safeValidateTypes2({ value: value2, schema });
  } catch (error) {
    return {
      success: false,
      error: JSONParseError2.isInstance(error) ? error : new JSONParseError2({ text: text2, cause: error }),
      rawValue: void 0
    };
  }
}
function isParsableJson2(input) {
  try {
    secureJsonParse2(input);
    return true;
  } catch (e) {
    return false;
  }
}
function parseJsonEventStream2({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream2()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON2({ text: data, schema }));
      }
    })
  );
}
function withoutTrailingSlash2(url) {
  return url == null ? void 0 : url.replace(/\/$/, "");
}
function isDefinedOrNotNull(value2) {
  return value2 !== null && value2 !== void 0;
}
function mapToUnified(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "other";
  }
}
function mapOpenRouterFinishReason(finishReason) {
  return {
    unified: mapToUnified(finishReason),
    raw: finishReason != null ? finishReason : void 0
  };
}
function createFinishReason(unified, raw) {
  return { unified, raw };
}
function isUrl({
  url,
  protocols
}) {
  try {
    const urlObj = new URL(url);
    return protocols.has(urlObj.protocol);
  } catch (_) {
    return false;
  }
}
function getFileUrl({
  part,
  defaultMediaType
}) {
  var _a163, _b162;
  if (part.data instanceof Uint8Array) {
    const base64 = convertUint8ArrayToBase642(part.data);
    return `data:${(_a163 = part.mediaType) != null ? _a163 : defaultMediaType};base64,${base64}`;
  }
  const stringUrl = part.data.toString();
  if (isUrl({
    url: stringUrl,
    protocols: /* @__PURE__ */ new Set(["http:", "https:"])
  })) {
    return stringUrl;
  }
  return stringUrl.startsWith("data:") ? stringUrl : `data:${(_b162 = part.mediaType) != null ? _b162 : defaultMediaType};base64,${stringUrl}`;
}
function getMediaType(dataUrl, defaultMediaType) {
  var _a163;
  const match = dataUrl.match(/^data:([^;]+)/);
  return match ? (_a163 = match[1]) != null ? _a163 : defaultMediaType : defaultMediaType;
}
function getBase64FromDataUrl(dataUrl) {
  const match = dataUrl.match(/^data:[^;]*;base64,(.+)$/);
  return match ? match[1] : dataUrl;
}
function getInputAudioData(part) {
  const fileData = getFileUrl({
    part,
    defaultMediaType: "audio/mpeg"
  });
  if (isUrl({
    url: fileData,
    protocols: /* @__PURE__ */ new Set(["http:", "https:"])
  })) {
    throw new Error(
      `Audio files cannot be provided as URLs.

OpenRouter requires audio to be base64-encoded. Please:
1. Download the audio file locally
2. Read it as a Buffer or Uint8Array
3. Pass it as the data parameter

The AI SDK will automatically handle base64 encoding.

Learn more: https://openrouter.ai/docs/features/multimodal/audio`
    );
  }
  const data = getBase64FromDataUrl(fileData);
  const mediaType = part.mediaType || "audio/mpeg";
  const rawFormat = mediaType.replace("audio/", "");
  const format = MIME_TO_FORMAT[rawFormat];
  if (format === void 0) {
    const supportedList = OPENROUTER_AUDIO_FORMATS.join(", ");
    throw new Error(
      `Unsupported audio format: "${mediaType}"

OpenRouter supports the following audio formats: ${supportedList}

Learn more: https://openrouter.ai/docs/features/multimodal/audio`
    );
  }
  return { data, format };
}
function getCacheControl2(providerMetadata) {
  var _a163, _b162, _c;
  const anthropic2 = providerMetadata == null ? void 0 : providerMetadata.anthropic;
  const openrouter2 = providerMetadata == null ? void 0 : providerMetadata.openrouter;
  return (_c = (_b162 = (_a163 = openrouter2 == null ? void 0 : openrouter2.cacheControl) != null ? _a163 : openrouter2 == null ? void 0 : openrouter2.cache_control) != null ? _b162 : anthropic2 == null ? void 0 : anthropic2.cacheControl) != null ? _c : anthropic2 == null ? void 0 : anthropic2.cache_control;
}
function convertToOpenRouterChatMessages(prompt) {
  var _a163, _b162, _c, _d, _e, _f, _g, _h;
  const messages = [];
  const reasoningDetailsTracker = new ReasoningDetailsDuplicateTracker();
  for (const { role, content, providerOptions } of prompt) {
    switch (role) {
      case "system": {
        messages.push({
          role: "system",
          content,
          cache_control: getCacheControl2(providerOptions)
        });
        break;
      }
      case "user": {
        if (content.length === 1 && ((_a163 = content[0]) == null ? void 0 : _a163.type) === "text") {
          const cacheControl = (_b162 = getCacheControl2(providerOptions)) != null ? _b162 : getCacheControl2(content[0].providerOptions);
          const contentWithCacheControl = cacheControl ? [
            {
              type: "text",
              text: content[0].text,
              cache_control: cacheControl
            }
          ] : content[0].text;
          messages.push({
            role: "user",
            content: contentWithCacheControl
          });
          break;
        }
        const messageCacheControl = getCacheControl2(providerOptions);
        let lastTextPartIndex = -1;
        for (let i = content.length - 1; i >= 0; i--) {
          if (((_c = content[i]) == null ? void 0 : _c.type) === "text") {
            lastTextPartIndex = i;
            break;
          }
        }
        const contentParts = content.map(
          (part, index) => {
            var _a173, _b172, _c2, _d2, _e2, _f2;
            const isLastTextPart = part.type === "text" && index === lastTextPartIndex;
            const partCacheControl = getCacheControl2(part.providerOptions);
            const cacheControl = part.type === "text" ? partCacheControl != null ? partCacheControl : isLastTextPart ? messageCacheControl : void 0 : partCacheControl;
            switch (part.type) {
              case "text":
                return __spreadValues({
                  type: "text",
                  text: part.text
                }, cacheControl && { cache_control: cacheControl });
              case "file": {
                if ((_a173 = part.mediaType) == null ? void 0 : _a173.startsWith("image/")) {
                  const url = getFileUrl({
                    part,
                    defaultMediaType: "image/jpeg"
                  });
                  return __spreadValues({
                    type: "image_url",
                    image_url: {
                      url
                    }
                  }, cacheControl && { cache_control: cacheControl });
                }
                if ((_b172 = part.mediaType) == null ? void 0 : _b172.startsWith("audio/")) {
                  return __spreadValues({
                    type: "input_audio",
                    input_audio: getInputAudioData(part)
                  }, cacheControl && { cache_control: cacheControl });
                }
                const fileName = String(
                  (_f2 = (_e2 = (_d2 = (_c2 = part.providerOptions) == null ? void 0 : _c2.openrouter) == null ? void 0 : _d2.filename) != null ? _e2 : part.filename) != null ? _f2 : ""
                );
                const fileData = getFileUrl({
                  part,
                  defaultMediaType: "application/pdf"
                });
                if (isUrl({
                  url: fileData,
                  protocols: /* @__PURE__ */ new Set(["http:", "https:"])
                })) {
                  return {
                    type: "file",
                    file: {
                      filename: fileName,
                      file_data: fileData
                    }
                  };
                }
                return __spreadValues({
                  type: "file",
                  file: {
                    filename: fileName,
                    file_data: fileData
                  }
                }, cacheControl && { cache_control: cacheControl });
              }
              default: {
                return __spreadValues({
                  type: "text",
                  text: ""
                }, cacheControl && { cache_control: cacheControl });
              }
            }
          }
        );
        messages.push({
          role: "user",
          content: contentParts
        });
        break;
      }
      case "assistant": {
        let text2 = "";
        let reasoning = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text2 += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
            case "reasoning": {
              reasoning += part.text;
              break;
            }
            case "file":
              break;
            default: {
              break;
            }
          }
        }
        const parsedProviderOptions = OpenRouterProviderOptionsSchema.safeParse(providerOptions);
        const messageReasoningDetails = parsedProviderOptions.success ? (_e = (_d = parsedProviderOptions.data) == null ? void 0 : _d.openrouter) == null ? void 0 : _e.reasoning_details : void 0;
        const messageAnnotations = parsedProviderOptions.success ? (_g = (_f = parsedProviderOptions.data) == null ? void 0 : _f.openrouter) == null ? void 0 : _g.annotations : void 0;
        const candidateReasoningDetails = messageReasoningDetails && Array.isArray(messageReasoningDetails) && messageReasoningDetails.length > 0 ? messageReasoningDetails : findFirstReasoningDetails(content);
        let finalReasoningDetails;
        if (candidateReasoningDetails && candidateReasoningDetails.length > 0) {
          const uniqueDetails = [];
          for (const detail of candidateReasoningDetails) {
            if (reasoningDetailsTracker.upsert(detail)) {
              uniqueDetails.push(detail);
            }
          }
          finalReasoningDetails = uniqueDetails.length > 0 ? uniqueDetails : void 0;
        }
        messages.push({
          role: "assistant",
          content: text2,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
          reasoning: reasoning || void 0,
          reasoning_details: finalReasoningDetails,
          annotations: messageAnnotations,
          cache_control: getCacheControl2(providerOptions)
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          if (toolResponse.type === "tool-approval-response") {
            continue;
          }
          const content2 = getToolResultContent(toolResponse);
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: content2,
            cache_control: (_h = getCacheControl2(providerOptions)) != null ? _h : getCacheControl2(toolResponse.providerOptions)
          });
        }
        break;
      }
      default: {
        break;
      }
    }
  }
  return messages;
}
function getToolResultContent(input) {
  var _a163;
  switch (input.output.type) {
    case "text":
    case "error-text":
      return input.output.value;
    case "json":
    case "error-json":
    case "content":
      return JSON.stringify(input.output.value);
    case "execution-denied":
      return (_a163 = input.output.reason) != null ? _a163 : "Tool execution denied";
  }
}
function findFirstReasoningDetails(content) {
  var _a163, _b162, _c;
  for (const part of content) {
    if (part.type === "tool-call") {
      const openrouter2 = (_a163 = part.providerOptions) == null ? void 0 : _a163.openrouter;
      const details = openrouter2 == null ? void 0 : openrouter2.reasoning_details;
      if (Array.isArray(details) && details.length > 0) {
        return details;
      }
    }
  }
  for (const part of content) {
    if (part.type === "reasoning") {
      const parsed = OpenRouterProviderOptionsSchema.safeParse(
        part.providerOptions
      );
      if (parsed.success && ((_c = (_b162 = parsed.data) == null ? void 0 : _b162.openrouter) == null ? void 0 : _c.reasoning_details) && parsed.data.openrouter.reasoning_details.length > 0) {
        return parsed.data.openrouter.reasoning_details;
      }
    }
  }
  return void 0;
}
function getChatCompletionToolChoice(toolChoice) {
  switch (toolChoice.type) {
    case "auto":
    case "none":
    case "required":
      return toolChoice.type;
    case "tool": {
      return {
        type: "function",
        function: { name: toolChoice.toolName }
      };
    }
    default: {
      toolChoice;
      throw new InvalidArgumentError4({
        argument: "toolChoice",
        message: `Invalid tool choice type: ${JSON.stringify(toolChoice)}`
      });
    }
  }
}
function convertToOpenRouterCompletionPrompt({
  prompt,
  inputFormat,
  user = "user",
  assistant = "assistant"
}) {
  if (inputFormat === "prompt" && prompt.length === 1 && prompt[0] && prompt[0].role === "user" && prompt[0].content.length === 1 && prompt[0].content[0] && prompt[0].content[0].type === "text") {
    return { prompt: prompt[0].content[0].text };
  }
  let text2 = "";
  if (prompt[0] && prompt[0].role === "system") {
    text2 += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new InvalidPromptError2({
          message: `Unexpected system message in prompt: ${content}`,
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "file": {
              throw new UnsupportedFunctionalityError2({
                functionality: "file attachments"
              });
            }
            default: {
              return "";
            }
          }
        }).join("");
        text2 += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map(
          (part) => {
            switch (part.type) {
              case "text": {
                return part.text;
              }
              case "tool-call": {
                throw new UnsupportedFunctionalityError2({
                  functionality: "tool-call messages"
                });
              }
              case "tool-result": {
                throw new UnsupportedFunctionalityError2({
                  functionality: "tool-result messages"
                });
              }
              case "reasoning": {
                throw new UnsupportedFunctionalityError2({
                  functionality: "reasoning messages"
                });
              }
              case "file": {
                throw new UnsupportedFunctionalityError2({
                  functionality: "file attachments"
                });
              }
              default: {
                return "";
              }
            }
          }
        ).join("");
        text2 += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new UnsupportedFunctionalityError2({
          functionality: "tool messages"
        });
      }
      default: {
        break;
      }
    }
  }
  text2 += `${assistant}:
`;
  return {
    prompt: text2
  };
}
function removeUndefinedEntries(record) {
  return Object.fromEntries(
    Object.entries(record).filter(([, value2]) => value2 != null)
  );
}
function normalizeHeaders22(headers) {
  if (!headers) {
    return {};
  }
  if (headers instanceof Headers) {
    return Object.fromEntries(headers.entries());
  }
  if (Array.isArray(headers)) {
    return Object.fromEntries(headers);
  }
  return headers;
}
function findHeaderKey(headers, targetKey) {
  const lowerTarget = targetKey.toLowerCase();
  return Object.keys(headers).find((key) => key.toLowerCase() === lowerTarget);
}
function withUserAgentSuffix22(headers, ...userAgentSuffixParts) {
  const normalizedHeaders = normalizeHeaders22(headers);
  const cleanedHeaders = removeUndefinedEntries(normalizedHeaders);
  const existingUserAgentKey = findHeaderKey(cleanedHeaders, "user-agent");
  const existingUserAgentValue = existingUserAgentKey ? cleanedHeaders[existingUserAgentKey] : void 0;
  const userAgent = (existingUserAgentValue == null ? void 0 : existingUserAgentValue.trim()) ? existingUserAgentValue : userAgentSuffixParts.filter(Boolean).join(" ");
  const headersWithoutUserAgent = Object.fromEntries(
    Object.entries(cleanedHeaders).filter(
      ([key]) => key.toLowerCase() !== "user-agent"
    )
  );
  return __spreadProps(__spreadValues({}, headersWithoutUserAgent), {
    "user-agent": userAgent
  });
}
function createOpenRouter(options = {}) {
  var _a163, _b162, _c;
  const baseURL = (_b162 = withoutTrailingSlash2((_a163 = options.baseURL) != null ? _a163 : options.baseUrl)) != null ? _b162 : "https://openrouter.ai/api/v1";
  const compatibility = (_c = options.compatibility) != null ? _c : "compatible";
  const getHeaders = () => withUserAgentSuffix22(
    __spreadValues(__spreadValues({
      Authorization: `Bearer ${loadApiKey2({
        apiKey: options.apiKey,
        environmentVariableName: "OPENROUTER_API_KEY",
        description: "OpenRouter"
      })}`
    }, options.headers), options.api_keys && Object.keys(options.api_keys).length > 0 && {
      "X-Provider-API-Keys": JSON.stringify(options.api_keys)
    }),
    `ai-sdk/openrouter/${VERSION22}`
  );
  const createChatModel = (modelId, settings = {}) => new OpenRouterChatLanguageModel(modelId, settings, {
    provider: "openrouter.chat",
    url: ({ path: path24 }) => `${baseURL}${path24}`,
    headers: getHeaders,
    compatibility,
    fetch: options.fetch,
    extraBody: options.extraBody
  });
  const createCompletionModel = (modelId, settings = {}) => new OpenRouterCompletionLanguageModel(modelId, settings, {
    provider: "openrouter.completion",
    url: ({ path: path24 }) => `${baseURL}${path24}`,
    headers: getHeaders,
    compatibility,
    fetch: options.fetch,
    extraBody: options.extraBody
  });
  const createEmbeddingModel = (modelId, settings = {}) => new OpenRouterEmbeddingModel(modelId, settings, {
    provider: "openrouter.embedding",
    url: ({ path: path24 }) => `${baseURL}${path24}`,
    headers: getHeaders,
    fetch: options.fetch,
    extraBody: options.extraBody
  });
  const createImageModel = (modelId, settings = {}) => new OpenRouterImageModel(modelId, settings, {
    provider: "openrouter.image",
    url: ({ path: path24 }) => `${baseURL}${path24}`,
    headers: getHeaders,
    fetch: options.fetch,
    extraBody: options.extraBody
  });
  const createLanguageModel = (modelId, settings) => {
    if (new.target) {
      throw new Error(
        "The OpenRouter model function cannot be called with the new keyword."
      );
    }
    if (modelId === "openai/gpt-3.5-turbo-instruct") {
      return createCompletionModel(
        modelId,
        settings
      );
    }
    return createChatModel(modelId, settings);
  };
  const provider = (modelId, settings) => createLanguageModel(modelId, settings);
  provider.languageModel = createLanguageModel;
  provider.chat = createChatModel;
  provider.completion = createCompletionModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.embedding = createEmbeddingModel;
  provider.imageModel = createImageModel;
  return provider;
}
var __defProp3, __defProps, __getOwnPropDescs, __getOwnPropSymbols, __hasOwnProp2, __propIsEnum, __typeError2, __defNormalProp, __spreadValues, __spreadProps, __objRest, __accessCheck, __privateGet, __privateAdd, marker21, symbol21, _a21, _b17, AISDKError2, name21, marker24, symbol24, _a24, _b23, APICallError2, name24, marker34, symbol34, _a34, _b33, EmptyResponseBodyError2, name34, marker44, symbol44, _a44, _b43, InvalidArgumentError4, name44, marker54, symbol54, _a54, _b53, InvalidPromptError2, name54, marker64, symbol64, _a64, _b63, InvalidResponseDataError2, name64, marker74, symbol74, _a74, _b73, JSONParseError2, name73, marker83, symbol83, _a83, _b82, LoadAPIKeyError2, name83, marker93, symbol93, _a93, _b92, LoadSettingError2, name93, marker103, symbol103, _a103, _b102, NoContentGeneratedError2, name103, marker113, symbol113, _a113, _b112, NoSuchModelError2, name113, marker123, symbol123, _a123, _b122, TooManyEmbeddingValuesForCallError2, name123, marker133, symbol133, _a133, _b132, TypeValidationError2, name133, marker143, symbol143, _a143, _b142, UnsupportedFunctionalityError2, ParseError2, EventSourceParserStream2, btoa3, atob3, name143, marker153, symbol153, _a153, _b152, DownloadError2, createIdGenerator2, generateId2, FETCH_FAILED_ERROR_MESSAGES2, VERSION11, suspectProtoRx2, suspectConstructorRx2, ignoreOverride3, defaultOptions3, getDefaultOptions3, parseCatchDef3, integerDateParser3, isJsonSchema7AllOfType3, emojiRegex3, zodPatterns3, ALPHA_NUMERIC3, primitiveMappings3, asAnyOf3, parseOptionalDef3, parsePipelineDef3, parseReadonlyDef3, selectParser3, getRelativePath3, get$ref3, addMeta3, getRefs3, zod3ToJsonSchema2, schemaSymbol2, getOriginalFetch22, postJsonToApi2, postToApi2, createJsonErrorResponseHandler2, createEventSourceResponseHandler2, createJsonResponseHandler2, ReasoningFormat, CommonReasoningDetailSchema, ReasoningDetailSummarySchema, ReasoningDetailEncryptedSchema, ReasoningDetailTextSchema, ReasoningDetailUnionSchema, ReasoningDetailsWithUnknownSchema, ReasoningDetailArraySchema, OutputUnionToReasoningDetailsSchema, OpenRouterErrorResponseSchema, openrouterFailedResponseHandler, FileAnnotationSchema, OpenRouterProviderMetadataSchema, OpenRouterProviderOptionsSchema, _seenKeys, ReasoningDetailsDuplicateTracker, OPENROUTER_AUDIO_FORMATS, MIME_TO_FORMAT, ChatCompletionToolChoiceSchema, ImageResponseSchema, ImageResponseWithUnknownSchema, ImageResponseArraySchema, OpenRouterChatCompletionBaseResponseSchema, OpenRouterNonStreamChatCompletionResponseSchema, OpenRouterStreamChatCompletionChunkSchema, OpenRouterChatLanguageModel, OpenRouterCompletionChunkSchema, OpenRouterCompletionLanguageModel, openrouterEmbeddingUsageSchema, openrouterEmbeddingDataSchema, OpenRouterEmbeddingResponseSchema, OpenRouterEmbeddingModel, OpenRouter, OpenRouterImageResponseSchema, OpenRouterImageModel, VERSION22, openrouter;
var init_dist17 = __esm({
  "node_modules/@openrouter/ai-sdk-provider/dist/index.mjs"() {
    __defProp3 = Object.defineProperty;
    __defProps = Object.defineProperties;
    __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    __getOwnPropSymbols = Object.getOwnPropertySymbols;
    __hasOwnProp2 = Object.prototype.hasOwnProperty;
    __propIsEnum = Object.prototype.propertyIsEnumerable;
    __typeError2 = (msg) => {
      throw TypeError(msg);
    };
    __defNormalProp = (obj, key, value2) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
    __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp2.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    __objRest = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp2.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    __accessCheck = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
    __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
    __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
    marker21 = "vercel.ai.error";
    symbol21 = Symbol.for(marker21);
    AISDKError2 = class _AISDKError2 extends (_b17 = Error, _a21 = symbol21, _b17) {
      /**
       * Creates an AI SDK Error.
       *
       * @param {Object} params - The parameters for creating the error.
       * @param {string} params.name - The name of the error.
       * @param {string} params.message - The error message.
       * @param {unknown} [params.cause] - The underlying cause of the error.
       */
      constructor({
        name: name1422,
        message,
        cause
      }) {
        super(message);
        this[_a21] = true;
        this.name = name1422;
        this.cause = cause;
      }
      /**
       * Checks if the given error is an AI SDK Error.
       * @param {unknown} error - The error to check.
       * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
       */
      static isInstance(error) {
        return _AISDKError2.hasMarker(error, marker21);
      }
      static hasMarker(error, marker1522) {
        const markerSymbol = Symbol.for(marker1522);
        return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
      }
    };
    name21 = "AI_APICallError";
    marker24 = `vercel.ai.error.${name21}`;
    symbol24 = Symbol.for(marker24);
    APICallError2 = class extends (_b23 = AISDKError2, _a24 = symbol24, _b23) {
      constructor({
        message,
        url,
        requestBodyValues,
        statusCode,
        responseHeaders,
        responseBody,
        cause,
        isRetryable = statusCode != null && (statusCode === 408 || // request timeout
        statusCode === 409 || // conflict
        statusCode === 429 || // too many requests
        statusCode >= 500),
        // server error
        data
      }) {
        super({ name: name21, message, cause });
        this[_a24] = true;
        this.url = url;
        this.requestBodyValues = requestBodyValues;
        this.statusCode = statusCode;
        this.responseHeaders = responseHeaders;
        this.responseBody = responseBody;
        this.isRetryable = isRetryable;
        this.data = data;
      }
      static isInstance(error) {
        return AISDKError2.hasMarker(error, marker24);
      }
    };
    name24 = "AI_EmptyResponseBodyError";
    marker34 = `vercel.ai.error.${name24}`;
    symbol34 = Symbol.for(marker34);
    EmptyResponseBodyError2 = class extends (_b33 = AISDKError2, _a34 = symbol34, _b33) {
      // used in isInstance
      constructor({ message = "Empty response body" } = {}) {
        super({ name: name24, message });
        this[_a34] = true;
      }
      static isInstance(error) {
        return AISDKError2.hasMarker(error, marker34);
      }
    };
    name34 = "AI_InvalidArgumentError";
    marker44 = `vercel.ai.error.${name34}`;
    symbol44 = Symbol.for(marker44);
    InvalidArgumentError4 = class extends (_b43 = AISDKError2, _a44 = symbol44, _b43) {
      constructor({
        message,
        cause,
        argument
      }) {
        super({ name: name34, message, cause });
        this[_a44] = true;
        this.argument = argument;
      }
      static isInstance(error) {
        return AISDKError2.hasMarker(error, marker44);
      }
    };
    name44 = "AI_InvalidPromptError";
    marker54 = `vercel.ai.error.${name44}`;
    symbol54 = Symbol.for(marker54);
    InvalidPromptError2 = class extends (_b53 = AISDKError2, _a54 = symbol54, _b53) {
      constructor({
        prompt,
        message,
        cause
      }) {
        super({ name: name44, message: `Invalid prompt: ${message}`, cause });
        this[_a54] = true;
        this.prompt = prompt;
      }
      static isInstance(error) {
        return AISDKError2.hasMarker(error, marker54);
      }
    };
    name54 = "AI_InvalidResponseDataError";
    marker64 = `vercel.ai.error.${name54}`;
    symbol64 = Symbol.for(marker64);
    InvalidResponseDataError2 = class extends (_b63 = AISDKError2, _a64 = symbol64, _b63) {
      constructor({
        data,
        message = `Invalid response data: ${JSON.stringify(data)}.`
      }) {
        super({ name: name54, message });
        this[_a64] = true;
        this.data = data;
      }
      static isInstance(error) {
        return AISDKError2.hasMarker(error, marker64);
      }
    };
    name64 = "AI_JSONParseError";
    marker74 = `vercel.ai.error.${name64}`;
    symbol74 = Symbol.for(marker74);
    JSONParseError2 = class extends (_b73 = AISDKError2, _a74 = symbol74, _b73) {
      constructor({ text: text2, cause }) {
        super({
          name: name64,
          message: `JSON parsing failed: Text: ${text2}.
Error message: ${getErrorMessage3(cause)}`,
          cause
        });
        this[_a74] = true;
        this.text = text2;
      }
      static isInstance(error) {
        return AISDKError2.hasMarker(error, marker74);
      }
    };
    name73 = "AI_LoadAPIKeyError";
    marker83 = `vercel.ai.error.${name73}`;
    symbol83 = Symbol.for(marker83);
    LoadAPIKeyError2 = class extends (_b82 = AISDKError2, _a83 = symbol83, _b82) {
      // used in isInstance
      constructor({ message }) {
        super({ name: name73, message });
        this[_a83] = true;
      }
      static isInstance(error) {
        return AISDKError2.hasMarker(error, marker83);
      }
    };
    name83 = "AI_LoadSettingError";
    marker93 = `vercel.ai.error.${name83}`;
    symbol93 = Symbol.for(marker93);
    LoadSettingError2 = class extends (_b92 = AISDKError2, _a93 = symbol93, _b92) {
      // used in isInstance
      constructor({ message }) {
        super({ name: name83, message });
        this[_a93] = true;
      }
      static isInstance(error) {
        return AISDKError2.hasMarker(error, marker93);
      }
    };
    name93 = "AI_NoContentGeneratedError";
    marker103 = `vercel.ai.error.${name93}`;
    symbol103 = Symbol.for(marker103);
    NoContentGeneratedError2 = class extends (_b102 = AISDKError2, _a103 = symbol103, _b102) {
      // used in isInstance
      constructor({
        message = "No content generated."
      } = {}) {
        super({ name: name93, message });
        this[_a103] = true;
      }
      static isInstance(error) {
        return AISDKError2.hasMarker(error, marker103);
      }
    };
    name103 = "AI_NoSuchModelError";
    marker113 = `vercel.ai.error.${name103}`;
    symbol113 = Symbol.for(marker113);
    NoSuchModelError2 = class extends (_b112 = AISDKError2, _a113 = symbol113, _b112) {
      constructor({
        errorName = name103,
        modelId,
        modelType,
        message = `No such ${modelType}: ${modelId}`
      }) {
        super({ name: errorName, message });
        this[_a113] = true;
        this.modelId = modelId;
        this.modelType = modelType;
      }
      static isInstance(error) {
        return AISDKError2.hasMarker(error, marker113);
      }
    };
    name113 = "AI_TooManyEmbeddingValuesForCallError";
    marker123 = `vercel.ai.error.${name113}`;
    symbol123 = Symbol.for(marker123);
    TooManyEmbeddingValuesForCallError2 = class extends (_b122 = AISDKError2, _a123 = symbol123, _b122) {
      constructor(options) {
        super({
          name: name113,
          message: `Too many values for a single embedding call. The ${options.provider} model "${options.modelId}" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`
        });
        this[_a123] = true;
        this.provider = options.provider;
        this.modelId = options.modelId;
        this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;
        this.values = options.values;
      }
      static isInstance(error) {
        return AISDKError2.hasMarker(error, marker123);
      }
    };
    name123 = "AI_TypeValidationError";
    marker133 = `vercel.ai.error.${name123}`;
    symbol133 = Symbol.for(marker133);
    TypeValidationError2 = class _TypeValidationError2 extends (_b132 = AISDKError2, _a133 = symbol133, _b132) {
      constructor({ value: value2, cause }) {
        super({
          name: name123,
          message: `Type validation failed: Value: ${JSON.stringify(value2)}.
Error message: ${getErrorMessage3(cause)}`,
          cause
        });
        this[_a133] = true;
        this.value = value2;
      }
      static isInstance(error) {
        return AISDKError2.hasMarker(error, marker133);
      }
      /**
       * Wraps an error into a TypeValidationError.
       * If the cause is already a TypeValidationError with the same value, it returns the cause.
       * Otherwise, it creates a new TypeValidationError.
       *
       * @param {Object} params - The parameters for wrapping the error.
       * @param {unknown} params.value - The value that failed validation.
       * @param {unknown} params.cause - The original error or cause of the validation failure.
       * @returns {TypeValidationError} A TypeValidationError instance.
       */
      static wrap({
        value: value2,
        cause
      }) {
        return _TypeValidationError2.isInstance(cause) && cause.value === value2 ? cause : new _TypeValidationError2({ value: value2, cause });
      }
    };
    name133 = "AI_UnsupportedFunctionalityError";
    marker143 = `vercel.ai.error.${name133}`;
    symbol143 = Symbol.for(marker143);
    UnsupportedFunctionalityError2 = class extends (_b142 = AISDKError2, _a143 = symbol143, _b142) {
      constructor({
        functionality,
        message = `'${functionality}' functionality not supported.`
      }) {
        super({ name: name133, message });
        this[_a143] = true;
        this.functionality = functionality;
      }
      static isInstance(error) {
        return AISDKError2.hasMarker(error, marker143);
      }
    };
    ParseError2 = class extends Error {
      constructor(message, options) {
        super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
      }
    };
    EventSourceParserStream2 = class extends TransformStream {
      constructor({ onError: onError2, onRetry, onComment } = {}) {
        let parser;
        super({
          start(controller) {
            parser = createParser2({
              onEvent: (event) => {
                controller.enqueue(event);
              },
              onError(error) {
                onError2 === "terminate" ? controller.error(error) : typeof onError2 == "function" && onError2(error);
              },
              onRetry,
              onComment
            });
          },
          transform(chunk) {
            parser.feed(chunk);
          }
        });
      }
    };
    ({ btoa: btoa3, atob: atob3 } = globalThis);
    name143 = "AI_DownloadError";
    marker153 = `vercel.ai.error.${name143}`;
    symbol153 = Symbol.for(marker153);
    DownloadError2 = class extends (_b152 = AISDKError2, _a153 = symbol153, _b152) {
      constructor({
        url,
        statusCode,
        statusText,
        cause,
        message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`
      }) {
        super({ name: name143, message, cause });
        this[_a153] = true;
        this.url = url;
        this.statusCode = statusCode;
        this.statusText = statusText;
      }
      static isInstance(error) {
        return AISDKError2.hasMarker(error, marker153);
      }
    };
    createIdGenerator2 = ({
      prefix,
      size = 16,
      alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
      separator = "-"
    } = {}) => {
      const generator = () => {
        const alphabetLength = alphabet.length;
        const chars = new Array(size);
        for (let i = 0; i < size; i++) {
          chars[i] = alphabet[Math.random() * alphabetLength | 0];
        }
        return chars.join("");
      };
      if (prefix == null) {
        return generator;
      }
      if (alphabet.includes(separator)) {
        throw new InvalidArgumentError4({
          argument: "separator",
          message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
        });
      }
      return () => `${prefix}${separator}${generator()}`;
    };
    generateId2 = createIdGenerator2();
    FETCH_FAILED_ERROR_MESSAGES2 = ["fetch failed", "failed to fetch"];
    VERSION11 = true ? "4.0.1" : "0.0.0-test";
    suspectProtoRx2 = /"__proto__"\s*:/;
    suspectConstructorRx2 = /"constructor"\s*:/;
    ignoreOverride3 = Symbol(
      "Let zodToJsonSchema decide on which parser to use"
    );
    defaultOptions3 = {
      name: void 0,
      $refStrategy: "root",
      basePath: ["#"],
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "format:date-time",
      mapStrategy: "entries",
      removeAdditionalStrategy: "passthrough",
      allowedAdditionalProperties: true,
      rejectedAdditionalProperties: false,
      definitionPath: "definitions",
      strictUnions: false,
      definitions: {},
      errorMessages: false,
      patternStrategy: "escape",
      applyRegexFlags: false,
      emailStrategy: "format:email",
      base64Strategy: "contentEncoding:base64",
      nameStrategy: "ref"
    };
    getDefaultOptions3 = (options) => typeof options === "string" ? __spreadProps(__spreadValues({}, defaultOptions3), {
      name: options
    }) : __spreadValues(__spreadValues({}, defaultOptions3), options);
    parseCatchDef3 = (def, refs) => {
      return parseDef3(def.innerType._def, refs);
    };
    integerDateParser3 = (def) => {
      const res = {
        type: "integer",
        format: "unix-time"
      };
      for (const check of def.checks) {
        switch (check.kind) {
          case "min":
            res.minimum = check.value;
            break;
          case "max":
            res.maximum = check.value;
            break;
        }
      }
      return res;
    };
    isJsonSchema7AllOfType3 = (type2) => {
      if ("type" in type2 && type2.type === "string") return false;
      return "allOf" in type2;
    };
    emojiRegex3 = void 0;
    zodPatterns3 = {
      /**
       * `c` was changed to `[cC]` to replicate /i flag
       */
      cuid: /^[cC][^\s-]{8,}$/,
      cuid2: /^[0-9a-z]+$/,
      ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
      /**
       * `a-z` was added to replicate /i flag
       */
      email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
      /**
       * Constructed a valid Unicode RegExp
       *
       * Lazily instantiate since this type of regex isn't supported
       * in all envs (e.g. React Native).
       *
       * See:
       * https://github.com/colinhacks/zod/issues/2433
       * Fix in Zod:
       * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
       */
      emoji: () => {
        if (emojiRegex3 === void 0) {
          emojiRegex3 = RegExp(
            "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
            "u"
          );
        }
        return emojiRegex3;
      },
      /**
       * Unused
       */
      uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
      /**
       * Unused
       */
      ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
      /**
       * Unused
       */
      ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
      ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
      base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
      base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
      nanoid: /^[a-zA-Z0-9_-]{21}$/,
      jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
    };
    ALPHA_NUMERIC3 = new Set(
      "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
    );
    primitiveMappings3 = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBigInt: "integer",
      ZodBoolean: "boolean",
      ZodNull: "null"
    };
    asAnyOf3 = (def, refs) => {
      const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
        (x, i) => parseDef3(x._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "anyOf", `${i}`]
        }))
      ).filter(
        (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
      );
      return anyOf.length ? { anyOf } : void 0;
    };
    parseOptionalDef3 = (def, refs) => {
      var _a222;
      if (refs.currentPath.toString() === ((_a222 = refs.propertyPath) == null ? void 0 : _a222.toString())) {
        return parseDef3(def.innerType._def, refs);
      }
      const innerSchema = parseDef3(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [...refs.currentPath, "anyOf", "1"]
      }));
      return innerSchema ? { anyOf: [{ not: parseAnyDef3() }, innerSchema] } : parseAnyDef3();
    };
    parsePipelineDef3 = (def, refs) => {
      if (refs.pipeStrategy === "input") {
        return parseDef3(def.in._def, refs);
      } else if (refs.pipeStrategy === "output") {
        return parseDef3(def.out._def, refs);
      }
      const a = parseDef3(def.in._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [...refs.currentPath, "allOf", "0"]
      }));
      const b = parseDef3(def.out._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
      }));
      return {
        allOf: [a, b].filter((x) => x !== void 0)
      };
    };
    parseReadonlyDef3 = (def, refs) => {
      return parseDef3(def.innerType._def, refs);
    };
    selectParser3 = (def, typeName, refs) => {
      switch (typeName) {
        case ZodFirstPartyTypeKind32.ZodString:
          return parseStringDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodNumber:
          return parseNumberDef3(def);
        case ZodFirstPartyTypeKind32.ZodObject:
          return parseObjectDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodBigInt:
          return parseBigintDef3(def);
        case ZodFirstPartyTypeKind32.ZodBoolean:
          return parseBooleanDef3();
        case ZodFirstPartyTypeKind32.ZodDate:
          return parseDateDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodUndefined:
          return parseUndefinedDef3();
        case ZodFirstPartyTypeKind32.ZodNull:
          return parseNullDef3();
        case ZodFirstPartyTypeKind32.ZodArray:
          return parseArrayDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodUnion:
        case ZodFirstPartyTypeKind32.ZodDiscriminatedUnion:
          return parseUnionDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodIntersection:
          return parseIntersectionDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodTuple:
          return parseTupleDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodRecord:
          return parseRecordDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodLiteral:
          return parseLiteralDef3(def);
        case ZodFirstPartyTypeKind32.ZodEnum:
          return parseEnumDef3(def);
        case ZodFirstPartyTypeKind32.ZodNativeEnum:
          return parseNativeEnumDef3(def);
        case ZodFirstPartyTypeKind32.ZodNullable:
          return parseNullableDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodOptional:
          return parseOptionalDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodMap:
          return parseMapDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodSet:
          return parseSetDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodLazy:
          return () => def.getter()._def;
        case ZodFirstPartyTypeKind32.ZodPromise:
          return parsePromiseDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodNaN:
        case ZodFirstPartyTypeKind32.ZodNever:
          return parseNeverDef3();
        case ZodFirstPartyTypeKind32.ZodEffects:
          return parseEffectsDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodAny:
          return parseAnyDef3();
        case ZodFirstPartyTypeKind32.ZodUnknown:
          return parseUnknownDef3();
        case ZodFirstPartyTypeKind32.ZodDefault:
          return parseDefaultDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodBranded:
          return parseBrandedDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodReadonly:
          return parseReadonlyDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodCatch:
          return parseCatchDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodPipeline:
          return parsePipelineDef3(def, refs);
        case ZodFirstPartyTypeKind32.ZodFunction:
        case ZodFirstPartyTypeKind32.ZodVoid:
        case ZodFirstPartyTypeKind32.ZodSymbol:
          return void 0;
        default:
          return /* @__PURE__ */ ((_) => void 0)(typeName);
      }
    };
    getRelativePath3 = (pathA, pathB) => {
      let i = 0;
      for (; i < pathA.length && i < pathB.length; i++) {
        if (pathA[i] !== pathB[i]) break;
      }
      return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
    };
    get$ref3 = (item, refs) => {
      switch (refs.$refStrategy) {
        case "root":
          return { $ref: item.path.join("/") };
        case "relative":
          return { $ref: getRelativePath3(refs.currentPath, item.path) };
        case "none":
        case "seen": {
          if (item.path.length < refs.currentPath.length && item.path.every((value2, index) => refs.currentPath[index] === value2)) {
            console.warn(
              `Recursive reference detected at ${refs.currentPath.join(
                "/"
              )}! Defaulting to any`
            );
            return parseAnyDef3();
          }
          return refs.$refStrategy === "seen" ? parseAnyDef3() : void 0;
        }
      }
    };
    addMeta3 = (def, refs, jsonSchema22) => {
      if (def.description) {
        jsonSchema22.description = def.description;
      }
      return jsonSchema22;
    };
    getRefs3 = (options) => {
      const _options = getDefaultOptions3(options);
      const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
      return __spreadProps(__spreadValues({}, _options), {
        currentPath,
        propertyPath: void 0,
        seen: new Map(
          Object.entries(_options.definitions).map(([name222, def]) => [
            def._def,
            {
              def: def._def,
              path: [..._options.basePath, _options.definitionPath, name222],
              // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
              jsonSchema: void 0
            }
          ])
        )
      });
    };
    zod3ToJsonSchema2 = (schema, options) => {
      var _a222;
      const refs = getRefs3(options);
      let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
        (acc, [name322, schema2]) => {
          var _a322;
          return __spreadProps(__spreadValues({}, acc), {
            [name322]: (_a322 = parseDef3(
              schema2._def,
              __spreadProps(__spreadValues({}, refs), {
                currentPath: [...refs.basePath, refs.definitionPath, name322]
              }),
              true
            )) != null ? _a322 : parseAnyDef3()
          });
        },
        {}
      ) : void 0;
      const name222 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
      const main = (_a222 = parseDef3(
        schema._def,
        name222 === void 0 ? refs : __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.basePath, refs.definitionPath, name222]
        }),
        false
      )) != null ? _a222 : parseAnyDef3();
      const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
      if (title !== void 0) {
        main.title = title;
      }
      const combined = name222 === void 0 ? definitions ? __spreadProps(__spreadValues({}, main), {
        [refs.definitionPath]: definitions
      }) : main : {
        $ref: [
          ...refs.$refStrategy === "relative" ? [] : refs.basePath,
          refs.definitionPath,
          name222
        ].join("/"),
        [refs.definitionPath]: __spreadProps(__spreadValues({}, definitions), {
          [name222]: main
        })
      };
      combined.$schema = "http://json-schema.org/draft-07/schema#";
      return combined;
    };
    schemaSymbol2 = Symbol.for("vercel.ai.schema");
    getOriginalFetch22 = () => globalThis.fetch;
    postJsonToApi2 = async ({
      url,
      headers,
      body,
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    }) => postToApi2({
      url,
      headers: __spreadValues({
        "Content-Type": "application/json"
      }, headers),
      body: {
        content: JSON.stringify(body),
        values: body
      },
      failedResponseHandler,
      successfulResponseHandler,
      abortSignal,
      fetch: fetch2
    });
    postToApi2 = async ({
      url,
      headers = {},
      body,
      successfulResponseHandler,
      failedResponseHandler,
      abortSignal,
      fetch: fetch2 = getOriginalFetch22()
    }) => {
      try {
        const response = await fetch2(url, {
          method: "POST",
          headers: withUserAgentSuffix2(
            headers,
            `ai-sdk/provider-utils/${VERSION11}`,
            getRuntimeEnvironmentUserAgent2()
          ),
          body: body.content,
          signal: abortSignal
        });
        const responseHeaders = extractResponseHeaders2(response);
        if (!response.ok) {
          let errorInformation;
          try {
            errorInformation = await failedResponseHandler({
              response,
              url,
              requestBodyValues: body.values
            });
          } catch (error) {
            if (isAbortError2(error) || APICallError2.isInstance(error)) {
              throw error;
            }
            throw new APICallError2({
              message: "Failed to process error response",
              cause: error,
              statusCode: response.status,
              url,
              responseHeaders,
              requestBodyValues: body.values
            });
          }
          throw errorInformation.value;
        }
        try {
          return await successfulResponseHandler({
            response,
            url,
            requestBodyValues: body.values
          });
        } catch (error) {
          if (error instanceof Error) {
            if (isAbortError2(error) || APICallError2.isInstance(error)) {
              throw error;
            }
          }
          throw new APICallError2({
            message: "Failed to process successful response",
            cause: error,
            statusCode: response.status,
            url,
            responseHeaders,
            requestBodyValues: body.values
          });
        }
      } catch (error) {
        throw handleFetchError2({ error, url, requestBodyValues: body.values });
      }
    };
    createJsonErrorResponseHandler2 = ({
      errorSchema,
      errorToMessage,
      isRetryable
    }) => async ({ response, url, requestBodyValues }) => {
      const responseBody = await response.text();
      const responseHeaders = extractResponseHeaders2(response);
      if (responseBody.trim() === "") {
        return {
          responseHeaders,
          value: new APICallError2({
            message: response.statusText,
            url,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
      try {
        const parsedError = await parseJSON2({
          text: responseBody,
          schema: errorSchema
        });
        return {
          responseHeaders,
          value: new APICallError2({
            message: errorToMessage(parsedError),
            url,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            data: parsedError,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
          })
        };
      } catch (parseError) {
        return {
          responseHeaders,
          value: new APICallError2({
            message: response.statusText,
            url,
            requestBodyValues,
            statusCode: response.status,
            responseHeaders,
            responseBody,
            isRetryable: isRetryable == null ? void 0 : isRetryable(response)
          })
        };
      }
    };
    createEventSourceResponseHandler2 = (chunkSchema2) => async ({ response }) => {
      const responseHeaders = extractResponseHeaders2(response);
      if (response.body == null) {
        throw new EmptyResponseBodyError2({});
      }
      return {
        responseHeaders,
        value: parseJsonEventStream2({
          stream: response.body,
          schema: chunkSchema2
        })
      };
    };
    createJsonResponseHandler2 = (responseSchema2) => async ({ response, url, requestBodyValues }) => {
      const responseBody = await response.text();
      const parsedResult = await safeParseJSON2({
        text: responseBody,
        schema: responseSchema2
      });
      const responseHeaders = extractResponseHeaders2(response);
      if (!parsedResult.success) {
        throw new APICallError2({
          message: "Invalid JSON response",
          cause: parsedResult.error,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          url,
          requestBodyValues
        });
      }
      return {
        responseHeaders,
        value: parsedResult.value,
        rawValue: parsedResult.rawValue
      };
    };
    ReasoningFormat = /* @__PURE__ */ ((ReasoningFormat2) => {
      ReasoningFormat2["Unknown"] = "unknown";
      ReasoningFormat2["OpenAIResponsesV1"] = "openai-responses-v1";
      ReasoningFormat2["XAIResponsesV1"] = "xai-responses-v1";
      ReasoningFormat2["AnthropicClaudeV1"] = "anthropic-claude-v1";
      ReasoningFormat2["GoogleGeminiV1"] = "google-gemini-v1";
      return ReasoningFormat2;
    })(ReasoningFormat || {});
    CommonReasoningDetailSchema = z39.object({
      id: z39.string().nullish(),
      format: z39.enum(ReasoningFormat).nullish(),
      index: z39.number().optional()
    }).loose();
    ReasoningDetailSummarySchema = z39.object({
      type: z39.literal(
        "reasoning.summary"
        /* Summary */
      ),
      summary: z39.string()
    }).extend(CommonReasoningDetailSchema.shape);
    ReasoningDetailEncryptedSchema = z39.object({
      type: z39.literal(
        "reasoning.encrypted"
        /* Encrypted */
      ),
      data: z39.string()
    }).extend(CommonReasoningDetailSchema.shape);
    ReasoningDetailTextSchema = z39.object({
      type: z39.literal(
        "reasoning.text"
        /* Text */
      ),
      text: z39.string().nullish(),
      signature: z39.string().nullish()
    }).extend(CommonReasoningDetailSchema.shape);
    ReasoningDetailUnionSchema = z39.union([
      ReasoningDetailSummarySchema,
      ReasoningDetailEncryptedSchema,
      ReasoningDetailTextSchema
    ]);
    ReasoningDetailsWithUnknownSchema = z39.union([
      ReasoningDetailUnionSchema,
      z39.unknown().transform(() => null)
    ]);
    ReasoningDetailArraySchema = z39.array(ReasoningDetailsWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));
    OutputUnionToReasoningDetailsSchema = z39.union([
      z39.object({
        delta: z39.object({
          reasoning_details: z39.array(ReasoningDetailsWithUnknownSchema)
        })
      }).transform(
        (data) => data.delta.reasoning_details.filter(isDefinedOrNotNull)
      ),
      z39.object({
        message: z39.object({
          reasoning_details: z39.array(ReasoningDetailsWithUnknownSchema)
        })
      }).transform(
        (data) => data.message.reasoning_details.filter(isDefinedOrNotNull)
      ),
      z39.object({
        text: z39.string(),
        reasoning_details: z39.array(ReasoningDetailsWithUnknownSchema)
      }).transform((data) => data.reasoning_details.filter(isDefinedOrNotNull))
    ]);
    OpenRouterErrorResponseSchema = z212.object({
      error: z212.object({
        code: z212.union([z212.string(), z212.number()]).nullable().optional().default(null),
        message: z212.string(),
        type: z212.string().nullable().optional().default(null),
        param: z212.any().nullable().optional().default(null)
      }).passthrough()
    }).passthrough();
    openrouterFailedResponseHandler = createJsonErrorResponseHandler2({
      errorSchema: OpenRouterErrorResponseSchema,
      errorToMessage: (data) => data.error.message
    });
    FileAnnotationSchema = z310.object({
      type: z310.literal("file"),
      file: z310.object({
        hash: z310.string(),
        name: z310.string(),
        content: z310.array(
          z310.object({
            type: z310.string(),
            text: z310.string().optional()
          }).catchall(z310.any())
        ).optional()
      }).catchall(z310.any())
    }).catchall(z310.any());
    OpenRouterProviderMetadataSchema = z310.object({
      provider: z310.string(),
      reasoning_details: z310.array(ReasoningDetailUnionSchema).optional(),
      annotations: z310.array(FileAnnotationSchema).optional(),
      usage: z310.object({
        promptTokens: z310.number(),
        promptTokensDetails: z310.object({
          cachedTokens: z310.number()
        }).catchall(z310.any()).optional(),
        completionTokens: z310.number(),
        completionTokensDetails: z310.object({
          reasoningTokens: z310.number()
        }).catchall(z310.any()).optional(),
        totalTokens: z310.number(),
        cost: z310.number().optional(),
        costDetails: z310.object({
          upstreamInferenceCost: z310.number()
        }).catchall(z310.any()).optional()
      }).catchall(z310.any())
    }).catchall(z310.any());
    OpenRouterProviderOptionsSchema = z310.object({
      openrouter: z310.object({
        reasoning_details: z310.array(ReasoningDetailUnionSchema).optional(),
        annotations: z310.array(FileAnnotationSchema).optional()
      }).optional()
    }).optional();
    ReasoningDetailsDuplicateTracker = class {
      constructor() {
        __privateAdd(this, _seenKeys, /* @__PURE__ */ new Set());
      }
      /**
       * Attempts to track a detail.
       * Returns true if this is a NEW detail (not seen before and has valid key),
       * false if it was skipped (no valid key) or already seen (duplicate).
       */
      upsert(detail) {
        const key = this.getCanonicalKey(detail);
        if (key === null) {
          return false;
        }
        if (__privateGet(this, _seenKeys).has(key)) {
          return false;
        }
        __privateGet(this, _seenKeys).add(key);
        return true;
      }
      getCanonicalKey(detail) {
        switch (detail.type) {
          case "reasoning.summary":
            return detail.summary;
          case "reasoning.encrypted":
            if (detail.id) {
              return detail.id;
            }
            return detail.data;
          case "reasoning.text": {
            if (detail.text) {
              return detail.text;
            }
            if (detail.signature) {
              return detail.signature;
            }
            return null;
          }
          default: {
            return null;
          }
        }
      }
    };
    _seenKeys = /* @__PURE__ */ new WeakMap();
    OPENROUTER_AUDIO_FORMATS = [
      "wav",
      "mp3",
      "aiff",
      "aac",
      "ogg",
      "flac",
      "m4a",
      "pcm16",
      "pcm24"
    ];
    MIME_TO_FORMAT = {
      // MP3 variants
      mpeg: "mp3",
      mp3: "mp3",
      // WAV variants
      "x-wav": "wav",
      wave: "wav",
      wav: "wav",
      // OGG variants
      ogg: "ogg",
      vorbis: "ogg",
      // AAC variants
      aac: "aac",
      "x-aac": "aac",
      // M4A variants
      m4a: "m4a",
      "x-m4a": "m4a",
      mp4: "m4a",
      // AIFF variants
      aiff: "aiff",
      "x-aiff": "aiff",
      // FLAC
      flac: "flac",
      "x-flac": "flac",
      // PCM variants
      pcm16: "pcm16",
      pcm24: "pcm24"
    };
    ChatCompletionToolChoiceSchema = z59.union([
      z59.literal("auto"),
      z59.literal("none"),
      z59.literal("required"),
      z59.object({
        type: z59.literal("function"),
        function: z59.object({
          name: z59.string()
        })
      })
    ]);
    ImageResponseSchema = z69.object({
      type: z69.literal("image_url"),
      image_url: z69.object({
        url: z69.string()
      }).passthrough()
    }).passthrough();
    ImageResponseWithUnknownSchema = z69.union([
      ImageResponseSchema,
      z69.unknown().transform(() => null)
    ]);
    ImageResponseArraySchema = z69.array(ImageResponseWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));
    OpenRouterChatCompletionBaseResponseSchema = z79.object({
      id: z79.string().optional(),
      model: z79.string().optional(),
      provider: z79.string().optional(),
      usage: z79.object({
        prompt_tokens: z79.number(),
        prompt_tokens_details: z79.object({
          cached_tokens: z79.number()
        }).passthrough().nullish(),
        completion_tokens: z79.number(),
        completion_tokens_details: z79.object({
          reasoning_tokens: z79.number()
        }).passthrough().nullish(),
        total_tokens: z79.number(),
        cost: z79.number().optional(),
        cost_details: z79.object({
          upstream_inference_cost: z79.number().nullish()
        }).passthrough().nullish()
      }).passthrough().nullish()
    }).passthrough();
    OpenRouterNonStreamChatCompletionResponseSchema = z79.union([
      // Success response with choices
      OpenRouterChatCompletionBaseResponseSchema.extend({
        choices: z79.array(
          z79.object({
            message: z79.object({
              role: z79.literal("assistant"),
              content: z79.string().nullable().optional(),
              reasoning: z79.string().nullable().optional(),
              reasoning_details: ReasoningDetailArraySchema.nullish(),
              images: ImageResponseArraySchema.nullish(),
              tool_calls: z79.array(
                z79.object({
                  id: z79.string().optional().nullable(),
                  type: z79.literal("function"),
                  function: z79.object({
                    name: z79.string(),
                    arguments: z79.string().optional()
                  }).passthrough()
                }).passthrough()
              ).optional(),
              annotations: z79.array(
                z79.union([
                  // URL citation from web search
                  // title, start_index, end_index are optional as some upstream providers may omit them
                  z79.object({
                    type: z79.literal("url_citation"),
                    url_citation: z79.object({
                      url: z79.string(),
                      title: z79.string().optional(),
                      start_index: z79.number().optional(),
                      end_index: z79.number().optional(),
                      content: z79.string().optional()
                    }).passthrough()
                  }).passthrough(),
                  // File annotation from FileParserPlugin (old format)
                  z79.object({
                    type: z79.literal("file_annotation"),
                    file_annotation: z79.object({
                      file_id: z79.string(),
                      quote: z79.string().optional()
                    }).passthrough()
                  }).passthrough(),
                  // File annotation from FileParserPlugin (new format)
                  z79.object({
                    type: z79.literal("file"),
                    file: z79.object({
                      hash: z79.string(),
                      name: z79.string(),
                      content: z79.array(
                        z79.object({
                          type: z79.string(),
                          text: z79.string().optional()
                        }).passthrough()
                      ).optional()
                    }).passthrough()
                  }).passthrough()
                ])
              ).nullish()
            }).passthrough(),
            index: z79.number().nullish(),
            logprobs: z79.object({
              content: z79.array(
                z79.object({
                  token: z79.string(),
                  logprob: z79.number(),
                  top_logprobs: z79.array(
                    z79.object({
                      token: z79.string(),
                      logprob: z79.number()
                    }).passthrough()
                  )
                }).passthrough()
              ).nullable()
            }).passthrough().nullable().optional(),
            finish_reason: z79.string().optional().nullable()
          }).passthrough()
        )
      }),
      // Error response (HTTP 200 with error payload)
      OpenRouterErrorResponseSchema.extend({
        user_id: z79.string().optional()
      })
    ]);
    OpenRouterStreamChatCompletionChunkSchema = z79.union([
      OpenRouterChatCompletionBaseResponseSchema.extend({
        choices: z79.array(
          z79.object({
            delta: z79.object({
              role: z79.enum(["assistant"]).optional(),
              content: z79.string().nullish(),
              reasoning: z79.string().nullish().optional(),
              reasoning_details: ReasoningDetailArraySchema.nullish(),
              images: ImageResponseArraySchema.nullish(),
              tool_calls: z79.array(
                z79.object({
                  index: z79.number().nullish(),
                  id: z79.string().nullish(),
                  type: z79.literal("function").optional(),
                  function: z79.object({
                    name: z79.string().nullish(),
                    arguments: z79.string().nullish()
                  }).passthrough()
                }).passthrough()
              ).nullish(),
              annotations: z79.array(
                z79.union([
                  // URL citation from web search
                  // title, start_index, end_index are optional as some upstream providers may omit them
                  z79.object({
                    type: z79.literal("url_citation"),
                    url_citation: z79.object({
                      url: z79.string(),
                      title: z79.string().optional(),
                      start_index: z79.number().optional(),
                      end_index: z79.number().optional(),
                      content: z79.string().optional()
                    }).passthrough()
                  }).passthrough(),
                  // File annotation from FileParserPlugin (old format)
                  z79.object({
                    type: z79.literal("file_annotation"),
                    file_annotation: z79.object({
                      file_id: z79.string(),
                      quote: z79.string().optional()
                    }).passthrough()
                  }).passthrough(),
                  // File annotation from FileParserPlugin (new format)
                  z79.object({
                    type: z79.literal("file"),
                    file: z79.object({
                      hash: z79.string(),
                      name: z79.string(),
                      content: z79.array(
                        z79.object({
                          type: z79.string(),
                          text: z79.string().optional()
                        }).passthrough()
                      ).optional()
                    }).passthrough()
                  }).passthrough()
                ])
              ).nullish()
            }).passthrough().nullish(),
            logprobs: z79.object({
              content: z79.array(
                z79.object({
                  token: z79.string(),
                  logprob: z79.number(),
                  top_logprobs: z79.array(
                    z79.object({
                      token: z79.string(),
                      logprob: z79.number()
                    }).passthrough()
                  )
                }).passthrough()
              ).nullable()
            }).passthrough().nullish(),
            finish_reason: z79.string().nullable().optional(),
            index: z79.number().nullish()
          }).passthrough()
        )
      }),
      OpenRouterErrorResponseSchema
    ]);
    OpenRouterChatLanguageModel = class {
      constructor(modelId, settings, config2) {
        this.specificationVersion = "v3";
        this.provider = "openrouter";
        this.defaultObjectGenerationMode = "tool";
        this.supportsImageUrls = true;
        this.supportedUrls = {
          "image/*": [
            /^data:image\/[a-zA-Z]+;base64,/,
            /^https?:\/\/.+\.(jpg|jpeg|png|gif|webp)$/i
          ],
          // 'text/*': [/^data:text\//, /^https?:\/\/.+$/],
          "application/*": [/^data:application\//, /^https?:\/\/.+$/]
        };
        this.modelId = modelId;
        this.settings = settings;
        this.config = config2;
      }
      getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        frequencyPenalty,
        presencePenalty,
        seed,
        stopSequences,
        responseFormat,
        topK,
        tools,
        toolChoice
      }) {
        var _a163;
        const baseArgs = __spreadValues(__spreadValues({
          // model id:
          model: this.modelId,
          models: this.settings.models,
          // model specific settings:
          logit_bias: this.settings.logitBias,
          logprobs: this.settings.logprobs === true || typeof this.settings.logprobs === "number" ? true : void 0,
          top_logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : void 0 : void 0,
          user: this.settings.user,
          parallel_tool_calls: this.settings.parallelToolCalls,
          // standardized settings:
          max_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          frequency_penalty: frequencyPenalty,
          presence_penalty: presencePenalty,
          seed,
          stop: stopSequences,
          response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? responseFormat.schema != null ? {
            type: "json_schema",
            json_schema: __spreadValues({
              schema: responseFormat.schema,
              strict: true,
              name: (_a163 = responseFormat.name) != null ? _a163 : "response"
            }, responseFormat.description && {
              description: responseFormat.description
            })
          } : { type: "json_object" } : void 0,
          top_k: topK,
          // messages:
          messages: convertToOpenRouterChatMessages(prompt),
          // OpenRouter specific settings:
          include_reasoning: this.settings.includeReasoning,
          reasoning: this.settings.reasoning,
          usage: this.settings.usage,
          // Web search settings:
          plugins: this.settings.plugins,
          web_search_options: this.settings.web_search_options,
          // Provider routing settings:
          provider: this.settings.provider,
          // Debug settings:
          debug: this.settings.debug
        }, this.config.extraBody), this.settings.extraBody);
        if (tools && tools.length > 0) {
          const mappedTools = tools.filter(
            (tool2) => tool2.type === "function"
          ).map((tool2) => ({
            type: "function",
            function: {
              name: tool2.name,
              description: tool2.description,
              parameters: tool2.inputSchema
            }
          }));
          return __spreadProps(__spreadValues({}, baseArgs), {
            tools: mappedTools,
            tool_choice: toolChoice ? getChatCompletionToolChoice(toolChoice) : void 0
          });
        }
        return baseArgs;
      }
      async doGenerate(options) {
        var _a163, _b162, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B;
        const providerOptions = options.providerOptions || {};
        const openrouterOptions = providerOptions.openrouter || {};
        const args2 = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
        const { value: responseValue, responseHeaders } = await postJsonToApi2({
          url: this.config.url({
            path: "/chat/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders2(this.config.headers(), options.headers),
          body: args2,
          failedResponseHandler: openrouterFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler2(
            OpenRouterNonStreamChatCompletionResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        if ("error" in responseValue) {
          const errorData = responseValue.error;
          throw new APICallError2({
            message: errorData.message,
            url: this.config.url({
              path: "/chat/completions",
              modelId: this.modelId
            }),
            requestBodyValues: args2,
            statusCode: 200,
            responseHeaders,
            data: errorData
          });
        }
        const response = responseValue;
        const choice2 = response.choices[0];
        if (!choice2) {
          throw new NoContentGeneratedError2({
            message: "No choice in response"
          });
        }
        const usageInfo = response.usage ? {
          inputTokens: {
            total: (_a163 = response.usage.prompt_tokens) != null ? _a163 : 0,
            noCache: void 0,
            cacheRead: (_c = (_b162 = response.usage.prompt_tokens_details) == null ? void 0 : _b162.cached_tokens) != null ? _c : void 0,
            cacheWrite: void 0
          },
          outputTokens: {
            total: (_d = response.usage.completion_tokens) != null ? _d : 0,
            text: void 0,
            reasoning: (_f = (_e = response.usage.completion_tokens_details) == null ? void 0 : _e.reasoning_tokens) != null ? _f : void 0
          },
          raw: response.usage
        } : {
          inputTokens: {
            total: 0,
            noCache: void 0,
            cacheRead: void 0,
            cacheWrite: void 0
          },
          outputTokens: {
            total: 0,
            text: void 0,
            reasoning: void 0
          },
          raw: void 0
        };
        const reasoningDetails = (_g = choice2.message.reasoning_details) != null ? _g : [];
        const reasoning = reasoningDetails.length > 0 ? reasoningDetails.map((detail) => {
          switch (detail.type) {
            case "reasoning.text": {
              if (detail.text) {
                return {
                  type: "reasoning",
                  text: detail.text,
                  providerMetadata: {
                    openrouter: {
                      reasoning_details: [detail]
                    }
                  }
                };
              }
              break;
            }
            case "reasoning.summary": {
              if (detail.summary) {
                return {
                  type: "reasoning",
                  text: detail.summary,
                  providerMetadata: {
                    openrouter: {
                      reasoning_details: [detail]
                    }
                  }
                };
              }
              break;
            }
            case "reasoning.encrypted": {
              if (detail.data) {
                return {
                  type: "reasoning",
                  text: "[REDACTED]",
                  providerMetadata: {
                    openrouter: {
                      reasoning_details: [detail]
                    }
                  }
                };
              }
              break;
            }
            default: {
              detail;
            }
          }
          return null;
        }).filter((p) => p !== null) : choice2.message.reasoning ? [
          {
            type: "reasoning",
            text: choice2.message.reasoning
          }
        ] : [];
        const content = [];
        content.push(...reasoning);
        if (choice2.message.content) {
          content.push({
            type: "text",
            text: choice2.message.content
          });
        }
        if (choice2.message.tool_calls) {
          let reasoningDetailsAttachedToToolCall = false;
          for (const toolCall of choice2.message.tool_calls) {
            content.push({
              type: "tool-call",
              toolCallId: (_h = toolCall.id) != null ? _h : generateId2(),
              toolName: toolCall.function.name,
              input: (_i = toolCall.function.arguments) != null ? _i : "{}",
              providerMetadata: !reasoningDetailsAttachedToToolCall ? {
                openrouter: {
                  reasoning_details: reasoningDetails
                }
              } : void 0
            });
            reasoningDetailsAttachedToToolCall = true;
          }
        }
        if (choice2.message.images) {
          for (const image of choice2.message.images) {
            content.push({
              type: "file",
              mediaType: getMediaType(image.image_url.url, "image/jpeg"),
              data: getBase64FromDataUrl(image.image_url.url)
            });
          }
        }
        if (choice2.message.annotations) {
          for (const annotation of choice2.message.annotations) {
            if (annotation.type === "url_citation") {
              content.push({
                type: "source",
                sourceType: "url",
                id: annotation.url_citation.url,
                url: annotation.url_citation.url,
                title: (_j = annotation.url_citation.title) != null ? _j : "",
                providerMetadata: {
                  openrouter: {
                    content: (_k = annotation.url_citation.content) != null ? _k : "",
                    startIndex: (_l = annotation.url_citation.start_index) != null ? _l : 0,
                    endIndex: (_m = annotation.url_citation.end_index) != null ? _m : 0
                  }
                }
              });
            }
          }
        }
        const fileAnnotations = (_n = choice2.message.annotations) == null ? void 0 : _n.filter(
          (a) => a.type === "file"
        );
        const hasToolCalls = choice2.message.tool_calls && choice2.message.tool_calls.length > 0;
        const hasEncryptedReasoning = reasoningDetails.some(
          (d) => d.type === "reasoning.encrypted" && d.data
        );
        const shouldOverrideFinishReason = hasToolCalls && hasEncryptedReasoning && choice2.finish_reason === "stop";
        const effectiveFinishReason = shouldOverrideFinishReason ? createFinishReason("tool-calls", (_o = choice2.finish_reason) != null ? _o : void 0) : mapOpenRouterFinishReason(choice2.finish_reason);
        return {
          content,
          finishReason: effectiveFinishReason,
          usage: usageInfo,
          warnings: [],
          providerMetadata: {
            openrouter: OpenRouterProviderMetadataSchema.parse({
              provider: (_p = response.provider) != null ? _p : "",
              reasoning_details: (_q = choice2.message.reasoning_details) != null ? _q : [],
              annotations: fileAnnotations && fileAnnotations.length > 0 ? fileAnnotations : void 0,
              usage: __spreadValues(__spreadValues(__spreadValues(__spreadValues({
                promptTokens: (_r = usageInfo.inputTokens.total) != null ? _r : 0,
                completionTokens: (_s = usageInfo.outputTokens.total) != null ? _s : 0,
                totalTokens: ((_t = usageInfo.inputTokens.total) != null ? _t : 0) + ((_u = usageInfo.outputTokens.total) != null ? _u : 0)
              }, ((_v = response.usage) == null ? void 0 : _v.cost) != null ? { cost: response.usage.cost } : {}), ((_x = (_w = response.usage) == null ? void 0 : _w.prompt_tokens_details) == null ? void 0 : _x.cached_tokens) != null ? {
                promptTokensDetails: {
                  cachedTokens: response.usage.prompt_tokens_details.cached_tokens
                }
              } : {}), ((_z = (_y = response.usage) == null ? void 0 : _y.completion_tokens_details) == null ? void 0 : _z.reasoning_tokens) != null ? {
                completionTokensDetails: {
                  reasoningTokens: response.usage.completion_tokens_details.reasoning_tokens
                }
              } : {}), ((_B = (_A = response.usage) == null ? void 0 : _A.cost_details) == null ? void 0 : _B.upstream_inference_cost) != null ? {
                costDetails: {
                  upstreamInferenceCost: response.usage.cost_details.upstream_inference_cost
                }
              } : {})
            })
          },
          request: { body: args2 },
          response: {
            id: response.id,
            modelId: response.model,
            headers: responseHeaders
          }
        };
      }
      async doStream(options) {
        var _a163;
        const providerOptions = options.providerOptions || {};
        const openrouterOptions = providerOptions.openrouter || {};
        const args2 = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
        const { value: response, responseHeaders } = await postJsonToApi2({
          url: this.config.url({
            path: "/chat/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders2(this.config.headers(), options.headers),
          body: __spreadProps(__spreadValues({}, args2), {
            stream: true,
            // only include stream_options when in strict compatibility mode:
            stream_options: this.config.compatibility === "strict" ? __spreadValues({
              include_usage: true
            }, ((_a163 = this.settings.usage) == null ? void 0 : _a163.include) ? { include_usage: true } : {}) : void 0
          }),
          failedResponseHandler: openrouterFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler2(
            OpenRouterStreamChatCompletionChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const toolCalls = [];
        let finishReason = createFinishReason("other");
        const usage = {
          inputTokens: {
            total: void 0,
            noCache: void 0,
            cacheRead: void 0,
            cacheWrite: void 0
          },
          outputTokens: {
            total: void 0,
            text: void 0,
            reasoning: void 0
          },
          raw: void 0
        };
        const openrouterUsage = {};
        let rawUsage;
        const accumulatedReasoningDetails = [];
        let reasoningDetailsAttachedToToolCall = false;
        const accumulatedFileAnnotations = [];
        let textStarted = false;
        let reasoningStarted = false;
        let textId;
        let reasoningId;
        let openrouterResponseId;
        let provider;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              transform(chunk, controller) {
                var _a173, _b162, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  finishReason = createFinishReason("error");
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value2 = chunk.value;
                if ("error" in value2) {
                  finishReason = createFinishReason("error");
                  controller.enqueue({ type: "error", error: value2.error });
                  return;
                }
                if (value2.provider) {
                  provider = value2.provider;
                }
                if (value2.id) {
                  openrouterResponseId = value2.id;
                  controller.enqueue({
                    type: "response-metadata",
                    id: value2.id
                  });
                }
                if (value2.model) {
                  controller.enqueue({
                    type: "response-metadata",
                    modelId: value2.model
                  });
                }
                if (value2.usage != null) {
                  usage.inputTokens.total = value2.usage.prompt_tokens;
                  usage.outputTokens.total = value2.usage.completion_tokens;
                  rawUsage = value2.usage;
                  openrouterUsage.promptTokens = value2.usage.prompt_tokens;
                  if (value2.usage.prompt_tokens_details) {
                    const cachedInputTokens = (_a173 = value2.usage.prompt_tokens_details.cached_tokens) != null ? _a173 : 0;
                    usage.inputTokens.cacheRead = cachedInputTokens;
                    openrouterUsage.promptTokensDetails = {
                      cachedTokens: cachedInputTokens
                    };
                  }
                  openrouterUsage.completionTokens = value2.usage.completion_tokens;
                  if (value2.usage.completion_tokens_details) {
                    const reasoningTokens = (_b162 = value2.usage.completion_tokens_details.reasoning_tokens) != null ? _b162 : 0;
                    usage.outputTokens.reasoning = reasoningTokens;
                    openrouterUsage.completionTokensDetails = {
                      reasoningTokens
                    };
                  }
                  if (value2.usage.cost != null) {
                    openrouterUsage.cost = value2.usage.cost;
                  }
                  openrouterUsage.totalTokens = value2.usage.total_tokens;
                  const upstreamInferenceCost = (_c = value2.usage.cost_details) == null ? void 0 : _c.upstream_inference_cost;
                  if (upstreamInferenceCost != null) {
                    openrouterUsage.costDetails = {
                      upstreamInferenceCost
                    };
                  }
                }
                const choice2 = value2.choices[0];
                if ((choice2 == null ? void 0 : choice2.finish_reason) != null) {
                  finishReason = mapOpenRouterFinishReason(choice2.finish_reason);
                }
                if ((choice2 == null ? void 0 : choice2.delta) == null) {
                  return;
                }
                const delta = choice2.delta;
                const emitReasoningChunk = (chunkText, providerMetadata) => {
                  if (!reasoningStarted) {
                    reasoningId = openrouterResponseId || generateId2();
                    controller.enqueue({
                      providerMetadata,
                      type: "reasoning-start",
                      id: reasoningId
                    });
                    reasoningStarted = true;
                  }
                  controller.enqueue({
                    providerMetadata,
                    type: "reasoning-delta",
                    delta: chunkText,
                    id: reasoningId || generateId2()
                  });
                };
                if (delta.reasoning_details && delta.reasoning_details.length > 0) {
                  for (const detail of delta.reasoning_details) {
                    if (detail.type === "reasoning.text") {
                      const lastDetail = accumulatedReasoningDetails[accumulatedReasoningDetails.length - 1];
                      if ((lastDetail == null ? void 0 : lastDetail.type) === "reasoning.text") {
                        lastDetail.text = (lastDetail.text || "") + (detail.text || "");
                        lastDetail.signature = lastDetail.signature || detail.signature;
                        lastDetail.format = lastDetail.format || detail.format;
                      } else {
                        accumulatedReasoningDetails.push(__spreadValues({}, detail));
                      }
                    } else {
                      accumulatedReasoningDetails.push(detail);
                    }
                  }
                  const reasoningMetadata = {
                    openrouter: {
                      reasoning_details: delta.reasoning_details
                    }
                  };
                  for (const detail of delta.reasoning_details) {
                    switch (detail.type) {
                      case "reasoning.text": {
                        if (detail.text) {
                          emitReasoningChunk(detail.text, reasoningMetadata);
                        }
                        break;
                      }
                      case "reasoning.encrypted": {
                        if (detail.data) {
                          emitReasoningChunk("[REDACTED]", reasoningMetadata);
                        }
                        break;
                      }
                      case "reasoning.summary": {
                        if (detail.summary) {
                          emitReasoningChunk(detail.summary, reasoningMetadata);
                        }
                        break;
                      }
                      default: {
                        detail;
                        break;
                      }
                    }
                  }
                } else if (delta.reasoning) {
                  emitReasoningChunk(delta.reasoning);
                }
                if (delta.content) {
                  if (reasoningStarted && !textStarted) {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: reasoningId || generateId2()
                    });
                    reasoningStarted = false;
                  }
                  if (!textStarted) {
                    textId = openrouterResponseId || generateId2();
                    controller.enqueue({
                      type: "text-start",
                      id: textId
                    });
                    textStarted = true;
                  }
                  controller.enqueue({
                    type: "text-delta",
                    delta: delta.content,
                    id: textId || generateId2()
                  });
                }
                if (delta.annotations) {
                  for (const annotation of delta.annotations) {
                    if (annotation.type === "url_citation") {
                      controller.enqueue({
                        type: "source",
                        sourceType: "url",
                        id: annotation.url_citation.url,
                        url: annotation.url_citation.url,
                        title: (_d = annotation.url_citation.title) != null ? _d : "",
                        providerMetadata: {
                          openrouter: {
                            content: (_e = annotation.url_citation.content) != null ? _e : "",
                            startIndex: (_f = annotation.url_citation.start_index) != null ? _f : 0,
                            endIndex: (_g = annotation.url_citation.end_index) != null ? _g : 0
                          }
                        }
                      });
                    } else if (annotation.type === "file") {
                      const file = annotation.file;
                      if (file && typeof file === "object" && "hash" in file && "name" in file) {
                        accumulatedFileAnnotations.push(
                          annotation
                        );
                      }
                    }
                  }
                }
                if (delta.tool_calls != null) {
                  for (const toolCallDelta of delta.tool_calls) {
                    const index = (_h = toolCallDelta.index) != null ? _h : toolCalls.length - 1;
                    if (toolCalls[index] == null) {
                      if (toolCallDelta.type !== "function") {
                        throw new InvalidResponseDataError2({
                          data: toolCallDelta,
                          message: `Expected 'function' type.`
                        });
                      }
                      if (toolCallDelta.id == null) {
                        throw new InvalidResponseDataError2({
                          data: toolCallDelta,
                          message: `Expected 'id' to be a string.`
                        });
                      }
                      if (((_i = toolCallDelta.function) == null ? void 0 : _i.name) == null) {
                        throw new InvalidResponseDataError2({
                          data: toolCallDelta,
                          message: `Expected 'function.name' to be a string.`
                        });
                      }
                      toolCalls[index] = {
                        id: toolCallDelta.id,
                        type: "function",
                        function: {
                          name: toolCallDelta.function.name,
                          arguments: (_j = toolCallDelta.function.arguments) != null ? _j : ""
                        },
                        inputStarted: false,
                        sent: false
                      };
                      const toolCall2 = toolCalls[index];
                      if (toolCall2 == null) {
                        throw new InvalidResponseDataError2({
                          data: { index, toolCallsLength: toolCalls.length },
                          message: `Tool call at index ${index} is missing after creation.`
                        });
                      }
                      if (((_k = toolCall2.function) == null ? void 0 : _k.name) != null && ((_l = toolCall2.function) == null ? void 0 : _l.arguments) != null && isParsableJson2(toolCall2.function.arguments)) {
                        toolCall2.inputStarted = true;
                        controller.enqueue({
                          type: "tool-input-start",
                          id: toolCall2.id,
                          toolName: toolCall2.function.name
                        });
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: toolCall2.id,
                          delta: toolCall2.function.arguments
                        });
                        controller.enqueue({
                          type: "tool-input-end",
                          id: toolCall2.id
                        });
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: toolCall2.id,
                          toolName: toolCall2.function.name,
                          input: toolCall2.function.arguments,
                          providerMetadata: !reasoningDetailsAttachedToToolCall ? {
                            openrouter: {
                              reasoning_details: accumulatedReasoningDetails
                            }
                          } : void 0
                        });
                        reasoningDetailsAttachedToToolCall = true;
                        toolCall2.sent = true;
                      }
                      continue;
                    }
                    const toolCall = toolCalls[index];
                    if (toolCall == null) {
                      throw new InvalidResponseDataError2({
                        data: {
                          index,
                          toolCallsLength: toolCalls.length,
                          toolCallDelta
                        },
                        message: `Tool call at index ${index} is missing during merge.`
                      });
                    }
                    if (!toolCall.inputStarted) {
                      toolCall.inputStarted = true;
                      controller.enqueue({
                        type: "tool-input-start",
                        id: toolCall.id,
                        toolName: toolCall.function.name
                      });
                    }
                    if (((_m = toolCallDelta.function) == null ? void 0 : _m.arguments) != null) {
                      toolCall.function.arguments += (_o = (_n = toolCallDelta.function) == null ? void 0 : _n.arguments) != null ? _o : "";
                    }
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.id,
                      delta: (_p = toolCallDelta.function.arguments) != null ? _p : ""
                    });
                    if (((_q = toolCall.function) == null ? void 0 : _q.name) != null && ((_r = toolCall.function) == null ? void 0 : _r.arguments) != null && isParsableJson2(toolCall.function.arguments)) {
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: (_s = toolCall.id) != null ? _s : generateId2(),
                        toolName: toolCall.function.name,
                        input: toolCall.function.arguments,
                        providerMetadata: !reasoningDetailsAttachedToToolCall ? {
                          openrouter: {
                            reasoning_details: accumulatedReasoningDetails
                          }
                        } : void 0
                      });
                      reasoningDetailsAttachedToToolCall = true;
                      toolCall.sent = true;
                    }
                  }
                }
                if (delta.images != null) {
                  for (const image of delta.images) {
                    controller.enqueue({
                      type: "file",
                      mediaType: getMediaType(image.image_url.url, "image/jpeg"),
                      data: getBase64FromDataUrl(image.image_url.url)
                    });
                  }
                }
              },
              flush(controller) {
                var _a173;
                const hasToolCalls = toolCalls.length > 0;
                const hasEncryptedReasoning = accumulatedReasoningDetails.some(
                  (d) => d.type === "reasoning.encrypted" && d.data
                );
                if (hasToolCalls && hasEncryptedReasoning && finishReason.unified === "stop") {
                  finishReason = createFinishReason("tool-calls", finishReason.raw);
                }
                if (finishReason.unified === "tool-calls") {
                  for (const toolCall of toolCalls) {
                    if (toolCall && !toolCall.sent) {
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: (_a173 = toolCall.id) != null ? _a173 : generateId2(),
                        toolName: toolCall.function.name,
                        // Coerce invalid arguments to an empty JSON object
                        input: isParsableJson2(toolCall.function.arguments) ? toolCall.function.arguments : "{}",
                        providerMetadata: !reasoningDetailsAttachedToToolCall ? {
                          openrouter: {
                            reasoning_details: accumulatedReasoningDetails
                          }
                        } : void 0
                      });
                      reasoningDetailsAttachedToToolCall = true;
                      toolCall.sent = true;
                    }
                  }
                }
                if (reasoningStarted) {
                  controller.enqueue({
                    type: "reasoning-end",
                    id: reasoningId || generateId2()
                  });
                }
                if (textStarted) {
                  controller.enqueue({
                    type: "text-end",
                    id: textId || generateId2()
                  });
                }
                const openrouterMetadata = {
                  usage: openrouterUsage
                };
                if (provider !== void 0) {
                  openrouterMetadata.provider = provider;
                }
                if (accumulatedReasoningDetails.length > 0) {
                  openrouterMetadata.reasoning_details = accumulatedReasoningDetails;
                }
                if (accumulatedFileAnnotations.length > 0) {
                  openrouterMetadata.annotations = accumulatedFileAnnotations;
                }
                usage.raw = rawUsage;
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage,
                  providerMetadata: {
                    openrouter: openrouterMetadata
                  }
                });
              }
            })
          ),
          warnings: [],
          request: { body: args2 },
          response: { headers: responseHeaders }
        };
      }
    };
    OpenRouterCompletionChunkSchema = z89.union([
      z89.object({
        id: z89.string().optional(),
        model: z89.string().optional(),
        provider: z89.string().optional(),
        choices: z89.array(
          z89.object({
            text: z89.string(),
            reasoning: z89.string().nullish().optional(),
            reasoning_details: ReasoningDetailArraySchema.nullish(),
            finish_reason: z89.string().nullish(),
            index: z89.number().nullish(),
            logprobs: z89.object({
              tokens: z89.array(z89.string()),
              token_logprobs: z89.array(z89.number()),
              top_logprobs: z89.array(z89.record(z89.string(), z89.number())).nullable()
            }).passthrough().nullable().optional()
          }).passthrough()
        ),
        usage: z89.object({
          prompt_tokens: z89.number(),
          prompt_tokens_details: z89.object({
            cached_tokens: z89.number()
          }).passthrough().nullish(),
          completion_tokens: z89.number(),
          completion_tokens_details: z89.object({
            reasoning_tokens: z89.number()
          }).passthrough().nullish(),
          total_tokens: z89.number(),
          cost: z89.number().optional(),
          cost_details: z89.object({
            upstream_inference_cost: z89.number().nullish()
          }).passthrough().nullish()
        }).passthrough().nullish()
      }).passthrough(),
      OpenRouterErrorResponseSchema
    ]);
    OpenRouterCompletionLanguageModel = class {
      constructor(modelId, settings, config2) {
        this.specificationVersion = "v3";
        this.provider = "openrouter";
        this.supportsImageUrls = true;
        this.supportedUrls = {
          "image/*": [
            /^data:image\/[a-zA-Z]+;base64,/,
            /^https?:\/\/.+\.(jpg|jpeg|png|gif|webp)$/i
          ],
          "text/*": [/^data:text\//, /^https?:\/\/.+$/],
          "application/*": [/^data:application\//, /^https?:\/\/.+$/]
        };
        this.defaultObjectGenerationMode = void 0;
        this.modelId = modelId;
        this.settings = settings;
        this.config = config2;
      }
      getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        frequencyPenalty,
        presencePenalty,
        seed,
        responseFormat,
        topK,
        stopSequences,
        tools,
        toolChoice
      }) {
        const { prompt: completionPrompt } = convertToOpenRouterCompletionPrompt({
          prompt,
          inputFormat: "prompt"
        });
        if (tools == null ? void 0 : tools.length) {
          throw new UnsupportedFunctionalityError2({
            functionality: "tools"
          });
        }
        if (toolChoice) {
          throw new UnsupportedFunctionalityError2({
            functionality: "toolChoice"
          });
        }
        return __spreadValues(__spreadValues({
          // model id:
          model: this.modelId,
          models: this.settings.models,
          // model specific settings:
          logit_bias: this.settings.logitBias,
          logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : void 0 : void 0,
          suffix: this.settings.suffix,
          user: this.settings.user,
          // standardized settings:
          max_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          frequency_penalty: frequencyPenalty,
          presence_penalty: presencePenalty,
          seed,
          stop: stopSequences,
          response_format: responseFormat,
          top_k: topK,
          // prompt:
          prompt: completionPrompt,
          // OpenRouter specific settings:
          include_reasoning: this.settings.includeReasoning,
          reasoning: this.settings.reasoning
        }, this.config.extraBody), this.settings.extraBody);
      }
      async doGenerate(options) {
        var _a163, _b162, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B;
        const providerOptions = options.providerOptions || {};
        const openrouterOptions = providerOptions.openrouter || {};
        const args2 = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
        const { value: response, responseHeaders } = await postJsonToApi2({
          url: this.config.url({
            path: "/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders2(this.config.headers(), options.headers),
          body: args2,
          failedResponseHandler: openrouterFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler2(
            OpenRouterCompletionChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        if ("error" in response) {
          const errorData = response.error;
          throw new APICallError2({
            message: errorData.message,
            url: this.config.url({
              path: "/completions",
              modelId: this.modelId
            }),
            requestBodyValues: args2,
            statusCode: 200,
            responseHeaders,
            data: errorData
          });
        }
        const choice2 = response.choices[0];
        if (!choice2) {
          throw new NoContentGeneratedError2({
            message: "No choice in OpenRouter completion response"
          });
        }
        return {
          content: [
            {
              type: "text",
              text: (_a163 = choice2.text) != null ? _a163 : ""
            }
          ],
          finishReason: mapOpenRouterFinishReason(choice2.finish_reason),
          usage: {
            inputTokens: {
              total: (_c = (_b162 = response.usage) == null ? void 0 : _b162.prompt_tokens) != null ? _c : 0,
              noCache: void 0,
              cacheRead: (_f = (_e = (_d = response.usage) == null ? void 0 : _d.prompt_tokens_details) == null ? void 0 : _e.cached_tokens) != null ? _f : void 0,
              cacheWrite: void 0
            },
            outputTokens: {
              total: (_h = (_g = response.usage) == null ? void 0 : _g.completion_tokens) != null ? _h : 0,
              text: void 0,
              reasoning: (_k = (_j = (_i = response.usage) == null ? void 0 : _i.completion_tokens_details) == null ? void 0 : _j.reasoning_tokens) != null ? _k : void 0
            },
            raw: (_l = response.usage) != null ? _l : void 0
          },
          warnings: [],
          providerMetadata: {
            openrouter: OpenRouterProviderMetadataSchema.parse({
              provider: (_m = response.provider) != null ? _m : "",
              usage: __spreadValues(__spreadValues(__spreadValues(__spreadValues({
                promptTokens: (_o = (_n = response.usage) == null ? void 0 : _n.prompt_tokens) != null ? _o : 0,
                completionTokens: (_q = (_p = response.usage) == null ? void 0 : _p.completion_tokens) != null ? _q : 0,
                totalTokens: ((_s = (_r = response.usage) == null ? void 0 : _r.prompt_tokens) != null ? _s : 0) + ((_u = (_t = response.usage) == null ? void 0 : _t.completion_tokens) != null ? _u : 0)
              }, ((_v = response.usage) == null ? void 0 : _v.cost) != null ? { cost: response.usage.cost } : {}), ((_x = (_w = response.usage) == null ? void 0 : _w.prompt_tokens_details) == null ? void 0 : _x.cached_tokens) != null ? {
                promptTokensDetails: {
                  cachedTokens: response.usage.prompt_tokens_details.cached_tokens
                }
              } : {}), ((_z = (_y = response.usage) == null ? void 0 : _y.completion_tokens_details) == null ? void 0 : _z.reasoning_tokens) != null ? {
                completionTokensDetails: {
                  reasoningTokens: response.usage.completion_tokens_details.reasoning_tokens
                }
              } : {}), ((_B = (_A = response.usage) == null ? void 0 : _A.cost_details) == null ? void 0 : _B.upstream_inference_cost) != null ? {
                costDetails: {
                  upstreamInferenceCost: response.usage.cost_details.upstream_inference_cost
                }
              } : {})
            })
          },
          response: {
            headers: responseHeaders
          }
        };
      }
      async doStream(options) {
        const providerOptions = options.providerOptions || {};
        const openrouterOptions = providerOptions.openrouter || {};
        const args2 = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
        const { value: response, responseHeaders } = await postJsonToApi2({
          url: this.config.url({
            path: "/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders2(this.config.headers(), options.headers),
          body: __spreadProps(__spreadValues({}, args2), {
            stream: true,
            // only include stream_options when in strict compatibility mode:
            stream_options: this.config.compatibility === "strict" ? { include_usage: true } : void 0
          }),
          failedResponseHandler: openrouterFailedResponseHandler,
          successfulResponseHandler: createEventSourceResponseHandler2(
            OpenRouterCompletionChunkSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        let finishReason = createFinishReason("other");
        const usage = {
          inputTokens: {
            total: void 0,
            noCache: void 0,
            cacheRead: void 0,
            cacheWrite: void 0
          },
          outputTokens: {
            total: void 0,
            text: void 0,
            reasoning: void 0
          },
          raw: void 0
        };
        const openrouterUsage = {};
        let provider;
        let rawUsage;
        return {
          stream: response.pipeThrough(
            new TransformStream({
              transform(chunk, controller) {
                var _a163, _b162, _c;
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  finishReason = createFinishReason("error");
                  controller.enqueue({ type: "error", error: chunk.error });
                  return;
                }
                const value2 = chunk.value;
                if ("error" in value2) {
                  finishReason = createFinishReason("error");
                  controller.enqueue({ type: "error", error: value2.error });
                  return;
                }
                if (value2.provider) {
                  provider = value2.provider;
                }
                if (value2.usage != null) {
                  usage.inputTokens.total = value2.usage.prompt_tokens;
                  usage.outputTokens.total = value2.usage.completion_tokens;
                  rawUsage = value2.usage;
                  openrouterUsage.promptTokens = value2.usage.prompt_tokens;
                  if (value2.usage.prompt_tokens_details) {
                    const cachedInputTokens = (_a163 = value2.usage.prompt_tokens_details.cached_tokens) != null ? _a163 : 0;
                    usage.inputTokens.cacheRead = cachedInputTokens;
                    openrouterUsage.promptTokensDetails = {
                      cachedTokens: cachedInputTokens
                    };
                  }
                  openrouterUsage.completionTokens = value2.usage.completion_tokens;
                  if (value2.usage.completion_tokens_details) {
                    const reasoningTokens = (_b162 = value2.usage.completion_tokens_details.reasoning_tokens) != null ? _b162 : 0;
                    usage.outputTokens.reasoning = reasoningTokens;
                    openrouterUsage.completionTokensDetails = {
                      reasoningTokens
                    };
                  }
                  if (value2.usage.cost != null) {
                    openrouterUsage.cost = value2.usage.cost;
                  }
                  openrouterUsage.totalTokens = value2.usage.total_tokens;
                  const upstreamInferenceCost = (_c = value2.usage.cost_details) == null ? void 0 : _c.upstream_inference_cost;
                  if (upstreamInferenceCost != null) {
                    openrouterUsage.costDetails = {
                      upstreamInferenceCost
                    };
                  }
                }
                const choice2 = value2.choices[0];
                if ((choice2 == null ? void 0 : choice2.finish_reason) != null) {
                  finishReason = mapOpenRouterFinishReason(choice2.finish_reason);
                }
                if ((choice2 == null ? void 0 : choice2.text) != null) {
                  controller.enqueue({
                    type: "text-delta",
                    delta: choice2.text,
                    id: generateId2()
                  });
                }
              },
              flush(controller) {
                usage.raw = rawUsage;
                const openrouterMetadata = {
                  usage: openrouterUsage
                };
                if (provider !== void 0) {
                  openrouterMetadata.provider = provider;
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage,
                  providerMetadata: {
                    openrouter: openrouterMetadata
                  }
                });
              }
            })
          ),
          response: {
            headers: responseHeaders
          }
        };
      }
    };
    openrouterEmbeddingUsageSchema = z97.object({
      prompt_tokens: z97.number(),
      total_tokens: z97.number(),
      cost: z97.number().optional()
    });
    openrouterEmbeddingDataSchema = z97.object({
      object: z97.literal("embedding"),
      embedding: z97.array(z97.number()),
      index: z97.number().optional()
    });
    OpenRouterEmbeddingResponseSchema = z97.object({
      id: z97.string().optional(),
      object: z97.literal("list"),
      data: z97.array(openrouterEmbeddingDataSchema),
      model: z97.string(),
      provider: z97.string().optional(),
      usage: openrouterEmbeddingUsageSchema.optional()
    });
    OpenRouterEmbeddingModel = class {
      constructor(modelId, settings, config2) {
        this.specificationVersion = "v3";
        this.provider = "openrouter";
        this.maxEmbeddingsPerCall = void 0;
        this.supportsParallelCalls = true;
        this.modelId = modelId;
        this.settings = settings;
        this.config = config2;
      }
      async doEmbed(options) {
        var _a163, _b162, _c, _d, _e, _f;
        const { values, abortSignal, headers } = options;
        const args2 = __spreadValues(__spreadValues({
          model: this.modelId,
          input: values,
          user: this.settings.user,
          provider: this.settings.provider
        }, this.config.extraBody), this.settings.extraBody);
        const { value: responseValue, responseHeaders } = await postJsonToApi2({
          url: this.config.url({
            path: "/embeddings",
            modelId: this.modelId
          }),
          headers: combineHeaders2(this.config.headers(), headers),
          body: args2,
          failedResponseHandler: openrouterFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler2(
            OpenRouterEmbeddingResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          embeddings: responseValue.data.map((item) => item.embedding),
          usage: responseValue.usage ? { tokens: responseValue.usage.prompt_tokens } : void 0,
          providerMetadata: {
            openrouter: OpenRouterProviderMetadataSchema.parse({
              provider: (_a163 = responseValue.provider) != null ? _a163 : "",
              usage: __spreadValues({
                promptTokens: (_c = (_b162 = responseValue.usage) == null ? void 0 : _b162.prompt_tokens) != null ? _c : 0,
                completionTokens: 0,
                totalTokens: (_e = (_d = responseValue.usage) == null ? void 0 : _d.total_tokens) != null ? _e : 0
              }, ((_f = responseValue.usage) == null ? void 0 : _f.cost) != null ? { cost: responseValue.usage.cost } : {})
            })
          },
          response: {
            headers: responseHeaders,
            body: responseValue
          },
          warnings: []
        };
      }
    };
    OpenRouter = class {
      /**
       * Creates a new OpenRouter provider instance.
       */
      constructor(options = {}) {
        var _a163, _b162;
        this.baseURL = (_b162 = withoutTrailingSlash2((_a163 = options.baseURL) != null ? _a163 : options.baseUrl)) != null ? _b162 : "https://openrouter.ai/api/v1";
        this.apiKey = options.apiKey;
        this.headers = options.headers;
        this.api_keys = options.api_keys;
      }
      get baseConfig() {
        return {
          baseURL: this.baseURL,
          headers: () => __spreadValues(__spreadValues({
            Authorization: `Bearer ${loadApiKey2({
              apiKey: this.apiKey,
              environmentVariableName: "OPENROUTER_API_KEY",
              description: "OpenRouter"
            })}`
          }, this.headers), this.api_keys && Object.keys(this.api_keys).length > 0 && {
            "X-Provider-API-Keys": JSON.stringify(this.api_keys)
          })
        };
      }
      chat(modelId, settings = {}) {
        return new OpenRouterChatLanguageModel(modelId, settings, __spreadProps(__spreadValues({
          provider: "openrouter.chat"
        }, this.baseConfig), {
          compatibility: "strict",
          url: ({ path: path24 }) => `${this.baseURL}${path24}`
        }));
      }
      completion(modelId, settings = {}) {
        return new OpenRouterCompletionLanguageModel(modelId, settings, __spreadProps(__spreadValues({
          provider: "openrouter.completion"
        }, this.baseConfig), {
          compatibility: "strict",
          url: ({ path: path24 }) => `${this.baseURL}${path24}`
        }));
      }
      textEmbeddingModel(modelId, settings = {}) {
        return new OpenRouterEmbeddingModel(modelId, settings, __spreadProps(__spreadValues({
          provider: "openrouter.embedding"
        }, this.baseConfig), {
          url: ({ path: path24 }) => `${this.baseURL}${path24}`
        }));
      }
      /**
       * @deprecated Use textEmbeddingModel instead
       */
      embedding(modelId, settings = {}) {
        return this.textEmbeddingModel(modelId, settings);
      }
    };
    OpenRouterImageResponseSchema = z107.object({
      id: z107.string().optional(),
      object: z107.string().optional(),
      created: z107.number().optional(),
      model: z107.string(),
      choices: z107.array(
        z107.object({
          index: z107.number(),
          message: z107.object({
            role: z107.string(),
            content: z107.string().nullable().optional(),
            images: z107.array(
              z107.object({
                type: z107.literal("image_url"),
                image_url: z107.object({
                  url: z107.string()
                })
              }).passthrough()
            ).optional()
          }).passthrough(),
          finish_reason: z107.string().nullable().optional()
        }).passthrough()
      ),
      usage: z107.object({
        prompt_tokens: z107.number(),
        completion_tokens: z107.number(),
        total_tokens: z107.number()
      }).passthrough().optional()
    }).passthrough();
    OpenRouterImageModel = class {
      constructor(modelId, settings, config2) {
        this.specificationVersion = "v3";
        this.provider = "openrouter";
        this.maxImagesPerCall = 1;
        this.modelId = modelId;
        this.settings = settings;
        this.config = config2;
      }
      async doGenerate(options) {
        var _a163;
        const {
          prompt,
          n,
          size,
          aspectRatio,
          seed,
          files,
          mask,
          abortSignal,
          headers,
          providerOptions
        } = options;
        const openrouterOptions = (providerOptions == null ? void 0 : providerOptions.openrouter) || {};
        const warnings = [];
        if (files !== void 0 && files.length > 0) {
          throw new UnsupportedFunctionalityError2({
            functionality: "image editing (files parameter)"
          });
        }
        if (mask !== void 0) {
          throw new UnsupportedFunctionalityError2({
            functionality: "image inpainting (mask parameter)"
          });
        }
        if (n > 1) {
          warnings.push({
            type: "unsupported",
            feature: "n > 1",
            details: `OpenRouter image generation returns 1 image per call. Requested ${n} images.`
          });
        }
        if (size !== void 0) {
          warnings.push({
            type: "unsupported",
            feature: "size",
            details: "Use aspectRatio instead. Size parameter is not supported by OpenRouter image generation."
          });
        }
        const imageConfig = aspectRatio !== void 0 ? { aspect_ratio: aspectRatio } : void 0;
        const body = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
          model: this.modelId,
          messages: [
            {
              role: "user",
              content: prompt != null ? prompt : ""
            }
          ],
          modalities: ["image", "text"]
        }, imageConfig !== void 0 && { image_config: imageConfig }), seed !== void 0 && { seed }), this.settings.user !== void 0 && { user: this.settings.user }), this.settings.provider !== void 0 && {
          provider: this.settings.provider
        }), this.config.extraBody), this.settings.extraBody), openrouterOptions);
        const { value: responseValue, responseHeaders } = await postJsonToApi2({
          url: this.config.url({
            path: "/chat/completions",
            modelId: this.modelId
          }),
          headers: combineHeaders2(this.config.headers(), headers),
          body,
          failedResponseHandler: openrouterFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler2(
            OpenRouterImageResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        const choice2 = responseValue.choices[0];
        if (!choice2) {
          throw new NoContentGeneratedError2({
            message: "No choice in response"
          });
        }
        const images = [];
        if ((_a163 = choice2.message) == null ? void 0 : _a163.images) {
          for (const image of choice2.message.images) {
            const dataUrl = image.image_url.url;
            images.push(getBase64FromDataUrl(dataUrl));
          }
        }
        const usage = responseValue.usage ? {
          inputTokens: responseValue.usage.prompt_tokens,
          outputTokens: responseValue.usage.completion_tokens,
          totalTokens: responseValue.usage.total_tokens
        } : void 0;
        return {
          images,
          warnings,
          response: {
            timestamp: /* @__PURE__ */ new Date(),
            modelId: responseValue.model,
            headers: responseHeaders
          },
          usage
        };
      }
    };
    VERSION22 = false ? "0.0.0-test" : "2.1.1";
    openrouter = createOpenRouter({
      compatibility: "strict"
      // strict for OpenRouter API
    });
  }
});

// node_modules/@ai-sdk/anthropic/dist/internal/index.mjs
import { z as z40 } from "zod/v4";
import { z as z213 } from "zod/v4";
import { z as z311 } from "zod/v4";
import { z as z411 } from "zod/v4";
import { z as z510 } from "zod/v4";
import { z as z610 } from "zod/v4";
import { z as z710 } from "zod/v4";
import { z as z810 } from "zod/v4";
import { z as z98 } from "zod/v4";
import { z as z108 } from "zod/v4";
import { z as z116 } from "zod/v4";
import { z as z126 } from "zod/v4";
import { z as z135 } from "zod/v4";
import { z as z145 } from "zod/v4";
import { z as z154 } from "zod/v4";
import { z as z164 } from "zod/v4";
import { z as z174 } from "zod/v4";
import { z as z184 } from "zod/v4";
import { z as z193 } from "zod/v4";
function getCacheControl3(providerMetadata) {
  var _a25;
  const anthropic2 = providerMetadata == null ? void 0 : providerMetadata.anthropic;
  const cacheControlValue = (_a25 = anthropic2 == null ? void 0 : anthropic2.cacheControl) != null ? _a25 : anthropic2 == null ? void 0 : anthropic2.cache_control;
  return cacheControlValue;
}
async function prepareTools6({
  tools,
  toolChoice,
  disableParallelToolUse,
  cacheControlValidator,
  supportsStructuredOutput
}) {
  var _a25;
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  const betas = /* @__PURE__ */ new Set();
  const validator = cacheControlValidator || new CacheControlValidator2();
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
  }
  const anthropicTools22 = [];
  for (const tool2 of tools) {
    switch (tool2.type) {
      case "function": {
        const cacheControl = validator.getCacheControl(tool2.providerOptions, {
          type: "tool definition",
          canCache: true
        });
        const anthropicOptions = (_a25 = tool2.providerOptions) == null ? void 0 : _a25.anthropic;
        const deferLoading = anthropicOptions == null ? void 0 : anthropicOptions.deferLoading;
        const allowedCallers = anthropicOptions == null ? void 0 : anthropicOptions.allowedCallers;
        anthropicTools22.push({
          name: tool2.name,
          description: tool2.description,
          input_schema: tool2.inputSchema,
          cache_control: cacheControl,
          ...supportsStructuredOutput === true && tool2.strict != null ? { strict: tool2.strict } : {},
          ...deferLoading != null ? { defer_loading: deferLoading } : {},
          ...allowedCallers != null ? { allowed_callers: allowedCallers } : {},
          ...tool2.inputExamples != null ? {
            input_examples: tool2.inputExamples.map(
              (example) => example.input
            )
          } : {}
        });
        if (supportsStructuredOutput === true) {
          betas.add("structured-outputs-2025-11-13");
        }
        if (tool2.inputExamples != null || allowedCallers != null) {
          betas.add("advanced-tool-use-2025-11-20");
        }
        break;
      }
      case "provider": {
        switch (tool2.id) {
          case "anthropic.code_execution_20250522": {
            betas.add("code-execution-2025-05-22");
            anthropicTools22.push({
              type: "code_execution_20250522",
              name: "code_execution",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.code_execution_20250825": {
            betas.add("code-execution-2025-08-25");
            anthropicTools22.push({
              type: "code_execution_20250825",
              name: "code_execution"
            });
            break;
          }
          case "anthropic.computer_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools22.push({
              name: "computer",
              type: "computer_20250124",
              display_width_px: tool2.args.displayWidthPx,
              display_height_px: tool2.args.displayHeightPx,
              display_number: tool2.args.displayNumber,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.computer_20251124": {
            betas.add("computer-use-2025-11-24");
            anthropicTools22.push({
              name: "computer",
              type: "computer_20251124",
              display_width_px: tool2.args.displayWidthPx,
              display_height_px: tool2.args.displayHeightPx,
              display_number: tool2.args.displayNumber,
              enable_zoom: tool2.args.enableZoom,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.computer_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools22.push({
              name: "computer",
              type: "computer_20241022",
              display_width_px: tool2.args.displayWidthPx,
              display_height_px: tool2.args.displayHeightPx,
              display_number: tool2.args.displayNumber,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools22.push({
              name: "str_replace_editor",
              type: "text_editor_20250124",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools22.push({
              name: "str_replace_editor",
              type: "text_editor_20241022",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250429": {
            betas.add("computer-use-2025-01-24");
            anthropicTools22.push({
              name: "str_replace_based_edit_tool",
              type: "text_editor_20250429",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250728": {
            const args2 = await validateTypes({
              value: tool2.args,
              schema: textEditor_20250728ArgsSchema2
            });
            anthropicTools22.push({
              name: "str_replace_based_edit_tool",
              type: "text_editor_20250728",
              max_characters: args2.maxCharacters,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.bash_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools22.push({
              name: "bash",
              type: "bash_20250124",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.bash_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools22.push({
              name: "bash",
              type: "bash_20241022",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.memory_20250818": {
            betas.add("context-management-2025-06-27");
            anthropicTools22.push({
              name: "memory",
              type: "memory_20250818"
            });
            break;
          }
          case "anthropic.web_fetch_20250910": {
            betas.add("web-fetch-2025-09-10");
            const args2 = await validateTypes({
              value: tool2.args,
              schema: webFetch_20250910ArgsSchema2
            });
            anthropicTools22.push({
              type: "web_fetch_20250910",
              name: "web_fetch",
              max_uses: args2.maxUses,
              allowed_domains: args2.allowedDomains,
              blocked_domains: args2.blockedDomains,
              citations: args2.citations,
              max_content_tokens: args2.maxContentTokens,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.web_search_20250305": {
            const args2 = await validateTypes({
              value: tool2.args,
              schema: webSearch_20250305ArgsSchema2
            });
            anthropicTools22.push({
              type: "web_search_20250305",
              name: "web_search",
              max_uses: args2.maxUses,
              allowed_domains: args2.allowedDomains,
              blocked_domains: args2.blockedDomains,
              user_location: args2.userLocation,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.tool_search_regex_20251119": {
            betas.add("advanced-tool-use-2025-11-20");
            anthropicTools22.push({
              type: "tool_search_tool_regex_20251119",
              name: "tool_search_tool_regex"
            });
            break;
          }
          case "anthropic.tool_search_bm25_20251119": {
            betas.add("advanced-tool-use-2025-11-20");
            anthropicTools22.push({
              type: "tool_search_tool_bm25_20251119",
              name: "tool_search_tool_bm25"
            });
            break;
          }
          default: {
            toolWarnings.push({
              type: "unsupported",
              feature: `provider-defined tool ${tool2.id}`
            });
            break;
          }
        }
        break;
      }
      default: {
        toolWarnings.push({
          type: "unsupported",
          feature: `tool ${tool2}`
        });
        break;
      }
    }
  }
  if (toolChoice == null) {
    return {
      tools: anthropicTools22,
      toolChoice: disableParallelToolUse ? { type: "auto", disable_parallel_tool_use: disableParallelToolUse } : void 0,
      toolWarnings,
      betas
    };
  }
  const type2 = toolChoice.type;
  switch (type2) {
    case "auto":
      return {
        tools: anthropicTools22,
        toolChoice: {
          type: "auto",
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    case "required":
      return {
        tools: anthropicTools22,
        toolChoice: {
          type: "any",
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    case "none":
      return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
    case "tool":
      return {
        tools: anthropicTools22,
        toolChoice: {
          type: "tool",
          name: toolChoice.toolName,
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    default: {
      const _exhaustiveCheck = type2;
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
var anthropicErrorDataSchema2, anthropicFailedResponseHandler2, anthropicMessagesResponseSchema2, anthropicMessagesChunkSchema2, anthropicReasoningMetadataSchema2, anthropicFilePartProviderOptions2, anthropicProviderOptions2, MAX_CACHE_BREAKPOINTS2, CacheControlValidator2, textEditor_20250728ArgsSchema2, textEditor_20250728InputSchema2, factory8, textEditor_202507282, webSearch_20250305ArgsSchema2, webSearch_20250305OutputSchema2, webSearch_20250305InputSchema2, factory22, webSearch_202503052, webFetch_20250910ArgsSchema2, webFetch_20250910OutputSchema2, webFetch_20250910InputSchema2, factory32, webFetch_202509102, codeExecution_20250522OutputSchema2, codeExecution_20250522InputSchema2, factory42, codeExecution_202505222, codeExecution_20250825OutputSchema2, codeExecution_20250825InputSchema2, factory52, codeExecution_202508252, toolSearchRegex_20251119OutputSchema2, toolSearchRegex_20251119InputSchema2, factory62, toolSearchRegex_202511192, bash_20241022InputSchema2, bash_202410222, bash_20250124InputSchema2, bash_202501242, computer_20241022InputSchema2, computer_202410222, computer_20250124InputSchema2, computer_202501242, computer_20251124InputSchema2, computer_202511242, memory_20250818InputSchema2, memory_202508182, textEditor_20241022InputSchema2, textEditor_202410222, textEditor_20250124InputSchema2, textEditor_202501242, textEditor_20250429InputSchema2, textEditor_202504292, toolSearchBm25_20251119OutputSchema2, toolSearchBm25_20251119InputSchema2, factory72, toolSearchBm25_202511192, anthropicTools2;
var init_internal = __esm({
  "node_modules/@ai-sdk/anthropic/dist/internal/index.mjs"() {
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    anthropicErrorDataSchema2 = lazySchema(
      () => zodSchema(
        z40.object({
          type: z40.literal("error"),
          error: z40.object({
            type: z40.string(),
            message: z40.string()
          })
        })
      )
    );
    anthropicFailedResponseHandler2 = createJsonErrorResponseHandler({
      errorSchema: anthropicErrorDataSchema2,
      errorToMessage: (data) => data.error.message
    });
    anthropicMessagesResponseSchema2 = lazySchema(
      () => zodSchema(
        z213.object({
          type: z213.literal("message"),
          id: z213.string().nullish(),
          model: z213.string().nullish(),
          content: z213.array(
            z213.discriminatedUnion("type", [
              z213.object({
                type: z213.literal("text"),
                text: z213.string(),
                citations: z213.array(
                  z213.discriminatedUnion("type", [
                    z213.object({
                      type: z213.literal("web_search_result_location"),
                      cited_text: z213.string(),
                      url: z213.string(),
                      title: z213.string(),
                      encrypted_index: z213.string()
                    }),
                    z213.object({
                      type: z213.literal("page_location"),
                      cited_text: z213.string(),
                      document_index: z213.number(),
                      document_title: z213.string().nullable(),
                      start_page_number: z213.number(),
                      end_page_number: z213.number()
                    }),
                    z213.object({
                      type: z213.literal("char_location"),
                      cited_text: z213.string(),
                      document_index: z213.number(),
                      document_title: z213.string().nullable(),
                      start_char_index: z213.number(),
                      end_char_index: z213.number()
                    })
                  ])
                ).optional()
              }),
              z213.object({
                type: z213.literal("thinking"),
                thinking: z213.string(),
                signature: z213.string()
              }),
              z213.object({
                type: z213.literal("redacted_thinking"),
                data: z213.string()
              }),
              z213.object({
                type: z213.literal("tool_use"),
                id: z213.string(),
                name: z213.string(),
                input: z213.unknown(),
                // Programmatic tool calling: caller info when triggered from code execution
                caller: z213.union([
                  z213.object({
                    type: z213.literal("code_execution_20250825"),
                    tool_id: z213.string()
                  }),
                  z213.object({
                    type: z213.literal("direct")
                  })
                ]).optional()
              }),
              z213.object({
                type: z213.literal("server_tool_use"),
                id: z213.string(),
                name: z213.string(),
                input: z213.record(z213.string(), z213.unknown()).nullish()
              }),
              z213.object({
                type: z213.literal("mcp_tool_use"),
                id: z213.string(),
                name: z213.string(),
                input: z213.unknown(),
                server_name: z213.string()
              }),
              z213.object({
                type: z213.literal("mcp_tool_result"),
                tool_use_id: z213.string(),
                is_error: z213.boolean(),
                content: z213.array(
                  z213.union([
                    z213.string(),
                    z213.object({ type: z213.literal("text"), text: z213.string() })
                  ])
                )
              }),
              z213.object({
                type: z213.literal("web_fetch_tool_result"),
                tool_use_id: z213.string(),
                content: z213.union([
                  z213.object({
                    type: z213.literal("web_fetch_result"),
                    url: z213.string(),
                    retrieved_at: z213.string(),
                    content: z213.object({
                      type: z213.literal("document"),
                      title: z213.string().nullable(),
                      citations: z213.object({ enabled: z213.boolean() }).optional(),
                      source: z213.union([
                        z213.object({
                          type: z213.literal("base64"),
                          media_type: z213.literal("application/pdf"),
                          data: z213.string()
                        }),
                        z213.object({
                          type: z213.literal("text"),
                          media_type: z213.literal("text/plain"),
                          data: z213.string()
                        })
                      ])
                    })
                  }),
                  z213.object({
                    type: z213.literal("web_fetch_tool_result_error"),
                    error_code: z213.string()
                  })
                ])
              }),
              z213.object({
                type: z213.literal("web_search_tool_result"),
                tool_use_id: z213.string(),
                content: z213.union([
                  z213.array(
                    z213.object({
                      type: z213.literal("web_search_result"),
                      url: z213.string(),
                      title: z213.string(),
                      encrypted_content: z213.string(),
                      page_age: z213.string().nullish()
                    })
                  ),
                  z213.object({
                    type: z213.literal("web_search_tool_result_error"),
                    error_code: z213.string()
                  })
                ])
              }),
              // code execution results for code_execution_20250522 tool:
              z213.object({
                type: z213.literal("code_execution_tool_result"),
                tool_use_id: z213.string(),
                content: z213.union([
                  z213.object({
                    type: z213.literal("code_execution_result"),
                    stdout: z213.string(),
                    stderr: z213.string(),
                    return_code: z213.number(),
                    content: z213.array(
                      z213.object({
                        type: z213.literal("code_execution_output"),
                        file_id: z213.string()
                      })
                    ).optional().default([])
                  }),
                  z213.object({
                    type: z213.literal("code_execution_tool_result_error"),
                    error_code: z213.string()
                  })
                ])
              }),
              // bash code execution results for code_execution_20250825 tool:
              z213.object({
                type: z213.literal("bash_code_execution_tool_result"),
                tool_use_id: z213.string(),
                content: z213.discriminatedUnion("type", [
                  z213.object({
                    type: z213.literal("bash_code_execution_result"),
                    content: z213.array(
                      z213.object({
                        type: z213.literal("bash_code_execution_output"),
                        file_id: z213.string()
                      })
                    ),
                    stdout: z213.string(),
                    stderr: z213.string(),
                    return_code: z213.number()
                  }),
                  z213.object({
                    type: z213.literal("bash_code_execution_tool_result_error"),
                    error_code: z213.string()
                  })
                ])
              }),
              // text editor code execution results for code_execution_20250825 tool:
              z213.object({
                type: z213.literal("text_editor_code_execution_tool_result"),
                tool_use_id: z213.string(),
                content: z213.discriminatedUnion("type", [
                  z213.object({
                    type: z213.literal("text_editor_code_execution_tool_result_error"),
                    error_code: z213.string()
                  }),
                  z213.object({
                    type: z213.literal("text_editor_code_execution_view_result"),
                    content: z213.string(),
                    file_type: z213.string(),
                    num_lines: z213.number().nullable(),
                    start_line: z213.number().nullable(),
                    total_lines: z213.number().nullable()
                  }),
                  z213.object({
                    type: z213.literal("text_editor_code_execution_create_result"),
                    is_file_update: z213.boolean()
                  }),
                  z213.object({
                    type: z213.literal(
                      "text_editor_code_execution_str_replace_result"
                    ),
                    lines: z213.array(z213.string()).nullable(),
                    new_lines: z213.number().nullable(),
                    new_start: z213.number().nullable(),
                    old_lines: z213.number().nullable(),
                    old_start: z213.number().nullable()
                  })
                ])
              }),
              // tool search tool results for tool_search_tool_regex_20251119 and tool_search_tool_bm25_20251119:
              z213.object({
                type: z213.literal("tool_search_tool_result"),
                tool_use_id: z213.string(),
                content: z213.union([
                  z213.object({
                    type: z213.literal("tool_search_tool_search_result"),
                    tool_references: z213.array(
                      z213.object({
                        type: z213.literal("tool_reference"),
                        tool_name: z213.string()
                      })
                    )
                  }),
                  z213.object({
                    type: z213.literal("tool_search_tool_result_error"),
                    error_code: z213.string()
                  })
                ])
              })
            ])
          ),
          stop_reason: z213.string().nullish(),
          stop_sequence: z213.string().nullish(),
          usage: z213.looseObject({
            input_tokens: z213.number(),
            output_tokens: z213.number(),
            cache_creation_input_tokens: z213.number().nullish(),
            cache_read_input_tokens: z213.number().nullish()
          }),
          container: z213.object({
            expires_at: z213.string(),
            id: z213.string(),
            skills: z213.array(
              z213.object({
                type: z213.union([z213.literal("anthropic"), z213.literal("custom")]),
                skill_id: z213.string(),
                version: z213.string()
              })
            ).nullish()
          }).nullish(),
          context_management: z213.object({
            applied_edits: z213.array(
              z213.union([
                z213.object({
                  type: z213.literal("clear_tool_uses_20250919"),
                  cleared_tool_uses: z213.number(),
                  cleared_input_tokens: z213.number()
                }),
                z213.object({
                  type: z213.literal("clear_thinking_20251015"),
                  cleared_thinking_turns: z213.number(),
                  cleared_input_tokens: z213.number()
                })
              ])
            )
          }).nullish()
        })
      )
    );
    anthropicMessagesChunkSchema2 = lazySchema(
      () => zodSchema(
        z213.discriminatedUnion("type", [
          z213.object({
            type: z213.literal("message_start"),
            message: z213.object({
              id: z213.string().nullish(),
              model: z213.string().nullish(),
              role: z213.string().nullish(),
              usage: z213.looseObject({
                input_tokens: z213.number(),
                cache_creation_input_tokens: z213.number().nullish(),
                cache_read_input_tokens: z213.number().nullish()
              }),
              // Programmatic tool calling: content may be pre-populated for deferred tool calls
              content: z213.array(
                z213.discriminatedUnion("type", [
                  z213.object({
                    type: z213.literal("tool_use"),
                    id: z213.string(),
                    name: z213.string(),
                    input: z213.unknown(),
                    caller: z213.union([
                      z213.object({
                        type: z213.literal("code_execution_20250825"),
                        tool_id: z213.string()
                      }),
                      z213.object({
                        type: z213.literal("direct")
                      })
                    ]).optional()
                  })
                ])
              ).nullish(),
              stop_reason: z213.string().nullish(),
              container: z213.object({
                expires_at: z213.string(),
                id: z213.string()
              }).nullish()
            })
          }),
          z213.object({
            type: z213.literal("content_block_start"),
            index: z213.number(),
            content_block: z213.discriminatedUnion("type", [
              z213.object({
                type: z213.literal("text"),
                text: z213.string()
              }),
              z213.object({
                type: z213.literal("thinking"),
                thinking: z213.string()
              }),
              z213.object({
                type: z213.literal("tool_use"),
                id: z213.string(),
                name: z213.string(),
                // Programmatic tool calling: input may be present directly for deferred tool calls
                input: z213.record(z213.string(), z213.unknown()).optional(),
                // Programmatic tool calling: caller info when triggered from code execution
                caller: z213.union([
                  z213.object({
                    type: z213.literal("code_execution_20250825"),
                    tool_id: z213.string()
                  }),
                  z213.object({
                    type: z213.literal("direct")
                  })
                ]).optional()
              }),
              z213.object({
                type: z213.literal("redacted_thinking"),
                data: z213.string()
              }),
              z213.object({
                type: z213.literal("server_tool_use"),
                id: z213.string(),
                name: z213.string(),
                input: z213.record(z213.string(), z213.unknown()).nullish()
              }),
              z213.object({
                type: z213.literal("mcp_tool_use"),
                id: z213.string(),
                name: z213.string(),
                input: z213.unknown(),
                server_name: z213.string()
              }),
              z213.object({
                type: z213.literal("mcp_tool_result"),
                tool_use_id: z213.string(),
                is_error: z213.boolean(),
                content: z213.array(
                  z213.union([
                    z213.string(),
                    z213.object({ type: z213.literal("text"), text: z213.string() })
                  ])
                )
              }),
              z213.object({
                type: z213.literal("web_fetch_tool_result"),
                tool_use_id: z213.string(),
                content: z213.union([
                  z213.object({
                    type: z213.literal("web_fetch_result"),
                    url: z213.string(),
                    retrieved_at: z213.string(),
                    content: z213.object({
                      type: z213.literal("document"),
                      title: z213.string().nullable(),
                      citations: z213.object({ enabled: z213.boolean() }).optional(),
                      source: z213.union([
                        z213.object({
                          type: z213.literal("base64"),
                          media_type: z213.literal("application/pdf"),
                          data: z213.string()
                        }),
                        z213.object({
                          type: z213.literal("text"),
                          media_type: z213.literal("text/plain"),
                          data: z213.string()
                        })
                      ])
                    })
                  }),
                  z213.object({
                    type: z213.literal("web_fetch_tool_result_error"),
                    error_code: z213.string()
                  })
                ])
              }),
              z213.object({
                type: z213.literal("web_search_tool_result"),
                tool_use_id: z213.string(),
                content: z213.union([
                  z213.array(
                    z213.object({
                      type: z213.literal("web_search_result"),
                      url: z213.string(),
                      title: z213.string(),
                      encrypted_content: z213.string(),
                      page_age: z213.string().nullish()
                    })
                  ),
                  z213.object({
                    type: z213.literal("web_search_tool_result_error"),
                    error_code: z213.string()
                  })
                ])
              }),
              // code execution results for code_execution_20250522 tool:
              z213.object({
                type: z213.literal("code_execution_tool_result"),
                tool_use_id: z213.string(),
                content: z213.union([
                  z213.object({
                    type: z213.literal("code_execution_result"),
                    stdout: z213.string(),
                    stderr: z213.string(),
                    return_code: z213.number(),
                    content: z213.array(
                      z213.object({
                        type: z213.literal("code_execution_output"),
                        file_id: z213.string()
                      })
                    ).optional().default([])
                  }),
                  z213.object({
                    type: z213.literal("code_execution_tool_result_error"),
                    error_code: z213.string()
                  })
                ])
              }),
              // bash code execution results for code_execution_20250825 tool:
              z213.object({
                type: z213.literal("bash_code_execution_tool_result"),
                tool_use_id: z213.string(),
                content: z213.discriminatedUnion("type", [
                  z213.object({
                    type: z213.literal("bash_code_execution_result"),
                    content: z213.array(
                      z213.object({
                        type: z213.literal("bash_code_execution_output"),
                        file_id: z213.string()
                      })
                    ),
                    stdout: z213.string(),
                    stderr: z213.string(),
                    return_code: z213.number()
                  }),
                  z213.object({
                    type: z213.literal("bash_code_execution_tool_result_error"),
                    error_code: z213.string()
                  })
                ])
              }),
              // text editor code execution results for code_execution_20250825 tool:
              z213.object({
                type: z213.literal("text_editor_code_execution_tool_result"),
                tool_use_id: z213.string(),
                content: z213.discriminatedUnion("type", [
                  z213.object({
                    type: z213.literal("text_editor_code_execution_tool_result_error"),
                    error_code: z213.string()
                  }),
                  z213.object({
                    type: z213.literal("text_editor_code_execution_view_result"),
                    content: z213.string(),
                    file_type: z213.string(),
                    num_lines: z213.number().nullable(),
                    start_line: z213.number().nullable(),
                    total_lines: z213.number().nullable()
                  }),
                  z213.object({
                    type: z213.literal("text_editor_code_execution_create_result"),
                    is_file_update: z213.boolean()
                  }),
                  z213.object({
                    type: z213.literal(
                      "text_editor_code_execution_str_replace_result"
                    ),
                    lines: z213.array(z213.string()).nullable(),
                    new_lines: z213.number().nullable(),
                    new_start: z213.number().nullable(),
                    old_lines: z213.number().nullable(),
                    old_start: z213.number().nullable()
                  })
                ])
              }),
              // tool search tool results for tool_search_tool_regex_20251119 and tool_search_tool_bm25_20251119:
              z213.object({
                type: z213.literal("tool_search_tool_result"),
                tool_use_id: z213.string(),
                content: z213.union([
                  z213.object({
                    type: z213.literal("tool_search_tool_search_result"),
                    tool_references: z213.array(
                      z213.object({
                        type: z213.literal("tool_reference"),
                        tool_name: z213.string()
                      })
                    )
                  }),
                  z213.object({
                    type: z213.literal("tool_search_tool_result_error"),
                    error_code: z213.string()
                  })
                ])
              })
            ])
          }),
          z213.object({
            type: z213.literal("content_block_delta"),
            index: z213.number(),
            delta: z213.discriminatedUnion("type", [
              z213.object({
                type: z213.literal("input_json_delta"),
                partial_json: z213.string()
              }),
              z213.object({
                type: z213.literal("text_delta"),
                text: z213.string()
              }),
              z213.object({
                type: z213.literal("thinking_delta"),
                thinking: z213.string()
              }),
              z213.object({
                type: z213.literal("signature_delta"),
                signature: z213.string()
              }),
              z213.object({
                type: z213.literal("citations_delta"),
                citation: z213.discriminatedUnion("type", [
                  z213.object({
                    type: z213.literal("web_search_result_location"),
                    cited_text: z213.string(),
                    url: z213.string(),
                    title: z213.string(),
                    encrypted_index: z213.string()
                  }),
                  z213.object({
                    type: z213.literal("page_location"),
                    cited_text: z213.string(),
                    document_index: z213.number(),
                    document_title: z213.string().nullable(),
                    start_page_number: z213.number(),
                    end_page_number: z213.number()
                  }),
                  z213.object({
                    type: z213.literal("char_location"),
                    cited_text: z213.string(),
                    document_index: z213.number(),
                    document_title: z213.string().nullable(),
                    start_char_index: z213.number(),
                    end_char_index: z213.number()
                  })
                ])
              })
            ])
          }),
          z213.object({
            type: z213.literal("content_block_stop"),
            index: z213.number()
          }),
          z213.object({
            type: z213.literal("error"),
            error: z213.object({
              type: z213.string(),
              message: z213.string()
            })
          }),
          z213.object({
            type: z213.literal("message_delta"),
            delta: z213.object({
              stop_reason: z213.string().nullish(),
              stop_sequence: z213.string().nullish(),
              container: z213.object({
                expires_at: z213.string(),
                id: z213.string(),
                skills: z213.array(
                  z213.object({
                    type: z213.union([
                      z213.literal("anthropic"),
                      z213.literal("custom")
                    ]),
                    skill_id: z213.string(),
                    version: z213.string()
                  })
                ).nullish()
              }).nullish()
            }),
            usage: z213.looseObject({
              input_tokens: z213.number().nullish(),
              output_tokens: z213.number(),
              cache_creation_input_tokens: z213.number().nullish(),
              cache_read_input_tokens: z213.number().nullish()
            }),
            context_management: z213.object({
              applied_edits: z213.array(
                z213.union([
                  z213.object({
                    type: z213.literal("clear_tool_uses_20250919"),
                    cleared_tool_uses: z213.number(),
                    cleared_input_tokens: z213.number()
                  }),
                  z213.object({
                    type: z213.literal("clear_thinking_20251015"),
                    cleared_thinking_turns: z213.number(),
                    cleared_input_tokens: z213.number()
                  })
                ])
              )
            }).nullish()
          }),
          z213.object({
            type: z213.literal("message_stop")
          }),
          z213.object({
            type: z213.literal("ping")
          })
        ])
      )
    );
    anthropicReasoningMetadataSchema2 = lazySchema(
      () => zodSchema(
        z213.object({
          signature: z213.string().optional(),
          redactedData: z213.string().optional()
        })
      )
    );
    anthropicFilePartProviderOptions2 = z311.object({
      /**
       * Citation configuration for this document.
       * When enabled, this document will generate citations in the response.
       */
      citations: z311.object({
        /**
         * Enable citations for this document
         */
        enabled: z311.boolean()
      }).optional(),
      /**
       * Custom title for the document.
       * If not provided, the filename will be used.
       */
      title: z311.string().optional(),
      /**
       * Context about the document that will be passed to the model
       * but not used towards cited content.
       * Useful for storing document metadata as text or stringified JSON.
       */
      context: z311.string().optional()
    });
    anthropicProviderOptions2 = z311.object({
      /**
       * Whether to send reasoning to the model.
       *
       * This allows you to deactivate reasoning inputs for models that do not support them.
       */
      sendReasoning: z311.boolean().optional(),
      /**
       * Determines how structured outputs are generated.
       *
       * - `outputFormat`: Use the `output_format` parameter to specify the structured output format.
       * - `jsonTool`: Use a special 'json' tool to specify the structured output format.
       * - `auto`: Use 'outputFormat' when supported, otherwise use 'jsonTool' (default).
       */
      structuredOutputMode: z311.enum(["outputFormat", "jsonTool", "auto"]).optional(),
      /**
       * Configuration for enabling Claude's extended thinking.
       *
       * When enabled, responses include thinking content blocks showing Claude's thinking process before the final answer.
       * Requires a minimum budget of 1,024 tokens and counts towards the `max_tokens` limit.
       */
      thinking: z311.discriminatedUnion("type", [
        z311.object({
          /** for Opus 4.6 and newer models */
          type: z311.literal("adaptive")
        }),
        z311.object({
          /** for models before Opus 4.6 */
          type: z311.literal("enabled"),
          budgetTokens: z311.number().optional()
        }),
        z311.object({
          type: z311.literal("disabled")
        })
      ]).optional(),
      /**
       * Whether to disable parallel function calling during tool use. Default is false.
       * When set to true, Claude will use at most one tool per response.
       */
      disableParallelToolUse: z311.boolean().optional(),
      /**
       * Cache control settings for this message.
       * See https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching
       */
      cacheControl: z311.object({
        type: z311.literal("ephemeral"),
        ttl: z311.union([z311.literal("5m"), z311.literal("1h")]).optional()
      }).optional(),
      /**
       * MCP servers to be utilized in this request.
       */
      mcpServers: z311.array(
        z311.object({
          type: z311.literal("url"),
          name: z311.string(),
          url: z311.string(),
          authorizationToken: z311.string().nullish(),
          toolConfiguration: z311.object({
            enabled: z311.boolean().nullish(),
            allowedTools: z311.array(z311.string()).nullish()
          }).nullish()
        })
      ).optional(),
      /**
       * Agent Skills configuration. Skills enable Claude to perform specialized tasks
       * like document processing (PPTX, DOCX, PDF, XLSX) and data analysis.
       * Requires code execution tool to be enabled.
       */
      container: z311.object({
        id: z311.string().optional(),
        skills: z311.array(
          z311.object({
            type: z311.union([z311.literal("anthropic"), z311.literal("custom")]),
            skillId: z311.string(),
            version: z311.string().optional()
          })
        ).optional()
      }).optional(),
      /**
       * Whether to enable tool streaming (and structured output streaming).
       *
       * When set to false, the model will return all tool calls and results
       * at once after a delay.
       *
       * @default true
       */
      toolStreaming: z311.boolean().optional(),
      /**
       * @default 'high'
       */
      effort: z311.enum(["low", "medium", "high", "max"]).optional(),
      contextManagement: z311.object({
        edits: z311.array(
          z311.discriminatedUnion("type", [
            z311.object({
              type: z311.literal("clear_tool_uses_20250919"),
              trigger: z311.discriminatedUnion("type", [
                z311.object({
                  type: z311.literal("input_tokens"),
                  value: z311.number()
                }),
                z311.object({
                  type: z311.literal("tool_uses"),
                  value: z311.number()
                })
              ]).optional(),
              keep: z311.object({
                type: z311.literal("tool_uses"),
                value: z311.number()
              }).optional(),
              clearAtLeast: z311.object({
                type: z311.literal("input_tokens"),
                value: z311.number()
              }).optional(),
              clearToolInputs: z311.boolean().optional(),
              excludeTools: z311.array(z311.string()).optional()
            }),
            z311.object({
              type: z311.literal("clear_thinking_20251015"),
              keep: z311.union([
                z311.literal("all"),
                z311.object({
                  type: z311.literal("thinking_turns"),
                  value: z311.number()
                })
              ]).optional()
            })
          ])
        )
      }).optional()
    });
    MAX_CACHE_BREAKPOINTS2 = 4;
    CacheControlValidator2 = class {
      constructor() {
        this.breakpointCount = 0;
        this.warnings = [];
      }
      getCacheControl(providerMetadata, context2) {
        const cacheControlValue = getCacheControl3(providerMetadata);
        if (!cacheControlValue) {
          return void 0;
        }
        if (!context2.canCache) {
          this.warnings.push({
            type: "unsupported",
            feature: "cache_control on non-cacheable context",
            details: `cache_control cannot be set on ${context2.type}. It will be ignored.`
          });
          return void 0;
        }
        this.breakpointCount++;
        if (this.breakpointCount > MAX_CACHE_BREAKPOINTS2) {
          this.warnings.push({
            type: "unsupported",
            feature: "cacheControl breakpoint limit",
            details: `Maximum ${MAX_CACHE_BREAKPOINTS2} cache breakpoints exceeded (found ${this.breakpointCount}). This breakpoint will be ignored.`
          });
          return void 0;
        }
        return cacheControlValue;
      }
      getWarnings() {
        return this.warnings;
      }
    };
    textEditor_20250728ArgsSchema2 = lazySchema(
      () => zodSchema(
        z411.object({
          maxCharacters: z411.number().optional()
        })
      )
    );
    textEditor_20250728InputSchema2 = lazySchema(
      () => zodSchema(
        z411.object({
          command: z411.enum(["view", "create", "str_replace", "insert"]),
          path: z411.string(),
          file_text: z411.string().optional(),
          insert_line: z411.number().int().optional(),
          new_str: z411.string().optional(),
          insert_text: z411.string().optional(),
          old_str: z411.string().optional(),
          view_range: z411.array(z411.number().int()).optional()
        })
      )
    );
    factory8 = createProviderToolFactory({
      id: "anthropic.text_editor_20250728",
      inputSchema: textEditor_20250728InputSchema2
    });
    textEditor_202507282 = (args2 = {}) => {
      return factory8(args2);
    };
    webSearch_20250305ArgsSchema2 = lazySchema(
      () => zodSchema(
        z510.object({
          maxUses: z510.number().optional(),
          allowedDomains: z510.array(z510.string()).optional(),
          blockedDomains: z510.array(z510.string()).optional(),
          userLocation: z510.object({
            type: z510.literal("approximate"),
            city: z510.string().optional(),
            region: z510.string().optional(),
            country: z510.string().optional(),
            timezone: z510.string().optional()
          }).optional()
        })
      )
    );
    webSearch_20250305OutputSchema2 = lazySchema(
      () => zodSchema(
        z510.array(
          z510.object({
            url: z510.string(),
            title: z510.string().nullable(),
            pageAge: z510.string().nullable(),
            encryptedContent: z510.string(),
            type: z510.literal("web_search_result")
          })
        )
      )
    );
    webSearch_20250305InputSchema2 = lazySchema(
      () => zodSchema(
        z510.object({
          query: z510.string()
        })
      )
    );
    factory22 = createProviderToolFactoryWithOutputSchema({
      id: "anthropic.web_search_20250305",
      inputSchema: webSearch_20250305InputSchema2,
      outputSchema: webSearch_20250305OutputSchema2,
      supportsDeferredResults: true
    });
    webSearch_202503052 = (args2 = {}) => {
      return factory22(args2);
    };
    webFetch_20250910ArgsSchema2 = lazySchema(
      () => zodSchema(
        z610.object({
          maxUses: z610.number().optional(),
          allowedDomains: z610.array(z610.string()).optional(),
          blockedDomains: z610.array(z610.string()).optional(),
          citations: z610.object({ enabled: z610.boolean() }).optional(),
          maxContentTokens: z610.number().optional()
        })
      )
    );
    webFetch_20250910OutputSchema2 = lazySchema(
      () => zodSchema(
        z610.object({
          type: z610.literal("web_fetch_result"),
          url: z610.string(),
          content: z610.object({
            type: z610.literal("document"),
            title: z610.string().nullable(),
            citations: z610.object({ enabled: z610.boolean() }).optional(),
            source: z610.union([
              z610.object({
                type: z610.literal("base64"),
                mediaType: z610.literal("application/pdf"),
                data: z610.string()
              }),
              z610.object({
                type: z610.literal("text"),
                mediaType: z610.literal("text/plain"),
                data: z610.string()
              })
            ])
          }),
          retrievedAt: z610.string().nullable()
        })
      )
    );
    webFetch_20250910InputSchema2 = lazySchema(
      () => zodSchema(
        z610.object({
          url: z610.string()
        })
      )
    );
    factory32 = createProviderToolFactoryWithOutputSchema({
      id: "anthropic.web_fetch_20250910",
      inputSchema: webFetch_20250910InputSchema2,
      outputSchema: webFetch_20250910OutputSchema2,
      supportsDeferredResults: true
    });
    webFetch_202509102 = (args2 = {}) => {
      return factory32(args2);
    };
    codeExecution_20250522OutputSchema2 = lazySchema(
      () => zodSchema(
        z710.object({
          type: z710.literal("code_execution_result"),
          stdout: z710.string(),
          stderr: z710.string(),
          return_code: z710.number(),
          content: z710.array(
            z710.object({
              type: z710.literal("code_execution_output"),
              file_id: z710.string()
            })
          ).optional().default([])
        })
      )
    );
    codeExecution_20250522InputSchema2 = lazySchema(
      () => zodSchema(
        z710.object({
          code: z710.string()
        })
      )
    );
    factory42 = createProviderToolFactoryWithOutputSchema({
      id: "anthropic.code_execution_20250522",
      inputSchema: codeExecution_20250522InputSchema2,
      outputSchema: codeExecution_20250522OutputSchema2
    });
    codeExecution_202505222 = (args2 = {}) => {
      return factory42(args2);
    };
    codeExecution_20250825OutputSchema2 = lazySchema(
      () => zodSchema(
        z810.discriminatedUnion("type", [
          z810.object({
            type: z810.literal("code_execution_result"),
            stdout: z810.string(),
            stderr: z810.string(),
            return_code: z810.number(),
            content: z810.array(
              z810.object({
                type: z810.literal("code_execution_output"),
                file_id: z810.string()
              })
            ).optional().default([])
          }),
          z810.object({
            type: z810.literal("bash_code_execution_result"),
            content: z810.array(
              z810.object({
                type: z810.literal("bash_code_execution_output"),
                file_id: z810.string()
              })
            ),
            stdout: z810.string(),
            stderr: z810.string(),
            return_code: z810.number()
          }),
          z810.object({
            type: z810.literal("bash_code_execution_tool_result_error"),
            error_code: z810.string()
          }),
          z810.object({
            type: z810.literal("text_editor_code_execution_tool_result_error"),
            error_code: z810.string()
          }),
          z810.object({
            type: z810.literal("text_editor_code_execution_view_result"),
            content: z810.string(),
            file_type: z810.string(),
            num_lines: z810.number().nullable(),
            start_line: z810.number().nullable(),
            total_lines: z810.number().nullable()
          }),
          z810.object({
            type: z810.literal("text_editor_code_execution_create_result"),
            is_file_update: z810.boolean()
          }),
          z810.object({
            type: z810.literal("text_editor_code_execution_str_replace_result"),
            lines: z810.array(z810.string()).nullable(),
            new_lines: z810.number().nullable(),
            new_start: z810.number().nullable(),
            old_lines: z810.number().nullable(),
            old_start: z810.number().nullable()
          })
        ])
      )
    );
    codeExecution_20250825InputSchema2 = lazySchema(
      () => zodSchema(
        z810.discriminatedUnion("type", [
          // Programmatic tool calling format (mapped from { code } by AI SDK)
          z810.object({
            type: z810.literal("programmatic-tool-call"),
            code: z810.string()
          }),
          z810.object({
            type: z810.literal("bash_code_execution"),
            command: z810.string()
          }),
          z810.discriminatedUnion("command", [
            z810.object({
              type: z810.literal("text_editor_code_execution"),
              command: z810.literal("view"),
              path: z810.string()
            }),
            z810.object({
              type: z810.literal("text_editor_code_execution"),
              command: z810.literal("create"),
              path: z810.string(),
              file_text: z810.string().nullish()
            }),
            z810.object({
              type: z810.literal("text_editor_code_execution"),
              command: z810.literal("str_replace"),
              path: z810.string(),
              old_str: z810.string(),
              new_str: z810.string()
            })
          ])
        ])
      )
    );
    factory52 = createProviderToolFactoryWithOutputSchema({
      id: "anthropic.code_execution_20250825",
      inputSchema: codeExecution_20250825InputSchema2,
      outputSchema: codeExecution_20250825OutputSchema2,
      // Programmatic tool calling: tool results may be deferred to a later turn
      // when code execution triggers a client-executed tool that needs to be
      // resolved before the code execution result can be returned.
      supportsDeferredResults: true
    });
    codeExecution_202508252 = (args2 = {}) => {
      return factory52(args2);
    };
    toolSearchRegex_20251119OutputSchema2 = lazySchema(
      () => zodSchema(
        z98.array(
          z98.object({
            type: z98.literal("tool_reference"),
            toolName: z98.string()
          })
        )
      )
    );
    toolSearchRegex_20251119InputSchema2 = lazySchema(
      () => zodSchema(
        z98.object({
          /**
           * A regex pattern to search for tools.
           * Uses Python re.search() syntax. Maximum 200 characters.
           *
           * Examples:
           * - "weather" - matches tool names/descriptions containing "weather"
           * - "get_.*_data" - matches tools like get_user_data, get_weather_data
           * - "database.*query|query.*database" - OR patterns for flexibility
           * - "(?i)slack" - case-insensitive search
           */
          pattern: z98.string(),
          /**
           * Maximum number of tools to return. Optional.
           */
          limit: z98.number().optional()
        })
      )
    );
    factory62 = createProviderToolFactoryWithOutputSchema({
      id: "anthropic.tool_search_regex_20251119",
      inputSchema: toolSearchRegex_20251119InputSchema2,
      outputSchema: toolSearchRegex_20251119OutputSchema2,
      supportsDeferredResults: true
    });
    toolSearchRegex_202511192 = (args2 = {}) => {
      return factory62(args2);
    };
    bash_20241022InputSchema2 = lazySchema(
      () => zodSchema(
        z108.object({
          command: z108.string(),
          restart: z108.boolean().optional()
        })
      )
    );
    bash_202410222 = createProviderToolFactory({
      id: "anthropic.bash_20241022",
      inputSchema: bash_20241022InputSchema2
    });
    bash_20250124InputSchema2 = lazySchema(
      () => zodSchema(
        z116.object({
          command: z116.string(),
          restart: z116.boolean().optional()
        })
      )
    );
    bash_202501242 = createProviderToolFactory({
      id: "anthropic.bash_20250124",
      inputSchema: bash_20250124InputSchema2
    });
    computer_20241022InputSchema2 = lazySchema(
      () => zodSchema(
        z126.object({
          action: z126.enum([
            "key",
            "type",
            "mouse_move",
            "left_click",
            "left_click_drag",
            "right_click",
            "middle_click",
            "double_click",
            "screenshot",
            "cursor_position"
          ]),
          coordinate: z126.array(z126.number().int()).optional(),
          text: z126.string().optional()
        })
      )
    );
    computer_202410222 = createProviderToolFactory({
      id: "anthropic.computer_20241022",
      inputSchema: computer_20241022InputSchema2
    });
    computer_20250124InputSchema2 = lazySchema(
      () => zodSchema(
        z135.object({
          action: z135.enum([
            "key",
            "hold_key",
            "type",
            "cursor_position",
            "mouse_move",
            "left_mouse_down",
            "left_mouse_up",
            "left_click",
            "left_click_drag",
            "right_click",
            "middle_click",
            "double_click",
            "triple_click",
            "scroll",
            "wait",
            "screenshot"
          ]),
          coordinate: z135.tuple([z135.number().int(), z135.number().int()]).optional(),
          duration: z135.number().optional(),
          scroll_amount: z135.number().optional(),
          scroll_direction: z135.enum(["up", "down", "left", "right"]).optional(),
          start_coordinate: z135.tuple([z135.number().int(), z135.number().int()]).optional(),
          text: z135.string().optional()
        })
      )
    );
    computer_202501242 = createProviderToolFactory({
      id: "anthropic.computer_20250124",
      inputSchema: computer_20250124InputSchema2
    });
    computer_20251124InputSchema2 = lazySchema(
      () => zodSchema(
        z145.object({
          action: z145.enum([
            "key",
            "hold_key",
            "type",
            "cursor_position",
            "mouse_move",
            "left_mouse_down",
            "left_mouse_up",
            "left_click",
            "left_click_drag",
            "right_click",
            "middle_click",
            "double_click",
            "triple_click",
            "scroll",
            "wait",
            "screenshot",
            "zoom"
          ]),
          coordinate: z145.tuple([z145.number().int(), z145.number().int()]).optional(),
          duration: z145.number().optional(),
          region: z145.tuple([
            z145.number().int(),
            z145.number().int(),
            z145.number().int(),
            z145.number().int()
          ]).optional(),
          scroll_amount: z145.number().optional(),
          scroll_direction: z145.enum(["up", "down", "left", "right"]).optional(),
          start_coordinate: z145.tuple([z145.number().int(), z145.number().int()]).optional(),
          text: z145.string().optional()
        })
      )
    );
    computer_202511242 = createProviderToolFactory({
      id: "anthropic.computer_20251124",
      inputSchema: computer_20251124InputSchema2
    });
    memory_20250818InputSchema2 = lazySchema(
      () => zodSchema(
        z154.discriminatedUnion("command", [
          z154.object({
            command: z154.literal("view"),
            path: z154.string(),
            view_range: z154.tuple([z154.number(), z154.number()]).optional()
          }),
          z154.object({
            command: z154.literal("create"),
            path: z154.string(),
            file_text: z154.string()
          }),
          z154.object({
            command: z154.literal("str_replace"),
            path: z154.string(),
            old_str: z154.string(),
            new_str: z154.string()
          }),
          z154.object({
            command: z154.literal("insert"),
            path: z154.string(),
            insert_line: z154.number(),
            insert_text: z154.string()
          }),
          z154.object({
            command: z154.literal("delete"),
            path: z154.string()
          }),
          z154.object({
            command: z154.literal("rename"),
            old_path: z154.string(),
            new_path: z154.string()
          })
        ])
      )
    );
    memory_202508182 = createProviderToolFactory({
      id: "anthropic.memory_20250818",
      inputSchema: memory_20250818InputSchema2
    });
    textEditor_20241022InputSchema2 = lazySchema(
      () => zodSchema(
        z164.object({
          command: z164.enum(["view", "create", "str_replace", "insert", "undo_edit"]),
          path: z164.string(),
          file_text: z164.string().optional(),
          insert_line: z164.number().int().optional(),
          new_str: z164.string().optional(),
          insert_text: z164.string().optional(),
          old_str: z164.string().optional(),
          view_range: z164.array(z164.number().int()).optional()
        })
      )
    );
    textEditor_202410222 = createProviderToolFactory({
      id: "anthropic.text_editor_20241022",
      inputSchema: textEditor_20241022InputSchema2
    });
    textEditor_20250124InputSchema2 = lazySchema(
      () => zodSchema(
        z174.object({
          command: z174.enum(["view", "create", "str_replace", "insert", "undo_edit"]),
          path: z174.string(),
          file_text: z174.string().optional(),
          insert_line: z174.number().int().optional(),
          new_str: z174.string().optional(),
          insert_text: z174.string().optional(),
          old_str: z174.string().optional(),
          view_range: z174.array(z174.number().int()).optional()
        })
      )
    );
    textEditor_202501242 = createProviderToolFactory({
      id: "anthropic.text_editor_20250124",
      inputSchema: textEditor_20250124InputSchema2
    });
    textEditor_20250429InputSchema2 = lazySchema(
      () => zodSchema(
        z184.object({
          command: z184.enum(["view", "create", "str_replace", "insert"]),
          path: z184.string(),
          file_text: z184.string().optional(),
          insert_line: z184.number().int().optional(),
          new_str: z184.string().optional(),
          insert_text: z184.string().optional(),
          old_str: z184.string().optional(),
          view_range: z184.array(z184.number().int()).optional()
        })
      )
    );
    textEditor_202504292 = createProviderToolFactory({
      id: "anthropic.text_editor_20250429",
      inputSchema: textEditor_20250429InputSchema2
    });
    toolSearchBm25_20251119OutputSchema2 = lazySchema(
      () => zodSchema(
        z193.array(
          z193.object({
            type: z193.literal("tool_reference"),
            toolName: z193.string()
          })
        )
      )
    );
    toolSearchBm25_20251119InputSchema2 = lazySchema(
      () => zodSchema(
        z193.object({
          /**
           * A natural language query to search for tools.
           * Claude will use BM25 text search to find relevant tools.
           */
          query: z193.string(),
          /**
           * Maximum number of tools to return. Optional.
           */
          limit: z193.number().optional()
        })
      )
    );
    factory72 = createProviderToolFactoryWithOutputSchema({
      id: "anthropic.tool_search_bm25_20251119",
      inputSchema: toolSearchBm25_20251119InputSchema2,
      outputSchema: toolSearchBm25_20251119OutputSchema2,
      supportsDeferredResults: true
    });
    toolSearchBm25_202511192 = (args2 = {}) => {
      return factory72(args2);
    };
    anthropicTools2 = {
      /**
       * The bash tool enables Claude to execute shell commands in a persistent bash session,
       * allowing system operations, script execution, and command-line automation.
       *
       * Image results are supported.
       */
      bash_20241022: bash_202410222,
      /**
       * The bash tool enables Claude to execute shell commands in a persistent bash session,
       * allowing system operations, script execution, and command-line automation.
       *
       * Image results are supported.
       */
      bash_20250124: bash_202501242,
      /**
       * Claude can analyze data, create visualizations, perform complex calculations,
       * run system commands, create and edit files, and process uploaded files directly within
       * the API conversation.
       *
       * The code execution tool allows Claude to run Bash commands and manipulate files,
       * including writing code, in a secure, sandboxed environment.
       */
      codeExecution_20250522: codeExecution_202505222,
      /**
       * Claude can analyze data, create visualizations, perform complex calculations,
       * run system commands, create and edit files, and process uploaded files directly within
       * the API conversation.
       *
       * The code execution tool allows Claude to run both Python and Bash commands and manipulate files,
       * including writing code, in a secure, sandboxed environment.
       *
       * This is the latest version with enhanced Bash support and file operations.
       */
      codeExecution_20250825: codeExecution_202508252,
      /**
       * Claude can interact with computer environments through the computer use tool, which
       * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
       *
       * Image results are supported.
       *
       * @param displayWidthPx - The width of the display being controlled by the model in pixels.
       * @param displayHeightPx - The height of the display being controlled by the model in pixels.
       * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
       */
      computer_20241022: computer_202410222,
      /**
       * Claude can interact with computer environments through the computer use tool, which
       * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
       *
       * Image results are supported.
       *
       * @param displayWidthPx - The width of the display being controlled by the model in pixels.
       * @param displayHeightPx - The height of the display being controlled by the model in pixels.
       * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
       */
      computer_20250124: computer_202501242,
      /**
       * Claude can interact with computer environments through the computer use tool, which
       * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
       *
       * This version adds the zoom action for detailed screen region inspection.
       *
       * Image results are supported.
       *
       * Supported models: Claude Opus 4.5
       *
       * @param displayWidthPx - The width of the display being controlled by the model in pixels.
       * @param displayHeightPx - The height of the display being controlled by the model in pixels.
       * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
       * @param enableZoom - Enable zoom action. Set to true to allow Claude to zoom into specific screen regions. Default: false.
       */
      computer_20251124: computer_202511242,
      /**
       * The memory tool enables Claude to store and retrieve information across conversations through a memory file directory.
       * Claude can create, read, update, and delete files that persist between sessions,
       * allowing it to build knowledge over time without keeping everything in the context window.
       * The memory tool operates client-sideyou control where and how the data is stored through your own infrastructure.
       *
       * Supported models: Claude Sonnet 4.5, Claude Sonnet 4, Claude Opus 4.1, Claude Opus 4.
       */
      memory_20250818: memory_202508182,
      /**
       * Claude can use an Anthropic-defined text editor tool to view and modify text files,
       * helping you debug, fix, and improve your code or other text documents. This allows Claude
       * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
       *
       * Supported models: Claude Sonnet 3.5
       */
      textEditor_20241022: textEditor_202410222,
      /**
       * Claude can use an Anthropic-defined text editor tool to view and modify text files,
       * helping you debug, fix, and improve your code or other text documents. This allows Claude
       * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
       *
       * Supported models: Claude Sonnet 3.7
       */
      textEditor_20250124: textEditor_202501242,
      /**
       * Claude can use an Anthropic-defined text editor tool to view and modify text files,
       * helping you debug, fix, and improve your code or other text documents. This allows Claude
       * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
       *
       * Note: This version does not support the "undo_edit" command.
       *
       * @deprecated Use textEditor_20250728 instead
       */
      textEditor_20250429: textEditor_202504292,
      /**
       * Claude can use an Anthropic-defined text editor tool to view and modify text files,
       * helping you debug, fix, and improve your code or other text documents. This allows Claude
       * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
       *
       * Note: This version does not support the "undo_edit" command and adds optional max_characters parameter.
       *
       * Supported models: Claude Sonnet 4, Opus 4, and Opus 4.1
       *
       * @param maxCharacters - Optional maximum number of characters to view in the file
       */
      textEditor_20250728: textEditor_202507282,
      /**
       * Creates a web fetch tool that gives Claude direct access to real-time web content.
       *
       * @param maxUses - The max_uses parameter limits the number of web fetches performed
       * @param allowedDomains - Only fetch from these domains
       * @param blockedDomains - Never fetch from these domains
       * @param citations - Unlike web search where citations are always enabled, citations are optional for web fetch. Set "citations": {"enabled": true} to enable Claude to cite specific passages from fetched documents.
       * @param maxContentTokens - The max_content_tokens parameter limits the amount of content that will be included in the context.
       */
      webFetch_20250910: webFetch_202509102,
      /**
       * Creates a web search tool that gives Claude direct access to real-time web content.
       *
       * @param maxUses - Maximum number of web searches Claude can perform during the conversation.
       * @param allowedDomains - Optional list of domains that Claude is allowed to search.
       * @param blockedDomains - Optional list of domains that Claude should avoid when searching.
       * @param userLocation - Optional user location information to provide geographically relevant search results.
       */
      webSearch_20250305: webSearch_202503052,
      /**
       * Creates a tool search tool that uses regex patterns to find tools.
       *
       * The tool search tool enables Claude to work with hundreds or thousands of tools
       * by dynamically discovering and loading them on-demand. Instead of loading all
       * tool definitions into the context window upfront, Claude searches your tool
       * catalog and loads only the tools it needs.
       *
       * Use `providerOptions: { anthropic: { deferLoading: true } }` on other tools
       * to mark them for deferred loading.
       *
       * Supported models: Claude Opus 4.5, Claude Sonnet 4.5
       */
      toolSearchRegex_20251119: toolSearchRegex_202511192,
      /**
       * Creates a tool search tool that uses BM25 (natural language) to find tools.
       *
       * The tool search tool enables Claude to work with hundreds or thousands of tools
       * by dynamically discovering and loading them on-demand. Instead of loading all
       * tool definitions into the context window upfront, Claude searches your tool
       * catalog and loads only the tools it needs.
       *
       * Use `providerOptions: { anthropic: { deferLoading: true } }` on other tools
       * to mark them for deferred loading.
       *
       * Supported models: Claude Opus 4.5, Claude Sonnet 4.5
       */
      toolSearchBm25_20251119: toolSearchBm25_202511192
    };
  }
});

// node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read5,
  __rest: () => __rest,
  __rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray5,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context2 = {};
    for (var p in contextIn) context2[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context2.access[p] = contextIn.access[p];
    context2.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value2) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value2 = useValue ? initializers[i].call(thisArg, value2) : initializers[i].call(thisArg);
  }
  return useValue ? value2 : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name25, prefix) {
  if (typeof name25 === "symbol") name25 = name25.description ? "[".concat(name25.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name25) : name25 });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve4) {
      resolve4(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve4, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve4(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read5(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read5(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray5(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value2) {
    resume("next", value2);
  }
  function reject(value2) {
    resume("throw", value2);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve4, reject) {
        v = o[n](v), settle(resolve4, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve4, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve4({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env3, value2, async) {
  if (value2 !== null && value2 !== void 0) {
    if (typeof value2 !== "object" && typeof value2 !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value2[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value2[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env3.stack.push({ value: value2, dispose, async });
  } else if (async) {
    env3.stack.push({ async: true });
  }
  return value2;
}
function __disposeResources(env3) {
  function fail(e) {
    env3.error = env3.hasError ? new _SuppressedError(e, env3.error, "An error was suppressed during disposal.") : e;
    env3.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env3.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env3.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env3.hasError ? Promise.reject(env3.error) : Promise.resolve();
    if (env3.hasError) throw env3.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path24, preserveJsx) {
  if (typeof path24 === "string" && /^\.\.?\//.test(path24)) {
    return path24.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path24;
}
var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    __setModuleDefault = Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    };
    ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __esDecorate,
      __runInitializers,
      __propKey,
      __setFunctionName,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read: __read5,
      __spread,
      __spreadArrays,
      __spreadArray: __spreadArray5,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources,
      __rewriteRelativeImportExtension
    };
  }
});

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/node_modules/@smithy/util-buffer-from/node_modules/@smithy/is-array-buffer/dist-cjs/index.js
var require_dist_cjs = __commonJS({
  "node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/node_modules/@smithy/util-buffer-from/node_modules/@smithy/is-array-buffer/dist-cjs/index.js"(exports, module) {
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __name = (target, value2) => __defProp4(target, "name", { value: value2, configurable: true });
    var __export3 = (target, all) => {
      for (var name25 in all)
        __defProp4(target, name25, { get: all[name25], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp4({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export3(src_exports, {
      isArrayBuffer: () => isArrayBuffer
    });
    module.exports = __toCommonJS2(src_exports);
    var isArrayBuffer = /* @__PURE__ */ __name((arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]", "isArrayBuffer");
  }
});

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/node_modules/@smithy/util-buffer-from/dist-cjs/index.js
var require_dist_cjs2 = __commonJS({
  "node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/node_modules/@smithy/util-buffer-from/dist-cjs/index.js"(exports, module) {
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __name = (target, value2) => __defProp4(target, "name", { value: value2, configurable: true });
    var __export3 = (target, all) => {
      for (var name25 in all)
        __defProp4(target, name25, { get: all[name25], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp4({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export3(src_exports, {
      fromArrayBuffer: () => fromArrayBuffer,
      fromString: () => fromString
    });
    module.exports = __toCommonJS2(src_exports);
    var import_is_array_buffer = require_dist_cjs();
    var import_buffer = __require("buffer");
    var fromArrayBuffer = /* @__PURE__ */ __name((input, offset = 0, length = input.byteLength - offset) => {
      if (!(0, import_is_array_buffer.isArrayBuffer)(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
      }
      return import_buffer.Buffer.from(input, offset, length);
    }, "fromArrayBuffer");
    var fromString = /* @__PURE__ */ __name((input, encoding) => {
      if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
      }
      return encoding ? import_buffer.Buffer.from(input, encoding) : import_buffer.Buffer.from(input);
    }, "fromString");
  }
});

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-cjs/index.js
var require_dist_cjs3 = __commonJS({
  "node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-cjs/index.js"(exports, module) {
    var __defProp4 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __name = (target, value2) => __defProp4(target, "name", { value: value2, configurable: true });
    var __export3 = (target, all) => {
      for (var name25 in all)
        __defProp4(target, name25, { get: all[name25], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp3.call(to, key) && key !== except)
            __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp4({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export3(src_exports, {
      fromUtf8: () => fromUtf82,
      toUint8Array: () => toUint8Array,
      toUtf8: () => toUtf82
    });
    module.exports = __toCommonJS2(src_exports);
    var import_util_buffer_from = require_dist_cjs2();
    var fromUtf82 = /* @__PURE__ */ __name((input) => {
      const buf = (0, import_util_buffer_from.fromString)(input, "utf8");
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }, "fromUtf8");
    var toUint8Array = /* @__PURE__ */ __name((data) => {
      if (typeof data === "string") {
        return fromUtf82(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }, "toUint8Array");
    var toUtf82 = /* @__PURE__ */ __name((input) => {
      if (typeof input === "string") {
        return input;
      }
      if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
      }
      return (0, import_util_buffer_from.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
    }, "toUtf8");
  }
});

// node_modules/@aws-crypto/util/build/main/convertToBuffer.js
var require_convertToBuffer = __commonJS({
  "node_modules/@aws-crypto/util/build/main/convertToBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertToBuffer = void 0;
    var util_utf8_1 = require_dist_cjs3();
    var fromUtf82 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
      return Buffer.from(input, "utf8");
    } : util_utf8_1.fromUtf8;
    function convertToBuffer(data) {
      if (data instanceof Uint8Array)
        return data;
      if (typeof data === "string") {
        return fromUtf82(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
    exports.convertToBuffer = convertToBuffer;
  }
});

// node_modules/@aws-crypto/util/build/main/isEmptyData.js
var require_isEmptyData = __commonJS({
  "node_modules/@aws-crypto/util/build/main/isEmptyData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyData = void 0;
    function isEmptyData(data) {
      if (typeof data === "string") {
        return data.length === 0;
      }
      return data.byteLength === 0;
    }
    exports.isEmptyData = isEmptyData;
  }
});

// node_modules/@aws-crypto/util/build/main/numToUint8.js
var require_numToUint8 = __commonJS({
  "node_modules/@aws-crypto/util/build/main/numToUint8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numToUint8 = void 0;
    function numToUint8(num) {
      return new Uint8Array([
        (num & 4278190080) >> 24,
        (num & 16711680) >> 16,
        (num & 65280) >> 8,
        num & 255
      ]);
    }
    exports.numToUint8 = numToUint8;
  }
});

// node_modules/@aws-crypto/util/build/main/uint32ArrayFrom.js
var require_uint32ArrayFrom = __commonJS({
  "node_modules/@aws-crypto/util/build/main/uint32ArrayFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = void 0;
    function uint32ArrayFrom(a_lookUpTable) {
      if (!Uint32Array.from) {
        var return_array = new Uint32Array(a_lookUpTable.length);
        var a_index = 0;
        while (a_index < a_lookUpTable.length) {
          return_array[a_index] = a_lookUpTable[a_index];
          a_index += 1;
        }
        return return_array;
      }
      return Uint32Array.from(a_lookUpTable);
    }
    exports.uint32ArrayFrom = uint32ArrayFrom;
  }
});

// node_modules/@aws-crypto/util/build/main/index.js
var require_main = __commonJS({
  "node_modules/@aws-crypto/util/build/main/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
    var convertToBuffer_1 = require_convertToBuffer();
    Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function() {
      return convertToBuffer_1.convertToBuffer;
    } });
    var isEmptyData_1 = require_isEmptyData();
    Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function() {
      return isEmptyData_1.isEmptyData;
    } });
    var numToUint8_1 = require_numToUint8();
    Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function() {
      return numToUint8_1.numToUint8;
    } });
    var uint32ArrayFrom_1 = require_uint32ArrayFrom();
    Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function() {
      return uint32ArrayFrom_1.uint32ArrayFrom;
    } });
  }
});

// node_modules/@aws-crypto/crc32/build/main/aws_crc32.js
var require_aws_crc32 = __commonJS({
  "node_modules/@aws-crypto/crc32/build/main/aws_crc32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util_1 = require_main();
    var index_1 = require_main2();
    var AwsCrc32 = (
      /** @class */
      (function() {
        function AwsCrc322() {
          this.crc32 = new index_1.Crc32();
        }
        AwsCrc322.prototype.update = function(toHash) {
          if ((0, util_1.isEmptyData)(toHash))
            return;
          this.crc32.update((0, util_1.convertToBuffer)(toHash));
        };
        AwsCrc322.prototype.digest = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a25) {
              return [2, (0, util_1.numToUint8)(this.crc32.digest())];
            });
          });
        };
        AwsCrc322.prototype.reset = function() {
          this.crc32 = new index_1.Crc32();
        };
        return AwsCrc322;
      })()
    );
    exports.AwsCrc32 = AwsCrc32;
  }
});

// node_modules/@aws-crypto/crc32/build/main/index.js
var require_main2 = __commonJS({
  "node_modules/@aws-crypto/crc32/build/main/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32 = exports.Crc32 = exports.crc32 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util_1 = require_main();
    function crc32(data) {
      return new Crc32().update(data).digest();
    }
    exports.crc32 = crc32;
    var Crc32 = (
      /** @class */
      (function() {
        function Crc322() {
          this.checksum = 4294967295;
        }
        Crc322.prototype.update = function(data) {
          var e_1, _a25;
          try {
            for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
              var byte = data_1_1.value;
              this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (data_1_1 && !data_1_1.done && (_a25 = data_1.return)) _a25.call(data_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return this;
        };
        Crc322.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        };
        return Crc322;
      })()
    );
    exports.Crc32 = Crc32;
    var a_lookUpTable = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);
    var aws_crc32_1 = require_aws_crc32();
    Object.defineProperty(exports, "AwsCrc32", { enumerable: true, get: function() {
      return aws_crc32_1.AwsCrc32;
    } });
  }
});

// node_modules/@smithy/util-hex-encoding/dist-cjs/index.js
var require_dist_cjs4 = __commonJS({
  "node_modules/@smithy/util-hex-encoding/dist-cjs/index.js"(exports) {
    "use strict";
    var SHORT_TO_HEX = {};
    var HEX_TO_SHORT = {};
    for (let i = 0; i < 256; i++) {
      let encodedByte = i.toString(16).toLowerCase();
      if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
      }
      SHORT_TO_HEX[i] = encodedByte;
      HEX_TO_SHORT[encodedByte] = i;
    }
    function fromHex(encoded) {
      if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
      }
      const out = new Uint8Array(encoded.length / 2);
      for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
          out[i / 2] = HEX_TO_SHORT[encodedByte];
        } else {
          throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
      }
      return out;
    }
    function toHex(bytes) {
      let out = "";
      for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
      }
      return out;
    }
    exports.fromHex = fromHex;
    exports.toHex = toHex;
  }
});

// node_modules/@smithy/eventstream-codec/dist-cjs/index.js
var require_dist_cjs5 = __commonJS({
  "node_modules/@smithy/eventstream-codec/dist-cjs/index.js"(exports) {
    "use strict";
    var crc32 = require_main2();
    var utilHexEncoding = require_dist_cjs4();
    var Int64 = class _Int64 {
      bytes;
      constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
          throw new Error("Int64 buffers must be exactly 8 bytes");
        }
      }
      static fromNumber(number) {
        if (number > 9223372036854776e3 || number < -9223372036854776e3) {
          throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
          bytes[i] = remaining;
        }
        if (number < 0) {
          negate(bytes);
        }
        return new _Int64(bytes);
      }
      valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 128;
        if (negative) {
          negate(bytes);
        }
        return parseInt(utilHexEncoding.toHex(bytes), 16) * (negative ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
    function negate(bytes) {
      for (let i = 0; i < 8; i++) {
        bytes[i] ^= 255;
      }
      for (let i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0)
          break;
      }
    }
    var HeaderMarshaller = class {
      toUtf8;
      fromUtf8;
      constructor(toUtf82, fromUtf82) {
        this.toUtf8 = toUtf82;
        this.fromUtf8 = fromUtf82;
      }
      format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)) {
          const bytes = this.fromUtf8(headerName);
          chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks) {
          out.set(chunk, position);
          position += chunk.byteLength;
        }
        return out;
      }
      formatHeaderValue(header) {
        switch (header.type) {
          case "boolean":
            return Uint8Array.from([header.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, header.value]);
          case "short":
            const shortView = new DataView(new ArrayBuffer(3));
            shortView.setUint8(0, 3);
            shortView.setInt16(1, header.value, false);
            return new Uint8Array(shortView.buffer);
          case "integer":
            const intView = new DataView(new ArrayBuffer(5));
            intView.setUint8(0, 4);
            intView.setInt32(1, header.value, false);
            return new Uint8Array(intView.buffer);
          case "long":
            const longBytes = new Uint8Array(9);
            longBytes[0] = 5;
            longBytes.set(header.value.bytes, 1);
            return longBytes;
          case "binary":
            const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
            binView.setUint8(0, 6);
            binView.setUint16(1, header.value.byteLength, false);
            const binBytes = new Uint8Array(binView.buffer);
            binBytes.set(header.value, 3);
            return binBytes;
          case "string":
            const utf8Bytes = this.fromUtf8(header.value);
            const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
            strView.setUint8(0, 7);
            strView.setUint16(1, utf8Bytes.byteLength, false);
            const strBytes = new Uint8Array(strView.buffer);
            strBytes.set(utf8Bytes, 3);
            return strBytes;
          case "timestamp":
            const tsBytes = new Uint8Array(9);
            tsBytes[0] = 8;
            tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
            return tsBytes;
          case "uuid":
            if (!UUID_PATTERN.test(header.value)) {
              throw new Error(`Invalid UUID received: ${header.value}`);
            }
            const uuidBytes = new Uint8Array(17);
            uuidBytes[0] = 9;
            uuidBytes.set(utilHexEncoding.fromHex(header.value.replace(/\-/g, "")), 1);
            return uuidBytes;
        }
      }
      parse(headers) {
        const out = {};
        let position = 0;
        while (position < headers.byteLength) {
          const nameLength = headers.getUint8(position++);
          const name25 = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
          position += nameLength;
          switch (headers.getUint8(position++)) {
            case 0:
              out[name25] = {
                type: BOOLEAN_TAG,
                value: true
              };
              break;
            case 1:
              out[name25] = {
                type: BOOLEAN_TAG,
                value: false
              };
              break;
            case 2:
              out[name25] = {
                type: BYTE_TAG,
                value: headers.getInt8(position++)
              };
              break;
            case 3:
              out[name25] = {
                type: SHORT_TAG,
                value: headers.getInt16(position, false)
              };
              position += 2;
              break;
            case 4:
              out[name25] = {
                type: INT_TAG,
                value: headers.getInt32(position, false)
              };
              position += 4;
              break;
            case 5:
              out[name25] = {
                type: LONG_TAG,
                value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
              };
              position += 8;
              break;
            case 6:
              const binaryLength = headers.getUint16(position, false);
              position += 2;
              out[name25] = {
                type: BINARY_TAG,
                value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
              };
              position += binaryLength;
              break;
            case 7:
              const stringLength = headers.getUint16(position, false);
              position += 2;
              out[name25] = {
                type: STRING_TAG,
                value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
              };
              position += stringLength;
              break;
            case 8:
              out[name25] = {
                type: TIMESTAMP_TAG,
                value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
              };
              position += 8;
              break;
            case 9:
              const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
              position += 16;
              out[name25] = {
                type: UUID_TAG,
                value: `${utilHexEncoding.toHex(uuidBytes.subarray(0, 4))}-${utilHexEncoding.toHex(uuidBytes.subarray(4, 6))}-${utilHexEncoding.toHex(uuidBytes.subarray(6, 8))}-${utilHexEncoding.toHex(uuidBytes.subarray(8, 10))}-${utilHexEncoding.toHex(uuidBytes.subarray(10))}`
              };
              break;
            default:
              throw new Error(`Unrecognized header type tag`);
          }
        }
        return out;
      }
    };
    var BOOLEAN_TAG = "boolean";
    var BYTE_TAG = "byte";
    var SHORT_TAG = "short";
    var INT_TAG = "integer";
    var LONG_TAG = "long";
    var BINARY_TAG = "binary";
    var STRING_TAG = "string";
    var TIMESTAMP_TAG = "timestamp";
    var UUID_TAG = "uuid";
    var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
    var PRELUDE_MEMBER_LENGTH = 4;
    var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
    var CHECKSUM_LENGTH = 4;
    var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
    function splitMessage({ byteLength, byteOffset, buffer }) {
      if (byteLength < MINIMUM_MESSAGE_LENGTH) {
        throw new Error("Provided message too short to accommodate event stream message overhead");
      }
      const view = new DataView(buffer, byteOffset, byteLength);
      const messageLength = view.getUint32(0, false);
      if (byteLength !== messageLength) {
        throw new Error("Reported message length does not match received message length");
      }
      const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
      const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
      const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
      const checksummer = new crc32.Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
      if (expectedPreludeChecksum !== checksummer.digest()) {
        throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
      }
      checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
      if (expectedMessageChecksum !== checksummer.digest()) {
        throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
      }
      return {
        headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
        body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
      };
    }
    var EventStreamCodec2 = class {
      headerMarshaller;
      messageBuffer;
      isEndOfStream;
      constructor(toUtf82, fromUtf82) {
        this.headerMarshaller = new HeaderMarshaller(toUtf82, fromUtf82);
        this.messageBuffer = [];
        this.isEndOfStream = false;
      }
      feed(message) {
        this.messageBuffer.push(this.decode(message));
      }
      endOfStream() {
        this.isEndOfStream = true;
      }
      getMessage() {
        const message = this.messageBuffer.pop();
        const isEndOfStream = this.isEndOfStream;
        return {
          getMessage() {
            return message;
          },
          isEndOfStream() {
            return isEndOfStream;
          }
        };
      }
      getAvailableMessages() {
        const messages = this.messageBuffer;
        this.messageBuffer = [];
        const isEndOfStream = this.isEndOfStream;
        return {
          getMessages() {
            return messages;
          },
          isEndOfStream() {
            return isEndOfStream;
          }
        };
      }
      encode({ headers: rawHeaders, body }) {
        const headers = this.headerMarshaller.format(rawHeaders);
        const length = headers.byteLength + body.byteLength + 16;
        const out = new Uint8Array(length);
        const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        const checksum = new crc32.Crc32();
        view.setUint32(0, length, false);
        view.setUint32(4, headers.byteLength, false);
        view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
        out.set(headers, 12);
        out.set(body, headers.byteLength + 12);
        view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
        return out;
      }
      decode(message) {
        const { headers, body } = splitMessage(message);
        return { headers: this.headerMarshaller.parse(headers), body };
      }
      formatHeaders(rawHeaders) {
        return this.headerMarshaller.format(rawHeaders);
      }
    };
    var MessageDecoderStream = class {
      options;
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const bytes of this.options.inputStream) {
          const decoded = this.options.decoder.decode(bytes);
          yield decoded;
        }
      }
    };
    var MessageEncoderStream = class {
      options;
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const msg of this.options.messageStream) {
          const encoded = this.options.encoder.encode(msg);
          yield encoded;
        }
        if (this.options.includeEndFrame) {
          yield new Uint8Array(0);
        }
      }
    };
    var SmithyMessageDecoderStream = class {
      options;
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const message of this.options.messageStream) {
          const deserialized = await this.options.deserializer(message);
          if (deserialized === void 0)
            continue;
          yield deserialized;
        }
      }
    };
    var SmithyMessageEncoderStream = class {
      options;
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const chunk of this.options.inputStream) {
          const payloadBuf = this.options.serializer(chunk);
          yield payloadBuf;
        }
      }
    };
    exports.EventStreamCodec = EventStreamCodec2;
    exports.HeaderMarshaller = HeaderMarshaller;
    exports.Int64 = Int64;
    exports.MessageDecoderStream = MessageDecoderStream;
    exports.MessageEncoderStream = MessageEncoderStream;
    exports.SmithyMessageDecoderStream = SmithyMessageDecoderStream;
    exports.SmithyMessageEncoderStream = SmithyMessageEncoderStream;
  }
});

// node_modules/@smithy/is-array-buffer/dist-cjs/index.js
var require_dist_cjs6 = __commonJS({
  "node_modules/@smithy/is-array-buffer/dist-cjs/index.js"(exports) {
    "use strict";
    var isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
    exports.isArrayBuffer = isArrayBuffer;
  }
});

// node_modules/@smithy/util-buffer-from/dist-cjs/index.js
var require_dist_cjs7 = __commonJS({
  "node_modules/@smithy/util-buffer-from/dist-cjs/index.js"(exports) {
    "use strict";
    var isArrayBuffer = require_dist_cjs6();
    var buffer = __require("buffer");
    var fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
      if (!isArrayBuffer.isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
      }
      return buffer.Buffer.from(input, offset, length);
    };
    var fromString = (input, encoding) => {
      if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
      }
      return encoding ? buffer.Buffer.from(input, encoding) : buffer.Buffer.from(input);
    };
    exports.fromArrayBuffer = fromArrayBuffer;
    exports.fromString = fromString;
  }
});

// node_modules/@smithy/util-utf8/dist-cjs/index.js
var require_dist_cjs8 = __commonJS({
  "node_modules/@smithy/util-utf8/dist-cjs/index.js"(exports) {
    "use strict";
    var utilBufferFrom = require_dist_cjs7();
    var fromUtf82 = (input) => {
      const buf = utilBufferFrom.fromString(input, "utf8");
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    };
    var toUint8Array = (data) => {
      if (typeof data === "string") {
        return fromUtf82(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    };
    var toUtf82 = (input) => {
      if (typeof input === "string") {
        return input;
      }
      if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
      }
      return utilBufferFrom.fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
    };
    exports.fromUtf8 = fromUtf82;
    exports.toUint8Array = toUint8Array;
    exports.toUtf8 = toUtf82;
  }
});

// node_modules/aws4fetch/dist/aws4fetch.esm.mjs
async function hmac(key, string) {
  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    typeof key === "string" ? encoder.encode(key) : key,
    { name: "HMAC", hash: { name: "SHA-256" } },
    false,
    ["sign"]
  );
  return crypto.subtle.sign("HMAC", cryptoKey, encoder.encode(string));
}
async function hash(content) {
  return crypto.subtle.digest("SHA-256", typeof content === "string" ? encoder.encode(content) : content);
}
function buf2hex(arrayBuffer) {
  const buffer = new Uint8Array(arrayBuffer);
  let out = "";
  for (let idx = 0; idx < buffer.length; idx++) {
    const n = buffer[idx];
    out += HEX_CHARS[n >>> 4 & 15];
    out += HEX_CHARS[n & 15];
  }
  return out;
}
function encodeRfc3986(urlEncodedStr) {
  return urlEncodedStr.replace(/[!'()*]/g, (c) => "%" + c.charCodeAt(0).toString(16).toUpperCase());
}
function guessServiceRegion(url, headers) {
  const { hostname, pathname } = url;
  if (hostname.endsWith(".on.aws")) {
    const match2 = hostname.match(/^[^.]{1,63}\.lambda-url\.([^.]{1,63})\.on\.aws$/);
    return match2 != null ? ["lambda", match2[1] || ""] : ["", ""];
  }
  if (hostname.endsWith(".r2.cloudflarestorage.com")) {
    return ["s3", "auto"];
  }
  if (hostname.endsWith(".backblazeb2.com")) {
    const match2 = hostname.match(/^(?:[^.]{1,63}\.)?s3\.([^.]{1,63})\.backblazeb2\.com$/);
    return match2 != null ? ["s3", match2[1] || ""] : ["", ""];
  }
  const match = hostname.replace("dualstack.", "").match(/([^.]{1,63})\.(?:([^.]{0,63})\.)?amazonaws\.com(?:\.cn)?$/);
  let service = match && match[1] || "";
  let region = match && match[2];
  if (region === "us-gov") {
    region = "us-gov-west-1";
  } else if (region === "s3" || region === "s3-accelerate") {
    region = "us-east-1";
    service = "s3";
  } else if (service === "iot") {
    if (hostname.startsWith("iot.")) {
      service = "execute-api";
    } else if (hostname.startsWith("data.jobs.iot.")) {
      service = "iot-jobs-data";
    } else {
      service = pathname === "/mqtt" ? "iotdevicegateway" : "iotdata";
    }
  } else if (service === "autoscaling") {
    const targetPrefix = (headers.get("X-Amz-Target") || "").split(".")[0];
    if (targetPrefix === "AnyScaleFrontendService") {
      service = "application-autoscaling";
    } else if (targetPrefix === "AnyScaleScalingPlannerFrontendService") {
      service = "autoscaling-plans";
    }
  } else if (region == null && service.startsWith("s3-")) {
    region = service.slice(3).replace(/^fips-|^external-1/, "");
    service = "s3";
  } else if (service.endsWith("-fips")) {
    service = service.slice(0, -5);
  } else if (region && /-\d$/.test(service) && !/-\d$/.test(region)) {
    [service, region] = [region, service];
  }
  return [HOST_SERVICES[service] || service, region || ""];
}
var encoder, HOST_SERVICES, UNSIGNABLE_HEADERS, AwsV4Signer, HEX_CHARS;
var init_aws4fetch_esm = __esm({
  "node_modules/aws4fetch/dist/aws4fetch.esm.mjs"() {
    encoder = new TextEncoder();
    HOST_SERVICES = {
      appstream2: "appstream",
      cloudhsmv2: "cloudhsm",
      email: "ses",
      marketplace: "aws-marketplace",
      mobile: "AWSMobileHubService",
      pinpoint: "mobiletargeting",
      queue: "sqs",
      "git-codecommit": "codecommit",
      "mturk-requester-sandbox": "mturk-requester",
      "personalize-runtime": "personalize"
    };
    UNSIGNABLE_HEADERS = /* @__PURE__ */ new Set([
      "authorization",
      "content-type",
      "content-length",
      "user-agent",
      "presigned-expires",
      "expect",
      "x-amzn-trace-id",
      "range",
      "connection"
    ]);
    AwsV4Signer = class {
      constructor({ method, url, headers, body, accessKeyId, secretAccessKey, sessionToken, service, region, cache, datetime, signQuery, appendSessionToken, allHeaders, singleEncode }) {
        if (url == null) throw new TypeError("url is a required option");
        if (accessKeyId == null) throw new TypeError("accessKeyId is a required option");
        if (secretAccessKey == null) throw new TypeError("secretAccessKey is a required option");
        this.method = method || (body ? "POST" : "GET");
        this.url = new URL(url);
        this.headers = new Headers(headers || {});
        this.body = body;
        this.accessKeyId = accessKeyId;
        this.secretAccessKey = secretAccessKey;
        this.sessionToken = sessionToken;
        let guessedService, guessedRegion;
        if (!service || !region) {
          [guessedService, guessedRegion] = guessServiceRegion(this.url, this.headers);
        }
        this.service = service || guessedService || "";
        this.region = region || guessedRegion || "us-east-1";
        this.cache = cache || /* @__PURE__ */ new Map();
        this.datetime = datetime || (/* @__PURE__ */ new Date()).toISOString().replace(/[:-]|\.\d{3}/g, "");
        this.signQuery = signQuery;
        this.appendSessionToken = appendSessionToken || this.service === "iotdevicegateway";
        this.headers.delete("Host");
        if (this.service === "s3" && !this.signQuery && !this.headers.has("X-Amz-Content-Sha256")) {
          this.headers.set("X-Amz-Content-Sha256", "UNSIGNED-PAYLOAD");
        }
        const params = this.signQuery ? this.url.searchParams : this.headers;
        params.set("X-Amz-Date", this.datetime);
        if (this.sessionToken && !this.appendSessionToken) {
          params.set("X-Amz-Security-Token", this.sessionToken);
        }
        this.signableHeaders = ["host", ...this.headers.keys()].filter((header) => allHeaders || !UNSIGNABLE_HEADERS.has(header)).sort();
        this.signedHeaders = this.signableHeaders.join(";");
        this.canonicalHeaders = this.signableHeaders.map((header) => header + ":" + (header === "host" ? this.url.host : (this.headers.get(header) || "").replace(/\s+/g, " "))).join("\n");
        this.credentialString = [this.datetime.slice(0, 8), this.region, this.service, "aws4_request"].join("/");
        if (this.signQuery) {
          if (this.service === "s3" && !params.has("X-Amz-Expires")) {
            params.set("X-Amz-Expires", "86400");
          }
          params.set("X-Amz-Algorithm", "AWS4-HMAC-SHA256");
          params.set("X-Amz-Credential", this.accessKeyId + "/" + this.credentialString);
          params.set("X-Amz-SignedHeaders", this.signedHeaders);
        }
        if (this.service === "s3") {
          try {
            this.encodedPath = decodeURIComponent(this.url.pathname.replace(/\+/g, " "));
          } catch (e) {
            this.encodedPath = this.url.pathname;
          }
        } else {
          this.encodedPath = this.url.pathname.replace(/\/+/g, "/");
        }
        if (!singleEncode) {
          this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, "/");
        }
        this.encodedPath = encodeRfc3986(this.encodedPath);
        const seenKeys = /* @__PURE__ */ new Set();
        this.encodedSearch = [...this.url.searchParams].filter(([k]) => {
          if (!k) return false;
          if (this.service === "s3") {
            if (seenKeys.has(k)) return false;
            seenKeys.add(k);
          }
          return true;
        }).map((pair) => pair.map((p) => encodeRfc3986(encodeURIComponent(p)))).sort(([k1, v1], [k2, v2]) => k1 < k2 ? -1 : k1 > k2 ? 1 : v1 < v2 ? -1 : v1 > v2 ? 1 : 0).map((pair) => pair.join("=")).join("&");
      }
      async sign() {
        if (this.signQuery) {
          this.url.searchParams.set("X-Amz-Signature", await this.signature());
          if (this.sessionToken && this.appendSessionToken) {
            this.url.searchParams.set("X-Amz-Security-Token", this.sessionToken);
          }
        } else {
          this.headers.set("Authorization", await this.authHeader());
        }
        return {
          method: this.method,
          url: this.url,
          headers: this.headers,
          body: this.body
        };
      }
      async authHeader() {
        return [
          "AWS4-HMAC-SHA256 Credential=" + this.accessKeyId + "/" + this.credentialString,
          "SignedHeaders=" + this.signedHeaders,
          "Signature=" + await this.signature()
        ].join(", ");
      }
      async signature() {
        const date = this.datetime.slice(0, 8);
        const cacheKey = [this.secretAccessKey, date, this.region, this.service].join();
        let kCredentials = this.cache.get(cacheKey);
        if (!kCredentials) {
          const kDate = await hmac("AWS4" + this.secretAccessKey, date);
          const kRegion = await hmac(kDate, this.region);
          const kService = await hmac(kRegion, this.service);
          kCredentials = await hmac(kService, "aws4_request");
          this.cache.set(cacheKey, kCredentials);
        }
        return buf2hex(await hmac(kCredentials, await this.stringToSign()));
      }
      async stringToSign() {
        return [
          "AWS4-HMAC-SHA256",
          this.datetime,
          this.credentialString,
          buf2hex(await hash(await this.canonicalString()))
        ].join("\n");
      }
      async canonicalString() {
        return [
          this.method.toUpperCase(),
          this.encodedPath,
          this.encodedSearch,
          this.canonicalHeaders + "\n",
          this.signedHeaders,
          await this.hexBodyHash()
        ].join("\n");
      }
      async hexBodyHash() {
        let hashHeader = this.headers.get("X-Amz-Content-Sha256") || (this.service === "s3" && this.signQuery ? "UNSIGNED-PAYLOAD" : null);
        if (hashHeader == null) {
          if (this.body && typeof this.body !== "string" && !("byteLength" in this.body)) {
            throw new Error("body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header");
          }
          hashHeader = buf2hex(await hash(this.body || ""));
        }
        return hashHeader;
      }
    };
    HEX_CHARS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
  }
});

// node_modules/@ai-sdk/amazon-bedrock/dist/index.mjs
var dist_exports10 = {};
__export(dist_exports10, {
  VERSION: () => VERSION12,
  bedrock: () => bedrock,
  createAmazonBedrock: () => createAmazonBedrock
});
import { z as z312 } from "zod/v4";
import { z as z41 } from "zod/v4";
import { z as z214 } from "zod/v4";
import { z as z412 } from "zod/v4";
import { z as z511 } from "zod/v4";
import { z as z611 } from "zod/v4";
import { z as z711 } from "zod/v4";
import { z as z811 } from "zod/v4";
function createBedrockEventStreamDecoder(body, processEvent) {
  const codec = new import_eventstream_codec.EventStreamCodec(import_util_utf8.toUtf8, import_util_utf8.fromUtf8);
  let buffer = new Uint8Array(0);
  const textDecoder = new TextDecoder();
  return body.pipeThrough(
    new TransformStream({
      async transform(chunk, controller) {
        var _a25, _b18;
        const newBuffer = new Uint8Array(buffer.length + chunk.length);
        newBuffer.set(buffer);
        newBuffer.set(chunk, buffer.length);
        buffer = newBuffer;
        while (buffer.length >= 4) {
          const totalLength = new DataView(
            buffer.buffer,
            buffer.byteOffset,
            buffer.byteLength
          ).getUint32(0, false);
          if (buffer.length < totalLength) {
            break;
          }
          try {
            const subView = buffer.subarray(0, totalLength);
            const decoded = codec.decode(subView);
            buffer = buffer.slice(totalLength);
            const messageType = (_a25 = decoded.headers[":message-type"]) == null ? void 0 : _a25.value;
            const eventType = (_b18 = decoded.headers[":event-type"]) == null ? void 0 : _b18.value;
            const data = textDecoder.decode(decoded.body);
            await processEvent({ messageType, eventType, data }, controller);
          } catch (e) {
            break;
          }
        }
      }
    })
  );
}
async function prepareTools7({
  tools,
  toolChoice,
  modelId
}) {
  var _a25;
  const toolWarnings = [];
  const betas = /* @__PURE__ */ new Set();
  if (tools == null || tools.length === 0) {
    return {
      toolConfig: {},
      additionalTools: void 0,
      betas,
      toolWarnings
    };
  }
  const supportedTools = tools.filter((tool2) => {
    if (tool2.type === "provider" && tool2.id === "anthropic.web_search_20250305") {
      toolWarnings.push({
        type: "unsupported",
        feature: "web_search_20250305 tool",
        details: "The web_search_20250305 tool is not supported on Amazon Bedrock."
      });
      return false;
    }
    return true;
  });
  if (supportedTools.length === 0) {
    return {
      toolConfig: {},
      additionalTools: void 0,
      betas,
      toolWarnings
    };
  }
  const isAnthropicModel = modelId.includes("anthropic.");
  const ProviderTools = supportedTools.filter((t) => t.type === "provider");
  const functionTools = supportedTools.filter((t) => t.type === "function");
  let additionalTools = void 0;
  const bedrockTools = [];
  const usingAnthropicTools = isAnthropicModel && ProviderTools.length > 0;
  if (usingAnthropicTools) {
    if (functionTools.length > 0) {
      toolWarnings.push({
        type: "unsupported",
        feature: "mixing Anthropic provider-defined tools and standard function tools",
        details: "Mixed Anthropic provider-defined tools and standard function tools are not supported in a single call to Bedrock. Only Anthropic tools will be used."
      });
    }
    const {
      toolChoice: preparedAnthropicToolChoice,
      toolWarnings: anthropicToolWarnings,
      betas: anthropicBetas
    } = await prepareTools6({
      tools: ProviderTools,
      toolChoice,
      supportsStructuredOutput: false
    });
    toolWarnings.push(...anthropicToolWarnings);
    anthropicBetas.forEach((beta) => betas.add(beta));
    if (preparedAnthropicToolChoice) {
      additionalTools = {
        tool_choice: preparedAnthropicToolChoice
      };
    }
    for (const tool2 of ProviderTools) {
      const toolFactory = Object.values(anthropicTools2).find((factory9) => {
        const instance = factory9({});
        return instance.id === tool2.id;
      });
      if (toolFactory != null) {
        const fullToolDefinition = toolFactory({});
        bedrockTools.push({
          toolSpec: {
            name: tool2.name,
            inputSchema: {
              json: await asSchema(fullToolDefinition.inputSchema).jsonSchema
            }
          }
        });
      } else {
        toolWarnings.push({ type: "unsupported", feature: "tool ${tool.id}" });
      }
    }
  } else {
    for (const tool2 of ProviderTools) {
      toolWarnings.push({ type: "unsupported", feature: `tool ${tool2.id}` });
    }
  }
  for (const tool2 of functionTools) {
    bedrockTools.push({
      toolSpec: {
        name: tool2.name,
        ...((_a25 = tool2.description) == null ? void 0 : _a25.trim()) !== "" ? { description: tool2.description } : {},
        inputSchema: {
          json: tool2.inputSchema
        }
      }
    });
  }
  let bedrockToolChoice = void 0;
  if (!usingAnthropicTools && bedrockTools.length > 0 && toolChoice) {
    const type2 = toolChoice.type;
    switch (type2) {
      case "auto":
        bedrockToolChoice = { auto: {} };
        break;
      case "required":
        bedrockToolChoice = { any: {} };
        break;
      case "none":
        bedrockTools.length = 0;
        bedrockToolChoice = void 0;
        break;
      case "tool":
        bedrockToolChoice = { tool: { name: toolChoice.toolName } };
        break;
      default: {
        const _exhaustiveCheck = type2;
        throw new UnsupportedFunctionalityError({
          functionality: `tool choice type: ${_exhaustiveCheck}`
        });
      }
    }
  }
  const toolConfig = bedrockTools.length > 0 ? { tools: bedrockTools, toolChoice: bedrockToolChoice } : {};
  return {
    toolConfig,
    additionalTools,
    betas,
    toolWarnings
  };
}
function convertBedrockUsage(usage) {
  var _a25, _b18;
  if (usage == null) {
    return {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
  }
  const inputTokens = usage.inputTokens;
  const outputTokens = usage.outputTokens;
  const cacheReadTokens = (_a25 = usage.cacheReadInputTokens) != null ? _a25 : 0;
  const cacheWriteTokens = (_b18 = usage.cacheWriteInputTokens) != null ? _b18 : 0;
  return {
    inputTokens: {
      total: inputTokens + cacheReadTokens + cacheWriteTokens,
      noCache: inputTokens,
      cacheRead: cacheReadTokens,
      cacheWrite: cacheWriteTokens
    },
    outputTokens: {
      total: outputTokens,
      text: outputTokens,
      reasoning: void 0
    },
    raw: usage
  };
}
function isMistralModel(modelId) {
  return modelId.includes("mistral.");
}
function normalizeToolCallId(toolCallId, isMistral) {
  if (!isMistral) {
    return toolCallId;
  }
  const alphanumericChars = toolCallId.replace(/[^a-zA-Z0-9]/g, "");
  return alphanumericChars.slice(0, 9);
}
function getCachePoint(providerMetadata) {
  var _a25;
  const cachePointConfig = (_a25 = providerMetadata == null ? void 0 : providerMetadata.bedrock) == null ? void 0 : _a25.cachePoint;
  if (!cachePointConfig) {
    return void 0;
  }
  return { cachePoint: cachePointConfig };
}
async function shouldEnableCitations(providerMetadata) {
  var _a25, _b18;
  const bedrockOptions = await parseProviderOptions({
    provider: "bedrock",
    providerOptions: providerMetadata,
    schema: bedrockFilePartProviderOptions
  });
  return (_b18 = (_a25 = bedrockOptions == null ? void 0 : bedrockOptions.citations) == null ? void 0 : _a25.enabled) != null ? _b18 : false;
}
async function convertToBedrockChatMessages(prompt, isMistral = false) {
  var _a25, _b18;
  const blocks = groupIntoBlocks2(prompt);
  let system = [];
  const messages = [];
  let documentCounter = 0;
  const generateDocumentName = () => `document-${++documentCounter}`;
  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    const isLastBlock = i === blocks.length - 1;
    const type2 = block.type;
    switch (type2) {
      case "system": {
        if (messages.length > 0) {
          throw new UnsupportedFunctionalityError({
            functionality: "Multiple system messages that are separated by user/assistant messages"
          });
        }
        for (const message of block.messages) {
          system.push({ text: message.content });
          const cachePoint = getCachePoint(message.providerOptions);
          if (cachePoint) {
            system.push(cachePoint);
          }
        }
        break;
      }
      case "user": {
        const bedrockContent = [];
        for (const message of block.messages) {
          const { role, content, providerOptions } = message;
          switch (role) {
            case "user": {
              for (let j = 0; j < content.length; j++) {
                const part = content[j];
                switch (part.type) {
                  case "text": {
                    bedrockContent.push({
                      text: part.text
                    });
                    break;
                  }
                  case "file": {
                    if (part.data instanceof URL) {
                      throw new UnsupportedFunctionalityError({
                        functionality: "File URL data"
                      });
                    }
                    if (part.mediaType.startsWith("image/")) {
                      bedrockContent.push({
                        image: {
                          format: getBedrockImageFormat(part.mediaType),
                          source: { bytes: convertToBase64(part.data) }
                        }
                      });
                    } else {
                      if (!part.mediaType) {
                        throw new UnsupportedFunctionalityError({
                          functionality: "file without mime type",
                          message: "File mime type is required in user message part content"
                        });
                      }
                      const enableCitations = await shouldEnableCitations(
                        part.providerOptions
                      );
                      bedrockContent.push({
                        document: {
                          format: getBedrockDocumentFormat(part.mediaType),
                          name: (_a25 = part.filename) != null ? _a25 : generateDocumentName(),
                          source: { bytes: convertToBase64(part.data) },
                          ...enableCitations && {
                            citations: { enabled: true }
                          }
                        }
                      });
                    }
                    break;
                  }
                }
              }
              break;
            }
            case "tool": {
              for (const part of content) {
                if (part.type === "tool-approval-response") {
                  continue;
                }
                let toolResultContent;
                const output = part.output;
                switch (output.type) {
                  case "content": {
                    toolResultContent = output.value.map((contentPart) => {
                      switch (contentPart.type) {
                        case "text":
                          return { text: contentPart.text };
                        case "image-data":
                          if (!contentPart.mediaType.startsWith("image/")) {
                            throw new UnsupportedFunctionalityError({
                              functionality: `media type: ${contentPart.mediaType}`
                            });
                          }
                          const format = getBedrockImageFormat(
                            contentPart.mediaType
                          );
                          return {
                            image: {
                              format,
                              source: { bytes: contentPart.data }
                            }
                          };
                        default: {
                          throw new UnsupportedFunctionalityError({
                            functionality: `unsupported tool content part type: ${contentPart.type}`
                          });
                        }
                      }
                    });
                    break;
                  }
                  case "text":
                  case "error-text":
                    toolResultContent = [{ text: output.value }];
                    break;
                  case "execution-denied":
                    toolResultContent = [
                      { text: (_b18 = output.reason) != null ? _b18 : "Tool execution denied." }
                    ];
                    break;
                  case "json":
                  case "error-json":
                  default:
                    toolResultContent = [
                      { text: JSON.stringify(output.value) }
                    ];
                    break;
                }
                bedrockContent.push({
                  toolResult: {
                    toolUseId: normalizeToolCallId(part.toolCallId, isMistral),
                    content: toolResultContent
                  }
                });
              }
              break;
            }
            default: {
              const _exhaustiveCheck = role;
              throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
            }
          }
          const cachePoint = getCachePoint(providerOptions);
          if (cachePoint) {
            bedrockContent.push(cachePoint);
          }
        }
        messages.push({ role: "user", content: bedrockContent });
        break;
      }
      case "assistant": {
        const bedrockContent = [];
        for (let j = 0; j < block.messages.length; j++) {
          const message = block.messages[j];
          const isLastMessage = j === block.messages.length - 1;
          const { content } = message;
          for (let k = 0; k < content.length; k++) {
            const part = content[k];
            const isLastContentPart = k === content.length - 1;
            switch (part.type) {
              case "text": {
                if (!part.text.trim()) {
                  break;
                }
                bedrockContent.push({
                  text: (
                    // trim the last text part if it's the last message in the block
                    // because Bedrock does not allow trailing whitespace
                    // in pre-filled assistant responses
                    trimIfLast(
                      isLastBlock,
                      isLastMessage,
                      isLastContentPart,
                      part.text
                    )
                  )
                });
                break;
              }
              case "reasoning": {
                const reasoningMetadata = await parseProviderOptions({
                  provider: "bedrock",
                  providerOptions: part.providerOptions,
                  schema: bedrockReasoningMetadataSchema
                });
                if (reasoningMetadata != null) {
                  if (reasoningMetadata.signature != null) {
                    bedrockContent.push({
                      reasoningContent: {
                        reasoningText: {
                          // trim the last text part if it's the last message in the block
                          // because Bedrock does not allow trailing whitespace
                          // in pre-filled assistant responses
                          text: trimIfLast(
                            isLastBlock,
                            isLastMessage,
                            isLastContentPart,
                            part.text
                          ),
                          signature: reasoningMetadata.signature
                        }
                      }
                    });
                  } else if (reasoningMetadata.redactedData != null) {
                    bedrockContent.push({
                      reasoningContent: {
                        redactedReasoning: {
                          data: reasoningMetadata.redactedData
                        }
                      }
                    });
                  }
                }
                break;
              }
              case "tool-call": {
                bedrockContent.push({
                  toolUse: {
                    toolUseId: normalizeToolCallId(part.toolCallId, isMistral),
                    name: part.toolName,
                    input: part.input
                  }
                });
                break;
              }
            }
          }
          const cachePoint = getCachePoint(message.providerOptions);
          if (cachePoint) {
            bedrockContent.push(cachePoint);
          }
        }
        messages.push({ role: "assistant", content: bedrockContent });
        break;
      }
      default: {
        const _exhaustiveCheck = type2;
        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);
      }
    }
  }
  return { system, messages };
}
function getBedrockImageFormat(mimeType) {
  if (!mimeType) {
    throw new UnsupportedFunctionalityError({
      functionality: "image without mime type",
      message: "Image mime type is required in user message part content"
    });
  }
  const format = BEDROCK_IMAGE_MIME_TYPES[mimeType];
  if (!format) {
    throw new UnsupportedFunctionalityError({
      functionality: `image mime type: ${mimeType}`,
      message: `Unsupported image mime type: ${mimeType}, expected one of: ${Object.keys(BEDROCK_IMAGE_MIME_TYPES).join(", ")}`
    });
  }
  return format;
}
function getBedrockDocumentFormat(mimeType) {
  const format = BEDROCK_DOCUMENT_MIME_TYPES[mimeType];
  if (!format) {
    throw new UnsupportedFunctionalityError({
      functionality: `file mime type: ${mimeType}`,
      message: `Unsupported file mime type: ${mimeType}, expected one of: ${Object.keys(BEDROCK_DOCUMENT_MIME_TYPES).join(", ")}`
    });
  }
  return format;
}
function trimIfLast(isLastBlock, isLastMessage, isLastContentPart, text2) {
  return isLastBlock && isLastMessage && isLastContentPart ? text2.trim() : text2;
}
function groupIntoBlocks2(prompt) {
  const blocks = [];
  let currentBlock = void 0;
  for (const message of prompt) {
    const { role } = message;
    switch (role) {
      case "system": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "system") {
          currentBlock = { type: "system", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "assistant": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "assistant") {
          currentBlock = { type: "assistant", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "user": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
          currentBlock = { type: "user", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "tool": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
          currentBlock = { type: "user", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return blocks;
}
function mapBedrockFinishReason(finishReason, isJsonResponseFromTool) {
  switch (finishReason) {
    case "stop_sequence":
    case "end_turn":
      return "stop";
    case "max_tokens":
      return "length";
    case "content_filtered":
    case "guardrail_intervened":
      return "content-filter";
    case "tool_use":
      return isJsonResponseFromTool ? "stop" : "tool-calls";
    default:
      return "other";
  }
}
function getBase64Data(file) {
  if (file.type === "url") {
    throw new Error(
      "URL-based images are not supported for Amazon Bedrock image editing. Please provide the image data directly."
    );
  }
  if (file.data instanceof Uint8Array) {
    return convertUint8ArrayToBase64(file.data);
  }
  return file.data;
}
function createSigV4FetchFunction(getCredentials, fetch2 = globalThis.fetch) {
  return async (input, init) => {
    var _a25, _b18;
    const request = input instanceof Request ? input : void 0;
    const originalHeaders = combineHeaders(
      normalizeHeaders(request == null ? void 0 : request.headers),
      normalizeHeaders(init == null ? void 0 : init.headers)
    );
    const headersWithUserAgent = withUserAgentSuffix(
      originalHeaders,
      `ai-sdk/amazon-bedrock/${VERSION12}`,
      getRuntimeEnvironmentUserAgent()
    );
    let effectiveBody = (_a25 = init == null ? void 0 : init.body) != null ? _a25 : void 0;
    if (effectiveBody === void 0 && request && request.body !== null) {
      try {
        effectiveBody = await request.clone().text();
      } catch (e) {
      }
    }
    const effectiveMethod = (_b18 = init == null ? void 0 : init.method) != null ? _b18 : request == null ? void 0 : request.method;
    if ((effectiveMethod == null ? void 0 : effectiveMethod.toUpperCase()) !== "POST" || !effectiveBody) {
      return fetch2(input, {
        ...init,
        headers: headersWithUserAgent
      });
    }
    const url = typeof input === "string" ? input : input instanceof URL ? input.href : input.url;
    const body = prepareBodyString(effectiveBody);
    const credentials = await getCredentials();
    const signer = new AwsV4Signer({
      url,
      method: "POST",
      headers: Object.entries(headersWithUserAgent),
      body,
      region: credentials.region,
      accessKeyId: credentials.accessKeyId,
      secretAccessKey: credentials.secretAccessKey,
      sessionToken: credentials.sessionToken,
      service: "bedrock"
    });
    const signingResult = await signer.sign();
    const signedHeaders = normalizeHeaders(signingResult.headers);
    const combinedHeaders = combineHeaders(headersWithUserAgent, signedHeaders);
    return fetch2(input, {
      ...init,
      body,
      headers: combinedHeaders
    });
  };
}
function prepareBodyString(body) {
  if (typeof body === "string") {
    return body;
  } else if (body instanceof Uint8Array) {
    return new TextDecoder().decode(body);
  } else if (body instanceof ArrayBuffer) {
    return new TextDecoder().decode(new Uint8Array(body));
  } else {
    return JSON.stringify(body);
  }
}
function createApiKeyFetchFunction(apiKey, fetch2 = globalThis.fetch) {
  return async (input, init) => {
    const originalHeaders = normalizeHeaders(init == null ? void 0 : init.headers);
    const headersWithUserAgent = withUserAgentSuffix(
      originalHeaders,
      `ai-sdk/amazon-bedrock/${VERSION12}`,
      getRuntimeEnvironmentUserAgent()
    );
    const finalHeaders = combineHeaders(headersWithUserAgent, {
      Authorization: `Bearer ${apiKey}`
    });
    return fetch2(input, {
      ...init,
      headers: finalHeaders
    });
  };
}
function createAmazonBedrock(options = {}) {
  const rawApiKey = loadOptionalSetting({
    settingValue: options.apiKey,
    environmentVariableName: "AWS_BEARER_TOKEN_BEDROCK"
  });
  const apiKey = rawApiKey && rawApiKey.trim().length > 0 ? rawApiKey.trim() : void 0;
  const fetchFunction = apiKey ? createApiKeyFetchFunction(apiKey, options.fetch) : createSigV4FetchFunction(async () => {
    const region = loadSetting({
      settingValue: options.region,
      settingName: "region",
      environmentVariableName: "AWS_REGION",
      description: "AWS region"
    });
    if (options.credentialProvider) {
      try {
        return {
          ...await options.credentialProvider(),
          region
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        throw new Error(
          `AWS credential provider failed: ${errorMessage}. Please ensure your credential provider returns valid AWS credentials with accessKeyId and secretAccessKey properties.`
        );
      }
    }
    try {
      return {
        region,
        accessKeyId: loadSetting({
          settingValue: options.accessKeyId,
          settingName: "accessKeyId",
          environmentVariableName: "AWS_ACCESS_KEY_ID",
          description: "AWS access key ID"
        }),
        secretAccessKey: loadSetting({
          settingValue: options.secretAccessKey,
          settingName: "secretAccessKey",
          environmentVariableName: "AWS_SECRET_ACCESS_KEY",
          description: "AWS secret access key"
        }),
        sessionToken: loadOptionalSetting({
          settingValue: options.sessionToken,
          environmentVariableName: "AWS_SESSION_TOKEN"
        })
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes("AWS_ACCESS_KEY_ID") || errorMessage.includes("accessKeyId")) {
        throw new Error(
          `AWS SigV4 authentication requires AWS credentials. Please provide either:
1. Set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables
2. Provide accessKeyId and secretAccessKey in options
3. Use a credentialProvider function
4. Use API key authentication with AWS_BEARER_TOKEN_BEDROCK or apiKey option
Original error: ${errorMessage}`
        );
      }
      if (errorMessage.includes("AWS_SECRET_ACCESS_KEY") || errorMessage.includes("secretAccessKey")) {
        throw new Error(
          `AWS SigV4 authentication requires both AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY. Please ensure both credentials are provided.
Original error: ${errorMessage}`
        );
      }
      throw error;
    }
  }, options.fetch);
  const getHeaders = () => {
    var _a25;
    const baseHeaders = (_a25 = options.headers) != null ? _a25 : {};
    return withUserAgentSuffix(baseHeaders, `ai-sdk/amazon-bedrock/${VERSION12}`);
  };
  const getBedrockRuntimeBaseUrl = () => {
    var _a25, _b18;
    return (_b18 = withoutTrailingSlash(
      (_a25 = options.baseURL) != null ? _a25 : `https://bedrock-runtime.${loadSetting({
        settingValue: options.region,
        settingName: "region",
        environmentVariableName: "AWS_REGION",
        description: "AWS region"
      })}.amazonaws.com`
    )) != null ? _b18 : `https://bedrock-runtime.us-east-1.amazonaws.com`;
  };
  const getBedrockAgentRuntimeBaseUrl = () => {
    var _a25, _b18;
    return (_b18 = withoutTrailingSlash(
      (_a25 = options.baseURL) != null ? _a25 : `https://bedrock-agent-runtime.${loadSetting({
        settingValue: options.region,
        settingName: "region",
        environmentVariableName: "AWS_REGION",
        description: "AWS region"
      })}.amazonaws.com`
    )) != null ? _b18 : `https://bedrock-agent-runtime.us-west-2.amazonaws.com`;
  };
  const createChatModel = (modelId) => new BedrockChatLanguageModel(modelId, {
    baseUrl: getBedrockRuntimeBaseUrl,
    headers: getHeaders,
    fetch: fetchFunction,
    generateId
  });
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Amazon Bedrock model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  const createEmbeddingModel = (modelId) => new BedrockEmbeddingModel(modelId, {
    baseUrl: getBedrockRuntimeBaseUrl,
    headers: getHeaders,
    fetch: fetchFunction
  });
  const createImageModel = (modelId) => new BedrockImageModel(modelId, {
    baseUrl: getBedrockRuntimeBaseUrl,
    headers: getHeaders,
    fetch: fetchFunction
  });
  const createRerankingModel = (modelId) => new BedrockRerankingModel(modelId, {
    baseUrl: getBedrockAgentRuntimeBaseUrl,
    region: loadSetting({
      settingValue: options.region,
      settingName: "region",
      environmentVariableName: "AWS_REGION",
      description: "AWS region"
    }),
    headers: getHeaders,
    fetch: fetchFunction
  });
  provider.specificationVersion = "v3";
  provider.languageModel = createChatModel;
  provider.embedding = createEmbeddingModel;
  provider.embeddingModel = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  provider.reranking = createRerankingModel;
  provider.rerankingModel = createRerankingModel;
  provider.tools = anthropicTools2;
  return provider;
}
var import_eventstream_codec, import_util_utf8, BEDROCK_STOP_REASONS, BEDROCK_IMAGE_MIME_TYPES, BEDROCK_DOCUMENT_MIME_TYPES, bedrockFilePartProviderOptions, bedrockProviderOptions, BedrockErrorSchema, createBedrockEventStreamResponseHandler, BedrockChatLanguageModel, BedrockStopReasonSchema, BedrockAdditionalModelResponseFieldsSchema, BedrockToolUseSchema, BedrockReasoningTextSchema, BedrockRedactedReasoningSchema, BedrockResponseSchema, BedrockStreamSchema, bedrockReasoningMetadataSchema, bedrockEmbeddingProviderOptions, BedrockEmbeddingModel, BedrockEmbeddingResponseSchema, modelMaxImagesPerCall2, BedrockImageModel, bedrockImageResponseSchema, VERSION12, bedrockRerankingResponseSchema, bedrockRerankingOptionsSchema, BedrockRerankingModel, bedrock;
var init_dist18 = __esm({
  "node_modules/@ai-sdk/amazon-bedrock/dist/index.mjs"() {
    init_internal();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    import_eventstream_codec = __toESM(require_dist_cjs5(), 1);
    import_util_utf8 = __toESM(require_dist_cjs8(), 1);
    init_dist6();
    init_dist8();
    init_internal();
    init_dist6();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_aws4fetch_esm();
    init_dist8();
    init_dist8();
    init_dist8();
    BEDROCK_STOP_REASONS = [
      "stop",
      "stop_sequence",
      "end_turn",
      "length",
      "max_tokens",
      "content-filter",
      "content_filtered",
      "guardrail_intervened",
      "tool-calls",
      "tool_use"
    ];
    BEDROCK_IMAGE_MIME_TYPES = {
      "image/jpeg": "jpeg",
      "image/png": "png",
      "image/gif": "gif",
      "image/webp": "webp"
    };
    BEDROCK_DOCUMENT_MIME_TYPES = {
      "application/pdf": "pdf",
      "text/csv": "csv",
      "application/msword": "doc",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
      "application/vnd.ms-excel": "xls",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
      "text/html": "html",
      "text/plain": "txt",
      "text/markdown": "md"
    };
    bedrockFilePartProviderOptions = z41.object({
      /**
       * Citation configuration for this document.
       * When enabled, this document will generate citations in the response.
       */
      citations: z41.object({
        /**
         * Enable citations for this document
         */
        enabled: z41.boolean()
      }).optional()
    });
    bedrockProviderOptions = z41.object({
      /**
       * Additional inference parameters that the model supports,
       * beyond the base set of inference parameters that Converse
       * supports in the inferenceConfig field
       */
      additionalModelRequestFields: z41.record(z41.string(), z41.any()).optional(),
      reasoningConfig: z41.object({
        type: z41.union([z41.literal("enabled"), z41.literal("disabled")]).optional(),
        budgetTokens: z41.number().optional(),
        maxReasoningEffort: z41.enum(["low", "medium", "high"]).optional()
      }).optional(),
      /**
       * Anthropic beta features to enable
       */
      anthropicBeta: z41.array(z41.string()).optional()
    });
    BedrockErrorSchema = z214.object({
      message: z214.string(),
      type: z214.string().nullish()
    });
    createBedrockEventStreamResponseHandler = (chunkSchema2) => async ({ response }) => {
      const responseHeaders = extractResponseHeaders(response);
      if (response.body == null) {
        throw new EmptyResponseBodyError({});
      }
      return {
        responseHeaders,
        value: createBedrockEventStreamDecoder(
          response.body,
          async (event, controller) => {
            if (event.messageType === "event") {
              const parsedDataResult = await safeParseJSON({ text: event.data });
              if (!parsedDataResult.success) {
                controller.enqueue(parsedDataResult);
                return;
              }
              delete parsedDataResult.value.p;
              const wrappedData = {
                [event.eventType]: parsedDataResult.value
              };
              const validatedWrappedData = await safeValidateTypes({
                value: wrappedData,
                schema: chunkSchema2
              });
              if (!validatedWrappedData.success) {
                controller.enqueue(validatedWrappedData);
              } else {
                controller.enqueue({
                  success: true,
                  value: validatedWrappedData.value,
                  rawValue: wrappedData
                });
              }
            }
          }
        )
      };
    };
    BedrockChatLanguageModel = class {
      constructor(modelId, config2) {
        this.modelId = modelId;
        this.config = config2;
        this.specificationVersion = "v3";
        this.provider = "amazon-bedrock";
        this.supportedUrls = {
          // no supported urls for bedrock
        };
      }
      async getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        stopSequences,
        responseFormat,
        seed,
        tools,
        toolChoice,
        providerOptions
      }) {
        var _a25, _b18, _c, _d, _e, _f, _g, _h, _i;
        const bedrockOptions = (_a25 = await parseProviderOptions({
          provider: "bedrock",
          providerOptions,
          schema: bedrockProviderOptions
        })) != null ? _a25 : {};
        const warnings = [];
        if (frequencyPenalty != null) {
          warnings.push({
            type: "unsupported",
            feature: "frequencyPenalty"
          });
        }
        if (presencePenalty != null) {
          warnings.push({
            type: "unsupported",
            feature: "presencePenalty"
          });
        }
        if (seed != null) {
          warnings.push({
            type: "unsupported",
            feature: "seed"
          });
        }
        if (temperature != null && temperature > 1) {
          warnings.push({
            type: "unsupported",
            feature: "temperature",
            details: `${temperature} exceeds bedrock maximum of 1.0. clamped to 1.0`
          });
          temperature = 1;
        } else if (temperature != null && temperature < 0) {
          warnings.push({
            type: "unsupported",
            feature: "temperature",
            details: `${temperature} is below bedrock minimum of 0. clamped to 0`
          });
          temperature = 0;
        }
        if (responseFormat != null && responseFormat.type !== "text" && responseFormat.type !== "json") {
          warnings.push({
            type: "unsupported",
            feature: "responseFormat",
            details: "Only text and json response formats are supported."
          });
        }
        const jsonResponseTool = (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null ? {
          type: "function",
          name: "json",
          description: "Respond with a JSON object.",
          inputSchema: responseFormat.schema
        } : void 0;
        const { toolConfig, additionalTools, toolWarnings, betas } = await prepareTools7({
          tools: jsonResponseTool ? [...tools != null ? tools : [], jsonResponseTool] : tools,
          toolChoice: jsonResponseTool != null ? { type: "required" } : toolChoice,
          modelId: this.modelId
        });
        warnings.push(...toolWarnings);
        if (additionalTools) {
          bedrockOptions.additionalModelRequestFields = {
            ...bedrockOptions.additionalModelRequestFields,
            ...additionalTools
          };
        }
        if (betas.size > 0 || bedrockOptions.anthropicBeta) {
          const existingBetas = (_b18 = bedrockOptions.anthropicBeta) != null ? _b18 : [];
          const mergedBetas = betas.size > 0 ? [...existingBetas, ...Array.from(betas)] : existingBetas;
          bedrockOptions.additionalModelRequestFields = {
            ...bedrockOptions.additionalModelRequestFields,
            anthropic_beta: mergedBetas
          };
        }
        const isAnthropicModel = this.modelId.includes("anthropic");
        const isThinkingRequested = ((_c = bedrockOptions.reasoningConfig) == null ? void 0 : _c.type) === "enabled";
        const thinkingBudget = (_d = bedrockOptions.reasoningConfig) == null ? void 0 : _d.budgetTokens;
        const isAnthropicThinkingEnabled = isAnthropicModel && isThinkingRequested;
        const inferenceConfig = {
          ...maxOutputTokens != null && { maxTokens: maxOutputTokens },
          ...temperature != null && { temperature },
          ...topP != null && { topP },
          ...topK != null && { topK },
          ...stopSequences != null && { stopSequences }
        };
        if (isAnthropicThinkingEnabled && thinkingBudget != null) {
          if (inferenceConfig.maxTokens != null) {
            inferenceConfig.maxTokens += thinkingBudget;
          } else {
            inferenceConfig.maxTokens = thinkingBudget + 4096;
          }
          bedrockOptions.additionalModelRequestFields = {
            ...bedrockOptions.additionalModelRequestFields,
            thinking: {
              type: (_e = bedrockOptions.reasoningConfig) == null ? void 0 : _e.type,
              budget_tokens: thinkingBudget
            }
          };
        } else if (!isAnthropicModel && thinkingBudget != null) {
          warnings.push({
            type: "unsupported",
            feature: "budgetTokens",
            details: "budgetTokens applies only to Anthropic models on Bedrock and will be ignored for this model."
          });
        }
        const maxReasoningEffort = (_f = bedrockOptions.reasoningConfig) == null ? void 0 : _f.maxReasoningEffort;
        const isOpenAIModel = this.modelId.startsWith("openai.");
        if (maxReasoningEffort != null && !isAnthropicModel) {
          if (isOpenAIModel) {
            bedrockOptions.additionalModelRequestFields = {
              ...bedrockOptions.additionalModelRequestFields,
              reasoning_effort: maxReasoningEffort
            };
          } else {
            bedrockOptions.additionalModelRequestFields = {
              ...bedrockOptions.additionalModelRequestFields,
              reasoningConfig: {
                ...((_g = bedrockOptions.reasoningConfig) == null ? void 0 : _g.type) != null && {
                  type: bedrockOptions.reasoningConfig.type
                },
                maxReasoningEffort
              }
            };
          }
        } else if (maxReasoningEffort != null && isAnthropicModel) {
          warnings.push({
            type: "unsupported",
            feature: "maxReasoningEffort",
            details: "maxReasoningEffort applies only to Amazon Nova models on Bedrock and will be ignored for this model."
          });
        }
        if (isAnthropicThinkingEnabled && inferenceConfig.temperature != null) {
          delete inferenceConfig.temperature;
          warnings.push({
            type: "unsupported",
            feature: "temperature",
            details: "temperature is not supported when thinking is enabled"
          });
        }
        if (isAnthropicThinkingEnabled && inferenceConfig.topP != null) {
          delete inferenceConfig.topP;
          warnings.push({
            type: "unsupported",
            feature: "topP",
            details: "topP is not supported when thinking is enabled"
          });
        }
        if (isAnthropicThinkingEnabled && inferenceConfig.topK != null) {
          delete inferenceConfig.topK;
          warnings.push({
            type: "unsupported",
            feature: "topK",
            details: "topK is not supported when thinking is enabled"
          });
        }
        const hasAnyTools = ((_i = (_h = toolConfig.tools) == null ? void 0 : _h.length) != null ? _i : 0) > 0 || additionalTools;
        let filteredPrompt = prompt;
        if (!hasAnyTools) {
          const hasToolContent = prompt.some(
            (message) => "content" in message && Array.isArray(message.content) && message.content.some(
              (part) => part.type === "tool-call" || part.type === "tool-result"
            )
          );
          if (hasToolContent) {
            filteredPrompt = prompt.map(
              (message) => message.role === "system" ? message : {
                ...message,
                content: message.content.filter(
                  (part) => part.type !== "tool-call" && part.type !== "tool-result"
                )
              }
            ).filter(
              (message) => message.role === "system" || message.content.length > 0
            );
            warnings.push({
              type: "unsupported",
              feature: "toolContent",
              details: "Tool calls and results removed from conversation because Bedrock does not support tool content without active tools."
            });
          }
        }
        const isMistral = isMistralModel(this.modelId);
        const { system, messages } = await convertToBedrockChatMessages(
          filteredPrompt,
          isMistral
        );
        const {
          reasoningConfig: _,
          additionalModelRequestFields: __,
          ...filteredBedrockOptions
        } = (providerOptions == null ? void 0 : providerOptions.bedrock) || {};
        const additionalModelResponseFieldPaths = isAnthropicModel ? ["/delta/stop_sequence"] : void 0;
        return {
          command: {
            system,
            messages,
            additionalModelRequestFields: bedrockOptions.additionalModelRequestFields,
            ...additionalModelResponseFieldPaths && {
              additionalModelResponseFieldPaths
            },
            ...Object.keys(inferenceConfig).length > 0 && {
              inferenceConfig
            },
            ...filteredBedrockOptions,
            ...toolConfig.tools !== void 0 && toolConfig.tools.length > 0 ? { toolConfig } : {}
          },
          warnings,
          usesJsonResponseTool: jsonResponseTool != null,
          betas
        };
      }
      async getHeaders({
        headers
      }) {
        return combineHeaders(await resolve(this.config.headers), headers);
      }
      async doGenerate(options) {
        var _a25, _b18, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
        const {
          command: args2,
          warnings,
          usesJsonResponseTool
        } = await this.getArgs(options);
        const url = `${this.getUrl(this.modelId)}/converse`;
        const { value: response, responseHeaders } = await postJsonToApi({
          url,
          headers: await this.getHeaders({ headers: options.headers }),
          body: args2,
          failedResponseHandler: createJsonErrorResponseHandler({
            errorSchema: BedrockErrorSchema,
            errorToMessage: (error) => {
              var _a26;
              return `${(_a26 = error.message) != null ? _a26 : "Unknown error"}`;
            }
          }),
          successfulResponseHandler: createJsonResponseHandler(
            BedrockResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const content = [];
        let isJsonResponseFromTool = false;
        for (const part of response.output.message.content) {
          if (part.text) {
            content.push({ type: "text", text: part.text });
          }
          if (part.reasoningContent) {
            if ("reasoningText" in part.reasoningContent) {
              const reasoning = {
                type: "reasoning",
                text: part.reasoningContent.reasoningText.text
              };
              if (part.reasoningContent.reasoningText.signature) {
                reasoning.providerMetadata = {
                  bedrock: {
                    signature: part.reasoningContent.reasoningText.signature
                  }
                };
              }
              content.push(reasoning);
            } else if ("redactedReasoning" in part.reasoningContent) {
              content.push({
                type: "reasoning",
                text: "",
                providerMetadata: {
                  bedrock: {
                    redactedData: (_a25 = part.reasoningContent.redactedReasoning.data) != null ? _a25 : ""
                  }
                }
              });
            }
          }
          if (part.toolUse) {
            const isJsonResponseTool = usesJsonResponseTool && part.toolUse.name === "json";
            if (isJsonResponseTool) {
              isJsonResponseFromTool = true;
              content.push({
                type: "text",
                text: JSON.stringify(part.toolUse.input)
              });
            } else {
              const isMistral = isMistralModel(this.modelId);
              const rawToolCallId = (_c = (_b18 = part.toolUse) == null ? void 0 : _b18.toolUseId) != null ? _c : this.config.generateId();
              content.push({
                type: "tool-call",
                toolCallId: normalizeToolCallId(rawToolCallId, isMistral),
                toolName: (_e = (_d = part.toolUse) == null ? void 0 : _d.name) != null ? _e : `tool-${this.config.generateId()}`,
                input: JSON.stringify((_g = (_f = part.toolUse) == null ? void 0 : _f.input) != null ? _g : {})
              });
            }
          }
        }
        const stopSequence = (_j = (_i = (_h = response.additionalModelResponseFields) == null ? void 0 : _h.delta) == null ? void 0 : _i.stop_sequence) != null ? _j : null;
        const providerMetadata = response.trace || response.usage || isJsonResponseFromTool || stopSequence ? {
          bedrock: {
            ...response.trace && typeof response.trace === "object" ? { trace: response.trace } : {},
            ...((_k = response.usage) == null ? void 0 : _k.cacheWriteInputTokens) != null && {
              usage: {
                cacheWriteInputTokens: response.usage.cacheWriteInputTokens
              }
            },
            ...isJsonResponseFromTool && { isJsonResponseFromTool: true },
            stopSequence
          }
        } : void 0;
        return {
          content,
          finishReason: {
            unified: mapBedrockFinishReason(
              response.stopReason,
              isJsonResponseFromTool
            ),
            raw: (_l = response.stopReason) != null ? _l : void 0
          },
          usage: convertBedrockUsage(response.usage),
          response: {
            // TODO add id, timestamp, etc
            headers: responseHeaders
          },
          warnings,
          ...providerMetadata && { providerMetadata }
        };
      }
      async doStream(options) {
        const {
          command: args2,
          warnings,
          usesJsonResponseTool
        } = await this.getArgs(options);
        const isMistral = isMistralModel(this.modelId);
        const url = `${this.getUrl(this.modelId)}/converse-stream`;
        const { value: response, responseHeaders } = await postJsonToApi({
          url,
          headers: await this.getHeaders({ headers: options.headers }),
          body: args2,
          failedResponseHandler: createJsonErrorResponseHandler({
            errorSchema: BedrockErrorSchema,
            errorToMessage: (error) => `${error.type}: ${error.message}`
          }),
          successfulResponseHandler: createBedrockEventStreamResponseHandler(BedrockStreamSchema),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        let finishReason = {
          unified: "other",
          raw: void 0
        };
        let usage = void 0;
        let providerMetadata = void 0;
        let isJsonResponseFromTool = false;
        let stopSequence = null;
        const contentBlocks = {};
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                controller.enqueue({ type: "stream-start", warnings });
              },
              transform(chunk, controller) {
                var _a25, _b18, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
                function enqueueError(bedrockError) {
                  finishReason = { unified: "error", raw: void 0 };
                  controller.enqueue({ type: "error", error: bedrockError });
                }
                if (options.includeRawChunks) {
                  controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                }
                if (!chunk.success) {
                  enqueueError(chunk.error);
                  return;
                }
                const value2 = chunk.value;
                if (value2.internalServerException) {
                  enqueueError(value2.internalServerException);
                  return;
                }
                if (value2.modelStreamErrorException) {
                  enqueueError(value2.modelStreamErrorException);
                  return;
                }
                if (value2.throttlingException) {
                  enqueueError(value2.throttlingException);
                  return;
                }
                if (value2.validationException) {
                  enqueueError(value2.validationException);
                  return;
                }
                if (value2.messageStop) {
                  finishReason = {
                    unified: mapBedrockFinishReason(
                      value2.messageStop.stopReason,
                      isJsonResponseFromTool
                    ),
                    raw: (_a25 = value2.messageStop.stopReason) != null ? _a25 : void 0
                  };
                  stopSequence = (_d = (_c = (_b18 = value2.messageStop.additionalModelResponseFields) == null ? void 0 : _b18.delta) == null ? void 0 : _c.stop_sequence) != null ? _d : null;
                }
                if (value2.metadata) {
                  if (value2.metadata.usage) {
                    usage = value2.metadata.usage;
                  }
                  const cacheUsage = ((_e = value2.metadata.usage) == null ? void 0 : _e.cacheWriteInputTokens) != null ? {
                    usage: {
                      cacheWriteInputTokens: value2.metadata.usage.cacheWriteInputTokens
                    }
                  } : void 0;
                  const trace2 = value2.metadata.trace ? {
                    trace: value2.metadata.trace
                  } : void 0;
                  if (cacheUsage || trace2) {
                    providerMetadata = {
                      bedrock: {
                        ...cacheUsage,
                        ...trace2
                      }
                    };
                  }
                }
                if (((_f = value2.contentBlockStart) == null ? void 0 : _f.contentBlockIndex) != null && !((_h = (_g = value2.contentBlockStart) == null ? void 0 : _g.start) == null ? void 0 : _h.toolUse)) {
                  const blockIndex = value2.contentBlockStart.contentBlockIndex;
                  contentBlocks[blockIndex] = { type: "text" };
                  controller.enqueue({
                    type: "text-start",
                    id: String(blockIndex)
                  });
                }
                if (((_i = value2.contentBlockDelta) == null ? void 0 : _i.delta) && "text" in value2.contentBlockDelta.delta && value2.contentBlockDelta.delta.text) {
                  const blockIndex = value2.contentBlockDelta.contentBlockIndex || 0;
                  if (contentBlocks[blockIndex] == null) {
                    contentBlocks[blockIndex] = { type: "text" };
                    controller.enqueue({
                      type: "text-start",
                      id: String(blockIndex)
                    });
                  }
                  controller.enqueue({
                    type: "text-delta",
                    id: String(blockIndex),
                    delta: value2.contentBlockDelta.delta.text
                  });
                }
                if (((_j = value2.contentBlockStop) == null ? void 0 : _j.contentBlockIndex) != null) {
                  const blockIndex = value2.contentBlockStop.contentBlockIndex;
                  const contentBlock = contentBlocks[blockIndex];
                  if (contentBlock != null) {
                    if (contentBlock.type === "reasoning") {
                      controller.enqueue({
                        type: "reasoning-end",
                        id: String(blockIndex)
                      });
                    } else if (contentBlock.type === "text") {
                      controller.enqueue({
                        type: "text-end",
                        id: String(blockIndex)
                      });
                    } else if (contentBlock.type === "tool-call") {
                      if (contentBlock.isJsonResponseTool) {
                        isJsonResponseFromTool = true;
                        controller.enqueue({
                          type: "text-start",
                          id: String(blockIndex)
                        });
                        controller.enqueue({
                          type: "text-delta",
                          id: String(blockIndex),
                          delta: contentBlock.jsonText
                        });
                        controller.enqueue({
                          type: "text-end",
                          id: String(blockIndex)
                        });
                      } else {
                        controller.enqueue({
                          type: "tool-input-end",
                          id: contentBlock.toolCallId
                        });
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: contentBlock.toolCallId,
                          toolName: contentBlock.toolName,
                          input: contentBlock.jsonText === "" ? "{}" : contentBlock.jsonText
                        });
                      }
                    }
                    delete contentBlocks[blockIndex];
                  }
                }
                if (((_k = value2.contentBlockDelta) == null ? void 0 : _k.delta) && "reasoningContent" in value2.contentBlockDelta.delta && value2.contentBlockDelta.delta.reasoningContent) {
                  const blockIndex = value2.contentBlockDelta.contentBlockIndex || 0;
                  const reasoningContent = value2.contentBlockDelta.delta.reasoningContent;
                  if ("text" in reasoningContent && reasoningContent.text) {
                    if (contentBlocks[blockIndex] == null) {
                      contentBlocks[blockIndex] = { type: "reasoning" };
                      controller.enqueue({
                        type: "reasoning-start",
                        id: String(blockIndex)
                      });
                    }
                    controller.enqueue({
                      type: "reasoning-delta",
                      id: String(blockIndex),
                      delta: reasoningContent.text
                    });
                  } else if ("signature" in reasoningContent && reasoningContent.signature) {
                    controller.enqueue({
                      type: "reasoning-delta",
                      id: String(blockIndex),
                      delta: "",
                      providerMetadata: {
                        bedrock: {
                          signature: reasoningContent.signature
                        }
                      }
                    });
                  } else if ("data" in reasoningContent && reasoningContent.data) {
                    controller.enqueue({
                      type: "reasoning-delta",
                      id: String(blockIndex),
                      delta: "",
                      providerMetadata: {
                        bedrock: {
                          redactedData: reasoningContent.data
                        }
                      }
                    });
                  }
                }
                const contentBlockStart = value2.contentBlockStart;
                if (((_l = contentBlockStart == null ? void 0 : contentBlockStart.start) == null ? void 0 : _l.toolUse) != null) {
                  const toolUse = contentBlockStart.start.toolUse;
                  const blockIndex = contentBlockStart.contentBlockIndex;
                  const isJsonResponseTool = usesJsonResponseTool && toolUse.name === "json";
                  const normalizedToolCallId = normalizeToolCallId(
                    toolUse.toolUseId,
                    isMistral
                  );
                  contentBlocks[blockIndex] = {
                    type: "tool-call",
                    toolCallId: normalizedToolCallId,
                    toolName: toolUse.name,
                    jsonText: "",
                    isJsonResponseTool
                  };
                  if (!isJsonResponseTool) {
                    controller.enqueue({
                      type: "tool-input-start",
                      id: normalizedToolCallId,
                      toolName: toolUse.name
                    });
                  }
                }
                const contentBlockDelta = value2.contentBlockDelta;
                if ((contentBlockDelta == null ? void 0 : contentBlockDelta.delta) && "toolUse" in contentBlockDelta.delta && contentBlockDelta.delta.toolUse) {
                  const blockIndex = contentBlockDelta.contentBlockIndex;
                  const contentBlock = contentBlocks[blockIndex];
                  if ((contentBlock == null ? void 0 : contentBlock.type) === "tool-call") {
                    const delta = (_m = contentBlockDelta.delta.toolUse.input) != null ? _m : "";
                    if (!contentBlock.isJsonResponseTool) {
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: contentBlock.toolCallId,
                        delta
                      });
                    }
                    contentBlock.jsonText += delta;
                  }
                }
              },
              flush(controller) {
                if (isJsonResponseFromTool || stopSequence != null) {
                  if (providerMetadata) {
                    providerMetadata.bedrock = {
                      ...providerMetadata.bedrock,
                      ...isJsonResponseFromTool && {
                        isJsonResponseFromTool: true
                      },
                      stopSequence
                    };
                  } else {
                    providerMetadata = {
                      bedrock: {
                        ...isJsonResponseFromTool && {
                          isJsonResponseFromTool: true
                        },
                        stopSequence
                      }
                    };
                  }
                }
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage: convertBedrockUsage(usage),
                  ...providerMetadata && { providerMetadata }
                });
              }
            })
          ),
          // TODO request?
          response: { headers: responseHeaders }
        };
      }
      getUrl(modelId) {
        const encodedModelId = encodeURIComponent(modelId);
        return `${this.config.baseUrl()}/model/${encodedModelId}`;
      }
    };
    BedrockStopReasonSchema = z312.union([
      z312.enum(BEDROCK_STOP_REASONS),
      z312.string()
    ]);
    BedrockAdditionalModelResponseFieldsSchema = z312.object({
      delta: z312.object({
        stop_sequence: z312.string().nullish()
      }).nullish()
    }).catchall(z312.unknown());
    BedrockToolUseSchema = z312.object({
      toolUseId: z312.string(),
      name: z312.string(),
      input: z312.unknown()
    });
    BedrockReasoningTextSchema = z312.object({
      signature: z312.string().nullish(),
      text: z312.string()
    });
    BedrockRedactedReasoningSchema = z312.object({
      data: z312.string()
    });
    BedrockResponseSchema = z312.object({
      metrics: z312.object({
        latencyMs: z312.number()
      }).nullish(),
      output: z312.object({
        message: z312.object({
          content: z312.array(
            z312.object({
              text: z312.string().nullish(),
              toolUse: BedrockToolUseSchema.nullish(),
              reasoningContent: z312.union([
                z312.object({
                  reasoningText: BedrockReasoningTextSchema
                }),
                z312.object({
                  redactedReasoning: BedrockRedactedReasoningSchema
                })
              ]).nullish()
            })
          ),
          role: z312.string()
        })
      }),
      stopReason: BedrockStopReasonSchema,
      additionalModelResponseFields: BedrockAdditionalModelResponseFieldsSchema.nullish(),
      trace: z312.unknown().nullish(),
      usage: z312.object({
        inputTokens: z312.number(),
        outputTokens: z312.number(),
        totalTokens: z312.number(),
        cacheReadInputTokens: z312.number().nullish(),
        cacheWriteInputTokens: z312.number().nullish()
      })
    });
    BedrockStreamSchema = z312.object({
      contentBlockDelta: z312.object({
        contentBlockIndex: z312.number(),
        delta: z312.union([
          z312.object({ text: z312.string() }),
          z312.object({ toolUse: z312.object({ input: z312.string() }) }),
          z312.object({
            reasoningContent: z312.object({ text: z312.string() })
          }),
          z312.object({
            reasoningContent: z312.object({
              signature: z312.string()
            })
          }),
          z312.object({
            reasoningContent: z312.object({ data: z312.string() })
          })
        ]).nullish()
      }).nullish(),
      contentBlockStart: z312.object({
        contentBlockIndex: z312.number(),
        start: z312.object({
          toolUse: BedrockToolUseSchema.nullish()
        }).nullish()
      }).nullish(),
      contentBlockStop: z312.object({
        contentBlockIndex: z312.number()
      }).nullish(),
      internalServerException: z312.record(z312.string(), z312.unknown()).nullish(),
      messageStop: z312.object({
        additionalModelResponseFields: BedrockAdditionalModelResponseFieldsSchema.nullish(),
        stopReason: BedrockStopReasonSchema
      }).nullish(),
      metadata: z312.object({
        trace: z312.unknown().nullish(),
        usage: z312.object({
          cacheReadInputTokens: z312.number().nullish(),
          cacheWriteInputTokens: z312.number().nullish(),
          inputTokens: z312.number(),
          outputTokens: z312.number()
        }).nullish()
      }).nullish(),
      modelStreamErrorException: z312.record(z312.string(), z312.unknown()).nullish(),
      throttlingException: z312.record(z312.string(), z312.unknown()).nullish(),
      validationException: z312.record(z312.string(), z312.unknown()).nullish()
    });
    bedrockReasoningMetadataSchema = z312.object({
      signature: z312.string().optional(),
      redactedData: z312.string().optional()
    });
    bedrockEmbeddingProviderOptions = z412.object({
      /**
       * The number of dimensions the resulting output embeddings should have (defaults to 1024).
       * Only supported in amazon.titan-embed-text-v2:0.
       */
      dimensions: z412.union([z412.literal(1024), z412.literal(512), z412.literal(256)]).optional(),
      /**
       * Flag indicating whether or not to normalize the output embeddings. Defaults to true.
       * Only supported in amazon.titan-embed-text-v2:0.
       */
      normalize: z412.boolean().optional(),
      /**
       * The number of dimensions for Nova embedding models (defaults to 1024).
       * Supported values: 256, 384, 1024, 3072.
       * Only supported in amazon.nova-* embedding models.
       */
      embeddingDimension: z412.union([z412.literal(256), z412.literal(384), z412.literal(1024), z412.literal(3072)]).optional(),
      /**
       * The purpose of the embedding. Defaults to 'GENERIC_INDEX'.
       * Only supported in amazon.nova-* embedding models.
       */
      embeddingPurpose: z412.enum([
        "GENERIC_INDEX",
        "TEXT_RETRIEVAL",
        "IMAGE_RETRIEVAL",
        "VIDEO_RETRIEVAL",
        "DOCUMENT_RETRIEVAL",
        "AUDIO_RETRIEVAL",
        "GENERIC_RETRIEVAL",
        "CLASSIFICATION",
        "CLUSTERING"
      ]).optional(),
      /**
       * Input type for Cohere embedding models on Bedrock.
       * Common values: `search_document`, `search_query`, `classification`, `clustering`.
       * If not set, the provider defaults to `search_query`.
       */
      inputType: z412.enum(["search_document", "search_query", "classification", "clustering"]).optional(),
      /**
       * Truncation behavior when input exceeds the model's context length.
       * Supported in Cohere and Nova embedding models. Defaults to 'END' for Nova models.
       */
      truncate: z412.enum(["NONE", "START", "END"]).optional(),
      /**
       * The number of dimensions the resulting output embeddings should have (defaults to 1536).
       * Only supported in cohere.embed-v4:0 and newer Cohere embedding models.
       */
      outputDimension: z412.union([z412.literal(256), z412.literal(512), z412.literal(1024), z412.literal(1536)]).optional()
    });
    BedrockEmbeddingModel = class {
      constructor(modelId, config2) {
        this.modelId = modelId;
        this.config = config2;
        this.specificationVersion = "v3";
        this.provider = "amazon-bedrock";
        this.maxEmbeddingsPerCall = 1;
        this.supportsParallelCalls = true;
      }
      getUrl(modelId) {
        const encodedModelId = encodeURIComponent(modelId);
        return `${this.config.baseUrl()}/model/${encodedModelId}/invoke`;
      }
      async doEmbed({
        values,
        headers,
        abortSignal,
        providerOptions
      }) {
        var _a25, _b18, _c, _d, _e, _f;
        if (values.length > this.maxEmbeddingsPerCall) {
          throw new TooManyEmbeddingValuesForCallError({
            provider: this.provider,
            modelId: this.modelId,
            maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
            values
          });
        }
        const bedrockOptions = (_a25 = await parseProviderOptions({
          provider: "bedrock",
          providerOptions,
          schema: bedrockEmbeddingProviderOptions
        })) != null ? _a25 : {};
        const isNovaModel = this.modelId.startsWith("amazon.nova-") && this.modelId.includes("embed");
        const isCohereModel = this.modelId.startsWith("cohere.embed-");
        const args2 = isNovaModel ? {
          taskType: "SINGLE_EMBEDDING",
          singleEmbeddingParams: {
            embeddingPurpose: (_b18 = bedrockOptions.embeddingPurpose) != null ? _b18 : "GENERIC_INDEX",
            embeddingDimension: (_c = bedrockOptions.embeddingDimension) != null ? _c : 1024,
            text: {
              truncationMode: (_d = bedrockOptions.truncate) != null ? _d : "END",
              value: values[0]
            }
          }
        } : isCohereModel ? {
          // Cohere embedding models on Bedrock require `input_type`.
          // Without it, the service attempts other schema branches and rejects the request.
          input_type: (_e = bedrockOptions.inputType) != null ? _e : "search_query",
          texts: [values[0]],
          truncate: bedrockOptions.truncate,
          output_dimension: bedrockOptions.outputDimension
        } : {
          inputText: values[0],
          dimensions: bedrockOptions.dimensions,
          normalize: bedrockOptions.normalize
        };
        const url = this.getUrl(this.modelId);
        const { value: response } = await postJsonToApi({
          url,
          headers: await resolve(
            combineHeaders(await resolve(this.config.headers), headers)
          ),
          body: args2,
          failedResponseHandler: createJsonErrorResponseHandler({
            errorSchema: BedrockErrorSchema,
            errorToMessage: (error) => `${error.type}: ${error.message}`
          }),
          successfulResponseHandler: createJsonResponseHandler(
            BedrockEmbeddingResponseSchema
          ),
          fetch: this.config.fetch,
          abortSignal
        });
        let embedding;
        if ("embedding" in response) {
          embedding = response.embedding;
        } else if (Array.isArray(response.embeddings)) {
          const firstEmbedding = response.embeddings[0];
          if (typeof firstEmbedding === "object" && firstEmbedding !== null && "embeddingType" in firstEmbedding) {
            embedding = firstEmbedding.embedding;
          } else {
            embedding = firstEmbedding;
          }
        } else {
          embedding = response.embeddings.float[0];
        }
        const tokens = "inputTextTokenCount" in response ? response.inputTextTokenCount : "inputTokenCount" in response ? (_f = response.inputTokenCount) != null ? _f : 0 : NaN;
        return {
          embeddings: [embedding],
          usage: { tokens },
          warnings: []
        };
      }
    };
    BedrockEmbeddingResponseSchema = z511.union([
      // Titan-style response
      z511.object({
        embedding: z511.array(z511.number()),
        inputTextTokenCount: z511.number()
      }),
      // Nova-style response
      z511.object({
        embeddings: z511.array(
          z511.object({
            embeddingType: z511.string(),
            embedding: z511.array(z511.number())
          })
        ),
        inputTokenCount: z511.number().optional()
      }),
      // Cohere v3-style response
      z511.object({
        embeddings: z511.array(z511.array(z511.number()))
      }),
      // Cohere v4-style response
      z511.object({
        embeddings: z511.object({
          float: z511.array(z511.array(z511.number()))
        })
      })
    ]);
    modelMaxImagesPerCall2 = {
      "amazon.nova-canvas-v1:0": 5
    };
    BedrockImageModel = class {
      constructor(modelId, config2) {
        this.modelId = modelId;
        this.config = config2;
        this.specificationVersion = "v3";
        this.provider = "amazon-bedrock";
      }
      get maxImagesPerCall() {
        var _a25;
        return (_a25 = modelMaxImagesPerCall2[this.modelId]) != null ? _a25 : 1;
      }
      getUrl(modelId) {
        const encodedModelId = encodeURIComponent(modelId);
        return `${this.config.baseUrl()}/model/${encodedModelId}/invoke`;
      }
      async doGenerate({
        prompt,
        n,
        size,
        aspectRatio,
        seed,
        providerOptions,
        headers,
        abortSignal,
        files,
        mask
      }) {
        var _a25, _b18, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
        const warnings = [];
        const [width, height] = size ? size.split("x").map(Number) : [];
        const hasFiles = files != null && files.length > 0;
        const imageGenerationConfig = {
          ...width ? { width } : {},
          ...height ? { height } : {},
          ...seed ? { seed } : {},
          ...n ? { numberOfImages: n } : {},
          ...((_a25 = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _a25.quality) ? { quality: providerOptions.bedrock.quality } : {},
          ...((_b18 = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _b18.cfgScale) ? { cfgScale: providerOptions.bedrock.cfgScale } : {}
        };
        let args2;
        if (hasFiles) {
          const hasMask = (mask == null ? void 0 : mask.type) != null;
          const hasMaskPrompt = ((_c = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _c.maskPrompt) != null;
          const taskType = (_e = (_d = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _d.taskType) != null ? _e : hasMask || hasMaskPrompt ? "INPAINTING" : "IMAGE_VARIATION";
          const sourceImageBase64 = getBase64Data(files[0]);
          switch (taskType) {
            case "INPAINTING": {
              const inPaintingParams = {
                image: sourceImageBase64,
                ...prompt ? { text: prompt } : {},
                ...((_f = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _f.negativeText) ? { negativeText: providerOptions.bedrock.negativeText } : {}
              };
              if (hasMask) {
                inPaintingParams.maskImage = getBase64Data(mask);
              } else if (hasMaskPrompt) {
                inPaintingParams.maskPrompt = providerOptions.bedrock.maskPrompt;
              }
              args2 = {
                taskType: "INPAINTING",
                inPaintingParams,
                imageGenerationConfig
              };
              break;
            }
            case "OUTPAINTING": {
              const outPaintingParams = {
                image: sourceImageBase64,
                ...prompt ? { text: prompt } : {},
                ...((_g = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _g.negativeText) ? { negativeText: providerOptions.bedrock.negativeText } : {},
                ...((_h = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _h.outPaintingMode) ? { outPaintingMode: providerOptions.bedrock.outPaintingMode } : {}
              };
              if (hasMask) {
                outPaintingParams.maskImage = getBase64Data(mask);
              } else if (hasMaskPrompt) {
                outPaintingParams.maskPrompt = providerOptions.bedrock.maskPrompt;
              }
              args2 = {
                taskType: "OUTPAINTING",
                outPaintingParams,
                imageGenerationConfig
              };
              break;
            }
            case "BACKGROUND_REMOVAL": {
              args2 = {
                taskType: "BACKGROUND_REMOVAL",
                backgroundRemovalParams: {
                  image: sourceImageBase64
                }
              };
              break;
            }
            case "IMAGE_VARIATION": {
              const images = files.map((file) => getBase64Data(file));
              const imageVariationParams = {
                images,
                ...prompt ? { text: prompt } : {},
                ...((_i = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _i.negativeText) ? { negativeText: providerOptions.bedrock.negativeText } : {},
                ...((_j = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _j.similarityStrength) != null ? {
                  similarityStrength: providerOptions.bedrock.similarityStrength
                } : {}
              };
              args2 = {
                taskType: "IMAGE_VARIATION",
                imageVariationParams,
                imageGenerationConfig
              };
              break;
            }
            default:
              throw new Error(`Unsupported task type: ${taskType}`);
          }
        } else {
          args2 = {
            taskType: "TEXT_IMAGE",
            textToImageParams: {
              text: prompt,
              ...((_k = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _k.negativeText) ? {
                negativeText: providerOptions.bedrock.negativeText
              } : {},
              ...((_l = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _l.style) ? {
                style: providerOptions.bedrock.style
              } : {}
            },
            imageGenerationConfig
          };
        }
        if (aspectRatio != void 0) {
          warnings.push({
            type: "unsupported",
            feature: "aspectRatio",
            details: "This model does not support aspect ratio. Use `size` instead."
          });
        }
        const currentDate = (_o = (_n = (_m = this.config._internal) == null ? void 0 : _m.currentDate) == null ? void 0 : _n.call(_m)) != null ? _o : /* @__PURE__ */ new Date();
        const { value: response, responseHeaders } = await postJsonToApi({
          url: this.getUrl(this.modelId),
          headers: await resolve(
            combineHeaders(await resolve(this.config.headers), headers)
          ),
          body: args2,
          failedResponseHandler: createJsonErrorResponseHandler({
            errorSchema: BedrockErrorSchema,
            errorToMessage: (error) => `${error.type}: ${error.message}`
          }),
          successfulResponseHandler: createJsonResponseHandler(
            bedrockImageResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        if (response.status === "Request Moderated") {
          const moderationReasons = (_p = response.details) == null ? void 0 : _p["Moderation Reasons"];
          const reasons = Array.isArray(moderationReasons) ? moderationReasons : ["Unknown"];
          throw new Error(
            `Amazon Bedrock request was moderated: ${reasons.join(", ")}`
          );
        }
        if (!response.images || response.images.length === 0) {
          throw new Error(
            "Amazon Bedrock returned no images. " + (response.status ? `Status: ${response.status}` : "")
          );
        }
        return {
          images: response.images,
          warnings,
          response: {
            timestamp: currentDate,
            modelId: this.modelId,
            headers: responseHeaders
          }
        };
      }
    };
    bedrockImageResponseSchema = z611.object({
      // Normal successful response
      images: z611.array(z611.string()).optional(),
      // Moderation response fields
      id: z611.string().optional(),
      status: z611.string().optional(),
      result: z611.unknown().optional(),
      progress: z611.unknown().optional(),
      details: z611.record(z611.string(), z611.unknown()).optional(),
      preview: z611.unknown().optional()
    });
    VERSION12 = true ? "4.0.49" : "0.0.0-test";
    bedrockRerankingResponseSchema = lazySchema(
      () => zodSchema(
        z711.object({
          results: z711.array(
            z711.object({
              index: z711.number(),
              relevanceScore: z711.number()
            })
          ),
          nextToken: z711.string().optional()
        })
      )
    );
    bedrockRerankingOptionsSchema = lazySchema(
      () => zodSchema(
        z811.object({
          /**
           * If the total number of results was greater than could fit in a response, a token is returned in the nextToken field. You can enter that token in this field to return the next batch of results.
           */
          nextToken: z811.string().optional(),
          /**
           * Additional model request fields to pass to the model.
           */
          additionalModelRequestFields: z811.record(z811.string(), z811.any()).optional()
        })
      )
    );
    BedrockRerankingModel = class {
      constructor(modelId, config2) {
        this.modelId = modelId;
        this.config = config2;
        this.specificationVersion = "v3";
        this.provider = "amazon-bedrock";
      }
      async doRerank({
        documents,
        headers,
        query,
        topN,
        abortSignal,
        providerOptions
      }) {
        const bedrockOptions = await parseProviderOptions({
          provider: "bedrock",
          providerOptions,
          schema: bedrockRerankingOptionsSchema
        });
        const {
          value: response,
          responseHeaders,
          rawValue
        } = await postJsonToApi({
          url: `${this.config.baseUrl()}/rerank`,
          headers: await resolve(
            combineHeaders(await resolve(this.config.headers), headers)
          ),
          body: {
            nextToken: bedrockOptions == null ? void 0 : bedrockOptions.nextToken,
            queries: [
              {
                textQuery: { text: query },
                type: "TEXT"
              }
            ],
            rerankingConfiguration: {
              bedrockRerankingConfiguration: {
                modelConfiguration: {
                  modelArn: `arn:aws:bedrock:${this.config.region}::foundation-model/${this.modelId}`,
                  additionalModelRequestFields: bedrockOptions == null ? void 0 : bedrockOptions.additionalModelRequestFields
                },
                numberOfResults: topN
              },
              type: "BEDROCK_RERANKING_MODEL"
            },
            sources: documents.values.map((value2) => ({
              type: "INLINE",
              inlineDocumentSource: documents.type === "text" ? {
                type: "TEXT",
                textDocument: { text: value2 }
              } : {
                type: "JSON",
                jsonDocument: value2
              }
            }))
          },
          failedResponseHandler: createJsonErrorResponseHandler({
            errorSchema: BedrockErrorSchema,
            errorToMessage: (error) => `${error.type}: ${error.message}`
          }),
          successfulResponseHandler: createJsonResponseHandler(
            bedrockRerankingResponseSchema
          ),
          fetch: this.config.fetch,
          abortSignal
        });
        return {
          ranking: response.results,
          response: {
            headers: responseHeaders,
            body: rawValue
          }
        };
      }
    };
    bedrock = createAmazonBedrock();
  }
});

// node_modules/ollama-ai-provider-v2/dist/index.mjs
var dist_exports11 = {};
__export(dist_exports11, {
  createOllama: () => createOllama,
  ollama: () => ollama
});
import { z as z215 } from "zod/v4";
import { z as z50 } from "zod/v4";
import { z as z313 } from "zod/v4";
import { z as z413 } from "zod/v4";
import { z as z512 } from "zod/v4";
function convertToOllamaCompletionPrompt({
  prompt,
  user = "user",
  assistant = "assistant"
}) {
  let text2 = "";
  if (prompt[0].role === "system") {
    text2 += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new InvalidPromptError({
          message: "Unexpected system message in prompt: ${content}",
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
          }
        }).filter(Boolean).join("");
        text2 += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "tool-call": {
              throw new UnsupportedFunctionalityError({
                functionality: "tool-call messages"
              });
            }
          }
        }).join("");
        text2 += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new UnsupportedFunctionalityError({
          functionality: "tool messages"
        });
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  text2 += `${assistant}:
`;
  return {
    prompt: text2,
    stopSequences: [`
${user}:`]
  };
}
function mapOllamaFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return {
        raw: finishReason,
        unified: "stop"
      };
    case "length":
      return {
        raw: finishReason,
        unified: "length"
      };
    case "content_filter":
      return {
        raw: finishReason,
        unified: "content-filter"
      };
    case "function_call":
    case "tool_calls":
      return {
        raw: finishReason,
        unified: "tool-calls"
      };
    default:
      return {
        raw: finishReason,
        unified: "other"
      };
  }
}
function getResponseMetadata6({
  model,
  created_at
}) {
  return {
    id: void 0,
    modelId: model != null ? model : void 0,
    timestamp: created_at != null ? new Date(created_at) : void 0
  };
}
function createNdjsonStreamResponseHandler(schema) {
  return async ({ response }) => {
    const responseHeaders = extractResponseHeaders(response);
    if (response.body == null) {
      throw new Error("Response body is null");
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";
    const stream = new ReadableStream({
      async pull(controller) {
        while (true) {
          const { done, value: value2 } = await reader.read();
          if (done) {
            if (buffer.trim()) {
              try {
                const parsed = JSON.parse(buffer.trim());
                const validated = schema.parse(parsed);
                controller.enqueue({ success: true, value: validated, rawValue: validated });
              } catch (e) {
              }
            }
            controller.close();
            return;
          }
          buffer += decoder.decode(value2, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";
          for (const line of lines) {
            const trimmedLine = line.trim();
            if (trimmedLine) {
              try {
                const parsed = JSON.parse(trimmedLine);
                const validated = schema.parse(parsed);
                controller.enqueue({ success: true, value: validated, rawValue: validated });
              } catch (error) {
                console.warn("Failed to parse NDJSON line:", error);
              }
            }
          }
        }
      },
      cancel() {
        reader.cancel();
      }
    });
    return {
      responseHeaders,
      value: stream
    };
  };
}
function extractOllamaResponseObjectsFromChunk(chunk) {
  var _a25;
  if (chunk.success) {
    return [chunk.value];
  }
  const results = [];
  const raw = (_a25 = chunk.error) == null ? void 0 : _a25.text;
  if (typeof raw !== "string" || raw.length === 0) {
    return results;
  }
  const lines = raw.split(/\r?\n/);
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed === "") continue;
    try {
      const parsed = JSON.parse(trimmed);
      const validated = baseOllamaResponseSchema2.safeParse(parsed);
      if (validated.success) {
        results.push(validated.data);
      }
    } catch (e) {
    }
  }
  return results;
}
function convertToOllamaChatMessages({
  prompt,
  systemMessageMode = "system"
}) {
  const messages = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            messages.push({ role: "system", content });
            break;
          }
          case "developer": {
            messages.push({ role: "developer", content });
            break;
          }
          case "remove": {
            break;
          }
          default: {
            const _exhaustiveCheck = systemMessageMode;
            throw new Error(
              `Unsupported system message mode: ${_exhaustiveCheck}`
            );
          }
        }
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        const userText = content.filter((part) => part.type === "text").map((part) => part.text).join("");
        const images = content.filter((part) => part.type === "file" && part.mediaType.startsWith("image/")).map((part) => part.data);
        messages.push({
          role: "user",
          content: userText.length > 0 ? userText : [],
          images: images.length > 0 ? images : void 0
        });
        break;
      }
      case "assistant": {
        let text2 = "";
        let thinking = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text2 += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: part.input
                }
              });
              break;
            }
            case "reasoning": {
              thinking += part.text;
              break;
            }
            default: {
              throw new Error(`Unsupported part: ${part}`);
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text2,
          ...thinking && { thinking },
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return messages;
}
function convertToOllamaResponsesMessages({
  prompt,
  systemMessageMode
}) {
  const messages = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            messages.push({ role: "system", content });
            break;
          }
          case "developer": {
            messages.push({ role: "developer", content });
            break;
          }
          case "remove": {
            warnings.push({
              type: "other",
              message: "system messages are removed for this model"
            });
            break;
          }
          default: {
            const _exhaustiveCheck = systemMessageMode;
            throw new Error(
              `Unsupported system message mode: ${_exhaustiveCheck}`
            );
          }
        }
        break;
      }
      case "user": {
        messages.push({
          role: "user",
          content: content.map((part, index) => {
            var _a25, _b18, _c;
            switch (part.type) {
              case "text": {
                return { type: "input_text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "input_image",
                    image_url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${part.data}`,
                    // Ollama specific extension: image detail
                    detail: (_b18 = (_a25 = part.providerOptions) == null ? void 0 : _a25.ollama) == null ? void 0 : _b18.imageDetail
                  };
                } else if (part.mediaType === "application/pdf") {
                  if (part.data instanceof URL) {
                    throw new UnsupportedFunctionalityError({
                      functionality: "PDF file parts with URLs"
                    });
                  }
                  return {
                    type: "input_file",
                    filename: (_c = part.filename) != null ? _c : `part-${index}.pdf`,
                    file_data: `data:application/pdf;base64,${part.data}`
                  };
                } else {
                  throw new UnsupportedFunctionalityError({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        for (const part of content) {
          switch (part.type) {
            case "text": {
              messages.push({
                role: "assistant",
                content: [{ type: "output_text", text: part.text }]
              });
              break;
            }
            case "tool-call": {
              if (part.providerExecuted) {
                break;
              }
              messages.push({
                type: "function_call",
                call_id: part.toolCallId,
                name: part.toolName,
                arguments: JSON.stringify(part.input)
              });
              break;
            }
            case "tool-result": {
              warnings.push({
                type: "other",
                message: `tool result parts in assistant messages are not supported for Ollama responses`
              });
              break;
            }
          }
        }
        break;
      }
      case "tool": {
        for (const part of content) {
          const output = part.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            type: "function_call_output",
            call_id: part.toolCallId,
            output: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { messages, warnings };
}
function prepareResponsesTools3({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const ollamaTools = [];
  for (const tool2 of tools) {
    switch (tool2.type) {
      case "function": {
        let parameters = tool2.inputSchema;
        if (!parameters) {
          parameters = {
            type: "object",
            properties: {},
            required: []
          };
        } else if (parameters && typeof parameters === "object" && parameters.type === "object" && parameters.properties && Object.keys(parameters.properties).length === 0) {
          parameters = {
            ...parameters,
            properties: {},
            required: []
          };
        }
        ollamaTools.push({
          type: "function",
          function: {
            name: tool2.name,
            description: tool2.description,
            parameters
          }
        });
        break;
      }
      default:
        toolWarnings.push({ type: "unsupported", feature: "tool", details: tool2.name });
        break;
    }
  }
  if (toolChoice == null) {
    return { tools: ollamaTools, toolChoice: void 0, toolWarnings };
  }
  const type2 = toolChoice.type;
  switch (type2) {
    case "auto":
    case "none":
    case "required":
      return { tools: ollamaTools, toolChoice: type2, toolWarnings };
    case "tool":
      return {
        tools: ollamaTools,
        toolChoice: toolChoice.toolName == "web_search_preview" ? { type: "web_search_preview" } : { type: "function", name: toolChoice.toolName },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type2;
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function createOllama(options = {}) {
  var _a25, _b18;
  const baseURL = (_a25 = withoutTrailingSlash(options.baseURL)) != null ? _a25 : "http://127.0.0.1:11434/api";
  const providerName = (_b18 = options.name) != null ? _b18 : "ollama";
  const getHeaders = () => ({
    "Ollama-Organization": options.organization,
    "Ollama-Project": options.project,
    ...options.headers
  });
  const createCompletionModel = (modelId, settings = {}) => new OllamaCompletionLanguageModel(modelId, settings, {
    provider: `${providerName}.completion`,
    url: ({ path: path24 }) => `${baseURL}${path24}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createEmbeddingModel = (modelId, settings = {}) => new OllamaEmbeddingModel(modelId, settings, {
    provider: `${providerName}.embedding`,
    url: ({ path: path24 }) => `${baseURL}${path24}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createLanguageModel = (modelId) => {
    if (new.target) {
      throw new Error(
        "The Ollama model function cannot be called with the new keyword."
      );
    }
    return createResponsesModel(modelId);
  };
  const createResponsesModel = (modelId) => {
    return new OllamaResponsesLanguageModel(modelId, {
      provider: `${providerName}.responses`,
      url: ({ path: path24 }) => `${baseURL}${path24}`,
      headers: getHeaders,
      fetch: options.fetch
    });
  };
  const provider = function(modelId) {
    return createLanguageModel(modelId);
  };
  provider.specificationVersion = "v3";
  provider.languageModel = createLanguageModel;
  provider.chat = createLanguageModel;
  provider.completion = createCompletionModel;
  provider.embedding = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.embeddingModel = createEmbeddingModel;
  provider.imageModel = (modelId) => {
    throw new NoSuchModelError({
      modelId,
      modelType: "imageModel",
      message: "Image generation is unsupported with Ollama"
    });
  };
  return provider;
}
var ollamaErrorDataSchema, ollamaFailedResponseHandler, ollamaCompletionProviderOptions, OllamaCompletionLanguageModel, baseOllamaResponseSchema, ollamaEmbeddingProviderOptions, OllamaEmbeddingModel, ollamaTextEmbeddingResponseSchema, baseOllamaResponseSchema2, OllamaResponseProcessor, ollamaProviderOptions, OllamaRequestBuilder, OllamaStreamProcessor, OllamaResponsesLanguageModel, ollama;
var init_dist19 = __esm({
  "node_modules/ollama-ai-provider-v2/dist/index.mjs"() {
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist8();
    init_dist6();
    init_dist6();
    init_dist6();
    init_dist8();
    ollamaErrorDataSchema = z50.object({
      error: z50.object({
        message: z50.string(),
        // The additional information below is handled loosely to support
        // Ollama-compatible providers that have slightly different error
        // responses:
        type: z50.string().nullish(),
        param: z50.any().nullish(),
        code: z50.union([z50.string(), z50.number()]).nullish()
      })
    });
    ollamaFailedResponseHandler = createJsonErrorResponseHandler({
      errorSchema: ollamaErrorDataSchema,
      errorToMessage: (data) => data.error.message
    });
    ollamaCompletionProviderOptions = z215.object({
      think: z215.boolean().optional(),
      user: z215.string().optional(),
      suffix: z215.string().optional(),
      echo: z215.boolean().optional()
    });
    OllamaCompletionLanguageModel = class {
      constructor(modelId, settings, config2) {
        this.specificationVersion = "v3";
        this.defaultObjectGenerationMode = void 0;
        this.supportsImageUrls = false;
        this.supportedUrls = {
          // No URLs are supported for completion models.
        };
        this.modelId = modelId;
        this.settings = settings;
        this.config = config2;
        this.provider = config2.provider;
      }
      getArgs({
        prompt,
        maxOutputTokens,
        temperature,
        topP,
        topK,
        frequencyPenalty,
        presencePenalty,
        stopSequences: userStopSequences,
        responseFormat,
        tools,
        toolChoice,
        seed
      }) {
        const warnings = [];
        if (topK != null) {
          warnings.push({
            type: "unsupported",
            feature: "topK"
          });
        }
        if (tools == null ? void 0 : tools.length) {
          warnings.push({ type: "unsupported", feature: "tools" });
        }
        if (toolChoice != null) {
          warnings.push({ type: "unsupported", feature: "toolChoice" });
        }
        if (responseFormat != null && responseFormat.type !== "text") {
          warnings.push({
            type: "unsupported",
            feature: "responseFormat (JSON)"
          });
        }
        const { prompt: completionPrompt, stopSequences } = convertToOllamaCompletionPrompt({ prompt });
        const stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
        return {
          args: {
            // model id:
            model: this.modelId,
            // Ollama-supported settings:
            user: this.settings.user,
            think: this.settings.think,
            // standardized settings:
            max_tokens: maxOutputTokens,
            temperature,
            top_p: topP,
            frequency_penalty: frequencyPenalty,
            presence_penalty: presencePenalty,
            stop,
            // prompt:
            prompt: completionPrompt,
            // other settings:
            suffix: this.settings.suffix,
            echo: this.settings.echo,
            stream: false
            // always disabled for doGenerate
          },
          warnings
        };
      }
      async doGenerate(options) {
        var _a25, _b18;
        const { args: body, warnings } = this.getArgs(options);
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi({
          url: this.config.url({
            path: "/generate",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body: { ...body, stream: false },
          failedResponseHandler: ollamaFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            baseOllamaResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const { prompt: rawPrompt, ...rawSettings } = body;
        const typedResponse = response;
        return {
          content: [
            {
              type: "text",
              text: typedResponse.response
            }
          ],
          usage: {
            inputTokens: {
              total: (_a25 = typedResponse.prompt_eval_count) != null ? _a25 : 0,
              noCache: void 0,
              cacheRead: void 0,
              cacheWrite: void 0
            },
            outputTokens: {
              total: (_b18 = typedResponse.eval_count) != null ? _b18 : 0,
              text: void 0,
              reasoning: void 0
            }
          },
          finishReason: mapOllamaFinishReason("stop"),
          request: { body: JSON.stringify(body) },
          response: {
            ...getResponseMetadata6(typedResponse),
            headers: responseHeaders,
            body: rawResponse
          },
          warnings
        };
      }
      async doStream(options) {
        const { args: args2, warnings } = this.getArgs(options);
        const body = {
          ...args2,
          stream: true
        };
        const { responseHeaders, value: response } = await postJsonToApi({
          url: this.config.url({
            path: "/generate",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body,
          failedResponseHandler: ollamaFailedResponseHandler,
          successfulResponseHandler: createNdjsonStreamResponseHandler(
            baseOllamaResponseSchema
          ),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const { prompt: rawPrompt, ...rawSettings } = args2;
        let finishReason = "other";
        let usage = {
          inputTokens: {
            total: void 0,
            noCache: void 0,
            cacheRead: void 0,
            cacheWrite: void 0
          },
          outputTokens: {
            total: void 0,
            text: void 0,
            reasoning: void 0
          }
        };
        let isFirstChunk = true;
        let textStarted = false;
        const textId = generateId();
        return {
          stream: response.pipeThrough(
            new TransformStream({
              transform(chunk, controller) {
                if (!chunk.success) {
                  controller.enqueue({ type: "error", error: chunk.rawValue });
                  return;
                }
                const value2 = chunk.value;
                if ("error" in value2) {
                  finishReason = "error";
                  controller.enqueue({ type: "error", error: value2.error });
                  return;
                }
                if (isFirstChunk) {
                  isFirstChunk = false;
                  controller.enqueue({
                    type: "response-metadata",
                    ...getResponseMetadata6(value2)
                  });
                }
                if (value2.done) {
                  finishReason = "stop";
                }
                if (value2.response != null) {
                  if (!textStarted) {
                    controller.enqueue({
                      type: "text-start",
                      id: textId
                    });
                    textStarted = true;
                  }
                  controller.enqueue({
                    type: "text-delta",
                    id: textId,
                    delta: value2.response
                  });
                }
              },
              flush(controller) {
                if (textStarted) {
                  controller.enqueue({
                    type: "text-end",
                    id: textId
                  });
                }
                controller.enqueue({
                  type: "finish",
                  finishReason: mapOllamaFinishReason(finishReason),
                  usage
                });
              }
            })
          ),
          request: { body: JSON.stringify(body) },
          response: { headers: responseHeaders },
          warnings
        };
      }
    };
    baseOllamaResponseSchema = z215.object({
      model: z215.string(),
      created_at: z215.string(),
      response: z215.string(),
      done: z215.boolean(),
      context: z215.array(z215.number()),
      eval_count: z215.number().optional(),
      eval_duration: z215.number().optional(),
      load_duration: z215.number().optional(),
      total_duration: z215.number().optional(),
      prompt_eval_count: z215.number().optional(),
      prompt_eval_duration: z215.number().optional()
    });
    ollamaEmbeddingProviderOptions = z313.object({
      dimensions: z313.number().optional(),
      truncate: z313.boolean().optional(),
      keepAlive: z313.string().optional()
    });
    OllamaEmbeddingModel = class {
      constructor(modelId, settings, config2) {
        this.specificationVersion = "v3";
        var _a25, _b18;
        this.modelId = modelId;
        this.settings = settings;
        this.config = config2;
        this.provider = config2.provider;
        this.maxEmbeddingsPerCall = (_a25 = settings.maxEmbeddingsPerCall) != null ? _a25 : 2048;
        this.supportsParallelCalls = (_b18 = settings.supportsParallelCalls) != null ? _b18 : true;
      }
      getArgs({
        values
      }) {
        return {
          // model id:
          model: this.modelId,
          input: values,
          // advanced parameters:
          dimensions: this.settings.dimensions,
          truncate: this.settings.truncate,
          keep_alive: this.settings.keepAlive
        };
      }
      async doEmbed({
        values,
        headers,
        abortSignal,
        providerOptions
      }) {
        var _a25, _b18, _c;
        if (this.maxEmbeddingsPerCall && values.length > this.maxEmbeddingsPerCall) {
          throw new TooManyEmbeddingValuesForCallError({
            provider: this.provider,
            modelId: this.modelId,
            maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
            values
          });
        }
        const ollamaOptions = await parseProviderOptions({
          provider: "ollama",
          providerOptions,
          schema: ollamaEmbeddingProviderOptions
        });
        const dimensions = (_a25 = ollamaOptions == null ? void 0 : ollamaOptions.dimensions) != null ? _a25 : this.settings.dimensions;
        const truncate = (_b18 = ollamaOptions == null ? void 0 : ollamaOptions.truncate) != null ? _b18 : this.settings.truncate;
        const keepAlive = (_c = ollamaOptions == null ? void 0 : ollamaOptions.keepAlive) != null ? _c : this.settings.keepAlive;
        const body = {
          model: this.modelId,
          input: values
        };
        if (dimensions !== void 0) body.dimensions = dimensions;
        if (truncate !== void 0) body.truncate = truncate;
        if (keepAlive !== void 0) body.keep_alive = keepAlive;
        const {
          responseHeaders,
          value: response,
          rawValue
        } = await postJsonToApi({
          url: this.config.url({
            path: "/embed",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), headers),
          body: { ...body },
          failedResponseHandler: ollamaFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(
            ollamaTextEmbeddingResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        const typedResponse = response;
        return {
          embeddings: typedResponse.embeddings.map((item) => item),
          usage: { tokens: typedResponse.prompt_eval_count },
          response: { headers: responseHeaders, body: rawValue },
          warnings: []
        };
      }
    };
    ollamaTextEmbeddingResponseSchema = z313.object({
      model: z313.string(),
      embeddings: z313.array(z313.array(z313.number())),
      total_duration: z313.number(),
      load_duration: z313.number(),
      prompt_eval_count: z313.number()
    });
    baseOllamaResponseSchema2 = z413.object({
      model: z413.string(),
      created_at: z413.string(),
      done: z413.boolean(),
      message: z413.object({
        content: z413.string(),
        role: z413.string(),
        thinking: z413.string().optional(),
        tool_calls: z413.array(
          z413.object({
            function: z413.object({
              name: z413.string(),
              arguments: z413.record(z413.string(), z413.any())
            }),
            id: z413.string().optional()
          })
        ).optional().nullable()
      }),
      done_reason: z413.string().optional(),
      eval_count: z413.number().optional(),
      eval_duration: z413.number().optional(),
      load_duration: z413.number().optional(),
      prompt_eval_count: z413.number().optional(),
      prompt_eval_duration: z413.number().optional(),
      total_duration: z413.number().optional()
    });
    OllamaResponseProcessor = class {
      constructor(config2) {
        this.config = config2;
      }
      processGenerateResponse(response) {
        const content = this.extractContent(response);
        const finishReason = mapOllamaFinishReason(response.done_reason);
        const usage = this.extractUsage(response);
        const providerMetadata = { ollama: {} };
        return {
          content,
          finishReason,
          usage,
          providerMetadata
        };
      }
      extractContent(response) {
        var _a25, _b18, _c, _d, _e;
        const content = [];
        const text2 = response.message.content;
        if (text2 != null && text2.length > 0) {
          content.push({
            type: "text",
            text: text2
          });
        }
        const thinking = response.message.thinking;
        if (thinking != null && thinking.length > 0) {
          content.push({
            type: "reasoning",
            text: thinking
          });
        }
        for (const toolCall of (_a25 = response.message.tool_calls) != null ? _a25 : []) {
          content.push({
            type: "tool-call",
            toolCallId: (_e = toolCall.id) != null ? _e : (_d = (_c = (_b18 = this.config).generateId) == null ? void 0 : _c.call(_b18)) != null ? _d : generateId(),
            toolName: toolCall.function.name,
            input: JSON.stringify(toolCall.function.arguments)
          });
        }
        return content;
      }
      extractUsage(response) {
        var _a25, _b18;
        return {
          inputTokens: {
            total: (_a25 = response.prompt_eval_count) != null ? _a25 : 0,
            noCache: void 0,
            cacheRead: void 0,
            cacheWrite: void 0
          },
          outputTokens: {
            total: (_b18 = response.eval_count) != null ? _b18 : 0,
            text: void 0,
            reasoning: void 0
          }
        };
      }
    };
    ollamaProviderOptions = z512.object({
      /**
       * Enable or disable the model's thinking process. When enabled, the output will separate
       * the model's thinking from the model's output. When disabled, the model will not think
       * and directly output the content.
       *
       * Only supported by certain models like DeepSeek R1 and Qwen 3.
       */
      think: z512.boolean().optional(),
      options: z512.object({
        num_ctx: z512.number().optional(),
        repeat_last_n: z512.number().optional(),
        repeat_penalty: z512.number().optional(),
        temperature: z512.number().optional(),
        seed: z512.number().optional(),
        stop: z512.array(z512.string()).optional(),
        num_predict: z512.number().optional(),
        top_k: z512.number().optional(),
        top_p: z512.number().optional(),
        min_p: z512.number().optional()
      }).optional()
    });
    OllamaRequestBuilder = class {
      async buildRequest({
        modelId,
        maxOutputTokens,
        temperature,
        stopSequences,
        topP,
        topK,
        presencePenalty,
        frequencyPenalty,
        seed,
        prompt,
        providerOptions,
        tools,
        toolChoice,
        responseFormat
      }) {
        const warnings = this.collectUnsupportedSettingsWarnings({
          topK,
          seed,
          presencePenalty,
          frequencyPenalty,
          stopSequences
        });
        const { messages, warnings: messageWarnings } = convertToOllamaResponsesMessages({
          prompt,
          systemMessageMode: "system"
        });
        warnings.push(...messageWarnings);
        const ollamaOptions = await this.parseProviderOptions(providerOptions);
        const baseArgs = this.buildBaseArgs({
          modelId,
          prompt,
          temperature,
          topP,
          maxOutputTokens,
          responseFormat,
          ollamaOptions
        });
        const { tools: ollamaTools, toolChoice: ollamaToolChoice, toolWarnings } = prepareResponsesTools3({
          tools,
          toolChoice
        });
        return {
          args: {
            ...baseArgs,
            tools: ollamaTools,
            tool_choice: ollamaToolChoice
          },
          warnings: [...warnings, ...toolWarnings]
        };
      }
      collectUnsupportedSettingsWarnings({
        topK,
        seed,
        presencePenalty,
        frequencyPenalty,
        stopSequences
      }) {
        const warnings = [];
        const unsupportedSettings = [
          { value: topK, name: "topK" },
          { value: seed, name: "seed" },
          { value: presencePenalty, name: "presencePenalty" },
          { value: frequencyPenalty, name: "frequencyPenalty" },
          { value: stopSequences, name: "stopSequences" }
        ];
        for (const { value: value2, name: name25 } of unsupportedSettings) {
          if (value2 != null) {
            warnings.push({ type: "unsupported", feature: "setting", details: name25 });
          }
        }
        return warnings;
      }
      async parseProviderOptions(providerOptions) {
        const result = await parseProviderOptions({
          provider: "ollama",
          providerOptions,
          schema: ollamaProviderOptions
        });
        return result != null ? result : null;
      }
      buildBaseArgs({
        modelId,
        prompt,
        temperature,
        topP,
        maxOutputTokens,
        responseFormat,
        ollamaOptions
      }) {
        var _a25, _b18;
        return {
          model: modelId,
          messages: convertToOllamaChatMessages({
            prompt,
            systemMessageMode: "system"
          }),
          temperature,
          top_p: topP,
          max_output_tokens: maxOutputTokens,
          ...(responseFormat == null ? void 0 : responseFormat.type) === "json" && {
            format: responseFormat.schema != null ? responseFormat.schema : "json"
          },
          think: (_a25 = ollamaOptions == null ? void 0 : ollamaOptions.think) != null ? _a25 : false,
          options: (_b18 = ollamaOptions == null ? void 0 : ollamaOptions.options) != null ? _b18 : void 0
        };
      }
    };
    OllamaStreamProcessor = class {
      constructor(config2) {
        this.config = config2;
        this.state = this.initializeState();
      }
      createTransformStream(warnings, options) {
        return new TransformStream({
          transform: (chunk, controller) => {
            this.processChunk(chunk, controller, options);
          },
          flush: (controller) => {
            this.finalizeStream(controller);
          }
        });
      }
      initializeState() {
        return {
          finishReason: {
            unified: "other",
            raw: void 0
          },
          usage: {
            inputTokens: {
              total: void 0,
              noCache: void 0,
              cacheRead: void 0,
              cacheWrite: void 0
            },
            outputTokens: {
              total: void 0,
              text: void 0,
              reasoning: void 0
            }
          },
          responseId: null,
          ongoingToolCalls: {},
          hasToolCalls: false,
          isFirstChunk: true,
          hasTextStarted: false,
          hasReasoningStarted: false,
          textEnded: false,
          reasoningEnded: false,
          textId: generateId(),
          reasoningId: generateId()
        };
      }
      processChunk(chunk, controller, options) {
        if (options == null ? void 0 : options.includeRawChunks) {
          controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
        }
        const values = extractOllamaResponseObjectsFromChunk(chunk);
        if (values.length === 0) {
          if (!chunk.success) {
            this.state.finishReason = { unified: "error", raw: void 0 };
            controller.enqueue({ type: "error", error: chunk.error });
          }
          return;
        }
        for (const value2 of values) {
          this.processResponseValue(value2, controller);
        }
      }
      processResponseValue(value2, controller) {
        if (value2 && typeof value2 === "object" && "error" in value2) {
          this.state.finishReason = { unified: "error", raw: void 0 };
          controller.enqueue({ type: "error", error: value2.error });
          return;
        }
        if (this.state.isFirstChunk) {
          this.state.isFirstChunk = false;
          controller.enqueue({
            type: "response-metadata",
            ...getResponseMetadata6(value2)
          });
        }
        if (value2.done) {
          this.handleDoneChunk(value2, controller);
        }
        const delta = value2 == null ? void 0 : value2.message;
        if (delta) {
          this.processDelta(delta, controller);
        }
      }
      handleDoneChunk(value2, controller) {
        this.state.finishReason = mapOllamaFinishReason(value2.done_reason);
        this.state.usage = {
          inputTokens: {
            total: value2.prompt_eval_count || 0,
            noCache: void 0,
            cacheRead: void 0,
            cacheWrite: void 0
          },
          outputTokens: {
            total: value2.eval_count || 0,
            text: void 0,
            reasoning: void 0
          }
        };
        if (this.state.hasTextStarted && !this.state.textEnded) {
          controller.enqueue({ type: "text-end", id: this.state.textId });
          this.state.textEnded = true;
        }
        if (this.state.hasReasoningStarted && !this.state.reasoningEnded) {
          controller.enqueue({ type: "reasoning-end", id: this.state.reasoningId });
          this.state.reasoningEnded = true;
        }
      }
      processDelta(delta, controller) {
        this.processTextContent(delta, controller);
        this.processThinking(delta, controller);
        this.processToolCalls(delta, controller);
      }
      processTextContent(delta, controller) {
        if ((delta == null ? void 0 : delta.content) != null) {
          if (!this.state.hasTextStarted) {
            controller.enqueue({ type: "text-start", id: this.state.textId });
            this.state.hasTextStarted = true;
          }
          controller.enqueue({
            type: "text-delta",
            id: this.state.textId,
            delta: delta.content
          });
        }
      }
      processThinking(delta, controller) {
        if (delta == null ? void 0 : delta.thinking) {
          if (!this.state.hasReasoningStarted) {
            controller.enqueue({ type: "reasoning-start", id: this.state.reasoningId });
            this.state.hasReasoningStarted = true;
          }
          controller.enqueue({
            type: "reasoning-delta",
            id: this.state.reasoningId,
            delta: delta.thinking
          });
        }
      }
      processToolCalls(delta, controller) {
        var _a25, _b18, _c, _d;
        for (const toolCall of (_a25 = delta.tool_calls) != null ? _a25 : []) {
          if (((_b18 = toolCall.function) == null ? void 0 : _b18.name) == null) {
            throw new InvalidResponseDataError({
              data: toolCall,
              message: `Expected 'function.name' to be a string.`
            });
          }
          if (((_c = toolCall.function) == null ? void 0 : _c.name) != null && ((_d = toolCall.function) == null ? void 0 : _d.arguments) != null) {
            this.emitToolCall(toolCall, controller);
          }
        }
      }
      emitToolCall(toolCall, controller) {
        var _a25, _b18, _c, _d;
        const id = (_d = toolCall.id) != null ? _d : (_c = (_b18 = (_a25 = this.config).generateId) == null ? void 0 : _b18.call(_a25)) != null ? _c : generateId();
        controller.enqueue({
          type: "tool-input-start",
          id,
          toolName: toolCall.function.name
        });
        controller.enqueue({
          type: "tool-input-delta",
          id,
          delta: JSON.stringify(toolCall.function.arguments)
        });
        controller.enqueue({
          type: "tool-input-end",
          id
        });
        controller.enqueue({
          type: "tool-call",
          toolCallId: id,
          toolName: toolCall.function.name,
          input: JSON.stringify(toolCall.function.arguments)
        });
        this.state.hasToolCalls = true;
      }
      finalizeStream(controller) {
        if (this.state.hasTextStarted && !this.state.textEnded) {
          controller.enqueue({ type: "text-end", id: this.state.textId });
        }
        if (this.state.hasReasoningStarted && !this.state.reasoningEnded) {
          controller.enqueue({ type: "reasoning-end", id: this.state.reasoningId });
        }
        controller.enqueue({
          type: "finish",
          finishReason: this.state.finishReason,
          usage: this.state.usage,
          providerMetadata: {
            ollama: {
              responseId: this.state.responseId
            }
          }
        });
      }
    };
    OllamaResponsesLanguageModel = class {
      constructor(modelId, config2) {
        this.specificationVersion = "v3";
        this.defaultObjectGenerationMode = void 0;
        this.supportsImageUrls = true;
        this.supportedUrls = {
          "image/*": [
            /^https?:\/\/.*$/
          ]
        };
        this.modelId = modelId;
        this.config = config2;
        this.provider = config2.provider;
        this.requestBuilder = new OllamaRequestBuilder();
        this.responseProcessor = new OllamaResponseProcessor(config2);
      }
      async doGenerate(options) {
        const { args: body, warnings } = await this.prepareRequest(options);
        const {
          responseHeaders,
          value: response,
          rawValue: rawResponse
        } = await postJsonToApi({
          url: this.config.url({
            path: "/chat",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body: { ...body, stream: false },
          failedResponseHandler: ollamaFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler(baseOllamaResponseSchema2),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const processedResponse = this.responseProcessor.processGenerateResponse(response);
        return {
          ...processedResponse,
          request: { body: JSON.stringify(body) },
          response: {
            modelId: this.modelId,
            timestamp: /* @__PURE__ */ new Date(),
            headers: responseHeaders,
            body: rawResponse
          },
          warnings
        };
      }
      async doStream(options) {
        const { args: body, warnings } = await this.prepareRequest(options);
        const { responseHeaders, value: response } = await postJsonToApi({
          url: this.config.url({
            path: "/chat",
            modelId: this.modelId
          }),
          headers: combineHeaders(this.config.headers(), options.headers),
          body: { ...body, stream: true },
          failedResponseHandler: ollamaFailedResponseHandler,
          successfulResponseHandler: createNdjsonStreamResponseHandler(baseOllamaResponseSchema2),
          abortSignal: options.abortSignal,
          fetch: this.config.fetch
        });
        const streamProcessor = new OllamaStreamProcessor(this.config);
        return {
          stream: response.pipeThrough(
            streamProcessor.createTransformStream(warnings, options)
          ),
          request: { body },
          response: { headers: responseHeaders },
          warnings
        };
      }
      async prepareRequest(options) {
        return await this.requestBuilder.buildRequest({
          modelId: this.modelId,
          ...options
        });
      }
    };
    ollama = createOllama();
  }
});

// node_modules/ssh-config/dist/glob.js
var require_glob = __commonJS({
  "node_modules/ssh-config/dist/glob.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function escapeChars(text2, chars) {
      for (let char of chars) {
        text2 = text2.replace(new RegExp("\\" + char, "g"), "\\" + char);
      }
      return text2;
    }
    function match(pattern, text2) {
      pattern = escapeChars(pattern, "\\()[]{}.+^$|");
      pattern = pattern.replace(/\*/g, ".*").replace(/\?/g, ".?");
      return new RegExp("^(?:" + pattern + ")$").test(text2);
    }
    function glob2(patternList, text2) {
      const patterns = Array.isArray(patternList) ? patternList : patternList.split(/,/);
      let result = false;
      for (const pattern of patterns) {
        const negate = pattern[0] == "!";
        if (negate && match(pattern.slice(1), text2)) {
          return false;
        } else if (match(pattern, text2)) {
          result = true;
        }
      }
      return result;
    }
    exports.default = glob2;
  }
});

// node_modules/ssh-config/dist/ssh-config.js
var require_ssh_config = __commonJS({
  "node_modules/ssh-config/dist/ssh-config.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.glob = exports.LineType = void 0;
    exports.parse = parse3;
    exports.stringify = stringify;
    var glob_1 = __importDefault2(require_glob());
    exports.glob = glob_1.default;
    var child_process_1 = __require("child_process");
    var os_1 = __importDefault2(__require("os"));
    var RE_SPACE = /\s/;
    var RE_LINE_BREAK = /\r|\n/;
    var RE_SECTION_DIRECTIVE = /^(Host|Match)$/i;
    var RE_MULTI_VALUE_DIRECTIVE = /^(GlobalKnownHostsFile|Host|IPQoS|SendEnv|UserKnownHostsFile|ProxyCommand|Match|CanonicalDomains)$/i;
    var RE_QUOTE_DIRECTIVE = /^(?:CertificateFile|IdentityFile|IdentityAgent|User)$/i;
    var RE_SINGLE_LINE_DIRECTIVE = /^(Include|IdentityFile)$/i;
    var LineType;
    (function(LineType2) {
      LineType2[LineType2["DIRECTIVE"] = 1] = "DIRECTIVE";
      LineType2[LineType2["COMMENT"] = 2] = "COMMENT";
      LineType2[LineType2["EMPTY"] = 3] = "EMPTY";
    })(LineType || (exports.LineType = LineType = {}));
    var REPEATABLE_DIRECTIVES = [
      "IdentityFile",
      "LocalForward",
      "RemoteForward",
      "DynamicForward",
      "CertificateFile"
    ];
    function compare(line, opts) {
      return opts.hasOwnProperty(line.param) && opts[line.param] === line.value;
    }
    function getIndent(config2) {
      for (const line of config2) {
        if (line.type === LineType.DIRECTIVE && "config" in line) {
          for (const subline of line.config) {
            if (subline.before) {
              return subline.before;
            }
          }
        }
      }
      return "  ";
    }
    function match(criteria, context2) {
      const testCriterion = (key, criterion) => {
        switch (key.toLowerCase()) {
          case "all":
            return true;
          case "final":
            if (context2.inFinalPass) {
              return true;
            }
            context2.doFinalPass = true;
            return false;
          case "exec":
            const command = `function main {
          ${criterion}
        }
        main`;
            return (0, child_process_1.spawnSync)(command, { shell: true }).status === 0;
          case "host":
            return (0, glob_1.default)(criterion, context2.params.HostName);
          case "originalhost":
            return (0, glob_1.default)(criterion, context2.params.OriginalHost);
          case "user":
            return (0, glob_1.default)(criterion, context2.params.User);
          case "localuser":
            return (0, glob_1.default)(criterion, context2.params.LocalUser);
        }
      };
      for (const key in criteria) {
        const criterion = criteria[key];
        const values = Array.isArray(criterion) ? criterion.map(({ val }) => val) : criterion;
        if (!testCriterion(key, values)) {
          return false;
        }
      }
      return true;
    }
    var SSHConfig2 = class _SSHConfig extends Array {
      /**
       * Parse SSH config text into structured object.
       */
      static parse(text2) {
        return parse3(text2);
      }
      /**
       * Stringify structured object into SSH config text.
       */
      static stringify(config2) {
        return stringify(config2);
      }
      compute(opts) {
        if (typeof opts === "string")
          opts = { Host: opts };
        let userInfo4;
        try {
          userInfo4 = os_1.default.userInfo();
        } catch (_a25) {
          userInfo4 = { username: process.env.USER || process.env.USERNAME || "" };
        }
        const context2 = {
          params: {
            Host: opts.Host,
            HostName: opts.Host,
            OriginalHost: opts.Host,
            User: userInfo4.username,
            LocalUser: userInfo4.username
          },
          inFinalPass: false,
          doFinalPass: false
        };
        const obj = {};
        const setProperty = (name25, value2) => {
          let val;
          if (Array.isArray(value2)) {
            if (/ProxyCommand/i.test(name25)) {
              val = value2.map(({ val: val2, separator, quoted }) => {
                return `${separator}${quoted ? `"${val2.replace(/"/g, '\\"')}"` : val2}`;
              }).join("").trim();
            } else {
              val = value2.map(({ val: val2 }) => val2);
            }
          } else {
            val = value2;
          }
          const val0 = Array.isArray(val) ? val[0] : val;
          if (REPEATABLE_DIRECTIVES.includes(name25)) {
            const list = obj[name25] || (obj[name25] = []);
            list.push(...[].concat(val));
          } else if (obj[name25] == null) {
            if (name25 === "HostName") {
              context2.params.HostName = val0;
            } else if (name25 === "User") {
              context2.params.User = val0;
            }
            obj[name25] = val;
          }
        };
        if (opts.User !== void 0) {
          setProperty("User", opts.User);
        }
        const doPass = () => {
          for (const line of this) {
            if (line.type !== LineType.DIRECTIVE)
              continue;
            if (line.param === "Host" && (0, glob_1.default)(Array.isArray(line.value) ? line.value.map(({ val }) => val) : line.value, context2.params.Host)) {
              let canonicalizeHostName = false;
              let canonicalDomains = [];
              setProperty(line.param, line.value);
              for (const subline of line.config) {
                if (subline.type === LineType.DIRECTIVE) {
                  setProperty(subline.param, subline.value);
                  if (/^CanonicalizeHostName$/i.test(subline.param) && subline.value === "yes") {
                    canonicalizeHostName = true;
                  }
                  if (/^CanonicalDomains$/i.test(subline.param) && Array.isArray(subline.value)) {
                    canonicalDomains = subline.value.map(({ val }) => val);
                  }
                }
              }
              if (canonicalDomains.length > 0 && canonicalizeHostName && context2.params.Host === context2.params.OriginalHost) {
                for (const domain of canonicalDomains) {
                  const host = `${context2.params.OriginalHost}.${domain}`;
                  const { status, stderr } = (0, child_process_1.spawnSync)("nslookup", [host]);
                  if (status === 0 && !/can't find/.test(stderr.toString())) {
                    context2.params.Host = host;
                    setProperty("Host", host);
                    doPass();
                    break;
                  }
                }
              }
            } else if (line.param === "Match" && "criteria" in line && match(line.criteria, context2)) {
              for (const subline of line.config) {
                if (subline.type === LineType.DIRECTIVE) {
                  setProperty(subline.param, subline.value);
                }
              }
            } else if (line.param !== "Host" && line.param !== "Match") {
              setProperty(line.param, line.value);
            }
          }
        };
        doPass();
        if (context2.doFinalPass) {
          context2.inFinalPass = true;
          context2.params.Host = context2.params.HostName;
          doPass();
        }
        return obj;
      }
      find(opts) {
        if (typeof opts === "function")
          return super.find(opts);
        if (!(opts && ("Host" in opts || "Match" in opts))) {
          throw new Error("Can only find by Host or Match");
        }
        return super.find((line) => compare(line, opts));
      }
      remove(opts) {
        let index;
        if (typeof opts === "function") {
          index = super.findIndex(opts);
        } else if (!(opts && ("Host" in opts || "Match" in opts))) {
          throw new Error("Can only remove by Host or Match");
        } else {
          index = super.findIndex((line) => compare(line, opts));
        }
        if (index >= 0)
          return this.splice(index, 1);
      }
      toString() {
        return stringify(this);
      }
      /**
       * Append new section to existing SSH config.
       */
      append(opts) {
        const indent = getIndent(this);
        const lastEntry = this.length > 0 ? this[this.length - 1] : null;
        let config2 = lastEntry && lastEntry.config || this;
        let configWas = this;
        let lastLine = config2.length > 0 ? config2[config2.length - 1] : lastEntry;
        if (lastLine && !lastLine.after)
          lastLine.after = "\n";
        let sectionLineFound = config2 !== configWas;
        for (const param in opts) {
          const value2 = opts[param];
          const line = {
            type: LineType.DIRECTIVE,
            param,
            separator: " ",
            value: Array.isArray(value2) ? value2.map((val, i) => ({ val, separator: i === 0 ? "" : " " })) : value2,
            before: sectionLineFound ? indent : indent.replace(/  |\t/, ""),
            after: "\n"
          };
          if (RE_SECTION_DIRECTIVE.test(param)) {
            sectionLineFound = true;
            line.before = indent.replace(/  |\t/, "");
            config2 = configWas;
            if (lastLine && lastLine.after === "\n")
              lastLine.after += "\n";
            config2.push(line);
            config2 = line.config = new _SSHConfig();
          } else {
            config2.push(line);
          }
          lastLine = line;
        }
        return configWas;
      }
      /**
       * Prepend new section to existing SSH config.
       */
      prepend(opts, beforeFirstSection = false) {
        const indent = getIndent(this);
        let config2 = this;
        let i = 0;
        if (beforeFirstSection) {
          while (i < this.length && !("config" in this[i])) {
            i += 1;
          }
          if (i >= this.length) {
            return this.append(opts);
          }
        }
        let sectionLineFound = false;
        let processedLines = 0;
        for (const param in opts) {
          processedLines += 1;
          const value2 = opts[param];
          const line = {
            type: LineType.DIRECTIVE,
            param,
            separator: " ",
            value: Array.isArray(value2) ? value2.map((val, i2) => ({ val, separator: i2 === 0 ? "" : " " })) : value2,
            before: "",
            after: "\n"
          };
          if (RE_SECTION_DIRECTIVE.test(param)) {
            line.before = indent.replace(/  |\t/, "");
            config2.splice(i, 0, line);
            config2 = line.config = new _SSHConfig();
            sectionLineFound = true;
            continue;
          }
          if (processedLines === Object.keys(opts).length) {
            line.after += "\n";
          }
          if (!sectionLineFound) {
            config2.splice(i, 0, line);
            i += 1;
            if (RE_SINGLE_LINE_DIRECTIVE.test(param)) {
              line.after += "\n";
            }
            continue;
          }
          line.before = indent;
          config2.push(line);
        }
        return config2;
      }
    };
    SSHConfig2.DIRECTIVE = LineType.DIRECTIVE;
    SSHConfig2.COMMENT = LineType.COMMENT;
    exports.default = SSHConfig2;
    function parse3(text2) {
      let i = 0;
      let chr = next();
      let config2 = new SSHConfig2();
      let configWas = config2;
      function next() {
        return text2[i++];
      }
      function space() {
        let spaces = "";
        while (RE_SPACE.test(chr)) {
          spaces += chr;
          chr = next();
        }
        return spaces;
      }
      function linebreak() {
        let breaks = "";
        while (RE_LINE_BREAK.test(chr)) {
          breaks += chr;
          chr = next();
        }
        return breaks;
      }
      function parameter() {
        let param = "";
        while (chr && /[^ \t=]/.test(chr)) {
          param += chr;
          chr = next();
        }
        return param;
      }
      function separator() {
        let sep = space();
        if (chr === "=") {
          sep += chr;
          chr = next();
        }
        return sep + space();
      }
      function value2() {
        let val = "";
        let quoted = false;
        let escaped = false;
        while (chr && !RE_LINE_BREAK.test(chr)) {
          if (escaped) {
            val += chr === '"' ? chr : `\\${chr}`;
            escaped = false;
          } else if (chr === '"' && (!val || quoted)) {
            quoted = !quoted;
          } else if (chr === "\\") {
            escaped = true;
          } else if (chr === "#" && !quoted) {
            break;
          } else {
            val += chr;
          }
          chr = next();
        }
        if (quoted || escaped) {
          throw new Error(`Unexpected line break at ${val}`);
        }
        return val.trim();
      }
      function comment() {
        const type2 = LineType.COMMENT;
        let content = "";
        while (chr && !RE_LINE_BREAK.test(chr)) {
          content += chr;
          chr = next();
        }
        return { type: type2, content, before: "", after: "" };
      }
      function values() {
        const results = [];
        let val = "";
        let valQuoted = false;
        let valSeparator = " ";
        let quoted = false;
        let escaped = false;
        while (chr && !RE_LINE_BREAK.test(chr)) {
          if (escaped) {
            val += chr === '"' ? chr : `\\${chr}`;
            escaped = false;
          } else if (chr === '"') {
            quoted = !quoted;
          } else if (chr === "\\") {
            escaped = true;
          } else if (quoted) {
            val += chr;
            valQuoted = true;
          } else if (/[ \t=]/.test(chr)) {
            if (val) {
              results.push({ val, separator: valSeparator, quoted: valQuoted });
              val = "";
              valQuoted = false;
              valSeparator = chr;
            }
          } else if (chr === "#" && results.length > 0) {
            break;
          } else {
            val += chr;
          }
          chr = next();
        }
        if (quoted || escaped) {
          throw new Error(`Unexpected line break at ${results.map(({ val: val2 }) => val2).concat(val).join(" ")}`);
        }
        if (val)
          results.push({ val, separator: valSeparator, quoted: valQuoted });
        return results.length > 1 ? results : results[0].val;
      }
      function directive() {
        const type2 = LineType.DIRECTIVE;
        const param = parameter();
        const multiple = RE_MULTI_VALUE_DIRECTIVE.test(param);
        const result = {
          type: type2,
          param,
          separator: separator(),
          quoted: !multiple && chr === '"',
          value: multiple ? values() : value2(),
          before: "",
          after: ""
        };
        if (!result.quoted)
          delete result.quoted;
        if (/^Match$/i.test(param)) {
          const criteria = {};
          if (typeof result.value === "string") {
            result.value = [{ val: result.value, separator: "", quoted: result.quoted }];
          }
          let i2 = 0;
          while (i2 < result.value.length) {
            const { val: keyword } = result.value[i2];
            switch (keyword.toLowerCase()) {
              case "all":
              case "canonical":
              case "final":
                criteria[keyword] = [];
                i2 += 1;
                break;
              default:
                if (i2 + 1 >= result.value.length) {
                  throw new Error(`Missing value for match criteria ${keyword}`);
                }
                criteria[keyword] = result.value[i2 + 1].val;
                i2 += 2;
                break;
            }
          }
          result.criteria = criteria;
        }
        return result;
      }
      function line() {
        const before = space();
        const node = chr === "#" ? comment() : directive();
        const after = linebreak();
        node.before = before;
        node.after = after;
        return node;
      }
      while (chr) {
        let node = line();
        if (node.type === LineType.DIRECTIVE && RE_SECTION_DIRECTIVE.test(node.param)) {
          config2 = configWas;
          config2.push(node);
          config2 = node.config = new SSHConfig2();
        } else if (node.type === LineType.DIRECTIVE && !node.param) {
          if (config2.length === 0) {
            if (configWas.length === 0) {
              configWas.push({ type: LineType.EMPTY, before: "", after: node.before });
            } else {
              configWas[configWas.length - 1].after += node.before;
            }
          } else {
            config2[config2.length - 1].after += node.before;
          }
        } else {
          config2.push(node);
        }
      }
      return configWas;
    }
    function stringify(config2) {
      let str = "";
      function formatValue(value2, quoted) {
        if (Array.isArray(value2)) {
          let result = "";
          for (const { val, separator, quoted: quoted2 } of value2) {
            result += (result ? separator : "") + formatValue(val, quoted2 || RE_SPACE.test(val));
          }
          return result;
        }
        return quoted ? `"${value2}"` : value2;
      }
      function formatDirective(line) {
        const quoted = line.quoted || RE_QUOTE_DIRECTIVE.test(line.param) && RE_SPACE.test(line.value);
        const value2 = formatValue(line.value, quoted);
        return `${line.param}${line.separator}${value2}`;
      }
      const format = (line) => {
        str += line.before;
        if (line.type === LineType.COMMENT) {
          str += line.content;
        } else if (line.type === LineType.DIRECTIVE && REPEATABLE_DIRECTIVES.includes(line.param)) {
          (Array.isArray(line.value) ? line.value : [line.value]).forEach((value2, i, values) => {
            str += formatDirective({ ...line, value: typeof value2 !== "string" ? value2.val : value2 });
            if (i < values.length - 1)
              str += `
${line.before}`;
          });
        } else if (line.type === LineType.DIRECTIVE) {
          str += formatDirective(line);
        }
        str += line.after;
        if ("config" in line) {
          line.config.forEach(format);
        }
      };
      config2.forEach(format);
      return str;
    }
  }
});

// node_modules/ssh-config/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/ssh-config/dist/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m, p);
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ssh_config_1 = __importDefault2(require_ssh_config());
    __exportStar2(require_ssh_config(), exports);
    exports.default = ssh_config_1.default;
  }
});

// node_modules/imurmurhash/imurmurhash.js
var require_imurmurhash = __commonJS({
  "node_modules/imurmurhash/imurmurhash.js"(exports, module) {
    (function() {
      var cache;
      function MurmurHash3(key, seed) {
        var m = this instanceof MurmurHash3 ? this : cache;
        m.reset(seed);
        if (typeof key === "string" && key.length > 0) {
          m.hash(key);
        }
        if (m !== this) {
          return m;
        }
      }
      ;
      MurmurHash3.prototype.hash = function(key) {
        var h1, k1, i, top, len;
        len = key.length;
        this.len += len;
        k1 = this.k1;
        i = 0;
        switch (this.rem) {
          case 0:
            k1 ^= len > i ? key.charCodeAt(i++) & 65535 : 0;
          case 1:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 8 : 0;
          case 2:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 16 : 0;
          case 3:
            k1 ^= len > i ? (key.charCodeAt(i) & 255) << 24 : 0;
            k1 ^= len > i ? (key.charCodeAt(i++) & 65280) >> 8 : 0;
        }
        this.rem = len + this.rem & 3;
        len -= this.rem;
        if (len > 0) {
          h1 = this.h1;
          while (1) {
            k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
            k1 = k1 << 15 | k1 >>> 17;
            k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
            h1 ^= k1;
            h1 = h1 << 13 | h1 >>> 19;
            h1 = h1 * 5 + 3864292196 & 4294967295;
            if (i >= len) {
              break;
            }
            k1 = key.charCodeAt(i++) & 65535 ^ (key.charCodeAt(i++) & 65535) << 8 ^ (key.charCodeAt(i++) & 65535) << 16;
            top = key.charCodeAt(i++);
            k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
          }
          k1 = 0;
          switch (this.rem) {
            case 3:
              k1 ^= (key.charCodeAt(i + 2) & 65535) << 16;
            case 2:
              k1 ^= (key.charCodeAt(i + 1) & 65535) << 8;
            case 1:
              k1 ^= key.charCodeAt(i) & 65535;
          }
          this.h1 = h1;
        }
        this.k1 = k1;
        return this;
      };
      MurmurHash3.prototype.result = function() {
        var k1, h1;
        k1 = this.k1;
        h1 = this.h1;
        if (k1 > 0) {
          k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
          h1 ^= k1;
        }
        h1 ^= this.len;
        h1 ^= h1 >>> 16;
        h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295;
        h1 ^= h1 >>> 13;
        h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295;
        h1 ^= h1 >>> 16;
        return h1 >>> 0;
      };
      MurmurHash3.prototype.reset = function(seed) {
        this.h1 = typeof seed === "number" ? seed : 0;
        this.rem = this.k1 = this.len = 0;
        return this;
      };
      cache = new MurmurHash3();
      if (typeof module != "undefined") {
        module.exports = MurmurHash3;
      } else {
        this.MurmurHash3 = MurmurHash3;
      }
    })();
  }
});

// node_modules/signal-exit/dist/cjs/signals.js
var require_signals = __commonJS({
  "node_modules/signal-exit/dist/cjs/signals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signals = void 0;
    exports.signals = [];
    exports.signals.push("SIGHUP", "SIGINT", "SIGTERM");
    if (process.platform !== "win32") {
      exports.signals.push(
        "SIGALRM",
        "SIGABRT",
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      exports.signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
    }
  }
});

// node_modules/signal-exit/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/signal-exit/dist/cjs/index.js"(exports) {
    "use strict";
    var _a25;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unload = exports.load = exports.onExit = exports.signals = void 0;
    var signals_js_1 = require_signals();
    Object.defineProperty(exports, "signals", { enumerable: true, get: function() {
      return signals_js_1.signals;
    } });
    var processOk = (process4) => !!process4 && typeof process4 === "object" && typeof process4.removeListener === "function" && typeof process4.emit === "function" && typeof process4.reallyExit === "function" && typeof process4.listeners === "function" && typeof process4.kill === "function" && typeof process4.pid === "number" && typeof process4.on === "function";
    var kExitEmitter = Symbol.for("signal-exit emitter");
    var global2 = globalThis;
    var ObjectDefineProperty = Object.defineProperty.bind(Object);
    var Emitter = class {
      emitted = {
        afterExit: false,
        exit: false
      };
      listeners = {
        afterExit: [],
        exit: []
      };
      count = 0;
      id = Math.random();
      constructor() {
        if (global2[kExitEmitter]) {
          return global2[kExitEmitter];
        }
        ObjectDefineProperty(global2, kExitEmitter, {
          value: this,
          writable: false,
          enumerable: false,
          configurable: false
        });
      }
      on(ev, fn) {
        this.listeners[ev].push(fn);
      }
      removeListener(ev, fn) {
        const list = this.listeners[ev];
        const i = list.indexOf(fn);
        if (i === -1) {
          return;
        }
        if (i === 0 && list.length === 1) {
          list.length = 0;
        } else {
          list.splice(i, 1);
        }
      }
      emit(ev, code, signal) {
        if (this.emitted[ev]) {
          return false;
        }
        this.emitted[ev] = true;
        let ret = false;
        for (const fn of this.listeners[ev]) {
          ret = fn(code, signal) === true || ret;
        }
        if (ev === "exit") {
          ret = this.emit("afterExit", code, signal) || ret;
        }
        return ret;
      }
    };
    var SignalExitBase = class {
    };
    var signalExitWrap = (handler) => {
      return {
        onExit(cb, opts) {
          return handler.onExit(cb, opts);
        },
        load() {
          return handler.load();
        },
        unload() {
          return handler.unload();
        }
      };
    };
    var SignalExitFallback = class extends SignalExitBase {
      onExit() {
        return () => {
        };
      }
      load() {
      }
      unload() {
      }
    };
    var SignalExit = class extends SignalExitBase {
      // "SIGHUP" throws an `ENOSYS` error on Windows,
      // so use a supported signal instead
      /* c8 ignore start */
      #hupSig = process3.platform === "win32" ? "SIGINT" : "SIGHUP";
      /* c8 ignore stop */
      #emitter = new Emitter();
      #process;
      #originalProcessEmit;
      #originalProcessReallyExit;
      #sigListeners = {};
      #loaded = false;
      constructor(process4) {
        super();
        this.#process = process4;
        this.#sigListeners = {};
        for (const sig of signals_js_1.signals) {
          this.#sigListeners[sig] = () => {
            const listeners = this.#process.listeners(sig);
            let { count } = this.#emitter;
            const p = process4;
            if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") {
              count += p.__signal_exit_emitter__.count;
            }
            if (listeners.length === count) {
              this.unload();
              const ret = this.#emitter.emit("exit", null, sig);
              const s = sig === "SIGHUP" ? this.#hupSig : sig;
              if (!ret)
                process4.kill(process4.pid, s);
            }
          };
        }
        this.#originalProcessReallyExit = process4.reallyExit;
        this.#originalProcessEmit = process4.emit;
      }
      onExit(cb, opts) {
        if (!processOk(this.#process)) {
          return () => {
          };
        }
        if (this.#loaded === false) {
          this.load();
        }
        const ev = opts?.alwaysLast ? "afterExit" : "exit";
        this.#emitter.on(ev, cb);
        return () => {
          this.#emitter.removeListener(ev, cb);
          if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) {
            this.unload();
          }
        };
      }
      load() {
        if (this.#loaded) {
          return;
        }
        this.#loaded = true;
        this.#emitter.count += 1;
        for (const sig of signals_js_1.signals) {
          try {
            const fn = this.#sigListeners[sig];
            if (fn)
              this.#process.on(sig, fn);
          } catch (_) {
          }
        }
        this.#process.emit = (ev, ...a) => {
          return this.#processEmit(ev, ...a);
        };
        this.#process.reallyExit = (code) => {
          return this.#processReallyExit(code);
        };
      }
      unload() {
        if (!this.#loaded) {
          return;
        }
        this.#loaded = false;
        signals_js_1.signals.forEach((sig) => {
          const listener = this.#sigListeners[sig];
          if (!listener) {
            throw new Error("Listener not defined for signal: " + sig);
          }
          try {
            this.#process.removeListener(sig, listener);
          } catch (_) {
          }
        });
        this.#process.emit = this.#originalProcessEmit;
        this.#process.reallyExit = this.#originalProcessReallyExit;
        this.#emitter.count -= 1;
      }
      #processReallyExit(code) {
        if (!processOk(this.#process)) {
          return 0;
        }
        this.#process.exitCode = code || 0;
        this.#emitter.emit("exit", this.#process.exitCode, null);
        return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
      }
      #processEmit(ev, ...args2) {
        const og = this.#originalProcessEmit;
        if (ev === "exit" && processOk(this.#process)) {
          if (typeof args2[0] === "number") {
            this.#process.exitCode = args2[0];
          }
          const ret = og.call(this.#process, ev, ...args2);
          this.#emitter.emit("exit", this.#process.exitCode, null);
          return ret;
        } else {
          return og.call(this.#process, ev, ...args2);
        }
      }
    };
    var process3 = globalThis.process;
    _a25 = signalExitWrap(processOk(process3) ? new SignalExit(process3) : new SignalExitFallback()), /**
     * Called when the process is exiting, whether via signal, explicit
     * exit, or running out of stuff to do.
     *
     * If the global process object is not suitable for instrumentation,
     * then this will be a no-op.
     *
     * Returns a function that may be used to unload signal-exit.
     */
    exports.onExit = _a25.onExit, /**
     * Load the listeners.  Likely you never need to call this, unless
     * doing a rather deep integration with signal-exit functionality.
     * Mostly exposed for the benefit of testing.
     *
     * @internal
     */
    exports.load = _a25.load, /**
     * Unload the listeners.  Likely you never need to call this, unless
     * doing a rather deep integration with signal-exit functionality.
     * Mostly exposed for the benefit of testing.
     *
     * @internal
     */
    exports.unload = _a25.unload;
  }
});

// node_modules/write-file-atomic/lib/index.js
var require_lib = __commonJS({
  "node_modules/write-file-atomic/lib/index.js"(exports, module) {
    "use strict";
    module.exports = writeFile2;
    module.exports.sync = writeFileSync2;
    module.exports._getTmpname = getTmpname;
    module.exports._cleanupOnExit = cleanupOnExit;
    var fs15 = __require("fs");
    var MurmurHash3 = require_imurmurhash();
    var { onExit } = require_cjs();
    var path24 = __require("path");
    var { promisify } = __require("util");
    var activeFiles = {};
    var threadId = (function getId() {
      try {
        const workerThreads = __require("worker_threads");
        return workerThreads.threadId;
      } catch (e) {
        return 0;
      }
    })();
    var invocations = 0;
    function getTmpname(filename) {
      return filename + "." + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
    }
    function cleanupOnExit(tmpfile) {
      return () => {
        try {
          fs15.unlinkSync(typeof tmpfile === "function" ? tmpfile() : tmpfile);
        } catch {
        }
      };
    }
    function serializeActiveFile(absoluteName) {
      return new Promise((resolve4) => {
        if (!activeFiles[absoluteName]) {
          activeFiles[absoluteName] = [];
        }
        activeFiles[absoluteName].push(resolve4);
        if (activeFiles[absoluteName].length === 1) {
          resolve4();
        }
      });
    }
    function isChownErrOk(err) {
      if (err.code === "ENOSYS") {
        return true;
      }
      const nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (err.code === "EINVAL" || err.code === "EPERM") {
          return true;
        }
      }
      return false;
    }
    async function writeFileAsync(filename, data, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      let fd;
      let tmpfile;
      const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile));
      const absoluteName = path24.resolve(filename);
      try {
        await serializeActiveFile(absoluteName);
        const truename = await promisify(fs15.realpath)(filename).catch(() => filename);
        tmpfile = getTmpname(truename);
        if (!options.mode || !options.chown) {
          const stats = await promisify(fs15.stat)(truename).catch(() => {
          });
          if (stats) {
            if (options.mode == null) {
              options.mode = stats.mode;
            }
            if (options.chown == null && process.getuid) {
              options.chown = { uid: stats.uid, gid: stats.gid };
            }
          }
        }
        fd = await promisify(fs15.open)(tmpfile, "w", options.mode);
        if (options.tmpfileCreated) {
          await options.tmpfileCreated(tmpfile);
        }
        if (ArrayBuffer.isView(data)) {
          await promisify(fs15.write)(fd, data, 0, data.length, 0);
        } else if (data != null) {
          await promisify(fs15.write)(fd, String(data), 0, String(options.encoding || "utf8"));
        }
        if (options.fsync !== false) {
          await promisify(fs15.fsync)(fd);
        }
        await promisify(fs15.close)(fd);
        fd = null;
        if (options.chown) {
          await promisify(fs15.chown)(tmpfile, options.chown.uid, options.chown.gid).catch((err) => {
            if (!isChownErrOk(err)) {
              throw err;
            }
          });
        }
        if (options.mode) {
          await promisify(fs15.chmod)(tmpfile, options.mode).catch((err) => {
            if (!isChownErrOk(err)) {
              throw err;
            }
          });
        }
        await promisify(fs15.rename)(tmpfile, truename);
      } finally {
        if (fd) {
          await promisify(fs15.close)(fd).catch(
            /* istanbul ignore next */
            () => {
            }
          );
        }
        removeOnExitHandler();
        await promisify(fs15.unlink)(tmpfile).catch(() => {
        });
        activeFiles[absoluteName].shift();
        if (activeFiles[absoluteName].length > 0) {
          activeFiles[absoluteName][0]();
        } else {
          delete activeFiles[absoluteName];
        }
      }
    }
    async function writeFile2(filename, data, options, callback) {
      if (options instanceof Function) {
        callback = options;
        options = {};
      }
      const promise = writeFileAsync(filename, data, options);
      if (callback) {
        try {
          const result = await promise;
          return callback(result);
        } catch (err) {
          return callback(err);
        }
      }
      return promise;
    }
    function writeFileSync2(filename, data, options) {
      if (typeof options === "string") {
        options = { encoding: options };
      } else if (!options) {
        options = {};
      }
      try {
        filename = fs15.realpathSync(filename);
      } catch (ex) {
      }
      const tmpfile = getTmpname(filename);
      if (!options.mode || !options.chown) {
        try {
          const stats = fs15.statSync(filename);
          options = Object.assign({}, options);
          if (!options.mode) {
            options.mode = stats.mode;
          }
          if (!options.chown && process.getuid) {
            options.chown = { uid: stats.uid, gid: stats.gid };
          }
        } catch (ex) {
        }
      }
      let fd;
      const cleanup = cleanupOnExit(tmpfile);
      const removeOnExitHandler = onExit(cleanup);
      let threw = true;
      try {
        fd = fs15.openSync(tmpfile, "w", options.mode || 438);
        if (options.tmpfileCreated) {
          options.tmpfileCreated(tmpfile);
        }
        if (ArrayBuffer.isView(data)) {
          fs15.writeSync(fd, data, 0, data.length, 0);
        } else if (data != null) {
          fs15.writeSync(fd, String(data), 0, String(options.encoding || "utf8"));
        }
        if (options.fsync !== false) {
          fs15.fsyncSync(fd);
        }
        fs15.closeSync(fd);
        fd = null;
        if (options.chown) {
          try {
            fs15.chownSync(tmpfile, options.chown.uid, options.chown.gid);
          } catch (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }
        }
        if (options.mode) {
          try {
            fs15.chmodSync(tmpfile, options.mode);
          } catch (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }
        }
        fs15.renameSync(tmpfile, filename);
        threw = false;
      } finally {
        if (fd) {
          try {
            fs15.closeSync(fd);
          } catch (ex) {
          }
        }
        removeOnExitHandler();
        if (threw) {
          cleanup();
        }
      }
    }
  }
});

// node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS({
  "node_modules/yaml/dist/nodes/identity.js"(exports) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias");
    var DOC = Symbol.for("yaml.document");
    var MAP = Symbol.for("yaml.map");
    var PAIR = Symbol.for("yaml.pair");
    var SCALAR = Symbol.for("yaml.scalar");
    var SEQ = Symbol.for("yaml.seq");
    var NODE_TYPE = Symbol.for("yaml.node.type");
    var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    exports.ALIAS = ALIAS;
    exports.DOC = DOC;
    exports.MAP = MAP;
    exports.NODE_TYPE = NODE_TYPE;
    exports.PAIR = PAIR;
    exports.SCALAR = SCALAR;
    exports.SEQ = SEQ;
    exports.hasAnchor = hasAnchor;
    exports.isAlias = isAlias;
    exports.isCollection = isCollection;
    exports.isDocument = isDocument;
    exports.isMap = isMap;
    exports.isNode = isNode;
    exports.isPair = isPair;
    exports.isScalar = isScalar;
    exports.isSeq = isSeq;
  }
});

// node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "node_modules/yaml/dist/visit.js"(exports) {
    "use strict";
    var identity = require_identity();
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove node");
    function visit2(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        visit_(null, node, visitor_, Object.freeze([]));
    }
    visit2.BREAK = BREAK;
    visit2.SKIP = SKIP;
    visit2.REMOVE = REMOVE;
    function visit_(key, node, visitor, path24) {
      const ctrl = callVisitor(key, node, visitor, path24);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path24, ctrl);
        return visit_(key, ctrl, visitor, path24);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path24 = Object.freeze(path24.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = visit_(i, node.items[i], visitor, path24);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path24 = Object.freeze(path24.concat(node));
          const ck = visit_("key", node.key, visitor, path24);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = visit_("value", node.value, visitor, path24);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path24) {
      const ctrl = await callVisitor(key, node, visitor, path24);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path24, ctrl);
        return visitAsync_(key, ctrl, visitor, path24);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path24 = Object.freeze(path24.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = await visitAsync_(i, node.items[i], visitor, path24);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path24 = Object.freeze(path24.concat(node));
          const ck = await visitAsync_("key", node.key, visitor, path24);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = await visitAsync_("value", node.value, visitor, path24);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path24) {
      if (typeof visitor === "function")
        return visitor(key, node, path24);
      if (identity.isMap(node))
        return visitor.Map?.(key, node, path24);
      if (identity.isSeq(node))
        return visitor.Seq?.(key, node, path24);
      if (identity.isPair(node))
        return visitor.Pair?.(key, node, path24);
      if (identity.isScalar(node))
        return visitor.Scalar?.(key, node, path24);
      if (identity.isAlias(node))
        return visitor.Alias?.(key, node, path24);
      return void 0;
    }
    function replaceNode(key, path24, node) {
      const parent = path24[path24.length - 1];
      if (identity.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity.isPair(parent)) {
        if (key === "key")
          parent.key = node;
        else
          parent.value = node;
      } else if (identity.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }
    exports.visit = visit2;
    exports.visitAsync = visitAsync;
  }
});

// node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "node_modules/yaml/dist/doc/directives.js"(exports) {
    "use strict";
    var identity = require_identity();
    var visit2 = require_visit();
    var escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    var Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError2) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name25 = parts.shift();
        switch (name25) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError2(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError2(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version] = parts;
            if (version === "1.1" || version === "1.2") {
              this.yaml.version = version;
              return true;
            } else {
              const isValid = /^\d+\.\d+$/.test(version);
              onError2(6, `Unsupported YAML version ${version}`, isValid);
              return false;
            }
          }
          default:
            onError2(0, `Unknown directive ${name25}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError2) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError2(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError2(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError2("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError2(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error) {
            onError2(String(error));
            return null;
          }
        }
        if (handle === "!")
          return source;
        onError2(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
          const tags = {};
          visit2.visit(doc.contents, (_key, node) => {
            if (identity.isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports.Directives = Directives;
  }
});

// node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "node_modules/yaml/dist/doc/anchors.js"(exports) {
    "use strict";
    var identity = require_identity();
    var visit2 = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = /* @__PURE__ */ new Set();
      visit2.visit(root, {
        Value(_key, node) {
          if (node.anchor)
            anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix, exclude) {
      for (let i = 1; true; ++i) {
        const name25 = `${prefix}${i}`;
        if (!exclude.has(name25))
          return name25;
      }
    }
    function createNodeAnchors(doc, prefix) {
      const aliasObjects = [];
      const sourceObjects = /* @__PURE__ */ new Map();
      let prevAnchors = null;
      return {
        onAnchor: (source) => {
          aliasObjects.push(source);
          prevAnchors ?? (prevAnchors = anchorNames(doc));
          const anchor = findNewAnchor(prefix, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (const source of aliasObjects) {
            const ref = sourceObjects.get(source);
            if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
              ref.node.anchor = ref.anchor;
            } else {
              const error = new Error("Failed to resolve repeated object (this should not happen)");
              error.source = source;
              throw error;
            }
          }
        },
        sourceObjects
      };
    }
    exports.anchorIsValid = anchorIsValid;
    exports.anchorNames = anchorNames;
    exports.createNodeAnchors = createNodeAnchors;
    exports.findNewAnchor = findNewAnchor;
  }
});

// node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "node_modules/yaml/dist/doc/applyReviver.js"(exports) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            if (v1 === void 0)
              delete val[i];
            else if (v1 !== v0)
              val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              val.delete(k);
            else if (v1 !== v0)
              val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0)
              val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              delete val[k];
            else if (v1 !== v0)
              val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }
    exports.applyReviver = applyReviver;
  }
});

// node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "node_modules/yaml/dist/nodes/toJS.js"(exports) {
    "use strict";
    var identity = require_identity();
    function toJS(value2, arg, ctx) {
      if (Array.isArray(value2))
        return value2.map((v, i) => toJS(v, String(i), ctx));
      if (value2 && typeof value2.toJSON === "function") {
        if (!ctx || !identity.hasAnchor(value2))
          return value2.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value2, data);
        ctx.onCreate = (res2) => {
          data.res = res2;
          delete ctx.onCreate;
        };
        const res = value2.toJSON(arg, ctx);
        if (ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if (typeof value2 === "bigint" && !ctx?.keep)
        return Number(value2);
      return value2;
    }
    exports.toJS = toJS;
  }
});

// node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "node_modules/yaml/dist/nodes/Node.js"(exports) {
    "use strict";
    var applyReviver = require_applyReviver();
    var identity = require_identity();
    var toJS = require_toJS();
    var NodeBase = class {
      constructor(type2) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type2 });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    exports.NodeBase = NodeBase;
  }
});

// node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "node_modules/yaml/dist/nodes/Alias.js"(exports) {
    "use strict";
    var anchors = require_anchors();
    var visit2 = require_visit();
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var Alias = class extends Node.NodeBase {
      constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc, ctx) {
        let nodes;
        if (ctx?.aliasResolveCache) {
          nodes = ctx.aliasResolveCache;
        } else {
          nodes = [];
          visit2.visit(doc, {
            Node: (_key, node) => {
              if (identity.isAlias(node) || identity.hasAnchor(node))
                nodes.push(node);
            }
          });
          if (ctx)
            ctx.aliasResolveCache = nodes;
        }
        let found = void 0;
        for (const node of nodes) {
          if (node === this)
            break;
          if (node.anchor === this.source)
            found = node;
        }
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc, ctx);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors2.get(source);
        if (!data) {
          toJS.toJS(source, null, ctx);
          data = anchors2.get(source);
        }
        if (data?.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors2);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors2 && source && anchors2.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors2);
          if (c > count)
            count = c;
        }
        return count;
      } else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports.Alias = Alias;
  }
});

// node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "node_modules/yaml/dist/nodes/Scalar.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value2) => !value2 || typeof value2 !== "function" && typeof value2 !== "object";
    var Scalar = class extends Node.NodeBase {
      constructor(value2) {
        super(identity.SCALAR);
        this.value = value2;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports.Scalar = Scalar;
    exports.isScalarValue = isScalarValue;
  }
});

// node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "node_modules/yaml/dist/doc/createNode.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value2, tagName, tags) {
      if (tagName) {
        const match = tags.filter((t) => t.tag === tagName);
        const tagObj = match.find((t) => !t.format) ?? match[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => t.identify?.(value2) && !t.format);
    }
    function createNode(value2, tagName, ctx) {
      if (identity.isDocument(value2))
        value2 = value2.contents;
      if (identity.isNode(value2))
        return value2;
      if (identity.isPair(value2)) {
        const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value2);
        return map;
      }
      if (value2 instanceof String || value2 instanceof Number || value2 instanceof Boolean || typeof BigInt !== "undefined" && value2 instanceof BigInt) {
        value2 = value2.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
      let ref = void 0;
      if (aliasDuplicateObjects && value2 && typeof value2 === "object") {
        ref = sourceObjects.get(value2);
        if (ref) {
          ref.anchor ?? (ref.anchor = onAnchor(value2));
          return new Alias.Alias(ref.anchor);
        } else {
          ref = { anchor: null, node: null };
          sourceObjects.set(value2, ref);
        }
      }
      if (tagName?.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value2, tagName, schema.tags);
      if (!tagObj) {
        if (value2 && typeof value2.toJSON === "function") {
          value2 = value2.toJSON();
        }
        if (!value2 || typeof value2 !== "object") {
          const node2 = new Scalar.Scalar(value2);
          if (ref)
            ref.node = node2;
          return node2;
        }
        tagObj = value2 instanceof Map ? schema[identity.MAP] : Symbol.iterator in Object(value2) ? schema[identity.SEQ] : schema[identity.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value2, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value2, ctx) : new Scalar.Scalar(value2);
      if (tagName)
        node.tag = tagName;
      else if (!tagObj.default)
        node.tag = tagObj.tag;
      if (ref)
        ref.node = node;
      return node;
    }
    exports.createNode = createNode;
  }
});

// node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "node_modules/yaml/dist/nodes/Collection.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var identity = require_identity();
    var Node = require_Node();
    function collectionFromPath(schema, path24, value2) {
      let v = value2;
      for (let i = path24.length - 1; i >= 0; --i) {
        const k = path24[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = /* @__PURE__ */ new Map([[k, v]]);
        }
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path24) => path24 == null || typeof path24 === "object" && !!path24[Symbol.iterator]().next().done;
    var Collection = class extends Node.NodeBase {
      constructor(type2, schema) {
        super(type2);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
          copy.schema = schema;
        copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path24, value2) {
        if (isEmptyPath(path24))
          this.add(value2);
        else {
          const [key, ...rest] = path24;
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.addIn(rest, value2);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value2));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path24) {
        const [key, ...rest] = path24;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path24, keepScalar) {
        const [key, ...rest] = path24;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && identity.isScalar(node) ? node.value : node;
        else
          return identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity.isPair(node))
            return false;
          const n = node.value;
          return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path24) {
        const [key, ...rest] = path24;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path24, value2) {
        const [key, ...rest] = path24;
        if (rest.length === 0) {
          this.set(key, value2);
        } else {
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.setIn(rest, value2);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value2));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    exports.Collection = Collection;
    exports.collectionFromPath = collectionFromPath;
    exports.isEmptyPath = isEmptyPath;
  }
});

// node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyComment.js"(exports) {
    "use strict";
    var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment, indent) {
      if (/^\n+$/.test(comment))
        return comment.substring(1);
      return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
    }
    var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
    exports.indentComment = indentComment;
    exports.lineComment = lineComment;
    exports.stringifyComment = stringifyComment;
  }
});

// node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "node_modules/yaml/dist/stringify/foldFlowLines.js"(exports) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text2, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text2;
      if (lineWidth < minContentWidth)
        minContentWidth = 0;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text2.length <= endStep)
        return text2;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text2, i, indent.length);
        if (i !== -1)
          end = i + endStep;
      }
      for (let ch; ch = text2[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text2[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text2, i, indent.length);
          end = i + indent.length + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text2[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text2[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text2;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text2;
      if (onFold)
        onFold();
      let res = text2.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text2.length;
        if (fold === 0)
          res = `
${indent}${text2.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold])
            res += `${text2[fold]}\\`;
          res += `
${indent}${text2.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text2, i, indent) {
      let end = i;
      let start = i + 1;
      let ch = text2[start];
      while (ch === " " || ch === "	") {
        if (i < start + indent) {
          ch = text2[++i];
        } else {
          do {
            ch = text2[++i];
          } while (ch && ch !== "\n");
          end = i;
          start = i + 1;
          ch = text2[start];
        }
      }
      return end;
    }
    exports.FOLD_BLOCK = FOLD_BLOCK;
    exports.FOLD_FLOW = FOLD_FLOW;
    exports.FOLD_QUOTED = FOLD_QUOTED;
    exports.foldFlowLines = foldFlowLines;
  }
});

// node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyString.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value2, ctx) {
      const json2 = JSON.stringify(value2);
      if (ctx.options.doubleQuotedAsJSON)
        return json2;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent = ctx.indent || (containsDocumentMarker(value2) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i = 0, ch = json2[i]; ch; ch = json2[++i]) {
        if (ch === " " && json2[i + 1] === "\\" && json2[i + 2] === "n") {
          str += json2.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json2[i + 1]) {
            case "u":
              {
                str += json2.slice(start, i);
                const code = json2.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str += "\\x" + code.substr(2);
                    else
                      str += json2.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json2[i + 2] === '"' || json2.length < minMultiLineLength) {
                i += 1;
              } else {
                str += json2.slice(start, i) + "\n\n";
                while (json2[i + 2] === "\\" && json2[i + 3] === "n" && json2[i + 4] !== '"') {
                  str += "\n";
                  i += 2;
                }
                str += indent;
                if (json2[i + 2] === " ")
                  str += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str = start ? str + json2.slice(start) : json2;
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value2, ctx) {
      if (ctx.options.singleQuote === false || ctx.implicitKey && value2.includes("\n") || /[ \t]\n|\n[ \t]/.test(value2))
        return doubleQuotedString(value2, ctx);
      const indent = ctx.indent || (containsDocumentMarker(value2) ? "  " : "");
      const res = "'" + value2.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value2, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false)
        qs = doubleQuotedString;
      else {
        const hasDouble = value2.includes('"');
        const hasSingle = value2.includes("'");
        if (hasDouble && !hasSingle)
          qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
          qs = doubleQuotedString;
        else
          qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value2, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment, type: type2, value: value2 }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value2)) {
        return quotedString(value2, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value2) ? "  " : "");
      const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type2 === Scalar.Scalar.BLOCK_FOLDED ? false : type2 === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value2, lineWidth, indent.length);
      if (!value2)
        return literal ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value2.length; endStart > 0; --endStart) {
        const ch = value2[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ")
          break;
      }
      let end = value2.substring(endStart);
      const endNlPos = end.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value2 === end || endNlPos !== end.length - 1) {
        chomp = "+";
        if (onChompKeep)
          onChompKeep();
      } else {
        chomp = "";
      }
      if (end) {
        value2 = value2.slice(0, -end.length);
        if (end[end.length - 1] === "\n")
          end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value2.length; ++startEnd) {
        const ch = value2[startEnd];
        if (ch === " ")
          startWithSpace = true;
        else if (ch === "\n")
          startNlPos = startEnd;
        else
          break;
      }
      let start = value2.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value2 = value2.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
      }
      const indentSize = indent ? "2" : "1";
      let header = (startWithSpace ? indentSize : "") + chomp;
      if (comment) {
        header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
        if (onComment)
          onComment();
      }
      if (!literal) {
        const foldedValue = value2.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== "folded" && type2 !== Scalar.Scalar.BLOCK_FOLDED) {
          foldOptions.onOverflow = () => {
            literalFallback = true;
          };
        }
        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
        if (!literalFallback)
          return `>${header}
${indent}${body}`;
      }
      value2 = value2.replace(/\n+/g, `$&${indent}`);
      return `|${header}
${indent}${start}${value2}${end}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type: type2, value: value2 } = item;
      const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
      if (implicitKey && value2.includes("\n") || inFlow && /[[\]{},]/.test(value2)) {
        return quotedString(value2, ctx);
      }
      if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value2)) {
        return implicitKey || inFlow || !value2.includes("\n") ? quotedString(value2, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type2 !== Scalar.Scalar.PLAIN && value2.includes("\n")) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value2)) {
        if (indent === "") {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent === indentStep) {
          return quotedString(value2, ctx);
        }
      }
      const str = value2.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
          return quotedString(value2, ctx);
      }
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
      let { type: type2 } = item;
      if (type2 !== Scalar.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type2 = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type2);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null)
          throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }
    exports.stringifyString = stringifyString;
  }
});

// node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS({
  "node_modules/yaml/dist/stringify/stringify.js"(exports) {
    "use strict";
    var anchors = require_anchors();
    var identity = require_identity();
    var stringifyComment = require_stringifyComment();
    var stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
      }, doc.schema.toStringOptions, options);
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match = tags.filter((t) => t.tag === item.tag);
        if (match.length > 0)
          return match.find((t) => t.format === item.format) ?? match[0];
      }
      let tagObj = void 0;
      let obj;
      if (identity.isScalar(item)) {
        obj = item.value;
        let match = tags.filter((t) => t.identify?.(obj));
        if (match.length > 1) {
          const testMatch = match.filter((t) => t.test);
          if (testMatch.length > 0)
            match = testMatch;
        }
        tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name25 = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
        throw new Error(`Tag not resolved for ${name25} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives)
        return "";
      const props = [];
      const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
      if (tag)
        props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity.isAlias(item)) {
        if (ctx.doc.directives)
          return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases)
            ctx.resolvedAliases.add(item);
          else
            ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = void 0;
      const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
      tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str;
      return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
    }
    exports.createStringifyContext = createStringifyContext;
    exports.stringify = stringify;
  }
});

// node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyPair.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value: value2 }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
      let keyComment = identity.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value2 == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value2 == null) {
          if (keyCommentDone && onComment)
            onComment();
          return str === "" ? "?" : explicitKey ? `? ${str}` : str;
        }
      } else if (allNullValues && !simpleKeys || value2 == null && explicitKey) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str;
      }
      if (keyCommentDone)
        keyComment = null;
      if (explicitKey) {
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}
${indent}:`;
      } else {
        str = `${str}:`;
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      }
      let vsb, vcb, valueComment;
      if (identity.isNode(value2)) {
        vsb = !!value2.spaceBefore;
        vcb = value2.commentBefore;
        valueComment = value2.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value2 && typeof value2 === "object")
          value2 = doc.createNode(value2);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity.isScalar(value2))
        ctx.indentAtStart = str.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value2) && !value2.flow && !value2.tag && !value2.anchor) {
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify.stringify(value2, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
          const cs = commentString(vcb);
          ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
          if (ws === "\n" && valueComment)
            ws = "\n\n";
        } else {
          ws += `
${ctx.indent}`;
        }
      } else if (!explicitKey && identity.isCollection(value2)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value2.flow ?? value2.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
              sp0 = valueStr.indexOf(" ", sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0)
              hasPropsLine = true;
          }
          if (!hasPropsLine)
            ws = `
${ctx.indent}`;
        }
      } else if (valueStr === "" || valueStr[0] === "\n") {
        ws = "";
      }
      str += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment)
          onComment();
      } else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str;
    }
    exports.stringifyPair = stringifyPair;
  }
});

// node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "node_modules/yaml/dist/log.js"(exports) {
    "use strict";
    var node_process = __require("process");
    function debug2(logLevel, ...messages) {
      if (logLevel === "debug")
        console.log(...messages);
    }
    function warn(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof node_process.emitWarning === "function")
          node_process.emitWarning(warning);
        else
          console.warn(warning);
      }
    }
    exports.debug = debug2;
    exports.warn = warn;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/merge.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var MERGE_KEY = "<<";
    var merge = {
      identify: (value2) => value2 === MERGE_KEY || typeof value2 === "symbol" && value2.description === MERGE_KEY,
      default: "key",
      tag: "tag:yaml.org,2002:merge",
      test: /^<<$/,
      resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
      }),
      stringify: () => MERGE_KEY
    };
    var isMergeKey = (ctx, key) => (merge.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
    function addMergeToJSMap(ctx, map, value2) {
      value2 = ctx && identity.isAlias(value2) ? value2.resolve(ctx.doc) : value2;
      if (identity.isSeq(value2))
        for (const it of value2.items)
          mergeValue(ctx, map, it);
      else if (Array.isArray(value2))
        for (const it of value2)
          mergeValue(ctx, map, it);
      else
        mergeValue(ctx, map, value2);
    }
    function mergeValue(ctx, map, value2) {
      const source = ctx && identity.isAlias(value2) ? value2.resolve(ctx.doc) : value2;
      if (!identity.isMap(source))
        throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source.toJSON(null, ctx, Map);
      for (const [key, value3] of srcMap) {
        if (map instanceof Map) {
          if (!map.has(key))
            map.set(key, value3);
        } else if (map instanceof Set) {
          map.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
          Object.defineProperty(map, key, {
            value: value3,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map;
    }
    exports.addMergeToJSMap = addMergeToJSMap;
    exports.isMergeKey = isMergeKey;
    exports.merge = merge;
  }
});

// node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports) {
    "use strict";
    var log2 = require_log();
    var merge = require_merge();
    var stringify = require_stringify();
    var identity = require_identity();
    var toJS = require_toJS();
    function addPairToJSMap(ctx, map, { key, value: value2 }) {
      if (identity.isNode(key) && key.addToJSMap)
        key.addToJSMap(ctx, map, value2);
      else if (merge.isMergeKey(ctx, key))
        merge.addMergeToJSMap(ctx, map, value2);
      else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map instanceof Map) {
          map.set(jsKey, toJS.toJS(value2, jsKey, ctx));
        } else if (map instanceof Set) {
          map.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value2, stringKey, ctx);
          if (stringKey in map)
            Object.defineProperty(map, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map[stringKey] = jsValue;
        }
      }
      return map;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (const node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40)
            jsonStr = jsonStr.substring(0, 36) + '..."';
          log2.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports.addPairToJSMap = addPairToJSMap;
  }
});

// node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "node_modules/yaml/dist/nodes/Pair.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var identity = require_identity();
    function createPair(key, value2, ctx) {
      const k = createNode.createNode(key, void 0, ctx);
      const v = createNode.createNode(value2, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class _Pair {
      constructor(key, value2 = null) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
        this.key = key;
        this.value = value2;
      }
      clone(schema) {
        let { key, value: value2 } = this;
        if (identity.isNode(key))
          key = key.clone(schema);
        if (identity.isNode(value2))
          value2 = value2.clone(schema);
        return new _Pair(key, value2);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports.Pair = Pair;
    exports.createPair = createPair;
  }
});

// node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyCollection.js"(exports) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify2(collection, ctx, options);
    }
    function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent, options: { commentString } } = ctx;
      const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
      let chompKeep = false;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment2 = null;
        if (identity.isNode(item)) {
          if (!chompKeep && item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
          if (item.comment)
            comment2 = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
        if (comment2)
          str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
        if (chompKeep && comment2)
          chompKeep = false;
        lines.push(blockItemPrefix + str2);
      }
      let str;
      if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
      } else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
          const line = lines[i];
          str += line ? `
${indent}${line}` : "\n";
        }
      }
      if (comment) {
        str += "\n" + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
      const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
          if (item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, false);
          if (item.comment)
            comment = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, false);
            if (ik.comment)
              reqNewline = true;
          }
          const iv = identity.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment)
              comment = iv.comment;
            if (iv.commentBefore)
              reqNewline = true;
          } else if (item.value == null && ik?.comment) {
            comment = ik.comment;
          }
        }
        if (comment)
          reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => comment = null);
        if (i < items.length - 1)
          str += ",";
        if (comment)
          str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
          reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
      }
      const { start, end } = flowChars;
      if (lines.length === 0) {
        return start + end;
      } else {
        if (!reqNewline) {
          const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
          reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
          let str = start;
          for (const line of lines)
            str += line ? `
${indentStep}${indent}${line}` : "\n";
          return `${str}
${indent}${end}`;
        } else {
          return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
        }
      }
    }
    function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
      if (comment && chompKeep)
        comment = comment.replace(/^\n+/, "");
      if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart());
      }
    }
    exports.stringifyCollection = stringifyCollection;
  }
});

// node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "node_modules/yaml/dist/nodes/YAMLMap.js"(exports) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    function findPair(items, key) {
      const k = identity.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (identity.isPair(it)) {
          if (it.key === key || it.key === k)
            return it;
          if (identity.isScalar(it.key) && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema);
        const add = (key, value2) => {
          if (typeof replacer === "function")
            value2 = replacer.call(obj, key, value2);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value2 !== void 0 || keepUndefined)
            map.items.push(Pair.createPair(key, value2, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value2] of obj)
            add(key, value2);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === "function") {
          map.items.sort(schema.sortMapEntries);
        }
        return map;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair?.value);
        } else
          _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value2) {
        this.add(new Pair.Pair(key, value2), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports.YAMLMap = YAMLMap;
    exports.findPair = findPair;
  }
});

// node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "node_modules/yaml/dist/schema/common/map.js"(exports) {
    "use strict";
    var identity = require_identity();
    var YAMLMap = require_YAMLMap();
    var map = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map2, onError2) {
        if (!identity.isMap(map2))
          onError2("Expected a mapping for this tag");
        return map2;
      },
      createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
    };
    exports.map = map;
  }
});

// node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "node_modules/yaml/dist/nodes/YAMLSeq.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var stringifyCollection = require_stringifyCollection();
    var Collection = require_Collection();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema) {
        super(identity.SEQ, schema);
        this.items = [];
      }
      add(value2) {
        this.items.push(value2);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value2) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity.isScalar(prev) && Scalar.isScalarValue(value2))
          prev.value = value2;
        else
          this.items[idx] = value2;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, void 0, ctx));
          }
        }
        return seq;
      }
    };
    function asItemIndex(key) {
      let idx = identity.isScalar(key) ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports.YAMLSeq = YAMLSeq;
  }
});

// node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "node_modules/yaml/dist/schema/common/seq.js"(exports) {
    "use strict";
    var identity = require_identity();
    var YAMLSeq = require_YAMLSeq();
    var seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError2) {
        if (!identity.isSeq(seq2))
          onError2("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
    };
    exports.seq = seq;
  }
});

// node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS({
  "node_modules/yaml/dist/schema/common/string.js"(exports) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string = {
      identify: (value2) => typeof value2 === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports.string = string;
  }
});

// node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "node_modules/yaml/dist/schema/common/null.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var nullTag = {
      identify: (value2) => value2 == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    exports.nullTag = nullTag;
  }
});

// node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "node_modules/yaml/dist/schema/core/bool.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var boolTag = {
      identify: (value2) => typeof value2 === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value: value2 }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value2 === sv)
            return source;
        }
        return value2 ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports.boolTag = boolTag;
  }
});

// node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyNumber.js"(exports) {
    "use strict";
    function stringifyNumber({ format, minFractionDigits, tag, value: value2 }) {
      if (typeof value2 === "bigint")
        return String(value2);
      const num = typeof value2 === "number" ? value2 : Number(value2);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = Object.is(value2, -0) ? "-0" : JSON.stringify(value2);
      if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    exports.stringifyNumber = stringifyNumber;
  }
});

// node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "node_modules/yaml/dist/schema/core/float.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "node_modules/yaml/dist/schema/core/int.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
    var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      const { value: value2 } = node;
      if (intIdentify(value2) && value2 >= 0)
        return prefix + value2.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value2) => intIdentify(value2) && value2 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value2) => intIdentify(value2) && value2 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "node_modules/yaml/dist/schema/core/schema.js"(exports) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports.schema = schema;
  }
});

// node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "node_modules/yaml/dist/schema/json/schema.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var map = require_map();
    var seq = require_seq();
    function intIdentify(value2) {
      return typeof value2 === "bigint" || Number.isInteger(value2);
    }
    var stringifyJSON2 = ({ value: value2 }) => JSON.stringify(value2);
    var jsonScalars = [
      {
        identify: (value2) => typeof value2 === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON2
      },
      {
        identify: (value2) => value2 == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON2
      },
      {
        identify: (value2) => typeof value2 === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true$|^false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON2
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value: value2 }) => intIdentify(value2) ? value2.toString() : JSON.stringify(value2)
      },
      {
        identify: (value2) => typeof value2 === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON2
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError2) {
        onError2(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    var schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
    exports.schema = schema;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports) {
    "use strict";
    var node_buffer = __require("buffer");
    var Scalar = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value2) => value2 instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError2) {
        if (typeof node_buffer.Buffer === "function") {
          return node_buffer.Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i)
            buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          onError2("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type: type2, value: value2 }, ctx, onComment, onChompKeep) {
        if (!value2)
          return "";
        const buf = value2;
        let str;
        if (typeof node_buffer.Buffer === "function") {
          str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        type2 ?? (type2 = Scalar.Scalar.BLOCK_LITERAL);
        if (type2 !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = str.substr(o, lineWidth);
          }
          str = lines.join(type2 === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({ comment, type: type2, value: str }, ctx, onComment, onChompKeep);
      }
    };
    exports.binary = binary;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError2) {
      if (identity.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (identity.isPair(item))
            continue;
          else if (identity.isMap(item)) {
            if (item.items.length > 1)
              onError2("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn = pair.value ?? pair.key;
              cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
      } else
        onError2("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === "function")
            it = replacer.call(iterable, String(i++), it);
          let key, value2;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value2 = it[1];
            } else
              throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys = Object.keys(it);
            if (keys.length === 1) {
              key = keys[0];
              value2 = it[key];
            } else {
              throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
            }
          } else {
            key = it;
          }
          pairs2.items.push(Pair.createPair(key, value2, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports.createPairs = createPairs;
    exports.pairs = pairs;
    exports.resolvePairs = resolvePairs;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports) {
    "use strict";
    var identity = require_identity();
    var toJS = require_toJS();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var pairs = require_pairs();
    var YAMLOMap = class _YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map);
        for (const pair of this.items) {
          let key, value2;
          if (identity.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value2 = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map.set(key, value2);
        }
        return map;
      }
      static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value2) => value2 instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError2) {
        const pairs$1 = pairs.resolvePairs(seq, onError2);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError2(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
    };
    exports.YAMLOMap = YAMLOMap;
    exports.omap = omap;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value: value2, source }, ctx) {
      const boolObj = value2 ? trueTag : falseTag;
      if (source && boolObj.test.test(source))
        return source;
      return value2 ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value2) => value2 === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value2) => value2 === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify
    };
    exports.falseTag = falseTag;
    exports.trueTag = trueTag;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
    function intResolve(str, offset, radix, { intAsBigInt }) {
      const sign = str[0];
      if (sign === "-" || sign === "+")
        offset += 1;
      str = str.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n2 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const { value: value2 } = node;
      if (intIdentify(value2)) {
        const str = value2.toString(radix);
        return value2 < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intBin = intBin;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSet = class _YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity.isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else
          pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value2) {
        if (typeof value2 !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value2}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value2) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value2) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value2 of iterable) {
            if (typeof replacer === "function")
              value2 = replacer.call(iterable, value2, value2);
            set2.items.push(Pair.createPair(value2, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set = {
      collection: "map",
      identify: (value2) => value2 instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
      resolve(map, onError2) {
        if (identity.isMap(map)) {
          if (map.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map);
          else
            onError2("Set items must all have null values");
        } else
          onError2("Expected a mapping for this tag");
        return map;
      }
    };
    exports.YAMLSet = YAMLSet;
    exports.set = set;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str, asBigInt) {
      const sign = str[0];
      const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
      const num = (n) => asBigInt ? BigInt(n) : Number(n);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value: value2 } = node;
      let num = (n) => n;
      if (typeof value2 === "bigint")
        num = (n) => BigInt(n);
      else if (isNaN(value2) || !isFinite(value2))
        return stringifyNumber.stringifyNumber(node);
      let sign = "";
      if (value2 < 0) {
        sign = "-";
        value2 *= num(-1);
      }
      const _60 = num(60);
      const parts = [value2 % _60];
      if (value2 < 60) {
        parts.unshift(0);
      } else {
        value2 = (value2 - parts[0]) / _60;
        parts.unshift(value2 % _60);
        if (value2 >= 60) {
          value2 = (value2 - parts[0]) / _60;
          parts.unshift(value2);
        }
      }
      return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value2) => typeof value2 === "bigint" || Number.isInteger(value2),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value2) => value2 instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({ value: value2 }) => value2?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
    };
    exports.floatTime = floatTime;
    exports.intTime = intTime;
    exports.timestamp = timestamp;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int = require_int2();
    var merge = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var set = require_set();
    var timestamp = require_timestamp();
    var schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      merge.merge,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports.schema = schema;
  }
});

// node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "node_modules/yaml/dist/schema/tags.js"(exports) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var merge = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set = require_set();
    var timestamp = require_timestamp();
    var schemas = /* @__PURE__ */ new Map([
      ["core", schema.schema],
      ["failsafe", [map.map, seq.seq, string.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema]
    ]);
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map.map,
      merge: merge.merge,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:merge": merge.merge,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName, addMergeTag) {
      const schemaTags = schemas.get(schemaName);
      if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
      }
      let tags = schemaTags;
      if (!tags) {
        if (Array.isArray(customTags))
          tags = [];
        else {
          const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      if (addMergeTag)
        tags = tags.concat(merge.merge);
      return tags.reduce((tags2, tag) => {
        const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
        if (!tagObj) {
          const tagName = JSON.stringify(tag);
          const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
        }
        if (!tags2.includes(tagObj))
          tags2.push(tagObj);
        return tags2;
      }, []);
    }
    exports.coreKnownTags = coreKnownTags;
    exports.getTags = getTags;
  }
});

// node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "node_modules/yaml/dist/schema/Schema.js"(exports) {
    "use strict";
    var identity = require_identity();
    var map = require_map();
    var seq = require_seq();
    var string = require_string();
    var tags = require_tags();
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class _Schema {
      constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name, merge);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, { value: map.map });
        Object.defineProperty(this, identity.SCALAR, { value: string.string });
        Object.defineProperty(this, identity.SEQ, { value: seq.seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    exports.Schema = Schema;
  }
});

// node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyDocument.js"(exports) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      const lines = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart)
          hasDirectives = true;
      }
      if (hasDirectives)
        lines.push("---");
      const ctx = stringify.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines.length !== 1)
          lines.unshift("");
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives)
            lines.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment)
          body += stringifyComment.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
          lines[lines.length - 1] = `--- ${body}`;
        } else
          lines.push(body);
      } else {
        lines.push(stringify.stringify(doc.contents, ctx));
      }
      if (doc.directives?.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes("\n")) {
            lines.push("...");
            lines.push(stringifyComment.indentComment(cs, ""));
          } else {
            lines.push(`... ${cs}`);
          }
        } else {
          lines.push("...");
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep)
          dc = dc.replace(/^\n+/, "");
        if (dc) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
            lines.push("");
          lines.push(stringifyComment.indentComment(commentString(dc), ""));
        }
      }
      return lines.join("\n") + "\n";
    }
    exports.stringifyDocument = stringifyDocument;
  }
});

// node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "node_modules/yaml/dist/doc/Document.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var Schema = require_Schema();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document = class _Document {
      constructor(value2, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          stringKeys: false,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version = this.directives.yaml.version;
        } else
          this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        this.contents = value2 === void 0 ? null : this.createNode(value2, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [identity.NODE_TYPE]: { value: identity.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value2) {
        if (assertCollection(this.contents))
          this.contents.add(value2);
      }
      /** Adds a value to the document. */
      addIn(path24, value2) {
        if (assertCollection(this.contents))
          this.contents.addIn(path24, value2);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name25) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name25 || prev.has(name25) ? anchors.findNewAnchor(name25 || "a", prev) : name25;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value2, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value2 = replacer.call({ "": value2 }, "", value2);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value2, tag, ctx);
        if (flow && identity.isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value2, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value2, null, options);
        return new Pair.Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path24) {
        if (Collection.isEmptyPath(path24)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path24) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path24, keepScalar) {
        if (Collection.isEmptyPath(path24))
          return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
        return identity.isCollection(this.contents) ? this.contents.getIn(path24, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path24) {
        if (Collection.isEmptyPath(path24))
          return this.contents !== void 0;
        return identity.isCollection(this.contents) ? this.contents.hasIn(path24) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value2) {
        if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, [key], value2);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value2);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path24, value2) {
        if (Collection.isEmptyPath(path24)) {
          this.contents = value2;
        } else if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path24), value2);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path24, value2);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version, options = {}) {
        if (typeof version === "number")
          version = String(version);
        let opt;
        switch (version) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new directives.Directives({ version: "1.1" });
            opt = { resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version;
            else
              this.directives = new directives.Directives({ version });
            opt = { resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json: json2, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json2,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    };
    function assertCollection(contents) {
      if (identity.isCollection(contents))
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports.Document = Document;
  }
});

// node_modules/yaml/dist/errors.js
var require_errors = __commonJS({
  "node_modules/yaml/dist/errors.js"(exports) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name25, pos, code, message) {
        super();
        this.name = name25;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    var prettifyError = (src, lc) => (error) => {
      if (error.pos[0] === -1)
        return;
      error.linePos = error.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end?.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports.YAMLError = YAMLError;
    exports.YAMLParseError = YAMLParseError;
    exports.YAMLWarning = YAMLWarning;
    exports.prettifyError = prettifyError;
  }
});

// node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "node_modules/yaml/dist/compose/resolve-props.js"(exports) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next, offset, onError: onError2, parentIndent, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment = "";
      let commentSep = "";
      let hasNewline = false;
      let reqSpace = false;
      let tab = null;
      let anchor = null;
      let tag = null;
      let newlineAfterProp = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token of tokens) {
        if (reqSpace) {
          if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
            onError2(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        if (tab) {
          if (atNewline && token.type !== "comment" && token.type !== "newline") {
            onError2(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          }
          tab = null;
        }
        switch (token.type) {
          case "space":
            if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
              tab = token;
            }
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError2(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token.source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment)
                comment += token.source;
              else if (!found || indicator !== "seq-item-ind")
                spaceBefore = true;
            } else
              commentSep += token.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag)
              newlineAfterProp = token;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError2(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            if (token.source.endsWith(":"))
              onError2(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
            anchor = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError2(token, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag)
              onError2(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
            if (found)
              onError2(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
            found = token;
            atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError2(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token;
              atNewline = false;
              hasSpace = false;
              break;
            }
          // else fallthrough
          default:
            onError2(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last = tokens[tokens.length - 1];
      const end = last ? last.offset + last.source.length : offset;
      if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
        onError2(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      }
      if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
        onError2(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end
      };
    }
    exports.resolveProps = resolveProps;
  }
});

// node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "node_modules/yaml/dist/compose/util-contains-newline.js"(exports) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n"))
            return true;
          if (key.end) {
            for (const st of key.end)
              if (st.type === "newline")
                return true;
          }
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start)
              if (st.type === "newline")
                return true;
            if (it.sep) {
              for (const st of it.sep)
                if (st.type === "newline")
                  return true;
            }
            if (containsNewline(it.key) || containsNewline(it.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports.containsNewline = containsNewline;
  }
});

// node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent, fc, onError2) {
      if (fc?.type === "flow-collection") {
        const end = fc.end[0];
        if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
          const msg = "Flow end indicator should be more indented than parent";
          onError2(end, "BAD_INDENT", msg, true);
        }
      }
    }
    exports.flowIndentCheck = flowIndentCheck;
  }
});

// node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "node_modules/yaml/dist/compose/util-map-includes.js"(exports) {
    "use strict";
    var identity = require_identity();
    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false)
        return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
      return items.some((pair) => isEqual(pair.key, search));
    }
    exports.mapIncludes = mapIncludes;
  }
});

// node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-map.js"(exports) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError2, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
      const map = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep, value: value2 } = collItem;
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? sep?.[0],
          offset,
          onError: onError2,
          parentIndent: bm.indent,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError2(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent)
              onError2(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map.comment)
                map.comment += "\n" + keyProps.comment;
              else
                map.comment = keyProps.comment;
            }
            continue;
          }
          if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
            onError2(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
          }
        } else if (keyProps.found?.indent !== bm.indent) {
          onError2(offset, "BAD_INDENT", startColMsg);
        }
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError2) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError2);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError2);
        ctx.atKey = false;
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
          onError2(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          indicator: "map-value-ind",
          next: value2,
          offset: keyNode.range[2],
          onError: onError2,
          parentIndent: bm.indent,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if (value2?.type === "block-map" && !valueProps.hasNewline)
              onError2(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError2(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value2 ? composeNode(ctx, value2, valueProps, onError2) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError2);
          if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, value2, onError2);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map.items.push(pair);
        } else {
          if (implicitKey)
            onError2(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset)
        onError2(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
      map.range = [bm.offset, offset, commentEnd ?? offset];
      return map;
    }
    exports.resolveBlockMap = resolveBlockMap;
  }
});

// node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-seq.js"(exports) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError2, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value: value2 } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value2,
          offset,
          onError: onError2,
          parentIndent: bs.indent,
          startOnNewline: true
        });
        if (!props.found) {
          if (props.anchor || props.tag || value2) {
            if (value2?.type === "block-seq")
              onError2(props.end, "BAD_INDENT", "All sequence items must start at the same column");
            else
              onError2(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            commentEnd = props.end;
            if (props.comment)
              seq.comment = props.comment;
            continue;
          }
        }
        const node = value2 ? composeNode(ctx, value2, props, onError2) : composeEmptyNode(ctx, props.end, start, null, props, onError2);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bs.indent, value2, onError2);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, commentEnd ?? offset];
      return seq;
    }
    exports.resolveBlockSeq = resolveBlockSeq;
  }
});

// node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "node_modules/yaml/dist/compose/resolve-end.js"(exports) {
    "use strict";
    function resolveEnd(end, offset, reqSpace, onError2) {
      let comment = "";
      if (end) {
        let hasSpace = false;
        let sep = "";
        for (const token of end) {
          const { source, type: type2 } = token;
          switch (type2) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError2(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source.substring(1) || " ";
              if (!comment)
                comment = cb;
              else
                comment += sep + cb;
              sep = "";
              break;
            }
            case "newline":
              if (comment)
                sep += source;
              hasSpace = true;
              break;
            default:
              onError2(token, "UNEXPECTED_TOKEN", `Unexpected ${type2} at node end`);
          }
          offset += source.length;
        }
      }
      return { comment, offset };
    }
    exports.resolveEnd = resolveEnd;
  }
});

// node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError2, tag) {
      const isMap = fc.start.source === "{";
      const fcName = isMap ? "flow map" : "flow sequence";
      const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value: value2 } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? sep?.[0],
          offset,
          onError: onError2,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep && !value2) {
            if (i === 0 && props.comma)
              onError2(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i < fc.items.length - 1)
              onError2(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment)
                coll.comment += "\n" + props.comment;
              else
                coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError2(
              key,
              // checked by containsNewline()
              "MULTILINE_IMPLICIT_KEY",
              "Implicit keys of flow sequence pairs need to be on a single line"
            );
        }
        if (i === 0) {
          if (props.comma)
            onError2(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma)
            onError2(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop: for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity.isPair(prev))
                prev = prev.value ?? prev.key;
              if (prev.comment)
                prev.comment += "\n" + prevItemComment;
              else
                prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap && !sep && !props.found) {
          const valueNode = value2 ? composeNode(ctx, value2, props, onError2) : composeEmptyNode(ctx, props.end, sep, null, props, onError2);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value2))
            onError2(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          ctx.atKey = true;
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError2) : composeEmptyNode(ctx, keyStart, start, null, props, onError2);
          if (isBlock(key))
            onError2(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          ctx.atKey = false;
          const valueProps = resolveProps.resolveProps(sep ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value2,
            offset: keyNode.range[2],
            onError: onError2,
            parentIndent: fc.indent,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep)
                for (const st of sep) {
                  if (st === valueProps.found)
                    break;
                  if (st.type === "newline") {
                    onError2(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError2(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value2) {
            if ("source" in value2 && value2.source?.[0] === ":")
              onError2(value2, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else
              onError2(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value2 ? composeNode(ctx, value2, valueProps, onError2) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError2) : null;
          if (valueNode) {
            if (isBlock(value2))
              onError2(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          if (isMap) {
            const map = coll;
            if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
              onError2(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map.items.push(pair);
          } else {
            const map = new YAMLMap.YAMLMap(ctx.schema);
            map.flow = true;
            map.items.push(pair);
            const endRange = (valueNode ?? keyNode).range;
            map.range = [keyNode.range[0], endRange[1], endRange[2]];
            coll.items.push(map);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce?.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        const name25 = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name25} must end with a ${expectedEnd}` : `${name25} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError2(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1)
          ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError2);
        if (end.comment) {
          if (coll.comment)
            coll.comment += "\n" + end.comment;
          else
            coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }
    exports.resolveFlowCollection = resolveFlowCollection;
  }
});

// node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "node_modules/yaml/dist/compose/compose-collection.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token, onError2, tagName, tag) {
      const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError2, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError2, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError2, tag);
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName)
        coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token, props, onError2) {
      const tagToken = props.tag;
      const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError2(tagToken, "TAG_RESOLVE_FAILED", msg));
      if (token.type === "block-seq") {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
          const message = "Missing newline after block sequence props";
          onError2(lastProp, "MISSING_CHAR", message);
        }
      }
      const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
        return resolveCollection(CN, ctx, token, onError2, tagName);
      }
      let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt?.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          if (kt) {
            onError2(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
          } else {
            onError2(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          }
          return resolveCollection(CN, ctx, token, onError2, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token, onError2, tagName, tag);
      const res = tag.resolve?.(coll, (msg) => onError2(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
      const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag?.format)
        node.format = tag.format;
      return node;
    }
    exports.composeCollection = composeCollection;
  }
});

// node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(ctx, scalar, onError2) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError2);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      const type2 = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines = scalar.source ? splitLines3(scalar.source) : [];
      let chompStart = lines.length;
      for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (chompStart === 0) {
        const value3 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
        let end2 = start + header.length;
        if (scalar.source)
          end2 += scalar.source.length;
        return { value: value3, type: type2, comment: header.comment, range: [start, end2, end2] };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent.length > trimIndent)
            trimIndent = indent.length;
        } else {
          if (indent.length < trimIndent) {
            const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError2(offset + indent.length, "MISSING_CHAR", message);
          }
          if (header.indent === 0)
            trimIndent = indent.length;
          contentStart = i;
          if (trimIndent === 0 && !ctx.atRoot) {
            const message = "Block scalar values in collections must be indented";
            onError2(offset, "BAD_INDENT", message);
          }
          break;
        }
        offset += indent.length + content.length + 1;
      }
      for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
          chompStart = i + 1;
      }
      let value2 = "";
      let sep = "";
      let prevMoreIndented = false;
      for (let i = 0; i < contentStart; ++i)
        value2 += lines[i][0].slice(trimIndent) + "\n";
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf)
          content = content.slice(0, -1);
        if (content && indent.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message = `Block scalar lines must not be less indented than their ${src}`;
          onError2(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
          indent = "";
        }
        if (type2 === Scalar.Scalar.BLOCK_LITERAL) {
          value2 += sep + indent.slice(trimIndent) + content;
          sep = "\n";
        } else if (indent.length > trimIndent || content[0] === "	") {
          if (sep === " ")
            sep = "\n";
          else if (!prevMoreIndented && sep === "\n")
            sep = "\n\n";
          value2 += sep + indent.slice(trimIndent) + content;
          sep = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep === "\n")
            value2 += "\n";
          else
            sep = "\n";
        } else {
          value2 += sep + content;
          sep = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines.length; ++i)
            value2 += "\n" + lines[i][0].slice(trimIndent);
          if (value2[value2.length - 1] !== "\n")
            value2 += "\n";
          break;
        default:
          value2 += "\n";
      }
      const end = start + header.length + scalar.source.length;
      return { value: value2, type: type2, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError2) {
      if (props[0].type !== "block-scalar-header") {
        onError2(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source } = props[0];
      const mode = source[0];
      let indent = 0;
      let chomp = "";
      let error = -1;
      for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          const n = Number(ch);
          if (!indent && n)
            indent = n;
          else if (error === -1)
            error = offset + i;
        }
      }
      if (error !== -1)
        onError2(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
      let hasSpace = false;
      let comment = "";
      let length = source.length;
      for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
          case "space":
            hasSpace = true;
          // fallthrough
          case "newline":
            length += token.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              const message = "Comments must be separated from other tokens by white space characters";
              onError2(token, "MISSING_CHAR", message);
            }
            length += token.source.length;
            comment = token.source.substring(1);
            break;
          case "error":
            onError2(token, "UNEXPECTED_TOKEN", token.message);
            length += token.source.length;
            break;
          /* istanbul ignore next should not happen */
          default: {
            const message = `Unexpected token in block scalar header: ${token.type}`;
            onError2(token, "UNEXPECTED_TOKEN", message);
            const ts = token.source;
            if (ts && typeof ts === "string")
              length += ts.length;
          }
        }
      }
      return { mode, indent, chomp, comment, length };
    }
    function splitLines3(source) {
      const split = source.split(/\n( *)/);
      const first = split[0];
      const m = first.match(/^( *)/);
      const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
      const lines = [line0];
      for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
      return lines;
    }
    exports.resolveBlockScalar = resolveBlockScalar;
  }
});

// node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError2) {
      const { offset, type: type2, source, end } = scalar;
      let _type;
      let value2;
      const _onError = (rel, code, msg) => onError2(offset + rel, code, msg);
      switch (type2) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value2 = plainValue(source, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value2 = singleQuotedValue(source, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value2 = doubleQuotedValue(source, _onError);
          break;
        /* istanbul ignore next should not happen */
        default:
          onError2(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type2}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source.length, offset + source.length]
          };
      }
      const valueEnd = offset + source.length;
      const re2 = resolveEnd.resolveEnd(end, valueEnd, strict, onError2);
      return {
        value: value2,
        type: _type,
        comment: re2.comment,
        range: [offset, valueEnd, re2.offset]
      };
    }
    function plainValue(source, onError2) {
      let badChar = "";
      switch (source[0]) {
        /* istanbul ignore next should not happen */
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source[0]}`;
          break;
        }
      }
      if (badChar)
        onError2(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source);
    }
    function singleQuotedValue(source, onError2) {
      if (source[source.length - 1] !== "'" || source.length === 1)
        onError2(source.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      let first, line;
      try {
        first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match = first.exec(source);
      if (!match)
        return source;
      let res = match[1];
      let sep = " ";
      let pos = first.lastIndex;
      line.lastIndex = pos;
      while (match = line.exec(source)) {
        if (match[1] === "") {
          if (sep === "\n")
            res += sep;
          else
            sep = "\n";
        } else {
          res += sep + match[1];
          sep = " ";
        }
        pos = line.lastIndex;
      }
      const last = /[ \t]*(.*)/sy;
      last.lastIndex = pos;
      match = last.exec(source);
      return res + sep + (match?.[1] ?? "");
    }
    function doubleQuotedValue(source, onError2) {
      let res = "";
      for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === "\r" && source[i + 1] === "\n")
          continue;
        if (ch === "\n") {
          const { fold, offset } = foldNewline(source, i);
          res += fold;
          i = offset;
        } else if (ch === "\\") {
          let next = source[++i];
          const cc = escapeCodes[next];
          if (cc)
            res += cc;
          else if (next === "\n") {
            next = source[i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "\r" && source[i + 1] === "\n") {
            next = source[++i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "x" || next === "u" || next === "U") {
            const length = { x: 2, u: 4, U: 8 }[next];
            res += parseCharCode(source, i + 1, length, onError2);
            i += length;
          } else {
            const raw = source.substr(i - 1, 2);
            onError2(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i;
          let next = source[i + 1];
          while (next === " " || next === "	")
            next = source[++i + 1];
          if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
            res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source[source.length - 1] !== '"' || source.length === 1)
        onError2(source.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source, offset) {
      let fold = "";
      let ch = source[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source[offset + 2] !== "\n")
          break;
        if (ch === "\n")
          fold += "\n";
        offset += 1;
        ch = source[offset + 1];
      }
      if (!fold)
        fold = " ";
      return { fold, offset };
    }
    var escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "\x85",
      // Unicode next line
      _: "\xA0",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source, offset, length, onError2) {
      const cc = source.substr(offset, length);
      const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError2(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }
    exports.resolveFlowScalar = resolveFlowScalar;
  }
});

// node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "node_modules/yaml/dist/compose/compose-scalar.js"(exports) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token, tagToken, onError2) {
      const { value: value2, type: type2, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError2) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError2);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError2(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      let tag;
      if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[identity.SCALAR];
      } else if (tagName)
        tag = findScalarTagByName(ctx.schema, value2, tagName, tagToken, onError2);
      else if (token.type === "scalar")
        tag = findScalarTagByTest(ctx, value2, token, onError2);
      else
        tag = ctx.schema[identity.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value2, (msg) => onError2(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError2(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar.Scalar(value2);
      }
      scalar.range = range;
      scalar.source = value2;
      if (type2)
        scalar.type = type2;
      if (tagName)
        scalar.tag = tagName;
      if (tag.format)
        scalar.format = tag.format;
      if (comment)
        scalar.comment = comment;
      return scalar;
    }
    function findScalarTagByName(schema, value2, tagName, tagToken, onError2) {
      if (tagName === "!")
        return schema[identity.SCALAR];
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
        }
      }
      for (const tag of matchWithTest)
        if (tag.test?.test(value2))
          return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
        return kt;
      }
      onError2(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema[identity.SCALAR];
    }
    function findScalarTagByTest({ atKey, directives, schema }, value2, token, onError2) {
      const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value2)) || schema[identity.SCALAR];
      if (schema.compat) {
        const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value2)) ?? schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError2(token, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }
    exports.composeScalar = composeScalar;
  }
});

// node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        pos ?? (pos = before.length);
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          st = before[++i];
          while (st?.type === "space") {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }
    exports.emptyScalarPosition = emptyScalarPosition;
  }
});

// node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "node_modules/yaml/dist/compose/compose-node.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token, props, onError2) {
      const atKey = ctx.atKey;
      const { spaceBefore, comment, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token.type) {
        case "alias":
          node = composeAlias(ctx, token, onError2);
          if (anchor || tag)
            onError2(token, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token, tag, onError2);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token, props, onError2);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
          onError2(token, "UNEXPECTED_TOKEN", message);
          node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError2);
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === "")
        onError2(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
        const msg = "With stringKeys, all keys must be strings";
        onError2(tag ?? token, "NON_STRING_KEY", msg);
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        if (token.type === "scalar" && token.source === "")
          node.comment = comment;
        else
          node.commentBefore = comment;
      }
      if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError2) {
      const token = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token, tag, onError2);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "")
          onError2(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        node.comment = comment;
        node.range[2] = end;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source, end }, onError2) {
      const alias = new Alias.Alias(source.substring(1));
      if (alias.source === "")
        onError2(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      if (alias.source.endsWith(":"))
        onError2(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
      const valueEnd = offset + source.length;
      const re2 = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError2);
      alias.range = [offset, valueEnd, re2.offset];
      if (re2.comment)
        alias.comment = re2.comment;
      return alias;
    }
    exports.composeEmptyNode = composeEmptyNode;
    exports.composeNode = composeNode;
  }
});

// node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "node_modules/yaml/dist/compose/compose-doc.js"(exports) {
    "use strict";
    var Document = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value: value2, end }, onError2) {
      const opts = Object.assign({ _directives: directives }, options);
      const doc = new Document.Document(void 0, opts);
      const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value2 ?? end?.[0],
        offset,
        onError: onError2,
        parentIndent: 0,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (value2 && (value2.type === "block-map" || value2.type === "block-seq") && !props.hasNewline)
          onError2(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value2 ? composeNode.composeNode(ctx, value2, props, onError2) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError2);
      const contentEnd = doc.contents.range[2];
      const re2 = resolveEnd.resolveEnd(end, contentEnd, false, onError2);
      if (re2.comment)
        doc.comment = re2.comment;
      doc.range = [offset, contentEnd, re2.offset];
      return doc;
    }
    exports.composeDoc = composeDoc;
  }
});

// node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "node_modules/yaml/dist/compose/composer.js"(exports) {
    "use strict";
    var node_process = __require("process");
    var directives = require_directives();
    var Document = require_Document();
    var errors = require_errors();
    var identity = require_identity();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source } = src;
      return [offset, offset + (typeof source === "string" ? source.length : 1)];
    }
    function parsePrelude(prelude) {
      let comment = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
          case "#":
            comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (prelude[i + 1]?.[0] !== "#")
              i += 1;
            atComment = false;
            break;
          default:
            if (!atComment)
              afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment, afterEmptyLine };
    }
    var Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new errors.YAMLWarning(pos, code, message));
          else
            this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        this.directives = new directives.Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (identity.isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        if (node_process.env.LOG_STREAM)
          console.dir(token, { depth: null });
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error);
            else
              this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document.Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports.Composer = Composer;
  }
});

// node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "node_modules/yaml/dist/parse/cst-scalar.js"(exports) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token, strict = true, onError2) {
      if (token) {
        const _onError = (pos, code, message) => {
          const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError2)
            onError2(offset, code, message);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value2, context2) {
      const { implicitKey = false, indent, inFlow = false, offset = -1, type: type2 = "PLAIN" } = context2;
      const source = stringifyString.stringifyString({ type: type2, value: value2 }, {
        implicitKey,
        indent: indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      const end = context2.end ?? [
        { type: "newline", offset: -1, indent, source: "\n" }
      ];
      switch (source[0]) {
        case "|":
        case ">": {
          const he = source.indexOf("\n");
          const head = source.substring(0, he);
          const body = source.substring(he + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent, source: head }
          ];
          if (!addEndtoBlockProps(props, end))
            props.push({ type: "newline", offset: -1, indent, source: "\n" });
          return { type: "block-scalar", offset, indent, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent, source, end };
        case "'":
          return { type: "single-quoted-scalar", offset, indent, source, end };
        default:
          return { type: "scalar", offset, indent, source, end };
      }
    }
    function setScalarValue(token, value2, context2 = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type: type2 } = context2;
      let indent = "indent" in token ? token.indent : null;
      if (afterKey && typeof indent === "number")
        indent += 2;
      if (!type2)
        switch (token.type) {
          case "single-quoted-scalar":
            type2 = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type2 = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type2 = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type2 = "PLAIN";
        }
      const source = stringifyString.stringifyString({ type: type2, value: value2 }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      switch (source[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token, source);
          break;
        case '"':
          setFlowScalarValue(token, source, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token, source, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token, source, "scalar");
      }
    }
    function setBlockScalarValue(token, source) {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      if (token.type === "block-scalar") {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head;
        token.source = body;
      } else {
        const { offset } = token;
        const indent = "indent" in token ? token.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
          props.push({ type: "newline", offset: -1, indent, source: "\n" });
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type: "block-scalar", indent, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end) {
      if (end)
        for (const st of end)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token, source, type2) {
      switch (token.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token.type = type2;
          token.source = source;
          break;
        case "block-scalar": {
          const end = token.props.slice(1);
          let oa = source.length;
          if (token.props[0].type === "block-scalar-header")
            oa -= token.props[0].source.length;
          for (const tok of end)
            tok.offset += oa;
          delete token.props;
          Object.assign(token, { type: type2, source, end });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token.offset + source.length;
          const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
          delete token.items;
          Object.assign(token, { type: type2, source, end: [nl] });
          break;
        }
        default: {
          const indent = "indent" in token ? token.indent : -1;
          const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (const key of Object.keys(token))
            if (key !== "type" && key !== "offset")
              delete token[key];
          Object.assign(token, { type: type2, indent, source, end });
        }
      }
    }
    exports.createScalarToken = createScalarToken;
    exports.resolveAsScalar = resolveAsScalar;
    exports.setScalarValue = setScalarValue;
  }
});

// node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "node_modules/yaml/dist/parse/cst-stringify.js"(exports) {
    "use strict";
    var stringify = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token) {
      switch (token.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token.props)
            res += stringifyToken(tok);
          return res + token.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token.start.source;
          for (const item of token.items)
            res += stringifyItem(item);
          for (const st of token.end)
            res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token);
          if (token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
        default: {
          let res = token.source;
          if ("end" in token && token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep, value: value2 }) {
      let res = "";
      for (const st of start)
        res += st.source;
      if (key)
        res += stringifyToken(key);
      if (sep)
        for (const st of sep)
          res += st.source;
      if (value2)
        res += stringifyToken(value2);
      return res;
    }
    exports.stringify = stringify;
  }
});

// node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "node_modules/yaml/dist/parse/cst-visit.js"(exports) {
    "use strict";
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove item");
    function visit2(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit2.BREAK = BREAK;
    visit2.SKIP = SKIP;
    visit2.REMOVE = REMOVE;
    visit2.itemAtPath = (cst, path24) => {
      let item = cst;
      for (const [field, index] of path24) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index];
        } else
          return void 0;
      }
      return item;
    };
    visit2.parentCollection = (cst, path24) => {
      const parent = visit2.itemAtPath(cst, path24.slice(0, -1));
      const field = path24[path24.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path24, item, visitor) {
      let ctrl = visitor(item, path24);
      if (typeof ctrl === "symbol")
        return ctrl;
      for (const field of ["key", "value"]) {
        const token = item[field];
        if (token && "items" in token) {
          for (let i = 0; i < token.items.length; ++i) {
            const ci = _visit(Object.freeze(path24.concat([[field, i]])), token.items[i], visitor);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              token.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path24);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path24) : ctrl;
    }
    exports.visit = visit2;
  }
});

// node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "node_modules/yaml/dist/parse/cst.js"(exports) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token) => !!token && "items" in token;
    var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token);
      }
    }
    function tokenType(source) {
      switch (source) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports.createScalarToken = cstScalar.createScalarToken;
    exports.resolveAsScalar = cstScalar.resolveAsScalar;
    exports.setScalarValue = cstScalar.setScalarValue;
    exports.stringify = cstStringify.stringify;
    exports.visit = cstVisit.visit;
    exports.BOM = BOM;
    exports.DOCUMENT = DOCUMENT;
    exports.FLOW_END = FLOW_END;
    exports.SCALAR = SCALAR;
    exports.isCollection = isCollection;
    exports.isScalar = isScalar;
    exports.prettyToken = prettyToken;
    exports.tokenType = tokenType;
  }
});

// node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "node_modules/yaml/dist/parse/lexer.js"(exports) {
    "use strict";
    var cst = require_cst();
    function isEmpty(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var hexDigits = new Set("0123456789ABCDEFabcdef");
    var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    var flowIndicatorChars = new Set(",[]{}");
    var invalidAnchorChars = new Set(" ,[]{}\n\r	");
    var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    var Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          if (typeof source !== "string")
            throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === cst.BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          let cs = line.indexOf("#");
          while (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s === "---" ? "doc" : "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case "#":
            yield* this.pushCount(line.length - n);
          // fallthrough
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          // fallthrough
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case "\n":
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === "\n")
                break;
            }
            // fallthrough
            default:
              break loop;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === " ")
          ch = this.buffer[++i];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
            ch = this.buffer[++i];
          nl = i - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " ")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next = this.buffer[i + 1];
            if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
              break;
            end = i;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i += 1;
                ch = "\n";
                next = this.buffer[i + 1];
              } else
                end = i;
            }
            if (next === "#" || inFlow && flowIndicatorChars.has(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch))
              break;
            end = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          // this is an error
          case "?":
          // this is an error outside flow collections
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.has(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    exports.Lexer = Lexer;
  }
});

// node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "node_modules/yaml/dist/parse/line-counter.js"(exports) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports.LineCounter = LineCounter;
  }
});

// node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "node_modules/yaml/dist/parse/parser.js"(exports) {
    "use strict";
    var node_process = __require("process");
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list, type2) {
      for (let i = 0; i < list.length; ++i)
        if (list[i].type === type2)
          return true;
      return false;
    }
    function findNonEmptyIndex(list) {
      for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i;
        }
      }
      return -1;
    }
    function isFlowToken(token) {
      switch (token?.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      if (prev.length === 0)
        return [];
      let i = prev.length;
      loop: while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
      while (prev[++i]?.type === "space") {
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
            if (it.key)
              it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end)
                Array.prototype.push.apply(it.value.end, it.sep);
              else
                it.value.end = it.sep;
            } else
              Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    var Parser = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (node_process.env.LOG_TOKENS)
          console.log("|", cst.prettyToken(source));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type2 = cst.tokenType(source);
        if (!type2) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type2 === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type2;
          yield* this.step();
          switch (type2) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && top?.type !== "doc-end") {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error) {
        const token = error ?? this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            /* istanbul ignore next should not happen */
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep;
          if (scalar.end) {
            sep = scalar.end;
            sep.push(this.sourceToken);
            delete scalar.end;
          } else
            sep = [this.sourceToken];
          const map = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          /* istanbul ignore next should not happen */
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map) {
        const it = map.items[map.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map.indent)) {
                const prev = map.items[map.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({ start, explicitKey: true });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep = it.sep;
                  sep.push(this.sourceToken);
                  delete it.key;
                  delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs15 = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map.items.push({ start, key: fs15, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs15);
              } else {
                Object.assign(it, { key: fs15, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map);
              if (bv) {
                if (bv.type === "block-seq") {
                  if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                    yield* this.pop({
                      type: "error",
                      offset: this.offset,
                      message: "Unexpected block-seq-ind on same line with key",
                      source: this.source
                    });
                    return;
                  }
                } else if (atMapIndent) {
                  map.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                seq.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top?.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs15 = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs15, sep: [] });
              else if (it.sep)
                this.stack.push(fs15);
              else
                Object.assign(it, { key: fs15, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep = fc.end.splice(1, fc.end.length);
            sep.push(this.sourceToken);
            const map = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type2) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type: type2,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, explicitKey: true }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          // fallthrough
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    exports.Parser = Parser;
  }
});

// node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "node_modules/yaml/dist/public-api.js"(exports) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var errors = require_errors();
    var log2 = require_log();
    var identity = require_identity();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    function parseAllDocuments(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source)));
      if (prettyErrors && lineCounter2)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source, lineCounter2));
          doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
        }
      if (docs.length > 0)
        return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    function parseDocument(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
      return doc;
    }
    function parse3(src, reviver, options) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options === void 0 && reviver && typeof reviver === "object") {
        options = reviver;
      }
      const doc = parseDocument(src, options);
      if (!doc)
        return null;
      doc.warnings.forEach((warning) => log2.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        else
          doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify(value2, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
      }
      if (typeof options === "string")
        options = options.length;
      if (typeof options === "number") {
        const indent = Math.round(options);
        options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
      }
      if (value2 === void 0) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
          return void 0;
      }
      if (identity.isDocument(value2) && !_replacer)
        return value2.toString(options);
      return new Document.Document(value2, _replacer, options).toString(options);
    }
    exports.parse = parse3;
    exports.parseAllDocuments = parseAllDocuments;
    exports.parseDocument = parseDocument;
    exports.stringify = stringify;
  }
});

// node_modules/yaml/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/yaml/dist/index.js"(exports) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var Schema = require_Schema();
    var errors = require_errors();
    var Alias = require_Alias();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    var publicApi = require_public_api();
    var visit2 = require_visit();
    exports.Composer = composer.Composer;
    exports.Document = Document.Document;
    exports.Schema = Schema.Schema;
    exports.YAMLError = errors.YAMLError;
    exports.YAMLParseError = errors.YAMLParseError;
    exports.YAMLWarning = errors.YAMLWarning;
    exports.Alias = Alias.Alias;
    exports.isAlias = identity.isAlias;
    exports.isCollection = identity.isCollection;
    exports.isDocument = identity.isDocument;
    exports.isMap = identity.isMap;
    exports.isNode = identity.isNode;
    exports.isPair = identity.isPair;
    exports.isScalar = identity.isScalar;
    exports.isSeq = identity.isSeq;
    exports.Pair = Pair.Pair;
    exports.Scalar = Scalar.Scalar;
    exports.YAMLMap = YAMLMap.YAMLMap;
    exports.YAMLSeq = YAMLSeq.YAMLSeq;
    exports.CST = cst;
    exports.Lexer = lexer.Lexer;
    exports.LineCounter = lineCounter.LineCounter;
    exports.Parser = parser.Parser;
    exports.parse = publicApi.parse;
    exports.parseAllDocuments = publicApi.parseAllDocuments;
    exports.parseDocument = publicApi.parseDocument;
    exports.stringify = publicApi.stringify;
    exports.visit = visit2.visit;
    exports.visitAsync = visit2.visitAsync;
  }
});

// node_modules/trpc-cli/dist/index.js
import { Argument as Argument2, Command as BaseCommand, InvalidArgumentError, InvalidOptionArgumentError } from "commander";
import { Option as BaseOption } from "commander";
import { inspect as inspect2 } from "util";

// node_modules/trpc-cli/dist/completions.js
function addCompletions(program, completion) {
  const commandSymbol = Symbol("command");
  const cTree = {};
  function addCommandCompletions(command, cTreeNode) {
    command.commands.forEach((c) => {
      const node = cTreeNode[c.name()] ||= {};
      Object.defineProperty(node, commandSymbol, { value: c, enumerable: false });
      addCommandCompletions(c, node);
    });
  }
  addCommandCompletions(program, cTree);
  completion.on("complete", (fragment, params) => {
    const segments = params.line.split(/ +/).slice(1, params.fragment);
    const last = segments.at(-1);
    let node = cTree;
    const existingFlags = /* @__PURE__ */ new Set();
    for (const segment of segments) {
      if (segment.startsWith("-")) {
        existingFlags.add(segment);
        continue;
      }
      if (existingFlags.size > 0)
        continue;
      node = node[segment];
      if (!node)
        return;
    }
    const correspondingCommand = node[commandSymbol];
    if (correspondingCommand?.options?.length) {
      const suggestions = [];
      for (const o of correspondingCommand.options) {
        if (last === o.long || last === o.short) {
          if (o.argChoices)
            suggestions.push(...o.argChoices);
          if (!o.isBoolean())
            break;
        }
        if (existingFlags.has(o.long))
          continue;
        if (existingFlags.has(o.short))
          continue;
        suggestions.push(o.long);
      }
      return void params.reply(suggestions);
    }
  });
  completion.tree(cTree).init();
}

// node_modules/trpc-cli/dist/errors.js
var CliValidationError = class extends Error {
};
var FailedToExitError = class extends Error {
  exitCode;
  constructor(message, { exitCode, cause }) {
    const fullMessage = `${message}. The process was expected to exit with exit code ${exitCode} but did not. This may be because a custom \`process\` parameter was used. The exit reason is in the \`cause\` property.`;
    super(fullMessage, { cause });
    this.exitCode = exitCode;
  }
};

// node_modules/trpc-cli/dist/json-schema.js
var capitaliseFromCamelCase = (camel) => {
  const parts = camel.split(/(?=[A-Z])/);
  return capitalise(parts.map((p) => p.toLowerCase()).join(" "));
};
var capitalise = (s) => s.slice(0, 1).toUpperCase() + s.slice(1);
var flattenedProperties = (sch) => {
  if ("properties" in sch) {
    return sch.properties;
  }
  if ("allOf" in sch) {
    return Object.fromEntries(sch.allOf.flatMap((subSchema) => Object.entries(flattenedProperties(subSchema))));
  }
  if ("anyOf" in sch) {
    const isExcluded = (v) => Object.keys(v).join(",") === "not";
    const entries = sch.anyOf.flatMap((subSchema) => {
      const flattened = flattenedProperties(subSchema);
      const excluded = Object.entries(flattened).flatMap(([name25, propSchema]) => {
        return isExcluded(propSchema) ? [`--${name25}`] : [];
      });
      return Object.entries(flattened).map(([k, v]) => {
        if (!isExcluded(v) && excluded.length > 0) {
          return [k, Object.assign({}, v, { "Do not use with": excluded })];
        }
        return [k, v];
      });
    });
    return Object.fromEntries(entries.sort((a, b) => {
      const scores = [a, b].map(([_k, v]) => isExcluded(v) ? 0 : 1);
      return scores[0] - scores[1];
    }));
  }
  return {};
};
var incompatiblePropertyPairs = (sch) => {
  const isUnion = "anyOf" in sch;
  if (!isUnion)
    return [];
  const sets = sch.anyOf.map((subSchema) => {
    const keys = Object.keys(flattenedProperties(subSchema));
    return { keys, set: new Set(keys) };
  });
  const compatiblityEntries = sets.flatMap(({ keys }) => {
    return keys.map((key) => {
      return [key, new Set(sets.filter((other) => other.set.has(key)).flatMap((other) => other.keys))];
    });
  });
  const allKeys = sets.flatMap(({ keys }) => keys);
  return compatiblityEntries.flatMap(([key, compatibleWith]) => {
    const incompatibleEntries = allKeys.filter((other) => key < other && !compatibleWith.has(other)).map((other) => [key, other]);
    return incompatibleEntries;
  });
};
var getDescription = (v, depth = 0) => {
  if ("items" in v && v.items) {
    const { items, ...rest } = v;
    return [getDescription(items, 1), getDescription(rest), "array"].filter(Boolean).join(" ");
  }
  return Object.entries(v).filter(([k, vv]) => {
    if (k === "default" || k === "additionalProperties" || k === "optional")
      return false;
    if (k === "type" && typeof vv === "string")
      return depth > 0;
    if (k.startsWith("$"))
      return false;
    if (k === "maximum" && vv === Number.MAX_SAFE_INTEGER)
      return false;
    if (depth <= 1 && k === "enum" && getEnumChoices(v)?.type === "string_enum")
      return false;
    return true;
  }).sort(([a], [b]) => {
    const scores = [a, b].map((k) => k === "description" ? 0 : 1);
    return scores[0] - scores[1];
  }).map(([k, vv], i) => {
    if (k === "type" && Array.isArray(vv))
      return `type: ${vv.join(" or ")}`;
    if (k === "description" && i === 0)
      return String(vv);
    if (k === "properties")
      return `Object (json formatted)`;
    if (typeof vv === "object")
      return `${capitaliseFromCamelCase(k)}: ${JSON.stringify(vv)}`;
    return `${capitaliseFromCamelCase(k)}: ${vv}`;
  }).join("; ") || "";
};
var getSchemaTypes = (propertyValue) => {
  const array2 = [];
  if ("type" in propertyValue) {
    array2.push(...[propertyValue.type].flat());
  }
  if ("enum" in propertyValue && Array.isArray(propertyValue.enum)) {
    array2.push(...propertyValue.enum.flatMap((s) => typeof s));
  }
  if ("const" in propertyValue && propertyValue.const === null) {
    array2.push("null");
  } else if ("const" in propertyValue) {
    array2.push(typeof propertyValue.const);
  }
  if ("oneOf" in propertyValue) {
    array2.push(...propertyValue.oneOf.flatMap(getSchemaTypes));
  }
  if ("anyOf" in propertyValue) {
    array2.push(...propertyValue.anyOf.flatMap(getSchemaTypes));
  }
  return [...new Set(array2)];
};
var getAllowedSchemas = (schema) => {
  if (!schema)
    return [];
  if ("anyOf" in schema && Array.isArray(schema.anyOf))
    return schema.anyOf.flatMap(getAllowedSchemas);
  if ("oneOf" in schema && Array.isArray(schema.oneOf))
    return schema.oneOf.flatMap(getAllowedSchemas);
  const types = getSchemaTypes(schema);
  if (types.length === 1)
    return [schema];
  return types.map((type2) => ({ ...schema, type: type2 }));
};
var getEnumChoices = (propertyValue) => {
  if (!propertyValue)
    return null;
  if (!("enum" in propertyValue && Array.isArray(propertyValue.enum))) {
    if ("anyOf" in propertyValue && propertyValue.anyOf?.every((subSchema) => {
      if (subSchema && typeof subSchema === "object" && "const" in subSchema && Object.keys(subSchema).length === 1 && typeof subSchema.const === "string") {
        return true;
      }
      return false;
    })) {
      return {
        type: "string_enum",
        choices: propertyValue.anyOf.map((subSchema) => subSchema.const)
      };
    }
    if ("anyOf" in propertyValue && propertyValue.anyOf?.every((subSchema) => {
      if (subSchema && typeof subSchema === "object" && "const" in subSchema && Object.keys(subSchema).length === 1 && typeof subSchema.const === "number") {
        return true;
      }
      return false;
    })) {
      return {
        type: "number_enum",
        choices: propertyValue.anyOf.map((subSchema) => subSchema.const)
      };
    }
    return null;
  }
  if (propertyValue.enum.every((s) => typeof s === "string")) {
    return {
      type: "string_enum",
      choices: propertyValue.enum
    };
  }
  if (propertyValue.enum.every((s) => typeof s === "number")) {
    return {
      type: "number_enum",
      choices: propertyValue.enum
    };
  }
  return null;
};

// node_modules/trpc-cli/dist/json.js
var commandToJSON = (command) => {
  const json2 = {};
  const name25 = command.name();
  if (name25)
    json2.name = name25;
  const version = command.version();
  if (version)
    json2.version = version;
  const description = command.description();
  if (description)
    json2.description = description;
  const usage = command.usage();
  if (usage)
    json2.usage = usage;
  json2.arguments = command.registeredArguments.map((arg) => {
    const result = { name: arg.name() };
    result.variadic = arg.variadic;
    result.required = arg.required;
    if (arg.description)
      result.description = arg.description;
    if (arg.defaultValue)
      result.defaultValue = arg.defaultValue;
    if (arg.defaultValueDescription)
      result.defaultValueDescription = arg.defaultValueDescription;
    if (arg.argChoices)
      result.choices = arg.argChoices;
    return result;
  });
  json2.options = command.options.map((o) => {
    const result = { name: o.name() };
    result.required = o.required;
    result.optional = o.optional;
    result.negate = o.negate;
    result.variadic = o.variadic;
    if (o.flags)
      result.flags = o.flags;
    if (o.short)
      result.short = o.short;
    if (o.description)
      result.description = o.description;
    if (o.argChoices)
      result.choices = o.argChoices;
    const attributeName = o.attributeName();
    if (attributeName)
      result.attributeName = attributeName;
    if (o.defaultValue)
      result.defaultValue = o.defaultValue;
    if (o.defaultValueDescription)
      result.defaultValueDescription = o.defaultValueDescription;
    return result;
  });
  json2.commands = command.commands.map((c) => commandToJSON(c));
  return json2;
};

// node_modules/trpc-cli/dist/logging.js
var lineByLineLogger = getLoggerTransformer((log2) => {
  const wrapper = (args2, depth) => {
    if (args2.length === 1 && Array.isArray(args2[0]) && depth === 0) {
      args2[0].forEach((item) => wrapper([item], 1));
    } else if (args2.every(isPrimitive)) {
      log2(...args2);
    } else if (args2.length === 1) {
      log2(JSON.stringify(args2[0], null, 2));
    } else {
      log2(JSON.stringify(args2, null, 2));
    }
  };
  return (...args2) => wrapper(args2, 0);
});
var isPrimitive = (value2) => {
  const type2 = typeof value2;
  return type2 === "string" || type2 === "number" || type2 === "boolean";
};
function getLoggerTransformer(transform) {
  return (logger) => {
    const info = logger.info && transform(logger.info);
    const error = logger.error && transform(logger.error);
    return { info, error };
  };
}
var lineByLineConsoleLogger = lineByLineLogger(console);

// node_modules/trpc-cli/dist/parse-procedure.js
import { inspect } from "util";

// node_modules/trpc-cli/dist/zod-to-json-schema/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions,
  name: options
} : {
  ...defaultOptions,
  ...options
};

// node_modules/trpc-cli/dist/zod-to-json-schema/Refs.js
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name25, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name25],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};

// node_modules/trpc-cli/dist/zod-to-json-schema/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key, value2, errorMessage, refs) {
  res[key] = value2;
  addErrorMessage(res, key, errorMessage, refs);
}

// node_modules/trpc-cli/dist/zod-to-json-schema/getRelativePath.js
var getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};

// node_modules/trpc-cli/dist/zod-to-json-schema/ZodFirstPartyTypeKind.js
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind5) {
  ZodFirstPartyTypeKind5["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind5["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind5["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind5["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind5["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind5["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind5["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind5["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind5["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind5["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind5["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind5["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind5["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind5["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind5["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind5["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind5["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind5["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind5["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind5["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind5["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind5["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind5["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind5["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind5["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind5["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind5["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind5["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind5["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind5["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind5["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind5["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind5["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind5["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind5["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind5["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/any.js
function parseAnyDef(refs) {
  if (refs.target !== "openAi") {
    return {};
  }
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref: refs.$refStrategy === "relative" ? getRelativePath(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
  };
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/array.js
function parseArrayDef(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/bigint.js
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/boolean.js
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/branded.js
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/catch.js
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
var integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors(
          res,
          "minimum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors(
          res,
          "maximum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
    }
  }
  return res;
};

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/default.js
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/effects.js
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef(refs);
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/enum.js
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/intersection.js
var isJsonSchema7AllOfType = (type2) => {
  if ("type" in type2 && type2.type === "string")
    return false;
  return "allOf" in type2;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/literal.js
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/string.js
var emojiRegex = void 0;
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex === void 0) {
      emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat(schema, value2, message, refs) {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value2,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value2, message, refs);
  }
}
function addPattern(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
  }
}
function stringifyRegExpWithFlags(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex.source;
  }
  return pattern;
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/record.js
function parseRecordDef(def, refs) {
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? parseAnyDef(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type: type2, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type: type2, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef(refs);
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
  const object2 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object2[object2[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object2[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/never.js
function parseNeverDef(refs) {
  return refs.target === "openAi" ? void 0 : {
    not: parseAnyDef({
      ...refs,
      currentPath: [...refs.currentPath, "not"]
    })
  };
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/null.js
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/union.js
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type2 = primitiveMappings[x._def.typeName];
      return type2 && !types2.includes(type2) ? [...types2, type2] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type2 = typeof x._def.value;
      switch (type2) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type2];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/nullable.js
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/number.js
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/object.js
function parseObjectDef(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    let propOptional = safeIsOptional(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/optional.js
var parseOptionalDef = (def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: parseAnyDef(refs)
      },
      innerSchema
    ]
  } : parseAnyDef(refs);
};

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/pipeline.js
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/promise.js
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/set.js
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/tuple.js
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/undefined.js
function parseUndefinedDef(refs) {
  return {
    not: parseAnyDef(refs)
  };
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/unknown.js
function parseUnknownDef(refs) {
  return parseAnyDef(refs);
}

// node_modules/trpc-cli/dist/zod-to-json-schema/parsers/readonly.js
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/trpc-cli/dist/zod-to-json-schema/selectParser.js
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef(refs);
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef(refs);
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef(refs);
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef(refs);
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
};

// node_modules/trpc-cli/dist/zod-to-json-schema/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema3 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema3) {
    addMeta(def, refs, jsonSchema3);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema3, def, refs);
    newItem.jsonSchema = jsonSchema3;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema3;
  return jsonSchema3;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value2, index) => refs.currentPath[index] === value2)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef(refs) : void 0;
    }
  }
};
var addMeta = (def, refs, jsonSchema3) => {
  if (def.description) {
    jsonSchema3.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema3.markdownDescription = def.description;
    }
  }
  return jsonSchema3;
};

// node_modules/trpc-cli/dist/zod-to-json-schema/zodToJsonSchema.js
var zodToJsonSchema = (schema, options) => {
  const refs = getRefs(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name26, schema2]) => ({
    ...acc,
    [name26]: parseDef(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name26]
    }, true) ?? parseAnyDef(refs)
  }), {}) : void 0;
  const name25 = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
  const main = parseDef(schema._def, name25 === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name25]
  }, false) ?? parseAnyDef(refs);
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) {
      definitions = {};
    }
    if (!definitions[refs.openAiAnyTypeName]) {
      definitions[refs.openAiAnyTypeName] = {
        // Skipping "object" as no properties can be defined and additionalProperties must be "false"
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/")
        }
      };
    }
  }
  const combined = name25 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name25
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name25]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
};

// node_modules/trpc-cli/dist/parse-procedure.js
var [valibotOrError, valibotToJsonSchemaOrError, effectOrError, zod4CoreOrError] = await Promise.all([
  import("valibot").catch(String),
  import("@valibot/to-json-schema").catch(String),
  import("effect").catch(String),
  import("zod/v4/core").catch(String)
]);
var getModule = (moduleOrError) => {
  if (typeof moduleOrError === "string") {
    throw new Error(`${moduleOrError} - try installing it and re-running`);
  }
  return moduleOrError;
};
function toJsonSchema(input, dependencies) {
  try {
    const jsonSchemaConverters = getJsonSchemaConverters(dependencies);
    const vendor = getVendor(input);
    if (vendor && vendor in jsonSchemaConverters) {
      const converter = jsonSchemaConverters[vendor];
      const converted = converter(input);
      return { success: true, value: converted };
    }
    return { success: false, error: `Schema not convertible to JSON schema` };
  } catch (e) {
    const message = e instanceof Error ? e.message : String(e);
    return { success: false, error: `Failed to convert input to JSON Schema: ${message}` };
  }
}
function looksLikeJsonSchema(value2) {
  return typeof value2 === "object" && value2 !== null && ("type" in value2 && (typeof value2.type === "string" || Array.isArray(value2.type)) || "const" in value2 || "oneOf" in value2 || "anyOf" in value2);
}
function parseProcedureInputs(inputs, dependencies) {
  const inner = parseProcedureInputsInner(inputs, dependencies);
  if (inner.success && inner.value.positionalParameters.some((param, i, { length }) => param.array && i < length - 1)) {
    return { success: false, error: `Array positional parameters must be at the end of the input.` };
  }
  if (inner.success) {
    const optionsProps = schemaDefPropValue(inner.value.optionsJsonSchema, "properties");
    if (optionsProps) {
      const optionishPositionals = Object.entries(optionsProps).flatMap(([key, schema]) => {
        if (typeof schema === "object" && "positional" in schema && schema.positional === true) {
          return [{ key, schema }];
        }
        return [];
      });
      if (optionishPositionals.length > 0) {
        return {
          success: true,
          value: {
            positionalParameters: [
              ...inner.value.positionalParameters,
              ...optionishPositionals.map(({ key, schema }) => ({
                name: key,
                array: looksLikeArray(schema),
                description: schema.description ?? "",
                required: !isOptional(schema),
                type: getSchemaTypes(schema).join(" | ")
              }))
            ],
            optionsJsonSchema: {
              ...inner.value.optionsJsonSchema,
              properties: Object.fromEntries(Object.entries(optionsProps).filter(([key]) => !optionishPositionals.some((x) => x.key === key)))
            },
            getPojoInput: (params) => {
              const positionalValues = [...params.positionalValues];
              const options = { ...params.options };
              for (const { key, schema } of optionishPositionals) {
                options[key] = convertPositional(schema, positionalValues.shift());
              }
              return inner.value.getPojoInput({ positionalValues, options });
            }
          }
        };
      }
    }
  }
  return inner;
}
function parseProcedureInputsInner(inputs, dependencies) {
  if (inputs.length === 0) {
    return {
      success: true,
      value: {
        positionalParameters: [],
        optionsJsonSchema: {},
        getPojoInput: () => ({})
      }
    };
  }
  const allJsonSchemaable = inputs.every((input) => looksJsonSchemaable(input));
  if (!allJsonSchemaable) {
    return {
      success: false,
      error: `Invalid input type ${inputs.map((s) => s?.constructor.name).join(", ")}, only inputs that can be converted to JSON Schema are supported`
    };
  }
  if (inputs.length > 1) {
    return parseMultiInputs(inputs, dependencies);
  }
  const mergedSchemaResult = toJsonSchema(inputs[0], dependencies);
  if (!mergedSchemaResult.success) {
    return {
      success: false,
      error: mergedSchemaResult.error
    };
  }
  const mergedSchema = mergedSchemaResult.value;
  return handleMergedSchema(mergedSchema);
}
function handleMergedSchema(mergedSchema) {
  if (mergedSchema.additionalProperties) {
    return { success: false, error: `Inputs with additional properties are not currently supported` };
  }
  if (acceptedPrimitiveTypes(mergedSchema).length > 0) {
    return parsePrimitiveInput(mergedSchema);
  }
  if (isTuple(mergedSchema)) {
    return parseTupleInput(mergedSchema);
  }
  if (mergedSchema.type === "array") {
    return parseArrayInput(mergedSchema);
  }
  if (mergedSchema.anyOf) {
    const allObjects = mergedSchema.anyOf.every((sub) => acceptsObject(toRoughJsonSchema7(sub)));
    if (allObjects) {
      return {
        success: true,
        value: {
          positionalParameters: [],
          optionsJsonSchema: mergedSchema,
          getPojoInput: (argv) => argv.options
        }
      };
    }
    if (mergedSchema.anyOf.length === 2 && JSON.stringify(mergedSchema.anyOf[0]) === '{"not":{}}') {
      return handleMergedSchema(mergedSchema.anyOf[1]);
    }
  }
  if (mergedSchema.type !== "object") {
    return {
      success: false,
      error: `Invalid input type ${inspect(mergedSchema, { depth: 2, breakLength: Infinity })}, expected object or tuple.`
    };
  }
  return {
    success: true,
    value: {
      positionalParameters: [],
      optionsJsonSchema: mergedSchema,
      getPojoInput: (argv) => argv.options
    }
  };
}
function isOptional(schema) {
  if (schema && typeof schema === "object" && "optional" in schema)
    return schema.optional === true;
  if (schemaDefPropValue(schema, "not") && JSON.stringify(schema) === '{"not":{}}')
    return true;
  const anyOf = schemaDefPropValue(schema, "anyOf");
  if (anyOf?.some((sub) => isOptional(sub)))
    return true;
  if (schemaDefPropValue(schema, "default") !== void 0)
    return true;
  return false;
}
function parsePrimitiveInput(schema) {
  const typeName = acceptedPrimitiveTypes(schema).join(" | ");
  const name25 = (schema.title || schema.description || /\W/.test(typeName) ? "value" : typeName).replaceAll(/\s+/g, "_");
  return {
    success: true,
    value: {
      positionalParameters: [
        {
          name: name25,
          array: false,
          description: schema.description || "",
          required: !isOptional(schema),
          type: typeName
        }
      ],
      optionsJsonSchema: {},
      getPojoInput: (argv) => convertPositional(schema, argv.positionalValues[0])
    }
  };
}
var schemaDefPropValue = (schema, prop) => {
  if (schema && typeof schema === "object" && prop in schema)
    return schema[prop];
  return void 0;
};
var primitiveCandidateTypes = ["string", "number", "boolean", "integer"];
function acceptedPrimitiveTypes(schema) {
  let constVals = [toRoughJsonSchema7(schema).const, toRoughJsonSchema7(schema).enum].flat().filter(Boolean).map((s) => typeof s);
  if (constVals.length === 0)
    constVals = void 0;
  const typeList = constVals || schemaDefPropValue(schema, "type") || schemaDefPropValue(schema, "oneOf")?.flatMap((s) => acceptedPrimitiveTypes(s)) || schemaDefPropValue(schema, "anyOf")?.flatMap((s) => acceptedPrimitiveTypes(s));
  const acceptedJsonSchemaTypes = new Set([typeList].flat().filter(Boolean));
  return primitiveCandidateTypes.filter((c) => acceptedJsonSchemaTypes.has(c));
}
function maybeMergeObjectSchemas(schemas) {
  const required = [];
  const properties = {};
  for (const schema of schemas) {
    if (!schema)
      return null;
    const { required: schemaRequired, properties: schemaProperties, type: type2, $schema, ...rest } = schema;
    if (type2 && type2 !== "object")
      return null;
    if (Object.keys(rest).length)
      return null;
    if (schemaRequired)
      required.push(...schemaRequired);
    if (schemaProperties)
      Object.assign(properties, schemaProperties);
  }
  return { type: "object", required, properties };
}
function parseMultiInputs(inputs, dependencies) {
  const parsedIndividually = inputs.map((input) => parseProcedureInputsInner([input], dependencies));
  const failures = parsedIndividually.flatMap((p) => p.success ? [] : [p.error]);
  if (failures.length > 0) {
    return { success: false, error: failures.join("\n") };
  }
  const allObjects = parsedIndividually.every((p) => p.success && p.value.positionalParameters.length === 0);
  if (!allObjects) {
    return {
      success: false,
      error: `Can't use positional parameters with multi-input type.`
    };
  }
  const merged = maybeMergeObjectSchemas(parsedIndividually.map((p) => p.success ? p.value.optionsJsonSchema : {}));
  if (merged) {
    return {
      success: true,
      value: {
        positionalParameters: [],
        optionsJsonSchema: merged,
        getPojoInput: (argv) => argv.options
      }
    };
  }
  return {
    success: true,
    value: {
      positionalParameters: [],
      optionsJsonSchema: {
        allOf: parsedIndividually.map((p) => {
          const successful = p;
          const optionsSchema = successful.value.optionsJsonSchema;
          if ("additionalProperties" in optionsSchema && optionsSchema.additionalProperties === false) {
            const { additionalProperties, ...rest } = optionsSchema;
            return rest;
          }
          return optionsSchema;
        })
      },
      getPojoInput: (argv) => argv.options
    }
  };
}
function isNullable(schema) {
  if (Array.isArray(schema.type) && schema.type.includes("null"))
    return true;
  if (schema.type === "null")
    return true;
  if ((schema.anyOf || schema.oneOf)?.some((sub) => isNullable(toRoughJsonSchema7(sub))))
    return true;
  if (schema.const === null)
    return true;
  return false;
}
var tupleItemsSchemas = (schema) => {
  if (!schema || typeof schema !== "object")
    return void 0;
  if (Array.isArray(schema.items))
    return schema.items;
  if ("prefixItems" in schema && Array.isArray(schema.prefixItems))
    return schema.prefixItems;
  return void 0;
};
function isTuple(schema) {
  return Array.isArray(tupleItemsSchemas(schema));
}
function parseArrayInput(array2) {
  if (looksLikeJsonSchema(array2.items) && isNullable(array2.items)) {
    return {
      success: false,
      error: `Invalid input type Array<${getSchemaTypes(array2.items).join(" | ")}>. Nullable arrays are not supported.`
    };
  }
  return {
    success: true,
    value: {
      positionalParameters: [
        {
          name: parameterName(array2, 1),
          array: true,
          description: array2.description || "",
          required: !isOptional(array2),
          type: "string"
        }
      ],
      optionsJsonSchema: {},
      getPojoInput: (argv) => argv.positionalValues.at(-1).map((s) => convertPositional(array2.items, s))
    }
  };
}
function parseTupleInput(tuple) {
  const items = tupleItemsSchemas(tuple);
  if (!Array.isArray(items))
    throw new Error(".items is not an array, is this really a tuple?");
  const flagsSchemaIndex = items.findIndex((item) => {
    if (acceptedPrimitiveTypes(item).length > 0) {
      return false;
    }
    if (looksLikeArray(item) && acceptedPrimitiveTypes(item.items).length > 0) {
      return false;
    }
    return true;
  });
  const types = `[${items.map((s) => schemaDefPropValue(s, "type")).join(", ")}]`;
  if (flagsSchemaIndex > -1 && flagsSchemaIndex !== items.length - 1) {
    return {
      success: false,
      error: `Invalid input type ${types}. Positional parameters must be strings, numbers or booleans.`
    };
  }
  const flagsSchema = flagsSchemaIndex === -1 ? null : items[flagsSchemaIndex];
  if (flagsSchema && !acceptsObject(flagsSchema)) {
    return {
      success: false,
      error: `Invalid input type ${types}. The last type must accept object inputs.`
    };
  }
  const positionalSchemas = flagsSchemaIndex === -1 ? items : items.slice(0, flagsSchemaIndex);
  return {
    success: true,
    value: {
      positionalParameters: positionalSchemas.map((schema, i) => ({
        name: parameterName(schema, i + 1),
        array: looksLikeArray(schema),
        description: schemaDefPropValue(schema, "description") || "",
        required: !isOptional(schema),
        type: getSchemaTypes(toRoughJsonSchema7(schema)).join(" | ")
      })),
      optionsJsonSchema: flagsSchema && typeof flagsSchema === "object" ? flagsSchema : {},
      getPojoInput: (commandArgs) => {
        const inputs = commandArgs.positionalValues.map((v, i) => {
          const correspondingSchema = positionalSchemas[i];
          if (looksLikeArray(correspondingSchema)) {
            if (!Array.isArray(v)) {
              throw new CliValidationError(`Expected array at position ${i}, got ${typeof v}`);
            }
            return v.map((s) => {
              if (!correspondingSchema.items || Array.isArray(correspondingSchema.items))
                return s;
              return convertPositional(correspondingSchema.items, s);
            });
          }
          if (typeof v !== "string" && v !== void 0) {
            throw new CliValidationError(`Expected string at position ${i}, got ${typeof v}`);
          }
          return convertPositional(correspondingSchema, v);
        });
        if (flagsSchema) {
          inputs.push(commandArgs.options);
        }
        return inputs;
      }
    }
  };
}
var convertPositional = (schema, value2) => {
  let preprocessed = void 0;
  const acceptedTypes = new Set(acceptedPrimitiveTypes(schema));
  if (acceptedTypes.has("string")) {
    preprocessed = value2;
  }
  if (acceptedTypes.has("boolean")) {
    if (value2 === "true")
      preprocessed = true;
    else if (value2 === "false")
      preprocessed = false;
  }
  if (acceptedTypes.has("number")) {
    const number = Number(value2);
    if (!Number.isNaN(number)) {
      preprocessed = number;
    }
  }
  if (acceptedTypes.has("integer")) {
    const num = Number(value2);
    if (Number.isInteger(num)) {
      preprocessed = num;
    } else if (!Number.isNaN(num) && acceptedTypes === void 0) {
      preprocessed = value2;
    }
  }
  if (preprocessed === void 0) {
    return value2;
  }
  return preprocessed;
};
var looksLikeArray = (schema) => {
  return schemaDefPropValue(schema, "type") === "array";
};
var toRoughJsonSchema7 = (schema) => {
  if (!schema || typeof schema !== "object") {
    return {};
  }
  return schema;
};
var maybeParameterName = (s) => {
  const value2 = schemaDefPropValue(s, "title") || schemaDefPropValue(s, "description");
  if (!value2 && looksLikeArray(s)) {
    const items = toRoughJsonSchema7(s).items;
    return items && !Array.isArray(items) ? maybeParameterName(items) : void 0;
  }
  return value2;
};
var parameterName = (s, position) => {
  let name25 = maybeParameterName(s) || `parameter_${position}`;
  if (looksLikeArray(s))
    return `[${name25}...]`;
  name25 = name25.replaceAll(/\W+/g, " ").trim();
  return isOptional(s) ? `[${name25}]` : `<${name25}>`;
};
var acceptsObject = (schema) => {
  return (schema.type === "object" || schema.anyOf?.some((sub) => acceptsObject(toRoughJsonSchema7(sub)))) ?? false;
};
var getJsonSchemaConverters = (dependencies) => {
  return {
    zod: (input) => {
      if (input._zod?.version?.major == 4) {
        const zod4 = getModule(zod4CoreOrError);
        return zod4.toJSONSchema(input, {
          io: "input",
          // todo[zod@>=4.1.0] remove the override if https://github.com/colinhacks/zod/issues/4164 is resolved, or this comment if it's closed
          unrepresentable: "any",
          // todo[zod@>=4.1.0] remove the override if https://github.com/colinhacks/zod/issues/4164 is resolved, or this comment if it's closed
          override: (ctx) => {
            if (ctx.zodSchema?.constructor?.name === "ZodOptional") {
              ctx.jsonSchema.optional = true;
            }
            const meta = ctx.zodSchema.meta?.();
            if (meta)
              Object.assign(ctx.jsonSchema, meta);
          }
        });
      }
      return zodToJsonSchema(input);
    },
    arktype: (input) => {
      const type2 = prepareArktypeType(input);
      return type2.toJsonSchema({
        fallback: (ctx) => {
          if (ctx.code === "unit" && ctx.unit === void 0)
            return { ...ctx.base, optional: true };
          return ctx.base;
        }
      });
    },
    valibot: (input) => {
      const valibotToJsonSchemaLib = dependencies["@valibot/to-json-schema"] || getModule(valibotToJsonSchemaOrError);
      const valibotToJsonSchema = valibotToJsonSchemaLib?.toJsonSchema;
      if (!valibotToJsonSchema) {
        throw new Error(`no 'toJsonSchema' function found in @valibot/to-json-schema - check you are using a supported version`);
      }
      if (typeof valibotOrError === "string") {
        return valibotToJsonSchema(input);
      }
      const v = getModule(valibotOrError);
      const parent = valibotToJsonSchema(v.object({ child: input }), {
        errorMode: "ignore"
      });
      const child = parent.properties.child;
      return parent.required?.length === 0 ? Object.assign(child, { optional: true }) : child;
    },
    effect: (input) => {
      const effect = dependencies.effect || getModule(effectOrError);
      if (!effect) {
        throw new Error(`effect dependency could not be found - try installing it and re-running`);
      }
      if (!effect.Schema.isSchema(input)) {
        const message = `input was not an effect schema - please use effect version 3.14.2 or higher. See https://github.com/mmkal/trpc-cli/pull/63`;
        throw new Error(message);
      }
      return effect.JSONSchema.make(input);
    }
  };
};
function getVendor(schema) {
  return schema?.["~standard"]?.vendor ?? null;
}
var jsonSchemaVendorNames = new Set(Object.keys(getJsonSchemaConverters({})));
function looksJsonSchemaable(value2) {
  const vendor = getVendor(value2);
  return !!vendor && jsonSchemaVendorNames.has(vendor);
}
function prepareArktypeType(type2) {
  let innerType = type2;
  while (innerType) {
    if (innerType?.in && innerType.in !== innerType) {
      innerType = innerType.in;
    } else {
      break;
    }
  }
  return innerType;
}

// node_modules/trpc-cli/dist/prompts.js
import { Argument, Command, Option } from "commander";
var parseUpstreamOptionInfo = (value2) => {
  if (typeof value2 !== "string" || !value2.startsWith("{"))
    return null;
  try {
    const info = JSON.parse(value2);
    if (info.typeName !== "UpstreamOptionInfo")
      return null;
    return info;
  } catch {
    return null;
  }
};
var parseUpstreamArgumentInfo = (value2) => {
  if (typeof value2 !== "string" || !value2.startsWith("{"))
    return null;
  try {
    const info = JSON.parse(value2);
    if (info.typeName !== "UpstreamArgumentInfo")
      return null;
    return info;
  } catch {
    return null;
  }
};
var getDefaultSubcommand = (command) => {
  const defaultChild = command.description().match(/Available subcommands:.* (\S+) \(default\)/)?.[1];
  return defaultChild ? command.commands.find((c) => c.name() === defaultChild) : void 0;
};
var createShadowCommand = (command, onAnalyze) => {
  const shadow = new Command(command.name());
  shadow.exitOverride();
  shadow.configureOutput({
    writeOut: () => {
    },
    writeErr: () => {
    }
  });
  const argumentsMap = /* @__PURE__ */ new Map();
  const optionsMap = /* @__PURE__ */ new Map();
  command.options.forEach((original) => {
    const id = Date.now().toString() + Math.random().toString().slice(1);
    const shadowOption = new Option(original.flags.replace("<", "[").replace(">", "]"), JSON.stringify([`id=${id}`, original.description]));
    const upstreamOptionInfo = { typeName: "UpstreamOptionInfo", id, specified: false };
    shadowOption.default(JSON.stringify(upstreamOptionInfo));
    shadowOption.argParser((value2) => JSON.stringify({ ...upstreamOptionInfo, specified: true, value: value2 }));
    shadow.addOption(shadowOption);
    optionsMap.set(id, { shadow: shadowOption, original });
  });
  command.registeredArguments.forEach((original) => {
    const shadowArgument = new Argument(original.name(), original.description);
    const id = Date.now().toString() + Math.random().toString().slice(1);
    shadowArgument.argOptional();
    const upstreamArgumentInfo = { typeName: "UpstreamArgumentInfo", id, specified: false };
    shadowArgument.default(JSON.stringify(upstreamArgumentInfo));
    shadowArgument.argParser((value2) => JSON.stringify({ ...upstreamArgumentInfo, specified: true, value: value2 }));
    shadow.addArgument(shadowArgument);
    argumentsMap.set(id, { shadow: shadowArgument, original });
  });
  const analysis = {
    command: { shadow, original: command },
    arguments: [],
    options: []
  };
  shadow.action(async (...args2) => {
    const positionalValues = args2.slice(0, -2);
    const options = shadow.opts();
    if (args2.at(-2) !== options) {
      throw new Error(`Unexpected args format, second last arg is not the options object`, { cause: args2 });
    }
    if (args2.at(-1) !== shadow) {
      throw new Error(`Unexpected args format, last arg is not the Command instance`, { cause: args2 });
    }
    positionalValues.forEach((value2) => {
      const argumentInfo = parseUpstreamArgumentInfo(value2);
      if (argumentInfo) {
        analysis.arguments.push({
          ...argumentsMap.get(argumentInfo.id),
          value: argumentInfo.value,
          specified: argumentInfo.specified
        });
      }
    });
    Object.values(options).forEach((value2) => {
      const upstreamOptionInfo = parseUpstreamOptionInfo(value2);
      if (upstreamOptionInfo) {
        analysis.options.push({
          ...optionsMap.get(upstreamOptionInfo.id),
          value: upstreamOptionInfo.value,
          specified: upstreamOptionInfo.specified
        });
      }
    });
    await onAnalyze(analysis);
  });
  command.commands.forEach((subcommand) => {
    const shadowSubcommand = createShadowCommand(subcommand, onAnalyze);
    shadow.addCommand(shadowSubcommand);
  });
  return shadow;
};
var inquirerPrompter = (prompts) => {
  return prompts;
};
var clackPrompter = (prompts) => {
  const clack = prompts;
  class ExitPromptError extends Error {
  }
  const throwOnCancel = (value2) => {
    if (clack.isCancel(value2))
      throw new ExitPromptError();
    return value2;
  };
  return {
    input: async (params) => {
      return clack.text({
        message: params.message,
        initialValue: params.default,
        defaultValue: params.default,
        placeholder: params.default,
        validate: params.validate ? (input) => {
          const result = params.validate(input);
          if (result === true)
            return void 0;
          if (result === false)
            return `Invalid input`;
          return result;
        } : void 0
      }).then(throwOnCancel);
    },
    checkbox: async (params) => {
      return clack.multiselect({
        message: params.message,
        options: params.choices.map((c) => ({
          label: c.name,
          value: c.value
        })),
        initialValues: params.choices.flatMap((c) => c.checked ? [c.value] : [])
      }).then(throwOnCancel);
    },
    confirm: async (params) => {
      return clack.confirm({
        message: params.message,
        initialValue: params.default
      }).then(throwOnCancel);
    },
    select: async (params) => {
      return clack.select({
        message: params.message,
        options: params.choices.map((sorc) => {
          const c = typeof sorc === "string" ? { name: sorc, value: sorc } : sorc;
          return {
            label: c.name,
            value: c.value,
            hint: c.description
          };
        }),
        initialValue: params.default
      }).then(throwOnCancel);
    }
  };
};
var promptsPrompter = (prompts) => {
  const p = prompts;
  function x() {
    return (value2) => value2.x;
  }
  return {
    input: async (params) => {
      return p({
        name: "x",
        type: "text",
        message: params.message,
        validate: params.validate,
        initial: params.default
      }).then(x());
    },
    confirm: async (params) => {
      return p({
        name: "x",
        type: "confirm",
        message: params.message,
        active: params.default ? "yes" : "no"
      }).then(x());
    },
    select: async (params) => {
      const choicesObjects = params.choices.map((c) => typeof c === "string" ? { name: c, value: c } : c);
      return p({
        name: "x",
        type: "select",
        message: params.message,
        active: params.default,
        choices: choicesObjects.map((c) => ({
          title: c.name || c.value,
          value: c.value
        })),
        initial: params.default ? choicesObjects.findIndex((c) => c.value === params.default) : void 0
      }).then(x());
    },
    checkbox: async (params) => {
      const choicesObjects = params.choices.map((c) => typeof c === "string" ? { name: c, value: c } : c);
      return p({
        name: "x",
        type: "multiselect",
        message: params.message,
        choices: choicesObjects.map((c) => ({
          title: c.name || c.value,
          value: c.value,
          selected: c.checked
        }))
      }).then(x());
    }
  };
};
var enquirerPrompter = (prompts) => {
  const enquirer = prompts;
  function x() {
    return (value2) => value2.x;
  }
  return {
    input: async (params) => {
      return enquirer.prompt({
        type: "input",
        name: "x",
        message: params.message,
        validate: params.validate,
        initial: params.default
      }).then(x());
    },
    confirm: async (params) => {
      return enquirer.prompt({
        type: "confirm",
        name: "x",
        message: params.message,
        validate: params.validate,
        initial: params.default
      }).then(x());
    },
    select: async (params) => {
      return enquirer.prompt({
        type: "select",
        name: "x",
        message: params.message,
        // @ts-expect-error not sure why this is an error, in the IDE it infers the type correctly
        choices: params.choices.slice(),
        validate: params.validate,
        initial: params.default
      }).then(x());
    },
    checkbox: async (params) => {
      return enquirer.prompt({
        type: "multiselect",
        name: "x",
        message: params.message,
        // @ts-expect-error not sure why this is an error, in the IDE it infers the type correctly
        choices: params.choices.slice().map((c) => ({
          name: c.name,
          value: c.value
        })),
        // validate: params.validate ? v => params.validate!([{value: v}]) : undefined,
        initial: params.choices.flatMap((c, i) => c.checked ? [i] : [])
      }).then(x());
    }
  };
};
var promptify = (program, prompts) => {
  let promptsInput = prompts;
  if (promptsInput?.default)
    promptsInput = promptsInput.default;
  let prompter;
  if (typeof promptsInput === "function" && typeof promptsInput.inject === "function") {
    prompter = promptsPrompter(promptsInput);
  } else if (promptsInput?.name === "Enquirer") {
    prompter = enquirerPrompter(promptsInput);
  } else if (typeof promptsInput?.rawlist === "function") {
    prompter = inquirerPrompter(promptsInput);
  } else if (typeof promptsInput?.intro === "function") {
    prompter = clackPrompter(promptsInput);
  } else if (typeof promptsInput === "function") {
    prompter = promptsInput(program);
  } else {
    prompter = promptsInput;
  }
  const command = program;
  const analyseThenParse = async (argv, parseOptions) => {
    if (parseOptions?.from === "electron") {
      console.warn(`Warning: using prompts in electron mode is untested. The first two args of $0 are not available in electron mode. Assuming that the first two args of ${JSON.stringify(argv)} are electron-related and not intended for the CLI.`);
    }
    if (parseOptions?.from !== "user") {
      argv = argv.slice(2);
      parseOptions = { from: "user" };
    }
    const f = { command, args: [...argv] };
    const nextArgv = [...f.args];
    let analysis = void 0;
    const maxAttempts = 100;
    for (let i = maxAttempts; i >= 0 && !analysis; i--) {
      analysis = await new Promise((resolve4, reject) => {
        const shadow = createShadowCommand(f.command, async (an) => {
          if (an.command.original.commands.length === 0) {
            resolve4(an);
            return;
          }
          const defaultSubcommand = getDefaultSubcommand(an.command.original);
          if (defaultSubcommand) {
            resolve4(an);
            return;
          }
          const name25 = await prompter.select({
            message: `Select a ${an.command.original.name() || ""} subcommand`.replace("  ", " "),
            choices: an.command.original.commands.map((c) => ({
              name: c.name(),
              value: c.name(),
              description: c.description()
            }))
          }, {});
          nextArgv.push(name25);
          resolve4(void 0);
        });
        shadow.parseAsync(nextArgv, parseOptions).catch((e) => {
          if (e?.constructor?.name === "CommanderError") {
            resolve4({
              command: { shadow: f.command, original: f.command },
              arguments: [],
              options: []
            });
          } else {
            reject(e);
          }
        });
      });
    }
    if (!analysis) {
      const message = `Failed to find a subcommand after ${maxAttempts} attempts - failing to avoid an infinite loop. This is probably a bug in trpc-cli.`;
      throw new Error(message);
    }
    const getMessage = (argOrOpt) => {
      const name25 = "long" in argOrOpt ? argOrOpt.flags : `[${argOrOpt.name()}]`;
      const parts = [
        name25,
        argOrOpt.description,
        argOrOpt.defaultValue && `(default: ${argOrOpt.defaultValue})`,
        !argOrOpt.defaultValue && !argOrOpt.required && "(optional)"
      ];
      return parts.filter(Boolean).join(" ").trim() + ":";
    };
    const baseContext = {
      command: analysis.command.original,
      inputs: {
        argv,
        arguments: analysis.arguments.map((a) => ({ name: a.original.name(), specified: a.specified, value: a.value })),
        options: analysis.options.map((o) => ({ name: o.original.name(), specified: o.specified, value: o.value }))
      }
    };
    await prompter.setup?.(baseContext);
    const procedureMeta = analysis.command.original.__trpcCli?.meta;
    let shouldPrompt;
    if (typeof procedureMeta?.prompt === "boolean") {
      shouldPrompt = procedureMeta.prompt;
    } else {
      const someRequiredArgsUnspecified = analysis.arguments.some((a) => a.original.required && !a.specified);
      const someRequiredOptionsUnspecified = analysis.options.some((o) => o.original.required && !o.specified);
      shouldPrompt = someRequiredArgsUnspecified || someRequiredOptionsUnspecified;
    }
    if (shouldPrompt) {
      for (const arg of analysis.arguments) {
        const ctx = { ...baseContext, argument: arg.original };
        if (!arg.specified) {
          const parseArg = "parseArg" in arg.original && typeof arg.original.parseArg === "function" ? arg.original.parseArg : void 0;
          const promptedValue = await prompter.input({
            message: getMessage(arg.original),
            required: arg.original.required,
            default: arg.value,
            validate: (input) => {
              try {
                parseArg?.(input);
                return true;
              } catch (e) {
                return `${e?.message || e}`;
              }
            }
          }, ctx);
          nextArgv.push(promptedValue);
        }
      }
      for (const option of analysis.options) {
        const ctx = { ...baseContext, option: option.original };
        if (!option.specified) {
          const fullFlag = option.original.long || `--${option.original.name()}`;
          const isBoolean = option.original.isBoolean() || option.original.flags.includes("[boolean]");
          if (isBoolean) {
            const promptedValue = await prompter.confirm({
              message: getMessage(option.original),
              default: option.original.defaultValue ?? false
            }, ctx);
            if (promptedValue)
              nextArgv.push(fullFlag);
          } else if (option.original.variadic && option.original.argChoices) {
            const choices = option.original.argChoices.slice();
            const results = await prompter.checkbox({
              message: getMessage(option.original),
              choices: choices.map((choice2) => ({
                value: choice2,
                name: choice2,
                checked: true
              }))
            }, ctx);
            results.forEach((result) => {
              if (typeof result === "string")
                nextArgv.push(fullFlag, result);
            });
          } else if (option.original.argChoices) {
            const choices = option.original.argChoices.slice();
            const set = new Set(choices);
            const promptedValue = await prompter.select({
              message: getMessage(option.original),
              choices,
              default: option.original.defaultValue
              // required: option.original.required,
            }, ctx);
            if (set.has(promptedValue)) {
              nextArgv.push(fullFlag, promptedValue);
            }
          } else if (option.original.variadic) {
            const values = [];
            do {
              const promptedValue = await prompter.input({
                message: getMessage(option.original),
                default: option.original.defaultValue?.[values.length]
              }, ctx);
              if (!promptedValue)
                break;
              values.push(fullFlag, promptedValue);
            } while (values);
            nextArgv.push(...values);
          } else {
            const getParsedValue = (input) => {
              return option.original.parseArg ? option.original.parseArg(input, void 0) : input;
            };
            const promptedValue = await prompter.input({
              message: getMessage(option.original),
              default: option.value,
              required: option.original.required,
              validate: (input) => {
                const parsed = getParsedValue(input);
                if (parsed == null && input != null)
                  return "Invalid value";
                return true;
              }
            }, ctx);
            if (promptedValue)
              nextArgv.push(fullFlag, getParsedValue(promptedValue) ?? promptedValue);
          }
        }
      }
    }
    await prompter.teardown?.(baseContext);
    return f.command.parseAsync(nextArgv, parseOptions);
  };
  const parseAsync = (args2, parseOptions) => analyseThenParse(args2, parseOptions).catch((e) => {
    if (e?.constructor?.name === "ExitPromptError")
      return;
    throw e;
  });
  return new Proxy(program, {
    get(target, prop, receiver) {
      if (prop === "parseAsync")
        return parseAsync;
      return Reflect.get(target, prop, receiver);
    }
  });
};

// node_modules/trpc-cli/dist/standard-schema/utils.js
var looksLikeStandardSchemaFailure = (error) => {
  return !!error && typeof error === "object" && "issues" in error && Array.isArray(error.issues);
};

// node_modules/trpc-cli/dist/standard-schema/errors.js
var prettifyStandardSchemaError = (error) => {
  if (!looksLikeStandardSchemaFailure(error))
    return null;
  const issues = [...error.issues].map((issue) => {
    const path24 = issue.path || [];
    const primitivePathSegments = path24.map((segment) => {
      if (typeof segment === "string" || typeof segment === "number" || typeof segment === "symbol")
        return segment;
      return segment.key;
    });
    const dotPath = toDotPath(primitivePathSegments);
    return {
      issue,
      path: path24,
      primitivePathSegments,
      dotPath
    };
  }).sort((a, b) => a.path.length - b.path.length);
  const lines = [];
  for (const { issue, dotPath } of issues) {
    let message = `\u2716 ${issue.message}`;
    if (dotPath)
      message += ` \u2192 at ${dotPath}`;
    lines.push(message);
  }
  return lines.join("\n");
};
function toDotPath(path24) {
  const segs = [];
  for (const seg of path24) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}

// node_modules/trpc-cli/dist/trpc-compat.js
var isOrpcRouter = (router2) => {
  const values = [];
  for (const v of Object.values(router2)) {
    if (typeof v === "function")
      return false;
    values.push(v);
  }
  return values.every((v) => isOrpcProcedure(v) || isOrpcRouter(v));
};
var isOrpcProcedure = (procedure) => {
  return typeof procedure === "object" && "~orpc" in procedure && typeof procedure["~orpc"] === "object";
};

// node_modules/trpc-cli/dist/util.js
var looksLikeInstanceof = (value2, target) => {
  let current = value2?.constructor;
  while (current?.name) {
    if (current?.name === (typeof target === "string" ? target : target.name))
      return true;
    current = Object.getPrototypeOf(current);
  }
  return false;
};

// node_modules/trpc-cli/dist/index.js
var orpcServerOrError = await Promise.resolve().then(() => (init_dist5(), dist_exports)).catch(String);
var getOrpcServerModule = () => {
  if (typeof orpcServerOrError === "string") {
    throw new Error(`@orpc/server must be installed. Error loading: ${orpcServerOrError}`);
  }
  return orpcServerOrError;
};
var Command2 = class extends BaseCommand {
  /** @internal track the commands that have been run, so that we can find the `__result` of the last command */
  __ran = [];
  __input;
  /** @internal stash the return value of the underlying procedure on the command so to pass to `FailedToExitError` for use in a pinch */
  __result;
};
var parseRouter = ({ router: router2, ...params }) => {
  if (isOrpcRouter(router2))
    return parseOrpcRouter({ router: router2, ...params });
  return parseTrpcRouter({ router: router2, ...params });
};
var parseTrpcRouter = ({ router: router2, ...params }) => {
  const defEntries = Object.entries(router2._def.procedures);
  return defEntries.map(([procedurePath, procedure]) => {
    const meta = getMeta(procedure);
    if (meta.jsonInput) {
      return [procedurePath, { meta, parsedProcedure: jsonProcedureInputs(), incompatiblePairs: [], procedure }];
    }
    const procedureInputsResult = parseProcedureInputs(procedure._def.inputs, params);
    if (!procedureInputsResult.success) {
      const procedureInputs2 = jsonProcedureInputs(`procedure's schema couldn't be converted to CLI arguments: ${procedureInputsResult.error}`);
      return [procedurePath, { meta, parsedProcedure: procedureInputs2, incompatiblePairs: [], procedure }];
    }
    const procedureInputs = procedureInputsResult.value;
    const incompatiblePairs = incompatiblePropertyPairs(procedureInputs.optionsJsonSchema);
    return [procedurePath, { meta: getMeta(procedure), parsedProcedure: procedureInputs, incompatiblePairs, procedure }];
  });
};
var parseOrpcRouter = (params) => {
  const entries = [];
  const { traverseContractProcedures: traverseContractProcedures2, isProcedure: isProcedure2 } = getOrpcServerModule();
  const router2 = params.router;
  const lazyRoutes = traverseContractProcedures2({ path: [], router: router2 }, ({ contract, path: path24 }) => {
    let procedure = params.router;
    for (const p of path24)
      procedure = procedure[p];
    if (!isProcedure2(procedure))
      return;
    const procedureInputsResult = parseProcedureInputs([contract["~orpc"].inputSchema], {
      "@valibot/to-json-schema": params["@valibot/to-json-schema"],
      effect: params.effect
    });
    const procedurePath = path24.join(".");
    const procedureish = { _def: { meta: contract["~orpc"].meta } };
    const meta = getMeta(procedureish);
    if (meta.jsonInput) {
      entries.push([procedurePath, { meta, parsedProcedure: jsonProcedureInputs(), incompatiblePairs: [], procedure }]);
      return;
    }
    if (!procedureInputsResult.success) {
      const parsedProcedure2 = jsonProcedureInputs(`procedure's schema couldn't be converted to CLI arguments: ${procedureInputsResult.error}`);
      entries.push([procedurePath, { meta, parsedProcedure: parsedProcedure2, incompatiblePairs: [], procedure }]);
      return;
    }
    const parsedProcedure = procedureInputsResult.value;
    const incompatiblePairs = incompatiblePropertyPairs(parsedProcedure.optionsJsonSchema);
    entries.push([procedurePath, { procedure, meta, incompatiblePairs, parsedProcedure }]);
  });
  if (lazyRoutes.length) {
    const suggestion = `Please use \`import {unlazyRouter} from '@orpc/server'\` to unlazy the router before passing it to trpc-cli`;
    const routes = lazyRoutes.map(({ path: path24 }) => path24.join(".")).join(", ");
    throw new Error(`Lazy routers are not supported. ${suggestion}. Lazy routes detected: ${routes}`);
  }
  return entries;
};
var jsonProcedureInputs = (reason) => {
  let description = `Input formatted as JSON`;
  if (reason)
    description += ` (${reason})`;
  return {
    positionalParameters: [],
    optionsJsonSchema: {
      type: "object",
      properties: {
        input: { description }
        // omit `type` - this is json input, it could be anything
      }
    },
    getPojoInput: (parsedCliParams) => parsedCliParams.options.input
  };
};
function createCli({ router: router2, ...params }) {
  const procedureEntries = parseRouter({ router: router2, ...params });
  function buildProgram(runParams) {
    const logger = { ...lineByLineConsoleLogger, ...runParams?.logger };
    const program = new Command2(params.name);
    if (params.version)
      program.version(params.version);
    if (params.description)
      program.description(params.description);
    if (params.usage)
      [params.usage].flat().forEach((usage) => program.usage(usage));
    program.showHelpAfterError();
    program.showSuggestionAfterError();
    const commandTree = {
      "": program
      // Root level
    };
    const defaultCommands = {};
    const _process = runParams?.process || process;
    const configureCommand = (command, procedurePath, { meta, parsedProcedure, incompatiblePairs, procedure }) => {
      Object.assign(command, { __trpcCli: { path: procedurePath, meta } });
      const optionJsonSchemaProperties = flattenedProperties(parsedProcedure.optionsJsonSchema);
      command.exitOverride((ec) => {
        _process.exit(ec.exitCode);
        throw new FailedToExitError(`Command ${command.name()} exitOverride`, { exitCode: ec.exitCode, cause: ec });
      });
      command.configureOutput({
        writeOut: (str) => {
          logger.info?.(str);
        },
        writeErr: (str) => {
          logger.error?.(str);
        }
      });
      command.showHelpAfterError();
      if (meta.usage)
        command.usage([meta.usage].flat().join("\n"));
      if (meta.examples)
        command.addHelpText("after", `
Examples:
${[meta.examples].flat().join("\n")}`);
      meta?.aliases?.command?.forEach((alias) => {
        command.alias(alias);
      });
      command.description(meta?.description || "");
      parsedProcedure.positionalParameters.forEach((param) => {
        const descriptionParts = [
          param.type === "string" ? "" : param.type,
          // "string" is the default assumption, don't bother showing it
          param.description,
          param.required ? "(required)" : ""
        ];
        const argument = new Argument2(param.name, descriptionParts.filter(Boolean).join(" "));
        if (param.type === "number") {
          argument.argParser((value2) => {
            const number = numberParser(value2, { fallback: null });
            if (number == null)
              throw new InvalidArgumentError(`Invalid number: ${value2}`);
            return value2;
          });
        }
        argument.required = param.required;
        argument.variadic = param.array;
        command.addArgument(argument);
      });
      const unusedOptionAliases = { ...meta.aliases?.options };
      const addOptionForProperty = ([propertyKey, propertyValue]) => {
        class Option2 extends BaseOption {
          attributeName() {
            return propertyKey;
          }
        }
        const description = getDescription(propertyValue);
        const longOption = `--${kebabCase(propertyKey)}`;
        let flags = longOption;
        const alias = propertyValue && "alias" in propertyValue && typeof propertyValue.alias === "string" ? propertyValue.alias : meta.aliases?.options?.[propertyKey];
        if (alias) {
          let prefix = "-";
          if (alias.startsWith("-"))
            prefix = "";
          else if (alias.length > 1)
            prefix = "--";
          flags = `${prefix}${alias}, ${flags}`;
          delete unusedOptionAliases[propertyKey];
        }
        const allowedSchemas = getAllowedSchemas(propertyValue);
        const firstSchemaWithDefault = allowedSchemas.find((subSchema) => "default" in subSchema);
        const defaultValue = firstSchemaWithDefault ? { exists: true, value: firstSchemaWithDefault.default } : { exists: false };
        const rootTypes = getSchemaTypes(propertyValue).sort();
        const propertyType = rootTypes[0];
        const isValueRequired = "required" in parsedProcedure.optionsJsonSchema && parsedProcedure.optionsJsonSchema.required?.includes(propertyKey);
        const isCliOptionRequired = isValueRequired && propertyType !== "boolean" && !defaultValue.exists;
        function negate() {
          const shouldNegate = "negatable" in propertyValue ? propertyValue.negatable : meta.negateBooleans;
          if (shouldNegate) {
            const negation = new Option2(longOption.replace("--", "--no-"), `Negate \`${longOption}\` option.`.trim());
            command.addOption(negation);
          }
        }
        const bracketise = (name25) => isCliOptionRequired ? `<${name25}>` : `[${name25}]`;
        if (allowedSchemas.length > 1) {
          const option2 = new Option2(`${flags} [value]`, description);
          if (defaultValue.exists)
            option2.default(defaultValue.value);
          else if (rootTypes.includes("boolean"))
            option2.default(false);
          option2.argParser(getOptionValueParser(propertyValue));
          command.addOption(option2);
          if (rootTypes.includes("boolean"))
            negate();
          return;
        }
        if (rootTypes.length !== 1) {
          const option2 = new Option2(`${flags} ${bracketise("json")}`, description);
          option2.argParser(getOptionValueParser(propertyValue));
          command.addOption(option2);
          return;
        }
        if (propertyType === "boolean") {
          const option2 = new Option2(`${flags} [boolean]`, description);
          option2.argParser((value2) => booleanParser(value2));
          if (isValueRequired)
            option2.default(false);
          else if (defaultValue.exists)
            option2.default(defaultValue.value);
          command.addOption(option2);
          negate();
          return;
        }
        let option = null;
        if (propertyType === "string") {
          option = new Option2(`${flags} ${bracketise("string")}`, description);
        } else if (propertyType === "boolean") {
          option = new Option2(flags, description);
        } else if (propertyType === "number" || propertyType === "integer") {
          option = new Option2(`${flags} ${bracketise("number")}`, description);
          option.argParser((value2) => numberParser(value2, { fallback: null }));
        } else if (propertyType === "array") {
          option = new Option2(`${flags} [values...]`, description);
          if (defaultValue.exists)
            option.default(defaultValue.value);
          else if (isValueRequired)
            option.default([]);
          const itemsSchema = "items" in propertyValue ? propertyValue.items : {};
          const itemEnumTypes = getEnumChoices(itemsSchema);
          if (itemEnumTypes?.type === "string_enum") {
            option.choices(itemEnumTypes.choices);
          }
          const itemParser = getOptionValueParser(itemsSchema);
          if (itemParser) {
            option.argParser((value2, previous) => {
              const parsed = itemParser(value2);
              return Array.isArray(previous) ? [...previous, parsed] : [parsed];
            });
          }
        }
        if (!option) {
          option = new Option2(`${flags} [json]`, description);
          option.argParser((value2) => parseJson(value2, InvalidOptionArgumentError));
        }
        if (defaultValue.exists && option.defaultValue !== defaultValue.value) {
          option.default(defaultValue.value);
        }
        if (option.flags.includes("<")) {
          option.makeOptionMandatory();
        }
        const enumChoices = getEnumChoices(propertyValue);
        if (enumChoices?.type === "string_enum") {
          option.choices(enumChoices.choices);
        }
        option.conflicts(incompatiblePairs.flatMap((pair) => {
          const filtered = pair.filter((p) => p !== propertyKey);
          if (filtered.length === pair.length)
            return [];
          return filtered;
        }));
        command.addOption(option);
        if (propertyType === "boolean")
          negate();
      };
      Object.entries(optionJsonSchemaProperties).forEach(addOptionForProperty);
      const invalidOptionAliases = Object.entries(unusedOptionAliases).map(([option, alias]) => `${option}: ${alias}`);
      if (invalidOptionAliases.length) {
        throw new Error(`Invalid option aliases: ${invalidOptionAliases.join(", ")}`);
      }
      command.action(async (...args2) => {
        program.__ran ||= [];
        program.__ran.push(command);
        const options = command.opts();
        if (args2.at(-2) !== options) {
          throw new Error(`Unexpected args format, second last arg is not the options object`, { cause: args2 });
        }
        if (args2.at(-1) !== command) {
          throw new Error(`Unexpected args format, last arg is not the Command instance`, { cause: args2 });
        }
        const positionalValues = args2.slice(0, -2);
        const input = parsedProcedure.getPojoInput({ positionalValues, options });
        let caller;
        const deprecatedCreateCaller = Reflect.get(params, "createCallerFactory");
        if (deprecatedCreateCaller) {
          const message = `Using deprecated \`createCallerFactory\` option. Use \`trpcServer\` instead. e.g. \`createCli({router: myRouter, trpcServer: import('@trpc/server')})\``;
          logger.error?.(message);
          caller = deprecatedCreateCaller(router2)(params.context);
        } else if (isOrpcRouter(router2)) {
          const { call: call2 } = getOrpcServerModule();
          caller = { [procedurePath]: (_input) => call2(procedure, _input, { context: params.context }) };
        } else {
          const resolvedTrpcServer = await (params.trpcServer || await import("@trpc/server"));
          const createCallerFactor = resolvedTrpcServer.initTRPC.create().createCallerFactory;
          caller = createCallerFactor(router2)(params.context);
        }
        const result = await caller[procedurePath](input).catch((err) => {
          throw transformError(err, command);
        });
        command.__result = result;
        if (result != null)
          logger.info?.(result);
      });
    };
    procedureEntries.forEach(([procedurePath, commandConfig]) => {
      const segments = procedurePath.split(".");
      let currentPath = "";
      for (let i = 0; i < segments.length - 1; i++) {
        const segment = segments[i];
        const parentPath2 = currentPath;
        currentPath = currentPath ? `${currentPath}.${segment}` : segment;
        if (!commandTree[currentPath]) {
          const parentCommand2 = commandTree[parentPath2];
          const newCommand = new Command2(kebabCase(segment));
          newCommand.showHelpAfterError();
          parentCommand2.addCommand(newCommand);
          commandTree[currentPath] = newCommand;
        }
      }
      const leafName = segments.at(-1);
      const parentPath = segments.length > 1 ? segments.slice(0, -1).join(".") : "";
      const parentCommand = commandTree[parentPath];
      const leafCommand = new Command2(leafName && kebabCase(leafName));
      configureCommand(leafCommand, procedurePath, commandConfig);
      parentCommand.addCommand(leafCommand);
      const meta = commandConfig.meta;
      if (meta.default === true) {
        parentCommand.allowExcessArguments();
        parentCommand.allowUnknownOption();
        parentCommand.addHelpText("after", leafCommand.helpInformation());
        parentCommand.action(async () => {
          await leafCommand.parseAsync([...parentCommand.args], { from: "user" });
        });
        defaultCommands[parentPath] = {
          procedurePath,
          config: commandConfig,
          command: leafCommand
        };
      }
    });
    Object.entries(commandTree).forEach(([path24, command]) => {
      if (command.commands.length === 0)
        return;
      const subcommandNames = command.commands.map((cmd) => cmd.name());
      const defaultCommand = defaultCommands[path24]?.command.name();
      const formattedSubcommands = subcommandNames.map((name25) => name25 === defaultCommand ? `${name25} (default)` : name25).join(", ");
      const existingDescription = command.description() || "";
      const descriptionParts = [existingDescription, `Available subcommands: ${formattedSubcommands}`];
      command.description(descriptionParts.filter(Boolean).join("\n"));
    });
    return program;
  }
  const run = async (runParams, program = buildProgram(runParams)) => {
    if (!looksLikeInstanceof(program, "Command"))
      throw new Error(`program is not a Command instance`);
    const opts = runParams?.argv ? { from: "user" } : void 0;
    const argv = [...runParams?.argv || process.argv];
    const _process = runParams?.process || process;
    const logger = { ...lineByLineConsoleLogger, ...runParams?.logger };
    program.exitOverride((exit) => {
      _process.exit(exit.exitCode);
      throw new FailedToExitError("Root command exitOverride", { exitCode: exit.exitCode, cause: exit });
    });
    program.configureOutput({
      writeOut: (str) => logger.info?.(str),
      writeErr: (str) => logger.error?.(str)
    });
    if (runParams?.completion) {
      const completion = typeof runParams.completion === "function" ? await runParams.completion() : runParams.completion;
      addCompletions(program, completion);
    }
    const formatError3 = runParams?.formatError || ((err) => {
      if (err instanceof CliValidationError) {
        return err.message;
      }
      return inspect2(err);
    });
    if (runParams?.prompts) {
      program = promptify(program, runParams.prompts);
    }
    await program.parseAsync(argv, opts).catch((err) => {
      if (err instanceof FailedToExitError)
        throw err;
      const logMessage = looksLikeInstanceof(err, Error) ? formatError3(err) || err.message : `Non-error of type ${typeof err} thrown: ${err}`;
      logger.error?.(logMessage);
      _process.exit(1);
      throw new FailedToExitError(`Program exit after failure`, { exitCode: 1, cause: err });
    });
    _process.exit(0);
    throw new FailedToExitError("Program exit after success", {
      exitCode: 0,
      cause: program.__ran.at(-1)?.__result
    });
  };
  return { run, buildProgram, toJSON: (program = buildProgram()) => commandToJSON(program) };
}
function getMeta(procedure) {
  const meta = procedure._def.meta;
  return meta?.cliMeta || meta || {};
}
var kebabCase = (str) => str.replaceAll(/([\da-z])([A-Z])/g, "$1-$2").replaceAll(/([A-Z]+)([A-Z][a-z])/g, "$1-$2").toLowerCase();
function transformError(err, command) {
  if (looksLikeInstanceof(err, Error) && err.message.includes("This is a client-only function")) {
    return new Error("Failed to create trpc caller. If using trpc v10, either upgrade to v11 or pass in the `@trpc/server` module to `createCli` explicitly");
  }
  if (looksLikeInstanceof(err, "TRPCError")) {
    const cause = err.cause;
    if (looksLikeStandardSchemaFailure(cause)) {
      const prettyMessage = prettifyStandardSchemaError(cause);
      return new CliValidationError(prettyMessage + "\n\n" + command.helpInformation());
    }
    if (err.code === "BAD_REQUEST" && (err.cause?.constructor?.name === "TraversalError" || // arktype error
    err.cause?.constructor?.name === "StandardSchemaV1Error")) {
      return new CliValidationError(err.cause.message + "\n\n" + command.helpInformation());
    }
    if (err.code === "INTERNAL_SERVER_ERROR") {
      return cause;
    }
  }
  return err;
}
var numberParser = (val, { fallback = val } = {}) => {
  const number = Number(val);
  return Number.isNaN(number) ? fallback : number;
};
var booleanParser = (val, { fallback = val } = {}) => {
  if (val === "true")
    return true;
  if (val === "false")
    return false;
  return fallback;
};
var getOptionValueParser = (schema) => {
  const allowedSchemas = getAllowedSchemas(schema).slice().sort((a, b) => String(getSchemaTypes(a)[0]).localeCompare(String(getSchemaTypes(b)[0])));
  const typesArray = allowedSchemas.flatMap(getSchemaTypes);
  const types = new Set(typesArray);
  return (value2) => {
    const definitelyPrimitive = typesArray.every((t) => t === "boolean" || t === "number" || t === "integer" || t === "string");
    if (types.size === 0 || !definitelyPrimitive) {
      const hint = `Malformed JSON. If passing a string, pass it as a valid JSON string with quotes (${JSON.stringify(value2)})`;
      const parsed = parseJson(value2, InvalidOptionArgumentError, hint);
      if (!types.size)
        return parsed;
      const jsonSchemaType = Array.isArray(parsed) ? "array" : parsed === null ? "null" : typeof parsed;
      if (!types.has(jsonSchemaType)) {
        throw new InvalidOptionArgumentError(`Got ${jsonSchemaType} but expected ${[...types].join(" or ")}`);
      }
      return parsed;
    }
    if (types.has("boolean")) {
      const parsed = booleanParser(value2, { fallback: null });
      if (typeof parsed === "boolean")
        return parsed;
    }
    if (types.has("number")) {
      const parsed = numberParser(value2, { fallback: null });
      if (typeof parsed === "number")
        return parsed;
    }
    if (types.has("integer")) {
      const parsed = numberParser(value2, { fallback: null });
      if (typeof parsed === "number" && Number.isInteger(parsed))
        return parsed;
    }
    if (types.has("string")) {
      return value2;
    }
    throw new InvalidOptionArgumentError(`Got ${JSON.stringify(value2)} but expected ${[...types].join(" or ")}`);
  };
};
var parseJson = (value2, ErrorClass = InvalidArgumentError, hint = `Malformed JSON.`) => {
  try {
    return JSON.parse(value2);
  } catch {
    throw new ErrorClass(hint);
  }
};

// src/node/orpc/router.ts
init_dist5();

// src/common/orpc/schemas/result.ts
import { z } from "zod";
var ResultSchema = (dataSchema, errorSchema = z.string()) => z.discriminatedUnion("success", [
  z.object({ success: z.literal(true), data: dataSchema }),
  z.object({ success: z.literal(false), error: errorSchema })
]);

// src/common/orpc/schemas/runtime.ts
import { z as z3 } from "zod";

// src/common/orpc/schemas/coder.ts
import { z as z2 } from "zod";
var CoderWorkspaceConfigSchema = z2.object({
  /**
   * Coder workspace name.
   * - For new workspaces: omit or undefined (backend derives from mux branch name)
   * - For existing workspaces: required (the selected Coder workspace name)
   * - After creation: populated with the actual Coder workspace name for reference
   */
  workspaceName: z2.string().optional().meta({ description: "Coder workspace name" }),
  template: z2.string().optional().meta({ description: "Template used to create workspace" }),
  templateOrg: z2.string().optional().meta({
    description: "Template organization (for disambiguation when templates have same name)"
  }),
  preset: z2.string().optional().meta({ description: "Preset used during creation" }),
  /** True if connected to pre-existing Coder workspace (vs mux creating one). */
  existingWorkspace: z2.boolean().optional().meta({
    description: "True if connected to pre-existing Coder workspace"
  })
});
var CoderUnavailableReasonSchema = z2.union([
  z2.literal("missing"),
  z2.object({ kind: z2.literal("not-logged-in"), message: z2.string() }),
  z2.object({ kind: z2.literal("error"), message: z2.string() })
]);
var CoderInfoSchema = z2.discriminatedUnion("state", [
  z2.object({
    state: z2.literal("available"),
    version: z2.string(),
    username: z2.string().optional(),
    url: z2.string().optional()
  }),
  z2.object({
    state: z2.literal("outdated"),
    version: z2.string(),
    minVersion: z2.string(),
    binaryPath: z2.string().optional()
  }),
  z2.object({ state: z2.literal("unavailable"), reason: CoderUnavailableReasonSchema })
]);
var CoderTemplateSchema = z2.object({
  name: z2.string(),
  displayName: z2.string(),
  organizationName: z2.string()
});
var CoderPresetSchema = z2.object({
  id: z2.string(),
  name: z2.string(),
  description: z2.string().optional(),
  isDefault: z2.boolean()
});
var CoderWorkspaceStatusSchema = z2.enum([
  "running",
  "stopped",
  "starting",
  "stopping",
  "failed",
  "pending",
  "canceling",
  "canceled",
  "deleting",
  "deleted"
]);
var CoderWorkspaceSchema = z2.object({
  name: z2.string(),
  templateName: z2.string(),
  templateDisplayName: z2.string(),
  status: CoderWorkspaceStatusSchema
});
var CoderListWorkspacesResultSchema = z2.discriminatedUnion("ok", [
  z2.object({ ok: z2.literal(true), workspaces: z2.array(CoderWorkspaceSchema) }),
  z2.object({ ok: z2.literal(false), error: z2.string() })
]);
var CoderListTemplatesResultSchema = z2.discriminatedUnion("ok", [
  z2.object({ ok: z2.literal(true), templates: z2.array(CoderTemplateSchema) }),
  z2.object({ ok: z2.literal(false), error: z2.string() })
]);
var CoderListPresetsResultSchema = z2.discriminatedUnion("ok", [
  z2.object({ ok: z2.literal(true), presets: z2.array(CoderPresetSchema) }),
  z2.object({ ok: z2.literal(false), error: z2.string() })
]);
var coder = {
  getInfo: {
    input: z2.void(),
    output: CoderInfoSchema
  },
  listTemplates: {
    input: z2.void(),
    output: CoderListTemplatesResultSchema
  },
  listPresets: {
    input: z2.object({
      template: z2.string(),
      org: z2.string().optional().meta({ description: "Organization name for disambiguation" })
    }),
    output: CoderListPresetsResultSchema
  },
  listWorkspaces: {
    input: z2.void(),
    output: CoderListWorkspacesResultSchema
  }
};

// src/common/orpc/schemas/runtime.ts
var RuntimeModeSchema = z3.enum(["local", "worktree", "ssh", "docker", "devcontainer"]);
var bgOutputDirField = z3.string().optional().meta({ description: "Directory for background process output (e.g., /tmp/mux-bashes)" });
var DevcontainerConfigInfoSchema = z3.object({
  path: z3.string(),
  label: z3.string()
});
var RuntimeAvailabilityStatusSchema = z3.union([
  // Devcontainer-specific: available with configs (must be first to preserve configs)
  z3.object({
    available: z3.literal(true),
    configs: z3.array(DevcontainerConfigInfoSchema),
    cliVersion: z3.string().optional()
  }),
  // Generic: available without extra data
  z3.object({ available: z3.literal(true) }),
  // Unavailable with reason
  z3.object({ available: z3.literal(false), reason: z3.string() })
]);
var RuntimeAvailabilitySchema = z3.object({
  local: RuntimeAvailabilityStatusSchema,
  worktree: RuntimeAvailabilityStatusSchema,
  ssh: RuntimeAvailabilityStatusSchema,
  docker: RuntimeAvailabilityStatusSchema,
  devcontainer: RuntimeAvailabilityStatusSchema
});
var RuntimeConfigSchema = z3.union([
  // Legacy local with srcBaseDir (treated as worktree)
  z3.object({
    type: z3.literal("local"),
    srcBaseDir: z3.string().meta({
      description: "Base directory where all workspaces are stored (legacy worktree config)"
    }),
    bgOutputDir: bgOutputDirField
  }),
  // New project-dir local (no srcBaseDir)
  z3.object({
    type: z3.literal("local"),
    bgOutputDir: bgOutputDirField
  }),
  // Explicit worktree runtime
  z3.object({
    type: z3.literal("worktree"),
    srcBaseDir: z3.string().meta({ description: "Base directory where all workspaces are stored (e.g., ~/.mux/src)" }),
    bgOutputDir: bgOutputDirField
  }),
  // SSH runtime
  z3.object({
    type: z3.literal("ssh"),
    host: z3.string().meta({ description: "SSH host (can be hostname, user@host, or SSH config alias)" }),
    srcBaseDir: z3.string().meta({ description: "Base directory on remote host where all workspaces are stored" }),
    bgOutputDir: bgOutputDirField,
    identityFile: z3.string().optional().meta({ description: "Path to SSH private key (if not using ~/.ssh/config or ssh-agent)" }),
    port: z3.number().optional().meta({ description: "SSH port (default: 22)" }),
    coder: CoderWorkspaceConfigSchema.optional().meta({
      description: "Coder workspace configuration (when using Coder as SSH backend)"
    })
  }),
  // Docker runtime - each workspace runs in its own container
  z3.object({
    type: z3.literal("docker"),
    image: z3.string().meta({ description: "Docker image to use (e.g., node:20)" }),
    containerName: z3.string().optional().meta({ description: "Container name (populated after workspace creation)" }),
    shareCredentials: z3.boolean().optional().meta({
      description: "Forward SSH agent and mount ~/.gitconfig read-only"
    })
  }),
  // Devcontainer runtime - uses devcontainer CLI to build/run containers from devcontainer.json
  z3.object({
    type: z3.literal("devcontainer"),
    configPath: z3.string().meta({ description: "Path to devcontainer.json (relative to project root)" }),
    shareCredentials: z3.boolean().optional().meta({
      description: "Forward SSH agent and mount ~/.gitconfig read-only"
    })
  })
]);

// src/common/orpc/schemas/project.ts
import { z as z6 } from "zod";

// src/common/orpc/schemas/mcp.ts
import { z as z4 } from "zod";
var WorkspaceMCPOverridesSchema = z4.object({
  /** Server names to explicitly disable for this workspace. */
  disabledServers: z4.array(z4.string()).optional(),
  /** Server names to explicitly enable for this workspace (overrides project-level disabled). */
  enabledServers: z4.array(z4.string()).optional(),
  /**
   * Per-server tool allowlist.
   * Key: server name
   * Value: raw MCP tool names (NOT namespaced)
   *
   * If omitted for a server => expose all tools from that server.
   * If present but empty => expose no tools from that server.
   */
  toolAllowlist: z4.record(z4.string(), z4.array(z4.string())).optional()
});
var MCPTransportSchema = z4.enum(["stdio", "http", "sse", "auto"]);
var MCPHeaderValueSchema = z4.union([z4.string(), z4.object({ secret: z4.string() })]);
var MCPHeadersSchema = z4.record(z4.string(), MCPHeaderValueSchema);
var MCPServerInfoSchema = z4.discriminatedUnion("transport", [
  z4.object({
    transport: z4.literal("stdio"),
    command: z4.string(),
    disabled: z4.boolean(),
    toolAllowlist: z4.array(z4.string()).optional()
  }),
  z4.object({
    transport: z4.literal("http"),
    url: z4.string(),
    headers: MCPHeadersSchema.optional(),
    disabled: z4.boolean(),
    toolAllowlist: z4.array(z4.string()).optional()
  }),
  z4.object({
    transport: z4.literal("sse"),
    url: z4.string(),
    headers: MCPHeadersSchema.optional(),
    disabled: z4.boolean(),
    toolAllowlist: z4.array(z4.string()).optional()
  }),
  z4.object({
    transport: z4.literal("auto"),
    url: z4.string(),
    headers: MCPHeadersSchema.optional(),
    disabled: z4.boolean(),
    toolAllowlist: z4.array(z4.string()).optional()
  })
]);
var MCPServerMapSchema = z4.record(z4.string(), MCPServerInfoSchema);
var MCPListParamsSchema = z4.object({
  projectPath: z4.string().optional()
});
var MCPAddParamsBaseSchema = z4.object({
  name: z4.string(),
  // Backward-compatible: if transport omitted, interpret as stdio.
  transport: MCPTransportSchema.optional(),
  command: z4.string().optional(),
  url: z4.string().optional(),
  headers: MCPHeadersSchema.optional()
});
function refineMcpAddParams(input, ctx) {
  const transport = input.transport ?? "stdio";
  if (transport === "stdio") {
    if (!input.command?.trim()) {
      ctx.addIssue({ code: z4.ZodIssueCode.custom, message: "command is required for stdio" });
    }
    return;
  }
  if (!input.url?.trim()) {
    ctx.addIssue({ code: z4.ZodIssueCode.custom, message: "url is required for http/sse/auto" });
  }
}
var MCPAddGlobalParamsSchema = MCPAddParamsBaseSchema.superRefine(refineMcpAddParams);
var MCPAddParamsSchema = MCPAddParamsBaseSchema.extend({
  projectPath: z4.string()
}).superRefine(refineMcpAddParams);
var MCPRemoveParamsBaseSchema = z4.object({
  name: z4.string()
});
var MCPRemoveGlobalParamsSchema = MCPRemoveParamsBaseSchema;
var MCPRemoveParamsSchema = MCPRemoveParamsBaseSchema.extend({
  projectPath: z4.string()
});
var MCPSetEnabledParamsBaseSchema = z4.object({
  name: z4.string(),
  enabled: z4.boolean()
});
var MCPSetEnabledGlobalParamsSchema = MCPSetEnabledParamsBaseSchema;
var MCPSetEnabledParamsSchema = MCPSetEnabledParamsBaseSchema.extend({
  projectPath: z4.string()
});
var MCPSetToolAllowlistParamsBaseSchema = z4.object({
  name: z4.string(),
  /** Tool names to allow. Empty array = no tools allowed. */
  toolAllowlist: z4.array(z4.string())
});
var MCPSetToolAllowlistGlobalParamsSchema = MCPSetToolAllowlistParamsBaseSchema;
var MCPSetToolAllowlistParamsSchema = MCPSetToolAllowlistParamsBaseSchema.extend({
  projectPath: z4.string()
});
var MCPTestParamsBaseSchema = z4.object({
  name: z4.string().optional(),
  transport: MCPTransportSchema.optional(),
  command: z4.string().optional(),
  url: z4.string().optional(),
  headers: MCPHeadersSchema.optional()
});
function refineMcpTestParams(input, ctx) {
  const hasName = Boolean(input.name?.trim());
  const hasCommand = Boolean(input.command?.trim());
  const hasUrl = Boolean(input.url?.trim());
  if (!hasName && !hasCommand && !hasUrl) {
    ctx.addIssue({
      code: z4.ZodIssueCode.custom,
      message: "Either name, command, or url is required"
    });
    return;
  }
  if (hasUrl) {
    const transport = input.transport;
    if (transport !== "http" && transport !== "sse" && transport !== "auto") {
      ctx.addIssue({
        code: z4.ZodIssueCode.custom,
        message: "transport must be http|sse|auto when testing by url"
      });
    }
  }
}
var MCPTestGlobalParamsSchema = MCPTestParamsBaseSchema.extend({
  projectPath: z4.string().optional()
}).superRefine(refineMcpTestParams);
var MCPTestParamsSchema = MCPTestParamsBaseSchema.extend({
  projectPath: z4.string()
}).superRefine(refineMcpTestParams);
var BearerChallengeSchema = z4.object({
  scope: z4.string().optional(),
  resourceMetadataUrl: z4.url().optional()
});
var MCPTestResultSchema = z4.discriminatedUnion("success", [
  z4.object({ success: z4.literal(true), tools: z4.array(z4.string()) }),
  z4.object({
    success: z4.literal(false),
    error: z4.string(),
    oauthChallenge: BearerChallengeSchema.optional()
  })
]);

// src/common/orpc/schemas/workspaceAiSettings.ts
import { z as z5 } from "zod";
var WorkspaceAISettingsSchema = z5.object({
  model: z5.string().meta({ description: 'Canonical model id in the form "provider:model"' }),
  thinkingLevel: z5.enum(["off", "low", "medium", "high", "xhigh", "max"]).meta({
    description: "Thinking/reasoning effort level"
  })
});
var WorkspaceAISettingsByAgentSchema = z5.record(
  z5.string().min(1),
  WorkspaceAISettingsSchema
);

// src/common/orpc/schemas/project.ts
var ThinkingLevelSchema = z6.enum(["off", "low", "medium", "high", "xhigh", "max"]);
var SectionConfigSchema = z6.object({
  id: z6.string().meta({
    description: "Unique section ID (8 hex chars)"
  }),
  name: z6.string().meta({
    description: "Display name for the section"
  }),
  color: z6.string().optional().meta({
    description: "Accent color (hex value like #ff6b6b or preset name)"
  }),
  nextId: z6.string().nullable().optional().meta({
    description: "ID of the next section in display order (null = last, undefined treated as null)"
  })
});
var WorkspaceConfigSchema = z6.object({
  path: z6.string().meta({
    description: "Absolute path to workspace directory - REQUIRED for backward compatibility"
  }),
  id: z6.string().optional().meta({
    description: "Stable workspace ID (10 hex chars for new workspaces) - optional for legacy"
  }),
  name: z6.string().optional().meta({
    description: 'Git branch / directory name (e.g., "plan-a1b2") - optional for legacy'
  }),
  title: z6.string().optional().meta({
    description: 'Human-readable workspace title (e.g., "Fix plan mode over SSH") - optional for legacy'
  }),
  createdAt: z6.string().optional().meta({ description: "ISO 8601 creation timestamp - optional for legacy" }),
  aiSettingsByAgent: WorkspaceAISettingsByAgentSchema.optional().meta({
    description: "Per-agent workspace-scoped AI settings"
  }),
  runtimeConfig: RuntimeConfigSchema.optional().meta({
    description: "Runtime configuration (local vs SSH) - optional, defaults to local"
  }),
  aiSettings: WorkspaceAISettingsSchema.optional().meta({
    description: "Workspace-scoped AI settings (model + thinking level)"
  }),
  parentWorkspaceId: z6.string().optional().meta({
    description: "If set, this workspace is a child workspace spawned from the parent workspaceId (enables nesting in UI and backend orchestration)."
  }),
  agentType: z6.string().optional().meta({
    description: 'If set, selects an agent preset for this workspace (e.g., "explore" or "exec").'
  }),
  agentId: z6.string().optional().meta({
    description: 'If set, selects an agent definition for this workspace (e.g., "explore" or "exec").'
  }),
  taskStatus: z6.enum(["queued", "running", "awaiting_report", "reported"]).optional().meta({
    description: "Agent task lifecycle status for child workspaces (queued|running|awaiting_report|reported)."
  }),
  reportedAt: z6.string().optional().meta({
    description: "ISO 8601 timestamp for when an agent task reported completion (optional)."
  }),
  taskModelString: z6.string().optional().meta({
    description: "Model string used to run this agent task (used for restart-safe resumptions)."
  }),
  taskThinkingLevel: ThinkingLevelSchema.optional().meta({
    description: "Thinking level used for this agent task (used for restart-safe resumptions)."
  }),
  taskPrompt: z6.string().optional().meta({
    description: "Initial prompt for a queued agent task (persisted only until the task actually starts)."
  }),
  taskExperiments: z6.object({
    programmaticToolCalling: z6.boolean().optional(),
    programmaticToolCallingExclusive: z6.boolean().optional(),
    execSubagentHardRestart: z6.boolean().optional()
  }).optional().meta({
    description: "Experiments inherited from parent for restart-safe resumptions."
  }),
  taskBaseCommitSha: z6.string().optional().meta({
    description: "Git commit SHA this agent task workspace started from (used for generating git-format-patch artifacts)."
  }),
  taskTrunkBranch: z6.string().optional().meta({
    description: "Trunk branch used to create/init this agent task workspace (used for restart-safe init on queued tasks)."
  }),
  mcp: WorkspaceMCPOverridesSchema.optional().meta({
    description: "LEGACY: Per-workspace MCP overrides (migrated to <workspace>/.mux/mcp.local.jsonc)"
  }),
  archivedAt: z6.string().optional().meta({
    description: "ISO 8601 timestamp when workspace was last archived. Workspace is considered archived if archivedAt > unarchivedAt (or unarchivedAt is absent)."
  }),
  unarchivedAt: z6.string().optional().meta({
    description: "ISO 8601 timestamp when workspace was last unarchived. Used for recency calculation to bump restored workspaces to top."
  }),
  sectionId: z6.string().optional().meta({
    description: "ID of the section this workspace belongs to (optional, unsectioned if absent)"
  })
});
var ProjectConfigSchema = z6.object({
  workspaces: z6.array(WorkspaceConfigSchema),
  sections: z6.array(SectionConfigSchema).optional().meta({
    description: "Sections for organizing workspaces within this project"
  }),
  idleCompactionHours: z6.number().min(1).nullable().optional().meta({
    description: "Hours of inactivity before auto-compacting workspaces. null/undefined = disabled."
  })
});

// src/common/orpc/schemas/workspace.ts
import { z as z7 } from "zod";
var ThinkingLevelSchema2 = z7.enum(["off", "low", "medium", "high", "xhigh", "max"]);
var WorkspaceMetadataSchema = z7.object({
  id: z7.string().meta({
    description: "Stable unique identifier (10 hex chars for new workspaces, legacy format for old)"
  }),
  name: z7.string().meta({
    description: 'Git branch / directory name (e.g., "plan-a1b2") - used for path computation'
  }),
  title: z7.string().optional().meta({
    description: 'Human-readable workspace title (e.g., "Fix plan mode over SSH") - optional for legacy workspaces'
  }),
  projectName: z7.string().meta({ description: "Project name extracted from project path (for display)" }),
  projectPath: z7.string().meta({ description: "Absolute path to the project (needed to compute workspace path)" }),
  createdAt: z7.string().optional().meta({
    description: "ISO 8601 timestamp of when workspace was created (optional for backward compatibility)"
  }),
  aiSettingsByAgent: WorkspaceAISettingsByAgentSchema.optional().meta({
    description: "Per-agent AI settings persisted in config"
  }),
  runtimeConfig: RuntimeConfigSchema.meta({
    description: "Runtime configuration for this workspace (always set, defaults to local on load)"
  }),
  aiSettings: WorkspaceAISettingsSchema.optional().meta({
    description: "Workspace-scoped AI settings (model + thinking level) persisted in config"
  }),
  parentWorkspaceId: z7.string().optional().meta({
    description: "If set, this workspace is a child workspace spawned from the parent workspaceId (enables nesting in UI and backend orchestration)."
  }),
  agentType: z7.string().optional().meta({
    description: 'If set, selects an agent preset for this workspace (e.g., "explore" or "exec").'
  }),
  agentId: z7.string().optional().meta({
    description: 'If set, selects an agent definition for this workspace (e.g., "explore" or "exec").'
  }),
  taskStatus: z7.enum(["queued", "running", "awaiting_report", "reported"]).optional().meta({
    description: "Agent task lifecycle status for child workspaces (queued|running|awaiting_report|reported)."
  }),
  reportedAt: z7.string().optional().meta({
    description: "ISO 8601 timestamp for when an agent task reported completion (optional)."
  }),
  taskModelString: z7.string().optional().meta({
    description: "Model string used to run this agent task (used for restart-safe resumptions)."
  }),
  taskThinkingLevel: ThinkingLevelSchema2.optional().meta({
    description: "Thinking level used for this agent task (used for restart-safe resumptions)."
  }),
  taskPrompt: z7.string().optional().meta({
    description: "Initial prompt for a queued agent task (persisted only until the task actually starts)."
  }),
  taskTrunkBranch: z7.string().optional().meta({
    description: "Trunk branch used to create/init this agent task workspace (used for restart-safe init on queued tasks)."
  }),
  archivedAt: z7.string().optional().meta({
    description: "ISO 8601 timestamp when workspace was last archived. Workspace is considered archived if archivedAt > unarchivedAt (or unarchivedAt is absent)."
  }),
  unarchivedAt: z7.string().optional().meta({
    description: "ISO 8601 timestamp when workspace was last unarchived. Used for recency calculation to bump restored workspaces to top."
  }),
  sectionId: z7.string().optional().meta({
    description: "ID of the section this workspace belongs to (optional, unsectioned if absent)"
  })
});
var FrontendWorkspaceMetadataSchema = WorkspaceMetadataSchema.extend({
  namedWorkspacePath: z7.string().meta({ description: "Worktree path (uses workspace name as directory)" }),
  incompatibleRuntime: z7.string().optional().meta({
    description: "If set, this workspace has an incompatible runtime configuration (e.g., from a newer version of mux). The workspace should be displayed but interactions should show this error message."
  }),
  isRemoving: z7.boolean().optional().meta({
    description: "True if this workspace is currently being deleted (deletion in progress)."
  }),
  isInitializing: z7.boolean().optional().meta({
    description: "True if this workspace is currently initializing (postCreateSetup or initWorkspace running)."
  })
});
var WorkspaceActivitySnapshotSchema = z7.object({
  recency: z7.number().meta({ description: "Unix ms timestamp of last user interaction" }),
  streaming: z7.boolean().meta({ description: "Whether workspace currently has an active stream" }),
  lastModel: z7.string().nullable().meta({ description: "Last model sent from this workspace" }),
  lastThinkingLevel: ThinkingLevelSchema2.nullable().meta({
    description: "Last thinking/reasoning level used in this workspace"
  })
});
var PostCompactionStateSchema = z7.object({
  planPath: z7.string().nullable(),
  trackedFilePaths: z7.array(z7.string()),
  excludedItems: z7.array(z7.string())
});
var GitStatusSchema = z7.object({
  /** Current HEAD branch name (empty string if detached HEAD or not a git repo) */
  branch: z7.string(),
  /** Commit divergence relative to origin's primary branch */
  ahead: z7.number(),
  behind: z7.number(),
  dirty: z7.boolean().meta({ description: "Whether there are uncommitted changes (staged or unstaged)" }),
  /**
   * Line deltas for changes unique to this workspace.
   * Computed vs the merge-base with origin's primary branch.
   *
   * Note: outgoing includes committed changes + uncommitted changes (working tree).
   */
  outgoingAdditions: z7.number(),
  outgoingDeletions: z7.number(),
  /** Line deltas for changes that exist on origin's primary branch but not locally */
  incomingAdditions: z7.number(),
  incomingDeletions: z7.number()
});

// src/common/orpc/schemas/workspaceStats.ts
import { z as z10 } from "zod";

// src/common/types/mode.ts
import { z as z8 } from "zod";
var UI_MODE_VALUES = ["plan", "exec"];
var UIModeSchema = z8.enum(UI_MODE_VALUES);
var AGENT_MODE_VALUES = [...UI_MODE_VALUES, "compact"];
var AgentModeSchema = z8.enum(AGENT_MODE_VALUES);

// src/common/orpc/schemas/agentDefinition.ts
import { z as z9 } from "zod";
var AgentDefinitionScopeSchema = z9.enum(["built-in", "project", "global"]);
var AgentIdSchema = z9.string().min(1).max(64).regex(/^[a-z0-9]+(?:[a-z0-9_-]*[a-z0-9])?$/);
var AgentDefinitionUiRequirementSchema = z9.enum(["plan"]);
var ThinkingLevelSchema3 = z9.enum(["off", "low", "medium", "high", "xhigh", "max"]);
var AgentDefinitionUiSchema = z9.object({
  // New: hidden is opt-out. Default: visible.
  hidden: z9.boolean().optional(),
  // Legacy: selectable was opt-in. Keep for backwards compatibility.
  selectable: z9.boolean().optional(),
  // When true, completely hides this agent (useful for disabling built-ins)
  disabled: z9.boolean().optional(),
  // UI color (CSS color value). Inherited from base agent if not specified.
  color: z9.string().min(1).optional(),
  // Requirements for this agent to be selectable in the UI.
  // Enforced in agents.list by toggling uiSelectable.
  requires: z9.array(AgentDefinitionUiRequirementSchema).min(1).optional()
}).strip();
var AgentDefinitionSubagentSchema = z9.object({
  runnable: z9.boolean().optional(),
  // Instructions appended when this agent runs as a subagent (child workspace)
  append_prompt: z9.string().min(1).optional(),
  // When true, do not run the project's .mux/init hook for this sub-agent.
  // NOTE: This skips only the hook execution, not runtime provisioning (e.g. SSH sync, Docker setup).
  skip_init_hook: z9.boolean().optional()
}).strip();
var AgentDefinitionAiDefaultsSchema = z9.object({
  // Model identifier: full string (e.g. "anthropic:claude-sonnet-4-5") or abbreviation (e.g. "sonnet")
  model: z9.string().min(1).optional(),
  thinkingLevel: ThinkingLevelSchema3.optional()
}).strip();
var AgentDefinitionPromptSchema = z9.object({
  // When true, append this agent's body to the base agent's body (default: false = replace)
  append: z9.boolean().optional()
}).strip();
var AgentDefinitionToolsSchema = z9.object({
  // Patterns to add (enable). Processed before remove.
  add: z9.array(z9.string().min(1)).optional(),
  // Patterns to remove (disable). Processed after add.
  remove: z9.array(z9.string().min(1)).optional()
}).strip();
var AgentDefinitionFrontmatterSchema = z9.object({
  name: z9.string().min(1).max(128),
  description: z9.string().min(1).max(1024).optional(),
  // Inheritance: reference a built-in or custom agent ID
  base: AgentIdSchema.optional(),
  // When true, this agent is disabled by default.
  //
  // Notes:
  // - This is a top-level flag (separate from ui.disabled) so repos can ship agents that are
  //   present on disk but opt-in.
  // - When both are set, `disabled` takes precedence over `ui.disabled`.
  disabled: z9.boolean().optional(),
  // UI metadata (color, visibility, etc.)
  ui: AgentDefinitionUiSchema.optional(),
  // Prompt behavior configuration
  prompt: AgentDefinitionPromptSchema.optional(),
  subagent: AgentDefinitionSubagentSchema.optional(),
  ai: AgentDefinitionAiDefaultsSchema.optional(),
  // Tool configuration: add/remove patterns (regex).
  // If omitted and no base, no tools are available.
  tools: AgentDefinitionToolsSchema.optional()
}).strip();
var AgentDefinitionDescriptorSchema = z9.object({
  id: AgentIdSchema,
  scope: AgentDefinitionScopeSchema,
  name: z9.string().min(1).max(128),
  description: z9.string().min(1).max(1024).optional(),
  uiSelectable: z9.boolean(),
  uiColor: z9.string().min(1).optional(),
  subagentRunnable: z9.boolean(),
  // Base agent ID for inheritance (e.g., "exec", "plan", or custom agent)
  base: AgentIdSchema.optional(),
  aiDefaults: AgentDefinitionAiDefaultsSchema.optional(),
  // Tool configuration (for UI display / inheritance computation)
  tools: AgentDefinitionToolsSchema.optional()
}).strict();
var AgentDefinitionPackageSchema = z9.object({
  id: AgentIdSchema,
  scope: AgentDefinitionScopeSchema,
  frontmatter: AgentDefinitionFrontmatterSchema,
  body: z9.string()
}).strict();

// src/common/orpc/schemas/workspaceStats.ts
var ModeSchema = AgentModeSchema.optional().catch(void 0);
var AgentIdStatsSchema = AgentIdSchema.optional().catch(void 0);
var TimingAnomalySchema = z10.enum([
  "negative_duration",
  "tool_gt_total",
  "ttft_gt_total",
  "percent_out_of_range",
  "nan"
]);
var ActiveStreamStatsSchema = z10.object({
  messageId: z10.string(),
  model: z10.string(),
  mode: ModeSchema,
  agentId: AgentIdStatsSchema,
  elapsedMs: z10.number(),
  ttftMs: z10.number().nullable(),
  toolExecutionMs: z10.number(),
  modelTimeMs: z10.number(),
  streamingMs: z10.number(),
  outputTokens: z10.number(),
  reasoningTokens: z10.number(),
  /** Total tokens streamed so far (text + reasoning + tool args). */
  liveTokenCount: z10.number(),
  /** Tokens/sec, trailing window. */
  liveTPS: z10.number(),
  invalid: z10.boolean(),
  anomalies: z10.array(TimingAnomalySchema)
});
var CompletedStreamStatsSchema = z10.object({
  messageId: z10.string(),
  model: z10.string(),
  mode: ModeSchema,
  agentId: AgentIdStatsSchema,
  totalDurationMs: z10.number(),
  ttftMs: z10.number().nullable(),
  toolExecutionMs: z10.number(),
  modelTimeMs: z10.number(),
  streamingMs: z10.number(),
  outputTokens: z10.number(),
  reasoningTokens: z10.number(),
  invalid: z10.boolean(),
  anomalies: z10.array(TimingAnomalySchema)
});
var ModelTimingStatsSchema = z10.object({
  model: z10.string(),
  mode: ModeSchema,
  agentId: AgentIdStatsSchema,
  totalDurationMs: z10.number(),
  totalToolExecutionMs: z10.number(),
  totalStreamingMs: z10.number(),
  totalTtftMs: z10.number(),
  ttftCount: z10.number(),
  responseCount: z10.number(),
  totalOutputTokens: z10.number(),
  totalReasoningTokens: z10.number()
});
var SessionTimingStatsSchema = z10.object({
  totalDurationMs: z10.number(),
  totalToolExecutionMs: z10.number(),
  totalStreamingMs: z10.number(),
  totalTtftMs: z10.number(),
  ttftCount: z10.number(),
  responseCount: z10.number(),
  totalOutputTokens: z10.number(),
  totalReasoningTokens: z10.number(),
  /**
   * Per-model breakdown.
   *
   * Key is a stable identifier like normalizeGatewayModel(model) or model:agentId (fallback: model:mode).
   */
  byModel: z10.record(z10.string(), ModelTimingStatsSchema)
});
var WorkspaceStatsSnapshotSchema = z10.object({
  workspaceId: z10.string(),
  generatedAt: z10.number(),
  active: ActiveStreamStatsSchema.optional(),
  lastRequest: CompletedStreamStatsSchema.optional(),
  session: SessionTimingStatsSchema.optional()
});
var SessionTimingFileSchema = z10.object({
  version: z10.literal(2),
  lastRequest: CompletedStreamStatsSchema.optional(),
  session: SessionTimingStatsSchema,
  /**
   * Idempotency ledger for rolled-up sub-agent timing.
   *
   * When a child workspace is deleted, we merge its session timing into the parent.
   * This tracks which children have already been merged to prevent double-counting
   * if removal is retried.
   */
  rolledUpFrom: z10.record(z10.string(), z10.literal(true)).optional()
});

// src/common/orpc/schemas/chatStats.ts
import { z as z11 } from "zod";
var TopFilePathSchema = z11.object({
  path: z11.string().meta({ description: "File path (relative or absolute)" }),
  tokens: z11.number().meta({ description: "Token count for this file" })
});
var TokenConsumerSchema = z11.object({
  name: z11.string().meta({ description: '"User", "Assistant", "bash", "readFile", etc.' }),
  tokens: z11.number().meta({ description: "Total token count for this consumer" }),
  percentage: z11.number().meta({ description: "% of total tokens" }),
  fixedTokens: z11.number().optional().meta({ description: "Fixed overhead (e.g., tool definitions)" }),
  variableTokens: z11.number().optional().meta({ description: "Variable usage (e.g., actual tool calls, text)" })
});
var ChatUsageComponentSchema = z11.object({
  tokens: z11.number(),
  cost_usd: z11.number().optional()
});
var ChatUsageDisplaySchema = z11.object({
  input: ChatUsageComponentSchema,
  cached: ChatUsageComponentSchema,
  cacheCreate: ChatUsageComponentSchema,
  output: ChatUsageComponentSchema,
  reasoning: ChatUsageComponentSchema,
  model: z11.string().optional()
});
var ChatStatsSchema = z11.object({
  consumers: z11.array(TokenConsumerSchema).meta({ description: "Sorted descending by token count" }),
  totalTokens: z11.number(),
  model: z11.string(),
  tokenizerName: z11.string().meta({ description: 'e.g., "o200k_base", "claude"' }),
  usageHistory: z11.array(ChatUsageDisplaySchema).meta({ description: "Ordered array of actual usage statistics from API responses" }),
  topFilePaths: z11.array(TopFilePathSchema).optional().meta({ description: "Top 10 files by token count aggregated across all file tools" })
});
var SessionUsageTokenStatsCacheSchema = z11.object({
  version: z11.literal(1),
  computedAt: z11.number().meta({ description: "Unix timestamp (ms) when this cache was computed" }),
  model: z11.string().meta({ description: "Model used for tokenization (affects tokenizer + tool definitions)" }),
  tokenizerName: z11.string().meta({ description: 'e.g., "o200k_base", "claude"' }),
  history: z11.object({
    messageCount: z11.number().meta({ description: "Number of messages used to compute this cache" }),
    maxHistorySequence: z11.number().optional().meta({ description: "Max MuxMessage.metadata.historySequence seen in the message list" })
  }),
  consumers: z11.array(TokenConsumerSchema).meta({ description: "Sorted descending by token count" }),
  totalTokens: z11.number(),
  topFilePaths: z11.array(TopFilePathSchema).optional().meta({ description: "Top 10 files by token count aggregated across all file tools" })
});
var SessionUsageFileSchema = z11.object({
  byModel: z11.record(z11.string(), ChatUsageDisplaySchema),
  lastRequest: z11.object({
    model: z11.string(),
    usage: ChatUsageDisplaySchema,
    timestamp: z11.number()
  }).optional(),
  /**
   * Idempotency ledger for rolled-up sub-agent usage.
   * Key: child workspaceId, value: true.
   */
  rolledUpFrom: z11.record(z11.string(), z11.literal(true)).optional(),
  tokenStatsCache: SessionUsageTokenStatsCacheSchema.optional(),
  version: z11.literal(1)
});

// src/common/orpc/schemas/agentSkill.ts
import { z as z12 } from "zod";
var AgentSkillScopeSchema = z12.enum(["project", "global", "built-in"]);
var SkillNameSchema = z12.string().min(1).max(64).regex(/^[a-z0-9]+(?:-[a-z0-9]+)*$/);
var AgentSkillFrontmatterSchema = z12.object({
  name: SkillNameSchema,
  description: z12.string().min(1).max(1024),
  license: z12.string().optional(),
  compatibility: z12.string().min(1).max(500).optional(),
  metadata: z12.record(z12.string(), z12.string()).optional(),
  // When false, skill is NOT listed in the tool description's skill index.
  // Unadvertised skills can still be invoked via /skill-name or agent_skill_read({ name: "skill-name" }).
  // Use for internal orchestration skills, sub-agent-only skills, or power-user workflows.
  advertise: z12.boolean().optional()
});
var AgentSkillDescriptorSchema = z12.object({
  name: SkillNameSchema,
  description: z12.string().min(1).max(1024),
  scope: AgentSkillScopeSchema,
  advertise: z12.boolean().optional()
});
var AgentSkillPackageSchema = z12.object({
  scope: AgentSkillScopeSchema,
  directoryName: SkillNameSchema,
  frontmatter: AgentSkillFrontmatterSchema,
  body: z12.string()
}).refine((value2) => value2.directoryName === value2.frontmatter.name, {
  message: "SKILL.md frontmatter.name must match the parent directory name",
  path: ["frontmatter", "name"]
});
var AgentSkillIssueSchema = z12.object({
  /** Directory name under the skills root (may be invalid / non-kebab-case). */
  directoryName: z12.string().min(1),
  scope: AgentSkillScopeSchema,
  /** User-facing path to the problematic skill (typically .../<dir>/SKILL.md). */
  displayPath: z12.string().min(1),
  /** What went wrong while trying to load the skill. */
  message: z12.string().min(1),
  /** Optional fix suggestion. */
  hint: z12.string().min(1).optional()
});

// src/common/orpc/schemas/errors.ts
import { z as z13 } from "zod";
var SendMessageErrorSchema = z13.discriminatedUnion("type", [
  z13.object({ type: z13.literal("api_key_not_found"), provider: z13.string() }),
  z13.object({ type: z13.literal("oauth_not_connected"), provider: z13.string() }),
  z13.object({ type: z13.literal("provider_not_supported"), provider: z13.string() }),
  z13.object({ type: z13.literal("invalid_model_string"), message: z13.string() }),
  z13.object({ type: z13.literal("incompatible_workspace"), message: z13.string() }),
  z13.object({ type: z13.literal("runtime_not_ready"), message: z13.string() }),
  z13.object({ type: z13.literal("runtime_start_failed"), message: z13.string() }),
  // Transient - retryable
  z13.object({ type: z13.literal("policy_denied"), message: z13.string() }),
  z13.object({ type: z13.literal("unknown"), raw: z13.string() })
]);
var StreamErrorTypeSchema = z13.enum([
  "authentication",
  // API key issues, 401 errors
  "rate_limit",
  // 429 rate limiting
  "server_error",
  // 5xx server errors
  "api",
  // Generic API errors
  "retry_failed",
  // Retry exhausted
  "aborted",
  // User aborted
  "network",
  // Network/fetch errors
  "context_exceeded",
  // Context length/token limit exceeded
  "quota",
  // Usage quota/billing limits
  "model_not_found",
  // Model does not exist
  "runtime_not_ready",
  // Container/runtime doesn't exist or failed to start (permanent)
  "runtime_start_failed",
  // Runtime is starting or temporarily unavailable (retryable)
  "unknown"
  // Catch-all
]);

// src/common/orpc/schemas/tools.ts
import { z as z14 } from "zod";
var ToolOutputUiOnlySchema = z14.object({
  ask_user_question: z14.object({
    questions: z14.array(z14.unknown()),
    answers: z14.record(z14.string(), z14.string())
  }).optional(),
  file_edit: z14.object({
    diff: z14.string()
  }).optional(),
  notify: z14.object({
    notifiedVia: z14.enum(["electron", "browser"]),
    workspaceId: z14.string().optional()
  }).optional()
});
var ToolOutputUiOnlyFieldSchema = {
  ui_only: ToolOutputUiOnlySchema.optional()
};
var BashToolResultSchema = z14.discriminatedUnion("success", [
  z14.object({
    success: z14.literal(true),
    wall_duration_ms: z14.number(),
    output: z14.string(),
    exitCode: z14.literal(0),
    note: z14.string().optional(),
    truncated: z14.object({
      reason: z14.string(),
      totalLines: z14.number()
    }).optional()
  }).extend(ToolOutputUiOnlyFieldSchema),
  z14.object({
    success: z14.literal(false),
    wall_duration_ms: z14.number(),
    output: z14.string().optional(),
    exitCode: z14.number(),
    error: z14.string(),
    note: z14.string().optional(),
    truncated: z14.object({
      reason: z14.string(),
      totalLines: z14.number()
    }).optional()
  }).extend(ToolOutputUiOnlyFieldSchema)
]);
var FileTreeNodeSchema = z14.object({
  name: z14.string(),
  path: z14.string(),
  isDirectory: z14.boolean(),
  get children() {
    return z14.array(FileTreeNodeSchema);
  },
  /** Whether this file/directory is gitignored */
  ignored: z14.boolean().optional(),
  stats: z14.object({
    filePath: z14.string(),
    additions: z14.number(),
    deletions: z14.number()
  }).optional(),
  totalStats: z14.object({
    filePath: z14.string(),
    additions: z14.number(),
    deletions: z14.number()
  }).optional()
});

// src/common/orpc/schemas/secrets.ts
import { z as z15 } from "zod";
var SecretValueSchema = z15.union([
  z15.string(),
  z15.object({
    secret: z15.string()
  }).strict()
]);
var SecretSchema = z15.object({
  key: z15.string(),
  value: SecretValueSchema
}).meta({
  description: "A key-value pair for storing sensitive configuration"
});

// src/common/orpc/schemas/policy.ts
import { z as z51 } from "zod";

// src/common/constants/providers.ts
var PROVIDER_DEFINITIONS = {
  "mux-gateway": {
    displayName: "Mux Gateway",
    import: () => Promise.resolve().then(() => (init_dist10(), dist_exports2)),
    factoryName: "createGateway",
    requiresApiKey: true,
    // Uses couponCode
    strokeBasedIcon: true
  },
  anthropic: {
    displayName: "Anthropic",
    import: () => Promise.resolve().then(() => (init_dist11(), dist_exports3)),
    factoryName: "createAnthropic",
    requiresApiKey: true
  },
  openai: {
    displayName: "OpenAI",
    import: () => Promise.resolve().then(() => (init_dist12(), dist_exports4)),
    factoryName: "createOpenAI",
    requiresApiKey: true
  },
  google: {
    displayName: "Google",
    import: () => Promise.resolve().then(() => (init_dist13(), dist_exports5)),
    factoryName: "createGoogleGenerativeAI",
    requiresApiKey: true
  },
  xai: {
    displayName: "xAI",
    import: () => Promise.resolve().then(() => (init_dist15(), dist_exports7)),
    factoryName: "createXai",
    requiresApiKey: true
  },
  deepseek: {
    displayName: "DeepSeek",
    import: () => Promise.resolve().then(() => (init_dist16(), dist_exports8)),
    factoryName: "createDeepSeek",
    requiresApiKey: true
  },
  openrouter: {
    displayName: "OpenRouter",
    import: () => Promise.resolve().then(() => (init_dist17(), dist_exports9)),
    factoryName: "createOpenRouter",
    requiresApiKey: true
  },
  "github-copilot": {
    displayName: "GitHub Copilot",
    import: () => Promise.resolve().then(() => (init_dist14(), dist_exports6)),
    factoryName: "createOpenAICompatible",
    requiresApiKey: true
  },
  bedrock: {
    displayName: "Bedrock",
    import: () => Promise.resolve().then(() => (init_dist18(), dist_exports10)),
    factoryName: "createAmazonBedrock",
    requiresApiKey: false
    // Uses AWS credential chain
  },
  ollama: {
    displayName: "Ollama",
    import: () => Promise.resolve().then(() => (init_dist19(), dist_exports11)),
    factoryName: "createOllama",
    requiresApiKey: false
    // Local service
  },
  "local-gateway": {
    displayName: "Local Gateway",
    import: () => Promise.resolve().then(() => (init_dist14(), dist_exports6)),
    factoryName: "createOpenAICompatible",
    requiresApiKey: true,
    strokeBasedIcon: true
  }
};
var SUPPORTED_PROVIDERS = Object.keys(PROVIDER_DEFINITIONS);
var PROVIDER_DISPLAY_NAMES = Object.fromEntries(
  Object.entries(PROVIDER_DEFINITIONS).map(([key, def]) => [key, def.displayName])
);
var PROVIDER_REGISTRY = Object.fromEntries(
  Object.entries(PROVIDER_DEFINITIONS).map(([key, def]) => [key, def.import])
);

// src/common/orpc/schemas/policy.ts
var PolicyFormatVersionSchema = z51.literal("0.1");
var PolicyProviderNameSchema = z51.enum(
  SUPPORTED_PROVIDERS
);
var PolicyProviderAccessSchema = z51.object({
  id: PolicyProviderNameSchema,
  // Empty/undefined means "do not force".
  base_url: z51.string().optional(),
  // Empty/undefined means "allow all".
  model_access: z51.array(z51.string()).optional()
}).strict();
var PolicyAllowUserDefinedMCPSchema = z51.object({
  stdio: z51.boolean(),
  remote: z51.boolean()
}).strict();
var PolicyToolsSchema = z51.object({
  allow_user_defined_mcp: PolicyAllowUserDefinedMCPSchema.optional()
}).strict();
var PolicyRuntimeIdSchema = z51.enum([
  "local",
  "worktree",
  "ssh",
  "ssh+coder",
  "docker",
  "devcontainer"
]);
var PolicyRuntimeAccessSchema = z51.object({
  id: PolicyRuntimeIdSchema
}).strict();
var PolicyFileSchema = z51.object({
  policy_format_version: PolicyFormatVersionSchema,
  server_version: z51.string().optional(),
  minimum_client_version: z51.string().optional(),
  // Empty/undefined means "allow all".
  provider_access: z51.array(PolicyProviderAccessSchema).optional(),
  tools: PolicyToolsSchema.optional(),
  // Empty/undefined means "allow all".
  runtimes: z51.array(PolicyRuntimeAccessSchema).optional()
}).strict();
var PolicyStatusSchema = z51.object({
  state: z51.enum(["disabled", "enforced", "blocked"]),
  reason: z51.string().optional()
}).strict();
var PolicySourceSchema = z51.enum(["none", "env", "governor"]);
var EffectivePolicyProviderAccessSchema = z51.object({
  id: PolicyProviderNameSchema,
  forcedBaseUrl: z51.string().optional(),
  // null means "allow all" for that provider.
  allowedModels: z51.array(z51.string()).nullable().optional()
}).strict();
var EffectivePolicySchema = z51.object({
  policyFormatVersion: PolicyFormatVersionSchema,
  serverVersion: z51.string().optional(),
  minimumClientVersion: z51.string().optional(),
  // null means "allow all providers".
  providerAccess: z51.array(EffectivePolicyProviderAccessSchema).nullable(),
  mcp: z51.object({
    allowUserDefined: z51.object({ stdio: z51.boolean(), remote: z51.boolean() }).strict()
  }).strict(),
  // null means "allow all runtimes".
  runtimes: z51.array(PolicyRuntimeIdSchema).nullable()
}).strict();
var PolicyGetResponseSchema = z51.object({
  source: PolicySourceSchema,
  status: PolicyStatusSchema,
  policy: EffectivePolicySchema.nullable()
}).strict();

// src/common/orpc/schemas/providerOptions.ts
import { z as z60 } from "zod";
var MuxProviderOptionsSchema = z60.object({
  anthropic: z60.object({
    // Deprecated: prefer use1MContextModels for per-model control.
    // Kept for backward compat with agentSession auto-retry which sets it directly.
    use1MContext: z60.boolean().optional().meta({
      description: "Enable 1M context window globally (deprecated: use use1MContextModels)"
    }),
    use1MContextModels: z60.array(z60.string()).optional().meta({
      description: "Model IDs with 1M context enabled (e.g. ['anthropic:claude-sonnet-4-20250514'])"
    })
  }).optional(),
  openai: z60.object({
    serviceTier: z60.enum(["auto", "default", "flex", "priority"]).optional().meta({
      description: "OpenAI service tier: priority (low-latency), flex (50% cheaper, higher latency), auto/default (standard)"
    }),
    forceContextLimitError: z60.boolean().optional().meta({
      description: "Force context limit error (used in integration tests to simulate overflow)"
    }),
    simulateToolPolicyNoop: z60.boolean().optional().meta({
      description: "Simulate successful response without executing tools (used in tool policy tests)"
    })
  }).optional(),
  google: z60.record(z60.string(), z60.unknown()).optional(),
  ollama: z60.record(z60.string(), z60.unknown()).optional(),
  openrouter: z60.record(z60.string(), z60.unknown()).optional(),
  xai: z60.object({
    searchParameters: z60.object({
      mode: z60.enum(["auto", "off", "on"]),
      returnCitations: z60.boolean().optional(),
      fromDate: z60.string().optional(),
      toDate: z60.string().optional(),
      maxSearchResults: z60.number().optional(),
      sources: z60.array(
        z60.discriminatedUnion("type", [
          z60.object({
            type: z60.literal("web"),
            country: z60.string().optional(),
            excludedWebsites: z60.array(z60.string()).optional(),
            allowedWebsites: z60.array(z60.string()).optional(),
            safeSearch: z60.boolean().optional()
          }),
          z60.object({
            type: z60.literal("x"),
            excludedXHandles: z60.array(z60.string()).optional(),
            includedXHandles: z60.array(z60.string()).optional(),
            postFavoriteCount: z60.number().optional(),
            postViewCount: z60.number().optional(),
            xHandles: z60.array(z60.string()).optional()
          }),
          z60.object({
            type: z60.literal("news"),
            country: z60.string().optional(),
            excludedWebsites: z60.array(z60.string()).optional(),
            safeSearch: z60.boolean().optional()
          }),
          z60.object({
            type: z60.literal("rss"),
            links: z60.array(z60.string())
          })
        ])
      ).optional()
    }).optional()
  }).optional()
});

// src/common/orpc/schemas/uiLayouts.ts
import { z as z61 } from "zod";
var KeybindSchema = z61.object({
  key: z61.string().min(1),
  allowShift: z61.boolean().optional(),
  ctrl: z61.boolean().optional(),
  shift: z61.boolean().optional(),
  alt: z61.boolean().optional(),
  meta: z61.boolean().optional(),
  macCtrlBehavior: z61.enum(["either", "command", "control"]).optional()
}).strict();
var RightSidebarPresetBaseTabSchema = z61.enum(["costs", "review", "explorer", "stats"]);
var RightSidebarPresetTabSchema = z61.union([
  RightSidebarPresetBaseTabSchema,
  z61.string().min("terminal_new:".length + 1).regex(/^terminal_new:.+$/)
]);
var RightSidebarLayoutPresetNodeSchema = z61.lazy(
  () => {
    const tabset = z61.object({
      type: z61.literal("tabset"),
      id: z61.string().min(1),
      tabs: z61.array(RightSidebarPresetTabSchema),
      activeTab: RightSidebarPresetTabSchema
    }).strict();
    const split = z61.object({
      type: z61.literal("split"),
      id: z61.string().min(1),
      direction: z61.enum(["horizontal", "vertical"]),
      sizes: z61.tuple([z61.number(), z61.number()]),
      children: z61.tuple([RightSidebarLayoutPresetNodeSchema, RightSidebarLayoutPresetNodeSchema])
    }).strict();
    return z61.union([split, tabset]);
  }
);
var RightSidebarLayoutPresetStateSchema = z61.object({
  version: z61.literal(1),
  nextId: z61.number().int(),
  focusedTabsetId: z61.string().min(1),
  root: RightSidebarLayoutPresetNodeSchema
}).strict();
var RightSidebarWidthPresetSchema = z61.discriminatedUnion("mode", [
  z61.object({
    mode: z61.literal("px"),
    value: z61.number().int()
  }).strict(),
  z61.object({
    mode: z61.literal("fraction"),
    value: z61.number()
  }).strict()
]);
var LayoutPresetSchema = z61.object({
  id: z61.string().min(1),
  name: z61.string().min(1),
  leftSidebarCollapsed: z61.boolean(),
  leftSidebarWidthPx: z61.number().int().optional(),
  rightSidebar: z61.object({
    collapsed: z61.boolean(),
    width: RightSidebarWidthPresetSchema,
    layout: RightSidebarLayoutPresetStateSchema
  }).strict()
}).strict();
var LayoutSlotSchema = z61.object({
  slot: z61.number().int().min(1),
  preset: LayoutPresetSchema.optional(),
  keybindOverride: KeybindSchema.optional()
}).strict();
var LayoutPresetsConfigSchema = z61.object({
  version: z61.literal(2),
  slots: z61.array(LayoutSlotSchema)
}).strict();

// src/common/orpc/schemas/terminal.ts
import { z as z70 } from "zod";
var TerminalSessionSchema = z70.object({
  sessionId: z70.string(),
  workspaceId: z70.string(),
  cols: z70.number(),
  rows: z70.number()
});
var TerminalCreateParamsSchema = z70.object({
  workspaceId: z70.string(),
  cols: z70.number(),
  rows: z70.number(),
  /** Optional command to run immediately after terminal creation */
  initialCommand: z70.string().optional()
});
var TerminalResizeParamsSchema = z70.object({
  sessionId: z70.string(),
  cols: z70.number(),
  rows: z70.number()
});

// src/common/orpc/schemas/message.ts
import { z as z71 } from "zod";
var FilePartSchema = z71.object({
  url: z71.string(),
  mediaType: z71.string(),
  filename: z71.string().optional()
});
var MuxTextPartSchema = z71.object({
  type: z71.literal("text"),
  text: z71.string(),
  timestamp: z71.number().optional()
});
var MuxReasoningPartSchema = z71.object({
  type: z71.literal("reasoning"),
  text: z71.string(),
  timestamp: z71.number().optional()
});
var MuxToolPartBase = z71.object({
  type: z71.literal("dynamic-tool"),
  toolCallId: z71.string(),
  toolName: z71.string(),
  input: z71.unknown(),
  timestamp: z71.number().optional()
});
var NestedToolCallSchema = z71.object({
  toolCallId: z71.string(),
  toolName: z71.string(),
  input: z71.unknown(),
  output: z71.unknown().optional(),
  state: z71.enum(["input-available", "output-available", "output-redacted"]),
  timestamp: z71.number().optional()
});
var DynamicToolPartPendingSchema = MuxToolPartBase.extend({
  state: z71.literal("input-available"),
  nestedCalls: z71.array(NestedToolCallSchema).optional()
});
var DynamicToolPartAvailableSchema = MuxToolPartBase.extend({
  state: z71.literal("output-available"),
  output: z71.unknown(),
  nestedCalls: z71.array(NestedToolCallSchema).optional()
});
var DynamicToolPartRedactedSchema = MuxToolPartBase.extend({
  state: z71.literal("output-redacted"),
  nestedCalls: z71.array(NestedToolCallSchema).optional()
});
var DynamicToolPartSchema = z71.discriminatedUnion("state", [
  DynamicToolPartAvailableSchema,
  DynamicToolPartPendingSchema,
  DynamicToolPartRedactedSchema
]);
var MuxToolPartSchema = DynamicToolPartSchema;
var MuxFilePartSchema = FilePartSchema.extend({
  type: z71.literal("file")
});
var CompactionEpochSchema = z71.optional(
  z71.preprocess(
    (value2) => typeof value2 === "number" && Number.isInteger(value2) && value2 > 0 ? value2 : void 0,
    z71.number().int().positive().or(z71.undefined())
  )
);
var MuxMessageSchema = z71.object({
  id: z71.string(),
  role: z71.enum(["system", "user", "assistant"]),
  parts: z71.array(
    z71.discriminatedUnion("type", [
      MuxTextPartSchema,
      MuxReasoningPartSchema,
      MuxToolPartSchema,
      MuxFilePartSchema
    ])
  ),
  createdAt: z71.date().optional(),
  metadata: z71.object({
    historySequence: z71.number().optional(),
    timestamp: z71.number().optional(),
    model: z71.string().optional(),
    thinkingLevel: z71.enum(["off", "low", "medium", "high", "xhigh", "max"]).optional(),
    routedThroughGateway: z71.boolean().optional(),
    usage: z71.any().optional(),
    contextUsage: z71.any().optional(),
    providerMetadata: z71.record(z71.string(), z71.unknown()).optional(),
    contextProviderMetadata: z71.record(z71.string(), z71.unknown()).optional(),
    duration: z71.number().optional(),
    systemMessageTokens: z71.number().optional(),
    muxMetadata: z71.any().optional(),
    cmuxMetadata: z71.any().optional(),
    // Legacy field for backward compatibility
    // Compaction source: "user" (manual), "idle" (auto), or legacy boolean (true)
    compacted: z71.union([z71.literal("user"), z71.literal("idle"), z71.boolean()]).optional(),
    // Monotonic compaction epoch id. Incremented whenever compaction succeeds.
    // Self-healing read path: malformed persisted compactionEpoch is ignored.
    compactionEpoch: CompactionEpochSchema,
    // Durable boundary marker for compaction summaries.
    compactionBoundary: z71.boolean().optional(),
    toolPolicy: z71.any().optional(),
    agentId: AgentIdSchema.optional().catch(void 0),
    partial: z71.boolean().optional(),
    synthetic: z71.boolean().optional(),
    uiVisible: z71.boolean().optional(),
    agentSkillSnapshot: z71.object({
      skillName: SkillNameSchema,
      scope: AgentSkillScopeSchema,
      sha256: z71.string(),
      frontmatterYaml: z71.string().optional()
    }).optional(),
    error: z71.string().optional(),
    errorType: StreamErrorTypeSchema.optional()
  }).optional()
});
var BranchListResultSchema = z71.object({
  branches: z71.array(z71.string()),
  /** Recommended trunk branch, or null for non-git directories */
  recommendedTrunk: z71.string().nullable()
});

// src/common/orpc/schemas/stream.ts
import { z as z80 } from "zod";

// src/common/types/thinking.ts
var THINKING_LEVELS = ["off", "low", "medium", "high", "xhigh", "max"];
function isThinkingLevel(value2) {
  return typeof value2 === "string" && THINKING_LEVELS.includes(value2);
}
var THINKING_LEVEL_SYNONYMS = {
  med: "medium"
};
function coerceThinkingLevel(value2) {
  if (typeof value2 !== "string") return void 0;
  const synonym = THINKING_LEVEL_SYNONYMS[value2];
  if (synonym) return synonym;
  return isThinkingLevel(value2) ? value2 : void 0;
}

// src/common/orpc/schemas/stream.ts
var HeartbeatEventSchema = z80.object({
  type: z80.literal("heartbeat")
});
var CaughtUpMessageSchema = z80.object({
  type: z80.literal("caught-up")
});
var RuntimeStatusEventSchema = z80.object({
  type: z80.literal("runtime-status"),
  workspaceId: z80.string(),
  phase: z80.enum(["checking", "starting", "waiting", "ready", "error"]),
  runtimeType: RuntimeModeSchema,
  detail: z80.string().optional()
  // Human-readable status like "Starting Coder workspace..."
});
var IdleCompactionNeededEventSchema = z80.object({
  type: z80.literal("idle-compaction-needed")
});
var StreamErrorMessageSchema = z80.object({
  type: z80.literal("stream-error"),
  messageId: z80.string(),
  error: z80.string(),
  errorType: StreamErrorTypeSchema
});
var DeleteMessageSchema = z80.object({
  type: z80.literal("delete"),
  historySequences: z80.array(z80.number())
});
var ThinkingLevelSchema4 = z80.enum(THINKING_LEVELS);
var StreamStartEventSchema = z80.object({
  type: z80.literal("stream-start"),
  workspaceId: z80.string(),
  messageId: z80.string(),
  replay: z80.boolean().optional().meta({ description: "True when this event is emitted during stream replay" }),
  model: z80.string(),
  routedThroughGateway: z80.boolean().optional(),
  historySequence: z80.number().meta({
    description: "Backend assigns global message ordering"
  }),
  startTime: z80.number().meta({
    description: "Backend timestamp when stream started (Date.now())"
  }),
  mode: AgentModeSchema.optional().catch(void 0).meta({
    description: "Legacy base mode (plan/exec/compact) derived from agent"
  }),
  agentId: AgentIdSchema.optional().catch(void 0).meta({
    description: "Agent id for this stream"
  }),
  thinkingLevel: ThinkingLevelSchema4.optional().meta({
    description: "Effective thinking level after model policy clamping"
  })
});
var StreamDeltaEventSchema = z80.object({
  type: z80.literal("stream-delta"),
  workspaceId: z80.string(),
  messageId: z80.string(),
  replay: z80.boolean().optional().meta({ description: "True when this event is emitted during stream replay" }),
  delta: z80.string(),
  tokens: z80.number().meta({
    description: "Token count for this delta"
  }),
  timestamp: z80.number().meta({
    description: "When delta was received (Date.now())"
  })
});
var CompletedMessagePartSchema = z80.discriminatedUnion("type", [
  MuxReasoningPartSchema,
  MuxTextPartSchema,
  MuxToolPartSchema
]);
var LanguageModelV2UsageSchema = z80.object({
  inputTokens: z80.union([z80.number(), z80.undefined()]).meta({ description: "The number of input tokens used" }),
  outputTokens: z80.union([z80.number(), z80.undefined()]).meta({ description: "The number of output tokens used" }),
  totalTokens: z80.union([z80.number(), z80.undefined()]).meta({
    description: "Total tokens used - may differ from sum of inputTokens and outputTokens (e.g. reasoning tokens or overhead)"
  }),
  reasoningTokens: z80.number().optional().meta({ description: "The number of reasoning tokens used" }),
  cachedInputTokens: z80.number().optional().meta({ description: "The number of cached input tokens" })
});
var StreamEndEventSchema = z80.object({
  type: z80.literal("stream-end"),
  workspaceId: z80.string(),
  messageId: z80.string(),
  metadata: z80.object({
    model: z80.string(),
    thinkingLevel: ThinkingLevelSchema4.optional(),
    routedThroughGateway: z80.boolean().optional(),
    // Total usage across all steps (for cost calculation)
    usage: LanguageModelV2UsageSchema.optional(),
    // Last step's usage only (for context window display - inputTokens = current context size)
    contextUsage: LanguageModelV2UsageSchema.optional(),
    // Aggregated provider metadata across all steps (for cost calculation)
    providerMetadata: z80.record(z80.string(), z80.unknown()).optional(),
    // Last step's provider metadata (for context window cache display)
    contextProviderMetadata: z80.record(z80.string(), z80.unknown()).optional(),
    duration: z80.number().optional(),
    systemMessageTokens: z80.number().optional(),
    historySequence: z80.number().optional().meta({
      description: "Present when loading from history"
    }),
    timestamp: z80.number().optional().meta({
      description: "Present when loading from history"
    })
  }).meta({
    description: "Structured metadata from backend - directly mergeable with MuxMetadata"
  }),
  parts: z80.array(CompletedMessagePartSchema).meta({
    description: "Parts array preserves temporal ordering of reasoning, text, and tool calls"
  })
});
var StreamAbortReasonSchema = z80.enum(["user", "startup", "system"]);
var StreamAbortEventSchema = z80.object({
  type: z80.literal("stream-abort"),
  workspaceId: z80.string(),
  messageId: z80.string(),
  abortReason: StreamAbortReasonSchema.optional(),
  metadata: z80.object({
    // Total usage across all steps (for cost calculation)
    usage: LanguageModelV2UsageSchema.optional(),
    // Last step's usage (for context window display - inputTokens = current context size)
    contextUsage: LanguageModelV2UsageSchema.optional(),
    // Provider metadata for cost calculation (cache tokens, etc.)
    providerMetadata: z80.record(z80.string(), z80.unknown()).optional(),
    // Last step's provider metadata (for context window cache display)
    contextProviderMetadata: z80.record(z80.string(), z80.unknown()).optional(),
    duration: z80.number().optional()
  }).optional().meta({
    description: "Metadata may contain usage if abort occurred after stream completed processing"
  }),
  abandonPartial: z80.boolean().optional()
});
var ToolCallStartEventSchema = z80.object({
  type: z80.literal("tool-call-start"),
  workspaceId: z80.string(),
  messageId: z80.string(),
  replay: z80.boolean().optional().meta({ description: "True when this event is emitted during stream replay" }),
  toolCallId: z80.string(),
  toolName: z80.string(),
  args: z80.unknown(),
  tokens: z80.number().meta({ description: "Token count for tool input" }),
  timestamp: z80.number().meta({ description: "When tool call started (Date.now())" }),
  parentToolCallId: z80.string().optional().meta({ description: "Set for nested PTC calls" })
});
var ToolCallDeltaEventSchema = z80.object({
  type: z80.literal("tool-call-delta"),
  workspaceId: z80.string(),
  messageId: z80.string(),
  replay: z80.boolean().optional().meta({ description: "True when this event is emitted during stream replay" }),
  toolCallId: z80.string(),
  toolName: z80.string(),
  delta: z80.unknown(),
  tokens: z80.number().meta({ description: "Token count for this delta" }),
  timestamp: z80.number().meta({ description: "When delta was received (Date.now())" })
});
var BashOutputEventSchema = z80.object({
  type: z80.literal("bash-output"),
  workspaceId: z80.string(),
  toolCallId: z80.string(),
  phase: z80.enum(["output", "filtering"]).optional().meta({ description: "UI hint for bash output state" }),
  text: z80.string(),
  isError: z80.boolean().meta({ description: "True if this chunk is from stderr" }),
  timestamp: z80.number().meta({ description: "When output was flushed (Date.now())" })
});
var TaskCreatedEventSchema = z80.object({
  type: z80.literal("task-created"),
  workspaceId: z80.string(),
  toolCallId: z80.string(),
  taskId: z80.string(),
  timestamp: z80.number().meta({ description: "When the task was created (Date.now())" })
});
var ToolCallEndEventSchema = z80.object({
  type: z80.literal("tool-call-end"),
  workspaceId: z80.string(),
  messageId: z80.string(),
  replay: z80.boolean().optional().meta({ description: "True when this event is emitted during stream replay" }),
  toolCallId: z80.string(),
  toolName: z80.string(),
  result: z80.unknown(),
  timestamp: z80.number().meta({ description: "When tool call completed (Date.now())" }),
  parentToolCallId: z80.string().optional().meta({ description: "Set for nested PTC calls" })
});
var ReasoningDeltaEventSchema = z80.object({
  type: z80.literal("reasoning-delta"),
  workspaceId: z80.string(),
  messageId: z80.string(),
  replay: z80.boolean().optional().meta({ description: "True when this event is emitted during stream replay" }),
  delta: z80.string(),
  tokens: z80.number().meta({ description: "Token count for this delta" }),
  timestamp: z80.number().meta({ description: "When delta was received (Date.now())" }),
  signature: z80.string().optional().meta({ description: "Anthropic thinking block signature for replay" })
});
var ReasoningEndEventSchema = z80.object({
  type: z80.literal("reasoning-end"),
  workspaceId: z80.string(),
  messageId: z80.string(),
  replay: z80.boolean().optional().meta({ description: "True when this event is emitted during stream replay" })
});
var ErrorEventSchema = z80.object({
  type: z80.literal("error"),
  workspaceId: z80.string(),
  messageId: z80.string(),
  error: z80.string(),
  errorType: StreamErrorTypeSchema.optional()
});
var SessionUsageDeltaEventSchema = z80.object({
  type: z80.literal("session-usage-delta"),
  workspaceId: z80.string().meta({ description: "Parent workspace ID" }),
  sourceWorkspaceId: z80.string().meta({ description: "Deleted child workspace ID" }),
  byModelDelta: z80.record(z80.string(), ChatUsageDisplaySchema),
  timestamp: z80.number()
});
var UsageDeltaEventSchema = z80.object({
  type: z80.literal("usage-delta"),
  workspaceId: z80.string(),
  messageId: z80.string(),
  // Step-level: this step only (for context window display)
  usage: LanguageModelV2UsageSchema,
  providerMetadata: z80.record(z80.string(), z80.unknown()).optional(),
  // Cumulative: sum across all steps (for live cost display)
  cumulativeUsage: LanguageModelV2UsageSchema,
  cumulativeProviderMetadata: z80.record(z80.string(), z80.unknown()).optional()
});
var InitStartEventSchema = z80.object({
  type: z80.literal("init-start"),
  hookPath: z80.string(),
  timestamp: z80.number()
});
var InitOutputEventSchema = z80.object({
  type: z80.literal("init-output"),
  line: z80.string(),
  timestamp: z80.number(),
  isError: z80.boolean().optional()
});
var InitEndEventSchema = z80.object({
  type: z80.literal("init-end"),
  exitCode: z80.number(),
  timestamp: z80.number(),
  /** Number of lines dropped from middle when output exceeded limit (omitted if 0) */
  truncatedLines: z80.number().optional()
});
var WorkspaceInitEventSchema = z80.discriminatedUnion("type", [
  InitStartEventSchema,
  InitOutputEventSchema,
  InitEndEventSchema
]);
var ChatMuxMessageSchema = MuxMessageSchema.extend({
  type: z80.literal("message")
});
var ReviewNoteDataSchema = z80.object({
  filePath: z80.string(),
  lineRange: z80.string(),
  selectedCode: z80.string(),
  selectedDiff: z80.string().optional(),
  oldStart: z80.number().optional(),
  newStart: z80.number().optional(),
  userNote: z80.string()
});
var QueuedMessageChangedEventSchema = z80.object({
  type: z80.literal("queued-message-changed"),
  workspaceId: z80.string(),
  queuedMessages: z80.array(z80.string()),
  displayText: z80.string(),
  fileParts: z80.array(FilePartSchema).optional(),
  reviews: z80.array(ReviewNoteDataSchema).optional(),
  /** True when the queued message is a compaction request (/compact) */
  hasCompactionRequest: z80.boolean().optional()
});
var RestoreToInputEventSchema = z80.object({
  type: z80.literal("restore-to-input"),
  workspaceId: z80.string(),
  text: z80.string(),
  fileParts: z80.array(FilePartSchema).optional(),
  reviews: z80.array(ReviewNoteDataSchema).optional()
});
var WorkspaceChatMessageSchema = z80.discriminatedUnion("type", [
  // Stream lifecycle events
  HeartbeatEventSchema,
  CaughtUpMessageSchema,
  StreamErrorMessageSchema,
  DeleteMessageSchema,
  StreamStartEventSchema,
  StreamDeltaEventSchema,
  StreamEndEventSchema,
  StreamAbortEventSchema,
  // Tool events
  ToolCallStartEventSchema,
  ToolCallDeltaEventSchema,
  ToolCallEndEventSchema,
  BashOutputEventSchema,
  TaskCreatedEventSchema,
  // Reasoning events
  ReasoningDeltaEventSchema,
  ReasoningEndEventSchema,
  // Error events
  ErrorEventSchema,
  // Usage and queue events
  UsageDeltaEventSchema,
  SessionUsageDeltaEventSchema,
  QueuedMessageChangedEventSchema,
  RestoreToInputEventSchema,
  // Idle compaction notification
  IdleCompactionNeededEventSchema,
  // Runtime status events
  RuntimeStatusEventSchema,
  // Init events
  ...WorkspaceInitEventSchema.def.options,
  // Chat messages with type discriminator
  ChatMuxMessageSchema
]);
var UpdateStatusSchema = z80.discriminatedUnion("type", [
  z80.object({ type: z80.literal("idle") }),
  z80.object({ type: z80.literal("checking") }),
  z80.object({ type: z80.literal("available"), info: z80.object({ version: z80.string() }) }),
  z80.object({ type: z80.literal("up-to-date") }),
  z80.object({ type: z80.literal("downloading"), percent: z80.number() }),
  z80.object({ type: z80.literal("downloaded"), info: z80.object({ version: z80.string() }) }),
  z80.object({ type: z80.literal("error"), message: z80.string() })
]);
var ToolPolicyFilterSchema = z80.object({
  regex_match: z80.string().meta({
    description: 'Regex pattern to match tool names (e.g., "bash", "file_edit_.*", ".*")'
  }),
  action: z80.enum(["enable", "disable", "require"]).meta({
    description: "Action to take when pattern matches"
  })
});
var ToolPolicySchema = z80.array(ToolPolicyFilterSchema).meta({
  description: "Tool policy - array of filters applied in order. Default behavior is allow all tools."
});
var ExperimentsSchema = z80.object({
  programmaticToolCalling: z80.boolean().optional(),
  programmaticToolCallingExclusive: z80.boolean().optional(),
  system1: z80.boolean().optional(),
  execSubagentHardRestart: z80.boolean().optional()
});
var SendMessageOptionsSchema = z80.object({
  editMessageId: z80.string().optional(),
  thinkingLevel: z80.enum(["off", "low", "medium", "high", "xhigh", "max"]).optional(),
  model: z80.string("No model specified"),
  system1ThinkingLevel: z80.enum(["off", "low", "medium", "high", "xhigh", "max"]).optional(),
  system1Model: z80.string().optional(),
  toolPolicy: ToolPolicySchema.optional(),
  additionalSystemInstructions: z80.string().optional(),
  maxOutputTokens: z80.number().optional(),
  agentId: AgentIdSchema.meta({
    description: "Agent id for this request"
  }),
  mode: AgentModeSchema.optional().catch(void 0).meta({
    description: "Legacy base mode (plan/exec/compact) for backend fallback"
  }),
  providerOptions: MuxProviderOptionsSchema.optional(),
  muxMetadata: z80.any().optional(),
  // Black box
  /**
   * When true, skip persisting AI settings (e.g., for one-shot or compaction sends).
   */
  skipAiSettingsPersistence: z80.boolean().optional(),
  experiments: ExperimentsSchema.optional(),
  /**
   * When true, workspace-specific agent definitions are disabled.
   * Only built-in and global agents are loaded. Useful for "unbricking" when
   * iterating on agent files - a broken agent in the worktree won't affect message sending.
   */
  disableWorkspaceAgents: z80.boolean().optional()
});

// src/common/orpc/schemas/api.ts
init_dist5();
import { z as z91 } from "zod";

// src/common/orpc/schemas/telemetry.ts
import { z as z81 } from "zod";
var ErrorContextSchema = z81.enum([
  "workspace-creation",
  "workspace-deletion",
  "workspace-switch",
  "message-send",
  "message-stream",
  "project-add",
  "project-remove",
  "git-operation"
]);
var TelemetryRuntimeTypeSchema = RuntimeModeSchema;
var FrontendPlatformInfoSchema = z81.object({
  userAgent: z81.string(),
  platform: z81.string()
});
var TelemetryThinkingLevelSchema = z81.enum(["off", "low", "medium", "high", "xhigh", "max"]);
var TelemetryCommandTypeSchema = z81.enum([
  "clear",
  "compact",
  "new",
  "fork",
  "vim",
  "model",
  "mode",
  "plan",
  "providers"
]);
var AppStartedPropertiesSchema = z81.object({
  isFirstLaunch: z81.boolean(),
  vimModeEnabled: z81.boolean()
});
var WorkspaceCreatedPropertiesSchema = z81.object({
  workspaceId: z81.string(),
  runtimeType: TelemetryRuntimeTypeSchema,
  frontendPlatform: FrontendPlatformInfoSchema
});
var WorkspaceSwitchedPropertiesSchema = z81.object({
  fromWorkspaceId: z81.string(),
  toWorkspaceId: z81.string()
});
var MessageSentPropertiesSchema = z81.object({
  workspaceId: z81.string(),
  model: z81.string(),
  agentId: z81.string().min(1).optional().catch(void 0),
  message_length_b2: z81.number(),
  runtimeType: TelemetryRuntimeTypeSchema,
  frontendPlatform: FrontendPlatformInfoSchema,
  thinkingLevel: TelemetryThinkingLevelSchema
});
var TelemetryMCPTransportModeSchema = z81.enum([
  "none",
  "stdio_only",
  "http_only",
  "sse_only",
  "mixed"
]);
var MCPContextInjectedPropertiesSchema = z81.object({
  workspaceId: z81.string(),
  model: z81.string(),
  agentId: z81.string().min(1).optional().catch(void 0),
  runtimeType: TelemetryRuntimeTypeSchema,
  mcp_server_enabled_count: z81.number(),
  mcp_server_started_count: z81.number(),
  mcp_server_failed_count: z81.number(),
  mcp_tool_count: z81.number(),
  total_tool_count: z81.number(),
  builtin_tool_count: z81.number(),
  mcp_transport_mode: TelemetryMCPTransportModeSchema,
  mcp_has_http: z81.boolean(),
  mcp_has_sse: z81.boolean(),
  mcp_has_stdio: z81.boolean(),
  mcp_auto_fallback_count: z81.number(),
  mcp_setup_duration_ms_b2: z81.number()
});
var TelemetryMCPServerTransportSchema = z81.enum(["stdio", "http", "sse", "auto"]);
var TelemetryMCPTestErrorCategorySchema = z81.enum([
  "timeout",
  "connect",
  "http_status",
  "unknown"
]);
var MCPServerTestedPropertiesSchema = z81.object({
  transport: TelemetryMCPServerTransportSchema,
  success: z81.boolean(),
  duration_ms_b2: z81.number(),
  error_category: TelemetryMCPTestErrorCategorySchema.optional()
});
var TelemetryMCPServerConfigActionSchema = z81.enum([
  "add",
  "edit",
  "remove",
  "enable",
  "disable",
  "set_tool_allowlist",
  "set_headers"
]);
var StatsTabOpenedPropertiesSchema = z81.object({
  viewMode: z81.enum(["session", "last-request"]),
  showModeBreakdown: z81.boolean()
});
var StreamTimingComputedPropertiesSchema = z81.object({
  model: z81.string(),
  agentId: z81.string().min(1).optional().catch(void 0),
  duration_b2: z81.number(),
  ttft_ms_b2: z81.number(),
  tool_ms_b2: z81.number(),
  streaming_ms_b2: z81.number(),
  tool_percent_bucket: z81.number(),
  invalid: z81.boolean()
});
var StreamTimingInvalidPropertiesSchema = z81.object({
  reason: z81.string()
});
var MCPServerConfigChangedPropertiesSchema = z81.object({
  action: TelemetryMCPServerConfigActionSchema,
  transport: TelemetryMCPServerTransportSchema,
  has_headers: z81.boolean(),
  uses_secret_headers: z81.boolean(),
  tool_allowlist_size_b2: z81.number().optional()
});
var TelemetryMCPOAuthFlowErrorCategorySchema = z81.enum([
  "timeout",
  "cancelled",
  "state_mismatch",
  "provider_error",
  "unknown"
]);
var MCPOAuthFlowStartedPropertiesSchema = z81.object({
  transport: TelemetryMCPServerTransportSchema,
  has_scope_hint: z81.boolean(),
  has_resource_metadata_hint: z81.boolean()
});
var MCPOAuthFlowCompletedPropertiesSchema = z81.object({
  transport: TelemetryMCPServerTransportSchema,
  duration_ms_b2: z81.number(),
  has_scope_hint: z81.boolean(),
  has_resource_metadata_hint: z81.boolean()
});
var MCPOAuthFlowFailedPropertiesSchema = z81.object({
  transport: TelemetryMCPServerTransportSchema,
  duration_ms_b2: z81.number(),
  has_scope_hint: z81.boolean(),
  has_resource_metadata_hint: z81.boolean(),
  error_category: TelemetryMCPOAuthFlowErrorCategorySchema
});
var StreamCompletedPropertiesSchema = z81.object({
  model: z81.string(),
  wasInterrupted: z81.boolean(),
  duration_b2: z81.number(),
  output_tokens_b2: z81.number()
});
var CompactionCompletedPropertiesSchema = z81.object({
  model: z81.string(),
  duration_b2: z81.number(),
  input_tokens_b2: z81.number(),
  output_tokens_b2: z81.number(),
  compaction_source: z81.enum(["manual", "idle"])
});
var ProviderConfiguredPropertiesSchema = z81.object({
  provider: z81.string(),
  keyType: z81.string()
});
var CommandUsedPropertiesSchema = z81.object({
  command: TelemetryCommandTypeSchema
});
var VoiceTranscriptionPropertiesSchema = z81.object({
  audio_duration_b2: z81.number(),
  success: z81.boolean()
});
var ErrorOccurredPropertiesSchema = z81.object({
  errorType: z81.string(),
  context: ErrorContextSchema
});
var ExperimentOverriddenPropertiesSchema = z81.object({
  experimentId: z81.string(),
  assignedVariant: z81.union([z81.string(), z81.boolean(), z81.null()]),
  userChoice: z81.boolean()
});
var TelemetryEventSchema = z81.discriminatedUnion("event", [
  z81.object({
    event: z81.literal("app_started"),
    properties: AppStartedPropertiesSchema
  }),
  z81.object({
    event: z81.literal("workspace_created"),
    properties: WorkspaceCreatedPropertiesSchema
  }),
  z81.object({
    event: z81.literal("workspace_switched"),
    properties: WorkspaceSwitchedPropertiesSchema
  }),
  z81.object({
    event: z81.literal("mcp_context_injected"),
    properties: MCPContextInjectedPropertiesSchema
  }),
  z81.object({
    event: z81.literal("mcp_server_tested"),
    properties: MCPServerTestedPropertiesSchema
  }),
  z81.object({
    event: z81.literal("stats_tab_opened"),
    properties: StatsTabOpenedPropertiesSchema
  }),
  z81.object({
    event: z81.literal("stream_timing_computed"),
    properties: StreamTimingComputedPropertiesSchema
  }),
  z81.object({
    event: z81.literal("stream_timing_invalid"),
    properties: StreamTimingInvalidPropertiesSchema
  }),
  z81.object({
    event: z81.literal("mcp_server_config_changed"),
    properties: MCPServerConfigChangedPropertiesSchema
  }),
  z81.object({
    event: z81.literal("mcp_oauth_flow_started"),
    properties: MCPOAuthFlowStartedPropertiesSchema
  }),
  z81.object({
    event: z81.literal("mcp_oauth_flow_completed"),
    properties: MCPOAuthFlowCompletedPropertiesSchema
  }),
  z81.object({
    event: z81.literal("mcp_oauth_flow_failed"),
    properties: MCPOAuthFlowFailedPropertiesSchema
  }),
  z81.object({
    event: z81.literal("message_sent"),
    properties: MessageSentPropertiesSchema
  }),
  z81.object({
    event: z81.literal("stream_completed"),
    properties: StreamCompletedPropertiesSchema
  }),
  z81.object({
    event: z81.literal("compaction_completed"),
    properties: CompactionCompletedPropertiesSchema
  }),
  z81.object({
    event: z81.literal("provider_configured"),
    properties: ProviderConfiguredPropertiesSchema
  }),
  z81.object({
    event: z81.literal("command_used"),
    properties: CommandUsedPropertiesSchema
  }),
  z81.object({
    event: z81.literal("voice_transcription"),
    properties: VoiceTranscriptionPropertiesSchema
  }),
  z81.object({
    event: z81.literal("error_occurred"),
    properties: ErrorOccurredPropertiesSchema
  }),
  z81.object({
    event: z81.literal("experiment_overridden"),
    properties: ExperimentOverriddenPropertiesSchema
  })
]);
var telemetry = {
  track: {
    input: TelemetryEventSchema,
    output: z81.void()
  },
  status: {
    input: z81.void(),
    output: z81.object({
      /** True if telemetry is actively running (false in dev mode) */
      enabled: z81.boolean(),
      /** True only if user explicitly set MUX_DISABLE_TELEMETRY=1 */
      explicit: z81.boolean()
    })
  }
};

// src/common/orpc/schemas/signing.ts
import { z as z90 } from "zod";
var signingCapabilitiesInput = z90.object({});
var signingErrorOutput = z90.object({
  /** Error message */
  message: z90.string(),
  /** True if a compatible key was found but requires a passphrase */
  hasEncryptedKey: z90.boolean()
});
var signingCapabilitiesOutput = z90.object({
  /** Public key in OpenSSH format (ssh-ed25519 AAAA...), null if no key is available */
  publicKey: z90.string().nullable(),
  /** Detected GitHub username, if any */
  githubUser: z90.string().nullable(),
  /** Error info if key loading or identity detection failed */
  error: signingErrorOutput.nullable()
});
var signatureEnvelopeOutput = z90.object({
  sig: z90.string(),
  publicKey: z90.string(),
  githubUser: z90.string().optional()
});
var signMessageInput = z90.object({
  content: z90.string()
}).strict();
var signMessageOutput = signatureEnvelopeOutput;
var clearIdentityCacheInput = z90.object({});
var clearIdentityCacheOutput = z90.object({
  success: z90.boolean()
});
var signing = {
  capabilities: {
    input: signingCapabilitiesInput,
    output: signingCapabilitiesOutput
  },
  signMessage: {
    input: signMessageInput,
    output: signMessageOutput
  },
  clearIdentityCache: {
    input: clearIdentityCacheInput,
    output: clearIdentityCacheOutput
  }
};

// src/common/orpc/schemas/api.ts
var ExperimentValueSchema = z91.object({
  value: z91.union([z91.string(), z91.boolean(), z91.null()]),
  source: z91.enum(["posthog", "cache", "disabled"])
});
var experiments = {
  getAll: {
    input: z91.void(),
    output: z91.record(z91.string(), ExperimentValueSchema)
  },
  reload: {
    input: z91.void(),
    output: z91.void()
  }
};
var BackgroundProcessInfoSchema = z91.object({
  id: z91.string(),
  pid: z91.number(),
  script: z91.string(),
  displayName: z91.string().optional(),
  startTime: z91.number(),
  status: z91.enum(["running", "exited", "killed", "failed"]),
  exitCode: z91.number().optional()
});
var tokenizer = {
  countTokens: {
    input: z91.object({ model: z91.string(), text: z91.string() }),
    output: z91.number()
  },
  countTokensBatch: {
    input: z91.object({ model: z91.string(), texts: z91.array(z91.string()) }),
    output: z91.array(z91.number())
  },
  calculateStats: {
    input: z91.object({
      workspaceId: z91.string(),
      messages: z91.array(MuxMessageSchema),
      model: z91.string()
    }),
    output: ChatStatsSchema
  }
};
var AWSCredentialStatusSchema = z91.object({
  region: z91.string().optional(),
  /** Optional AWS shared config profile name (equivalent to AWS_PROFILE). */
  profile: z91.string().optional(),
  bearerTokenSet: z91.boolean(),
  accessKeyIdSet: z91.boolean(),
  secretAccessKeySet: z91.boolean()
});
var CustomModelMetadataSchema = z91.object({
  maxInputTokens: z91.number().int().positive().optional(),
  maxOutputTokens: z91.number().int().positive().optional(),
  inputCostPerToken: z91.number().nonnegative().optional(),
  outputCostPerToken: z91.number().nonnegative().optional(),
  cacheCreationInputTokenCost: z91.number().nonnegative().optional(),
  cacheReadInputTokenCost: z91.number().nonnegative().optional()
});
var ProviderConfigInfoSchema = z91.object({
  apiKeySet: z91.boolean(),
  /** Whether this provider is configured and ready to use */
  isConfigured: z91.boolean(),
  baseUrl: z91.string().optional(),
  models: z91.array(z91.string()).optional(),
  /** OpenAI-specific fields */
  serviceTier: z91.enum(["auto", "default", "flex", "priority"]).optional(),
  /** OpenAI-only: whether Codex OAuth tokens are present in providers.jsonc */
  codexOauthSet: z91.boolean().optional(),
  /**
   * OpenAI-only: default auth precedence to use for Codex-OAuth-allowed models when BOTH
   * ChatGPT OAuth and an OpenAI API key are configured.
   */
  codexOauthDefaultAuth: z91.enum(["oauth", "apiKey"]).optional(),
  /** AWS-specific fields (only present for bedrock provider) */
  aws: AWSCredentialStatusSchema.optional(),
  /** Mux Gateway-specific fields */
  couponCodeSet: z91.boolean().optional(),
  /** Custom model metadata (overrides defaults layer) */
  modelMetadata: z91.record(z91.string(), CustomModelMetadataSchema).optional()
});
var ProvidersConfigMapSchema = z91.record(z91.string(), ProviderConfigInfoSchema);
var providers = {
  setProviderConfig: {
    input: z91.object({
      provider: z91.string(),
      keyPath: z91.array(z91.string()),
      value: z91.string()
    }),
    output: ResultSchema(z91.void(), z91.string())
  },
  getConfig: {
    input: z91.void(),
    output: ProvidersConfigMapSchema
  },
  setModelMetadata: {
    input: z91.object({
      provider: z91.string(),
      modelId: z91.string(),
      metadata: CustomModelMetadataSchema
    }),
    output: ResultSchema(z91.void(), z91.string())
  },
  setModels: {
    input: z91.object({
      provider: z91.string(),
      models: z91.array(z91.string())
    }),
    output: ResultSchema(z91.void(), z91.string())
  },
  list: {
    input: z91.void(),
    output: z91.array(z91.string())
  },
  // Subscription: emits when provider config changes (API keys, models, etc.)
  onConfigChanged: {
    input: z91.void(),
    output: eventIterator(z91.void())
  }
};
var policy = {
  get: {
    input: z91.void(),
    output: PolicyGetResponseSchema
  },
  // Subscription: emits when the effective policy changes (file refresh)
  onChanged: {
    input: z91.void(),
    output: eventIterator(z91.void())
  },
  // Force a refresh of the effective policy (re-reads MUX_POLICY_FILE or Governor policy)
  refreshNow: {
    input: z91.void(),
    output: ResultSchema(PolicyGetResponseSchema, z91.string())
  }
};
var muxGatewayOauth = {
  startDesktopFlow: {
    input: z91.void(),
    output: ResultSchema(
      z91.object({
        flowId: z91.string(),
        authorizeUrl: z91.string(),
        redirectUri: z91.string()
      }),
      z91.string()
    )
  },
  waitForDesktopFlow: {
    input: z91.object({
      flowId: z91.string(),
      timeoutMs: z91.number().int().positive().optional()
    }).strict(),
    output: ResultSchema(z91.void(), z91.string())
  },
  cancelDesktopFlow: {
    input: z91.object({ flowId: z91.string() }).strict(),
    output: z91.void()
  }
};
var copilotOauth = {
  startDeviceFlow: {
    input: z91.void(),
    output: ResultSchema(
      z91.object({
        flowId: z91.string(),
        verificationUri: z91.string(),
        userCode: z91.string()
      }),
      z91.string()
    )
  },
  waitForDeviceFlow: {
    input: z91.object({
      flowId: z91.string(),
      timeoutMs: z91.number().int().positive().optional()
    }).strict(),
    output: ResultSchema(z91.void(), z91.string())
  },
  cancelDeviceFlow: {
    input: z91.object({ flowId: z91.string() }).strict(),
    output: z91.void()
  }
};
var muxGovernorOauth = {
  startDesktopFlow: {
    input: z91.object({ governorOrigin: z91.string() }).strict(),
    output: ResultSchema(
      z91.object({
        flowId: z91.string(),
        authorizeUrl: z91.string(),
        redirectUri: z91.string()
      }),
      z91.string()
    )
  },
  waitForDesktopFlow: {
    input: z91.object({
      flowId: z91.string(),
      timeoutMs: z91.number().int().positive().optional()
    }).strict(),
    output: ResultSchema(z91.void(), z91.string())
  },
  cancelDesktopFlow: {
    input: z91.object({ flowId: z91.string() }).strict(),
    output: z91.void()
  }
};
var codexOauth = {
  startDesktopFlow: {
    input: z91.void(),
    output: ResultSchema(z91.object({ flowId: z91.string(), authorizeUrl: z91.string() }), z91.string())
  },
  waitForDesktopFlow: {
    input: z91.object({
      flowId: z91.string(),
      timeoutMs: z91.number().int().positive().optional()
    }).strict(),
    output: ResultSchema(z91.void(), z91.string())
  },
  cancelDesktopFlow: {
    input: z91.object({ flowId: z91.string() }).strict(),
    output: z91.void()
  },
  startDeviceFlow: {
    input: z91.void(),
    output: ResultSchema(
      z91.object({
        flowId: z91.string(),
        userCode: z91.string(),
        verifyUrl: z91.string(),
        intervalSeconds: z91.number().int().positive()
      }),
      z91.string()
    )
  },
  waitForDeviceFlow: {
    input: z91.object({
      flowId: z91.string(),
      timeoutMs: z91.number().int().positive().optional()
    }).strict(),
    output: ResultSchema(z91.void(), z91.string())
  },
  cancelDeviceFlow: {
    input: z91.object({ flowId: z91.string() }).strict(),
    output: z91.void()
  },
  disconnect: {
    input: z91.void(),
    output: ResultSchema(z91.void(), z91.string())
  }
};
var muxGateway = {
  getAccountStatus: {
    input: z91.void(),
    output: ResultSchema(
      z91.object({
        remaining_microdollars: z91.number().int().nonnegative(),
        ai_gateway_concurrent_requests_per_user: z91.number().int().nonnegative()
      }),
      z91.string()
    )
  }
};
var MCPOAuthPendingServerSchema = z91.object({
  // OAuth is only supported for remote transports.
  transport: z91.union([z91.literal("http"), z91.literal("sse"), z91.literal("auto")]),
  url: z91.string()
}).strict();
var mcpOauth = {
  startDesktopFlow: {
    input: z91.object({
      projectPath: z91.string().optional(),
      serverName: z91.string(),
      pendingServer: MCPOAuthPendingServerSchema.optional()
    }).strict(),
    output: ResultSchema(
      z91.object({
        flowId: z91.string(),
        authorizeUrl: z91.string(),
        redirectUri: z91.string()
      }),
      z91.string()
    )
  },
  waitForDesktopFlow: {
    input: z91.object({
      flowId: z91.string(),
      timeoutMs: z91.number().int().positive().optional()
    }).strict(),
    output: ResultSchema(z91.void(), z91.string())
  },
  cancelDesktopFlow: {
    input: z91.object({ flowId: z91.string() }).strict(),
    output: z91.void()
  },
  startServerFlow: {
    input: z91.object({
      projectPath: z91.string().optional(),
      serverName: z91.string(),
      pendingServer: MCPOAuthPendingServerSchema.optional()
    }).strict(),
    output: ResultSchema(
      z91.object({
        flowId: z91.string(),
        authorizeUrl: z91.string(),
        redirectUri: z91.string()
      }),
      z91.string()
    )
  },
  waitForServerFlow: {
    input: z91.object({
      flowId: z91.string(),
      timeoutMs: z91.number().int().positive().optional()
    }).strict(),
    output: ResultSchema(z91.void(), z91.string())
  },
  cancelServerFlow: {
    input: z91.object({ flowId: z91.string() }).strict(),
    output: z91.void()
  },
  getAuthStatus: {
    input: z91.object({ serverUrl: z91.string() }).strict(),
    output: z91.object({
      serverUrl: z91.string().optional(),
      isLoggedIn: z91.boolean(),
      hasRefreshToken: z91.boolean(),
      scope: z91.string().optional(),
      updatedAtMs: z91.number().optional()
    })
  },
  logout: {
    input: z91.object({ serverUrl: z91.string() }).strict(),
    output: ResultSchema(z91.void(), z91.string())
  }
};
var projects = {
  create: {
    input: z91.object({ projectPath: z91.string() }),
    output: ResultSchema(
      z91.object({
        projectConfig: ProjectConfigSchema,
        normalizedPath: z91.string()
      }),
      z91.string()
    )
  },
  pickDirectory: {
    input: z91.void(),
    output: z91.string().nullable()
  },
  remove: {
    input: z91.object({ projectPath: z91.string() }),
    output: ResultSchema(z91.void(), z91.string())
  },
  list: {
    input: z91.void(),
    output: z91.array(z91.tuple([z91.string(), ProjectConfigSchema]))
  },
  getFileCompletions: {
    input: z91.object({
      projectPath: z91.string(),
      query: z91.string(),
      limit: z91.number().int().positive().max(50).optional()
    }).strict(),
    output: z91.object({ paths: z91.array(z91.string()) })
  },
  runtimeAvailability: {
    input: z91.object({ projectPath: z91.string() }),
    output: RuntimeAvailabilitySchema
  },
  listBranches: {
    input: z91.object({ projectPath: z91.string() }),
    output: BranchListResultSchema
  },
  gitInit: {
    input: z91.object({ projectPath: z91.string() }),
    output: ResultSchema(z91.void(), z91.string())
  },
  mcp: {
    list: {
      input: z91.object({ projectPath: z91.string() }),
      output: MCPServerMapSchema
    },
    add: {
      input: MCPAddParamsSchema,
      output: ResultSchema(z91.void(), z91.string())
    },
    remove: {
      input: MCPRemoveParamsSchema,
      output: ResultSchema(z91.void(), z91.string())
    },
    test: {
      input: MCPTestParamsSchema,
      output: MCPTestResultSchema
    },
    setEnabled: {
      input: MCPSetEnabledParamsSchema,
      output: ResultSchema(z91.void(), z91.string())
    },
    setToolAllowlist: {
      input: MCPSetToolAllowlistParamsSchema,
      output: ResultSchema(z91.void(), z91.string())
    }
  },
  mcpOauth: {
    startDesktopFlow: {
      input: z91.object({
        projectPath: z91.string(),
        serverName: z91.string(),
        pendingServer: MCPOAuthPendingServerSchema.optional()
      }).strict(),
      output: ResultSchema(
        z91.object({
          flowId: z91.string(),
          authorizeUrl: z91.string(),
          redirectUri: z91.string()
        }),
        z91.string()
      )
    },
    waitForDesktopFlow: {
      input: z91.object({
        flowId: z91.string(),
        timeoutMs: z91.number().int().positive().optional()
      }).strict(),
      output: ResultSchema(z91.void(), z91.string())
    },
    cancelDesktopFlow: {
      input: z91.object({ flowId: z91.string() }).strict(),
      output: z91.void()
    },
    startServerFlow: {
      input: z91.object({
        projectPath: z91.string(),
        serverName: z91.string(),
        pendingServer: MCPOAuthPendingServerSchema.optional()
      }).strict(),
      output: ResultSchema(
        z91.object({
          flowId: z91.string(),
          authorizeUrl: z91.string(),
          redirectUri: z91.string()
        }),
        z91.string()
      )
    },
    waitForServerFlow: {
      input: z91.object({
        flowId: z91.string(),
        timeoutMs: z91.number().int().positive().optional()
      }).strict(),
      output: ResultSchema(z91.void(), z91.string())
    },
    cancelServerFlow: {
      input: z91.object({ flowId: z91.string() }).strict(),
      output: z91.void()
    },
    getAuthStatus: {
      input: z91.object({
        projectPath: z91.string(),
        serverName: z91.string()
      }).strict(),
      output: z91.object({
        serverUrl: z91.string().optional(),
        isLoggedIn: z91.boolean(),
        hasRefreshToken: z91.boolean(),
        scope: z91.string().optional(),
        updatedAtMs: z91.number().optional()
      })
    },
    logout: {
      input: z91.object({
        projectPath: z91.string(),
        serverName: z91.string()
      }).strict(),
      output: ResultSchema(z91.void(), z91.string())
    }
  },
  secrets: {
    get: {
      input: z91.object({ projectPath: z91.string() }),
      output: z91.array(SecretSchema)
    },
    update: {
      input: z91.object({
        projectPath: z91.string(),
        secrets: z91.array(SecretSchema)
      }),
      output: ResultSchema(z91.void(), z91.string())
    }
  },
  idleCompaction: {
    get: {
      input: z91.object({ projectPath: z91.string() }),
      output: z91.object({ hours: z91.number().nullable() })
    },
    set: {
      input: z91.object({
        projectPath: z91.string(),
        hours: z91.number().min(1).nullable()
      }),
      output: ResultSchema(z91.void(), z91.string())
    }
  },
  sections: {
    list: {
      input: z91.object({ projectPath: z91.string() }),
      output: z91.array(SectionConfigSchema)
    },
    create: {
      input: z91.object({
        projectPath: z91.string(),
        name: z91.string().min(1),
        color: z91.string().optional()
      }),
      output: ResultSchema(SectionConfigSchema, z91.string())
    },
    update: {
      input: z91.object({
        projectPath: z91.string(),
        sectionId: z91.string(),
        name: z91.string().min(1).optional(),
        color: z91.string().optional()
      }),
      output: ResultSchema(z91.void(), z91.string())
    },
    remove: {
      input: z91.object({
        projectPath: z91.string(),
        sectionId: z91.string()
      }),
      output: ResultSchema(z91.void(), z91.string())
    },
    reorder: {
      input: z91.object({
        projectPath: z91.string(),
        sectionIds: z91.array(z91.string())
      }),
      output: ResultSchema(z91.void(), z91.string())
    },
    assignWorkspace: {
      input: z91.object({
        projectPath: z91.string(),
        workspaceId: z91.string(),
        sectionId: z91.string().nullable()
      }),
      output: ResultSchema(z91.void(), z91.string())
    }
  }
};
var mcp2 = {
  list: {
    input: MCPListParamsSchema,
    output: MCPServerMapSchema
  },
  add: {
    input: MCPAddGlobalParamsSchema,
    output: ResultSchema(z91.void(), z91.string())
  },
  remove: {
    input: MCPRemoveGlobalParamsSchema,
    output: ResultSchema(z91.void(), z91.string())
  },
  test: {
    input: MCPTestGlobalParamsSchema,
    output: MCPTestResultSchema
  },
  setEnabled: {
    input: MCPSetEnabledGlobalParamsSchema,
    output: ResultSchema(z91.void(), z91.string())
  },
  setToolAllowlist: {
    input: MCPSetToolAllowlistGlobalParamsSchema,
    output: ResultSchema(z91.void(), z91.string())
  }
};
var secrets = {
  get: {
    input: z91.object({ projectPath: z91.string().optional() }),
    output: z91.array(SecretSchema)
  },
  update: {
    input: z91.object({
      projectPath: z91.string().optional(),
      secrets: z91.array(SecretSchema)
    }),
    output: ResultSchema(z91.void(), z91.string())
  }
};
var DebugLlmRequestSnapshotSchema = z91.object({
  capturedAt: z91.number(),
  workspaceId: z91.string(),
  messageId: z91.string().optional(),
  model: z91.string(),
  providerName: z91.string(),
  thinkingLevel: z91.string(),
  mode: z91.string().optional(),
  agentId: z91.string().optional(),
  maxOutputTokens: z91.number().optional(),
  systemMessage: z91.string(),
  messages: z91.array(z91.unknown()),
  response: z91.object({
    capturedAt: z91.number(),
    metadata: StreamEndEventSchema.shape.metadata,
    parts: z91.array(CompletedMessagePartSchema)
  }).strict().optional()
}).strict();
var workspace = {
  list: {
    input: z91.object({
      /** When true, only return archived workspaces. Default returns only non-archived. */
      archived: z91.boolean().optional()
    }).optional(),
    output: z91.array(FrontendWorkspaceMetadataSchema)
  },
  create: {
    input: z91.object({
      projectPath: z91.string(),
      branchName: z91.string(),
      /** Trunk branch to fork from - only required for worktree/SSH runtimes, ignored for local */
      trunkBranch: z91.string().optional(),
      /** Human-readable title (e.g., "Fix plan mode over SSH") - optional for backwards compat */
      title: z91.string().optional(),
      runtimeConfig: RuntimeConfigSchema.optional(),
      /** Section ID to assign the new workspace to (optional) */
      sectionId: z91.string().optional()
    }),
    output: z91.discriminatedUnion("success", [
      z91.object({ success: z91.literal(true), metadata: FrontendWorkspaceMetadataSchema }),
      z91.object({ success: z91.literal(false), error: z91.string() })
    ])
  },
  remove: {
    input: z91.object({
      workspaceId: z91.string(),
      options: z91.object({ force: z91.boolean().optional() }).optional()
    }),
    output: z91.object({ success: z91.boolean(), error: z91.string().optional() })
  },
  rename: {
    input: z91.object({ workspaceId: z91.string(), newName: z91.string() }),
    output: ResultSchema(z91.object({ newWorkspaceId: z91.string() }), z91.string())
  },
  updateTitle: {
    input: z91.object({ workspaceId: z91.string(), title: z91.string() }),
    output: ResultSchema(z91.void(), z91.string())
  },
  updateAgentAISettings: {
    input: z91.object({
      workspaceId: z91.string(),
      agentId: AgentIdSchema,
      aiSettings: WorkspaceAISettingsSchema
    }),
    output: ResultSchema(z91.void(), z91.string())
  },
  updateModeAISettings: {
    input: z91.object({
      workspaceId: z91.string(),
      mode: UIModeSchema,
      aiSettings: WorkspaceAISettingsSchema
    }),
    output: ResultSchema(z91.void(), z91.string())
  },
  archive: {
    input: z91.object({ workspaceId: z91.string() }),
    output: ResultSchema(z91.void(), z91.string())
  },
  unarchive: {
    input: z91.object({ workspaceId: z91.string() }),
    output: ResultSchema(z91.void(), z91.string())
  },
  archiveMergedInProject: {
    input: z91.object({ projectPath: z91.string() }),
    output: ResultSchema(
      z91.object({
        archivedWorkspaceIds: z91.array(z91.string()),
        skippedWorkspaceIds: z91.array(z91.string()),
        errors: z91.array(
          z91.object({
            workspaceId: z91.string(),
            error: z91.string()
          })
        )
      }),
      z91.string()
    )
  },
  fork: {
    input: z91.object({ sourceWorkspaceId: z91.string(), newName: z91.string() }),
    output: z91.discriminatedUnion("success", [
      z91.object({
        success: z91.literal(true),
        metadata: FrontendWorkspaceMetadataSchema,
        projectPath: z91.string()
      }),
      z91.object({ success: z91.literal(false), error: z91.string() })
    ])
  },
  sendMessage: {
    input: z91.object({
      workspaceId: z91.string(),
      message: z91.string(),
      options: SendMessageOptionsSchema.extend({
        fileParts: z91.array(FilePartSchema).optional()
      })
    }),
    output: ResultSchema(z91.object({}), SendMessageErrorSchema)
  },
  answerAskUserQuestion: {
    input: z91.object({
      workspaceId: z91.string(),
      toolCallId: z91.string(),
      answers: z91.record(z91.string(), z91.string())
    }).strict(),
    output: ResultSchema(z91.void(), z91.string())
  },
  resumeStream: {
    input: z91.object({
      workspaceId: z91.string(),
      options: SendMessageOptionsSchema
    }),
    output: ResultSchema(z91.void(), SendMessageErrorSchema)
  },
  interruptStream: {
    input: z91.object({
      workspaceId: z91.string(),
      options: z91.object({
        soft: z91.boolean().optional(),
        abandonPartial: z91.boolean().optional(),
        sendQueuedImmediately: z91.boolean().optional()
      }).optional()
    }),
    output: ResultSchema(z91.void(), z91.string())
  },
  clearQueue: {
    input: z91.object({ workspaceId: z91.string() }),
    output: ResultSchema(z91.void(), z91.string())
  },
  truncateHistory: {
    input: z91.object({
      workspaceId: z91.string(),
      percentage: z91.number().optional()
    }),
    output: ResultSchema(z91.void(), z91.string())
  },
  replaceChatHistory: {
    input: z91.object({
      workspaceId: z91.string(),
      summaryMessage: MuxMessageSchema,
      /**
       * Replace strategy.
       * - destructive (default): clear history, then append summary
       * - append-compaction-boundary: keep history and append summary as durable boundary
       */
      mode: z91.enum(["destructive", "append-compaction-boundary"]).nullish(),
      /** When true, delete the plan file (new + legacy paths) and clear plan tracking state. */
      deletePlanFile: z91.boolean().optional()
    }),
    output: ResultSchema(z91.void(), z91.string())
  },
  getDevcontainerInfo: {
    input: z91.object({ workspaceId: z91.string() }),
    output: z91.object({
      containerName: z91.string(),
      containerWorkspacePath: z91.string(),
      hostWorkspacePath: z91.string()
    }).nullable()
  },
  getInfo: {
    input: z91.object({ workspaceId: z91.string() }),
    output: FrontendWorkspaceMetadataSchema.nullable()
  },
  getLastLlmRequest: {
    input: z91.object({ workspaceId: z91.string() }),
    output: ResultSchema(DebugLlmRequestSnapshotSchema.nullable(), z91.string())
  },
  getFullReplay: {
    input: z91.object({ workspaceId: z91.string() }),
    output: z91.array(WorkspaceChatMessageSchema)
  },
  /**
   * Load an archived subagent transcript (chat.jsonl + optional partial.json) from this workspace's
   * session dir.
   */
  getSubagentTranscript: {
    input: z91.object({
      /** Workspace that owns the transcript artifact index (usually the current workspace). */
      workspaceId: z91.string().optional(),
      /** Child task/workspace id whose transcript should be loaded. */
      taskId: z91.string()
    }),
    output: z91.object({
      messages: z91.array(MuxMessageSchema),
      /** Task-level model string used when running the sub-agent (optional for legacy entries). */
      model: z91.string().optional(),
      /** Task-level thinking/reasoning level used when running the sub-agent (optional for legacy entries). */
      thinkingLevel: z91.enum(["off", "low", "medium", "high", "xhigh", "max"]).optional()
    })
  },
  executeBash: {
    input: z91.object({
      workspaceId: z91.string(),
      script: z91.string(),
      options: z91.object({
        timeout_secs: z91.number().optional()
      }).optional()
    }),
    output: ResultSchema(BashToolResultSchema, z91.string())
  },
  getFileCompletions: {
    input: z91.object({
      workspaceId: z91.string(),
      query: z91.string(),
      limit: z91.number().int().positive().max(50).optional()
    }).strict(),
    output: z91.object({ paths: z91.array(z91.string()) })
  },
  // Subscriptions
  onChat: {
    input: z91.object({ workspaceId: z91.string() }),
    output: eventIterator(WorkspaceChatMessageSchema)
    // Stream event
  },
  onMetadata: {
    input: z91.void(),
    output: eventIterator(
      z91.object({
        workspaceId: z91.string(),
        metadata: FrontendWorkspaceMetadataSchema.nullable()
      })
    )
  },
  activity: {
    list: {
      input: z91.void(),
      output: z91.record(z91.string(), WorkspaceActivitySnapshotSchema)
    },
    subscribe: {
      input: z91.void(),
      output: eventIterator(
        z91.object({
          workspaceId: z91.string(),
          activity: WorkspaceActivitySnapshotSchema.nullable()
        })
      )
    }
  },
  /**
   * Get the current plan file content for a workspace.
   * Used by UI to refresh plan display when file is edited externally.
   */
  getPlanContent: {
    input: z91.object({ workspaceId: z91.string() }),
    output: ResultSchema(
      z91.object({
        content: z91.string(),
        path: z91.string()
      }),
      z91.string()
    )
  },
  backgroundBashes: {
    /**
     * Subscribe to background bash state changes for a workspace.
     * Emits full state on connect, then incremental updates.
     */
    subscribe: {
      input: z91.object({ workspaceId: z91.string() }),
      output: eventIterator(
        z91.object({
          /** Background processes (not including foreground ones being waited on) */
          processes: z91.array(BackgroundProcessInfoSchema),
          /** Tool call IDs of foreground bashes that can be sent to background */
          foregroundToolCallIds: z91.array(z91.string())
        })
      )
    },
    terminate: {
      input: z91.object({ workspaceId: z91.string(), processId: z91.string() }),
      output: ResultSchema(z91.void(), z91.string())
    },
    /**
     * Send a foreground bash process to background.
     * The process continues running but the agent stops waiting for it.
     */
    sendToBackground: {
      input: z91.object({ workspaceId: z91.string(), toolCallId: z91.string() }),
      output: ResultSchema(z91.void(), z91.string())
    },
    /**
     * Peek output for a background bash process without consuming the bash_output cursor.
     */
    getOutput: {
      input: z91.object({
        workspaceId: z91.string(),
        processId: z91.string(),
        fromOffset: z91.number().int().nonnegative().optional(),
        tailBytes: z91.number().int().positive().max(1e6).optional()
      }),
      output: ResultSchema(
        z91.object({
          status: z91.enum(["running", "exited", "killed", "failed"]),
          output: z91.string(),
          nextOffset: z91.number().int().nonnegative(),
          truncatedStart: z91.boolean()
        }),
        z91.string()
      )
    }
  },
  /**
   * Get post-compaction context state for a workspace.
   * Returns plan path (if exists) and tracked file paths that will be injected.
   */
  getPostCompactionState: {
    input: z91.object({ workspaceId: z91.string() }),
    output: z91.object({
      planPath: z91.string().nullable(),
      trackedFilePaths: z91.array(z91.string()),
      excludedItems: z91.array(z91.string())
    })
  },
  /**
   * Toggle whether a post-compaction item is excluded from injection.
   * Item IDs: "plan" for plan file, "file:<path>" for tracked files.
   */
  setPostCompactionExclusion: {
    input: z91.object({
      workspaceId: z91.string(),
      itemId: z91.string(),
      excluded: z91.boolean()
    }),
    output: ResultSchema(z91.void(), z91.string())
  },
  stats: {
    subscribe: {
      input: z91.object({ workspaceId: z91.string() }),
      output: eventIterator(WorkspaceStatsSnapshotSchema)
    },
    clear: {
      input: z91.object({ workspaceId: z91.string() }),
      output: ResultSchema(z91.void(), z91.string())
    }
  },
  getSessionUsage: {
    input: z91.object({ workspaceId: z91.string() }),
    output: SessionUsageFileSchema.optional()
  },
  /** Batch fetch session usage for multiple workspaces (for archived workspaces cost display) */
  getSessionUsageBatch: {
    input: z91.object({ workspaceIds: z91.array(z91.string()) }),
    output: z91.record(z91.string(), SessionUsageFileSchema.optional())
  },
  /** Per-workspace MCP configuration (overrides project-level mcp.jsonc) */
  mcp: {
    get: {
      input: z91.object({ workspaceId: z91.string() }),
      output: WorkspaceMCPOverridesSchema
    },
    set: {
      input: z91.object({
        workspaceId: z91.string(),
        overrides: WorkspaceMCPOverridesSchema
      }),
      output: ResultSchema(z91.void(), z91.string())
    }
  }
};
var tasks = {
  create: {
    input: z91.object({
      parentWorkspaceId: z91.string(),
      kind: z91.literal("agent"),
      agentId: AgentIdSchema.optional(),
      /** @deprecated Legacy alias for agentId (kept for downgrade compatibility). */
      agentType: z91.string().min(1).optional(),
      prompt: z91.string(),
      title: z91.string().min(1),
      modelString: z91.string().optional(),
      thinkingLevel: z91.string().optional()
    }).superRefine((value2, ctx) => {
      const hasAgentId = typeof value2.agentId === "string" && value2.agentId.trim().length > 0;
      const hasAgentType = typeof value2.agentType === "string" && value2.agentType.trim().length > 0;
      if (hasAgentId === hasAgentType) {
        ctx.addIssue({
          code: z91.ZodIssueCode.custom,
          message: "tasks.create: exactly one of agentId or agentType is required",
          path: ["agentId"]
        });
      }
    }),
    output: ResultSchema(
      z91.object({
        taskId: z91.string(),
        kind: z91.literal("agent"),
        status: z91.enum(["queued", "running"])
      }),
      z91.string()
    )
  }
};
var AgentDiscoveryInputSchema = z91.object({
  projectPath: z91.string().optional(),
  workspaceId: z91.string().optional(),
  /** When true, skip workspace worktree and discover from projectPath (but still use workspace runtime) */
  disableWorkspaceAgents: z91.boolean().optional(),
  /** When true, include agents disabled by front-matter (for Settings UI). */
  includeDisabled: z91.boolean().optional()
}).refine((data) => Boolean(data.projectPath ?? data.workspaceId), {
  message: "Either projectPath or workspaceId must be provided"
});
var agents = {
  list: {
    input: AgentDiscoveryInputSchema,
    output: z91.array(AgentDefinitionDescriptorSchema)
  },
  get: {
    input: AgentDiscoveryInputSchema.and(z91.object({ agentId: AgentIdSchema })),
    output: AgentDefinitionPackageSchema
  }
};
var agentSkills = {
  list: {
    input: AgentDiscoveryInputSchema,
    output: z91.array(AgentSkillDescriptorSchema)
  },
  listDiagnostics: {
    input: AgentDiscoveryInputSchema,
    output: z91.object({
      skills: z91.array(AgentSkillDescriptorSchema),
      invalidSkills: z91.array(AgentSkillIssueSchema)
    })
  },
  get: {
    input: AgentDiscoveryInputSchema.and(z91.object({ skillName: SkillNameSchema })),
    output: AgentSkillPackageSchema
  }
};
var nameGeneration = {
  generate: {
    input: z91.object({
      message: z91.string(),
      /** Ordered list of model candidates to try (frontend applies gateway prefs) */
      candidates: z91.array(z91.string())
    }),
    output: ResultSchema(
      z91.object({
        /** Short git-safe name with suffix (e.g., "plan-a1b2") */
        name: z91.string(),
        /** Human-readable title (e.g., "Fix plan mode over SSH") */
        title: z91.string(),
        modelUsed: z91.string()
      }),
      SendMessageErrorSchema
    )
  }
};
var window2 = {
  setTitle: {
    input: z91.object({ title: z91.string() }),
    output: z91.void()
  }
};
var terminal = {
  create: {
    input: TerminalCreateParamsSchema,
    output: TerminalSessionSchema
  },
  close: {
    input: z91.object({ sessionId: z91.string() }),
    output: z91.void()
  },
  resize: {
    input: TerminalResizeParamsSchema,
    output: z91.void()
  },
  sendInput: {
    input: z91.object({ sessionId: z91.string(), data: z91.string() }),
    output: z91.void()
  },
  onOutput: {
    input: z91.object({ sessionId: z91.string() }),
    output: eventIterator(z91.string())
  },
  /**
   * Attach to a terminal session with race-free state restore.
   * First yields { type: "screenState", data: string } with serialized screen (~4KB),
   * then yields { type: "output", data: string } for each live output chunk.
   * Guarantees no missed output between state snapshot and live stream.
   */
  attach: {
    input: z91.object({ sessionId: z91.string() }),
    output: eventIterator(
      z91.discriminatedUnion("type", [
        z91.object({ type: z91.literal("screenState"), data: z91.string() }),
        z91.object({ type: z91.literal("output"), data: z91.string() })
      ])
    )
  },
  onExit: {
    input: z91.object({ sessionId: z91.string() }),
    output: eventIterator(z91.number())
  },
  openWindow: {
    input: z91.object({
      workspaceId: z91.string(),
      /** Optional session ID to reattach to an existing terminal session (for pop-out handoff) */
      sessionId: z91.string().optional()
    }),
    output: z91.void()
  },
  closeWindow: {
    input: z91.object({ workspaceId: z91.string() }),
    output: z91.void()
  },
  /**
   * List active terminal sessions for a workspace.
   * Used by frontend to discover existing sessions to reattach to after reload.
   */
  listSessions: {
    input: z91.object({ workspaceId: z91.string() }),
    output: z91.array(z91.string())
  },
  /**
   * Open the native system terminal for a workspace.
   * Opens the user's preferred terminal emulator (Ghostty, Terminal.app, etc.)
   * with the working directory set to the workspace path.
   */
  openNative: {
    input: z91.object({ workspaceId: z91.string() }),
    output: z91.void()
  }
};
var ApiServerStatusSchema = z91.object({
  running: z91.boolean(),
  /** Base URL that is always connectable from the local machine (loopback for wildcard binds). */
  baseUrl: z91.string().nullable(),
  /** The host/interface the server is actually bound to. */
  bindHost: z91.string().nullable(),
  /** The port the server is listening on. */
  port: z91.number().int().min(0).max(65535).nullable(),
  /** Additional base URLs that may be reachable from other devices (LAN/VPN). */
  networkBaseUrls: z91.array(z91.url()),
  /** Auth token required for HTTP/WS API access. */
  token: z91.string().nullable(),
  /** Configured bind host from ~/.mux/config.json (if set). */
  configuredBindHost: z91.string().nullable(),
  /** Configured port from ~/.mux/config.json (if set). */
  configuredPort: z91.number().int().min(0).max(65535).nullable(),
  /** Whether the API server should serve the mux web UI at /. */
  configuredServeWebUi: z91.boolean()
});
var server = {
  getLaunchProject: {
    input: z91.void(),
    output: z91.string().nullable()
  },
  getSshHost: {
    input: z91.void(),
    output: z91.string().nullable()
  },
  setSshHost: {
    input: z91.object({ sshHost: z91.string().nullable() }),
    output: z91.void()
  },
  getApiServerStatus: {
    input: z91.void(),
    output: ApiServerStatusSchema
  },
  setApiServerSettings: {
    input: z91.object({
      bindHost: z91.string().nullable(),
      port: z91.number().int().min(0).max(65535).nullable(),
      serveWebUi: z91.boolean().nullable().optional()
    }),
    output: ApiServerStatusSchema
  }
};
var SubagentAiDefaultsEntrySchema = z91.object({
  modelString: z91.string().min(1).optional(),
  thinkingLevel: z91.enum(["off", "low", "medium", "high", "xhigh", "max"]).optional(),
  enabled: z91.boolean().optional()
}).strict();
var AgentAiDefaultsSchema = z91.record(z91.string().min(1), SubagentAiDefaultsEntrySchema);
var SubagentAiDefaultsSchema = z91.record(z91.string().min(1), SubagentAiDefaultsEntrySchema);
var config = {
  getConfig: {
    input: z91.void(),
    output: z91.object({
      taskSettings: z91.object({
        maxParallelAgentTasks: z91.number().int(),
        maxTaskNestingDepth: z91.number().int(),
        proposePlanImplementReplacesChatHistory: z91.boolean().optional(),
        bashOutputCompactionMinLines: z91.number().int().optional(),
        bashOutputCompactionMinTotalBytes: z91.number().int().optional(),
        bashOutputCompactionMaxKeptLines: z91.number().int().optional(),
        bashOutputCompactionTimeoutMs: z91.number().int().optional(),
        bashOutputCompactionHeuristicFallback: z91.boolean().optional()
      }),
      muxGatewayEnabled: z91.boolean().optional(),
      muxGatewayModels: z91.array(z91.string()).optional(),
      defaultModel: z91.string().optional(),
      hiddenModels: z91.array(z91.string()).optional(),
      preferredCompactionModel: z91.string().optional(),
      stopCoderWorkspaceOnArchive: z91.boolean(),
      agentAiDefaults: AgentAiDefaultsSchema,
      // Legacy fields (downgrade compatibility)
      subagentAiDefaults: SubagentAiDefaultsSchema,
      // Mux Governor enrollment status (safe fields only - token never exposed)
      muxGovernorUrl: z91.string().nullable(),
      muxGovernorEnrolled: z91.boolean()
    })
  },
  saveConfig: {
    input: z91.object({
      taskSettings: z91.object({
        maxParallelAgentTasks: z91.number().int(),
        maxTaskNestingDepth: z91.number().int(),
        proposePlanImplementReplacesChatHistory: z91.boolean().optional(),
        bashOutputCompactionMinLines: z91.number().int().optional(),
        bashOutputCompactionMinTotalBytes: z91.number().int().optional(),
        bashOutputCompactionMaxKeptLines: z91.number().int().optional(),
        bashOutputCompactionTimeoutMs: z91.number().int().optional(),
        bashOutputCompactionHeuristicFallback: z91.boolean().optional()
      }),
      agentAiDefaults: AgentAiDefaultsSchema.optional(),
      // Legacy field (downgrade compatibility)
      subagentAiDefaults: SubagentAiDefaultsSchema.optional()
    }),
    output: z91.void()
  },
  updateAgentAiDefaults: {
    input: z91.object({
      agentAiDefaults: AgentAiDefaultsSchema
    }),
    output: z91.void()
  },
  updateMuxGatewayPrefs: {
    input: z91.object({
      muxGatewayEnabled: z91.boolean(),
      muxGatewayModels: z91.array(z91.string())
    }),
    output: z91.void()
  },
  updateModelPreferences: {
    input: z91.object({
      defaultModel: z91.string().optional(),
      hiddenModels: z91.array(z91.string()).optional(),
      preferredCompactionModel: z91.string().optional()
    }),
    output: z91.void()
  },
  updateCoderPrefs: {
    input: z91.object({
      stopCoderWorkspaceOnArchive: z91.boolean()
    }).strict(),
    output: z91.void()
  },
  unenrollMuxGovernor: {
    input: z91.void(),
    output: z91.void()
  }
};
var uiLayouts = {
  getAll: {
    input: z91.void(),
    output: LayoutPresetsConfigSchema
  },
  saveAll: {
    input: z91.object({
      layoutPresets: LayoutPresetsConfigSchema
    }).strict(),
    output: z91.void()
  }
};
var splashScreens = {
  getViewedSplashScreens: {
    input: z91.void(),
    output: z91.array(z91.string())
  },
  markSplashScreenViewed: {
    input: z91.object({
      splashId: z91.string()
    }),
    output: z91.void()
  }
};
var update = {
  check: {
    input: z91.void(),
    output: z91.void()
  },
  download: {
    input: z91.void(),
    output: z91.void()
  },
  install: {
    input: z91.void(),
    output: z91.void()
  },
  onStatus: {
    input: z91.void(),
    output: eventIterator(UpdateStatusSchema)
  }
};
var EditorTypeSchema = z91.enum(["vscode", "cursor", "zed", "custom"]);
var EditorConfigSchema = z91.object({
  editor: EditorTypeSchema,
  customCommand: z91.string().optional()
});
var StatsTabVariantSchema = z91.enum(["control", "stats"]);
var StatsTabOverrideSchema = z91.enum(["default", "on", "off"]);
var StatsTabStateSchema = z91.object({
  enabled: z91.boolean(),
  variant: StatsTabVariantSchema,
  override: StatsTabOverrideSchema
});
var features = {
  getStatsTabState: {
    input: z91.void(),
    output: StatsTabStateSchema
  },
  setStatsTabOverride: {
    input: z91.object({ override: StatsTabOverrideSchema }),
    output: StatsTabStateSchema
  }
};
var general = {
  listDirectory: {
    input: z91.object({ path: z91.string() }),
    output: ResultSchema(FileTreeNodeSchema)
  },
  /**
   * Create a directory at the specified path.
   * Creates parent directories recursively if they don't exist (like mkdir -p).
   */
  createDirectory: {
    input: z91.object({ path: z91.string() }),
    output: ResultSchema(z91.object({ normalizedPath: z91.string() }), z91.string())
  },
  ping: {
    input: z91.string(),
    output: z91.string()
  },
  /**
   * Test endpoint: emits numbered ticks at an interval.
   * Useful for verifying streaming works over HTTP and WebSocket.
   */
  tick: {
    input: z91.object({
      count: z91.number().int().min(1).max(100),
      intervalMs: z91.number().int().min(10).max(5e3)
    }),
    output: eventIterator(z91.object({ tick: z91.number(), timestamp: z91.number() }))
  },
  /**
   * Open a path in the user's configured code editor.
   * For SSH workspaces with useRemoteExtension enabled, uses Remote-SSH extension.
   *
   * @param workspaceId - The workspace (used to determine if SSH and get remote host)
   * @param targetPath - The path to open (workspace directory or specific file)
   * @param editorConfig - Editor configuration from user settings
   */
  openInEditor: {
    input: z91.object({
      workspaceId: z91.string(),
      targetPath: z91.string(),
      editorConfig: EditorConfigSchema
    }),
    output: ResultSchema(z91.void(), z91.string())
  }
};
var menu = {
  onOpenSettings: {
    input: z91.void(),
    output: eventIterator(z91.void())
  }
};
var voice = {
  transcribe: {
    input: z91.object({ audioBase64: z91.string() }),
    output: ResultSchema(z91.string(), z91.string())
  }
};
var debug = {
  /**
   * Trigger an artificial stream error for testing recovery.
   * Used by integration tests to simulate network errors mid-stream.
   */
  triggerStreamError: {
    input: z91.object({
      workspaceId: z91.string(),
      errorMessage: z91.string().optional()
    }),
    output: z91.boolean()
    // true if error was triggered on an active stream
  }
};
var PresetModelEntrySchema = z91.object({
  provider: z91.string(),
  modelId: z91.string(),
  metadata: CustomModelMetadataSchema.optional()
});
var ModelPresetSchema = z91.object({
  id: z91.string(),
  name: z91.string(),
  description: z91.string().optional(),
  createdAt: z91.number(),
  updatedAt: z91.number(),
  models: z91.array(PresetModelEntrySchema)
});
var modelPresets = {
  list: {
    input: z91.void(),
    output: z91.array(ModelPresetSchema)
  },
  save: {
    input: z91.object({
      name: z91.string().min(1),
      models: z91.array(PresetModelEntrySchema),
      description: z91.string().optional()
    }),
    output: ModelPresetSchema
  },
  get: {
    input: z91.object({ id: z91.string() }),
    output: ModelPresetSchema.nullable()
  },
  delete: {
    input: z91.object({ id: z91.string() }),
    output: ResultSchema(z91.void(), z91.string())
  },
  update: {
    input: z91.object({
      id: z91.string(),
      name: z91.string().optional(),
      description: z91.string().optional(),
      models: z91.array(PresetModelEntrySchema).optional()
    }),
    output: ResultSchema(ModelPresetSchema, z91.string())
  },
  export: {
    input: z91.object({ ids: z91.array(z91.string()).optional() }),
    output: z91.string()
  },
  import: {
    input: z91.object({ json: z91.string() }),
    output: ResultSchema(z91.array(ModelPresetSchema), z91.string())
  }
};
var CheckStatusSchema = z91.enum(["pass", "warn", "fail", "skip"]);
var OverallStatusSchema = z91.enum(["healthy", "warning", "error"]);
var CheckResultSchema = z91.object({
  status: CheckStatusSchema,
  message: z91.string(),
  details: z91.string().optional()
});
var HealthCheckResultSchema = z91.object({
  modelId: z91.string(),
  provider: z91.string(),
  timestamp: z91.number(),
  status: OverallStatusSchema,
  checks: z91.object({
    authentication: CheckResultSchema,
    modelExists: CheckResultSchema,
    tokenLimits: CheckResultSchema,
    pricing: CheckResultSchema,
    connectivity: CheckResultSchema
  })
});
var modelHealth = {
  checkModel: {
    input: z91.object({
      provider: z91.string(),
      modelId: z91.string(),
      metadata: CustomModelMetadataSchema.optional()
    }),
    output: HealthCheckResultSchema
  },
  checkAll: {
    input: z91.object({
      models: z91.array(
        z91.object({
          provider: z91.string(),
          modelId: z91.string(),
          metadata: CustomModelMetadataSchema.optional()
        })
      )
    }),
    output: z91.array(HealthCheckResultSchema)
  },
  getLastResults: {
    input: z91.void(),
    output: z91.array(HealthCheckResultSchema)
  }
};
var CostEntrySchema = z91.object({
  timestamp: z91.number(),
  workspaceId: z91.string(),
  model: z91.string(),
  inputTokens: z91.number(),
  outputTokens: z91.number(),
  cachedTokens: z91.number(),
  cacheCreateTokens: z91.number(),
  reasoningTokens: z91.number(),
  cost: z91.number()
});
var DailySummarySchema = z91.object({
  date: z91.string(),
  totalCost: z91.number(),
  requestCount: z91.number(),
  byModel: z91.record(
    z91.string(),
    z91.object({ cost: z91.number(), requests: z91.number(), tokens: z91.number() })
  )
});
var CostHistoryRangeSchema = z91.object({ start: z91.number().optional(), end: z91.number().optional() }).optional();
var CostSummaryTotalsSchema = z91.object({
  today: z91.number(),
  thisWeek: z91.number(),
  thisMonth: z91.number(),
  previousDay: z91.number(),
  previousWeek: z91.number(),
  previousMonth: z91.number()
});
var ModelCostBreakdownSchema = z91.record(
  z91.string(),
  z91.object({ cost: z91.number(), requests: z91.number(), tokens: z91.number() })
);
var costTracking = {
  getSummary: {
    input: z91.void(),
    output: CostSummaryTotalsSchema
  },
  getDailySummaries: {
    input: z91.object({ startDate: z91.string().optional(), endDate: z91.string().optional() }),
    output: z91.array(DailySummarySchema)
  },
  getModelBreakdown: {
    input: CostHistoryRangeSchema,
    output: ModelCostBreakdownSchema
  },
  prune: {
    input: z91.object({ retentionDays: z91.number().optional() }),
    output: z91.object({ pruned: z91.number() })
  }
};

// src/common/orpc/schemas/iconTheme.ts
import { z as z99 } from "zod";
var IconDefinitionSchema = z99.object({
  iconPath: z99.string(),
  fontCharacter: z99.string().optional(),
  fontColor: z99.string().optional(),
  fontSize: z99.string().optional(),
  fontId: z99.string().optional()
});
var IconThemeDocumentSchema = z99.object({
  fonts: z99.array(z99.unknown()).optional(),
  iconDefinitions: z99.record(z99.string(), IconDefinitionSchema),
  file: z99.string().optional(),
  folder: z99.string().optional(),
  folderExpanded: z99.string().optional(),
  rootFolder: z99.string().optional(),
  rootFolderExpanded: z99.string().optional(),
  fileExtensions: z99.record(z99.string(), z99.string()).optional(),
  fileNames: z99.record(z99.string(), z99.string()).optional(),
  folderNames: z99.record(z99.string(), z99.string()).optional(),
  folderNamesExpanded: z99.record(z99.string(), z99.string()).optional(),
  languageIds: z99.record(z99.string(), z99.string()).optional(),
  hidesExplorerArrows: z99.boolean().optional(),
  light: z99.record(z99.string(), z99.unknown()).optional(),
  highContrast: z99.record(z99.string(), z99.unknown()).optional()
});
var InstalledIconThemeSchema = z99.object({
  id: z99.string(),
  label: z99.string(),
  description: z99.string().optional(),
  publisher: z99.string().optional(),
  version: z99.string().optional(),
  themeDir: z99.string(),
  themeJsonPath: z99.string(),
  isBuiltin: z99.boolean()
});
var iconTheme = {
  getActiveThemeId: {
    input: z99.void(),
    output: z99.string()
  },
  setActiveTheme: {
    input: z99.object({ themeId: z99.string() }),
    output: z99.void()
  },
  getInstalledThemes: {
    input: z99.void(),
    output: z99.array(InstalledIconThemeSchema)
  },
  deleteTheme: {
    input: z99.object({ themeId: z99.string() }),
    output: z99.boolean()
  },
  getActiveThemeDocument: {
    input: z99.void(),
    output: IconThemeDocumentSchema.nullable()
  },
  importVsix: {
    input: z99.object({ vsixBase64: z99.string() }),
    output: z99.object({
      importedThemeIds: z99.array(z99.string()),
      errors: z99.array(z99.string())
    })
  },
  getIconFile: {
    input: z99.object({ themeId: z99.string(), iconPath: z99.string() }),
    output: z99.object({ data: z99.string(), mimeType: z99.string() }).nullable()
  }
};

// src/common/constants/muxGatewayOAuth.ts
var MUX_GATEWAY_ORIGIN = "https://gateway.mux.coder.com";
var MUX_GATEWAY_AUTHORIZE_URL = `${MUX_GATEWAY_ORIGIN}/oauth2/authorize`;
var MUX_GATEWAY_EXCHANGE_URL = `${MUX_GATEWAY_ORIGIN}/api/v1/oauth2/exchange`;
var MUX_GATEWAY_SESSION_EXPIRED_MESSAGE = "You've been logged out of mux gateway. Please login again to continue using Mux Gateway.";

// src/common/types/result.ts
function Ok(data) {
  return { success: true, data };
}
function Err(error) {
  return { success: false, error };
}

// src/node/utils/providerRequirements.ts
var PROVIDER_ENV_VARS = {
  anthropic: {
    apiKey: ["ANTHROPIC_API_KEY", "ANTHROPIC_AUTH_TOKEN"],
    baseUrl: ["ANTHROPIC_BASE_URL"]
  },
  openai: {
    apiKey: ["OPENAI_API_KEY"],
    baseUrl: ["OPENAI_BASE_URL", "OPENAI_API_BASE"],
    organization: ["OPENAI_ORG_ID"]
  },
  google: {
    apiKey: ["GOOGLE_GENERATIVE_AI_API_KEY", "GOOGLE_API_KEY"],
    baseUrl: ["GOOGLE_BASE_URL"]
  },
  xai: {
    apiKey: ["XAI_API_KEY"],
    baseUrl: ["XAI_BASE_URL"]
  },
  openrouter: {
    apiKey: ["OPENROUTER_API_KEY"]
  },
  deepseek: {
    apiKey: ["DEEPSEEK_API_KEY"]
  },
  "github-copilot": {
    apiKey: ["GITHUB_COPILOT_TOKEN"]
  },
  bedrock: {
    region: ["AWS_REGION", "AWS_DEFAULT_REGION"]
  }
};
function resolveEnv(keys, env3) {
  for (const key of keys ?? []) {
    const val = env3[key]?.trim();
    if (val) return val;
  }
  return void 0;
}
function resolveProviderCredentials(provider, config2, env3 = process.env) {
  if (provider === "bedrock") {
    const configRegion = typeof config2.region === "string" && config2.region ? config2.region : null;
    const region = configRegion ?? resolveEnv(PROVIDER_ENV_VARS.bedrock?.region, env3);
    return region ? { isConfigured: true, region } : { isConfigured: false, missingRequirement: "region" };
  }
  if (provider === "mux-gateway") {
    const couponCode = config2.couponCode ?? config2.voucher;
    return couponCode ? { isConfigured: true, couponCode } : { isConfigured: false, missingRequirement: "coupon_code" };
  }
  const def = PROVIDER_DEFINITIONS[provider];
  if (!def.requiresApiKey) {
    const hasExplicitConfig = Boolean(config2.baseUrl ?? (config2.models?.length ?? 0) > 0);
    return { isConfigured: hasExplicitConfig };
  }
  const envMapping = PROVIDER_ENV_VARS[provider];
  const configKey = config2.apiKey || null;
  const apiKey = configKey ?? resolveEnv(envMapping?.apiKey, env3);
  const baseUrl = config2.baseURL ?? config2.baseUrl ?? resolveEnv(envMapping?.baseUrl, env3);
  const organization = config2.organization ?? resolveEnv(envMapping?.organization, env3);
  if (apiKey) {
    return { isConfigured: true, apiKey, baseUrl, organization };
  }
  return { isConfigured: false, missingRequirement: "api_key" };
}

// src/node/services/workspaceTitleGenerator.ts
init_dist10();
import { z as z100 } from "zod";

// src/node/services/log.ts
import * as fs from "fs";
import * as path from "path";

// node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value2 = Math.max(red, green, blue) * 2;
        if (value2 === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value2 === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// node_modules/chalk/source/vendor/supports-color/index.js
import process2 from "node:process";
import os2 from "node:os";
import tty from "node:tty";
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = process2;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (process2.platform === "win32") {
    const osRelease = os2.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key) => key in env)) {
      return 3;
    }
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if (env.TERM === "xterm-ghostty") {
    return 3;
  }
  if (env.TERM === "wezterm") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

// node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = /* @__PURE__ */ Object.create(null);
var applyOptions = (object2, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object2.level = options.level === void 0 ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk2 = (...strings) => strings.join(" ");
  applyOptions(chalk2, options);
  Object.setPrototypeOf(chalk2, createChalk.prototype);
  return chalk2;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type2, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type2].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type2].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type2].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type2, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type2][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self, string) => {
  if (self.level <= 0 || !string) {
    return self[IS_EMPTY] ? "" : string;
  }
  let styler = self[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// src/common/utils/env.ts
function parseBoolEnv(value2) {
  if (!value2) return false;
  const normalized = value2.toLowerCase();
  return normalized === "1" || normalized === "true" || normalized === "yes";
}

// src/common/constants/paths.ts
import { homedir } from "os";
import { join } from "path";
var MUX_DIR_NAME = ".mux";
function getMuxHome() {
  if (process.env.MUX_ROOT) {
    return process.env.MUX_ROOT;
  }
  const baseName = MUX_DIR_NAME;
  const suffix = process.env.NODE_ENV === "development" ? "-dev" : "";
  return join(homedir(), baseName + suffix);
}

// src/node/services/log.ts
var _debugObjDir = null;
function getDebugObjDir() {
  _debugObjDir ??= path.join(getMuxHome(), "debug_obj");
  return _debugObjDir;
}
var LOG_LEVEL_PRIORITY = {
  error: 0,
  warn: 1,
  info: 2,
  debug: 3
};
function getDefaultLogLevel() {
  const envLevel = process.env.MUX_LOG_LEVEL?.toLowerCase();
  if (envLevel && envLevel in LOG_LEVEL_PRIORITY) {
    return envLevel;
  }
  if (parseBoolEnv(process.env.MUX_DEBUG)) {
    return "debug";
  }
  const isElectron = "electron" in process.versions;
  return isElectron ? "info" : "error";
}
var currentLogLevel = getDefaultLogLevel();
function shouldLog(level) {
  return LOG_LEVEL_PRIORITY[level] <= LOG_LEVEL_PRIORITY[currentLogLevel];
}
function isDebugMode() {
  return currentLogLevel === "debug";
}
function supportsColor2() {
  return process.stdout.isTTY ?? false;
}
var chalkDim = typeof source_default.dim === "function" ? source_default.dim : (text2) => text2;
var chalkCyan = typeof source_default.cyan === "function" ? source_default.cyan : (text2) => text2;
var chalkGray = typeof source_default.gray === "function" ? source_default.gray : (text2) => text2;
var chalkRed = typeof source_default.red === "function" ? source_default.red : (text2) => text2;
var chalkYellow = typeof source_default.yellow === "function" ? source_default.yellow : (text2) => text2;
function getTimestamp() {
  const now2 = /* @__PURE__ */ new Date();
  let hours = now2.getHours();
  const minutes = now2.getMinutes();
  const milliseconds = now2.getMilliseconds();
  const ampm = hours >= 12 ? "PM" : "AM";
  hours = hours % 12;
  hours = hours ? hours : 12;
  const mm = String(minutes).padStart(2, "0");
  const ms = String(milliseconds).padStart(3, "0");
  return `${hours}:${mm}.${ms}${ampm}`;
}
function getCallerLocation() {
  const error = new Error();
  const stack = error.stack?.split("\n");
  if (stack && stack.length > 4) {
    const callerLine = stack[4];
    const match = /\((.+):(\d+):\d+\)/.exec(callerLine) ?? /at (.+):(\d+):\d+/.exec(callerLine);
    if (match) {
      const [, filePath, lineNum] = match;
      const relativePath = filePath.replace(/^.*\/mux\//, "");
      return `${relativePath}:${lineNum}`;
    }
  }
  return "unknown:0";
}
function safePipeLog(level, ...args2) {
  if (!shouldLog(level)) {
    return;
  }
  const timestamp = getTimestamp();
  const location = getCallerLocation();
  const useColor = supportsColor2();
  let prefix;
  if (useColor) {
    const coloredTimestamp = chalkDim(timestamp);
    const coloredLocation = chalkCyan(location);
    if (level === "error") {
      prefix = `${coloredTimestamp} ${coloredLocation}`;
    } else if (level === "warn") {
      prefix = `${coloredTimestamp} ${coloredLocation}`;
    } else if (level === "debug") {
      prefix = `${coloredTimestamp} ${chalkGray(location)}`;
    } else {
      prefix = `${coloredTimestamp} ${coloredLocation}`;
    }
  } else {
    prefix = `${timestamp} ${location}`;
  }
  try {
    if (level === "error") {
      if (useColor) {
        console.error(
          prefix,
          ...args2.map((arg) => typeof arg === "string" ? chalkRed(arg) : arg)
        );
      } else {
        console.error(prefix, ...args2);
      }
    } else if (level === "warn") {
      if (useColor) {
        console.error(
          prefix,
          ...args2.map((arg) => typeof arg === "string" ? chalkYellow(arg) : arg)
        );
      } else {
        console.error(prefix, ...args2);
      }
    } else {
      console.log(prefix, ...args2);
    }
  } catch (error) {
    const errorCode = error && typeof error === "object" && "code" in error ? error.code : void 0;
    const errorMessage = error && typeof error === "object" && "message" in error ? String(error.message) : "Unknown error";
    if (errorCode !== "EPIPE") {
      try {
        const stream = level === "error" || level === "warn" ? process.stderr : process.stdout;
        stream.write(`${timestamp} ${location} Console error: ${errorMessage}
`);
      } catch {
      }
    }
  }
}
function debugObject(filename, obj) {
  if (!isDebugMode()) {
    return;
  }
  try {
    const debugObjDir = getDebugObjDir();
    fs.mkdirSync(debugObjDir, { recursive: true });
    const filePath = path.join(debugObjDir, filename);
    const dirPath = path.dirname(filePath);
    fs.mkdirSync(dirPath, { recursive: true });
    fs.writeFileSync(filePath, JSON.stringify(obj, null, 2), "utf-8");
    safePipeLog("debug", `Dumped object to ${filePath}`);
  } catch (error) {
    safePipeLog("error", `Failed to dump debug object to ${filename}:`, error);
  }
}
function isPlainObject(value2) {
  if (!value2 || typeof value2 !== "object") {
    return false;
  }
  if (Array.isArray(value2)) {
    return false;
  }
  if (value2 instanceof Error) {
    return false;
  }
  const proto2 = Object.getPrototypeOf(value2);
  return proto2 === Object.prototype || proto2 === null;
}
function normalizeFields(fields) {
  return fields && Object.keys(fields).length > 0 ? fields : void 0;
}
function mergeLogFields(base, extra) {
  return normalizeFields({ ...base ?? {}, ...extra ?? {} });
}
var baseLogger = {
  debug_obj: debugObject,
  setLevel: (level) => {
    currentLogLevel = level;
  },
  getLevel: () => currentLogLevel,
  isDebugMode
};
function appendFieldsToArgs(args2, fields) {
  if (!fields) {
    return args2;
  }
  if (args2.length === 0) {
    return [fields];
  }
  const lastArg = args2[args2.length - 1];
  if (isPlainObject(lastArg)) {
    return [...args2.slice(0, -1), { ...fields, ...lastArg }];
  }
  return [...args2, fields];
}
function createLogger(boundFields) {
  const normalizedFields = normalizeFields(boundFields);
  const logAtLevel = (level) => (...args2) => {
    safePipeLog(level, ...appendFieldsToArgs(args2, normalizedFields));
  };
  return {
    ...baseLogger,
    info: logAtLevel("info"),
    warn: logAtLevel("warn"),
    error: logAtLevel("error"),
    debug: logAtLevel("debug"),
    withFields: (fields) => createLogger(mergeLogFields(normalizedFields, fields))
  };
}
var log = createLogger();

// src/node/services/workspaceTitleGenerator.ts
import crypto2 from "crypto";
var workspaceIdentitySchema = z100.object({
  name: z100.string().regex(/^[a-z0-9-]+$/).min(2).max(20).describe(
    "Codebase area (1-2 words, max 15 chars): lowercase, hyphens only, e.g. 'sidebar', 'auth', 'config'"
  ),
  title: z100.string().min(5).max(60).describe("Human-readable title (2-5 words): verb-noun format like 'Fix plan mode'")
});
var CROCKFORD_ALPHABET = "0123456789abcdefghjkmnpqrstvwxyz";
function generateNameSuffix() {
  const bytes = crypto2.randomBytes(3);
  const value2 = bytes[0] << 12 | bytes[1] << 4 | bytes[2] >> 4;
  return CROCKFORD_ALPHABET[value2 >> 15 & 31] + CROCKFORD_ALPHABET[value2 >> 10 & 31] + CROCKFORD_ALPHABET[value2 >> 5 & 31] + CROCKFORD_ALPHABET[value2 & 31];
}
async function generateWorkspaceIdentity(message, candidates, aiService) {
  if (candidates.length === 0) {
    return Err({ type: "unknown", raw: "No model candidates provided for name generation" });
  }
  const maxAttempts = Math.min(candidates.length, 3);
  let lastApiError;
  for (let i = 0; i < maxAttempts; i++) {
    const modelString = candidates[i];
    const modelResult = await aiService.createModel(modelString);
    if (!modelResult.success) {
      log.debug(`Name generation: skipping ${modelString} (${modelResult.error.type})`);
      continue;
    }
    try {
      const stream = streamText({
        model: modelResult.data,
        output: output_exports.object({ schema: workspaceIdentitySchema }),
        prompt: `Generate a workspace name and title for this development task:

"${message}"

Requirements:
- name: The area of the codebase being worked on (1-2 words, max 15 chars, git-safe: lowercase, hyphens only). Random bytes will be appended for uniqueness, so focus on the area not the specific task. Examples: "sidebar", "auth", "config", "api"
- title: A 2-5 word description in verb-noun format. Examples: "Fix plan mode", "Add user authentication", "Refactor sidebar layout"`
      });
      const output = await stream.output;
      const suffix = generateNameSuffix();
      const sanitizedName = sanitizeBranchName(output.name, 20);
      const nameWithSuffix = `${sanitizedName}-${suffix}`;
      return Ok({
        name: nameWithSuffix,
        title: output.title.trim(),
        modelUsed: modelString
      });
    } catch (error) {
      if (NoObjectGeneratedError.isInstance(error) && error.text) {
        const textFallback = extractIdentityFromText(error.text);
        if (textFallback) {
          log.info(
            `Name generation: structured output failed for ${modelString}, recovered from text fallback`
          );
          const suffix = generateNameSuffix();
          const sanitizedName = sanitizeBranchName(textFallback.name, 20);
          const nameWithSuffix = `${sanitizedName}-${suffix}`;
          return Ok({
            name: nameWithSuffix,
            title: textFallback.title,
            modelUsed: modelString
          });
        }
      }
      lastApiError = error instanceof Error ? error.message : String(error);
      log.warn(`Name generation failed with ${modelString}, trying next candidate`, {
        error: lastApiError
      });
      continue;
    }
  }
  const errorMessage = lastApiError ? `Name generation failed: ${lastApiError}` : "Name generation failed - no working model found";
  return Err({ type: "unknown", raw: errorMessage });
}
function extractIdentityFromText(text2) {
  const jsonMatch = /\{[^}]*"name"\s*:\s*"([^"]+)"[^}]*"title"\s*:\s*"([^"]+)"[^}]*\}/.exec(text2);
  if (jsonMatch) {
    return validateExtracted(jsonMatch[1], jsonMatch[2]);
  }
  const jsonMatchReverse = /\{[^}]*"title"\s*:\s*"([^"]+)"[^}]*"name"\s*:\s*"([^"]+)"[^}]*\}/.exec(
    text2
  );
  if (jsonMatchReverse) {
    return validateExtracted(jsonMatchReverse[2], jsonMatchReverse[1]);
  }
  const nameMatch = /\*?\*?name:\*?\*?\s*`([^`]+)`/i.exec(text2) ?? /\bname:\s*"([^"]+)"/i.exec(text2);
  const titleMatch = /\*?\*?title:\*?\*?\s*`([^`]+)`/i.exec(text2) ?? /\btitle:\s*"([^"]+)"/i.exec(text2);
  if (nameMatch && titleMatch) {
    return validateExtracted(nameMatch[1], titleMatch[1]);
  }
  return null;
}
function validateExtracted(rawName, rawTitle) {
  const name25 = rawName.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "").replace(/-+/g, "-");
  const title = rawTitle.trim();
  if (name25.length < 2 || name25.length > 20) return null;
  if (title.length < 5 || title.length > 60) return null;
  return { name: name25, title };
}
function sanitizeBranchName(name25, maxLength) {
  return name25.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "").replace(/-+/g, "-").substring(0, maxLength);
}

// src/node/orpc/authMiddleware.ts
init_dist5();
import { timingSafeEqual } from "crypto";
function safeEq(a, b) {
  const bufA = Buffer.from(a);
  const bufB = Buffer.from(b);
  const maxLen = Math.max(bufA.length, bufB.length);
  const paddedA = Buffer.alloc(maxLen);
  const paddedB = Buffer.alloc(maxLen);
  bufA.copy(paddedA);
  bufB.copy(paddedB);
  const bytesMatch = timingSafeEqual(paddedA, paddedB);
  return bytesMatch && bufA.length === bufB.length;
}
function extractBearerToken(header) {
  const h = Array.isArray(header) ? header[0] : header;
  if (!h?.toLowerCase().startsWith("bearer ")) return null;
  return h.slice(7).trim() || null;
}
function createAuthMiddleware(authToken) {
  if (!authToken?.trim()) {
    return os.middleware(({ next }) => next());
  }
  const expectedToken = authToken.trim();
  return os.$context().errors({
    UNAUTHORIZED: {
      message: "Invalid or missing auth token"
    }
  }).middleware(({ context: context2, errors, next }) => {
    const presentedToken = extractBearerToken(context2.headers?.authorization);
    if (!presentedToken || !safeEq(presentedToken, expectedToken)) {
      throw errors.UNAUTHORIZED();
    }
    return next();
  });
}

// src/common/utils/asyncMessageQueue.ts
function createAsyncMessageQueue() {
  const queue = [];
  let resolveNext = null;
  let ended = false;
  const push = (msg) => {
    if (ended) return;
    queue.push(msg);
    if (resolveNext) {
      const resolve4 = resolveNext;
      resolveNext = null;
      resolve4();
    }
  };
  async function* iterate() {
    while (!ended) {
      while (queue.length > 0) {
        yield queue.shift();
      }
      await new Promise((resolve4) => {
        resolveNext = resolve4;
      });
    }
    while (queue.length > 0) {
      yield queue.shift();
    }
  }
  const end = () => {
    ended = true;
    if (resolveNext) {
      resolveNext();
    }
  };
  return { push, iterate, end };
}

// src/node/orpc/replayBufferedStreamMessageRelay.ts
function isReplayBufferedStreamMessage(message) {
  return message.type === "stream-delta" || message.type === "reasoning-delta" || message.type === "stream-end" || message.type === "stream-abort" || message.type === "stream-error";
}
function isReplayBufferedDeltaMessage(message) {
  return message.type === "stream-delta" || message.type === "reasoning-delta";
}
function isReplayMessage(message) {
  return message.replay === true;
}
function replayBufferedDeltaKey(message) {
  return JSON.stringify([message.type, message.messageId, message.timestamp, message.delta]);
}
function createReplayBufferedStreamMessageRelay(push) {
  let isReplaying = true;
  const bufferedLiveStreamMessages = [];
  const replayedDeltaKeyCounts = /* @__PURE__ */ new Map();
  const noteReplayedDelta = (message) => {
    const key = replayBufferedDeltaKey(message);
    replayedDeltaKeyCounts.set(key, (replayedDeltaKeyCounts.get(key) ?? 0) + 1);
  };
  const shouldDropBufferedDelta = (message) => {
    const key = replayBufferedDeltaKey(message);
    const remaining = replayedDeltaKeyCounts.get(key) ?? 0;
    if (remaining <= 0) {
      return false;
    }
    if (remaining === 1) {
      replayedDeltaKeyCounts.delete(key);
    } else {
      replayedDeltaKeyCounts.set(key, remaining - 1);
    }
    return true;
  };
  const handleSessionMessage = (message) => {
    if (isReplaying && isReplayBufferedStreamMessage(message)) {
      if (!isReplayMessage(message)) {
        bufferedLiveStreamMessages.push(message);
        return;
      }
      if (isReplayBufferedDeltaMessage(message)) {
        noteReplayedDelta(message);
      }
    }
    push(message);
  };
  const finishReplay = () => {
    for (const message of bufferedLiveStreamMessages) {
      if (isReplayBufferedDeltaMessage(message) && shouldDropBufferedDelta(message)) {
        continue;
      }
      push(message);
    }
    isReplaying = false;
    replayedDeltaKeyCounts.clear();
    bufferedLiveStreamMessages.length = 0;
  };
  return { handleSessionMessage, finishReplay };
}

// src/node/runtime/runtimeFactory.ts
import * as fs11 from "fs/promises";
import * as path19 from "path";

// src/node/runtime/initHook.ts
import * as fs2 from "fs";
import * as fsPromises from "fs/promises";
import * as path2 from "path";

// src/common/types/runtime.ts
function isSSHRuntime(config2) {
  return config2?.type === "ssh";
}
function hasSrcBaseDir(config2) {
  if (!config2) return false;
  return "srcBaseDir" in config2 && typeof config2.srcBaseDir === "string";
}

// src/node/runtime/initHook.ts
async function checkInitHookExists(projectPath) {
  const hookPath = path2.join(projectPath, ".mux", "init");
  try {
    await fsPromises.access(hookPath, fs2.constants.X_OK);
    return true;
  } catch {
    return false;
  }
}
function getInitHookPath(projectPath) {
  return path2.join(projectPath, ".mux", "init");
}
function getMuxEnv(projectPath, runtime, workspaceName, options) {
  if (!projectPath) {
    throw new Error("getMuxEnv: projectPath is required");
  }
  if (!workspaceName) {
    throw new Error("getMuxEnv: workspaceName is required");
  }
  const env3 = {
    MUX_PROJECT_PATH: projectPath,
    MUX_RUNTIME: runtime,
    MUX_WORKSPACE_NAME: workspaceName
  };
  if (options?.modelString) {
    env3.MUX_MODEL_STRING = options.modelString;
  }
  if (options?.thinkingLevel !== void 0) {
    env3.MUX_THINKING_LEVEL = options.thinkingLevel;
  }
  if (options?.costsUsd !== void 0) {
    env3.MUX_COSTS_USD = options.costsUsd.toFixed(2);
  }
  return env3;
}
var LineBuffer = class {
  constructor(logLine) {
    this.buffer = "";
    this.logLine = logLine;
  }
  /**
   * Process a chunk of data, splitting on newlines and logging complete lines
   */
  append(data) {
    this.buffer += data;
    const lines = this.buffer.split("\n");
    this.buffer = lines.pop() ?? "";
    for (const line of lines) {
      if (line) this.logLine(line);
    }
  }
  /**
   * Flush any remaining buffered data (called when stream closes)
   */
  flush() {
    if (this.buffer) {
      this.logLine(this.buffer);
      this.buffer = "";
    }
  }
};
function createLineBufferedLoggers(initLogger) {
  const stdoutBuffer = new LineBuffer((line) => initLogger.logStdout(line));
  const stderrBuffer = new LineBuffer((line) => initLogger.logStderr(line));
  return {
    stdout: {
      append: (data) => stdoutBuffer.append(data),
      flush: () => stdoutBuffer.flush()
    },
    stderr: {
      append: (data) => stderrBuffer.append(data),
      flush: () => stderrBuffer.flush()
    }
  };
}
async function runInitHookOnRuntime(runtime, hookPath, workspacePath, muxEnv, initLogger, abortSignal) {
  initLogger.logStep(`Running init hook: ${hookPath}`);
  const hookStream = await runtime.exec(hookPath, {
    cwd: workspacePath,
    timeout: 3600,
    // 1 hour - generous timeout for init hooks
    abortSignal,
    // When init is cancellable (archive/remove), we want abort to actually stop the remote hook.
    // With OpenSSH, allocating a PTY ensures the remote process is tied to the session and
    // receives a hangup when the client disconnects.
    forcePTY: abortSignal !== void 0,
    env: muxEnv
  });
  const loggers = createLineBufferedLoggers(initLogger);
  const stdoutReader = hookStream.stdout.getReader();
  const stderrReader = hookStream.stderr.getReader();
  const decoder = new TextDecoder();
  const readStdout = async () => {
    try {
      while (true) {
        const { done, value: value2 } = await stdoutReader.read();
        if (done) break;
        loggers.stdout.append(decoder.decode(value2, { stream: true }));
      }
      loggers.stdout.flush();
    } finally {
      stdoutReader.releaseLock();
    }
  };
  const readStderr = async () => {
    try {
      while (true) {
        const { done, value: value2 } = await stderrReader.read();
        if (done) break;
        loggers.stderr.append(decoder.decode(value2, { stream: true }));
      }
      loggers.stderr.flush();
    } finally {
      stderrReader.releaseLock();
    }
  };
  const [exitCode] = await Promise.all([hookStream.exitCode, readStdout(), readStderr()]);
  initLogger.logComplete(exitCode);
}

// src/common/utils/errors.ts
function getErrorMessage4(error) {
  return error instanceof Error ? error.message : String(error);
}

// src/node/runtime/LocalBaseRuntime.ts
import { spawn } from "child_process";
import * as fs3 from "fs";
import * as fsPromises2 from "fs/promises";
import * as path5 from "path";
import { Readable, Writable } from "stream";

// src/node/runtime/Runtime.ts
var WORKSPACE_REPO_MISSING_ERROR = "Workspace setup incomplete: repository not found.";
var RuntimeError = class extends Error {
  constructor(message, type2, cause) {
    super(message);
    this.type = type2;
    this.cause = cause;
    this.name = "RuntimeError";
  }
};

// src/common/constants/env.ts
var NON_INTERACTIVE_ENV_VARS = {
  // Prevent interactive editors from blocking execution
  // Critical for git operations like rebase/commit that try to open editors
  GIT_EDITOR: "true",
  // Git-specific editor (highest priority)
  GIT_SEQUENCE_EDITOR: "true",
  // For interactive rebase sequences
  EDITOR: "true",
  // General fallback for non-git commands
  VISUAL: "true",
  // Another common editor environment variable
  // Prevent git from prompting for credentials
  GIT_TERMINAL_PROMPT: "0"
  // Disables git credential prompts
};

// src/node/utils/main/bashPath.ts
import { execSync } from "child_process";
import { existsSync } from "fs";
import path3 from "path";
var WIN_PATH = path3.win32;
var BASH_PATH_ERROR_COOLDOWN_MS = 3e4;
var cachedBashPath = null;
var cachedBashPathError = null;
var defaultExecSync = (command, options) => execSync(command, options);
function parseWhereOutput(output) {
  return output.split(/\r?\n/).map((line) => line.trim()).filter((line) => line.length > 0);
}
function isWslLauncherPath(p) {
  const normalized = WIN_PATH.normalize(p).toLowerCase();
  return normalized.endsWith("\\windows\\system32\\bash.exe") || normalized.endsWith("\\windows\\system32\\wsl.exe");
}
function looksLikeGitForWindowsBash(bashPath, existsSyncFn) {
  if (isWslLauncherPath(bashPath)) {
    return false;
  }
  const normalized = WIN_PATH.normalize(bashPath);
  const lower = normalized.toLowerCase();
  if (lower.endsWith("\\usr\\bin\\bash.exe")) {
    const root = WIN_PATH.dirname(WIN_PATH.dirname(WIN_PATH.dirname(normalized)));
    return existsSyncFn(WIN_PATH.join(root, "cmd", "git.exe"));
  }
  if (lower.endsWith("\\bin\\bash.exe")) {
    const root = WIN_PATH.dirname(WIN_PATH.dirname(normalized));
    return existsSyncFn(WIN_PATH.join(root, "cmd", "git.exe"));
  }
  let dir = WIN_PATH.dirname(normalized);
  for (let i = 0; i < 4; i++) {
    if (existsSyncFn(WIN_PATH.join(dir, "cmd", "git.exe"))) {
      return true;
    }
    const parent = WIN_PATH.dirname(dir);
    if (parent === dir) {
      break;
    }
    dir = parent;
  }
  return false;
}
function findGitRootFromGitExePath(gitExePath, existsSyncFn) {
  let dir = WIN_PATH.dirname(WIN_PATH.dirname(WIN_PATH.normalize(gitExePath)));
  for (let i = 0; i < 4; i++) {
    if (existsSyncFn(WIN_PATH.join(dir, "cmd", "git.exe"))) {
      return dir;
    }
    const parent = WIN_PATH.dirname(dir);
    if (parent === dir) {
      break;
    }
    dir = parent;
  }
  return null;
}
function findWindowsBash(params) {
  const { env: env3, execSyncFn, existsSyncFn } = params;
  const gitRoots = [
    // Git for Windows default paths
    "C:\\Program Files\\Git",
    "C:\\Program Files (x86)\\Git",
    // Chocolatey installation
    "C:\\tools\\git"
  ];
  if (env3.LOCALAPPDATA) {
    gitRoots.push(WIN_PATH.join(env3.LOCALAPPDATA, "Programs", "Git"));
  }
  if (env3.USERPROFILE) {
    gitRoots.push(WIN_PATH.join(env3.USERPROFILE, "scoop", "apps", "git", "current"));
  }
  const commonPaths = gitRoots.flatMap((root) => [
    WIN_PATH.join(root, "bin", "bash.exe"),
    WIN_PATH.join(root, "usr", "bin", "bash.exe")
  ]);
  for (const bashPath of commonPaths) {
    if (existsSyncFn(bashPath) && looksLikeGitForWindowsBash(bashPath, existsSyncFn)) {
      return bashPath;
    }
  }
  try {
    const result = execSyncFn("where git", {
      encoding: "utf8",
      stdio: ["pipe", "pipe", "ignore"],
      windowsHide: true
    });
    for (const gitExePath of parseWhereOutput(result)) {
      if (!existsSyncFn(gitExePath)) {
        continue;
      }
      const gitRoot = findGitRootFromGitExePath(gitExePath, existsSyncFn);
      if (!gitRoot) {
        continue;
      }
      const candidateBashPaths = [
        WIN_PATH.join(gitRoot, "bin", "bash.exe"),
        WIN_PATH.join(gitRoot, "usr", "bin", "bash.exe")
      ];
      for (const bashPath of candidateBashPaths) {
        if (existsSyncFn(bashPath) && looksLikeGitForWindowsBash(bashPath, existsSyncFn)) {
          return bashPath;
        }
      }
    }
  } catch {
  }
  try {
    const result = execSyncFn("where bash", {
      encoding: "utf8",
      stdio: ["pipe", "pipe", "ignore"],
      windowsHide: true
    });
    for (const bashPath of parseWhereOutput(result)) {
      if (!existsSyncFn(bashPath)) {
        continue;
      }
      if (looksLikeGitForWindowsBash(bashPath, existsSyncFn)) {
        return bashPath;
      }
    }
  } catch {
  }
  return null;
}
function getBashPathForPlatform(params) {
  if (params.platform !== "win32") {
    return "bash";
  }
  const bashPath = findWindowsBash({
    env: params.env ?? process.env,
    execSyncFn: params.execSyncFn ?? defaultExecSync,
    existsSyncFn: params.existsSyncFn ?? existsSync
  });
  if (!bashPath) {
    throw new Error(
      "Git Bash not found. On Windows, mux requires Git for Windows (Git Bash). WSL is not supported. Install Git for Windows from https://git-scm.com/download/win"
    );
  }
  return bashPath;
}
function getBashPath(params = {}) {
  const platform2 = params.platform ?? process.platform;
  if (platform2 !== "win32") {
    return "bash";
  }
  if (cachedBashPath !== null) {
    return cachedBashPath;
  }
  const nowFn = params.nowFn ?? Date.now;
  const now2 = nowFn();
  if (cachedBashPathError && now2 - cachedBashPathError.lastCheckedMs < BASH_PATH_ERROR_COOLDOWN_MS) {
    throw new Error(cachedBashPathError.message);
  }
  try {
    cachedBashPath = getBashPathForPlatform({
      platform: platform2,
      env: params.env,
      execSyncFn: params.execSyncFn,
      existsSyncFn: params.existsSyncFn
    });
    cachedBashPathError = null;
    return cachedBashPath;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    cachedBashPathError = { message, lastCheckedMs: now2 };
    throw error;
  }
}

// src/common/utils/shell.ts
function shellQuote(value2) {
  if (value2.length === 0) return "''";
  return "'" + value2.replace(/'/g, `'"'"'`) + "'";
}

// src/common/constants/exitCodes.ts
var EXIT_CODE_ABORTED = -997;
var EXIT_CODE_TIMEOUT = -998;

// src/node/utils/disposableExec.ts
import { exec, execFileSync } from "child_process";
function killProcessTree(pid) {
  if (!Number.isFinite(pid) || pid <= 0) {
    return;
  }
  if (process.platform === "win32") {
    try {
      execFileSync("taskkill", ["/PID", String(pid), "/T", "/F"], {
        stdio: "ignore",
        windowsHide: true
      });
    } catch {
    }
    return;
  }
  try {
    process.kill(-pid, "SIGKILL");
  } catch {
    try {
      process.kill(pid, "SIGKILL");
    } catch {
    }
  }
}
var DisposableProcess = class {
  constructor(process3) {
    this.process = process3;
    this.cleanupCallbacks = [];
    this.disposed = false;
  }
  /**
   * Register cleanup callback to run when process is disposed.
   * If already disposed, runs immediately.
   */
  addCleanup(callback) {
    if (this.disposed) {
      try {
        callback();
      } catch {
      }
    } else {
      this.cleanupCallbacks.push(callback);
    }
  }
  /**
   * Get the underlying child process
   */
  get underlying() {
    return this.process;
  }
  /**
   * Cleanup: kill process + run all cleanup callbacks immediately.
   * Safe to call multiple times (idempotent).
   */
  [Symbol.dispose]() {
    if (this.disposed) return;
    this.disposed = true;
    if (!this.process.killed && this.process.exitCode === null && this.process.signalCode === null) {
      const pid = this.process.pid;
      if (pid !== void 0 && pid > 0) {
        killProcessTree(pid);
      } else {
        try {
          this.process.kill("SIGKILL");
        } catch {
        }
      }
    }
    for (const callback of this.cleanupCallbacks) {
      try {
        callback();
      } catch {
      }
    }
    this.cleanupCallbacks = [];
  }
};
var DisposableExec = class {
  constructor(promise, child) {
    this.promise = promise;
    this.child = child;
  }
  [Symbol.dispose]() {
    const hasExited = this.child.exitCode !== null || this.child.signalCode !== null;
    if (!hasExited && !this.child.killed) {
      this.child.kill();
    }
  }
  get result() {
    return this.promise;
  }
};
function execAsync(command, options) {
  const child = exec(command, { shell: options?.shell });
  const promise = new Promise((resolve4, reject) => {
    let stdout = "";
    let stderr = "";
    let exitCode = null;
    let exitSignal = null;
    child.stdout?.on("data", (data) => {
      stdout += data;
    });
    child.stderr?.on("data", (data) => {
      stderr += data;
    });
    child.on("exit", (code, signal) => {
      exitCode = code;
      exitSignal = signal;
    });
    child.on("close", () => {
      if (exitCode === 0 && exitSignal === null) {
        resolve4({ stdout, stderr });
      } else {
        const errorMsg = stderr.trim() || (exitSignal ? `Command killed by signal ${exitSignal}` : `Command failed with exit code ${exitCode ?? "unknown"}`);
        const error = new Error(errorMsg);
        error.code = exitCode;
        error.signal = exitSignal;
        error.stdout = stdout;
        error.stderr = stderr;
        reject(error);
      }
    });
    child.on("error", reject);
  });
  return new DisposableExec(promise, child);
}

// src/node/runtime/tildeExpansion.ts
import path4 from "path";

// src/node/utils/paths.main.ts
import { platform, env as env2 } from "node:process";
function isWindowsPlatform() {
  return platform === "win32";
}
function getSeparator() {
  return isWindowsPlatform() ? "\\" : "/";
}
function getHomeDir() {
  if (isWindowsPlatform()) {
    return env2.USERPROFILE ?? "";
  }
  return env2.HOME ?? "";
}
var PlatformPaths = class {
  /**
   * Get the appropriate path separator for the current platform
   */
  static get separator() {
    return getSeparator();
  }
  /**
   * Extract basename from path (OS-aware)
   */
  static basename(filePath) {
    if (!filePath || typeof filePath !== "string") {
      return filePath;
    }
    const lastSlash = isWindowsPlatform() ? Math.max(filePath.lastIndexOf("/"), filePath.lastIndexOf("\\")) : filePath.lastIndexOf("/");
    if (lastSlash === -1) {
      return filePath;
    }
    return filePath.slice(lastSlash + 1);
  }
  /**
   * Split path into components (OS-aware)
   */
  static parse(filePath) {
    if (!filePath || typeof filePath !== "string") {
      return { root: "", segments: [], basename: filePath };
    }
    const original = filePath;
    let root = "";
    let dir = "";
    let base = "";
    const lastSlash = isWindowsPlatform() ? Math.max(original.lastIndexOf("/"), original.lastIndexOf("\\")) : original.lastIndexOf("/");
    if (lastSlash === -1) {
      base = original;
      dir = "";
    } else {
      base = original.slice(lastSlash + 1);
      dir = original.slice(0, lastSlash);
    }
    if (isWindowsPlatform()) {
      const driveMatch = /^[A-Za-z]:[\\/]/.exec(original);
      if (driveMatch) {
        root = driveMatch[0];
        if (dir.startsWith(root)) {
          dir = dir.slice(root.length);
        }
      } else if (original.startsWith("\\\\")) {
        root = "\\\\";
        if (dir.startsWith(root)) {
          dir = dir.slice(root.length);
        }
      }
      if (!root && original.startsWith("/")) {
        root = "/";
        if (dir.startsWith(root)) {
          dir = dir.slice(root.length);
        }
      }
    } else if (original.startsWith("/")) {
      root = "/";
      if (dir.startsWith(root)) {
        dir = dir.slice(root.length);
      }
    }
    const separatorRegex = isWindowsPlatform() ? /[\\/]+/ : /\/+/;
    const segments = dir ? dir.split(separatorRegex).filter(Boolean) : [];
    return {
      root,
      segments,
      basename: base
    };
  }
  /**
   * Format path for display with fish-style abbreviation (OS-aware)
   * Abbreviates all directory components except the last one to their first letter
   */
  static abbreviate(filePath) {
    if (!filePath || typeof filePath !== "string") {
      return filePath;
    }
    const { root, segments, basename } = this.parse(filePath);
    const abbreviated = segments.map((seg) => seg.length > 0 ? seg[0] : seg);
    if (!root && abbreviated.length === 0) {
      return basename;
    }
    const sep = isWindowsPlatform() ? filePath.includes("\\") ? "\\" : "/" : "/";
    const joined = [...abbreviated, basename].filter(Boolean).join(sep);
    if (!root) {
      return joined;
    }
    const rootEndsWithSep = root.endsWith("\\") || root.endsWith("/");
    return rootEndsWithSep ? root + joined : root + sep + joined;
  }
  /**
   * Split an abbreviated path into directory path and basename
   */
  static splitAbbreviated(filePath) {
    if (!filePath || typeof filePath !== "string") {
      return { dirPath: "", basename: filePath };
    }
    const sep = isWindowsPlatform() ? filePath.includes("\\") ? "\\" : "/" : "/";
    const lastSlash = filePath.lastIndexOf(sep);
    if (lastSlash === -1) {
      return { dirPath: "", basename: filePath };
    }
    return {
      dirPath: filePath.slice(0, lastSlash + 1),
      basename: filePath.slice(lastSlash + 1)
    };
  }
  /**
   * Format home directory path for display (shows ~ on Unix, full path on Windows)
   */
  static formatHome(filePath) {
    if (!filePath || typeof filePath !== "string") {
      return filePath;
    }
    const home = getHomeDir();
    if (!home) {
      return filePath;
    }
    if (filePath.startsWith(home)) {
      return filePath.replace(home, "~");
    }
    return filePath;
  }
  /**
   * Expand user home in path (cross-platform)
   * Handles ~ on Unix and %USERPROFILE% on Windows
   */
  static expandHome(filePath) {
    if (!filePath || typeof filePath !== "string") {
      return filePath;
    }
    const muxRoot = env2.MUX_ROOT;
    if (muxRoot) {
      const normalizedMuxRoot = muxRoot.replace(/[\\/]+$/g, "");
      const sep = getSeparator();
      const prefixes = ["~/.mux", "~\\.mux"];
      for (const prefix of prefixes) {
        if (filePath === prefix) {
          return normalizedMuxRoot;
        }
        const slashPrefix = `${prefix}/`;
        const backslashPrefix = `${prefix}\\`;
        if (filePath.startsWith(slashPrefix) || filePath.startsWith(backslashPrefix)) {
          const rest = filePath.slice(prefix.length + 1);
          const normalizedRest = rest.replace(/[\\/]+/g, sep);
          return normalizedMuxRoot + (normalizedRest ? sep + normalizedRest : "");
        }
      }
    }
    if (filePath === "~") {
      return getHomeDir() || filePath;
    }
    if (filePath.startsWith("~/") || filePath.startsWith("~\\")) {
      const home = getHomeDir();
      if (!home) return filePath;
      const sep = getSeparator();
      const rest = filePath.slice(2);
      return home + (rest ? sep + rest.replace(/[\\/]+/g, sep) : "");
    }
    if (isWindowsPlatform() && filePath.includes("%USERPROFILE%")) {
      const home = getHomeDir();
      if (!home) return filePath;
      return filePath.replace(/%USERPROFILE%/g, home);
    }
    return filePath;
  }
  /**
   * Get project name from path (OS-aware)
   * Extracts the final directory name from a project path
   */
  static getProjectName(projectPath) {
    return this.basename(projectPath) || "unknown";
  }
};

// src/node/runtime/tildeExpansion.ts
function expandTilde(filePath) {
  const muxPrefixes = ["~/.mux", "~\\.mux", "~/.cmux", "~\\.cmux"];
  for (const prefix of muxPrefixes) {
    if (!filePath.startsWith(prefix)) {
      continue;
    }
    const nextChar = filePath.at(prefix.length);
    if (nextChar !== void 0 && nextChar !== "/" && nextChar !== "\\") {
      continue;
    }
    const muxHome = getMuxHome();
    const suffix = filePath.slice(prefix.length).replace(/^[/\\]+/, "");
    const normalizedSuffix = suffix.replace(/[/\\]+/g, path4.sep);
    return normalizedSuffix ? path4.join(muxHome, normalizedSuffix) : muxHome;
  }
  return PlatformPaths.expandHome(filePath);
}
function expandTildeForSSH(path24) {
  if (path24 === "~") {
    return '"$HOME"';
  } else if (path24.startsWith("~/")) {
    const pathAfterTilde = path24.slice(2);
    const escaped = pathAfterTilde.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\$/g, "\\$").replace(/`/g, "\\`");
    return `"$HOME/${escaped}"`;
  } else {
    return `"${path24.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\$/g, "\\$").replace(/`/g, "\\`")}"`;
  }
}
function cdCommandForSSH(path24) {
  return `cd ${expandTildeForSSH(path24)}`;
}

// src/node/runtime/LocalBaseRuntime.ts
var LocalBaseRuntime = class {
  async exec(command, options) {
    const startTime = performance.now();
    const cwd = options.cwd;
    try {
      await fsPromises2.access(cwd);
    } catch (err) {
      throw new RuntimeError(
        `Working directory does not exist: ${cwd}`,
        "exec",
        err instanceof Error ? err : void 0
      );
    }
    const bashPath = getBashPath();
    const spawnCommand = bashPath;
    const nonInteractivePrelude = Object.entries(NON_INTERACTIVE_ENV_VARS).map(([key, value2]) => `export ${key}=${shellQuote(value2)}`).join("\n");
    const spawnArgs = ["-c", `${nonInteractivePrelude}
${command}`];
    const defaultPath = "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin";
    const effectivePath = (options.env?.PATH && options.env.PATH.length > 0 ? options.env.PATH : process.env.PATH) ?? defaultPath;
    const childProcess = spawn(spawnCommand, spawnArgs, {
      cwd,
      env: {
        ...process.env,
        ...options.env ?? {},
        ...NON_INTERACTIVE_ENV_VARS,
        PATH: effectivePath
      },
      stdio: ["pipe", "pipe", "pipe"],
      // CRITICAL: Spawn as detached process group leader to enable cleanup of background processes.
      // When a bash script spawns background processes (e.g., `sleep 100 &`), we need to kill
      // the entire process group (including all backgrounded children) via process.kill(-pid).
      // NOTE: detached:true does NOT cause bash to wait for background jobs when using 'exit' event
      // instead of 'close' event. The 'exit' event fires when bash exits, ignoring background children.
      detached: true,
      // Prevent console window from appearing on Windows (WSL bash spawns steal focus otherwise)
      windowsHide: true
    });
    const disposable = new DisposableProcess(childProcess);
    const stdout = Readable.toWeb(childProcess.stdout);
    const stderr = Readable.toWeb(childProcess.stderr);
    const stdin = Writable.toWeb(childProcess.stdin);
    let timedOut = false;
    let aborted = false;
    const exitCode = new Promise((resolve4, reject) => {
      childProcess.on("exit", (code) => {
        if (childProcess.pid !== void 0) {
          killProcessTree(childProcess.pid);
        }
        if (aborted || options.abortSignal?.aborted) {
          resolve4(EXIT_CODE_ABORTED);
          return;
        }
        if (timedOut) {
          resolve4(EXIT_CODE_TIMEOUT);
          return;
        }
        resolve4(code ?? 0);
      });
      childProcess.on("error", (err) => {
        reject(new RuntimeError(`Failed to execute command: ${err.message}`, "exec", err));
      });
    });
    const duration = exitCode.then(() => performance.now() - startTime);
    void exitCode.catch(() => void 0);
    void duration.catch(() => void 0);
    disposable.addCleanup(() => {
      if (childProcess.pid === void 0) return;
      killProcessTree(childProcess.pid);
    });
    if (options.abortSignal) {
      options.abortSignal.addEventListener("abort", () => {
        aborted = true;
        disposable[Symbol.dispose]();
      });
    }
    if (options.timeout !== void 0) {
      const timeoutHandle = setTimeout(() => {
        timedOut = true;
        disposable[Symbol.dispose]();
      }, options.timeout * 1e3);
      void exitCode.catch(() => void 0).finally(() => clearTimeout(timeoutHandle));
    }
    return { stdout, stderr, stdin, exitCode, duration };
  }
  readFile(filePath, _abortSignal) {
    const expandedPath = expandTilde(filePath);
    const nodeStream = fs3.createReadStream(expandedPath);
    const webStream = Readable.toWeb(nodeStream);
    return new ReadableStream({
      async start(controller) {
        try {
          const reader = webStream.getReader();
          while (true) {
            const { done, value: value2 } = await reader.read();
            if (done) break;
            controller.enqueue(value2);
          }
          controller.close();
        } catch (err) {
          controller.error(
            new RuntimeError(
              `Failed to read file ${filePath}: ${err instanceof Error ? err.message : String(err)}`,
              "file_io",
              err instanceof Error ? err : void 0
            )
          );
        }
      }
    });
  }
  writeFile(filePath, _abortSignal) {
    const expandedPath = expandTilde(filePath);
    let tempPath;
    let writer;
    let resolvedPath;
    let originalMode;
    return new WritableStream({
      async start() {
        try {
          resolvedPath = await fsPromises2.realpath(expandedPath);
          const stat4 = await fsPromises2.stat(resolvedPath);
          originalMode = stat4.mode;
        } catch {
          resolvedPath = expandedPath;
          originalMode = void 0;
        }
        const parentDir = path5.dirname(resolvedPath);
        await fsPromises2.mkdir(parentDir, { recursive: true });
        tempPath = `${resolvedPath}.tmp.${Date.now()}`;
        const nodeStream = fs3.createWriteStream(tempPath);
        const webStream = Writable.toWeb(nodeStream);
        writer = webStream.getWriter();
      },
      async write(chunk) {
        await writer.write(chunk);
      },
      async close() {
        await writer.close();
        try {
          if (originalMode !== void 0) {
            await fsPromises2.chmod(tempPath, originalMode);
          }
          await fsPromises2.rename(tempPath, resolvedPath);
        } catch (err) {
          throw new RuntimeError(
            `Failed to write file ${filePath}: ${err instanceof Error ? err.message : String(err)}`,
            "file_io",
            err instanceof Error ? err : void 0
          );
        }
      },
      async abort(reason) {
        await writer.abort();
        try {
          await fsPromises2.unlink(tempPath);
        } catch {
        }
        throw new RuntimeError(
          `Failed to write file ${filePath}: ${String(reason)}`,
          "file_io"
        );
      }
    });
  }
  async stat(filePath, _abortSignal) {
    const expandedPath = expandTilde(filePath);
    try {
      const stats = await fsPromises2.stat(expandedPath);
      return {
        size: stats.size,
        modifiedTime: stats.mtime,
        isDirectory: stats.isDirectory()
      };
    } catch (err) {
      throw new RuntimeError(
        `Failed to stat ${filePath}: ${err instanceof Error ? err.message : String(err)}`,
        "file_io",
        err instanceof Error ? err : void 0
      );
    }
  }
  async ensureDir(dirPath) {
    const expandedPath = expandTilde(dirPath);
    try {
      await fsPromises2.mkdir(expandedPath, { recursive: true });
    } catch (err) {
      throw new RuntimeError(
        `Failed to create directory ${dirPath}: ${err instanceof Error ? err.message : String(err)}`,
        "file_io",
        err instanceof Error ? err : void 0
      );
    }
  }
  resolvePath(filePath) {
    const expanded = expandTilde(filePath);
    return Promise.resolve(path5.resolve(expanded));
  }
  normalizePath(targetPath, basePath) {
    const target = targetPath.trim();
    if (target === ".") {
      return path5.resolve(basePath);
    }
    const expanded = expandTilde(target);
    return path5.resolve(basePath, expanded);
  }
  /**
   * Get the runtime's temp directory.
   * Uses OS temp dir on local systems.
   */
  tempDir() {
    const isWindows = process.platform === "win32";
    return Promise.resolve(isWindows ? process.env.TEMP ?? "C:\\Temp" : "/tmp");
  }
  getMuxHome() {
    return "~/.mux";
  }
  /**
   * Local runtimes are always ready.
   */
  ensureReady() {
    return Promise.resolve({ ready: true });
  }
  /**
   * Helper to run .mux/init hook if it exists and is executable.
   * Shared between WorktreeRuntime and LocalRuntime.
   * @param workspacePath - Path to the workspace directory
   * @param muxEnv - MUX_ environment variables (from getMuxEnv)
   * @param initLogger - Logger for streaming output
   * @param abortSignal - Optional abort signal
   */
  async runInitHook(workspacePath, muxEnv, initLogger, abortSignal) {
    const projectPath = muxEnv.MUX_PROJECT_PATH;
    const hookPath = getInitHookPath(projectPath);
    initLogger.logStep(`Running init hook: ${hookPath}`);
    if (abortSignal?.aborted) {
      initLogger.logComplete(EXIT_CODE_ABORTED);
      return;
    }
    const loggers = createLineBufferedLoggers(initLogger);
    return new Promise((resolve4) => {
      const bashPath = getBashPath();
      const proc = spawn(bashPath, ["-c", `"${hookPath}"`], {
        cwd: workspacePath,
        stdio: ["ignore", "pipe", "pipe"],
        env: {
          ...process.env,
          ...muxEnv
        },
        // Prevent console window from appearing on Windows
        windowsHide: true,
        // Spawn as a detached process group leader so we can reliably cancel the hook.
        detached: true
      });
      let aborted = false;
      const onAbort = () => {
        aborted = true;
        if (proc.pid !== void 0) {
          killProcessTree(proc.pid);
          return;
        }
        try {
          proc.kill("SIGKILL");
        } catch {
        }
      };
      abortSignal?.addEventListener("abort", onAbort, { once: true });
      if (abortSignal?.aborted) {
        onAbort();
      }
      proc.stdout.on("data", (data) => {
        loggers.stdout.append(data.toString());
      });
      proc.stderr.on("data", (data) => {
        loggers.stderr.append(data.toString());
      });
      proc.on("close", (code) => {
        abortSignal?.removeEventListener("abort", onAbort);
        loggers.stdout.flush();
        loggers.stderr.flush();
        initLogger.logComplete(aborted || abortSignal?.aborted ? EXIT_CODE_ABORTED : code ?? 0);
        resolve4();
      });
      proc.on("error", (err) => {
        abortSignal?.removeEventListener("abort", onAbort);
        if (aborted || abortSignal?.aborted) {
          initLogger.logComplete(EXIT_CODE_ABORTED);
          resolve4();
          return;
        }
        initLogger.logStderr(`Error running init hook: ${err.message}`);
        initLogger.logComplete(-1);
        resolve4();
      });
    });
  }
};

// src/node/runtime/LocalRuntime.ts
var LocalRuntime = class extends LocalBaseRuntime {
  constructor(projectPath) {
    super();
    this.projectPath = projectPath;
  }
  /**
   * For LocalRuntime, the workspace path is always the project path itself.
   * The workspaceName parameter is ignored since there's only one workspace per project.
   */
  getWorkspacePath(_projectPath, _workspaceName) {
    return this.projectPath;
  }
  ensureReady(options) {
    const statusSink = options?.statusSink;
    statusSink?.({
      phase: "checking",
      runtimeType: "local",
      detail: "Checking repository..."
    });
    statusSink?.({ phase: "ready", runtimeType: "local" });
    return Promise.resolve({ ready: true });
  }
  /**
   * Creating a workspace is a no-op for LocalRuntime since we use the project directory directly.
   * We just verify the directory exists.
   */
  async createWorkspace(params) {
    const { initLogger } = params;
    try {
      initLogger.logStep("Using project directory directly (no worktree isolation)");
      try {
        await this.stat(this.projectPath);
      } catch {
        return {
          success: false,
          error: `Project directory does not exist: ${this.projectPath}`
        };
      }
      initLogger.logStep("Project directory verified");
      return { success: true, workspacePath: this.projectPath };
    } catch (error) {
      return {
        success: false,
        error: getErrorMessage4(error)
      };
    }
  }
  async initWorkspace(params) {
    const { projectPath, branchName, workspacePath, initLogger, abortSignal, env: env3, skipInitHook } = params;
    try {
      if (skipInitHook) {
        initLogger.logStep("Skipping .mux/init hook (disabled for this task)");
        initLogger.logComplete(0);
        return { success: true };
      }
      const hookExists = await checkInitHookExists(projectPath);
      if (hookExists) {
        initLogger.enterHookPhase?.();
        const muxEnv = { ...env3, ...getMuxEnv(projectPath, "local", branchName) };
        await this.runInitHook(workspacePath, muxEnv, initLogger, abortSignal);
      } else {
        initLogger.logComplete(0);
      }
      return { success: true };
    } catch (error) {
      const errorMsg = getErrorMessage4(error);
      initLogger.logStderr(`Initialization failed: ${errorMsg}`);
      initLogger.logComplete(-1);
      return {
        success: false,
        error: errorMsg
      };
    }
  }
  /**
   * Renaming is a no-op for LocalRuntime - the workspace path is always the project directory.
   * Returns success so the metadata (workspace name) can be updated in config.
   */
  // eslint-disable-next-line @typescript-eslint/require-await
  async renameWorkspace(_projectPath, _oldName, _newName, _abortSignal) {
    return { success: true, oldPath: this.projectPath, newPath: this.projectPath };
  }
  /**
   * Deleting is a no-op for LocalRuntime - we never delete the user's project directory.
   * Returns success so the workspace entry can be removed from config.
   */
  // eslint-disable-next-line @typescript-eslint/require-await
  async deleteWorkspace(_projectPath, _workspaceName, _force, _abortSignal) {
    return { success: true, deletedPath: this.projectPath };
  }
  /**
   * Fork for LocalRuntime creates a new workspace entry pointing to the same project directory.
   * Since LocalRuntime doesn't create separate directories, "forking" just means:
   * 1. A new workspace ID with the new name
   * 2. Copied chat history (handled by workspaceService)
   * 3. Same project directory as source
   *
   * This enables conversation branching without git worktree overhead.
   */
  async forkWorkspace(params) {
    const { initLogger } = params;
    initLogger.logStep("Creating conversation fork (no worktree isolation)");
    try {
      await this.stat(this.projectPath);
    } catch {
      return {
        success: false,
        error: `Project directory does not exist: ${this.projectPath}`
      };
    }
    initLogger.logStep("Project directory verified");
    return {
      success: true,
      workspacePath: this.projectPath
      // sourceBranch is optional for LocalRuntime since no git operations are involved
    };
  }
};

// src/node/utils/pathUtils.ts
import * as fs4 from "fs/promises";
import * as path6 from "path";
function stripTrailingSlashes(inputPath) {
  return inputPath.replace(/[/\\]+$/, "");
}
async function isGitRepository(projectPath) {
  const gitPath = path6.join(projectPath, ".git");
  try {
    await fs4.stat(gitPath);
    return true;
  } catch {
    return false;
  }
}

// src/node/worktree/WorktreeManager.ts
import * as fsPromises3 from "fs/promises";
import * as path8 from "path";

// src/node/git.ts
import * as fs5 from "fs";
import * as path7 from "path";
var STALE_LOCK_AGE_MS = 5e3;
function cleanStaleLock(repoPath) {
  const lockPath = path7.join(repoPath, ".git", "index.lock");
  try {
    const stat4 = fs5.statSync(lockPath);
    const ageMs = Date.now() - stat4.mtimeMs;
    if (ageMs > STALE_LOCK_AGE_MS) {
      fs5.unlinkSync(lockPath);
      log.info(`Removed stale git index.lock (age: ${Math.round(ageMs / 1e3)}s) at ${lockPath}`);
    }
  } catch {
  }
}
async function listLocalBranches(projectPath) {
  var _stack = [];
  try {
    const proc = __using(_stack, execAsync(
      `git -C "${projectPath}" for-each-ref --format="%(refname:short)" refs/heads`
    ));
    const { stdout } = await proc.result;
    return stdout.split("\n").map((line) => line.trim()).filter((line) => line.length > 0).sort((a, b) => a.localeCompare(b));
  } catch (_) {
    var _error = _, _hasError = true;
  } finally {
    __callDispose(_stack, _error, _hasError);
  }
}
async function getCurrentBranch(projectPath) {
  try {
    var _stack = [];
    try {
      const proc = __using(_stack, execAsync(`git -C "${projectPath}" rev-parse --abbrev-ref HEAD`));
      const { stdout } = await proc.result;
      const branch = stdout.trim();
      if (!branch || branch === "HEAD") {
        return null;
      }
      return branch;
    } catch (_) {
      var _error = _, _hasError = true;
    } finally {
      __callDispose(_stack, _error, _hasError);
    }
  } catch {
    return null;
  }
}

// src/common/utils/planStorage.ts
var DEFAULT_MUX_HOME = "~/.mux";
function getPlanFilePath(workspaceName, projectName, muxHome = DEFAULT_MUX_HOME) {
  return `${muxHome}/plans/${projectName}/${workspaceName}.md`;
}
function getLegacyPlanFilePath(workspaceId) {
  return `${DEFAULT_MUX_HOME}/plans/${workspaceId}.md`;
}

// src/node/utils/runtime/helpers.ts
function getProjectName(projectPath) {
  return PlatformPaths.getProjectName(projectPath);
}
async function execBuffered(runtime, command, options) {
  const stream = await runtime.exec(command, options);
  if (options.stdin !== void 0) {
    const writer = stream.stdin.getWriter();
    try {
      await writer.write(new TextEncoder().encode(options.stdin));
      await writer.close();
    } catch (err) {
      writer.releaseLock();
      throw err;
    }
  } else {
    await stream.stdin.close();
  }
  const [stdout, stderr, exitCode, duration] = await Promise.all([
    streamToString(stream.stdout),
    streamToString(stream.stderr),
    stream.exitCode,
    stream.duration
  ]);
  return { stdout, stderr, exitCode, duration };
}
async function readFileString(runtime, path24, abortSignal) {
  const stream = runtime.readFile(path24, abortSignal);
  return streamToString(stream);
}
async function streamToString(stream) {
  const reader = stream.getReader();
  const decoder = new TextDecoder("utf-8");
  let result = "";
  try {
    while (true) {
      const { done, value: value2 } = await reader.read();
      if (done) break;
      result += decoder.decode(value2, { stream: true });
    }
    result += decoder.decode();
    return result;
  } finally {
    reader.releaseLock();
  }
}
async function readPlanFile(runtime, workspaceName, projectName, workspaceId) {
  const muxHome = runtime.getMuxHome();
  const planPath = getPlanFilePath(workspaceName, projectName, muxHome);
  const legacyPath = getLegacyPlanFilePath(workspaceId);
  const resolvedPath = await runtime.resolvePath(planPath);
  try {
    const content = await readFileString(runtime, planPath);
    return { content, exists: true, path: resolvedPath };
  } catch {
    try {
      const content = await readFileString(runtime, legacyPath);
      try {
        const planDir = planPath.substring(0, planPath.lastIndexOf("/"));
        await execBuffered(runtime, `mkdir -p "${planDir}" && mv "${legacyPath}" "${planPath}"`, {
          cwd: "/tmp",
          timeout: 5
        });
      } catch {
      }
      return { content, exists: true, path: resolvedPath };
    } catch {
      return { content: "", exists: false, path: resolvedPath };
    }
  }
}
async function hasNonEmptyPlanFile(runtime, workspaceName, projectName, workspaceId) {
  if (!workspaceName || !projectName || !workspaceId) {
    return false;
  }
  const muxHome = runtime.getMuxHome();
  const planPath = getPlanFilePath(workspaceName, projectName, muxHome);
  const legacyPath = getLegacyPlanFilePath(workspaceId);
  for (const candidatePath of [planPath, legacyPath]) {
    try {
      const stat4 = await runtime.stat(candidatePath);
      if (!stat4.isDirectory && stat4.size > 0) {
        return true;
      }
    } catch {
    }
  }
  return false;
}

// src/node/utils/paths.ts
import { execFileSync as execFileSync2 } from "child_process";
function toPosixPath(windowsPath) {
  if (process.platform !== "win32") return windowsPath;
  try {
    return execFileSync2("cygpath", ["-u", windowsPath], { encoding: "utf8" }).trim();
  } catch {
    return windowsPath;
  }
}

// src/node/worktree/WorktreeManager.ts
var WorktreeManager = class {
  constructor(srcBaseDir) {
    this.srcBaseDir = expandTilde(srcBaseDir);
  }
  getWorkspacePath(projectPath, workspaceName) {
    const projectName = getProjectName(projectPath);
    return path8.join(this.srcBaseDir, projectName, workspaceName);
  }
  async createWorkspace(params) {
    const { projectPath, branchName, trunkBranch, initLogger } = params;
    cleanStaleLock(projectPath);
    try {
      const workspacePath = this.getWorkspacePath(projectPath, branchName);
      initLogger.logStep("Creating git worktree...");
      const parentDir = path8.dirname(workspacePath);
      try {
        await fsPromises3.access(parentDir);
      } catch {
        await fsPromises3.mkdir(parentDir, { recursive: true });
      }
      try {
        await fsPromises3.access(workspacePath);
        return {
          success: false,
          error: `Workspace already exists at ${workspacePath}`
        };
      } catch {
      }
      const localBranches = await listLocalBranches(projectPath);
      const branchExists = localBranches.includes(branchName);
      const fetchedOrigin = await this.fetchOriginTrunk(projectPath, trunkBranch, initLogger);
      const shouldUseOrigin = fetchedOrigin && await this.canFastForwardToOrigin(projectPath, trunkBranch, initLogger);
      if (branchExists) {
        var _stack = [];
        try {
          const proc = __using(_stack, execAsync(
            `git -C "${projectPath}" worktree add "${workspacePath}" "${branchName}"`
          ));
          await proc.result;
        } catch (_) {
          var _error = _, _hasError = true;
        } finally {
          __callDispose(_stack, _error, _hasError);
        }
      } else {
        var _stack2 = [];
        try {
          const newBranchBase = shouldUseOrigin ? `origin/${trunkBranch}` : trunkBranch;
          const proc = __using(_stack2, execAsync(
            `git -C "${projectPath}" worktree add -b "${branchName}" "${workspacePath}" "${newBranchBase}"`
          ));
          await proc.result;
        } catch (_2) {
          var _error2 = _2, _hasError2 = true;
        } finally {
          __callDispose(_stack2, _error2, _hasError2);
        }
      }
      initLogger.logStep("Worktree created successfully");
      if (shouldUseOrigin && branchExists) {
        await this.fastForwardToOrigin(workspacePath, trunkBranch, initLogger);
      }
      return { success: true, workspacePath };
    } catch (error) {
      return {
        success: false,
        error: getErrorMessage4(error)
      };
    }
  }
  /**
   * Fetch trunk branch from origin before worktree creation.
   * Returns true if fetch succeeded (origin is available for branching).
   */
  async fetchOriginTrunk(projectPath, trunkBranch, initLogger) {
    try {
      var _stack = [];
      try {
        initLogger.logStep(`Fetching latest from origin/${trunkBranch}...`);
        const fetchProc = __using(_stack, execAsync(`git -C "${projectPath}" fetch origin "${trunkBranch}"`));
        await fetchProc.result;
        initLogger.logStep("Fetched latest from origin");
        return true;
      } catch (_) {
        var _error = _, _hasError = true;
      } finally {
        __callDispose(_stack, _error, _hasError);
      }
    } catch (error) {
      const errorMsg = getErrorMessage4(error);
      if (errorMsg.includes("couldn't find remote ref")) {
        initLogger.logStep(`Branch "${trunkBranch}" not found on origin; using local state.`);
      } else {
        initLogger.logStderr(
          `Note: Could not fetch from origin (${errorMsg}), using local branch state`
        );
      }
      return false;
    }
  }
  /**
   * Check if local trunk can fast-forward to origin/<trunk>.
   * Returns true if local is behind or equal to origin (safe to use origin).
   * Returns false if local is ahead or diverged (preserve local state).
   */
  async canFastForwardToOrigin(projectPath, trunkBranch, initLogger) {
    try {
      var _stack = [];
      try {
        const proc = __using(_stack, execAsync(
          `git -C "${projectPath}" merge-base --is-ancestor "${trunkBranch}" "origin/${trunkBranch}"`
        ));
        await proc.result;
        return true;
      } catch (_) {
        var _error = _, _hasError = true;
      } finally {
        __callDispose(_stack, _error, _hasError);
      }
    } catch {
      initLogger.logStderr(
        `Note: Local ${trunkBranch} is ahead of or diverged from origin, using local state`
      );
      return false;
    }
  }
  /**
   * Fast-forward merge to latest origin/<trunkBranch> after checkout.
   * Best-effort operation for existing branches that may be behind origin.
   */
  async fastForwardToOrigin(workspacePath, trunkBranch, initLogger) {
    try {
      var _stack = [];
      try {
        initLogger.logStep("Fast-forward merging...");
        const mergeProc = __using(_stack, execAsync(
          `git -C "${workspacePath}" merge --ff-only "origin/${trunkBranch}"`
        ));
        await mergeProc.result;
        initLogger.logStep("Fast-forwarded to latest origin successfully");
      } catch (_) {
        var _error = _, _hasError = true;
      } finally {
        __callDispose(_stack, _error, _hasError);
      }
    } catch (mergeError) {
      const errorMsg = getErrorMessage4(mergeError);
      initLogger.logStderr(`Note: Fast-forward failed (${errorMsg}), using local branch state`);
    }
  }
  async renameWorkspace(projectPath, oldName, newName) {
    cleanStaleLock(projectPath);
    const oldPath = this.getWorkspacePath(projectPath, oldName);
    const newPath = this.getWorkspacePath(projectPath, newName);
    try {
      var _stack2 = [];
      try {
        const moveProc = __using(_stack2, execAsync(`git -C "${projectPath}" worktree move "${oldPath}" "${newPath}"`));
        await moveProc.result;
        try {
          var _stack = [];
          try {
            const branchProc = __using(_stack, execAsync(`git -C "${newPath}" branch -m "${oldName}" "${newName}"`));
            await branchProc.result;
          } catch (_) {
            var _error = _, _hasError = true;
          } finally {
            __callDispose(_stack, _error, _hasError);
          }
        } catch {
        }
        return { success: true, oldPath, newPath };
      } catch (_2) {
        var _error2 = _2, _hasError2 = true;
      } finally {
        __callDispose(_stack2, _error2, _hasError2);
      }
    } catch (error) {
      return { success: false, error: `Failed to rename workspace: ${getErrorMessage4(error)}` };
    }
  }
  async deleteWorkspace(projectPath, workspaceName, force) {
    cleanStaleLock(projectPath);
    const isInPlace = projectPath === workspaceName;
    const shouldDeleteBranch = !isInPlace;
    const tryDeleteBranch = async () => {
      if (!shouldDeleteBranch) return;
      const branchToDelete = workspaceName.trim();
      if (!branchToDelete) {
        log.debug("Skipping git branch deletion: empty workspace name", {
          projectPath,
          workspaceName
        });
        return;
      }
      let localBranches;
      try {
        localBranches = await listLocalBranches(projectPath);
      } catch (error) {
        log.debug("Failed to list local branches; skipping branch deletion", {
          projectPath,
          workspaceName: branchToDelete,
          error: getErrorMessage4(error)
        });
        return;
      }
      if (!localBranches.includes(branchToDelete)) {
        log.debug("Skipping git branch deletion: branch does not exist locally", {
          projectPath,
          workspaceName: branchToDelete
        });
        return;
      }
      const protectedBranches = /* @__PURE__ */ new Set(["main", "master", "trunk", "develop", "default"]);
      if (localBranches.length === 1) {
        protectedBranches.add(localBranches[0]);
      }
      const currentBranch = await getCurrentBranch(projectPath);
      if (currentBranch) {
        protectedBranches.add(currentBranch);
      }
      try {
        var _stack6 = [];
        try {
          const originHeadProc = __using(_stack6, execAsync(
            `git -C "${projectPath}" symbolic-ref refs/remotes/origin/HEAD`
          ));
          const { stdout } = await originHeadProc.result;
          const ref = stdout.trim();
          const prefix = "refs/remotes/origin/";
          if (ref.startsWith(prefix)) {
            protectedBranches.add(ref.slice(prefix.length));
          }
        } catch (_6) {
          var _error6 = _6, _hasError6 = true;
        } finally {
          __callDispose(_stack6, _error6, _hasError6);
        }
      } catch {
      }
      if (protectedBranches.has(branchToDelete)) {
        log.debug("Skipping git branch deletion: protected branch", {
          projectPath,
          workspaceName: branchToDelete
        });
        return;
      }
      try {
        var _stack7 = [];
        try {
          const worktreeProc = __using(_stack7, execAsync(`git -C "${projectPath}" worktree list --porcelain`));
          const { stdout } = await worktreeProc.result;
          const needle = `branch refs/heads/${branchToDelete}`;
          const isCheckedOut = stdout.split("\n").some((line) => line.trim() === needle);
          if (isCheckedOut) {
            log.debug("Skipping git branch deletion: branch still checked out by a worktree", {
              projectPath,
              workspaceName: branchToDelete
            });
            return;
          }
        } catch (_7) {
          var _error7 = _7, _hasError7 = true;
        } finally {
          __callDispose(_stack7, _error7, _hasError7);
        }
      } catch (error) {
        log.debug("Failed to check worktree list before branch deletion; proceeding", {
          projectPath,
          workspaceName: branchToDelete,
          error: getErrorMessage4(error)
        });
      }
      const deleteFlag = force ? "-D" : "-d";
      try {
        var _stack8 = [];
        try {
          const deleteProc = __using(_stack8, execAsync(
            `git -C "${projectPath}" branch ${deleteFlag} "${branchToDelete}"`
          ));
          await deleteProc.result;
        } catch (_8) {
          var _error8 = _8, _hasError8 = true;
        } finally {
          __callDispose(_stack8, _error8, _hasError8);
        }
      } catch (error) {
        log.debug("Failed to delete git branch after removing worktree", {
          projectPath,
          workspaceName: branchToDelete,
          error: getErrorMessage4(error)
        });
      }
    };
    const deletedPath = this.getWorkspacePath(projectPath, workspaceName);
    try {
      await fsPromises3.access(deletedPath);
    } catch {
      if (!isInPlace) {
        try {
          var _stack = [];
          try {
            const pruneProc = __using(_stack, execAsync(`git -C "${projectPath}" worktree prune`));
            await pruneProc.result;
          } catch (_) {
            var _error = _, _hasError = true;
          } finally {
            __callDispose(_stack, _error, _hasError);
          }
        } catch {
        }
      }
      await tryDeleteBranch();
      return { success: true, deletedPath };
    }
    if (isInPlace) {
      return { success: true, deletedPath };
    }
    try {
      var _stack2 = [];
      try {
        const forceFlag = force ? " --force" : "";
        const proc = __using(_stack2, execAsync(
          `git -C "${projectPath}" worktree remove${forceFlag} "${deletedPath}"`
        ));
        await proc.result;
        await tryDeleteBranch();
        return { success: true, deletedPath };
      } catch (_2) {
        var _error2 = _2, _hasError2 = true;
      } finally {
        __callDispose(_stack2, _error2, _hasError2);
      }
    } catch (error) {
      const message = getErrorMessage4(error);
      const normalizedError = message.toLowerCase();
      const looksLikeMissingWorktree = normalizedError.includes("not a working tree") || normalizedError.includes("does not exist") || normalizedError.includes("no such file");
      if (looksLikeMissingWorktree) {
        try {
          var _stack3 = [];
          try {
            const pruneProc = __using(_stack3, execAsync(`git -C "${projectPath}" worktree prune`));
            await pruneProc.result;
          } catch (_3) {
            var _error3 = _3, _hasError3 = true;
          } finally {
            __callDispose(_stack3, _error3, _hasError3);
          }
        } catch {
        }
        await tryDeleteBranch();
        return { success: true, deletedPath };
      }
      if (force) {
        try {
          var _stack5 = [];
          try {
            try {
              var _stack4 = [];
              try {
                const pruneProc = __using(_stack4, execAsync(`git -C "${projectPath}" worktree prune`));
                await pruneProc.result;
              } catch (_4) {
                var _error4 = _4, _hasError4 = true;
              } finally {
                __callDispose(_stack4, _error4, _hasError4);
              }
            } catch {
            }
            const rmProc = __using(_stack5, execAsync(`rm -rf "${toPosixPath(deletedPath)}"`, {
              shell: getBashPath()
            }));
            await rmProc.result;
            await tryDeleteBranch();
            return { success: true, deletedPath };
          } catch (_5) {
            var _error5 = _5, _hasError5 = true;
          } finally {
            __callDispose(_stack5, _error5, _hasError5);
          }
        } catch (rmError) {
          return {
            success: false,
            error: `Failed to remove worktree via git and rm: ${getErrorMessage4(rmError)}`
          };
        }
      }
      return { success: false, error: `Failed to remove worktree: ${message}` };
    }
  }
  async forkWorkspace(params) {
    const { projectPath, sourceWorkspaceName, newWorkspaceName, initLogger } = params;
    const sourceWorkspacePath = this.getWorkspacePath(projectPath, sourceWorkspaceName);
    try {
      var _stack = [];
      try {
        const proc = __using(_stack, execAsync(`git -C "${sourceWorkspacePath}" branch --show-current`));
        const { stdout } = await proc.result;
        const sourceBranch = stdout.trim();
        if (!sourceBranch) {
          return {
            success: false,
            error: "Failed to detect branch in source workspace"
          };
        }
        const createResult = await this.createWorkspace({
          projectPath,
          branchName: newWorkspaceName,
          trunkBranch: sourceBranch,
          // Fork from source branch instead of main/master
          initLogger
        });
        if (!createResult.success || !createResult.workspacePath) {
          return {
            success: false,
            error: createResult.error ?? "Failed to create workspace"
          };
        }
        return {
          success: true,
          workspacePath: createResult.workspacePath,
          sourceBranch
        };
      } catch (_) {
        var _error = _, _hasError = true;
      } finally {
        __callDispose(_stack, _error, _hasError);
      }
    } catch (error) {
      return {
        success: false,
        error: getErrorMessage4(error)
      };
    }
  }
};

// src/node/runtime/WorktreeRuntime.ts
var WorktreeRuntime = class extends LocalBaseRuntime {
  constructor(srcBaseDir, options) {
    super();
    this.worktreeManager = new WorktreeManager(srcBaseDir);
    this.currentProjectPath = options?.projectPath;
    this.currentWorkspaceName = options?.workspaceName;
  }
  getWorkspacePath(projectPath, workspaceName) {
    return this.worktreeManager.getWorkspacePath(projectPath, workspaceName);
  }
  async ensureReady(options) {
    if (!this.currentProjectPath || !this.currentWorkspaceName) {
      return { ready: true };
    }
    const statusSink = options?.statusSink;
    statusSink?.({
      phase: "checking",
      runtimeType: "worktree",
      detail: "Checking repository..."
    });
    const workspacePath = this.getWorkspacePath(this.currentProjectPath, this.currentWorkspaceName);
    const hasRepo = await isGitRepository(workspacePath);
    if (!hasRepo) {
      statusSink?.({
        phase: "error",
        runtimeType: "worktree",
        detail: WORKSPACE_REPO_MISSING_ERROR
      });
      return {
        ready: false,
        error: WORKSPACE_REPO_MISSING_ERROR,
        errorType: "runtime_not_ready"
      };
    }
    statusSink?.({ phase: "ready", runtimeType: "worktree" });
    return { ready: true };
  }
  async createWorkspace(params) {
    return this.worktreeManager.createWorkspace({
      projectPath: params.projectPath,
      branchName: params.branchName,
      trunkBranch: params.trunkBranch,
      initLogger: params.initLogger
    });
  }
  async initWorkspace(params) {
    const { projectPath, branchName, workspacePath, initLogger, abortSignal, env: env3, skipInitHook } = params;
    try {
      if (skipInitHook) {
        initLogger.logStep("Skipping .mux/init hook (disabled for this task)");
        initLogger.logComplete(0);
        return { success: true };
      }
      const hookExists = await checkInitHookExists(projectPath);
      if (hookExists) {
        initLogger.enterHookPhase?.();
        const muxEnv = { ...env3, ...getMuxEnv(projectPath, "worktree", branchName) };
        await this.runInitHook(workspacePath, muxEnv, initLogger, abortSignal);
      } else {
        initLogger.logComplete(0);
      }
      return { success: true };
    } catch (error) {
      const errorMsg = getErrorMessage4(error);
      initLogger.logStderr(`Initialization failed: ${errorMsg}`);
      initLogger.logComplete(-1);
      return {
        success: false,
        error: errorMsg
      };
    }
  }
  async renameWorkspace(projectPath, oldName, newName, _abortSignal) {
    return this.worktreeManager.renameWorkspace(projectPath, oldName, newName);
  }
  async deleteWorkspace(projectPath, workspaceName, force, _abortSignal) {
    return this.worktreeManager.deleteWorkspace(projectPath, workspaceName, force);
  }
  async forkWorkspace(params) {
    return this.worktreeManager.forkWorkspace(params);
  }
};

// src/node/runtime/SSHRuntime.ts
import { spawn as spawn2 } from "child_process";
import * as path9 from "path";

// src/node/runtime/RemoteRuntime.ts
import { Readable as Readable2 } from "stream";

// src/node/utils/streamErrors.ts
function normalizeError(error) {
  if (error instanceof Error) {
    return error;
  }
  if (typeof error === "string") {
    return new Error(error);
  }
  return new Error("Unknown error");
}
function getErrorCode(error) {
  if (!error || typeof error !== "object") {
    return void 0;
  }
  if ("code" in error && typeof error.code === "string") {
    return error.code;
  }
  return void 0;
}
function isIgnorableStreamError(error) {
  const code = getErrorCode(error);
  return code === "EPIPE" || code === "ECONNRESET";
}
function attachStreamErrorHandler(emitter, label, options = {}) {
  const handler = (error) => {
    const normalized = normalizeError(error);
    const info = {
      label,
      code: getErrorCode(error),
      message: normalized.message
    };
    if (isIgnorableStreamError(error)) {
      options.logger?.debug("Ignored stream error", info, normalized);
      options.onIgnorable?.(normalized, info);
      return;
    }
    options.logger?.warn("Stream error", info, normalized);
    options.onUnexpected?.(normalized, info);
  };
  emitter.on("error", handler);
  return () => {
    emitter.removeListener("error", handler);
  };
}

// src/node/runtime/streamUtils.ts
var shescape = {
  quote(value2) {
    const s = String(value2);
    if (s.length === 0) return "''";
    return "'" + s.replace(/'/g, `'"'"'`) + "'";
  }
};
async function streamToString2(stream) {
  const reader = stream.getReader();
  const decoder = new TextDecoder("utf-8");
  let result = "";
  try {
    while (true) {
      const { done, value: value2 } = await reader.read();
      if (done) break;
      result += decoder.decode(value2, { stream: true });
    }
    result += decoder.decode();
    return result;
  } finally {
    reader.releaseLock();
  }
}

// src/node/runtime/RemoteRuntime.ts
var RemoteRuntime = class {
  /**
   * Called when exec completes with an exit code.
   * Subclasses can use this for connection pool health tracking.
   * @param stderr - Captured stderr for error reporting (e.g., SSH connection failures)
   */
  onExitCode(_exitCode, _options, _stderr) {
  }
  /**
   * Execute command with streaming I/O.
   * Shared implementation that delegates process spawning to subclass.
   */
  async exec(command, options) {
    const startTime = performance.now();
    if (options.abortSignal?.aborted) {
      throw new RuntimeError("Operation aborted before execution", "exec");
    }
    const parts = [];
    parts.push(this.cdCommand(options.cwd));
    const envVars = { ...options.env, ...NON_INTERACTIVE_ENV_VARS };
    for (const [key, value2] of Object.entries(envVars)) {
      parts.push(`export ${key}=${shescape.quote(value2)}`);
    }
    parts.push(command);
    let fullCommand = parts.join(" && ");
    fullCommand = `bash -c ${shescape.quote(fullCommand)}`;
    if (options.timeout !== void 0) {
      const remoteTimeout = Math.ceil(options.timeout) + 1;
      fullCommand = `timeout -s KILL ${remoteTimeout} ${fullCommand}`;
    }
    const { process: childProcess } = await this.spawnRemoteProcess(fullCommand, options);
    if (childProcess.stdin) {
      attachStreamErrorHandler(childProcess.stdin, `${this.commandPrefix} stdin`, {
        logger: log
      });
    }
    const disposable = new DisposableProcess(childProcess);
    let timedOut = false;
    let aborted = false;
    let stderrForErrorReporting = "";
    const exitCode = new Promise((resolve4, reject) => {
      childProcess.on("close", (code, signal) => {
        if (aborted || options.abortSignal?.aborted) {
          resolve4(EXIT_CODE_ABORTED);
          return;
        }
        if (timedOut) {
          resolve4(EXIT_CODE_TIMEOUT);
          return;
        }
        const finalExitCode = code ?? (signal ? -1 : 0);
        this.onExitCode(finalExitCode, options, stderrForErrorReporting);
        resolve4(finalExitCode);
      });
      childProcess.on("error", (err) => {
        reject(
          new RuntimeError(
            `Failed to execute ${this.commandPrefix} command: ${err.message}`,
            "exec",
            err
          )
        );
      });
    });
    const duration = exitCode.then(() => performance.now() - startTime);
    if (options.abortSignal) {
      const abortSignal = options.abortSignal;
      const onAbort = () => {
        aborted = true;
        try {
          childProcess.kill("SIGTERM");
        } catch {
        }
        const hardKillHandle = setTimeout(() => {
          const hasExited = childProcess.exitCode !== null || childProcess.signalCode !== null;
          if (hasExited) {
            return;
          }
          disposable[Symbol.dispose]();
        }, 1e3);
        hardKillHandle.unref();
      };
      abortSignal.addEventListener("abort", onAbort, { once: true });
      void exitCode.finally(() => abortSignal.removeEventListener("abort", onAbort));
    }
    if (options.timeout !== void 0) {
      const timeoutHandle = setTimeout(() => {
        timedOut = true;
        try {
          childProcess.kill("SIGTERM");
        } catch {
        }
        const hardKillHandle = setTimeout(() => {
          const hasExited = childProcess.exitCode !== null || childProcess.signalCode !== null;
          if (hasExited) {
            return;
          }
          disposable[Symbol.dispose]();
        }, 1e3);
        hardKillHandle.unref();
      }, options.timeout * 1e3);
      void exitCode.finally(() => clearTimeout(timeoutHandle));
    }
    const stdout = Readable2.toWeb(childProcess.stdout);
    const stderr = Readable2.toWeb(childProcess.stderr);
    childProcess.stderr?.on("data", (data) => {
      stderrForErrorReporting += data.toString();
    });
    const stdin = new WritableStream({
      write: async (chunk) => {
        const nodeStdin = childProcess.stdin;
        if (!nodeStdin || nodeStdin.destroyed) {
          return;
        }
        await new Promise((resolve4, reject) => {
          const onError2 = (err) => {
            nodeStdin.off("error", onError2);
            reject(err);
          };
          nodeStdin.on("error", onError2);
          nodeStdin.write(Buffer.from(chunk), (err) => {
            nodeStdin.off("error", onError2);
            if (err) {
              reject(err);
              return;
            }
            resolve4();
          });
        });
      },
      close: async () => {
        const nodeStdin = childProcess.stdin;
        if (!nodeStdin || nodeStdin.destroyed || nodeStdin.writableEnded) {
          return;
        }
        await new Promise((resolve4) => {
          const onError2 = () => {
            cleanup();
            resolve4();
          };
          const onFinish2 = () => {
            cleanup();
            resolve4();
          };
          const cleanup = () => {
            nodeStdin.removeListener("error", onError2);
            nodeStdin.removeListener("finish", onFinish2);
          };
          nodeStdin.once("error", onError2);
          nodeStdin.once("finish", onFinish2);
          try {
            nodeStdin.end();
          } catch {
            onError2();
          }
        });
      },
      abort: () => {
        childProcess.stdin?.destroy();
      }
    });
    log.debug(`${this.commandPrefix} command: ${fullCommand}`);
    return { stdout, stderr, stdin, exitCode, duration };
  }
  /**
   * Read file contents as a stream via exec.
   */
  readFile(filePath, abortSignal) {
    return new ReadableStream({
      start: async (controller) => {
        try {
          const stream = await this.exec(`cat ${this.quoteForRemote(filePath)}`, {
            cwd: this.getBasePath(),
            timeout: 300,
            abortSignal
          });
          const reader = stream.stdout.getReader();
          const exitCodePromise = stream.exitCode;
          while (true) {
            const { done, value: value2 } = await reader.read();
            if (done) break;
            controller.enqueue(value2);
          }
          const code = await exitCodePromise;
          if (code !== 0) {
            const stderr = await streamToString2(stream.stderr);
            throw new RuntimeError(`Failed to read file ${filePath}: ${stderr}`, "file_io");
          }
          controller.close();
        } catch (err) {
          if (err instanceof RuntimeError) {
            controller.error(err);
          } else {
            controller.error(
              new RuntimeError(
                `Failed to read file ${filePath}: ${err instanceof Error ? err.message : String(err)}`,
                "file_io",
                err instanceof Error ? err : void 0
              )
            );
          }
        }
      }
    });
  }
  /**
   * Write file contents atomically via exec.
   * Uses temp file + mv for atomic write.
   */
  writeFile(filePath, abortSignal) {
    const quotedPath = this.quoteForRemote(filePath);
    const tempPath = `${filePath}.tmp.${Date.now()}`;
    const quotedTempPath = this.quoteForRemote(tempPath);
    const writeCommand = this.buildWriteCommand(quotedPath, quotedTempPath);
    let execPromise = null;
    const getExecStream = () => {
      execPromise ??= this.exec(writeCommand, {
        cwd: this.getBasePath(),
        timeout: 300,
        abortSignal
      });
      return execPromise;
    };
    return new WritableStream({
      write: async (chunk) => {
        const stream = await getExecStream();
        const writer = stream.stdin.getWriter();
        try {
          await writer.write(chunk);
        } finally {
          writer.releaseLock();
        }
      },
      close: async () => {
        const stream = await getExecStream();
        await stream.stdin.close();
        const exitCode = await stream.exitCode;
        if (exitCode !== 0) {
          const stderr = await streamToString2(stream.stderr);
          throw new RuntimeError(`Failed to write file ${filePath}: ${stderr}`, "file_io");
        }
      },
      abort: async (reason) => {
        const stream = await getExecStream();
        await stream.stdin.abort();
        throw new RuntimeError(`Failed to write file ${filePath}: ${String(reason)}`, "file_io");
      }
    });
  }
  /**
   * Build the write command for atomic file writes.
   * Can be overridden by subclasses for special handling (e.g., SSH symlink preservation).
   */
  buildWriteCommand(quotedPath, quotedTempPath) {
    return `mkdir -p $(dirname ${quotedPath}) && cat > ${quotedTempPath} && mv ${quotedTempPath} ${quotedPath}`;
  }
  /**
   * Ensure a directory exists (mkdir -p semantics).
   */
  async ensureDir(dirPath) {
    const stream = await this.exec(`mkdir -p ${this.quoteForRemote(dirPath)}`, {
      cwd: "/",
      timeout: 10
    });
    await stream.stdin.close();
    const [stdout, stderr, exitCode] = await Promise.all([
      streamToString2(stream.stdout),
      streamToString2(stream.stderr),
      stream.exitCode
    ]);
    if (exitCode !== 0) {
      const extra = stderr.trim() || stdout.trim();
      throw new RuntimeError(
        `Failed to create directory ${dirPath}: exit code ${exitCode}${extra ? `: ${extra}` : ""}`,
        "file_io"
      );
    }
  }
  /**
   * Get file statistics via exec.
   * Uses stat -L to follow symlinks (report target's type, not "symbolic link").
   */
  async stat(filePath, abortSignal) {
    const stream = await this.exec(`stat -L -c '%s %Y %F' ${this.quoteForRemote(filePath)}`, {
      cwd: this.getBasePath(),
      timeout: 10,
      abortSignal
    });
    const [stdout, stderr, exitCode] = await Promise.all([
      streamToString2(stream.stdout),
      streamToString2(stream.stderr),
      stream.exitCode
    ]);
    if (exitCode !== 0) {
      throw new RuntimeError(`Failed to stat ${filePath}: ${stderr}`, "file_io");
    }
    const parts = stdout.trim().split(" ");
    if (parts.length < 3) {
      throw new RuntimeError(`Failed to parse stat output for ${filePath}: ${stdout}`, "file_io");
    }
    const size = parseInt(parts[0], 10);
    const mtime = parseInt(parts[1], 10);
    const fileType = parts.slice(2).join(" ");
    return {
      size,
      modifiedTime: new Date(mtime * 1e3),
      isDirectory: fileType === "directory"
    };
  }
  /**
   * Normalize path for comparison (POSIX semantics).
   * Shared between SSH and Docker.
   */
  normalizePath(targetPath, basePath) {
    const target = targetPath.trim();
    let base = basePath.trim();
    if (base.length > 1 && base.endsWith("/")) {
      base = base.slice(0, -1);
    }
    if (target === ".") {
      return base;
    }
    if (target.startsWith("/") || target === "~" || target.startsWith("~/")) {
      let normalizedTarget2 = target;
      if (normalizedTarget2.length > 1 && normalizedTarget2.endsWith("/")) {
        normalizedTarget2 = normalizedTarget2.slice(0, -1);
      }
      return normalizedTarget2;
    }
    const normalizedTarget = base.endsWith("/") ? base + target : base + "/" + target;
    if (normalizedTarget.length > 1 && normalizedTarget.endsWith("/")) {
      return normalizedTarget.slice(0, -1);
    }
    return normalizedTarget;
  }
  /**
   * Return /tmp as the temp directory for remote runtimes.
   */
  tempDir() {
    return Promise.resolve("/tmp");
  }
  getMuxHome() {
    return "~/.mux";
  }
  // Abstract methods that subclasses must implement
  /**
   * Remote runtimes are always ready (SSH connections are re-established as needed).
   * Subclasses (CoderSSHRuntime, DockerRuntime) may override for provisioning checks.
   */
  ensureReady() {
    return Promise.resolve({ ready: true });
  }
};

// src/node/runtime/gitBundleSync.ts
async function getOriginUrlForBundle(projectPath, initLogger, logErrors) {
  try {
    var _stack = [];
    try {
      const proc = __using(_stack, execAsync(`git -C "${projectPath}" remote get-url origin`));
      const { stdout } = await proc.result;
      const url = stdout.trim();
      if (url && !url.includes(".bundle") && !url.includes(".mux-bundle")) {
        return { originUrl: url };
      }
      return { originUrl: null };
    } catch (_) {
      var _error = _, _hasError = true;
    } finally {
      __callDispose(_stack, _error, _hasError);
    }
  } catch (error) {
    if (logErrors) {
      initLogger.logStderr(`Could not get origin URL: ${getErrorMessage4(error)}`);
    } else {
      log.debug("Could not get origin URL", { error: getErrorMessage4(error) });
    }
    return { originUrl: null };
  }
}
var TRACKING_BRANCHES_COMMAND = "for branch in $(git for-each-ref --format='%(refname:short)' refs/remotes/origin/ | grep -v 'origin/HEAD'); do localname=${branch#origin/}; git show-ref --verify --quiet refs/heads/$localname || git branch $localname $branch; done";
async function syncProjectViaGitBundle(params) {
  const {
    projectPath,
    workspacePath,
    remoteTmpDir,
    remoteBundlePath,
    exec: exec3,
    quoteRemotePath,
    initLogger,
    logOriginErrors,
    abortSignal,
    createRemoteBundle,
    cloneStep
  } = params;
  if (abortSignal?.aborted) {
    throw new Error("Sync operation aborted before starting");
  }
  const { originUrl } = await getOriginUrlForBundle(
    projectPath,
    initLogger,
    logOriginErrors ?? false
  );
  initLogger.logStep("Creating git bundle...");
  let createResult;
  try {
    createResult = await createRemoteBundle({ remoteBundlePath, initLogger, abortSignal });
  } catch (error) {
    try {
      const rmStream = await exec3(`rm -f ${quoteRemotePath(remoteBundlePath)}`, {
        cwd: remoteTmpDir,
        timeout: 10,
        abortSignal
      });
      await rmStream.exitCode;
    } catch {
    }
    throw error;
  }
  try {
    initLogger.logStep(cloneStep);
    const cloneStream = await exec3(
      `git clone --quiet ${quoteRemotePath(remoteBundlePath)} ${quoteRemotePath(workspacePath)}`,
      {
        cwd: remoteTmpDir,
        timeout: 300,
        abortSignal
      }
    );
    const [cloneStdout, cloneStderr, cloneExitCode] = await Promise.all([
      streamToString2(cloneStream.stdout),
      streamToString2(cloneStream.stderr),
      cloneStream.exitCode
    ]);
    if (cloneExitCode !== 0) {
      throw new Error(`Failed to clone repository: ${cloneStderr || cloneStdout}`);
    }
    initLogger.logStep("Creating local tracking branches...");
    const trackingStream = await exec3(TRACKING_BRANCHES_COMMAND, {
      cwd: workspacePath,
      timeout: 30,
      abortSignal
    });
    await trackingStream.exitCode;
    if (originUrl) {
      initLogger.logStep(`Setting origin remote to ${originUrl}...`);
      const setOriginStream = await exec3(`git remote set-url origin ${shescape.quote(originUrl)}`, {
        cwd: workspacePath,
        timeout: 10,
        abortSignal
      });
      const setOriginExitCode = await setOriginStream.exitCode;
      if (setOriginExitCode !== 0) {
        const stderr = await streamToString2(setOriginStream.stderr);
        log.debug("Failed to set origin remote", { stderr });
      }
    } else {
      initLogger.logStep("Removing bundle origin remote...");
      const removeOriginStream = await exec3(`git remote remove origin 2>/dev/null || true`, {
        cwd: workspacePath,
        timeout: 10,
        abortSignal
      });
      await removeOriginStream.exitCode;
    }
    initLogger.logStep("Cleaning up bundle file...");
    const rmStream = await exec3(`rm -f ${quoteRemotePath(remoteBundlePath)}`, {
      cwd: remoteTmpDir,
      timeout: 10,
      abortSignal
    });
    const rmExitCode = await rmStream.exitCode;
    if (rmExitCode !== 0) {
      log.debug("Failed to remove remote bundle file", { remoteBundlePath });
    }
    if (createResult && "cleanupLocal" in createResult && createResult.cleanupLocal) {
      await createResult.cleanupLocal();
    }
    initLogger.logStep("Repository cloned successfully");
  } catch (error) {
    try {
      const rmStream = await exec3(`rm -f ${quoteRemotePath(remoteBundlePath)}`, {
        cwd: remoteTmpDir,
        timeout: 10,
        abortSignal
      });
      await rmStream.exitCode;
    } catch {
    }
    try {
      if (createResult && "cleanupLocal" in createResult && createResult.cleanupLocal) {
        await createResult.cleanupLocal();
      }
    } catch {
    }
    throw error;
  }
}

// src/node/runtime/SSHRuntime.ts
var BASE_REPO_DIR = ".mux-base.git";
var BUNDLE_REF_PREFIX = "refs/mux-bundle/";
function logSSHBackoffWait(initLogger, waitMs) {
  const secs = Math.max(1, Math.ceil(waitMs / 1e3));
  initLogger.logStep(`SSH unavailable; retrying in ${secs}s...`);
}
async function pipeReadableToWebWritable(readable, writable, abortSignal) {
  if (!readable) {
    throw new Error("Missing git bundle output stream");
  }
  const writer = writable.getWriter();
  try {
    for await (const chunk of readable) {
      if (abortSignal?.aborted) {
        throw new Error("Bundle creation aborted");
      }
      const data = typeof chunk === "string" ? Buffer.from(chunk) : chunk instanceof Uint8Array ? chunk : Buffer.from(chunk);
      await writer.write(data);
    }
    await writer.close();
  } catch (error) {
    try {
      await writer.abort(error);
    } catch {
      writer.releaseLock();
    }
    throw error;
  }
}
function createAbortController(timeoutMs, abortSignal) {
  const controller = new AbortController();
  let timedOut = false;
  const onAbort = () => controller.abort();
  if (abortSignal) {
    if (abortSignal.aborted) {
      controller.abort();
    } else {
      abortSignal.addEventListener("abort", onAbort, { once: true });
    }
  }
  const timeoutHandle = timeoutMs === void 0 ? void 0 : setTimeout(() => {
    timedOut = true;
    controller.abort();
  }, timeoutMs);
  return {
    signal: controller.signal,
    didTimeout: () => timedOut,
    dispose: () => {
      if (timeoutHandle) {
        clearTimeout(timeoutHandle);
      }
      abortSignal?.removeEventListener("abort", onAbort);
    }
  };
}
async function waitForProcessExit(proc) {
  return new Promise((resolve4, reject) => {
    proc.on("close", (code) => resolve4(code ?? 0));
    proc.on("error", (err) => reject(err));
  });
}
function truncateSSHError(stderr) {
  const trimmed = stderr.trim();
  if (!trimmed) return "exit code 255";
  const firstLine = trimmed.split("\n")[0];
  if (firstLine.length <= 200) return firstLine;
  return firstLine.slice(0, 197) + "...";
}
function computeBaseRepoPath(srcBaseDir, projectPath) {
  const projectName = getProjectName(projectPath);
  return path9.posix.join(srcBaseDir, projectName, BASE_REPO_DIR);
}
var SSHRuntime = class extends RemoteRuntime {
  constructor(config2, transport, options) {
    super();
    /** Cached resolved bgOutputDir (tilde expanded to absolute path) */
    this.resolvedBgOutputDir = null;
    // ===== RemoteRuntime abstract method implementations =====
    this.commandPrefix = "SSH";
    this.config = config2;
    this.transport = transport;
    this.ensureReadyProjectPath = options?.projectPath;
    this.ensureReadyWorkspaceName = options?.workspaceName;
  }
  /**
   * Get resolved background output directory (tilde expanded), caching the result.
   * This ensures all background process paths are absolute from the start.
   * Public for use by BackgroundProcessExecutor.
   */
  async getBgOutputDir() {
    if (this.resolvedBgOutputDir !== null) {
      return this.resolvedBgOutputDir;
    }
    let dir = this.config.bgOutputDir ?? "/tmp/mux-bashes";
    if (dir === "~" || dir.startsWith("~/")) {
      const result = await execBuffered(this, 'echo "$HOME"', { cwd: "/", timeout: 10 });
      let home;
      if (result.exitCode === 0 && result.stdout.trim()) {
        home = result.stdout.trim();
      } else {
        log.warn(
          `SSHRuntime: Failed to resolve $HOME (exitCode=${result.exitCode}). Falling back to /tmp.`
        );
        home = "/tmp";
      }
      dir = dir === "~" ? home : `${home}/${dir.slice(2)}`;
    }
    this.resolvedBgOutputDir = dir;
    return this.resolvedBgOutputDir;
  }
  /** Create a PTY session using the underlying transport. */
  createPtySession(params) {
    return this.transport.createPtySession(params);
  }
  /** Get SSH configuration (for PTY terminal spawning). */
  getConfig() {
    return this.config;
  }
  getBasePath() {
    return this.config.srcBaseDir;
  }
  quoteForRemote(filePath) {
    return expandTildeForSSH(filePath);
  }
  cdCommand(cwd) {
    return cdCommandForSSH(cwd);
  }
  /**
   * Handle exit codes for SSH connection pool health tracking.
   */
  onExitCode(exitCode, _options, stderr) {
    if (this.transport.isConnectionFailure(exitCode, stderr)) {
      this.transport.reportFailure(truncateSSHError(stderr));
    } else {
      this.transport.markHealthy();
    }
  }
  async spawnRemoteProcess(fullCommand, options) {
    return this.transport.spawnRemoteProcess(fullCommand, {
      forcePTY: options.forcePTY,
      timeout: options.timeout,
      abortSignal: options.abortSignal
    });
  }
  /**
   * Override buildWriteCommand for SSH to handle symlinks and preserve permissions.
   */
  buildWriteCommand(quotedPath, quotedTempPath) {
    return `RESOLVED=$(readlink -f ${quotedPath} 2>/dev/null || echo ${quotedPath}) && PERMS=$(stat -c '%a' "$RESOLVED" 2>/dev/null || echo 600) && mkdir -p $(dirname "$RESOLVED") && cat > ${quotedTempPath} && chmod "$PERMS" ${quotedTempPath} && mv ${quotedTempPath} "$RESOLVED"`;
  }
  // ===== Runtime interface implementations =====
  async resolvePath(filePath) {
    const script = [
      `p=${shescape.quote(filePath)}`,
      'if [ "$p" = "~" ]; then',
      '  echo "$HOME"',
      'elif [ "${p#\\~/}" != "$p" ]; then',
      '  echo "$HOME/${p#\\~/}"',
      'elif [ "${p#/}" != "$p" ]; then',
      '  echo "$p"',
      "else",
      '  echo "$PWD/$p"',
      "fi"
    ].join("\n");
    const command = `bash -lc ${shescape.quote(script)}`;
    const abortController = createAbortController(1e4);
    try {
      const result = await execBuffered(this, command, {
        cwd: "/tmp",
        abortSignal: abortController.signal
      });
      if (abortController.didTimeout()) {
        throw new Error(`SSH command timed out after 10000ms: ${command}`);
      }
      if (result.exitCode !== 0) {
        const message = result.stderr || result.stdout || "Unknown error";
        throw new Error(`Failed to resolve SSH path: ${message}`);
      }
      return result.stdout.trim();
    } finally {
      abortController.dispose();
    }
  }
  getWorkspacePath(projectPath, workspaceName) {
    const projectName = getProjectName(projectPath);
    return path9.posix.join(this.config.srcBaseDir, projectName, workspaceName);
  }
  /**
   * Path to the shared bare repo for a project on the remote.
   * All worktree-based workspaces share this object store.
   */
  getBaseRepoPath(projectPath) {
    return computeBaseRepoPath(this.config.srcBaseDir, projectPath);
  }
  /**
   * Ensure the shared bare repo exists on the remote for a project.
   * Creates it lazily on first use. Returns the shell-expanded path arg
   * for use in subsequent commands.
   */
  async ensureBaseRepo(projectPath, initLogger, abortSignal) {
    const baseRepoPath = this.getBaseRepoPath(projectPath);
    const baseRepoPathArg = expandTildeForSSH(baseRepoPath);
    const check = await execBuffered(this, `test -d ${baseRepoPathArg}`, {
      cwd: "/tmp",
      timeout: 10,
      abortSignal
    });
    if (check.exitCode !== 0) {
      initLogger.logStep("Creating shared base repository...");
      const parentDir = path9.posix.dirname(baseRepoPath);
      await execBuffered(this, `mkdir -p ${expandTildeForSSH(parentDir)}`, {
        cwd: "/tmp",
        timeout: 10,
        abortSignal
      });
      const initResult = await execBuffered(this, `git init --bare ${baseRepoPathArg}`, {
        cwd: "/tmp",
        timeout: 30,
        abortSignal
      });
      if (initResult.exitCode !== 0) {
        throw new Error(`Failed to create base repo: ${initResult.stderr || initResult.stdout}`);
      }
    }
    return baseRepoPathArg;
  }
  /**
   * Detect whether a remote workspace is a git worktree (`.git` is a file)
   * vs a legacy full clone (`.git` is a directory).
   */
  async isWorktreeWorkspace(workspacePath, abortSignal) {
    const gitPath = path9.posix.join(workspacePath, ".git");
    const result = await execBuffered(this, `test -f ${this.quoteForRemote(gitPath)}`, {
      cwd: "/tmp",
      timeout: 10,
      abortSignal
    });
    return result.exitCode === 0;
  }
  /**
   * Resolve the bundle staging ref for the trunk branch.
   * Returns refs/mux-bundle/<trunkBranch> if it exists, otherwise falls back
   * to the first available ref under refs/mux-bundle/ (handles main vs master
   * mismatches). Returns null if no bundle refs exist.
   */
  async resolveBundleTrunkRef(baseRepoPathArg, trunkBranch, abortSignal) {
    const preferredRef = `${BUNDLE_REF_PREFIX}${trunkBranch}`;
    const check = await execBuffered(
      this,
      `git -C ${baseRepoPathArg} rev-parse --verify ${shescape.quote(preferredRef)}`,
      { cwd: "/tmp", timeout: 10, abortSignal }
    );
    if (check.exitCode === 0) {
      return preferredRef;
    }
    const listResult = await execBuffered(
      this,
      `git -C ${baseRepoPathArg} for-each-ref --format='%(refname)' ${BUNDLE_REF_PREFIX} --count=1`,
      { cwd: "/tmp", timeout: 10, abortSignal }
    );
    const fallbackRef = listResult.stdout.trim();
    if (listResult.exitCode === 0 && fallbackRef.length > 0) {
      log.info(`Bundle trunk ref mismatch: expected ${preferredRef}, using ${fallbackRef}`);
      return fallbackRef;
    }
    return null;
  }
  async ensureReady(options) {
    const repoCheck = await this.checkWorkspaceRepo(options);
    if (repoCheck) {
      if (!repoCheck.ready) {
        options?.statusSink?.({
          phase: "error",
          runtimeType: "ssh",
          detail: repoCheck.error
        });
        return repoCheck;
      }
      options?.statusSink?.({ phase: "ready", runtimeType: "ssh" });
      return { ready: true };
    }
    return { ready: true };
  }
  async checkWorkspaceRepo(options) {
    if (!this.ensureReadyProjectPath || !this.ensureReadyWorkspaceName) {
      return null;
    }
    const statusSink = options?.statusSink;
    statusSink?.({
      phase: "checking",
      runtimeType: "ssh",
      detail: "Checking repository..."
    });
    if (options?.signal?.aborted) {
      return { ready: false, error: "Aborted", errorType: "runtime_start_failed" };
    }
    const workspacePath = this.getWorkspacePath(
      this.ensureReadyProjectPath,
      this.ensureReadyWorkspaceName
    );
    const gitDir = path9.posix.join(workspacePath, ".git");
    const gitDirProbe = this.quoteForRemote(gitDir);
    let testResult;
    try {
      testResult = await execBuffered(this, `test -d ${gitDirProbe} || test -f ${gitDirProbe}`, {
        cwd: "~",
        timeout: 10,
        abortSignal: options?.signal
      });
    } catch (error) {
      return {
        ready: false,
        error: `Failed to reach SSH host: ${getErrorMessage4(error)}`,
        errorType: "runtime_start_failed"
      };
    }
    if (testResult.exitCode !== 0) {
      if (this.transport.isConnectionFailure(testResult.exitCode, testResult.stderr)) {
        return {
          ready: false,
          error: `Failed to reach SSH host: ${testResult.stderr || "connection failure"}`,
          errorType: "runtime_start_failed"
        };
      }
      return {
        ready: false,
        error: WORKSPACE_REPO_MISSING_ERROR,
        errorType: "runtime_not_ready"
      };
    }
    let revResult;
    try {
      revResult = await execBuffered(
        this,
        `git -C ${this.quoteForRemote(workspacePath)} rev-parse --git-dir`,
        {
          cwd: "~",
          timeout: 10,
          abortSignal: options?.signal
        }
      );
    } catch (error) {
      return {
        ready: false,
        error: `Failed to verify repository: ${getErrorMessage4(error)}`,
        errorType: "runtime_start_failed"
      };
    }
    if (revResult.exitCode !== 0) {
      const stderr = revResult.stderr.trim();
      const stdout = revResult.stdout.trim();
      const errorDetail = stderr || stdout || "git unavailable";
      const isCommandMissing = revResult.exitCode === 127 || /command not found/i.test(stderr || stdout);
      if (isCommandMissing || this.transport.isConnectionFailure(revResult.exitCode, revResult.stderr)) {
        return {
          ready: false,
          error: `Failed to verify repository: ${errorDetail}`,
          errorType: "runtime_start_failed"
        };
      }
      return {
        ready: false,
        error: WORKSPACE_REPO_MISSING_ERROR,
        errorType: "runtime_not_ready"
      };
    }
    return { ready: true };
  }
  /**
   * Sync project to remote using git bundle
   *
   * Uses `git bundle` to create a packfile and clones it on the remote.
   *
   * Benefits over git archive:
   * - Creates a real git repository on remote (can run git commands)
   * - Better parity with git worktrees (full .git directory with metadata)
   * - Enables remote git operations (commit, branch, status, diff, etc.)
   * - Only tracked files in checkout (no node_modules, build artifacts)
   * - Includes full history for flexibility
   *
   * Benefits over rsync/scp:
   * - Much faster (only tracked files)
   * - No external dependencies (git is always available)
   * - Simpler implementation
   */
  /**
   * Transfer a git bundle to the remote and return its path.
   * Callers are responsible for cleanup of the remote bundle file.
   */
  async transferBundleToRemote(projectPath, initLogger, abortSignal) {
    const timestamp = Date.now();
    const remoteBundlePath = `~/.mux-bundle-${timestamp}.bundle`;
    await this.transport.acquireConnection({
      abortSignal,
      onWait: (waitMs) => logSSHBackoffWait(initLogger, waitMs)
    });
    if (abortSignal?.aborted) {
      throw new Error("Bundle creation aborted");
    }
    initLogger.logStep("Creating git bundle...");
    const gitProc = spawn2(
      "git",
      ["-C", projectPath, "bundle", "create", "-", "--branches", "--tags"],
      {
        stdio: ["ignore", "pipe", "pipe"],
        windowsHide: true
      }
    );
    let stderr = "";
    gitProc.stderr?.on("data", (data) => {
      const chunk = data.toString();
      stderr += chunk;
      for (const line of chunk.split("\n").filter(Boolean)) {
        initLogger.logStderr(line);
      }
    });
    const remoteAbortController = createAbortController(3e5, abortSignal);
    const remoteStream = await this.exec(`cat > ${this.quoteForRemote(remoteBundlePath)}`, {
      cwd: "~",
      abortSignal: remoteAbortController.signal
    });
    try {
      try {
        await pipeReadableToWebWritable(gitProc.stdout, remoteStream.stdin, abortSignal);
      } catch (error) {
        gitProc.kill();
        throw error;
      }
      const [gitExitCode, remoteExitCode] = await Promise.all([
        waitForProcessExit(gitProc),
        remoteStream.exitCode
      ]);
      if (remoteAbortController.didTimeout()) {
        throw new Error(
          `SSH command timed out after 300000ms: cat > ${this.quoteForRemote(remoteBundlePath)}`
        );
      }
      if (abortSignal?.aborted) {
        throw new Error("Bundle creation aborted");
      }
      if (gitExitCode !== 0) {
        throw new Error(`Failed to create bundle: ${stderr}`);
      }
      if (remoteExitCode !== 0) {
        const remoteStderr = await streamToString2(remoteStream.stderr);
        throw new Error(`Failed to upload bundle: ${remoteStderr}`);
      }
    } finally {
      remoteAbortController.dispose();
    }
    return remoteBundlePath;
  }
  /**
   * Sync local project to the shared bare base repo on the remote via git bundle.
   *
   * Branches land in a staging namespace (refs/mux-bundle/*) to avoid colliding
   * with branches checked out in existing worktrees. Tags go to refs/tags/*
   * directly. Remote tracking refs are excluded entirely.
   * Idempotent  re-running is a no-op when nothing changed.
   */
  async syncProjectToRemote(projectPath, _workspacePath, initLogger, abortSignal) {
    const baseRepoPathArg = await this.ensureBaseRepo(projectPath, initLogger, abortSignal);
    const remoteBundlePath = await this.transferBundleToRemote(
      projectPath,
      initLogger,
      abortSignal
    );
    const remoteBundlePathArg = this.quoteForRemote(remoteBundlePath);
    try {
      initLogger.logStep("Importing bundle into shared base repository...");
      const fetchResult = await execBuffered(
        this,
        `git -C ${baseRepoPathArg} fetch ${remoteBundlePathArg} '+refs/heads/*:${BUNDLE_REF_PREFIX}*' '+refs/tags/*:refs/tags/*'`,
        { cwd: "/tmp", timeout: 300, abortSignal }
      );
      if (fetchResult.exitCode !== 0) {
        throw new Error(
          `Failed to import bundle into base repo: ${fetchResult.stderr || fetchResult.stdout}`
        );
      }
      const { originUrl } = await this.getOriginUrlForSync(projectPath, initLogger);
      if (originUrl) {
        initLogger.logStep(`Setting origin remote to ${originUrl}...`);
        await execBuffered(
          this,
          `git -C ${baseRepoPathArg} remote set-url origin ${shescape.quote(originUrl)} 2>/dev/null || git -C ${baseRepoPathArg} remote add origin ${shescape.quote(originUrl)}`,
          { cwd: "/tmp", timeout: 10, abortSignal }
        );
      }
      initLogger.logStep("Repository synced to base successfully");
    } finally {
      try {
        await execBuffered(this, `rm -f ${remoteBundlePathArg}`, {
          cwd: "/tmp",
          timeout: 10
        });
      } catch {
      }
    }
  }
  /** Get origin URL from local project for setting on the remote base repo. */
  async getOriginUrlForSync(projectPath, initLogger) {
    return getOriginUrlForBundle(
      projectPath,
      initLogger,
      /* logErrors */
      false
    );
  }
  async createWorkspace(params) {
    try {
      const { projectPath, branchName, initLogger, abortSignal } = params;
      const workspacePath = this.getWorkspacePath(projectPath, branchName);
      initLogger.logStep("Preparing remote workspace...");
      try {
        const lastSlash = workspacePath.lastIndexOf("/");
        const parentDir = lastSlash > 0 ? workspacePath.substring(0, lastSlash) : "~";
        const expandedParentDir = expandTildeForSSH(parentDir);
        const parentDirCommand = `mkdir -p ${expandedParentDir}`;
        const mkdirStream = await this.exec(parentDirCommand, {
          cwd: "/tmp",
          timeout: 10,
          abortSignal
        });
        const mkdirExitCode = await mkdirStream.exitCode;
        if (mkdirExitCode !== 0) {
          const stderr = await streamToString2(mkdirStream.stderr);
          return {
            success: false,
            error: `Failed to prepare remote workspace: ${stderr}`
          };
        }
      } catch (error) {
        return {
          success: false,
          error: `Failed to prepare remote workspace: ${getErrorMessage4(error)}`
        };
      }
      initLogger.logStep("Remote workspace prepared");
      return {
        success: true,
        workspacePath
      };
    } catch (error) {
      return {
        success: false,
        error: getErrorMessage4(error)
      };
    }
  }
  async initWorkspace(params) {
    const {
      projectPath,
      branchName,
      trunkBranch,
      workspacePath,
      initLogger,
      abortSignal,
      env: env3,
      skipInitHook
    } = params;
    try {
      const workspacePathArg = expandTildeForSSH(workspacePath);
      let shouldSync = true;
      try {
        const dirCheck = await execBuffered(this, `test -d ${workspacePathArg}`, {
          cwd: "/tmp",
          timeout: 10,
          abortSignal
        });
        if (dirCheck.exitCode === 0) {
          const gitCheck = await execBuffered(
            this,
            `git -C ${workspacePathArg} rev-parse --is-inside-work-tree`,
            {
              cwd: "/tmp",
              timeout: 20,
              abortSignal
            }
          );
          shouldSync = gitCheck.exitCode !== 0;
        }
      } catch {
        shouldSync = true;
      }
      if (shouldSync) {
        initLogger.logStep("Syncing project files to remote...");
        const maxSyncAttempts = 3;
        for (let attempt = 1; attempt <= maxSyncAttempts; attempt++) {
          try {
            await this.syncProjectToRemote(projectPath, workspacePath, initLogger, abortSignal);
            break;
          } catch (error) {
            const errorMsg = getErrorMessage4(error);
            const isRetryable = errorMsg.includes("pack-objects died") || errorMsg.includes("Connection reset") || errorMsg.includes("Connection closed") || errorMsg.includes("Broken pipe") || errorMsg.includes("EPIPE");
            if (!isRetryable || attempt === maxSyncAttempts) {
              initLogger.logStderr(`Failed to sync project: ${errorMsg}`);
              initLogger.logComplete(-1);
              return {
                success: false,
                error: `Failed to sync project: ${errorMsg}`
              };
            }
            log.info(
              `Sync failed (attempt ${attempt}/${maxSyncAttempts}), will retry: ${errorMsg}`
            );
            initLogger.logStep(
              `Sync failed, retrying (attempt ${attempt + 1}/${maxSyncAttempts})...`
            );
            await new Promise((r) => setTimeout(r, attempt * 1e3));
          }
        }
        initLogger.logStep("Files synced successfully");
        const baseRepoPath = this.getBaseRepoPath(projectPath);
        const baseRepoPathArg = expandTildeForSSH(baseRepoPath);
        const fetchedOrigin = await this.fetchOriginTrunk(
          baseRepoPath,
          trunkBranch,
          initLogger,
          abortSignal
        );
        const bundleTrunkRef = await this.resolveBundleTrunkRef(
          baseRepoPathArg,
          trunkBranch,
          abortSignal
        );
        const shouldUseOrigin = fetchedOrigin && bundleTrunkRef != null && await this.canFastForwardToOrigin(
          baseRepoPath,
          bundleTrunkRef,
          trunkBranch,
          initLogger,
          abortSignal
        );
        const newBranchBase = shouldUseOrigin ? `origin/${trunkBranch}` : bundleTrunkRef ?? "HEAD";
        initLogger.logStep(`Creating worktree for branch: ${branchName}`);
        const worktreeCmd = `git -C ${baseRepoPathArg} worktree add ${workspacePathArg} -B ${shescape.quote(branchName)} ${shescape.quote(newBranchBase)}`;
        const worktreeResult = await execBuffered(this, worktreeCmd, {
          cwd: "/tmp",
          timeout: 300,
          abortSignal
        });
        if (worktreeResult.exitCode !== 0) {
          const errorMsg = `Failed to create worktree: ${worktreeResult.stderr || worktreeResult.stdout}`;
          initLogger.logStderr(errorMsg);
          initLogger.logComplete(-1);
          return { success: false, error: errorMsg };
        }
        initLogger.logStep("Worktree created successfully");
      } else {
        initLogger.logStep("Remote workspace already contains a git repo; skipping sync");
        const fetchedOrigin = await this.fetchOriginTrunk(
          workspacePath,
          trunkBranch,
          initLogger,
          abortSignal
        );
        const shouldUseOrigin = fetchedOrigin && await this.canFastForwardToOrigin(
          workspacePath,
          trunkBranch,
          trunkBranch,
          initLogger,
          abortSignal
        );
        if (shouldUseOrigin) {
          await this.fastForwardToOrigin(workspacePath, trunkBranch, initLogger, abortSignal);
        }
      }
      if (skipInitHook) {
        initLogger.logStep("Skipping .mux/init hook (disabled for this task)");
        initLogger.logComplete(0);
      } else {
        const hookExists = await checkInitHookExists(projectPath);
        if (hookExists) {
          initLogger.enterHookPhase?.();
          const muxEnv = { ...env3, ...getMuxEnv(projectPath, "ssh", branchName) };
          const hookPath = expandTildeForSSH(`${workspacePath}/.mux/init`);
          await runInitHookOnRuntime(
            this,
            hookPath,
            workspacePath,
            muxEnv,
            initLogger,
            abortSignal
          );
        } else {
          initLogger.logComplete(0);
        }
      }
      return { success: true };
    } catch (error) {
      const errorMsg = getErrorMessage4(error);
      initLogger.logStderr(`Initialization failed: ${errorMsg}`);
      initLogger.logComplete(-1);
      return {
        success: false,
        error: errorMsg
      };
    }
  }
  /**
   * Fetch trunk branch from origin before checkout.
   * Returns true if fetch succeeded (origin is available for branching).
   */
  async fetchOriginTrunk(workspacePath, trunkBranch, initLogger, abortSignal) {
    try {
      initLogger.logStep(`Fetching latest from origin/${trunkBranch}...`);
      const fetchCmd = `git fetch origin ${shescape.quote(trunkBranch)}`;
      const fetchStream = await this.exec(fetchCmd, {
        cwd: workspacePath,
        timeout: 120,
        // 2 minutes for network operation
        abortSignal
      });
      const fetchExitCode = await fetchStream.exitCode;
      if (fetchExitCode !== 0) {
        const fetchStderr = await streamToString2(fetchStream.stderr);
        if (fetchStderr.includes("couldn't find remote ref")) {
          initLogger.logStep(`Branch "${trunkBranch}" not found on origin; using local state.`);
        } else {
          initLogger.logStderr(
            `Note: Could not fetch from origin (${fetchStderr}), using local branch state`
          );
        }
        return false;
      }
      initLogger.logStep("Fetched latest from origin");
      return true;
    } catch (error) {
      const errorMsg = getErrorMessage4(error);
      initLogger.logStderr(
        `Note: Could not fetch from origin (${errorMsg}), using local branch state`
      );
      return false;
    }
  }
  /**
   * Check if a local ref can fast-forward to origin/<originBranch>.
   * Returns true if localRef is behind or equal to origin (safe to use origin).
   * Returns false if localRef is ahead or diverged (preserve local state).
   *
   * @param localRef - The ref to compare (e.g. "main" or "refs/mux-bundle/main")
   * @param originBranch - The branch name on origin (e.g. "main")
   */
  async canFastForwardToOrigin(workspacePath, localRef, originBranch, initLogger, abortSignal) {
    try {
      const checkCmd = `git merge-base --is-ancestor ${shescape.quote(localRef)} origin/${shescape.quote(originBranch)}`;
      const checkStream = await this.exec(checkCmd, {
        cwd: workspacePath,
        timeout: 30,
        abortSignal
      });
      const exitCode = await checkStream.exitCode;
      if (exitCode === 0) {
        return true;
      }
      initLogger.logStderr(
        `Note: Local ${localRef} is ahead of or diverged from origin/${originBranch}, using local state`
      );
      return false;
    } catch {
      return false;
    }
  }
  /**
   * Fast-forward merge to latest origin/<trunkBranch> after checkout.
   * Best-effort operation for existing branches that may be behind origin.
   */
  async fastForwardToOrigin(workspacePath, trunkBranch, initLogger, abortSignal) {
    try {
      initLogger.logStep("Fast-forward merging...");
      const mergeCmd = `git merge --ff-only origin/${shescape.quote(trunkBranch)}`;
      const mergeStream = await this.exec(mergeCmd, {
        cwd: workspacePath,
        timeout: 60,
        // 1 minute for fast-forward merge
        abortSignal
      });
      const [mergeStderr, mergeExitCode] = await Promise.all([
        streamToString2(mergeStream.stderr),
        mergeStream.exitCode
      ]);
      if (mergeExitCode !== 0) {
        initLogger.logStderr(
          `Note: Fast-forward skipped (${mergeStderr || "branches diverged"}), using local branch state`
        );
      } else {
        initLogger.logStep("Fast-forwarded to latest origin successfully");
      }
    } catch (error) {
      const errorMsg = getErrorMessage4(error);
      initLogger.logStderr(`Note: Fast-forward failed (${errorMsg}), using local branch state`);
    }
  }
  async renameWorkspace(projectPath, oldName, newName, abortSignal) {
    if (abortSignal?.aborted) {
      return { success: false, error: "Rename operation aborted" };
    }
    const oldPath = this.getWorkspacePath(projectPath, oldName);
    const newPath = this.getWorkspacePath(projectPath, newName);
    try {
      const expandedOldPath = expandTildeForSSH(oldPath);
      const expandedNewPath = expandTildeForSSH(newPath);
      const isWorktree = await this.isWorktreeWorkspace(oldPath, abortSignal);
      let moveCommand;
      if (isWorktree) {
        const baseRepoPathArg = expandTildeForSSH(this.getBaseRepoPath(projectPath));
        moveCommand = `git -C ${baseRepoPathArg} worktree move ${expandedOldPath} ${expandedNewPath}`;
      } else {
        moveCommand = `mv ${expandedOldPath} ${expandedNewPath}`;
      }
      const stream = await this.exec(moveCommand, {
        cwd: this.config.srcBaseDir,
        timeout: 30,
        abortSignal
      });
      await stream.stdin.abort();
      const exitCode = await stream.exitCode;
      if (exitCode !== 0) {
        const stderrReader = stream.stderr.getReader();
        const decoder = new TextDecoder();
        let stderr = "";
        try {
          while (true) {
            const { done, value: value2 } = await stderrReader.read();
            if (done) break;
            stderr += decoder.decode(value2, { stream: true });
          }
        } finally {
          stderrReader.releaseLock();
        }
        return {
          success: false,
          error: `Failed to rename directory: ${stderr.trim() || "Unknown error"}`
        };
      }
      return { success: true, oldPath, newPath };
    } catch (error) {
      return {
        success: false,
        error: `Failed to rename directory: ${getErrorMessage4(error)}`
      };
    }
  }
  async deleteWorkspace(projectPath, workspaceName, force, abortSignal) {
    if (abortSignal?.aborted) {
      return { success: false, error: "Delete operation aborted" };
    }
    const deletedPath = this.getWorkspacePath(projectPath, workspaceName);
    try {
      const checkScript = force ? (
        // When force=true, only check existence
        `test -d ${shescape.quote(deletedPath)} || exit 3`
      ) : (
        // When force=false, perform all safety checks
        `
            test -d ${shescape.quote(deletedPath)} || exit 3
            cd ${shescape.quote(deletedPath)} || exit 1
            git diff --quiet --exit-code && git diff --quiet --cached --exit-code || exit 1
            if git remote | grep -q .; then
              # First, check the original condition: any commits not in any remote
              unpushed=$(git log --branches --not --remotes --oneline)
              if [ -n "$unpushed" ]; then
                # Get current branch for better error messaging
                BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)

                # Get default branch (prefer main/master over origin/HEAD since origin/HEAD
                # might point to a feature branch in some setups)
                if git rev-parse --verify origin/main >/dev/null 2>&1; then
                  DEFAULT="main"
                elif git rev-parse --verify origin/master >/dev/null 2>&1; then
                  DEFAULT="master"
                else
                  # Fallback to origin/HEAD if main/master don't exist
                  DEFAULT=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
                fi

                # Check for squash-merge: if all changed files match origin/$DEFAULT, content is merged
                if [ -n "$DEFAULT" ]; then
                  # Fetch latest to ensure we have current remote state
                  git fetch origin "$DEFAULT" --quiet 2>/dev/null || true

                  # Get merge-base between current branch and default
                  MERGE_BASE=$(git merge-base "origin/$DEFAULT" HEAD 2>/dev/null)
                  if [ -n "$MERGE_BASE" ]; then
                    # Get files changed on this branch since fork point
                    CHANGED_FILES=$(git diff --name-only "$MERGE_BASE" HEAD 2>/dev/null)

                    if [ -n "$CHANGED_FILES" ]; then
                      # Check if all changed files match what's in origin/$DEFAULT
                      ALL_MERGED=true
                      while IFS= read -r f; do
                        # Compare file content between HEAD and origin/$DEFAULT
                        # If file doesn't exist in one but exists in other, they differ
                        if ! git diff --quiet "HEAD:$f" "origin/$DEFAULT:$f" 2>/dev/null; then
                          ALL_MERGED=false
                          break
                        fi
                      done <<< "$CHANGED_FILES"

                      if $ALL_MERGED; then
                        # All changes are in default branch - safe to delete (squash-merge case)
                        exit 0
                      fi
                    else
                      # No changed files means nothing to merge - safe to delete
                      exit 0
                    fi
                  fi
                fi

                # If we get here, there are real unpushed changes
                # Show helpful output for debugging
                if [ -n "$BRANCH" ] && [ -n "$DEFAULT" ] && git show-branch "$BRANCH" "origin/$DEFAULT" >/dev/null 2>&1; then
                  echo "Branch status compared to origin/$DEFAULT:" >&2
                  echo "" >&2
                  git show-branch "$BRANCH" "origin/$DEFAULT" 2>&1 | head -20 >&2
                  echo "" >&2
                  echo "Note: Branch has changes not yet in origin/$DEFAULT." >&2
                else
                  # Fallback to just showing the commit list
                  echo "$unpushed" | head -10 >&2
                fi
                exit 2
              fi
            fi
            exit 0
          `
      );
      const checkStream = await this.exec(checkScript, {
        cwd: this.config.srcBaseDir,
        // Non-force path includes `git fetch origin` (network op) that can
        // easily exceed 10s on slow SSH connections. Force path only checks
        // existence, so a short timeout is fine.
        timeout: force ? 10 : 30,
        abortSignal
      });
      await checkStream.stdin.abort();
      const checkExitCode = await checkStream.exitCode;
      if (checkExitCode === 3) {
        return { success: true, deletedPath };
      }
      if (checkExitCode === 1) {
        return {
          success: false,
          error: "Workspace contains uncommitted changes. Use force flag to delete anyway."
        };
      }
      if (checkExitCode === 2) {
        const stderr = await streamToString2(checkStream.stderr);
        const commitList = stderr.trim();
        const errorMsg = commitList ? `Workspace contains unpushed commits:

${commitList}` : "Workspace contains unpushed commits. Use force flag to delete anyway.";
        return {
          success: false,
          error: errorMsg
        };
      }
      if (checkExitCode !== 0) {
        const stderr = await streamToString2(checkStream.stderr);
        return {
          success: false,
          error: `Failed to check workspace state: ${stderr.trim() || `exit code ${checkExitCode}`}`
        };
      }
      const isWorktree = await this.isWorktreeWorkspace(deletedPath, abortSignal);
      if (isWorktree) {
        const baseRepoPathArg = expandTildeForSSH(this.getBaseRepoPath(projectPath));
        const removeCmd = force ? `git -C ${baseRepoPathArg} worktree remove --force ${this.quoteForRemote(deletedPath)}` : `git -C ${baseRepoPathArg} worktree remove ${this.quoteForRemote(deletedPath)}`;
        const stream = await this.exec(removeCmd, {
          cwd: this.config.srcBaseDir,
          timeout: 30,
          abortSignal
        });
        await stream.stdin.abort();
        const exitCode = await stream.exitCode;
        if (exitCode !== 0) {
          const stderr = await streamToString2(stream.stderr);
          const fallbackStream = await this.exec(
            // Use quoteForRemote (expandTildeForSSH) to match the quoting in the
            // worktree remove command above  shescape.quote doesn't expand tilde.
            // `worktree prune` is best-effort: if the base repo was externally
            // deleted/corrupted the prune fails, but the workspace IS gone after
            // rm -rf  don't report failure for a cosmetic prune error.
            `rm -rf ${this.quoteForRemote(deletedPath)} && (git -C ${baseRepoPathArg} worktree prune 2>/dev/null || true)`,
            { cwd: this.config.srcBaseDir, timeout: 30, abortSignal }
          );
          await fallbackStream.stdin.abort();
          const fallbackExitCode = await fallbackStream.exitCode;
          if (fallbackExitCode !== 0) {
            const fallbackStderr = await streamToString2(fallbackStream.stderr);
            return {
              success: false,
              error: `Failed to delete worktree: ${stderr.trim() || fallbackStderr.trim() || "Unknown error"}`
            };
          }
        }
        const PROTECTED_BRANCHES = ["main", "master", "trunk", "develop", "default"];
        if (!PROTECTED_BRANCHES.includes(workspaceName)) {
          await execBuffered(
            this,
            `git -C ${baseRepoPathArg} branch -D ${shescape.quote(workspaceName)} 2>/dev/null || true`,
            { cwd: "/tmp", timeout: 10 }
          ).catch(() => void 0);
        }
      } else {
        const removeCommand = `rm -rf ${shescape.quote(deletedPath)}`;
        const stream = await this.exec(removeCommand, {
          cwd: this.config.srcBaseDir,
          timeout: 30,
          abortSignal
        });
        await stream.stdin.abort();
        const exitCode = await stream.exitCode;
        if (exitCode !== 0) {
          const stderr = await streamToString2(stream.stderr);
          return {
            success: false,
            error: `Failed to delete directory: ${stderr.trim() || "Unknown error"}`
          };
        }
      }
      return { success: true, deletedPath };
    } catch (error) {
      return { success: false, error: `Failed to delete directory: ${getErrorMessage4(error)}` };
    }
  }
  async forkWorkspace(params) {
    const { projectPath, sourceWorkspaceName, newWorkspaceName, initLogger, abortSignal } = params;
    const sourceWorkspacePath = this.getWorkspacePath(projectPath, sourceWorkspaceName);
    const newWorkspacePath = this.getWorkspacePath(projectPath, newWorkspaceName);
    const sourceWorkspacePathArg = expandTildeForSSH(sourceWorkspacePath);
    const newWorkspacePathArg = expandTildeForSSH(newWorkspacePath);
    try {
      {
        const exists = await execBuffered(this, `test -e ${newWorkspacePathArg}`, {
          cwd: "/tmp",
          timeout: 10,
          abortSignal
        });
        if (exists.exitCode === 0) {
          return { success: false, error: `Workspace already exists at ${newWorkspacePath}` };
        }
      }
      initLogger.logStep("Detecting source workspace branch...");
      const branchResult = await execBuffered(
        this,
        `git -C ${sourceWorkspacePathArg} branch --show-current`,
        {
          cwd: "/tmp",
          timeout: 30,
          abortSignal
        }
      );
      const sourceBranch = branchResult.stdout.trim();
      if (branchResult.exitCode !== 0 || sourceBranch.length === 0) {
        return {
          success: false,
          error: "Failed to detect branch in source workspace"
        };
      }
      const baseRepoPath = this.getBaseRepoPath(projectPath);
      const baseRepoPathArg = expandTildeForSSH(baseRepoPath);
      let usedWorktree = false;
      const hasBaseRepo = await execBuffered(this, `test -d ${baseRepoPathArg}`, {
        cwd: "/tmp",
        timeout: 10,
        abortSignal
      });
      if (hasBaseRepo.exitCode === 0) {
        initLogger.logStep("Creating worktree for forked workspace...");
        const worktreeCmd = `git -C ${baseRepoPathArg} worktree add ${newWorkspacePathArg} -b ${shescape.quote(newWorkspaceName)} ${shescape.quote(sourceBranch)}`;
        const worktreeResult = await execBuffered(this, worktreeCmd, {
          cwd: "/tmp",
          timeout: 60,
          abortSignal
        });
        if (worktreeResult.exitCode === 0) {
          usedWorktree = true;
        } else {
          await execBuffered(this, `rm -rf ${newWorkspacePathArg}`, {
            cwd: "/tmp",
            timeout: 10
            // Best-effort cleanup  ignore failures since we're about to fall
            // through to the cp path which will overwrite the target anyway.
          }).catch(() => void 0);
          log.info(
            `Worktree fork failed (${(worktreeResult.stderr || worktreeResult.stdout).trim()}); falling back to full copy`
          );
          initLogger.logStep("Worktree creation failed; falling back to full copy...");
        }
      }
      if (!usedWorktree) {
        initLogger.logStep("Preparing remote workspace...");
        const parentDir = path9.posix.dirname(newWorkspacePath);
        const mkdirResult = await execBuffered(this, `mkdir -p ${expandTildeForSSH(parentDir)}`, {
          cwd: "/tmp",
          timeout: 10,
          abortSignal
        });
        if (mkdirResult.exitCode !== 0) {
          return {
            success: false,
            error: `Failed to prepare remote workspace: ${mkdirResult.stderr || mkdirResult.stdout}`
          };
        }
        initLogger.logStep("Copying workspace on remote...");
        const copyResult = await execBuffered(
          this,
          `cp -R -P ${sourceWorkspacePathArg} ${newWorkspacePathArg}`,
          { cwd: "/tmp", timeout: 300, abortSignal }
        );
        if (copyResult.exitCode !== 0) {
          try {
            await execBuffered(this, `rm -rf ${newWorkspacePathArg}`, {
              cwd: "/tmp",
              timeout: 30
            });
          } catch {
          }
          return {
            success: false,
            error: `Failed to copy workspace: ${copyResult.stderr || copyResult.stdout}`
          };
        }
        initLogger.logStep("Creating local tracking branches...");
        try {
          await execBuffered(
            this,
            `cd ${newWorkspacePathArg} && for branch in $(git for-each-ref --format='%(refname:short)' refs/remotes/origin/ | grep -v 'origin/HEAD'); do localname=\${branch#origin/}; git show-ref --verify --quiet refs/heads/$localname || git branch $localname $branch; done`,
            { cwd: "/tmp", timeout: 30 }
          );
        } catch {
        }
        try {
          const originResult = await execBuffered(
            this,
            `git -C ${sourceWorkspacePathArg} remote get-url origin 2>/dev/null || true`,
            { cwd: "/tmp", timeout: 10 }
          );
          const originUrl = originResult.stdout.trim();
          if (originUrl.length > 0) {
            await execBuffered(
              this,
              `git -C ${newWorkspacePathArg} remote set-url origin ${shescape.quote(originUrl)}`,
              { cwd: "/tmp", timeout: 10 }
            );
          } else {
            await execBuffered(
              this,
              `git -C ${newWorkspacePathArg} remote remove origin 2>/dev/null || true`,
              { cwd: "/tmp", timeout: 10 }
            );
          }
        } catch {
        }
        initLogger.logStep(`Checking out branch: ${newWorkspaceName}`);
        const checkoutCmd = `git checkout ${shescape.quote(newWorkspaceName)} 2>/dev/null || git checkout -b ${shescape.quote(newWorkspaceName)} ${shescape.quote(sourceBranch)}`;
        const checkoutResult = await execBuffered(this, checkoutCmd, {
          cwd: newWorkspacePath,
          timeout: 120
        });
        if (checkoutResult.exitCode !== 0) {
          return {
            success: false,
            error: `Failed to checkout forked branch: ${checkoutResult.stderr || checkoutResult.stdout}`
          };
        }
      }
      return { success: true, workspacePath: newWorkspacePath, sourceBranch };
    } catch (error) {
      return { success: false, error: getErrorMessage4(error) };
    }
  }
};

// src/node/runtime/CoderSSHRuntime.ts
import * as path10 from "path";
var CODER_NAME_REGEX = /^[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*$/;
function toCoderCompatibleName(name25) {
  return name25.replace(/_/g, "-").replace(/^-+|-+$/g, "").replace(/-{2,}/g, "-");
}
var CODER_INACTIVITY_THRESHOLD_MS = 5 * 60 * 1e3;
var CODER_ENSURE_READY_TIMEOUT_MS = 12e4;
var CODER_STATUS_POLL_INTERVAL_MS = 2e3;
var CoderSSHRuntime = class extends SSHRuntime {
  constructor(config2, transport, coderService, options) {
    if (!config2 || !coderService || !transport) {
      throw new Error("CoderSSHRuntime requires config, transport, and coderService");
    }
    const baseConfig = {
      host: config2.host,
      srcBaseDir: config2.srcBaseDir,
      bgOutputDir: config2.bgOutputDir,
      identityFile: config2.identityFile,
      port: config2.port
    };
    super(baseConfig, transport, options);
    /**
     * Timestamp of last time we (a) successfully used the runtime or (b) decided not
     * to block the user (unknown Coder CLI error).
     * Used to avoid running expensive status checks on every message while still
     * catching auto-stopped workspaces after long inactivity.
     */
    this.lastActivityAtMs = 0;
    /**
     * Flags for WorkspaceService to customize create flow:
     * - deferredRuntimeAccess: skip srcBaseDir resolution (Coder host doesn't exist yet)
     * - configLevelCollisionDetection: use config-based collision check (can't reach host)
     */
    this.createFlags = {
      deferredRuntimeAccess: true,
      configLevelCollisionDetection: true
    };
    /** In-flight ensureReady promise to avoid duplicate start/wait sequences */
    this.ensureReadyPromise = null;
    this.coderConfig = config2.coder;
    this.coderService = coderService;
  }
  /**
   * Check if runtime is ready for use.
   *
   * Behavior:
   * - If creation failed during postCreateSetup(), fail fast.
   * - If workspace is running: return ready.
   * - If workspace is stopped: auto-start and wait (blocking, ~120s timeout).
   * - If workspace is stopping: poll until stopped, then start.
   * - Emits runtime-status events via statusSink for UX feedback.
   *
   * Concurrency: shares an in-flight promise to avoid duplicate start sequences.
   */
  async ensureReady(options) {
    const workspaceName = this.coderConfig.workspaceName;
    if (!workspaceName) {
      return {
        ready: false,
        error: "Coder workspace name not set",
        errorType: "runtime_not_ready"
      };
    }
    const now2 = Date.now();
    if (this.lastActivityAtMs !== 0 && now2 - this.lastActivityAtMs < CODER_INACTIVITY_THRESHOLD_MS) {
      return { ready: true };
    }
    if (this.ensureReadyPromise) {
      return this.ensureReadyPromise;
    }
    this.ensureReadyPromise = this.doEnsureReady(workspaceName, options);
    try {
      return await this.ensureReadyPromise;
    } finally {
      this.ensureReadyPromise = null;
    }
  }
  /**
   * Core ensureReady logic - called once (protected by ensureReadyPromise).
   *
   * Flow:
   * 1. Check status via `coder list` - short-circuit for "running" or "not_found"
   * 2. If "stopping"/"canceling": poll until it clears (coder ssh can't autostart during these)
   * 3. Run `coder ssh --wait=yes -- true` which handles everything else:
   *    - stopped: auto-starts, streams build logs, waits for startup scripts
   *    - starting/pending: waits for build completion + startup scripts
   */
  async doEnsureReady(workspaceName, options) {
    const statusSink = options?.statusSink;
    const signal = options?.signal;
    const startTime = Date.now();
    const emitStatus = (phase, detail) => {
      statusSink?.({ phase, runtimeType: "ssh", detail });
    };
    const isTimedOut = () => Date.now() - startTime > CODER_ENSURE_READY_TIMEOUT_MS;
    const remainingMs = () => Math.max(0, CODER_ENSURE_READY_TIMEOUT_MS - (Date.now() - startTime));
    emitStatus("checking");
    if (signal?.aborted) {
      emitStatus("error");
      return { ready: false, error: "Aborted", errorType: "runtime_start_failed" };
    }
    let statusResult = await this.coderService.getWorkspaceStatus(workspaceName, {
      timeoutMs: Math.min(remainingMs(), 1e4),
      signal
    });
    if (statusResult.kind === "ok" && statusResult.status === "running") {
      const repoCheck = await this.checkWorkspaceRepo(options);
      if (repoCheck && !repoCheck.ready) {
        emitStatus("error", repoCheck.error);
        return repoCheck;
      }
      this.lastActivityAtMs = Date.now();
      emitStatus("ready");
      return { ready: true };
    }
    if (statusResult.kind === "not_found") {
      emitStatus("error");
      return {
        ready: false,
        error: `Coder workspace "${workspaceName}" not found`,
        errorType: "runtime_not_ready"
      };
    }
    if (statusResult.kind === "error") {
      if (signal?.aborted) {
        emitStatus("error");
        return { ready: false, error: "Aborted", errorType: "runtime_start_failed" };
      }
      log.debug("Coder workspace status unknown, proceeding optimistically", {
        workspaceName,
        error: statusResult.error
      });
    }
    if (statusResult.kind === "ok" && (statusResult.status === "stopping" || statusResult.status === "canceling")) {
      emitStatus("waiting", "Waiting for Coder workspace to stop...");
      while (statusResult.kind === "ok" && (statusResult.status === "stopping" || statusResult.status === "canceling") && !isTimedOut()) {
        if (signal?.aborted) {
          emitStatus("error");
          return { ready: false, error: "Aborted", errorType: "runtime_start_failed" };
        }
        await this.sleep(CODER_STATUS_POLL_INTERVAL_MS, signal);
        statusResult = await this.coderService.getWorkspaceStatus(workspaceName, {
          timeoutMs: Math.min(remainingMs(), 1e4),
          signal
        });
        if (statusResult.kind === "ok" && statusResult.status === "running") {
          const repoCheck = await this.checkWorkspaceRepo(options);
          if (repoCheck && !repoCheck.ready) {
            emitStatus("error", repoCheck.error);
            return repoCheck;
          }
          this.lastActivityAtMs = Date.now();
          emitStatus("ready");
          return { ready: true };
        }
        if (statusResult.kind === "not_found") {
          emitStatus("error");
          return {
            ready: false,
            error: `Coder workspace "${workspaceName}" not found`,
            errorType: "runtime_not_ready"
          };
        }
      }
      if (isTimedOut()) {
        emitStatus("error");
        return {
          ready: false,
          error: "Coder workspace is still stopping... Please retry shortly.",
          errorType: "runtime_start_failed"
        };
      }
    }
    emitStatus("starting", "Connecting to Coder workspace...");
    log.debug("Connecting to Coder workspace via SSH", { workspaceName });
    const controller = new AbortController();
    const checkInterval = setInterval(() => {
      if (isTimedOut() || signal?.aborted) {
        controller.abort();
        clearInterval(checkInterval);
      }
    }, 1e3);
    controller.signal.addEventListener("abort", () => clearInterval(checkInterval), {
      once: true
    });
    if (isTimedOut() || signal?.aborted) controller.abort();
    try {
      for await (const _line of this.coderService.waitForStartupScripts(
        workspaceName,
        controller.signal
      )) {
      }
      const repoCheck = await this.checkWorkspaceRepo(options);
      if (repoCheck && !repoCheck.ready) {
        emitStatus("error", repoCheck.error);
        return repoCheck;
      }
      this.lastActivityAtMs = Date.now();
      emitStatus("ready");
      return { ready: true };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      emitStatus("error");
      if (isTimedOut()) {
        return {
          ready: false,
          error: "Coder workspace start timed out",
          errorType: "runtime_start_failed"
        };
      }
      if (signal?.aborted) {
        return { ready: false, error: "Aborted", errorType: "runtime_start_failed" };
      }
      if (/not found|no access/i.test(errorMsg)) {
        return {
          ready: false,
          error: `Coder workspace "${workspaceName}" not found`,
          errorType: "runtime_not_ready"
        };
      }
      return {
        ready: false,
        error: `Failed to connect to Coder workspace: ${errorMsg}`,
        errorType: "runtime_start_failed"
      };
    } finally {
      clearInterval(checkInterval);
    }
  }
  /** Promise-based sleep helper */
  sleep(ms, abortSignal) {
    if (abortSignal?.aborted) {
      return Promise.resolve();
    }
    return new Promise((resolve4) => {
      const timeout = setTimeout(() => {
        abortSignal?.removeEventListener("abort", onAbort);
        resolve4();
      }, ms);
      const onAbort = () => {
        clearTimeout(timeout);
        abortSignal?.removeEventListener("abort", onAbort);
        resolve4();
      };
      abortSignal?.addEventListener("abort", onAbort, { once: true });
    });
  }
  /**
   * Finalize runtime config after collision handling.
   * Derives Coder workspace name from branch name and computes SSH host.
   */
  async finalizeConfig(finalBranchName, config2) {
    if (!isSSHRuntime(config2) || !config2.coder) {
      return Ok(config2);
    }
    const coder2 = config2.coder;
    let workspaceName = coder2.workspaceName?.trim() ?? "";
    if (!coder2.existingWorkspace) {
      if (!workspaceName) {
        workspaceName = `mux-${finalBranchName}`;
      }
      workspaceName = toCoderCompatibleName(workspaceName);
      if (!CODER_NAME_REGEX.test(workspaceName)) {
        return Err(
          `Workspace name "${finalBranchName}" cannot be converted to a valid Coder name. Use only letters, numbers, and hyphens.`
        );
      }
    } else {
      if (!workspaceName) {
        return Err("Coder workspace name is required for existing workspaces");
      }
    }
    if (!workspaceName) {
      return Err("Coder workspace name is required");
    }
    let hostnameSuffix;
    try {
      const session = coder2.existingWorkspace ? void 0 : await this.coderService.ensureProvisioningSession(workspaceName);
      const sshConfig = await this.coderService.fetchDeploymentSshConfig(session);
      hostnameSuffix = sshConfig.hostnameSuffix;
    } catch (error) {
      if (!coder2.existingWorkspace) {
        await this.coderService.disposeProvisioningSession(workspaceName);
      }
      const message = error instanceof Error ? error.message : String(error);
      return Err(
        `Failed to read Coder deployment SSH config. Make sure you're logged in with the Coder CLI. (${message})`
      );
    }
    return Ok({
      ...config2,
      host: `${workspaceName}.${hostnameSuffix}`,
      coder: { ...coder2, workspaceName }
    });
  }
  /**
   * Validate before persisting workspace metadata.
   * Checks if a Coder workspace with this name already exists.
   */
  async validateBeforePersist(_finalBranchName, config2) {
    if (!isSSHRuntime(config2) || !config2.coder) {
      return Ok(void 0);
    }
    if (config2.coder.existingWorkspace) {
      return Ok(void 0);
    }
    const workspaceName = config2.coder.workspaceName;
    if (!workspaceName) {
      return Ok(void 0);
    }
    const exists = await this.coderService.workspaceExists(workspaceName);
    if (exists) {
      await this.coderService.disposeProvisioningSession(workspaceName);
      return Err(
        `A Coder workspace named "${workspaceName}" already exists. Either switch to "Existing" mode to use it, delete/rename it in Coder, or choose a different mux workspace name.`
      );
    }
    return Ok(void 0);
  }
  /**
   * Create workspace (fast path only - no SSH needed).
   * The Coder workspace may not exist yet, so we can't reach the SSH host.
   * Just compute the workspace path locally.
   */
  createWorkspace(params) {
    const workspacePath = this.getWorkspacePath(params.projectPath, params.directoryName);
    params.initLogger.logStep("Workspace path computed (Coder provisioning will follow)");
    return Promise.resolve({
      success: true,
      workspacePath
    });
  }
  /**
   * Delete workspace: removes SSH files AND deletes Coder workspace (if Mux-managed).
   *
   * IMPORTANT: Only delete the Coder workspace once we're confident mux will commit
   * the deletion. In the non-force path, WorkspaceService.remove() aborts and keeps
   * workspace metadata when runtime.deleteWorkspace() fails.
   */
  async deleteWorkspace(projectPath, workspaceName, force, abortSignal) {
    if (this.coderConfig.existingWorkspace) {
      return super.deleteWorkspace(projectPath, workspaceName, force, abortSignal);
    }
    const coderWorkspaceName = this.coderConfig.workspaceName;
    if (!coderWorkspaceName) {
      log.warn("Coder workspace name not set, falling back to SSH-only deletion");
      return super.deleteWorkspace(projectPath, workspaceName, force, abortSignal);
    }
    if (force) {
      const deleteResult = await this.coderService.deleteWorkspaceEventually(coderWorkspaceName, {
        timeoutMs: 6e4,
        signal: abortSignal,
        // Avoid races where coder create finishes server-side after we abort the local CLI.
        waitForExistence: true,
        // If the workspace never appears on the server within 10s, assume it was never created
        // and return early instead of waiting the full 60s timeout.
        waitForExistenceTimeoutMs: 1e4
      });
      if (!deleteResult.success) {
        return { success: false, error: `Failed to delete Coder workspace: ${deleteResult.error}` };
      }
      return { success: true, deletedPath: this.getWorkspacePath(projectPath, workspaceName) };
    }
    const statusResult = await this.coderService.getWorkspaceStatus(coderWorkspaceName);
    if (statusResult.kind === "not_found") {
      log.debug("Coder workspace already deleted, skipping SSH cleanup", { coderWorkspaceName });
      return { success: true, deletedPath: this.getWorkspacePath(projectPath, workspaceName) };
    }
    if (statusResult.kind === "error") {
      log.warn("Could not check Coder workspace status, proceeding with SSH cleanup", {
        coderWorkspaceName,
        error: statusResult.error
      });
    }
    if (statusResult.kind === "ok") {
      if (statusResult.status === "stopped") {
        if (abortSignal?.aborted && !force) {
          return { success: false, error: "Delete operation aborted" };
        }
        try {
          log.debug("Coder workspace is stopped; deleting without SSH cleanup", {
            coderWorkspaceName
          });
          const deleteResult = await this.coderService.deleteWorkspaceEventually(
            coderWorkspaceName,
            {
              timeoutMs: 6e4,
              signal: abortSignal,
              waitForExistence: false
            }
          );
          if (!deleteResult.success) {
            return {
              success: false,
              error: `Failed to delete Coder workspace: ${deleteResult.error}`
            };
          }
          return {
            success: true,
            deletedPath: this.getWorkspacePath(projectPath, workspaceName)
          };
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          log.error("Failed to delete stopped Coder workspace", {
            coderWorkspaceName,
            error: message
          });
          return { success: false, error: `Failed to delete Coder workspace: ${message}` };
        }
      }
      if (statusResult.status === "deleted" || statusResult.status === "deleting") {
        log.debug("Coder workspace is deleted/deleting, skipping SSH cleanup", {
          coderWorkspaceName,
          status: statusResult.status
        });
        return { success: true, deletedPath: this.getWorkspacePath(projectPath, workspaceName) };
      }
    }
    const sshResult = await super.deleteWorkspace(projectPath, workspaceName, force, abortSignal);
    if (!sshResult.success && !force) {
      return sshResult;
    }
    try {
      log.debug(`Deleting Coder workspace "${coderWorkspaceName}"`);
      const deleteResult = await this.coderService.deleteWorkspaceEventually(coderWorkspaceName, {
        timeoutMs: 6e4,
        signal: abortSignal,
        waitForExistence: false
      });
      if (!deleteResult.success) {
        throw new Error(deleteResult.error);
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      log.error("Failed to delete Coder workspace", {
        coderWorkspaceName,
        error: message
      });
      if (sshResult.success) {
        return {
          success: false,
          error: `SSH delete succeeded, but failed to delete Coder workspace: ${message}`
        };
      }
      return {
        success: false,
        error: `SSH delete failed: ${sshResult.error}; Coder delete also failed: ${message}`
      };
    }
    return sshResult;
  }
  /**
   * Fork workspace: delegates to SSHRuntime, but marks both source and fork
   * as existingWorkspace=true so neither can delete the shared Coder workspace.
   *
   * IMPORTANT: Also updates this instance's coderConfig so that if postCreateSetup
   * runs on this same runtime instance (for the forked workspace), it won't attempt
   * to create a new Coder workspace.
   */
  async forkWorkspace(params) {
    const result = await super.forkWorkspace(params);
    if (!result.success) return { ...result, failureIsFatal: true };
    const sharedCoderConfig = { ...this.coderConfig, existingWorkspace: true };
    this.coderConfig = sharedCoderConfig;
    const sshConfig = this.getConfig();
    const sharedRuntimeConfig = { type: "ssh", ...sshConfig, coder: sharedCoderConfig };
    return {
      ...result,
      forkedRuntimeConfig: sharedRuntimeConfig,
      sourceRuntimeConfig: sharedRuntimeConfig
    };
  }
  /**
   * Post-create setup: provision Coder workspace and configure SSH.
   * This runs after mux persists workspace metadata, so build logs stream to UI.
   */
  async postCreateSetup(params) {
    const { initLogger, abortSignal } = params;
    if (!this.coderConfig.existingWorkspace) {
      const coderWorkspaceName = this.coderConfig.workspaceName;
      if (!coderWorkspaceName) {
        throw new Error("Coder workspace name is required (should be set by finalizeConfig)");
      }
      if (!this.coderConfig.template) {
        await this.coderService.disposeProvisioningSession(coderWorkspaceName);
        throw new Error("Coder template is required for new workspaces");
      }
      initLogger.logStep(`Creating Coder workspace "${coderWorkspaceName}"...`);
      const provisioningSession = this.coderService.takeProvisioningSession(coderWorkspaceName);
      try {
        for await (const line of this.coderService.createWorkspace(
          coderWorkspaceName,
          this.coderConfig.template,
          this.coderConfig.preset,
          abortSignal,
          this.coderConfig.templateOrg,
          provisioningSession
        )) {
          initLogger.logStdout(line);
        }
        initLogger.logStep("Coder workspace created successfully");
        initLogger.logStep("Waiting for startup scripts...");
        for await (const line of this.coderService.waitForStartupScripts(
          coderWorkspaceName,
          abortSignal
        )) {
          initLogger.logStdout(line);
        }
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        log.error("Failed to create Coder workspace", { error, config: this.coderConfig });
        initLogger.logStderr(`Failed to create Coder workspace: ${errorMsg}`);
        throw new Error(`Failed to create Coder workspace: ${errorMsg}`);
      } finally {
        if (provisioningSession) {
          await provisioningSession.dispose();
        }
      }
    } else if (this.coderConfig.workspaceName) {
      const workspaceName = this.coderConfig.workspaceName;
      let status = await this.coderService.getWorkspaceStatus(workspaceName, {
        signal: abortSignal
      });
      if (status.kind === "ok" && (status.status === "stopping" || status.status === "canceling")) {
        initLogger.logStep(`Waiting for Coder workspace "${workspaceName}" to stop...`);
        while (status.kind === "ok" && (status.status === "stopping" || status.status === "canceling")) {
          if (abortSignal?.aborted) {
            throw new Error("Aborted while waiting for Coder workspace to stop");
          }
          await this.sleep(CODER_STATUS_POLL_INTERVAL_MS, abortSignal);
          status = await this.coderService.getWorkspaceStatus(workspaceName, {
            signal: abortSignal
          });
        }
      }
      initLogger.logStep(`Connecting to Coder workspace "${workspaceName}"...`);
      try {
        for await (const line of this.coderService.waitForStartupScripts(
          workspaceName,
          abortSignal
        )) {
          initLogger.logStdout(line);
        }
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        log.error("Failed waiting for Coder workspace", { error, config: this.coderConfig });
        initLogger.logStderr(`Failed connecting to Coder workspace: ${errorMsg}`);
        throw new Error(`Failed connecting to Coder workspace: ${errorMsg}`);
      }
    }
    initLogger.logStep("Configuring SSH for Coder...");
    try {
      await this.coderService.ensureSSHConfig();
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      log.error("Failed to configure SSH for Coder", { error });
      initLogger.logStderr(`Failed to configure SSH: ${errorMsg}`);
      throw new Error(`Failed to configure SSH for Coder: ${errorMsg}`);
    }
    initLogger.logStep("Preparing workspace directory...");
    const parentDir = path10.posix.dirname(params.workspacePath);
    const mkdirResult = await execBuffered(this, `mkdir -p ${expandTildeForSSH(parentDir)}`, {
      cwd: "/tmp",
      timeout: 10,
      abortSignal
    });
    if (mkdirResult.exitCode !== 0) {
      const errorMsg = mkdirResult.stderr || mkdirResult.stdout || "Unknown error";
      log.error("Failed to create workspace parent directory", { parentDir, error: errorMsg });
      initLogger.logStderr(`Failed to prepare workspace directory: ${errorMsg}`);
      throw new Error(`Failed to prepare workspace directory: ${errorMsg}`);
    }
    this.lastActivityAtMs = Date.now();
  }
};

// src/node/runtime/transports/OpenSSHTransport.ts
import { spawn as spawn4 } from "child_process";

// src/node/runtime/ptySpawn.ts
function loadNodePty(runtimeType, preferElectronBuild) {
  const first = preferElectronBuild ? "node-pty" : "@lydell/node-pty";
  const second = preferElectronBuild ? "@lydell/node-pty" : "node-pty";
  try {
    const pty = __require(first);
    log.debug(`Using ${first} for ${runtimeType}`);
    return pty;
  } catch {
    try {
      const pty = __require(second);
      log.debug(`Using ${second} for ${runtimeType} (fallback)`);
      return pty;
    } catch (err) {
      log.error("Neither @lydell/node-pty nor node-pty available:", err);
      throw new Error(
        process.versions.electron ? `${runtimeType} terminals are not available. node-pty failed to load (likely due to Electron ABI version mismatch). Run 'make rebuild-native' to rebuild native modules.` : `${runtimeType} terminals are not available. No prebuilt binaries found for your platform. Supported: linux-x64, linux-arm64, darwin-x64, darwin-arm64, win32-x64.`
      );
    }
  }
}
function resolvePathEnv(env3, pathEnvOverride) {
  if (pathEnvOverride) {
    return pathEnvOverride;
  }
  return env3.PATH ?? env3.Path ?? (process.platform === "win32" ? void 0 : "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin");
}
function spawnPtyProcess(request) {
  const pty = loadNodePty(request.runtimeLabel, request.preferElectronBuild);
  const mergedEnv = { ...process.env, ...request.env };
  const pathEnv = resolvePathEnv(mergedEnv, request.pathEnv);
  const env3 = {
    ...mergedEnv,
    TERM: "xterm-256color",
    ...pathEnv ? { PATH: pathEnv } : {}
  };
  try {
    return pty.spawn(request.command, request.args, {
      name: "xterm-256color",
      cols: request.cols,
      rows: request.rows,
      cwd: request.cwd,
      env: env3
    });
  } catch (err) {
    log.error(`[PTY] Failed to spawn ${request.runtimeLabel} terminal:`, err);
    const printableArgs = request.args.length > 0 ? ` ${request.args.join(" ")}` : "";
    const cmd = `${request.command}${printableArgs}`;
    const details = `cmd="${cmd}", cwd="${request.cwd}", platform="${process.platform}"`;
    const errMessage = err instanceof Error ? err.message : String(err);
    if (request.logLocalEnv) {
      log.error(`Local PTY spawn config: ${cmd} (cwd: ${request.cwd})`);
      log.error(`process.env.SHELL: ${process.env.SHELL ?? "undefined"}`);
      log.error(`process.env.PATH: ${process.env.PATH ?? process.env.Path ?? "undefined"}`);
    }
    throw new Error(`Failed to spawn ${request.runtimeLabel} terminal (${details}): ${errMessage}`);
  }
}

// src/node/runtime/sshConnectionPool.ts
import * as crypto3 from "crypto";
import * as path11 from "path";
import * as os3 from "os";
import { spawn as spawn3 } from "child_process";
var BACKOFF_SCHEDULE = [1, 2, 4, 7, 10];
function withJitter(seconds) {
  const jitterFactor = 0.8 + Math.random() * 0.4;
  return seconds * jitterFactor;
}
var HEALTHY_TTL_MS = 15 * 1e3;
var DEFAULT_PROBE_TIMEOUT_MS = 1e4;
var DEFAULT_MAX_WAIT_MS = 2 * 60 * 1e3;
async function sleepWithAbort(ms, abortSignal) {
  if (ms <= 0) return;
  if (abortSignal?.aborted) {
    throw new Error("Operation aborted");
  }
  await new Promise((resolve4, reject) => {
    const timer = setTimeout(() => {
      cleanup();
      resolve4();
    }, ms);
    const onAbort = () => {
      cleanup();
      reject(new Error("Operation aborted"));
    };
    const cleanup = () => {
      clearTimeout(timer);
      abortSignal?.removeEventListener("abort", onAbort);
    };
    abortSignal?.addEventListener("abort", onAbort);
  });
}
var SSHConnectionPool = class {
  constructor() {
    this.health = /* @__PURE__ */ new Map();
    this.inflight = /* @__PURE__ */ new Map();
  }
  async acquireConnection(config2, timeoutMsOrOptions = DEFAULT_PROBE_TIMEOUT_MS) {
    const options = typeof timeoutMsOrOptions === "number" ? { timeoutMs: timeoutMsOrOptions } : timeoutMsOrOptions ?? {};
    const timeoutMs = options.timeoutMs ?? DEFAULT_PROBE_TIMEOUT_MS;
    const sleep = options.sleep ?? sleepWithAbort;
    const maxWaitMs = options.maxWaitMs ?? DEFAULT_MAX_WAIT_MS;
    const shouldWait = maxWaitMs > 0;
    const key = makeConnectionKey(config2);
    const startTime = Date.now();
    while (true) {
      if (options.abortSignal?.aborted) {
        throw new Error("Operation aborted");
      }
      const health = this.health.get(key);
      if (health?.backoffUntil && health.backoffUntil > /* @__PURE__ */ new Date()) {
        const remainingMs = health.backoffUntil.getTime() - Date.now();
        const remainingSecs = Math.ceil(remainingMs / 1e3);
        if (!shouldWait) {
          throw new Error(
            `SSH connection to ${config2.host} is in backoff for ${remainingSecs}s. Last error: ${health.lastError ?? "unknown"}`
          );
        }
        const elapsedMs = Date.now() - startTime;
        const budgetMs = Math.max(0, maxWaitMs - elapsedMs);
        if (budgetMs <= 0) {
          throw new Error(
            `SSH connection to ${config2.host} did not become healthy within ${maxWaitMs}ms. Last error: ${health.lastError ?? "unknown"}`
          );
        }
        const waitMs = Math.min(remainingMs, budgetMs);
        options.onWait?.(waitMs);
        await sleep(waitMs, options.abortSignal);
        continue;
      }
      if (health?.status === "healthy") {
        const age = Date.now() - (health.lastSuccess?.getTime() ?? 0);
        if (age < HEALTHY_TTL_MS) {
          log.debug(`SSH connection to ${config2.host} is known healthy, skipping probe`);
          return;
        }
        log.debug(
          `SSH connection to ${config2.host} health is stale (${Math.round(age / 1e3)}s), re-probing`
        );
      }
      const existing = this.inflight.get(key);
      if (existing) {
        log.debug(`SSH connection to ${config2.host} has inflight probe, waiting...`);
        try {
          await existing;
          return;
        } catch (error) {
          if (!shouldWait) {
            throw error;
          }
          continue;
        }
      }
      log.debug(`SSH connection to ${config2.host} needs probe, starting health check`);
      const probe = this.probeConnection(config2, timeoutMs, key);
      this.inflight.set(key, probe);
      try {
        await probe;
        return;
      } catch (error) {
        if (!shouldWait) {
          throw error;
        }
        continue;
      } finally {
        this.inflight.delete(key);
      }
    }
  }
  /**
   * Get current health status for a connection
   */
  getConnectionHealth(config2) {
    const key = makeConnectionKey(config2);
    return this.health.get(key);
  }
  /**
   * Get deterministic controlPath for SSH config.
   */
  getControlPath(config2) {
    return getControlPath(config2);
  }
  /**
   * Reset backoff for a connection (e.g., after user intervention)
   */
  resetBackoff(config2) {
    const key = makeConnectionKey(config2);
    const health = this.health.get(key);
    if (health) {
      health.backoffUntil = void 0;
      health.consecutiveFailures = 0;
      health.status = "unknown";
      log.info(`Reset backoff for SSH connection to ${config2.host}`);
    }
  }
  /**
   * Mark connection as healthy.
   * Call after successful SSH operations to maintain health state.
   */
  markHealthy(config2) {
    const key = makeConnectionKey(config2);
    this.markHealthyByKey(key);
  }
  /**
   * Report a connection failure.
   * Call when SSH operations fail due to connection issues (not command failures).
   * This triggers backoff to prevent thundering herd on a failing host.
   */
  reportFailure(config2, error) {
    const key = makeConnectionKey(config2);
    this.markFailedByKey(key, error);
  }
  /**
   * Mark connection as healthy by key (internal use)
   */
  markHealthyByKey(key) {
    this.health.set(key, {
      status: "healthy",
      lastSuccess: /* @__PURE__ */ new Date(),
      consecutiveFailures: 0
    });
  }
  /**
   * Mark connection as failed (internal use after failed probe)
   */
  markFailedByKey(key, error) {
    const current = this.health.get(key);
    const failures = (current?.consecutiveFailures ?? 0) + 1;
    const backoffIndex = Math.min(failures - 1, BACKOFF_SCHEDULE.length - 1);
    const backoffSecs = withJitter(BACKOFF_SCHEDULE[backoffIndex]);
    this.health.set(key, {
      status: "unhealthy",
      lastFailure: /* @__PURE__ */ new Date(),
      lastError: error,
      backoffUntil: new Date(Date.now() + backoffSecs * 1e3),
      consecutiveFailures: failures
    });
    log.warn(
      `SSH connection failed (${failures} consecutive). Backoff for ${backoffSecs.toFixed(1)}s. Error: ${error}`
    );
  }
  /**
   * Clear all health state. Used in tests to reset between test cases
   * so backoff from one test doesn't affect subsequent tests.
   */
  clearAllHealth() {
    this.health.clear();
    this.inflight.clear();
  }
  /**
   * Probe connection health by running a simple command
   */
  async probeConnection(config2, timeoutMs, key) {
    const controlPath = getControlPath(config2);
    const args2 = ["-T"];
    if (config2.port) {
      args2.push("-p", config2.port.toString());
    }
    if (config2.identityFile) {
      args2.push("-i", config2.identityFile);
      args2.push("-o", "StrictHostKeyChecking=no");
      args2.push("-o", "UserKnownHostsFile=/dev/null");
      args2.push("-o", "LogLevel=ERROR");
    }
    args2.push("-o", "ControlMaster=auto");
    args2.push("-o", `ControlPath=${controlPath}`);
    args2.push("-o", "ControlPersist=60");
    const connectTimeout = Math.min(Math.ceil(timeoutMs / 1e3), 15);
    args2.push("-o", `ConnectTimeout=${connectTimeout}`);
    args2.push("-o", "ServerAliveInterval=5");
    args2.push("-o", "ServerAliveCountMax=2");
    args2.push(config2.host, "echo ok");
    log.debug(`SSH probe: ssh ${args2.join(" ")}`);
    return new Promise((resolve4, reject) => {
      const proc = spawn3("ssh", args2, { stdio: ["ignore", "pipe", "pipe"] });
      let stderr = "";
      proc.stderr.on("data", (data) => {
        stderr += data.toString();
      });
      let timedOut = false;
      const timeout = setTimeout(() => {
        timedOut = true;
        proc.kill("SIGKILL");
        const error = "SSH probe timed out";
        this.markFailedByKey(key, error);
        reject(new Error(error));
      }, timeoutMs);
      proc.on("close", (code) => {
        clearTimeout(timeout);
        if (timedOut) return;
        if (code === 0) {
          this.markHealthyByKey(key);
          log.debug(`SSH probe to ${config2.host} succeeded`);
          resolve4();
        } else {
          const error = stderr.trim() || `SSH probe failed with code ${code ?? "unknown"}`;
          this.markFailedByKey(key, error);
          reject(new Error(error));
        }
      });
      proc.on("error", (err) => {
        clearTimeout(timeout);
        const error = `SSH probe spawn error: ${err.message}`;
        this.markFailedByKey(key, error);
        reject(new Error(error));
      });
    });
  }
};
var sshConnectionPool = new SSHConnectionPool();
function getControlPath(config2) {
  const key = makeConnectionKey(config2);
  const hash2 = hashKey(key);
  return path11.join(os3.tmpdir(), `mux-ssh-${hash2}`);
}
function makeConnectionKey(config2) {
  const parts = [
    os3.userInfo().username,
    // Include local user to prevent cross-user collisions
    config2.host,
    config2.port?.toString() ?? "22",
    config2.identityFile ?? "default"
  ];
  return parts.join(":");
}
function hashKey(key) {
  return crypto3.createHash("sha256").update(key).digest("hex").substring(0, 12);
}

// src/node/runtime/transports/OpenSSHTransport.ts
var OpenSSHTransport = class {
  constructor(config2) {
    this.config = config2;
    this.controlPath = getControlPath(config2);
  }
  isConnectionFailure(exitCode, _stderr) {
    return exitCode === 255;
  }
  getConfig() {
    return this.config;
  }
  markHealthy() {
    sshConnectionPool.markHealthy(this.config);
  }
  reportFailure(error) {
    sshConnectionPool.reportFailure(this.config, error);
  }
  async acquireConnection(options) {
    await sshConnectionPool.acquireConnection(this.config, {
      abortSignal: options?.abortSignal,
      timeoutMs: options?.timeoutMs,
      onWait: options?.onWait
    });
  }
  async spawnRemoteProcess(fullCommand, options) {
    await sshConnectionPool.acquireConnection(this.config, {
      abortSignal: options.abortSignal
    });
    const sshArgs = [options.forcePTY ? "-tt" : "-T", ...this.buildSSHArgs()];
    const connectTimeout = options.timeout !== void 0 ? Math.min(Math.ceil(options.timeout), 15) : 15;
    sshArgs.push("-o", `ConnectTimeout=${connectTimeout}`);
    sshArgs.push("-o", "ServerAliveInterval=5");
    sshArgs.push("-o", "ServerAliveCountMax=2");
    sshArgs.push(this.config.host, fullCommand);
    log.debug(`SSH exec on ${this.config.host}`);
    const process3 = spawn4("ssh", sshArgs, {
      stdio: ["pipe", "pipe", "pipe"],
      windowsHide: true
    });
    return { process: process3 };
  }
  async createPtySession(params) {
    await sshConnectionPool.acquireConnection(this.config, { maxWaitMs: 0 });
    const args2 = [...this.buildSSHArgs()];
    args2.push("-o", "ConnectTimeout=15");
    args2.push("-o", "ServerAliveInterval=5");
    args2.push("-o", "ServerAliveCountMax=2");
    args2.push("-t");
    args2.push(this.config.host);
    const expandedPath = expandTildeForSSH(params.workspacePath);
    args2.push(`cd ${expandedPath} && exec $SHELL -i`);
    return spawnPtyProcess({
      runtimeLabel: "SSH",
      command: "ssh",
      args: args2,
      cwd: process.cwd(),
      cols: params.cols,
      rows: params.rows,
      preferElectronBuild: false
    });
  }
  buildSSHArgs() {
    const args2 = [];
    if (this.config.port) {
      args2.push("-p", this.config.port.toString());
    }
    if (this.config.identityFile) {
      args2.push("-i", this.config.identityFile);
      args2.push("-o", "StrictHostKeyChecking=no");
      args2.push("-o", "UserKnownHostsFile=/dev/null");
    }
    args2.push("-o", "LogLevel=FATAL");
    args2.push("-o", "ControlMaster=auto");
    args2.push("-o", `ControlPath=${this.controlPath}`);
    args2.push("-o", "ControlPersist=60");
    return args2;
  }
};

// src/node/runtime/transports/SSH2Transport.ts
import { EventEmitter } from "events";
import { PassThrough } from "stream";

// src/node/runtime/SSH2ConnectionPool.ts
import * as fs7 from "fs/promises";
import * as os5 from "os";
import * as path13 from "path";
import { spawn as spawn5 } from "child_process";
import { Duplex } from "stream";
import { Client } from "ssh2";

// src/node/runtime/sshConfigParser.ts
var import_ssh_config = __toESM(require_dist2());
import { spawnSync } from "child_process";
import * as fs6 from "fs/promises";
import * as os4 from "os";
import * as path12 from "path";
var DEFAULT_SSH_PORT = 22;
function getHomeDir2() {
  return process.env.USERPROFILE ?? os4.homedir();
}
function getDefaultUsername() {
  try {
    return os4.userInfo().username;
  } catch {
    return process.env.USER ?? process.env.USERNAME ?? "";
  }
}
function expandHomePath(value2, homeDir) {
  if (value2 === "~") {
    return homeDir;
  }
  if (value2.startsWith("~/") || value2.startsWith("~\\")) {
    return path12.join(homeDir, value2.slice(2));
  }
  return value2;
}
function normalizeIdentityFile(value2, homeDir) {
  const expanded = expandHomePath(value2, homeDir);
  if (path12.isAbsolute(expanded)) {
    return expanded;
  }
  return path12.join(homeDir, expanded);
}
function parseHostAndUser(host) {
  const trimmed = host.trim();
  const atIndex = trimmed.lastIndexOf("@");
  if (atIndex > 0) {
    const user = trimmed.slice(0, atIndex).trim();
    const hostname = trimmed.slice(atIndex + 1).trim();
    if (user && hostname) {
      return { host: hostname, user };
    }
  }
  return { host: trimmed };
}
function isParsedValueToken(value2) {
  return typeof value2 === "object" && value2 !== null && "val" in value2 && "separator" in value2;
}
function tokensToString(tokens) {
  return tokens.map(({ val, separator, quoted }) => {
    const rendered = quoted ? `"${val}"` : val;
    return `${separator}${rendered}`;
  }).join("").trimStart();
}
function getConfigValue(config2, key) {
  const match = Object.entries(config2).find(
    ([configKey]) => configKey.toLowerCase() === key.toLowerCase()
  );
  return match?.[1];
}
function toStringValue(value2) {
  if (typeof value2 === "string") {
    return value2;
  }
  if (Array.isArray(value2)) {
    const first = value2[0];
    if (typeof first === "string") {
      return first;
    }
    if (isParsedValueToken(first)) {
      return tokensToString(value2);
    }
  }
  return void 0;
}
function getCriteriaValue(criteria, key) {
  const match = Object.entries(criteria).find(
    ([criteriaKey]) => criteriaKey.toLowerCase() === key.toLowerCase()
  );
  return match?.[1];
}
function criteriaToString(value2) {
  if (typeof value2 === "string") {
    return value2;
  }
  if (Array.isArray(value2)) {
    return value2[0]?.val;
  }
  return void 0;
}
function criteriaToStringArray(value2) {
  if (typeof value2 === "string") {
    return [value2];
  }
  if (Array.isArray(value2)) {
    return value2.map(({ val }) => val);
  }
  return [];
}
function expandMatchExecTokens(command, hostName, user) {
  return command.replace(/%(%|h|r)/g, (_match, token) => {
    switch (token) {
      case "%":
        return "%";
      case "h":
        return hostName;
      case "r":
        return user ?? "";
      default:
        return _match;
    }
  });
}
function applyNegatedExecMatch(config2, hostName, user, computed) {
  if (getConfigValue(computed, "ProxyCommand")) {
    return;
  }
  for (const line of config2) {
    if (line.type !== import_ssh_config.default.DIRECTIVE || line.param !== "Match") {
      continue;
    }
    if (!("criteria" in line)) {
      continue;
    }
    const criteria = line.criteria;
    const hostCriterion = getCriteriaValue(criteria, "host");
    const negatedExec = getCriteriaValue(criteria, "!exec");
    if (!hostCriterion || !negatedExec) {
      continue;
    }
    const hostPatterns = criteriaToStringArray(hostCriterion);
    if (!(0, import_ssh_config.glob)(hostPatterns, hostName)) {
      continue;
    }
    const execCommand = criteriaToString(negatedExec);
    if (!execCommand) {
      continue;
    }
    const expandedCommand = expandMatchExecTokens(execCommand, hostName, user);
    const execResult = spawnSync(expandedCommand, { shell: true });
    if (execResult.status === 0) {
      continue;
    }
    const proxyLine = line.config.find(
      (subline) => subline.type === import_ssh_config.default.DIRECTIVE && subline.param.toLowerCase() === "proxycommand"
    );
    if (proxyLine?.type === import_ssh_config.default.DIRECTIVE) {
      computed.ProxyCommand = proxyLine.value;
      return;
    }
  }
}
function toStringArray(value2) {
  if (typeof value2 === "string") {
    return [value2];
  }
  if (Array.isArray(value2)) {
    const first = value2[0];
    if (typeof first === "string") {
      return value2;
    }
    if (isParsedValueToken(first)) {
      return [tokensToString(value2)];
    }
  }
  return [];
}
async function loadSSHConfig() {
  const homeDir = getHomeDir2();
  const configPath = path12.join(homeDir, ".ssh", "config");
  try {
    const content = await fs6.readFile(configPath, "utf8");
    const parsed = import_ssh_config.default.parse(content);
    return parsed;
  } catch (error) {
    if (error?.code !== "ENOENT") {
      log.debug("Failed to read SSH config", {
        configPath,
        error: error instanceof Error ? error.message : String(error)
      });
    }
    return null;
  }
}
async function resolveSSHConfig(host) {
  const { host: hostAlias, user: userOverride } = parseHostAndUser(host);
  const homeDir = getHomeDir2();
  const config2 = await loadSSHConfig();
  const computed = config2 ? userOverride ? config2.compute({ Host: hostAlias, User: userOverride }) : config2.compute(hostAlias) : {};
  const hostName = toStringValue(getConfigValue(computed, "HostName")) ?? hostAlias;
  const userFromConfig = toStringValue(getConfigValue(computed, "User"));
  if (config2) {
    const matchExecUser = userOverride ?? userFromConfig ?? getDefaultUsername();
    applyNegatedExecMatch(config2, hostName, matchExecUser, computed);
  }
  const portValue = toStringValue(getConfigValue(computed, "Port"));
  const identityValues = toStringArray(getConfigValue(computed, "IdentityFile"));
  const proxyCommandRaw = toStringValue(getConfigValue(computed, "ProxyCommand"));
  const port = portValue ? Number.parseInt(portValue, 10) : DEFAULT_SSH_PORT;
  const identityFiles = identityValues.map((value2) => normalizeIdentityFile(value2, homeDir));
  const proxyCommand = proxyCommandRaw && proxyCommandRaw.toLowerCase() !== "none" ? proxyCommandRaw.trim() : void 0;
  return {
    host: hostAlias,
    hostName,
    user: userOverride ?? userFromConfig,
    port: Number.isFinite(port) ? port : DEFAULT_SSH_PORT,
    identityFiles,
    proxyCommand
  };
}

// src/node/runtime/SSH2ConnectionPool.ts
var BACKOFF_SCHEDULE2 = [1, 2, 4, 7, 10];
var DEFAULT_CONNECT_TIMEOUT_MS = 1e4;
var DEFAULT_MAX_WAIT_MS2 = 2 * 60 * 1e3;
var IDLE_TIMEOUT_MS = 60 * 1e3;
function withJitter2(seconds) {
  const jitterFactor = 0.8 + Math.random() * 0.4;
  return seconds * jitterFactor;
}
async function sleepWithAbort2(ms, abortSignal) {
  if (ms <= 0) return;
  if (abortSignal?.aborted) {
    throw new Error("Operation aborted");
  }
  await new Promise((resolve4, reject) => {
    const timer = setTimeout(() => {
      cleanup();
      resolve4();
    }, ms);
    const onAbort = () => {
      cleanup();
      reject(new Error("Operation aborted"));
    };
    const cleanup = () => {
      clearTimeout(timer);
      abortSignal?.removeEventListener("abort", onAbort);
    };
    abortSignal?.addEventListener("abort", onAbort);
  });
}
function getAgentConfig() {
  if (process.env.SSH_AUTH_SOCK) {
    return process.env.SSH_AUTH_SOCK;
  }
  if (process.platform === "win32") {
    return "pageant";
  }
  return void 0;
}
function getDefaultUsername2() {
  try {
    return os5.userInfo().username;
  } catch {
    return process.env.USER ?? process.env.USERNAME ?? "unknown";
  }
}
var DEFAULT_IDENTITY_FILES = [
  "~/.ssh/id_rsa",
  "~/.ssh/id_ecdsa",
  "~/.ssh/id_ecdsa_sk",
  "~/.ssh/id_ed25519",
  "~/.ssh/id_ed25519_sk",
  "~/.ssh/id_dsa"
];
function expandLocalPath(value2) {
  if (value2 === "~") {
    return os5.homedir();
  }
  if (value2.startsWith("~/") || value2.startsWith("~\\")) {
    return path13.join(os5.homedir(), value2.slice(2));
  }
  if (!path13.isAbsolute(value2)) {
    return path13.join(os5.homedir(), value2);
  }
  return value2;
}
function makeConnectionKey2(config2) {
  const parts = [
    getDefaultUsername2(),
    config2.host,
    config2.port?.toString() ?? "22",
    config2.identityFile ?? "default"
  ];
  return parts.join(":");
}
function sanitizeProxyCommand(command, tokens) {
  return command.replace(/%(%|h|p|r)/g, (match, token) => {
    switch (token) {
      case "%":
        return "%";
      case "h":
        return tokens.host;
      case "p":
        return String(tokens.port);
      case "r":
        return tokens.user;
      default:
        return match;
    }
  });
}
function getProxyShellArgs(command) {
  if (process.platform === "win32") {
    return {
      command: process.env.COMSPEC ?? "cmd.exe",
      args: ["/d", "/s", "/c", command]
    };
  }
  return { command: "/bin/sh", args: ["-c", command] };
}
function spawnProxyCommand(command, tokens) {
  const substituted = sanitizeProxyCommand(command, tokens);
  const { command: shell2, args: args2 } = getProxyShellArgs(substituted);
  const proc = spawn5(shell2, args2, {
    stdio: ["pipe", "pipe", "pipe"],
    windowsHide: true
  });
  proc.stderr?.on("data", () => {
  });
  if (!proc.stdin || !proc.stdout) {
    throw new Error("ProxyCommand did not provide stdio streams");
  }
  const sock = Duplex.from({ writable: proc.stdin, readable: proc.stdout });
  return { sock, process: proc };
}
function isEncryptedKeyError(error) {
  if (!error) {
    return false;
  }
  const message = error instanceof Error ? error.message : typeof error === "string" ? error : "";
  return message.includes("Encrypted private key detected") || message.includes("Encrypted private OpenSSH key detected") || message.includes("Encrypted PPK private key detected") || message.includes("Cannot parse privateKey") && message.includes("ncrypted");
}
function isAuthFailure(error) {
  if (!error) {
    return false;
  }
  if (isEncryptedKeyError(error)) {
    return true;
  }
  if (typeof error === "object" && error !== null && "level" in error) {
    const level = error.level;
    if (level === "client-authentication") {
      return true;
    }
  }
  const message = error instanceof Error ? error.message : typeof error === "string" ? error : "";
  return message.includes("All configured authentication methods failed") || message.includes("Authentication failed") || message.includes("Authentication failure");
}
async function resolvePrivateKeys(identityFiles) {
  const keys = [];
  for (const file of identityFiles) {
    try {
      keys.push(await fs7.readFile(file));
    } catch {
    }
  }
  return keys;
}
var SSH2ConnectionPool = class {
  constructor() {
    this.health = /* @__PURE__ */ new Map();
    this.inflight = /* @__PURE__ */ new Map();
    this.connections = /* @__PURE__ */ new Map();
  }
  async acquireConnection(config2, options = {}) {
    const key = makeConnectionKey2(config2);
    const timeoutMs = options.timeoutMs ?? DEFAULT_CONNECT_TIMEOUT_MS;
    const sleep = options.sleep ?? sleepWithAbort2;
    const maxWaitMs = options.maxWaitMs ?? DEFAULT_MAX_WAIT_MS2;
    const shouldWait = maxWaitMs > 0;
    const startTime = Date.now();
    while (true) {
      if (options.abortSignal?.aborted) {
        throw new Error("Operation aborted");
      }
      const existing = this.connections.get(key);
      if (existing) {
        this.touchConnection(existing, key);
        this.markHealthy(config2);
        return existing;
      }
      const health = this.health.get(key);
      if (health?.backoffUntil && health.backoffUntil > /* @__PURE__ */ new Date()) {
        const remainingMs = health.backoffUntil.getTime() - Date.now();
        const remainingSecs = Math.ceil(remainingMs / 1e3);
        if (!shouldWait) {
          throw new Error(
            `SSH connection to ${config2.host} is in backoff for ${remainingSecs}s. Last error: ${health.lastError ?? "unknown"}`
          );
        }
        const elapsedMs = Date.now() - startTime;
        const budgetMs = Math.max(0, maxWaitMs - elapsedMs);
        if (budgetMs <= 0) {
          throw new Error(
            `SSH connection to ${config2.host} is in backoff and maxWaitMs exceeded. Last error: ${health.lastError ?? "unknown"}`
          );
        }
        const waitMs = Math.min(remainingMs, budgetMs);
        options.onWait?.(waitMs);
        await sleep(waitMs, options.abortSignal);
        continue;
      }
      let inflight = this.inflight.get(key);
      if (!inflight) {
        inflight = this.connect(config2, timeoutMs, options.abortSignal);
        this.inflight.set(key, inflight);
        void inflight.catch(() => {
        }).finally(() => this.inflight.delete(key));
      }
      try {
        const entry = await inflight;
        return entry;
      } catch (error) {
        if (!shouldWait) {
          throw error;
        }
        const elapsedMs = Date.now() - startTime;
        if (elapsedMs >= maxWaitMs) {
          throw error;
        }
      }
    }
  }
  markHealthy(config2) {
    const key = makeConnectionKey2(config2);
    const existing = this.health.get(key);
    this.health.set(key, {
      status: "healthy",
      lastSuccess: /* @__PURE__ */ new Date(),
      consecutiveFailures: 0,
      lastFailure: existing?.lastFailure,
      lastError: existing?.lastError
    });
  }
  reportFailure(config2, errorMessage) {
    const key = makeConnectionKey2(config2);
    const now2 = /* @__PURE__ */ new Date();
    const current = this.health.get(key);
    const failures = (current?.consecutiveFailures ?? 0) + 1;
    const backoffIndex = Math.min(failures - 1, BACKOFF_SCHEDULE2.length - 1);
    const backoffSeconds = withJitter2(BACKOFF_SCHEDULE2[backoffIndex]);
    this.health.set(key, {
      status: "unhealthy",
      lastFailure: now2,
      lastError: errorMessage,
      consecutiveFailures: failures,
      backoffUntil: new Date(Date.now() + backoffSeconds * 1e3),
      lastSuccess: current?.lastSuccess
    });
  }
  /**
   * Clear all health state. Used in tests to reset between test cases
   * so backoff from one test doesn't affect subsequent tests.
   */
  clearAllHealth() {
    this.health.clear();
    this.inflight.clear();
  }
  /**
   * Update last activity time and reset idle timer.
   * Called on each acquireConnection() to keep active connections alive.
   */
  touchConnection(entry, key) {
    entry.lastActivityAt = Date.now();
    if (entry.idleTimer) {
      clearTimeout(entry.idleTimer);
    }
    entry.idleTimer = setTimeout(() => {
      this.closeIdleConnection(key, entry);
    }, IDLE_TIMEOUT_MS);
  }
  /**
   * Close a connection that has been idle for too long.
   */
  closeIdleConnection(key, entry) {
    if (this.connections.get(key) !== entry) {
      return;
    }
    this.connections.delete(key);
    try {
      entry.client.end();
    } catch {
    }
    if (entry.proxyProcess?.exitCode === null) {
      try {
        entry.proxyProcess.kill();
      } catch {
      }
    }
  }
  async connect(config2, timeoutMs, abortSignal) {
    const key = makeConnectionKey2(config2);
    try {
      const resolved = await resolveSSHConfig(config2.host);
      const resolvedConfig = {
        ...resolved,
        port: config2.port ?? resolved.port,
        identityFiles: config2.identityFile ? [expandLocalPath(config2.identityFile)] : resolved.identityFiles
      };
      const agent = getAgentConfig();
      const baseIdentityFiles = resolvedConfig.identityFiles.length > 0 ? resolvedConfig.identityFiles : [];
      const fallbackIdentityFiles = baseIdentityFiles.length > 0 ? baseIdentityFiles : DEFAULT_IDENTITY_FILES.map((file) => expandLocalPath(file));
      const username = resolvedConfig.user ?? getDefaultUsername2();
      const proxyTokens = {
        host: resolvedConfig.hostName,
        port: resolvedConfig.port,
        user: username
      };
      const attemptConnection = async (identityFiles, agentOverride) => {
        const resolvedConfigWithIdentities = {
          ...resolvedConfig,
          identityFiles
        };
        const readableKeys = await resolvePrivateKeys(resolvedConfigWithIdentities.identityFiles);
        const keysToTry = readableKeys.length > 0 ? readableKeys : [void 0];
        const connectWithKey = async (privateKey, reportAuthFailure) => {
          const proxy = resolvedConfigWithIdentities.proxyCommand ? spawnProxyCommand(resolvedConfigWithIdentities.proxyCommand, proxyTokens) : void 0;
          const client = new Client();
          const entry = {
            client,
            resolvedConfig: resolvedConfigWithIdentities,
            proxyProcess: proxy?.process,
            lastActivityAt: Date.now()
          };
          const cleanupProxy = () => {
            if (proxy?.process?.exitCode === null) {
              proxy.process.kill();
            }
          };
          const cleanupProxySocket = () => {
            if (proxy?.sock && !proxy.sock.destroyed) {
              proxy.sock.destroy();
            }
            cleanupProxy();
          };
          if (proxy) {
            const attach = (emitter, label) => {
              attachStreamErrorHandler(emitter, label, {
                logger: log,
                onIgnorable: cleanupProxySocket,
                onUnexpected: cleanupProxySocket
              });
            };
            attach(proxy.process, "ssh2-proxy-process");
            attach(proxy.sock, "ssh2-proxy-socket");
            if (proxy.process.stdin) {
              attach(proxy.process.stdin, "ssh2-proxy-stdin");
            }
            if (proxy.process.stdout) {
              attach(proxy.process.stdout, "ssh2-proxy-stdout");
            }
            if (proxy.process.stderr) {
              attach(proxy.process.stderr, "ssh2-proxy-stderr");
            }
          }
          const onClose = () => {
            if (entry.idleTimer) {
              clearTimeout(entry.idleTimer);
            }
            cleanupProxy();
            this.connections.delete(key);
          };
          client.on("close", onClose);
          client.on("end", onClose);
          client.on("error", (err) => {
            if (entry.idleTimer) {
              clearTimeout(entry.idleTimer);
            }
            if (!isAuthFailure(err) || reportAuthFailure) {
              this.reportFailure(config2, getErrorMessage4(err));
            }
            this.connections.delete(key);
            cleanupProxy();
          });
          await new Promise((resolve4, reject) => {
            const onReady = () => {
              cleanup();
              resolve4();
            };
            const onError2 = (err) => {
              cleanup();
              reject(err);
            };
            const onAbort = () => {
              cleanup();
              client.end();
              cleanupProxy();
              reject(new Error("Operation aborted"));
            };
            const cleanup = () => {
              client.off("ready", onReady);
              client.off("error", onError2);
              abortSignal?.removeEventListener("abort", onAbort);
            };
            client.on("ready", onReady);
            client.on("error", onError2);
            abortSignal?.addEventListener("abort", onAbort, { once: true });
            const connectOptions = {
              host: resolvedConfig.hostName,
              port: resolvedConfig.port,
              username,
              agent: agentOverride,
              sock: proxy?.sock,
              readyTimeout: timeoutMs,
              keepaliveInterval: 5e3,
              keepaliveCountMax: 2,
              ...privateKey ? { privateKey } : {}
            };
            client.connect(connectOptions);
          });
          if (abortSignal?.aborted) {
            client.end();
            throw new Error("Operation aborted");
          }
          this.markHealthy(config2);
          this.connections.set(key, entry);
          entry.idleTimer = setTimeout(() => {
            this.closeIdleConnection(key, entry);
          }, IDLE_TIMEOUT_MS);
          return entry;
        };
        for (const [index, privateKey] of keysToTry.entries()) {
          const isLastKey = index === keysToTry.length - 1;
          try {
            return await connectWithKey(privateKey, isLastKey);
          } catch (error) {
            if (!isAuthFailure(error) || isLastKey) {
              throw error;
            }
          }
        }
        throw new Error("SSH2 authentication failed");
      };
      const shouldTryAgentOnly = agent && baseIdentityFiles.length === 0;
      if (shouldTryAgentOnly) {
        try {
          return await attemptConnection([], agent);
        } catch (error) {
          if (!isAuthFailure(error)) {
            throw error;
          }
        }
      }
      const agentForFallback = shouldTryAgentOnly ? void 0 : agent;
      return await attemptConnection(fallbackIdentityFiles, agentForFallback);
    } catch (error) {
      this.reportFailure(config2, getErrorMessage4(error));
      throw error;
    }
  }
};
var ssh2ConnectionPool = new SSH2ConnectionPool();

// src/node/runtime/transports/SSH2Transport.ts
var SSH2ChildProcess = class extends EventEmitter {
  constructor(channel) {
    super();
    this.channel = channel;
    this.exitCode = null;
    this.signalCode = null;
    this.killed = false;
    this.pid = 0;
    const stdoutPipe = new PassThrough();
    const stderrPipe = new PassThrough();
    const stdinPipe = new PassThrough();
    channel.pipe(stdoutPipe);
    (channel.stderr ?? new PassThrough()).pipe(stderrPipe);
    stdinPipe.pipe(channel);
    this.stdout = stdoutPipe;
    this.stderr = stderrPipe;
    this.stdin = stdinPipe;
    let closeEventFired = false;
    let closeTimer = null;
    let closeEmitted = false;
    const emitClose = () => {
      if (closeEmitted) {
        return;
      }
      closeEmitted = true;
      if (closeTimer) {
        clearTimeout(closeTimer);
        closeTimer = null;
      }
      this.emit("close", this.exitCode ?? 0, this.signalCode);
    };
    channel.on("exit", (code, signal) => {
      this.exitCode = typeof code === "number" ? code : null;
      this.signalCode = typeof signal === "string" ? signal : null;
      if (closeEventFired) {
        emitClose();
      }
    });
    channel.on("close", (...args2) => {
      closeEventFired = true;
      const [code, signal] = args2;
      if (this.exitCode === null && typeof code === "number") {
        this.exitCode = code;
      }
      if (this.signalCode === null && typeof signal === "string") {
        this.signalCode = signal;
      }
      if (this.exitCode !== null || this.signalCode !== null) {
        emitClose();
        return;
      }
      closeTimer = setTimeout(() => emitClose(), 250);
      closeTimer.unref?.();
    });
    channel.on("error", (err) => {
      this.emit("error", err);
    });
  }
  kill(signal) {
    this.killed = true;
    try {
      if (signal && typeof this.channel.signal === "function") {
        this.channel.signal(signal);
      }
    } catch {
    }
    try {
      this.channel.close();
    } catch {
    }
    return true;
  }
};
var SSH2Pty = class {
  constructor(channel) {
    this.channel = channel;
    this.closed = false;
    this.channel.on("close", () => {
      this.closed = true;
    });
    const closeChannel = () => {
      this.closed = true;
      try {
        this.channel.close();
      } catch {
      }
    };
    attachStreamErrorHandler(this.channel, "ssh2-pty-channel", {
      logger: log,
      onIgnorable: closeChannel,
      onUnexpected: closeChannel
    });
    if (this.channel.stderr) {
      attachStreamErrorHandler(this.channel.stderr, "ssh2-pty-stderr", {
        logger: log,
        onIgnorable: closeChannel,
        onUnexpected: closeChannel
      });
    }
  }
  write(data) {
    if (this.closed || this.channel.destroyed || this.channel.writableEnded) {
      return;
    }
    try {
      this.channel.write(data);
    } catch (error) {
      if (isIgnorableStreamError(error)) {
        return;
      }
      const message = error instanceof Error ? error.message : String(error);
      const code = error && typeof error === "object" && "code" in error && typeof error.code === "string" ? error.code : void 0;
      log.warn("SSH2 PTY write failed", { code, message });
    }
  }
  resize(cols, rows) {
    this.channel.setWindow(rows, cols, 0, 0);
  }
  kill() {
    this.closed = true;
    this.channel.close();
  }
  onData(handler) {
    const onStdout = (data) => handler(data.toString());
    const onStderr = (data) => handler(data.toString());
    this.channel.on("data", onStdout);
    this.channel.stderr?.on("data", onStderr);
    return {
      dispose: () => {
        this.channel.off("data", onStdout);
        this.channel.stderr?.off("data", onStderr);
      }
    };
  }
  onExit(handler) {
    const onClose = (code) => {
      handler({ exitCode: typeof code === "number" ? code : 0 });
    };
    this.channel.on("close", onClose);
    return {
      dispose: () => {
        this.channel.off("close", onClose);
      }
    };
  }
};
var SSH2Transport = class {
  constructor(config2) {
    this.config = config2;
  }
  isConnectionFailure(_exitCode, _stderr) {
    return false;
  }
  getConfig() {
    return this.config;
  }
  markHealthy() {
    ssh2ConnectionPool.markHealthy(this.config);
  }
  reportFailure(error) {
    ssh2ConnectionPool.reportFailure(this.config, error);
  }
  async acquireConnection(options) {
    await ssh2ConnectionPool.acquireConnection(this.config, {
      abortSignal: options?.abortSignal,
      timeoutMs: options?.timeoutMs,
      onWait: options?.onWait
    });
  }
  async spawnRemoteProcess(fullCommand, options) {
    const connectTimeoutSec = options.timeout !== void 0 ? Math.min(Math.ceil(options.timeout), 15) : 15;
    let client;
    try {
      ({ client } = await ssh2ConnectionPool.acquireConnection(this.config, {
        abortSignal: options.abortSignal,
        timeoutMs: connectTimeoutSec * 1e3
      }));
    } catch (error) {
      throw new RuntimeError(
        `SSH2 connection failed: ${getErrorMessage4(error)}`,
        "network",
        error instanceof Error ? error : void 0
      );
    }
    try {
      const channel = await new Promise((resolve4, reject) => {
        const onExec = (err, stream) => {
          if (err) {
            reject(err);
            return;
          }
          if (!stream) {
            reject(new Error("SSH2 exec did not return a stream"));
            return;
          }
          resolve4(stream);
        };
        if (options.forcePTY) {
          client.exec(fullCommand, { pty: { term: "xterm-256color" } }, onExec);
        } else {
          client.exec(fullCommand, onExec);
        }
      });
      const process3 = new SSH2ChildProcess(channel);
      return { process: process3 };
    } catch (error) {
      ssh2ConnectionPool.reportFailure(this.config, getErrorMessage4(error));
      throw new RuntimeError(
        `SSH2 command failed: ${getErrorMessage4(error)}`,
        "network",
        error instanceof Error ? error : void 0
      );
    }
  }
  async createPtySession(params) {
    const { client } = await ssh2ConnectionPool.acquireConnection(this.config, { maxWaitMs: 0 });
    const channel = await new Promise((resolve4, reject) => {
      client.shell(
        {
          term: "xterm-256color",
          cols: params.cols,
          rows: params.rows
        },
        (err, stream) => {
          if (err) {
            reject(err);
            return;
          }
          if (!stream) {
            reject(new Error("SSH2 shell did not return a stream"));
            return;
          }
          resolve4(stream);
        }
      );
    });
    const expandedPath = expandTildeForSSH(params.workspacePath);
    channel.write(`cd ${expandedPath} || exit 1
`);
    return new SSH2Pty(channel);
  }
};

// src/node/runtime/transports/index.ts
function createSSHTransport(config2, useSSH2) {
  return useSSH2 ? new SSH2Transport(config2) : new OpenSSHTransport(config2);
}

// src/node/runtime/DockerRuntime.ts
import { spawn as spawn6, exec as exec2 } from "child_process";
import { createHash as createHash2 } from "crypto";
import * as path15 from "path";
import * as fs8 from "fs/promises";
import * as os7 from "os";

// src/node/runtime/credentialForwarding.ts
import { existsSync as existsSync3 } from "fs";
import * as fsPromises4 from "fs/promises";
import * as os6 from "os";
import * as path14 from "path";
function resolveSshAgentForwarding(targetSocketPath) {
  const hostSocketPath = process.platform === "darwin" ? "/run/host-services/ssh-auth.sock" : process.env.SSH_AUTH_SOCK;
  if (!hostSocketPath || !existsSync3(hostSocketPath)) {
    return null;
  }
  return { hostSocketPath, targetSocketPath };
}
function resolveGhToken(env3) {
  return env3?.GH_TOKEN ?? process.env.GH_TOKEN ?? null;
}
function getHostGitconfigPath() {
  return path14.join(os6.homedir(), ".gitconfig");
}
function hasHostGitconfig() {
  return existsSync3(getHostGitconfigPath());
}
async function readHostGitconfig() {
  const gitconfigPath = getHostGitconfigPath();
  if (!existsSync3(gitconfigPath)) {
    return null;
  }
  return fsPromises4.readFile(gitconfigPath);
}

// src/node/runtime/DockerRuntime.ts
var CONTAINER_SRC_DIR = "/src";
function runDockerCommand(command, timeoutMs = 3e4) {
  return new Promise((resolve4) => {
    let stdout = "";
    let stderr = "";
    let timedOut = false;
    const child = exec2(command);
    const timer = setTimeout(() => {
      timedOut = true;
      child.kill();
      resolve4({ exitCode: -1, stdout, stderr: "Command timed out" });
    }, timeoutMs);
    child.stdout?.on("data", (data) => {
      stdout += data.toString();
    });
    child.stderr?.on("data", (data) => {
      stderr += data.toString();
    });
    child.on("close", (code) => {
      clearTimeout(timer);
      if (timedOut) return;
      resolve4({ exitCode: code ?? -1, stdout, stderr });
    });
    child.on("error", (err) => {
      clearTimeout(timer);
      if (timedOut) return;
      resolve4({ exitCode: -1, stdout, stderr: err.message });
    });
  });
}
function runSpawnCommand(command, args2, timeoutMs = 3e4) {
  return new Promise((resolve4) => {
    let stdout = "";
    let stderr = "";
    let timedOut = false;
    const child = spawn6(command, args2);
    const timer = setTimeout(() => {
      timedOut = true;
      child.kill();
      resolve4({ exitCode: -1, stdout, stderr: "Command timed out" });
    }, timeoutMs);
    child.stdout?.on("data", (data) => {
      stdout += data.toString();
    });
    child.stderr?.on("data", (data) => {
      stderr += data.toString();
    });
    child.on("close", (code) => {
      clearTimeout(timer);
      if (timedOut) return;
      resolve4({ exitCode: code ?? -1, stdout, stderr });
    });
    child.on("error", (err) => {
      clearTimeout(timer);
      if (timedOut) return;
      resolve4({ exitCode: -1, stdout, stderr: err.message });
    });
  });
}
function buildCredentialArgs() {
  const args2 = [];
  const sshForwarding = resolveSshAgentForwarding("/ssh-agent");
  if (sshForwarding) {
    args2.push("-v", `${sshForwarding.hostSocketPath}:${sshForwarding.targetSocketPath}:ro`);
    args2.push("-e", `SSH_AUTH_SOCK=${sshForwarding.targetSocketPath}`);
  }
  const ghToken = resolveGhToken();
  if (ghToken) {
    args2.push("-e", `GH_TOKEN=${ghToken}`);
  }
  return args2;
}
function streamDockerRun(containerName, image, initLogger, options) {
  const { abortSignal, shareCredentials, timeoutMs = 6e5 } = options ?? {};
  return new Promise((resolve4) => {
    let stdout = "";
    let stderr = "";
    let resolved = false;
    const finish = (result) => {
      if (resolved) return;
      resolved = true;
      clearTimeout(timer);
      abortSignal?.removeEventListener("abort", abortHandler);
      resolve4(result);
    };
    const dockerArgs = ["run", "-d", "--name", containerName];
    if (shareCredentials) {
      dockerArgs.push(...buildCredentialArgs());
    }
    dockerArgs.push(image, "sleep", "infinity");
    const child = spawn6("docker", dockerArgs);
    const timer = setTimeout(() => {
      child.kill();
      void runDockerCommand(`docker rm -f ${containerName}`, 1e4);
      finish({ exitCode: -1, stdout, stderr: "Container creation timed out" });
    }, timeoutMs);
    const abortHandler = () => {
      child.kill();
      void runDockerCommand(`docker rm -f ${containerName}`, 1e4);
      finish({ exitCode: -1, stdout, stderr: "Aborted" });
    };
    abortSignal?.addEventListener("abort", abortHandler);
    child.stdout?.on("data", (data) => {
      const text2 = data.toString();
      stdout += text2;
    });
    child.stderr?.on("data", (data) => {
      const text2 = data.toString();
      stderr += text2;
      for (const line of text2.split("\n").filter((l) => l.trim())) {
        initLogger.logStdout(line);
      }
    });
    child.on("close", (code) => {
      finish({ exitCode: code ?? -1, stdout, stderr });
    });
    child.on("error", (err) => {
      finish({ exitCode: -1, stdout, stderr: err.message });
    });
  });
}
function sanitizeContainerName(name25) {
  return name25.replace(/[^a-zA-Z0-9_.-]/g, "-").replace(/^[^a-zA-Z0-9]+/, "").replace(/-+/g, "-");
}
function getContainerName(projectPath, workspaceName) {
  const projectName = getProjectName(projectPath);
  const hash2 = createHash2("sha256").update(`${projectPath}:${workspaceName}`).digest("hex").slice(0, 6);
  const base = sanitizeContainerName(`mux-${projectName}-${workspaceName}`).slice(0, 56);
  return `${base}-${hash2}`;
}
var DockerRuntime = class extends RemoteRuntime {
  constructor(config2) {
    super();
    // ===== RemoteRuntime abstract method implementations =====
    this.commandPrefix = "Docker";
    this.config = config2;
    if (config2.containerName) {
      this.containerName = config2.containerName;
    }
  }
  /**
   * Get the container name (if set)
   */
  getContainerName() {
    return this.containerName;
  }
  /**
   * Get Docker image name
   */
  getImage() {
    return this.config.image;
  }
  getBasePath() {
    return CONTAINER_SRC_DIR;
  }
  quoteForRemote(filePath) {
    const home = this.containerHome ?? "/root";
    const expanded = filePath.startsWith("~/") ? `${home}/${filePath.slice(2)}` : filePath === "~" ? home : filePath;
    return shescape.quote(expanded);
  }
  cdCommand(cwd) {
    return `cd ${shescape.quote(cwd)}`;
  }
  spawnRemoteProcess(fullCommand, _options) {
    if (!this.containerName) {
      throw new RuntimeError(
        "Docker runtime not initialized with container name. For existing workspaces, pass containerName in config. For new workspaces, call createWorkspace first.",
        "exec"
      );
    }
    const dockerArgs = ["exec", "-i", this.containerName, "bash", "-c", fullCommand];
    const process3 = spawn6("docker", dockerArgs, {
      stdio: ["pipe", "pipe", "pipe"],
      windowsHide: true
    });
    return Promise.resolve({ process: process3 });
  }
  /**
   * Override buildWriteCommand to preserve symlinks and file permissions.
   *
   * This matches SSHRuntime behavior: write through the symlink to the final target,
   * while keeping the symlink itself intact.
   */
  buildWriteCommand(quotedPath, quotedTempPath) {
    return `RESOLVED=$(readlink -f ${quotedPath} 2>/dev/null || echo ${quotedPath}) && PERMS=$(stat -c '%a' "$RESOLVED" 2>/dev/null || echo 644) && mkdir -p $(dirname "$RESOLVED") && cat > ${quotedTempPath} && chmod "$PERMS" ${quotedTempPath} && mv ${quotedTempPath} "$RESOLVED"`;
  }
  // ===== Runtime interface implementations =====
  resolvePath(filePath) {
    const home = this.containerHome ?? "/root";
    if (filePath === "~") {
      return Promise.resolve(home);
    }
    if (filePath.startsWith("~/")) {
      return Promise.resolve(path15.posix.join(home, filePath.slice(2)));
    }
    return Promise.resolve(
      filePath.startsWith("/") ? filePath : path15.posix.join(CONTAINER_SRC_DIR, filePath)
    );
  }
  getWorkspacePath(_projectPath, _workspaceName) {
    return CONTAINER_SRC_DIR;
  }
  async createWorkspace(params) {
    const { projectPath, branchName } = params;
    const containerName = getContainerName(projectPath, branchName);
    const checkResult = await runDockerCommand(`docker inspect ${containerName}`, 1e4);
    if (checkResult.exitCode === 0) {
      return {
        success: false,
        error: `Workspace already exists: container ${containerName}`
      };
    }
    if (!checkResult.stderr.toLowerCase().includes("no such object")) {
      return {
        success: false,
        error: `Docker error: ${checkResult.stderr || checkResult.stdout || "unknown error"}`
      };
    }
    this.containerName = containerName;
    return {
      success: true,
      workspacePath: CONTAINER_SRC_DIR
    };
  }
  /**
   * Post-create setup: provision container OR detect fork and setup credentials.
   * Runs after mux persists workspace metadata so build logs stream to UI in real-time.
   *
   * Handles ALL environment setup:
   * - Fresh workspace: provisions container (create, sync, checkout, credentials)
   * - Fork: detects existing container, logs "from fork", sets up credentials
   * - Stale container: removes and re-provisions
   *
   * After this completes, the container is ready for initWorkspace() to run the hook.
   */
  async postCreateSetup(params) {
    const {
      projectPath,
      branchName,
      trunkBranch,
      workspacePath,
      initLogger,
      abortSignal,
      env: env3,
      skipInitHook
    } = params;
    if (!this.containerName) {
      throw new Error("Container not initialized. Call createWorkspace first.");
    }
    const containerName = this.containerName;
    const containerCheck = await this.checkExistingContainer(
      containerName,
      workspacePath,
      branchName
    );
    switch (containerCheck.action) {
      case "skip":
        initLogger.logStep(
          skipInitHook ? "Container already running (from fork), skipping init hook..." : "Container already running (from fork), running init hook..."
        );
        await this.setupCredentials(containerName, env3);
        return;
      case "cleanup":
        initLogger.logStep(containerCheck.reason);
        await runDockerCommand(`docker rm -f ${containerName}`, 1e4);
        break;
      case "create":
        break;
    }
    await this.provisionContainer({
      containerName,
      projectPath,
      workspacePath,
      branchName,
      trunkBranch,
      initLogger,
      abortSignal,
      env: env3
    });
  }
  /**
   * Initialize workspace by running .mux/init hook.
   * Assumes postCreateSetup() has already been called to provision/prepare the container.
   *
   * This method ONLY runs the hook - all container provisioning and credential setup
   * is handled by postCreateSetup().
   */
  async initWorkspace(params) {
    const { projectPath, branchName, workspacePath, initLogger, abortSignal, env: env3, skipInitHook } = params;
    try {
      if (!this.containerName) {
        return {
          success: false,
          error: "Container not initialized. Call createWorkspace first."
        };
      }
      if (skipInitHook) {
        initLogger.logStep("Skipping .mux/init hook (disabled for this task)");
        initLogger.logComplete(0);
        return { success: true };
      }
      const hookExists = await checkInitHookExists(projectPath);
      if (hookExists) {
        initLogger.enterHookPhase?.();
        const muxEnv = { ...env3, ...getMuxEnv(projectPath, "docker", branchName) };
        const hookPath = `${workspacePath}/.mux/init`;
        await runInitHookOnRuntime(this, hookPath, workspacePath, muxEnv, initLogger, abortSignal);
      } else {
        initLogger.logComplete(0);
      }
      return { success: true };
    } catch (error) {
      const errorMsg = getErrorMessage4(error);
      initLogger.logStderr(`Initialization failed: ${errorMsg}`);
      initLogger.logComplete(-1);
      return {
        success: false,
        error: errorMsg
      };
    }
  }
  /**
   * Check if a container already exists and whether it's valid for reuse.
   * Returns action to take: skip setup, cleanup invalid container, or create new.
   */
  async checkExistingContainer(containerName, workspacePath, branchName) {
    const exists = await runDockerCommand(`docker inspect ${containerName}`, 1e4);
    if (exists.exitCode !== 0) return { action: "create" };
    const isRunning = await runDockerCommand(
      `docker inspect -f '{{.State.Running}}' ${containerName}`,
      1e4
    );
    if (isRunning.exitCode !== 0 || isRunning.stdout.trim() !== "true") {
      return { action: "cleanup", reason: "Removing stale container from previous attempt..." };
    }
    const gitCheck = await runDockerCommand(
      `docker exec ${containerName} test -d ${workspacePath}/.git`,
      5e3
    );
    if (gitCheck.exitCode !== 0) {
      return {
        action: "cleanup",
        reason: "Container exists but repo not initialized, recreating..."
      };
    }
    const branchCheck = await runDockerCommand(
      `docker exec ${containerName} git -C ${workspacePath} rev-parse --abbrev-ref HEAD`,
      5e3
    );
    if (branchCheck.exitCode !== 0 || branchCheck.stdout.trim() !== branchName) {
      return { action: "cleanup", reason: "Container exists but wrong branch, recreating..." };
    }
    return { action: "skip" };
  }
  /**
   * Copy gitconfig and configure gh CLI credential helper in container.
   * Called for both new containers and reused forked containers.
   */
  async setupCredentials(containerName, env3) {
    if (!this.config.shareCredentials) return;
    if (hasHostGitconfig()) {
      await runDockerCommand(
        `docker cp ${getHostGitconfigPath()} ${containerName}:/root/.gitconfig`,
        1e4
      );
    }
    const ghToken = resolveGhToken(env3);
    if (ghToken) {
      await runDockerCommand(
        `docker exec -e GH_TOKEN=${shescape.quote(ghToken)} ${containerName} sh -c 'command -v gh >/dev/null && gh auth setup-git || true'`,
        1e4
      );
    }
  }
  /**
   * Provision container: create, sync project, checkout branch.
   * Throws on error (does not call logComplete - caller handles that).
   * Used by postCreateSetup() for streaming logs before initWorkspace().
   */
  async provisionContainer(params) {
    const {
      containerName,
      projectPath,
      workspacePath,
      branchName,
      trunkBranch,
      initLogger,
      abortSignal,
      env: env3
    } = params;
    initLogger.logStep(`Creating container from ${this.config.image}...`);
    if (abortSignal?.aborted) {
      throw new Error("Workspace creation aborted");
    }
    const runResult = await streamDockerRun(containerName, this.config.image, initLogger, {
      abortSignal,
      shareCredentials: this.config.shareCredentials
    });
    if (runResult.exitCode !== 0) {
      await runDockerCommand(`docker rm -f ${containerName}`, 1e4);
      throw new Error(`Failed to create container: ${runResult.stderr}`);
    }
    const [uidResult, gidResult, homeResult] = await Promise.all([
      runDockerCommand(`docker exec ${containerName} id -u`, 5e3),
      runDockerCommand(`docker exec ${containerName} id -g`, 5e3),
      runDockerCommand(`docker exec ${containerName} sh -c 'echo $HOME'`, 5e3)
    ]);
    this.containerUid = uidResult.stdout.trim() || "0";
    this.containerGid = gidResult.stdout.trim() || "0";
    this.containerHome = homeResult.stdout.trim() || "/root";
    initLogger.logStep("Preparing workspace directory...");
    const mkdirResult = await runDockerCommand(
      `docker exec --user root ${containerName} sh -c 'mkdir -p ${CONTAINER_SRC_DIR} /var/mux/plans && chown ${this.containerUid}:${this.containerGid} ${CONTAINER_SRC_DIR} /var/mux /var/mux/plans'`,
      1e4
    );
    if (mkdirResult.exitCode !== 0) {
      await runDockerCommand(`docker rm -f ${containerName}`, 1e4);
      throw new Error(`Failed to create workspace directory: ${mkdirResult.stderr}`);
    }
    initLogger.logStep("Container ready");
    await this.setupCredentials(containerName, env3);
    initLogger.logStep("Syncing project files to container...");
    try {
      await this.syncProjectToContainer(
        projectPath,
        containerName,
        workspacePath,
        initLogger,
        abortSignal
      );
    } catch (error) {
      await runDockerCommand(`docker rm -f ${containerName}`, 1e4);
      throw new Error(`Failed to sync project: ${getErrorMessage4(error)}`);
    }
    initLogger.logStep("Files synced successfully");
    initLogger.logStep(`Checking out branch: ${branchName}`);
    const checkoutCmd = `git checkout ${shescape.quote(branchName)} 2>/dev/null || git checkout -b ${shescape.quote(branchName)} ${shescape.quote(trunkBranch)}`;
    const checkoutStream = await this.exec(checkoutCmd, {
      cwd: workspacePath,
      timeout: 300,
      abortSignal
    });
    const [stdout, stderr, exitCode] = await Promise.all([
      streamToString2(checkoutStream.stdout),
      streamToString2(checkoutStream.stderr),
      checkoutStream.exitCode
    ]);
    if (exitCode !== 0) {
      await runDockerCommand(`docker rm -f ${containerName}`, 1e4);
      throw new Error(`Failed to checkout branch: ${stderr || stdout}`);
    }
    initLogger.logStep("Branch checked out successfully");
  }
  async syncProjectToContainer(projectPath, containerName, workspacePath, initLogger, abortSignal) {
    const timestamp = Date.now();
    const bundleFilename = `mux-bundle-${timestamp}.bundle`;
    const remoteBundlePath = `/tmp/${bundleFilename}`;
    const localBundlePath = path15.join(os7.tmpdir(), bundleFilename);
    await syncProjectViaGitBundle({
      projectPath,
      workspacePath,
      remoteTmpDir: "/tmp",
      remoteBundlePath,
      exec: (command, options) => this.exec(command, options),
      quoteRemotePath: (path24) => this.quoteForRemote(path24),
      initLogger,
      abortSignal,
      cloneStep: "Cloning repository in container...",
      createRemoteBundle: async ({ remoteBundlePath: remoteBundlePath2, initLogger: initLogger2, abortSignal: abortSignal2 }) => {
        try {
          if (abortSignal2?.aborted) {
            throw new Error("Sync operation aborted before starting");
          }
          const bundleResult = await runDockerCommand(
            `git -C "${projectPath}" bundle create "${localBundlePath}" --all`,
            3e5
          );
          if (bundleResult.exitCode !== 0) {
            throw new Error(`Failed to create bundle: ${bundleResult.stderr}`);
          }
          initLogger2.logStep("Copying bundle to container...");
          const copyResult = await runDockerCommand(
            `docker cp "${localBundlePath}" ${containerName}:${remoteBundlePath2}`,
            3e5
          );
          if (copyResult.exitCode !== 0) {
            throw new Error(`Failed to copy bundle: ${copyResult.stderr}`);
          }
          return {
            cleanupLocal: async () => {
              await runDockerCommand(`rm -f "${localBundlePath}"`, 5e3);
            }
          };
        } catch (error) {
          await runDockerCommand(`rm -f "${localBundlePath}"`, 5e3);
          throw error;
        }
      }
    });
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async renameWorkspace(_projectPath, _oldName, _newName, _abortSignal) {
    return {
      success: false,
      error: "Renaming Docker workspaces is not supported. Create a new workspace and delete the old one."
    };
  }
  async deleteWorkspace(projectPath, workspaceName, force, abortSignal) {
    if (abortSignal?.aborted) {
      return { success: false, error: "Delete operation aborted" };
    }
    const containerName = getContainerName(projectPath, workspaceName);
    const deletedPath = CONTAINER_SRC_DIR;
    try {
      const inspectResult = await runDockerCommand(`docker inspect ${containerName}`, 1e4);
      if (inspectResult.exitCode !== 0) {
        if (inspectResult.stderr.toLowerCase().includes("no such object")) {
          return { success: true, deletedPath };
        }
        return {
          success: false,
          error: `Docker error: ${inspectResult.stderr || inspectResult.stdout || "unknown error"}`
        };
      }
      if (!force) {
        const wasRunning = await runDockerCommand(
          `docker inspect -f '{{.State.Running}}' ${containerName}`,
          1e4
        );
        const containerWasRunning = wasRunning.exitCode === 0 && wasRunning.stdout.trim() === "true";
        const startResult = await runDockerCommand(`docker start ${containerName}`, 3e4);
        if (startResult.exitCode !== 0) {
        } else {
          const stopIfWeStartedIt = async () => {
            if (!containerWasRunning) {
              await runDockerCommand(`docker stop ${containerName}`, 1e4);
            }
          };
          const checkResult = await runDockerCommand(
            `docker exec ${containerName} bash -c 'cd ${CONTAINER_SRC_DIR} && git diff --quiet --exit-code && git diff --quiet --cached --exit-code'`,
            1e4
          );
          if (checkResult.exitCode !== 0) {
            await stopIfWeStartedIt();
            return {
              success: false,
              error: "Workspace contains uncommitted changes. Use force flag to delete anyway."
            };
          }
          const hasRemotes = await runDockerCommand(
            `docker exec ${containerName} bash -c 'cd ${CONTAINER_SRC_DIR} && git remote | grep -q .'`,
            1e4
          );
          if (hasRemotes.exitCode === 0) {
            const unpushedResult = await runDockerCommand(
              `docker exec ${containerName} bash -c 'cd ${CONTAINER_SRC_DIR} && git log --branches --not --remotes --oneline'`,
              1e4
            );
            if (unpushedResult.exitCode === 0 && unpushedResult.stdout.trim()) {
              await stopIfWeStartedIt();
              return {
                success: false,
                error: `Workspace contains unpushed commits:

${unpushedResult.stdout.trim()}`
              };
            }
          }
        }
      }
      const rmResult = await runDockerCommand(`docker rm -f ${containerName}`, 3e4);
      if (rmResult.exitCode !== 0) {
        return {
          success: false,
          error: `Failed to remove container: ${rmResult.stderr}`
        };
      }
      return { success: true, deletedPath };
    } catch (error) {
      return { success: false, error: `Failed to delete workspace: ${getErrorMessage4(error)}` };
    }
  }
  async forkWorkspace(params) {
    const { projectPath, sourceWorkspaceName, newWorkspaceName, initLogger } = params;
    const srcContainerName = getContainerName(projectPath, sourceWorkspaceName);
    const destContainerName = getContainerName(projectPath, newWorkspaceName);
    const hostTempPath = path15.join(os7.tmpdir(), `mux-fork-${Date.now()}.bundle`);
    const containerBundlePath = "/tmp/fork.bundle";
    let destContainerCreated = false;
    let forkSucceeded = false;
    try {
      const srcCheck = await runDockerCommand(`docker inspect ${srcContainerName}`, 1e4);
      if (srcCheck.exitCode !== 0) {
        return {
          success: false,
          error: `Source workspace container not found: ${srcContainerName}`
        };
      }
      initLogger.logStep("Detecting source workspace branch...");
      const branchResult = await runDockerCommand(
        `docker exec ${srcContainerName} git -C ${CONTAINER_SRC_DIR} branch --show-current`,
        3e4
      );
      const sourceBranch = branchResult.stdout.trim();
      if (branchResult.exitCode !== 0 || sourceBranch.length === 0) {
        return {
          success: false,
          error: "Failed to detect branch in source workspace (detached HEAD?)"
        };
      }
      initLogger.logStep("Creating git bundle from source...");
      const bundleResult = await runDockerCommand(
        `docker exec ${srcContainerName} git -C ${CONTAINER_SRC_DIR} bundle create ${containerBundlePath} --all`,
        3e5
      );
      if (bundleResult.exitCode !== 0) {
        return { success: false, error: `Failed to create git bundle: ${bundleResult.stderr}` };
      }
      initLogger.logStep("Copying bundle from source container...");
      const cpOutResult = await runDockerCommand(
        `docker cp ${srcContainerName}:${containerBundlePath} ${shescape.quote(hostTempPath)}`,
        3e5
      );
      if (cpOutResult.exitCode !== 0) {
        return {
          success: false,
          error: `Failed to copy bundle from source: ${cpOutResult.stderr}`
        };
      }
      initLogger.logStep(`Creating container: ${destContainerName}...`);
      const dockerArgs = ["run", "-d", "--name", destContainerName];
      if (this.config.shareCredentials) {
        dockerArgs.push(...buildCredentialArgs());
      }
      dockerArgs.push(this.config.image, "sleep", "infinity");
      const runResult = await runSpawnCommand("docker", dockerArgs, 6e4);
      if (runResult.exitCode !== 0) {
        if (runResult.stderr.includes("already in use")) {
          return {
            success: false,
            error: `Workspace already exists: container ${destContainerName}`
          };
        }
        return { success: false, error: `Failed to create container: ${runResult.stderr}` };
      }
      destContainerCreated = true;
      const [uidResult, gidResult, homeResult] = await Promise.all([
        runDockerCommand(`docker exec ${destContainerName} id -u`, 5e3),
        runDockerCommand(`docker exec ${destContainerName} id -g`, 5e3),
        runDockerCommand(`docker exec ${destContainerName} sh -c 'echo $HOME'`, 5e3)
      ]);
      const destUid = uidResult.stdout.trim() || "0";
      const destGid = gidResult.stdout.trim() || "0";
      const destHome = homeResult.stdout.trim() || "/root";
      const mkdirResult = await runDockerCommand(
        `docker exec --user root ${destContainerName} sh -c 'mkdir -p ${CONTAINER_SRC_DIR} /var/mux/plans && chown ${destUid}:${destGid} ${CONTAINER_SRC_DIR} /var/mux /var/mux/plans'`,
        1e4
      );
      if (mkdirResult.exitCode !== 0) {
        return {
          success: false,
          error: `Failed to prepare workspace directory: ${mkdirResult.stderr}`
        };
      }
      initLogger.logStep("Copying bundle to destination container...");
      const cpInResult = await runDockerCommand(
        `docker cp ${shescape.quote(hostTempPath)} ${destContainerName}:${containerBundlePath}`,
        3e5
      );
      if (cpInResult.exitCode !== 0) {
        return {
          success: false,
          error: `Failed to copy bundle to destination: ${cpInResult.stderr}`
        };
      }
      initLogger.logStep("Cloning repository in destination...");
      const cloneResult = await runDockerCommand(
        `docker exec ${destContainerName} git clone ${containerBundlePath} ${CONTAINER_SRC_DIR}`,
        3e5
      );
      if (cloneResult.exitCode !== 0) {
        return { success: false, error: `Failed to clone from bundle: ${cloneResult.stderr}` };
      }
      await runDockerCommand(
        `docker exec --user root ${destContainerName} chown -R ${destUid}:${destGid} ${CONTAINER_SRC_DIR}`,
        3e4
      );
      this.containerUid = destUid;
      this.containerGid = destGid;
      this.containerHome = destHome;
      initLogger.logStep("Creating local tracking branches...");
      try {
        const remotesResult = await runDockerCommand(
          `docker exec ${destContainerName} git -C ${CONTAINER_SRC_DIR} branch -r`,
          3e4
        );
        if (remotesResult.exitCode === 0) {
          const remotes = remotesResult.stdout.split("\n").map((b) => b.trim()).filter((b) => b.startsWith("origin/") && !b.includes("HEAD"));
          for (const remote of remotes) {
            const localName = remote.replace("origin/", "");
            await runDockerCommand(
              `docker exec ${destContainerName} git -C ${CONTAINER_SRC_DIR} branch ${shescape.quote(localName)} ${shescape.quote(remote)} 2>/dev/null || true`,
              1e4
            );
          }
        }
      } catch {
      }
      try {
        const originResult = await runDockerCommand(
          `docker exec ${srcContainerName} git -C ${CONTAINER_SRC_DIR} remote get-url origin 2>/dev/null || true`,
          1e4
        );
        const originUrl = originResult.stdout.trim();
        if (originUrl.length > 0) {
          await runDockerCommand(
            `docker exec ${destContainerName} git -C ${CONTAINER_SRC_DIR} remote set-url origin ${shescape.quote(originUrl)}`,
            1e4
          );
        } else {
          await runDockerCommand(
            `docker exec ${destContainerName} git -C ${CONTAINER_SRC_DIR} remote remove origin 2>/dev/null || true`,
            1e4
          );
        }
      } catch {
      }
      initLogger.logStep(`Checking out branch: ${newWorkspaceName}`);
      const checkoutCmd = `git checkout ${shescape.quote(newWorkspaceName)} 2>/dev/null || git checkout -b ${shescape.quote(newWorkspaceName)} ${shescape.quote(sourceBranch)}`;
      const checkoutResult = await runDockerCommand(
        `docker exec ${destContainerName} bash -c ${shescape.quote(`cd ${CONTAINER_SRC_DIR} && ${checkoutCmd}`)}`,
        12e4
      );
      if (checkoutResult.exitCode !== 0) {
        return {
          success: false,
          error: `Failed to checkout forked branch: ${checkoutResult.stderr || checkoutResult.stdout}`
        };
      }
      initLogger.logStep("Fork completed successfully");
      forkSucceeded = true;
      this.containerName = destContainerName;
      return { success: true, workspacePath: CONTAINER_SRC_DIR, sourceBranch };
    } catch (error) {
      return { success: false, error: getErrorMessage4(error) };
    } finally {
      await runDockerCommand(
        `docker exec ${srcContainerName} rm -f ${containerBundlePath}`,
        5e3
      ).catch(() => {
      });
      if (destContainerCreated) {
        await runDockerCommand(
          `docker exec ${destContainerName} rm -f ${containerBundlePath}`,
          5e3
        ).catch(() => {
        });
        if (!forkSucceeded) {
          await runDockerCommand(`docker rm -f ${destContainerName}`, 1e4).catch(() => {
          });
        }
      }
      await fs8.unlink(hostTempPath).catch(() => {
      });
    }
  }
  /**
   * Ensure the Docker container is running.
   * `docker start` is idempotent - succeeds if already running, starts if stopped,
   * and waits if container is in a transitional state (starting/restarting).
   *
   * Returns typed error for retry decisions:
   * - runtime_not_ready: container missing or permanent failure
   * - runtime_start_failed: transient failure (daemon issue, etc.)
   */
  async ensureReady() {
    if (!this.containerName) {
      return {
        ready: false,
        error: "Container name not set",
        errorType: "runtime_not_ready"
      };
    }
    const result = await runDockerCommand(`docker start ${this.containerName}`, 3e4);
    if (result.exitCode !== 0) {
      const stderr = result.stderr || "Failed to start container";
      const isContainerMissing = stderr.includes("No such container") || stderr.includes("not found");
      return {
        ready: false,
        error: stderr,
        errorType: isContainerMissing ? "runtime_not_ready" : "runtime_start_failed"
      };
    }
    if (!this.containerHome) {
      const [uidResult, gidResult, homeResult] = await Promise.all([
        runDockerCommand(`docker exec ${this.containerName} id -u`, 5e3),
        runDockerCommand(`docker exec ${this.containerName} id -g`, 5e3),
        runDockerCommand(`docker exec ${this.containerName} sh -c 'echo $HOME'`, 5e3)
      ]);
      this.containerUid = uidResult.stdout.trim() || "0";
      this.containerGid = gidResult.stdout.trim() || "0";
      this.containerHome = homeResult.stdout.trim() || "/root";
    }
    return { ready: true };
  }
  /**
   * Docker uses /var/mux instead of ~/.mux because:
   * - /root has 700 permissions, inaccessible to VS Code Dev Containers (non-root user)
   * - /var/mux is world-readable by default
   */
  getMuxHome() {
    return "/var/mux";
  }
};

// src/node/runtime/DevcontainerRuntime.ts
import { spawn as spawn8 } from "child_process";
import * as path16 from "path";
import { Readable as Readable3, Writable as Writable2 } from "stream";

// src/node/runtime/devcontainerCli.ts
import { spawn as spawn7 } from "child_process";
function isRecord(value2) {
  return typeof value2 === "object" && value2 !== null;
}
function isDevcontainerUpOutcome(value2) {
  return value2 === "success" || value2 === "error";
}
function isDevcontainerUpResult(value2) {
  if (!isRecord(value2)) return false;
  return isDevcontainerUpOutcome(value2.outcome);
}
function extractDevcontainerLogText(value2) {
  const text2 = typeof value2.text === "string" ? value2.text : void 0;
  if (text2) {
    const level = typeof value2.level === "number" ? value2.level : 0;
    const channel = typeof value2.channel === "string" ? value2.channel : "";
    const type2 = typeof value2.type === "string" ? value2.type : "";
    const isError = channel === "error" || type2 === "error";
    if (level >= 2 || isError) {
      return text2;
    }
    return null;
  }
  const name25 = typeof value2.name === "string" ? value2.name : void 0;
  if (name25) {
    return name25;
  }
  return null;
}
function parseJsonLine(line) {
  try {
    return JSON.parse(line);
  } catch {
    return null;
  }
}
function parseDevcontainerStdoutLine(line) {
  const trimmed = line.trim();
  if (!trimmed) return null;
  if (!trimmed.startsWith("{")) {
    return { kind: "raw", text: line };
  }
  const parsed = parseJsonLine(trimmed);
  if (!parsed) {
    return { kind: "raw", text: line };
  }
  if (isDevcontainerUpResult(parsed)) {
    return { kind: "result", result: parsed };
  }
  if (isRecord(parsed)) {
    const text2 = extractDevcontainerLogText(parsed);
    if (text2) {
      return { kind: "log", text: text2 };
    }
  }
  return null;
}
function formatDevcontainerUpError(result, stderrSummary) {
  const messageParts = [result.message, result.description].filter(
    (value2) => typeof value2 === "string" && value2.trim().length > 0
  );
  if (messageParts.length > 0) {
    return `devcontainer up failed: ${messageParts.join(" - ")}`;
  }
  if (stderrSummary && stderrSummary.trim().length > 0) {
    return `devcontainer up failed: ${stderrSummary.trim()}`;
  }
  return "devcontainer up failed";
}
function shouldCleanupDevcontainer(result) {
  return result.outcome === "error" && typeof result.containerId === "string" && result.containerId.trim().length > 0;
}
var SENSITIVE_REMOTE_ENV_KEYS = /* @__PURE__ */ new Set([
  "GH_TOKEN",
  "GITHUB_TOKEN",
  "GH_ENTERPRISE_TOKEN",
  "GITHUB_ENTERPRISE_TOKEN"
]);
function redactRemoteEnvArgs(args2) {
  const redacted = [...args2];
  for (let i = 0; i < redacted.length - 1; i += 1) {
    if (redacted[i] !== "--remote-env") continue;
    const entry = redacted[i + 1] ?? "";
    const [key] = entry.split("=");
    if (SENSITIVE_REMOTE_ENV_KEYS.has(key)) {
      redacted[i + 1] = `${key}=<redacted>`;
    }
  }
  return redacted;
}
var DEFAULT_UP_TIMEOUT_MS = 30 * 60 * 1e3;
var MAX_STDERR_BUFFER_LENGTH = 8e3;
var DEFAULT_CLEANUP_TIMEOUT_MS = 6e4;
async function removeDevcontainerContainer(containerId) {
  await new Promise((resolve4) => {
    const proc = spawn7("docker", ["rm", "-f", containerId], {
      stdio: ["ignore", "pipe", "pipe"],
      timeout: DEFAULT_CLEANUP_TIMEOUT_MS
    });
    proc.on("error", () => {
      resolve4();
    });
    proc.on("close", () => {
      resolve4();
    });
  });
}
var VERSION_CHECK_TIMEOUT_MS = 1e4;
async function checkDevcontainerCliVersion() {
  return new Promise((resolve4) => {
    const proc = spawn7("devcontainer", ["--version"], {
      stdio: ["ignore", "pipe", "pipe"],
      timeout: VERSION_CHECK_TIMEOUT_MS
    });
    let stdout = "";
    proc.stdout?.on("data", (data) => {
      stdout += data.toString();
    });
    proc.on("error", () => {
      resolve4(null);
    });
    proc.on("close", (code) => {
      if (code === 0 && stdout.trim()) {
        resolve4({ available: true, version: stdout.trim() });
      } else {
        resolve4(null);
      }
    });
  });
}
async function devcontainerUp(options) {
  const {
    workspaceFolder,
    configPath,
    initLogger,
    abortSignal,
    additionalMounts,
    remoteEnv,
    timeoutMs = DEFAULT_UP_TIMEOUT_MS
  } = options;
  const baseArgs = ["up", "--log-format", "json", "--workspace-folder", workspaceFolder];
  if (configPath) {
    baseArgs.push("--config", configPath);
  }
  if (additionalMounts) {
    for (const mount of additionalMounts) {
      baseArgs.push("--mount", mount);
    }
  }
  if (remoteEnv) {
    for (const [key, value2] of Object.entries(remoteEnv)) {
      baseArgs.push("--remote-env", `${key}=${value2}`);
    }
  }
  const runUp = (args2) => {
    const logArgs = redactRemoteEnvArgs(args2);
    initLogger.logStep(`Running: devcontainer ${logArgs.join(" ")}`);
    return new Promise((resolve4, reject) => {
      const proc = spawn7("devcontainer", args2, {
        stdio: ["ignore", "pipe", "pipe"],
        timeout: timeoutMs,
        cwd: workspaceFolder
      });
      let settled = false;
      let lastResultLine = null;
      let stderrBuffer = "";
      let timeoutId;
      const settleSuccess = (result) => {
        if (settled) return;
        settled = true;
        if (timeoutId) clearTimeout(timeoutId);
        resolve4(result);
      };
      const appendStderrSummary = (text2) => {
        if (stderrBuffer.length >= MAX_STDERR_BUFFER_LENGTH) return;
        const next = `${text2}
`;
        stderrBuffer = (stderrBuffer + next).slice(0, MAX_STDERR_BUFFER_LENGTH);
      };
      const settleError = (error) => {
        if (settled) return;
        settled = true;
        if (timeoutId) clearTimeout(timeoutId);
        reject(error);
      };
      const stdoutLineBuffer = new LineBuffer((line) => {
        const parsed = parseDevcontainerStdoutLine(line);
        if (!parsed) return;
        if (parsed.kind === "result") {
          lastResultLine = parsed.result;
          return;
        }
        if (parsed.kind === "log") {
          initLogger.logStdout(parsed.text);
          return;
        }
        initLogger.logStdout(parsed.text);
      });
      const stderrLineBuffer = new LineBuffer((line) => {
        const parsed = parseDevcontainerStdoutLine(line);
        if (parsed?.kind === "result") {
          lastResultLine ??= parsed.result;
          return;
        }
        const summaryText = parsed ? parsed.text : line;
        appendStderrSummary(summaryText);
        if (!parsed) return;
        initLogger.logStdout(parsed.text);
      });
      proc.stdout?.on("data", (data) => {
        stdoutLineBuffer.append(data.toString());
      });
      proc.stderr?.on("data", (data) => {
        stderrLineBuffer.append(data.toString());
      });
      const abortHandler = () => {
        proc.kill("SIGTERM");
        settleError(new Error("devcontainer up aborted"));
      };
      if (timeoutMs && timeoutMs > 0) {
        timeoutId = setTimeout(() => {
          proc.kill("SIGTERM");
          settleError(new Error(`devcontainer up timed out after ${timeoutMs}ms`));
        }, timeoutMs);
      }
      abortSignal?.addEventListener("abort", abortHandler);
      const finalizeError = async (message, result) => {
        if (result && shouldCleanupDevcontainer(result)) {
          try {
            await removeDevcontainerContainer(result.containerId ?? "");
          } catch (cleanupError) {
            log.debug("Failed to remove devcontainer container", {
              cleanupError,
              containerId: result.containerId
            });
          }
        }
        settleError(new Error(message));
      };
      proc.on("error", (err) => {
        abortSignal?.removeEventListener("abort", abortHandler);
        stdoutLineBuffer.flush();
        stderrLineBuffer.flush();
        settleError(new Error(`devcontainer up failed: ${getErrorMessage4(err)}`));
      });
      proc.on("close", (code) => {
        const handleClose = async () => {
          abortSignal?.removeEventListener("abort", abortHandler);
          stdoutLineBuffer.flush();
          stderrLineBuffer.flush();
          if (settled) return;
          const stderrSummary = stderrBuffer.trim();
          if (lastResultLine) {
            if (lastResultLine.outcome === "success") {
              if (!lastResultLine.containerId || !lastResultLine.remoteUser || !lastResultLine.remoteWorkspaceFolder) {
                await finalizeError(
                  "devcontainer up output missing required fields",
                  lastResultLine
                );
                return;
              }
              settleSuccess({
                containerId: lastResultLine.containerId,
                remoteUser: lastResultLine.remoteUser,
                remoteWorkspaceFolder: lastResultLine.remoteWorkspaceFolder
              });
              return;
            }
            await finalizeError(
              formatDevcontainerUpError(lastResultLine, stderrSummary),
              lastResultLine
            );
            return;
          }
          if (code !== 0) {
            const suffix2 = stderrSummary.length > 0 ? `: ${stderrSummary}` : "";
            settleError(new Error(`devcontainer up exited with code ${String(code)}${suffix2}`));
            return;
          }
          const suffix = stderrSummary.length > 0 ? `: ${stderrSummary}` : "";
          settleError(new Error(`devcontainer up did not produce result output${suffix}`));
        };
        void handleClose();
      });
    });
  };
  return runUp(baseArgs);
}
async function getDevcontainerContainerId(workspaceFolder, _configPath, timeoutMs = 1e4) {
  const labelValue = workspaceFolder;
  return new Promise((resolve4) => {
    const proc = spawn7(
      "docker",
      ["ps", "-q", "--filter", `label=devcontainer.local_folder=${labelValue}`],
      {
        stdio: ["ignore", "pipe", "pipe"],
        timeout: timeoutMs
      }
    );
    let stdout = "";
    proc.stdout?.on("data", (data) => {
      stdout += data.toString();
    });
    proc.on("error", () => {
      resolve4(null);
    });
    proc.on("close", (code) => {
      if (code === 0 && stdout.trim()) {
        resolve4(stdout.trim().split("\n")[0]);
      } else {
        resolve4(null);
      }
    });
  });
}
async function devcontainerDown(workspaceFolder, _configPath, timeoutMs = 6e4) {
  const containerId = await getDevcontainerContainerId(workspaceFolder);
  if (!containerId) {
    return;
  }
  return new Promise((resolve4) => {
    const proc = spawn7("docker", ["rm", "-f", containerId], {
      stdio: ["ignore", "pipe", "pipe"],
      timeout: timeoutMs
    });
    proc.on("error", () => {
      resolve4();
    });
    proc.on("close", () => {
      resolve4();
    });
  });
}

// src/node/runtime/DevcontainerRuntime.ts
var DevcontainerRuntime = class extends LocalBaseRuntime {
  constructor(options) {
    super();
    this.createFlags = {
      deferredRuntimeAccess: true
    };
    this.worktreeManager = new WorktreeManager(options.srcBaseDir);
    this.configPath = options.configPath;
    this.shareCredentials = options.shareCredentials ?? false;
  }
  buildCredentialForwarding(env3) {
    const additionalMounts = [];
    const remoteEnv = {};
    if (!this.shareCredentials) {
      return { additionalMounts, remoteEnv };
    }
    const sshForwarding = resolveSshAgentForwarding("/tmp/ssh-agent.sock");
    if (sshForwarding) {
      additionalMounts.push(
        `type=bind,source=${sshForwarding.hostSocketPath},target=${sshForwarding.targetSocketPath}`
      );
      remoteEnv.SSH_AUTH_SOCK = sshForwarding.targetSocketPath;
    }
    const ghToken = resolveGhToken(env3);
    if (ghToken) {
      remoteEnv.GH_TOKEN = ghToken;
    }
    return { additionalMounts, remoteEnv };
  }
  mapContainerPathToHost(containerPath) {
    if (!this.remoteWorkspaceFolder || !this.currentWorkspacePath) return null;
    const remoteRoot = this.remoteWorkspaceFolder.replace(/\/+$/, "");
    if (containerPath !== remoteRoot && !containerPath.startsWith(`${remoteRoot}/`)) return null;
    const suffix = containerPath.slice(remoteRoot.length).replace(/^\/+/, "");
    return suffix.length === 0 ? this.currentWorkspacePath : path16.join(this.currentWorkspacePath, suffix);
  }
  getContainerBasePath() {
    return this.remoteWorkspaceFolder ?? "/";
  }
  resolveHostPathForMounted(filePath) {
    if (this.currentWorkspacePath) {
      const normalizedFilePath = filePath.replaceAll("\\", "/");
      const normalizedHostRoot = stripTrailingSlashes(
        this.currentWorkspacePath.replaceAll("\\", "/")
      );
      if (normalizedFilePath === normalizedHostRoot || normalizedFilePath.startsWith(`${normalizedHostRoot}/`)) {
        return filePath;
      }
    }
    return this.mapContainerPathToHost(filePath);
  }
  quoteForContainer(filePath) {
    if (filePath === "~" || filePath.startsWith("~/")) {
      return expandTildeForSSH(filePath);
    }
    return shescape.quote(filePath);
  }
  /**
   * Expand tilde in file paths for container operations.
   * Returns unexpanded path when container user is unknown (before ensureReady).
   * Callers must check for unexpanded tilde and handle appropriately.
   */
  expandTildeForContainer(filePath) {
    if (filePath === "~" || filePath.startsWith("~/")) {
      if (this.remoteHomeDir) {
        return filePath === "~" ? this.remoteHomeDir : this.remoteHomeDir + filePath.slice(1);
      }
      if (this.remoteUser !== void 0) {
        const homeDir = this.remoteUser === "root" ? "/root" : `/home/${this.remoteUser}`;
        return filePath === "~" ? homeDir : homeDir + filePath.slice(1);
      }
      return filePath;
    }
    return filePath;
  }
  /**
   * Check if a path contains unexpanded tilde (container user unknown).
   */
  hasUnexpandedTilde(filePath) {
    return filePath === "~" || filePath.startsWith("~/");
  }
  async setupCredentials(env3) {
    if (!this.shareCredentials) return;
    const gitconfigContents = await readHostGitconfig();
    if (gitconfigContents) {
      const stream = await this.exec('cat > "$HOME/.gitconfig"', {
        cwd: this.getContainerBasePath(),
        timeout: 30
      });
      const writer = stream.stdin.getWriter();
      try {
        await writer.write(gitconfigContents);
      } finally {
        writer.releaseLock();
      }
      await stream.stdin.close();
      const exitCode = await stream.exitCode;
      if (exitCode !== 0) {
        const stderr = await streamToString2(stream.stderr);
        throw new RuntimeError(`Failed to copy gitconfig: ${stderr}`, "file_io");
      }
    }
    const ghToken = resolveGhToken(env3);
    if (ghToken) {
      const stream = await this.exec("command -v gh >/dev/null && gh auth setup-git || true", {
        cwd: this.getContainerBasePath(),
        timeout: 30,
        env: { GH_TOKEN: ghToken }
      });
      await stream.stdin.close();
      await stream.exitCode;
    }
  }
  async fetchRemoteHome() {
    if (!this.currentWorkspacePath) return;
    try {
      const stream = await this.exec('printf "%s" "$HOME"', {
        cwd: this.remoteWorkspaceFolder ?? "/",
        timeout: 10
      });
      await stream.stdin.close();
      const stdout = await streamToString2(stream.stdout);
      const exitCode = await stream.exitCode;
      if (exitCode === 0 && stdout.trim()) {
        this.remoteHomeDir = stdout.trim();
      }
    } catch {
    }
  }
  readFileViaExec(filePath, abortSignal) {
    return new ReadableStream({
      start: async (controller) => {
        try {
          const stream = await this.exec(`cat ${this.quoteForContainer(filePath)}`, {
            cwd: this.getContainerBasePath(),
            timeout: 300,
            abortSignal
          });
          const reader = stream.stdout.getReader();
          const exitCodePromise = stream.exitCode;
          while (true) {
            const { done, value: value2 } = await reader.read();
            if (done) break;
            controller.enqueue(value2);
          }
          const code = await exitCodePromise;
          if (code !== 0) {
            const stderr = await streamToString2(stream.stderr);
            throw new RuntimeError(`Failed to read file ${filePath}: ${stderr}`, "file_io");
          }
          controller.close();
        } catch (err) {
          if (err instanceof RuntimeError) {
            controller.error(err);
          } else {
            controller.error(
              new RuntimeError(
                `Failed to read file ${filePath}: ${err instanceof Error ? err.message : String(err)}`,
                "file_io",
                err instanceof Error ? err : void 0
              )
            );
          }
        }
      }
    });
  }
  writeFileViaExec(filePath, abortSignal) {
    const quotedPath = this.quoteForContainer(filePath);
    const tempPath = `${filePath}.tmp.${Date.now()}`;
    const quotedTempPath = this.quoteForContainer(tempPath);
    const writeCommand = `mkdir -p $(dirname ${quotedPath}) && cat > ${quotedTempPath} && mv ${quotedTempPath} ${quotedPath}`;
    let execPromise = null;
    const getExecStream = () => {
      execPromise ??= this.exec(writeCommand, {
        cwd: this.getContainerBasePath(),
        timeout: 300,
        abortSignal
      });
      return execPromise;
    };
    return new WritableStream({
      write: async (chunk) => {
        const stream = await getExecStream();
        const writer = stream.stdin.getWriter();
        try {
          await writer.write(chunk);
        } finally {
          writer.releaseLock();
        }
      },
      close: async () => {
        const stream = await getExecStream();
        await stream.stdin.close();
        const exitCode = await stream.exitCode;
        if (exitCode !== 0) {
          const stderr = await streamToString2(stream.stderr);
          throw new RuntimeError(`Failed to write file ${filePath}: ${stderr}`, "file_io");
        }
      },
      abort: async (reason) => {
        const stream = await getExecStream();
        await stream.stdin.abort();
        throw new RuntimeError(`Failed to write file ${filePath}: ${String(reason)}`, "file_io");
      }
    });
  }
  async ensureDirViaExec(dirPath) {
    const stream = await this.exec(`mkdir -p ${this.quoteForContainer(dirPath)}`, {
      cwd: "/",
      timeout: 10
    });
    await stream.stdin.close();
    const [stdout, stderr, exitCode] = await Promise.all([
      streamToString2(stream.stdout),
      streamToString2(stream.stderr),
      stream.exitCode
    ]);
    if (exitCode !== 0) {
      const extra = stderr.trim() || stdout.trim();
      throw new RuntimeError(
        `Failed to create directory ${dirPath}: exit code ${exitCode}${extra ? `: ${extra}` : ""}`,
        "file_io"
      );
    }
  }
  async statViaExec(filePath, abortSignal) {
    const stream = await this.exec(`stat -L -c '%s %Y %F' ${this.quoteForContainer(filePath)}`, {
      cwd: this.getContainerBasePath(),
      timeout: 10,
      abortSignal
    });
    const [stdout, stderr, exitCode] = await Promise.all([
      streamToString2(stream.stdout),
      streamToString2(stream.stderr),
      stream.exitCode
    ]);
    if (exitCode !== 0) {
      throw new RuntimeError(`Failed to stat ${filePath}: ${stderr}`, "file_io");
    }
    const parts = stdout.trim().split(" ");
    if (parts.length < 3) {
      throw new RuntimeError(`Failed to parse stat output for ${filePath}: ${stdout}`, "file_io");
    }
    const size = parseInt(parts[0], 10);
    const mtime = parseInt(parts[1], 10);
    const fileType = parts.slice(2).join(" ");
    return {
      size,
      modifiedTime: new Date(mtime * 1e3),
      isDirectory: fileType === "directory"
    };
  }
  mapHostPathToContainer(hostPath) {
    if (!this.remoteWorkspaceFolder || !this.currentWorkspacePath) return null;
    const normalizedHostPath = hostPath.replaceAll("\\", "/");
    const hostRoot = this.currentWorkspacePath.replaceAll("\\", "/").replace(/\/+$/, "");
    if (normalizedHostPath !== hostRoot && !normalizedHostPath.startsWith(`${hostRoot}/`))
      return null;
    const suffix = normalizedHostPath.slice(hostRoot.length).replace(/^\/+/, "");
    return suffix.length === 0 ? this.remoteWorkspaceFolder : path16.posix.join(this.remoteWorkspaceFolder, suffix);
  }
  /**
   * Resolve cwd for container exec, filtering out unmappable host paths.
   * Only uses options.cwd if it looks like a valid container path (POSIX absolute, no Windows drive letters).
   */
  resolveContainerCwd(optionsCwd, workspaceFolder) {
    if (optionsCwd && this.looksLikeContainerPath(optionsCwd)) {
      return optionsCwd;
    }
    return this.remoteWorkspaceFolder ?? workspaceFolder;
  }
  /**
   * Check if a path looks like a valid container path (POSIX absolute, no Windows artifacts).
   */
  looksLikeContainerPath(p) {
    if (/^[A-Za-z]:/.test(p)) return false;
    if (p.includes("\\")) return false;
    return p.startsWith("/");
  }
  getWorkspacePath(projectPath, workspaceName) {
    return this.worktreeManager.getWorkspacePath(projectPath, workspaceName);
  }
  async createWorkspace(params) {
    return this.worktreeManager.createWorkspace({
      projectPath: params.projectPath,
      branchName: params.branchName,
      trunkBranch: params.trunkBranch,
      initLogger: params.initLogger
    });
  }
  /**
   * Build and start the devcontainer after workspace creation.
   * This runs `devcontainer up` which builds the image and starts the container.
   */
  async postCreateSetup(params) {
    const { workspacePath, initLogger, abortSignal, env: env3 } = params;
    initLogger.logStep("Building devcontainer...");
    this.lastCredentialEnv = env3;
    const { additionalMounts, remoteEnv } = this.buildCredentialForwarding(env3);
    try {
      const result = await devcontainerUp({
        workspaceFolder: workspacePath,
        configPath: this.configPath,
        initLogger,
        abortSignal,
        additionalMounts: additionalMounts.length > 0 ? additionalMounts : void 0,
        remoteEnv: Object.keys(remoteEnv).length > 0 ? remoteEnv : void 0
      });
      this.remoteWorkspaceFolder = result.remoteWorkspaceFolder;
      this.remoteUser = result.remoteUser;
      this.currentWorkspacePath = workspacePath;
      await this.fetchRemoteHome();
      await this.setupCredentials(env3);
      initLogger.logStep("Devcontainer ready");
    } catch (error) {
      throw new Error(`Failed to start devcontainer: ${getErrorMessage4(error)}`);
    }
  }
  /**
   * Run .mux/init hook inside the devcontainer.
   */
  async initWorkspace(params) {
    const { projectPath, branchName, workspacePath, initLogger, env: env3 } = params;
    try {
      const hookExists = await checkInitHookExists(workspacePath);
      if (hookExists) {
        initLogger.enterHookPhase?.();
        const muxEnv = { ...env3, ...getMuxEnv(projectPath, "devcontainer", branchName) };
        const containerWorkspacePath = this.remoteWorkspaceFolder ?? workspacePath;
        const hookPath = `${containerWorkspacePath}/.mux/init`;
        await runInitHookOnRuntime(this, hookPath, containerWorkspacePath, muxEnv, initLogger);
      } else {
        initLogger.logComplete(0);
      }
      return { success: true };
    } catch (error) {
      const errorMsg = getErrorMessage4(error);
      initLogger.logStderr(`Initialization failed: ${errorMsg}`);
      initLogger.logComplete(-1);
      return {
        success: false,
        error: errorMsg
      };
    }
  }
  /**
   * Execute a command inside the devcontainer.
   * Overrides LocalBaseRuntime.exec() to use `devcontainer exec`.
   */
  exec(command, options) {
    const startTime = performance.now();
    if (options.abortSignal?.aborted) {
      throw new RuntimeError("Operation aborted before execution", "exec");
    }
    const workspaceFolder = this.currentWorkspacePath;
    if (!workspaceFolder) {
      throw new RuntimeError("Devcontainer not initialized. Call ensureReady() first.", "exec");
    }
    const args2 = ["exec", "--workspace-folder", workspaceFolder];
    if (this.configPath) {
      args2.push("--config", this.configPath);
    }
    const envVars = { ...options.env, ...NON_INTERACTIVE_ENV_VARS };
    for (const [key, value2] of Object.entries(envVars)) {
      args2.push("--remote-env", `${key}=${value2}`);
    }
    const mappedCwd = options.cwd ? this.mapHostPathToContainer(options.cwd) : null;
    const cwd = mappedCwd ?? this.resolveContainerCwd(options.cwd, workspaceFolder);
    const fullCommand = `cd ${JSON.stringify(cwd)} && ${command}`;
    args2.push("--", "bash", "-c", fullCommand);
    const childProcess = spawn8("devcontainer", args2, {
      stdio: ["pipe", "pipe", "pipe"],
      detached: true,
      windowsHide: true,
      cwd: workspaceFolder
    });
    const disposable = new DisposableProcess(childProcess);
    const stdout = Readable3.toWeb(childProcess.stdout);
    const stderr = Readable3.toWeb(childProcess.stderr);
    const stdin = Writable2.toWeb(childProcess.stdin);
    let timedOut = false;
    let aborted = false;
    const exitCode = new Promise((resolve4, reject) => {
      childProcess.on("exit", (code) => {
        if (childProcess.pid !== void 0) {
          killProcessTree(childProcess.pid);
        }
        if (aborted || options.abortSignal?.aborted) {
          resolve4(EXIT_CODE_ABORTED);
          return;
        }
        if (timedOut) {
          resolve4(EXIT_CODE_TIMEOUT);
          return;
        }
        resolve4(code ?? 0);
      });
      childProcess.on("error", (err) => {
        reject(
          new RuntimeError(`Failed to execute devcontainer exec: ${err.message}`, "exec", err)
        );
      });
    });
    const duration = exitCode.then(() => performance.now() - startTime);
    void exitCode.catch(() => void 0);
    void duration.catch(() => void 0);
    let timeoutId;
    if (options.timeout && options.timeout > 0) {
      timeoutId = setTimeout(() => {
        timedOut = true;
        disposable[Symbol.dispose]();
      }, options.timeout * 1e3);
      void exitCode.finally(() => {
        if (timeoutId) clearTimeout(timeoutId);
      });
    }
    const abortHandler = () => {
      aborted = true;
      disposable[Symbol.dispose]();
    };
    options.abortSignal?.addEventListener("abort", abortHandler);
    void exitCode.finally(() => {
      options.abortSignal?.removeEventListener("abort", abortHandler);
    });
    return Promise.resolve({
      stdout,
      stderr,
      stdin,
      exitCode,
      duration
    });
  }
  readFile(filePath, abortSignal) {
    const hostPath = this.resolveHostPathForMounted(filePath);
    if (hostPath) {
      return super.readFile(hostPath, abortSignal);
    }
    return this.readFileViaExec(filePath, abortSignal);
  }
  writeFile(filePath, abortSignal) {
    const hostPath = this.resolveHostPathForMounted(filePath);
    if (hostPath) {
      return super.writeFile(hostPath, abortSignal);
    }
    return this.writeFileViaExec(filePath, abortSignal);
  }
  async stat(filePath) {
    const hostPath = this.resolveHostPathForMounted(filePath);
    if (hostPath) {
      return super.stat(hostPath);
    }
    return this.statViaExec(filePath);
  }
  async ensureDir(dirPath) {
    const hostPath = this.resolveHostPathForMounted(dirPath);
    if (hostPath) {
      return super.ensureDir(hostPath);
    }
    return this.ensureDirViaExec(dirPath);
  }
  async resolvePath(filePath) {
    let expanded = this.expandTildeForContainer(filePath);
    if (this.hasUnexpandedTilde(expanded)) {
      await this.fetchRemoteHome();
      if (this.remoteHomeDir) {
        expanded = filePath === "~" ? this.remoteHomeDir : this.remoteHomeDir + filePath.slice(1);
      } else {
        throw new RuntimeError(
          `Failed to resolve path ${filePath}: container home directory unavailable`,
          "exec"
        );
      }
    }
    if (!expanded.startsWith("/")) {
      const basePath = this.remoteWorkspaceFolder ?? "/";
      return path16.posix.resolve(basePath, expanded);
    }
    return path16.posix.resolve(expanded);
  }
  tempDir() {
    const workspaceRoot = this.remoteWorkspaceFolder ?? this.currentWorkspacePath;
    if (!workspaceRoot) {
      return super.tempDir();
    }
    const tmpPath = this.remoteWorkspaceFolder ? path16.posix.join(workspaceRoot, ".mux", "tmp") : path16.join(workspaceRoot, ".mux", "tmp");
    return Promise.resolve(tmpPath);
  }
  /**
   * Ensure the devcontainer is ready for operations.
   * Runs `devcontainer up` which starts the container if stopped,
   * or rebuilds if the container was deleted.
   */
  async ensureReady(options) {
    if (!this.currentWorkspacePath) {
      return {
        ready: false,
        error: "Workspace path not set. Call postCreateSetup() first.",
        errorType: "runtime_not_ready"
      };
    }
    const statusSink = options?.statusSink;
    statusSink?.({
      phase: "checking",
      runtimeType: "devcontainer",
      detail: "Checking repository..."
    });
    const hasRepo = await isGitRepository(this.currentWorkspacePath);
    if (!hasRepo) {
      statusSink?.({
        phase: "error",
        runtimeType: "devcontainer",
        detail: WORKSPACE_REPO_MISSING_ERROR
      });
      return {
        ready: false,
        error: WORKSPACE_REPO_MISSING_ERROR,
        errorType: "runtime_not_ready"
      };
    }
    try {
      statusSink?.({
        phase: "starting",
        runtimeType: "devcontainer",
        detail: "Starting devcontainer..."
      });
      const silentLogger = {
        logStep: (_message) => {
        },
        logStdout: (_line) => {
        },
        logStderr: (line) => log.debug("devcontainer up stderr:", { line }),
        logComplete: (_exitCode) => {
        }
      };
      const { additionalMounts, remoteEnv } = this.buildCredentialForwarding(
        this.lastCredentialEnv
      );
      const result = await devcontainerUp({
        workspaceFolder: this.currentWorkspacePath,
        configPath: this.configPath,
        initLogger: silentLogger,
        abortSignal: options?.signal,
        additionalMounts: additionalMounts.length > 0 ? additionalMounts : void 0,
        remoteEnv: Object.keys(remoteEnv).length > 0 ? remoteEnv : void 0
      });
      this.remoteWorkspaceFolder = result.remoteWorkspaceFolder;
      this.remoteUser = result.remoteUser;
      await this.fetchRemoteHome();
      await this.setupCredentials(this.lastCredentialEnv);
      statusSink?.({ phase: "ready", runtimeType: "devcontainer" });
      return { ready: true };
    } catch (error) {
      const errorMsg = getErrorMessage4(error);
      statusSink?.({ phase: "error", runtimeType: "devcontainer", detail: errorMsg });
      return {
        ready: false,
        error: errorMsg,
        errorType: "runtime_not_ready"
      };
    }
  }
  async renameWorkspace(projectPath, oldName, newName, _abortSignal) {
    const oldPath = this.getWorkspacePath(projectPath, oldName);
    await devcontainerDown(oldPath, this.configPath);
    const result = await this.worktreeManager.renameWorkspace(projectPath, oldName, newName);
    if (result.success) {
      if (this.currentWorkspacePath === oldPath) {
        this.currentWorkspacePath = result.newPath;
      }
    }
    return result;
  }
  async deleteWorkspace(projectPath, workspaceName, force, _abortSignal) {
    const workspacePath = this.getWorkspacePath(projectPath, workspaceName);
    try {
      await devcontainerDown(workspacePath, this.configPath);
    } catch (error) {
      log.debug("devcontainerDown failed (container may not exist):", { error });
    }
    return this.worktreeManager.deleteWorkspace(projectPath, workspaceName, force);
  }
  async forkWorkspace(params) {
    return this.worktreeManager.forkWorkspace(params);
  }
  /**
   * Set the current workspace path for exec operations.
   * Called by workspaceService when switching to an existing workspace.
   */
  setCurrentWorkspacePath(workspacePath) {
    this.currentWorkspacePath = workspacePath;
  }
  /**
   * Get the remote workspace folder path (inside container).
   */
  getRemoteWorkspaceFolder() {
    return this.remoteWorkspaceFolder;
  }
};

// src/common/utils/runtimeCompatibility.ts
function isIncompatibleRuntimeConfig(config2) {
  if (!config2) {
    return false;
  }
  return !RuntimeModeSchema.safeParse(config2.type).success;
}

// src/node/config.ts
var import_write_file_atomic = __toESM(require_lib());
import * as fs9 from "fs";
import * as path17 from "path";
import * as crypto4 from "crypto";
import * as jsonc from "jsonc-parser";

// src/common/utils/assert.ts
var AssertionError = class extends Error {
  constructor(message) {
    super(message ?? "Assertion failed");
    this.name = "AssertionError";
  }
};
function assert(condition, message) {
  if (!condition) {
    throw new AssertionError(message);
  }
}
var assert_default = assert;

// src/common/types/tasks.ts
var TASK_SETTINGS_LIMITS = {
  maxParallelAgentTasks: { min: 1, max: 256, default: 3 },
  maxTaskNestingDepth: { min: 1, max: 5, default: 3 }
};
var SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS = {
  bashOutputCompactionMinLines: { min: 0, max: 1e3, default: 10 },
  bashOutputCompactionMinTotalBytes: { min: 0, max: 16 * 1024, default: 4 * 1024 },
  bashOutputCompactionMaxKeptLines: { min: 1, max: 1e3, default: 40 },
  bashOutputCompactionTimeoutMs: { min: 1e3, max: 12e4, default: 5e3 }
};
var DEFAULT_TASK_SETTINGS = {
  maxParallelAgentTasks: TASK_SETTINGS_LIMITS.maxParallelAgentTasks.default,
  maxTaskNestingDepth: TASK_SETTINGS_LIMITS.maxTaskNestingDepth.default,
  proposePlanImplementReplacesChatHistory: false,
  bashOutputCompactionMinLines: SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionMinLines.default,
  bashOutputCompactionMinTotalBytes: SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionMinTotalBytes.default,
  bashOutputCompactionMaxKeptLines: SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionMaxKeptLines.default,
  bashOutputCompactionTimeoutMs: SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionTimeoutMs.default,
  bashOutputCompactionHeuristicFallback: true
};
function normalizeSubagentAiDefaults(raw) {
  const record = raw && typeof raw === "object" ? raw : {};
  const result = {};
  for (const [agentTypeRaw, entryRaw] of Object.entries(record)) {
    const agentType = agentTypeRaw.trim().toLowerCase();
    if (!agentType) continue;
    if (agentType === "exec") continue;
    if (!entryRaw || typeof entryRaw !== "object") continue;
    const entry = entryRaw;
    const modelString = typeof entry.modelString === "string" && entry.modelString.trim().length > 0 ? entry.modelString.trim() : void 0;
    const thinkingLevel = coerceThinkingLevel(entry.thinkingLevel);
    if (!modelString && !thinkingLevel) {
      continue;
    }
    result[agentType] = { modelString, thinkingLevel };
  }
  return result;
}
function clampInt(value2, fallback, min, max) {
  if (typeof value2 !== "number" || !Number.isFinite(value2)) {
    return fallback;
  }
  const rounded = Math.floor(value2);
  if (rounded < min) return min;
  if (rounded > max) return max;
  return rounded;
}
function normalizeTaskSettings(raw) {
  const record = raw && typeof raw === "object" ? raw : {};
  const maxParallelAgentTasks = clampInt(
    record.maxParallelAgentTasks,
    DEFAULT_TASK_SETTINGS.maxParallelAgentTasks,
    TASK_SETTINGS_LIMITS.maxParallelAgentTasks.min,
    TASK_SETTINGS_LIMITS.maxParallelAgentTasks.max
  );
  const maxTaskNestingDepth = clampInt(
    record.maxTaskNestingDepth,
    DEFAULT_TASK_SETTINGS.maxTaskNestingDepth,
    TASK_SETTINGS_LIMITS.maxTaskNestingDepth.min,
    TASK_SETTINGS_LIMITS.maxTaskNestingDepth.max
  );
  const proposePlanImplementReplacesChatHistory = typeof record.proposePlanImplementReplacesChatHistory === "boolean" ? record.proposePlanImplementReplacesChatHistory : DEFAULT_TASK_SETTINGS.proposePlanImplementReplacesChatHistory ?? false;
  const bashOutputCompactionMinLines = clampInt(
    record.bashOutputCompactionMinLines,
    SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionMinLines.default,
    SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionMinLines.min,
    SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionMinLines.max
  );
  const bashOutputCompactionMinTotalBytes = clampInt(
    record.bashOutputCompactionMinTotalBytes,
    SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionMinTotalBytes.default,
    SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionMinTotalBytes.min,
    SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionMinTotalBytes.max
  );
  const bashOutputCompactionMaxKeptLines = clampInt(
    record.bashOutputCompactionMaxKeptLines,
    SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionMaxKeptLines.default,
    SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionMaxKeptLines.min,
    SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionMaxKeptLines.max
  );
  const bashOutputCompactionTimeoutMsRaw = clampInt(
    record.bashOutputCompactionTimeoutMs,
    SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionTimeoutMs.default,
    SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionTimeoutMs.min,
    SYSTEM1_BASH_OUTPUT_COMPACTION_LIMITS.bashOutputCompactionTimeoutMs.max
  );
  const bashOutputCompactionHeuristicFallback = typeof record.bashOutputCompactionHeuristicFallback === "boolean" ? record.bashOutputCompactionHeuristicFallback : DEFAULT_TASK_SETTINGS.bashOutputCompactionHeuristicFallback ?? true;
  const bashOutputCompactionTimeoutMs = Math.floor(bashOutputCompactionTimeoutMsRaw / 1e3) * 1e3;
  const result = {
    maxParallelAgentTasks,
    maxTaskNestingDepth,
    proposePlanImplementReplacesChatHistory,
    bashOutputCompactionMinLines,
    bashOutputCompactionMinTotalBytes,
    bashOutputCompactionMaxKeptLines,
    bashOutputCompactionTimeoutMs,
    bashOutputCompactionHeuristicFallback
  };
  assert_default(
    Number.isInteger(maxParallelAgentTasks),
    "normalizeTaskSettings: maxParallelAgentTasks must be an integer"
  );
  assert_default(
    Number.isInteger(maxTaskNestingDepth),
    "normalizeTaskSettings: maxTaskNestingDepth must be an integer"
  );
  assert_default(
    typeof proposePlanImplementReplacesChatHistory === "boolean",
    "normalizeTaskSettings: proposePlanImplementReplacesChatHistory must be a boolean"
  );
  assert_default(
    Number.isInteger(bashOutputCompactionMinLines),
    "normalizeTaskSettings: bashOutputCompactionMinLines must be an integer"
  );
  assert_default(
    Number.isInteger(bashOutputCompactionMinTotalBytes),
    "normalizeTaskSettings: bashOutputCompactionMinTotalBytes must be an integer"
  );
  assert_default(
    Number.isInteger(bashOutputCompactionMaxKeptLines),
    "normalizeTaskSettings: bashOutputCompactionMaxKeptLines must be an integer"
  );
  assert_default(
    Number.isInteger(bashOutputCompactionTimeoutMs),
    "normalizeTaskSettings: bashOutputCompactionTimeoutMs must be an integer"
  );
  assert_default(
    typeof bashOutputCompactionHeuristicFallback === "boolean",
    "normalizeTaskSettings: bashOutputCompactionHeuristicFallback must be a boolean"
  );
  assert_default(
    bashOutputCompactionTimeoutMs % 1e3 === 0,
    "normalizeTaskSettings: bashOutputCompactionTimeoutMs must be a whole number of seconds"
  );
  return result;
}

// src/common/types/keybind.ts
function hasModifierKeybind(keybind) {
  return [keybind.ctrl, keybind.shift, keybind.alt, keybind.meta].some((v) => v === true);
}
function normalizeKeybind(raw) {
  if (!raw || typeof raw !== "object") {
    return void 0;
  }
  const record = raw;
  const rawKey = typeof record.key === "string" ? record.key : "";
  const key = rawKey === " " ? rawKey : rawKey.trim();
  if (!key) {
    return void 0;
  }
  const allowShift = typeof record.allowShift === "boolean" ? record.allowShift : void 0;
  const ctrl = typeof record.ctrl === "boolean" ? record.ctrl : void 0;
  const shift = typeof record.shift === "boolean" ? record.shift : void 0;
  const alt = typeof record.alt === "boolean" ? record.alt : void 0;
  const meta = typeof record.meta === "boolean" ? record.meta : void 0;
  const macCtrlBehavior = record.macCtrlBehavior === "either" || record.macCtrlBehavior === "command" || record.macCtrlBehavior === "control" ? record.macCtrlBehavior : void 0;
  const result = {
    key,
    allowShift,
    ctrl,
    shift,
    alt,
    meta,
    macCtrlBehavior
  };
  assert_default(typeof result.key === "string" && result.key.length > 0, "Keybind.key must be non-empty");
  return result;
}

// src/common/types/uiLayouts.ts
var DEFAULT_LAYOUT_PRESETS_CONFIG = {
  version: 2,
  slots: []
};
function isLayoutSlotNumber(value2) {
  return typeof value2 === "number" && Number.isInteger(value2) && value2 >= 1;
}
function normalizeOptionalNonEmptyString(value2) {
  if (typeof value2 !== "string") {
    return void 0;
  }
  const trimmed = value2.trim();
  return trimmed ? trimmed : void 0;
}
function normalizeRightSidebarWidthPreset(raw) {
  if (!raw || typeof raw !== "object") {
    return { mode: "px", value: 400 };
  }
  const record = raw;
  const mode = record.mode;
  if (mode === "fraction") {
    const value3 = typeof record.value === "number" && Number.isFinite(record.value) ? record.value : 0.3;
    const clamped2 = Math.min(0.9, Math.max(0.1, value3));
    return { mode: "fraction", value: clamped2 };
  }
  const value2 = typeof record.value === "number" && Number.isFinite(record.value) ? record.value : 400;
  const rounded = Math.floor(value2);
  const clamped = Math.min(1200, Math.max(300, rounded));
  return { mode: "px", value: clamped };
}
function isPresetTabType(value2) {
  if (typeof value2 !== "string") return false;
  if (value2 === "costs" || value2 === "review" || value2 === "explorer" || value2 === "stats") {
    return true;
  }
  return value2.startsWith("terminal_new:") && value2.length > "terminal_new:".length;
}
function isLayoutNode(value2) {
  if (!value2 || typeof value2 !== "object") return false;
  const v = value2;
  if (v.type === "tabset") {
    return typeof v.id === "string" && Array.isArray(v.tabs) && v.tabs.every((t) => isPresetTabType(t)) && isPresetTabType(v.activeTab);
  }
  if (v.type === "split") {
    if (typeof v.id !== "string") return false;
    if (v.direction !== "horizontal" && v.direction !== "vertical") return false;
    if (!Array.isArray(v.sizes) || v.sizes.length !== 2) return false;
    if (typeof v.sizes[0] !== "number" || typeof v.sizes[1] !== "number") return false;
    if (!Array.isArray(v.children) || v.children.length !== 2) return false;
    return isLayoutNode(v.children[0]) && isLayoutNode(v.children[1]);
  }
  return false;
}
function findTabset(root, tabsetId) {
  if (root.type === "tabset") {
    return root.id === tabsetId ? root : null;
  }
  return findTabset(root.children[0], tabsetId) ?? findTabset(root.children[1], tabsetId);
}
function isRightSidebarLayoutPresetState(value2) {
  if (!value2 || typeof value2 !== "object") return false;
  const v = value2;
  if (v.version !== 1) return false;
  if (typeof v.nextId !== "number") return false;
  if (typeof v.focusedTabsetId !== "string") return false;
  if (!isLayoutNode(v.root)) return false;
  return findTabset(v.root, v.focusedTabsetId) !== null;
}
function normalizeLayoutSlot(raw) {
  if (!raw || typeof raw !== "object") {
    return void 0;
  }
  const record = raw;
  if (!isLayoutSlotNumber(record.slot)) {
    return void 0;
  }
  const preset = normalizeLayoutPreset(record.preset);
  const keybindOverrideRaw = normalizeKeybind(record.keybindOverride);
  const keybindOverride = keybindOverrideRaw ? hasModifierKeybind(keybindOverrideRaw) ? keybindOverrideRaw : void 0 : void 0;
  if (!preset && !keybindOverride) {
    return void 0;
  }
  return {
    slot: record.slot,
    preset: preset ?? void 0,
    keybindOverride
  };
}
function normalizeLayoutSlotV1(raw) {
  if (!raw || typeof raw !== "object") {
    return void 0;
  }
  const record = raw;
  if (!isLayoutSlotNumber(record.slot)) {
    return void 0;
  }
  const presetId = normalizeOptionalNonEmptyString(record.presetId);
  const keybindOverrideRaw = normalizeKeybind(record.keybindOverride);
  const keybindOverride = keybindOverrideRaw ? hasModifierKeybind(keybindOverrideRaw) ? keybindOverrideRaw : void 0 : void 0;
  if (!presetId && !keybindOverride) {
    return void 0;
  }
  return {
    slot: record.slot,
    presetId,
    keybindOverride
  };
}
function normalizeLayoutPreset(raw) {
  if (!raw || typeof raw !== "object") {
    return void 0;
  }
  const record = raw;
  const id = normalizeOptionalNonEmptyString(record.id);
  const name25 = normalizeOptionalNonEmptyString(record.name);
  if (!id || !name25) {
    return void 0;
  }
  const leftSidebarCollapsed = typeof record.leftSidebarCollapsed === "boolean" ? record.leftSidebarCollapsed : false;
  const leftSidebarWidthPx = typeof record.leftSidebarWidthPx === "number" && Number.isFinite(record.leftSidebarWidthPx) ? Math.min(600, Math.max(200, Math.floor(record.leftSidebarWidthPx))) : void 0;
  if (!record.rightSidebar || typeof record.rightSidebar !== "object") {
    return void 0;
  }
  const rightSidebarRecord = record.rightSidebar;
  const collapsed = typeof rightSidebarRecord.collapsed === "boolean" ? rightSidebarRecord.collapsed : false;
  const width = normalizeRightSidebarWidthPreset(rightSidebarRecord.width);
  const layoutRaw = rightSidebarRecord.layout;
  if (!isRightSidebarLayoutPresetState(layoutRaw)) {
    return void 0;
  }
  const layout = layoutRaw;
  return {
    id,
    name: name25,
    leftSidebarCollapsed,
    leftSidebarWidthPx,
    rightSidebar: {
      collapsed,
      width,
      layout
    }
  };
}
function normalizeLayoutPresetsConfig(raw) {
  if (!raw || typeof raw !== "object") {
    return DEFAULT_LAYOUT_PRESETS_CONFIG;
  }
  const record = raw;
  if (record.version === 2) {
    return normalizeLayoutPresetsConfigV2(record);
  }
  if (record.version === 1) {
    return migrateLayoutPresetsConfigV1(record);
  }
  return DEFAULT_LAYOUT_PRESETS_CONFIG;
}
function normalizeLayoutPresetsConfigV2(record) {
  const slotsArray = Array.isArray(record.slots) ? record.slots : [];
  const slotsByNumber = /* @__PURE__ */ new Map();
  for (const entry of slotsArray) {
    const slot = normalizeLayoutSlot(entry);
    if (!slot) continue;
    slotsByNumber.set(slot.slot, slot);
  }
  const slots = Array.from(slotsByNumber.values()).sort((a, b) => a.slot - b.slot);
  const result = {
    version: 2,
    slots
  };
  assert_default(result.version === 2, "normalizeLayoutPresetsConfig: version must be 2");
  assert_default(Array.isArray(result.slots), "normalizeLayoutPresetsConfig: slots must be an array");
  return result;
}
function migrateLayoutPresetsConfigV1(record) {
  const presetsArray = Array.isArray(record.presets) ? record.presets : [];
  const presetsById = /* @__PURE__ */ new Map();
  for (const entry of presetsArray) {
    const preset = normalizeLayoutPreset(entry);
    if (!preset) continue;
    presetsById.set(preset.id, preset);
  }
  const slotsArray = Array.isArray(record.slots) ? record.slots : [];
  const slotsByNumber = /* @__PURE__ */ new Map();
  for (const entry of slotsArray) {
    const slot = normalizeLayoutSlotV1(entry);
    if (!slot) continue;
    const preset = slot.presetId ? presetsById.get(slot.presetId) : void 0;
    if (!preset && !slot.keybindOverride) {
      continue;
    }
    slotsByNumber.set(slot.slot, {
      slot: slot.slot,
      preset,
      keybindOverride: slot.keybindOverride
    });
  }
  const slots = Array.from(slotsByNumber.values()).sort((a, b) => a.slot - b.slot);
  const result = {
    version: 2,
    slots
  };
  assert_default(result.version === 2, "migrateLayoutPresetsConfigV1: version must be 2");
  assert_default(Array.isArray(result.slots), "migrateLayoutPresetsConfigV1: slots must be an array");
  return result;
}
function isLayoutPresetsConfigEmpty(value2) {
  assert_default(value2.version === 2, "isLayoutPresetsConfigEmpty: version must be 2");
  for (const slot of value2.slots) {
    if (slot.preset || slot.keybindOverride) {
      return false;
    }
  }
  return true;
}

// src/common/types/agentAiDefaults.ts
function normalizeAgentAiDefaults(raw) {
  const record = raw && typeof raw === "object" ? raw : {};
  const result = {};
  for (const [agentIdRaw, entryRaw] of Object.entries(record)) {
    const agentId = agentIdRaw.trim().toLowerCase();
    if (!agentId) continue;
    if (!AgentIdSchema.safeParse(agentId).success) continue;
    if (!entryRaw || typeof entryRaw !== "object") continue;
    const entry = entryRaw;
    const modelString = typeof entry.modelString === "string" && entry.modelString.trim().length > 0 ? entry.modelString.trim() : void 0;
    const thinkingLevel = coerceThinkingLevel(entry.thinkingLevel);
    const enabled = typeof entry.enabled === "boolean" ? entry.enabled : void 0;
    if (!modelString && !thinkingLevel && enabled === void 0) {
      continue;
    }
    result[agentId] = { modelString, thinkingLevel, enabled };
  }
  return result;
}

// src/common/constants/workspace.ts
var DEFAULT_RUNTIME_CONFIG = {
  type: "worktree",
  srcBaseDir: "~/.mux/src"
};

// src/common/utils/paths.ts
function isWindowsPlatform2() {
  if (typeof navigator !== "undefined" && navigator.platform) {
    return navigator.platform.toLowerCase().includes("win");
  }
  return false;
}
function getSeparator2() {
  return isWindowsPlatform2() ? "\\" : "/";
}
var PlatformPaths2 = class {
  /**
   * Get the appropriate path separator for the current platform
   */
  static get separator() {
    return getSeparator2();
  }
  /**
   * Extract basename from path (OS-aware)
   *
   * @param filePath - Path to extract basename from
   * @returns The final component of the path
   *
   * @example
   * // Unix
   * basename("/home/user/project") // => "project"
   *
   * // Windows
   * basename("C:\\Users\\user\\project") // => "project"
   */
  static basename(filePath) {
    if (!filePath || typeof filePath !== "string") {
      return filePath;
    }
    const lastSlash = isWindowsPlatform2() ? Math.max(filePath.lastIndexOf("/"), filePath.lastIndexOf("\\")) : filePath.lastIndexOf("/");
    if (lastSlash === -1) {
      return filePath;
    }
    return filePath.slice(lastSlash + 1);
  }
  /**
   * Split path into components (OS-aware)
   *
   * @param filePath - Path to parse
   * @returns Object with root, segments, and basename
   *
   * @example
   * // Unix
   * parse("/home/user/project") // => { root: "/", segments: ["home", "user"], basename: "project" }
   *
   * // Windows
   * parse("C:\\Users\\user\\project") // => { root: "C:\\", segments: ["Users", "user"], basename: "project" }
   */
  static parse(filePath) {
    if (!filePath || typeof filePath !== "string") {
      return { root: "", segments: [], basename: filePath };
    }
    const original = filePath;
    let root = "";
    let dir = "";
    let base = "";
    const lastSlash = isWindowsPlatform2() ? Math.max(original.lastIndexOf("/"), original.lastIndexOf("\\")) : original.lastIndexOf("/");
    if (lastSlash === -1) {
      base = original;
      dir = "";
    } else {
      base = original.slice(lastSlash + 1);
      dir = original.slice(0, lastSlash);
    }
    if (isWindowsPlatform2()) {
      const driveMatch = /^[A-Za-z]:[\\/]/.exec(original);
      if (driveMatch) {
        root = driveMatch[0];
        if (dir.startsWith(root)) {
          dir = dir.slice(root.length);
        }
      } else if (original.startsWith("\\\\")) {
        root = "\\\\";
        if (dir.startsWith(root)) {
          dir = dir.slice(root.length);
        }
      }
      if (!root && original.startsWith("/")) {
        root = "/";
        if (dir.startsWith(root)) {
          dir = dir.slice(root.length);
        }
      }
    } else if (original.startsWith("/")) {
      root = "/";
      if (dir.startsWith(root)) {
        dir = dir.slice(root.length);
      }
    }
    const separatorRegex = isWindowsPlatform2() ? /[\\/]+/ : /\/+/;
    const segments = dir ? dir.split(separatorRegex).filter(Boolean) : [];
    return {
      root,
      segments,
      basename: base
    };
  }
  /**
   * Format path for display with fish-style abbreviation (OS-aware)
   * Abbreviates all directory components except the last one to their first letter
   *
   * @param filePath - Path to abbreviate
   * @returns Abbreviated path
   *
   * @example
   * // Unix
   * abbreviate("/home/user/Projects/mux") // => "/h/u/P/mux"
   *
   * // Windows
   * abbreviate("C:\\Users\\john\\Documents\\project") // => "C:\\U\\j\\D\\project"
   */
  static abbreviate(filePath) {
    if (!filePath || typeof filePath !== "string") {
      return filePath;
    }
    const { root, segments, basename } = this.parse(filePath);
    const abbreviated = segments.map((seg) => seg.length > 0 ? seg[0] : seg);
    if (!root && abbreviated.length === 0) {
      return basename;
    }
    const sep = isWindowsPlatform2() ? filePath.includes("\\") ? "\\" : "/" : "/";
    const joined = [...abbreviated, basename].filter(Boolean).join(sep);
    if (!root) {
      return joined;
    }
    const rootEndsWithSep = root.endsWith("\\") || root.endsWith("/");
    return rootEndsWithSep ? root + joined : root + sep + joined;
  }
  /**
   * Split an abbreviated path into directory path and basename
   *
   * @param filePath - Abbreviated path
   * @returns Object with dirPath (including trailing separator) and basename
   *
   * @example
   * splitAbbreviated("/h/u/P/mux") // => { dirPath: "/h/u/P/", basename: "mux" }
   */
  static splitAbbreviated(filePath) {
    if (!filePath || typeof filePath !== "string") {
      return { dirPath: "", basename: filePath };
    }
    const sep = isWindowsPlatform2() ? filePath.includes("\\") ? "\\" : "/" : "/";
    const lastSlash = filePath.lastIndexOf(sep);
    if (lastSlash === -1) {
      return { dirPath: "", basename: filePath };
    }
    return {
      dirPath: filePath.slice(0, lastSlash + 1),
      basename: filePath.slice(lastSlash + 1)
    };
  }
  /**
   * NOTE: Home expansion and formatting helpers are main-only.
   * Use './paths.main' for expandHome/formatHome in Node contexts.
   */
  /**
   * Get project name from path (OS-aware)
   * Extracts the final directory name from a project path
   *
   * @param projectPath - Path to the project
   * @returns Project name (final directory component)
   *
   * @example
   * getProjectName("/home/user/projects/mux") // => "mux"
   * getProjectName("C:\\Users\\john\\projects\\mux") // => "mux"
   */
  static getProjectName(projectPath) {
    return this.basename(projectPath) || "unknown";
  }
};

// src/common/utils/ai/modelDisplay.ts
function formatModelDisplayName(modelName) {
  const bedrockParsed = parseBedrockModelName(modelName);
  if (bedrockParsed) {
    modelName = bedrockParsed;
  }
  const lower = modelName.toLowerCase();
  if (lower.startsWith("claude-")) {
    const parts = lower.replace("claude-", "").split("-");
    const tiers = ["sonnet", "opus", "haiku"];
    if (parts.length >= 3 && tiers.includes(parts[0])) {
      const tier = capitalize(parts[0]);
      const version = formatVersion(parts.slice(1));
      return `${tier} ${version}`;
    }
    if (parts.length >= 3) {
      const tierIdx = parts.findIndex((p) => tiers.includes(p));
      if (tierIdx > 0) {
        const tier = capitalize(parts[tierIdx]);
        const version = formatVersion(parts.slice(0, tierIdx));
        return `${tier} ${version}`;
      }
    }
    if (parts.length === 2 && tiers.includes(parts[0])) {
      const tier = capitalize(parts[0]);
      return `${tier} ${parts[1]}`;
    }
  }
  if (lower.startsWith("gpt-")) {
    const parts = lower.split("-");
    if (parts.length >= 2) {
      const base = `GPT-${parts[1]}`;
      const rest = parts.slice(2).map(capitalize).join(" ");
      return rest ? `${base} ${rest}` : base;
    }
  }
  if (lower.startsWith("gemini-")) {
    const parts = lower.replace("gemini-", "").split("-");
    const versionParts = [];
    const nameParts = [];
    for (const part of parts) {
      if (versionParts.length < 2 && /^\d+$/.test(part)) {
        versionParts.push(part);
      } else {
        nameParts.push(capitalize(part));
      }
    }
    const version = versionParts.length > 0 ? versionParts.join(".") : "";
    const name25 = nameParts.join(" ");
    if (version && name25) {
      return `Gemini ${version} ${name25}`;
    } else if (version) {
      return `Gemini ${version}`;
    } else if (name25) {
      return `Gemini ${name25}`;
    }
  }
  const [baseName, size] = modelName.split(":");
  if (size) {
    const formatted = baseName.split(/(\d+\.?\d*)/).map((part, idx) => {
      if (idx === 0) return capitalize(part);
      if (/^\d+\.?\d*$/.test(part)) return ` ${part}`;
      return part;
    }).join("");
    return `${formatted.trim()} (${size.toUpperCase()})`;
  }
  return modelName.split("-").map(capitalize).join(" ");
}
function capitalize(str) {
  if (!str) return str;
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function formatVersion(parts) {
  return parts.join(".");
}
function parseBedrockModelName(modelId) {
  if (!modelId.includes(".")) {
    return null;
  }
  const dotParts = modelId.split(".");
  if (dotParts.length < 2) {
    return null;
  }
  const knownVendors = ["anthropic", "amazon", "meta", "cohere", "mistral", "ai21"];
  const knownRegionPrefixes = ["global", "us", "eu", "ap", "sa"];
  const firstPart = dotParts[0].toLowerCase();
  const secondPart = dotParts.length > 1 ? dotParts[1].toLowerCase() : "";
  const isVendor = knownVendors.includes(firstPart);
  const isRegionPrefix = knownRegionPrefixes.some(
    (prefix) => firstPart === prefix || firstPart.startsWith(`${prefix}-`)
  );
  const secondPartIsVendor = knownVendors.includes(secondPart);
  if (!isVendor && !(isRegionPrefix && secondPartIsVendor)) {
    return null;
  }
  const rawModelName = dotParts[dotParts.length - 1];
  const withoutVersion = rawModelName.split(":")[0];
  const dateVersionPattern = /-\d{8}-v\d+$/;
  const versionOnlyPattern = /-v\d+$/;
  const cleanedName = withoutVersion.replace(dateVersionPattern, "").replace(versionOnlyPattern, "");
  return cleanedName;
}

// src/common/constants/knownModels.ts
var MODEL_DEFINITIONS = {
  OPUS: {
    provider: "anthropic",
    providerModelId: "claude-opus-4-6",
    aliases: ["opus"],
    warm: true
  },
  SONNET: {
    provider: "anthropic",
    providerModelId: "claude-sonnet-4-5",
    aliases: ["sonnet"],
    warm: true,
    tokenizerOverride: "anthropic/claude-sonnet-4.5"
  },
  HAIKU: {
    provider: "anthropic",
    providerModelId: "claude-haiku-4-5",
    aliases: ["haiku"],
    tokenizerOverride: "anthropic/claude-3.5-haiku"
  },
  GPT: {
    provider: "openai",
    providerModelId: "gpt-5.2",
    aliases: ["gpt"],
    warm: true,
    tokenizerOverride: "openai/gpt-5"
  },
  GPT_PRO: {
    provider: "openai",
    providerModelId: "gpt-5.2-pro",
    aliases: ["gpt-pro"]
  },
  GPT_52_CODEX: {
    provider: "openai",
    providerModelId: "gpt-5.2-codex",
    aliases: ["codex"],
    warm: true,
    tokenizerOverride: "openai/gpt-5"
  },
  GPT_53_CODEX: {
    provider: "openai",
    providerModelId: "gpt-5.3-codex",
    aliases: ["codex-5.3"],
    warm: true,
    tokenizerOverride: "openai/gpt-5"
  },
  GPT_CODEX: {
    provider: "openai",
    providerModelId: "gpt-5.1-codex",
    aliases: ["codex-5.1"],
    warm: true,
    tokenizerOverride: "openai/gpt-5"
  },
  GPT_MINI: {
    provider: "openai",
    providerModelId: "gpt-5.1-codex-mini",
    aliases: ["codex-mini"]
  },
  GPT_CODEX_MAX: {
    provider: "openai",
    providerModelId: "gpt-5.1-codex-max",
    aliases: ["codex-max"],
    warm: true,
    tokenizerOverride: "openai/gpt-5"
  },
  GEMINI_3_PRO: {
    provider: "google",
    providerModelId: "gemini-3-pro-preview",
    aliases: ["gemini", "gemini-3", "gemini-3-pro"],
    tokenizerOverride: "google/gemini-2.5-pro"
  },
  GEMINI_3_FLASH: {
    provider: "google",
    providerModelId: "gemini-3-flash-preview",
    aliases: ["gemini-3-flash"],
    tokenizerOverride: "google/gemini-2.5-pro"
  },
  GROK_4_1: {
    provider: "xai",
    providerModelId: "grok-4-1-fast",
    aliases: ["grok", "grok-4", "grok-4.1", "grok-4-1"]
  },
  GROK_CODE: {
    provider: "xai",
    providerModelId: "grok-code-fast-1",
    aliases: ["grok-code"]
  }
};
var MODEL_DEFINITION_ENTRIES = Object.entries(MODEL_DEFINITIONS);
var KNOWN_MODELS = Object.fromEntries(
  MODEL_DEFINITION_ENTRIES.map(([key, definition]) => toKnownModelEntry(key, definition))
);
function toKnownModelEntry(key, definition) {
  return [
    key,
    {
      ...definition,
      id: `${definition.provider}:${definition.providerModelId}`
    }
  ];
}
var DEFAULT_KNOWN_MODEL_KEY = "OPUS";
var DEFAULT_MODEL = KNOWN_MODELS[DEFAULT_KNOWN_MODEL_KEY].id;
var DEFAULT_WARM_MODELS = Object.values(KNOWN_MODELS).filter((model) => model.warm).map((model) => model.id);
var MODEL_ABBREVIATIONS = Object.fromEntries(
  Object.values(KNOWN_MODELS).flatMap((model) => (model.aliases ?? []).map((alias) => [alias, model.id])).sort(([a], [b]) => a.localeCompare(b))
);
var TOKENIZER_MODEL_OVERRIDES = Object.fromEntries(
  Object.values(KNOWN_MODELS).filter((model) => Boolean(model.tokenizerOverride)).map((model) => [model.id, model.tokenizerOverride])
);
var MODEL_ABBREVIATION_EXAMPLES = ["opus", "sonnet"].map((abbrev) => ({
  abbrev,
  displayName: formatModelDisplayName(MODEL_ABBREVIATIONS[abbrev]?.split(":")[1] ?? abbrev)
}));

// src/common/utils/ai/models.ts
function isValidModelFormat(model) {
  const colonIndex = model.indexOf(":");
  return colonIndex > 0 && colonIndex < model.length - 1;
}
var MUX_GATEWAY_PREFIX = "mux-gateway:";
function normalizeGatewayModel(modelString) {
  if (!modelString.startsWith(MUX_GATEWAY_PREFIX)) {
    return modelString;
  }
  const inner = modelString.slice(MUX_GATEWAY_PREFIX.length);
  const slashIndex = inner.indexOf("/");
  if (slashIndex === -1) {
    return modelString;
  }
  return `${inner.slice(0, slashIndex)}:${inner.slice(slashIndex + 1)}`;
}

// src/node/config.ts
function parseOptionalNonEmptyString(value2) {
  if (typeof value2 !== "string") {
    return void 0;
  }
  const trimmed = value2.trim();
  return trimmed ? trimmed : void 0;
}
function parseOptionalEnvBoolean(value2) {
  if (typeof value2 !== "string") {
    return void 0;
  }
  const normalized = value2.trim().toLowerCase();
  if (!normalized) {
    return void 0;
  }
  if (normalized === "1" || normalized === "true" || normalized === "yes" || normalized === "on") {
    return true;
  }
  if (normalized === "0" || normalized === "false" || normalized === "no" || normalized === "off") {
    return false;
  }
  return void 0;
}
function parseOptionalBoolean(value2) {
  return typeof value2 === "boolean" ? value2 : void 0;
}
function parseOptionalStringArray(value2) {
  if (!Array.isArray(value2)) {
    return void 0;
  }
  return value2.filter((item) => typeof item === "string");
}
function normalizeOptionalModelString(value2) {
  if (typeof value2 !== "string") {
    return void 0;
  }
  const trimmed = value2.trim();
  if (!trimmed) {
    return void 0;
  }
  if (trimmed.startsWith("mux-gateway:") && !trimmed.includes("/")) {
    return void 0;
  }
  const normalized = normalizeGatewayModel(trimmed);
  if (!isValidModelFormat(normalized)) {
    return void 0;
  }
  return normalized;
}
function normalizeOptionalModelStringArray(value2) {
  if (!Array.isArray(value2)) {
    return void 0;
  }
  const out = [];
  const seen = /* @__PURE__ */ new Set();
  for (const item of value2) {
    const normalized = normalizeOptionalModelString(item);
    if (!normalized) continue;
    if (seen.has(normalized)) continue;
    seen.add(normalized);
    out.push(normalized);
  }
  return out;
}
function parseOptionalPort(value2) {
  if (typeof value2 !== "number" || !Number.isFinite(value2) || !Number.isInteger(value2)) {
    return void 0;
  }
  if (value2 < 0 || value2 > 65535) {
    return void 0;
  }
  return value2;
}
var Config = class _Config {
  constructor(rootDir) {
    this.rootDir = rootDir ?? getMuxHome();
    this.sessionsDir = path17.join(this.rootDir, "sessions");
    this.srcDir = path17.join(this.rootDir, "src");
    this.configFile = path17.join(this.rootDir, "config.json");
    this.providersFile = path17.join(this.rootDir, "providers.jsonc");
    this.secretsFile = path17.join(this.rootDir, "secrets.json");
  }
  loadConfigOrDefault() {
    try {
      if (fs9.existsSync(this.configFile)) {
        const data = fs9.readFileSync(this.configFile, "utf-8");
        const parsed = JSON.parse(data);
        if (parsed.projects && Array.isArray(parsed.projects)) {
          const rawPairs = parsed.projects;
          const normalizedPairs = rawPairs.filter(([projectPath]) => {
            if (!projectPath || typeof projectPath !== "string") {
              log.warn("Filtering out project with invalid path", { projectPath });
              return false;
            }
            return true;
          }).map(([projectPath, projectConfig]) => {
            return [stripTrailingSlashes(projectPath), projectConfig];
          });
          const projectsMap = new Map(normalizedPairs);
          const taskSettings = normalizeTaskSettings(parsed.taskSettings);
          const muxGatewayEnabled = parseOptionalBoolean(parsed.muxGatewayEnabled);
          const muxGatewayModels = parseOptionalStringArray(parsed.muxGatewayModels);
          const defaultModel = normalizeOptionalModelString(parsed.defaultModel);
          const hiddenModels = normalizeOptionalModelStringArray(parsed.hiddenModels);
          const preferredCompactionModel = normalizeOptionalModelString(
            parsed.preferredCompactionModel
          );
          const legacySubagentAiDefaults = normalizeSubagentAiDefaults(parsed.subagentAiDefaults);
          const stopCoderWorkspaceOnArchive = parseOptionalBoolean(parsed.stopCoderWorkspaceOnArchive) === false ? false : void 0;
          const agentAiDefaults = parsed.agentAiDefaults !== void 0 ? normalizeAgentAiDefaults(parsed.agentAiDefaults) : normalizeAgentAiDefaults(legacySubagentAiDefaults);
          const layoutPresetsRaw = normalizeLayoutPresetsConfig(parsed.layoutPresets);
          const layoutPresets = isLayoutPresetsConfigEmpty(layoutPresetsRaw) ? void 0 : layoutPresetsRaw;
          return {
            projects: projectsMap,
            apiServerBindHost: parseOptionalNonEmptyString(parsed.apiServerBindHost),
            apiServerServeWebUi: parseOptionalBoolean(parsed.apiServerServeWebUi) ? true : void 0,
            apiServerPort: parseOptionalPort(parsed.apiServerPort),
            mdnsAdvertisementEnabled: parseOptionalBoolean(parsed.mdnsAdvertisementEnabled),
            mdnsServiceName: parseOptionalNonEmptyString(parsed.mdnsServiceName),
            serverSshHost: parsed.serverSshHost,
            viewedSplashScreens: parsed.viewedSplashScreens,
            layoutPresets,
            taskSettings,
            muxGatewayEnabled,
            muxGatewayModels,
            defaultModel,
            hiddenModels,
            preferredCompactionModel,
            agentAiDefaults,
            // Legacy fields are still parsed and returned for downgrade compatibility.
            subagentAiDefaults: legacySubagentAiDefaults,
            featureFlagOverrides: parsed.featureFlagOverrides,
            useSSH2Transport: parseOptionalBoolean(parsed.useSSH2Transport),
            muxGovernorUrl: parseOptionalNonEmptyString(parsed.muxGovernorUrl),
            muxGovernorToken: parseOptionalNonEmptyString(parsed.muxGovernorToken),
            stopCoderWorkspaceOnArchive,
            customModelPrices: parsed.customModelPrices,
            iconThemeConfig: parsed.iconThemeConfig
          };
        }
      }
    } catch (error) {
      log.error("Error loading config:", error);
    }
    return {
      projects: /* @__PURE__ */ new Map(),
      taskSettings: DEFAULT_TASK_SETTINGS,
      agentAiDefaults: {},
      subagentAiDefaults: {}
    };
  }
  async saveConfig(config2) {
    try {
      if (!fs9.existsSync(this.rootDir)) {
        fs9.mkdirSync(this.rootDir, { recursive: true });
      }
      const data = {
        projects: Array.from(config2.projects.entries()),
        taskSettings: config2.taskSettings ?? DEFAULT_TASK_SETTINGS
      };
      const muxGatewayEnabled = parseOptionalBoolean(config2.muxGatewayEnabled);
      if (muxGatewayEnabled !== void 0) {
        data.muxGatewayEnabled = muxGatewayEnabled;
      }
      const muxGatewayModels = parseOptionalStringArray(config2.muxGatewayModels);
      if (muxGatewayModels !== void 0) {
        data.muxGatewayModels = muxGatewayModels;
      }
      const defaultModel = normalizeOptionalModelString(config2.defaultModel);
      if (defaultModel !== void 0) {
        data.defaultModel = defaultModel;
      }
      const hiddenModels = normalizeOptionalModelStringArray(config2.hiddenModels);
      if (hiddenModels !== void 0) {
        data.hiddenModels = hiddenModels;
      }
      const preferredCompactionModel = normalizeOptionalModelString(
        config2.preferredCompactionModel
      );
      if (preferredCompactionModel !== void 0) {
        data.preferredCompactionModel = preferredCompactionModel;
      }
      const apiServerBindHost = parseOptionalNonEmptyString(config2.apiServerBindHost);
      if (apiServerBindHost) {
        data.apiServerBindHost = apiServerBindHost;
      }
      const apiServerServeWebUi = parseOptionalBoolean(config2.apiServerServeWebUi);
      if (apiServerServeWebUi) {
        data.apiServerServeWebUi = true;
      }
      const apiServerPort = parseOptionalPort(config2.apiServerPort);
      if (apiServerPort !== void 0) {
        data.apiServerPort = apiServerPort;
      }
      const mdnsAdvertisementEnabled = parseOptionalBoolean(config2.mdnsAdvertisementEnabled);
      if (mdnsAdvertisementEnabled !== void 0) {
        data.mdnsAdvertisementEnabled = mdnsAdvertisementEnabled;
      }
      const mdnsServiceName = parseOptionalNonEmptyString(config2.mdnsServiceName);
      if (mdnsServiceName) {
        data.mdnsServiceName = mdnsServiceName;
      }
      if (config2.serverSshHost) {
        data.serverSshHost = config2.serverSshHost;
      }
      if (config2.featureFlagOverrides) {
        data.featureFlagOverrides = config2.featureFlagOverrides;
      }
      if (config2.layoutPresets) {
        const normalized = normalizeLayoutPresetsConfig(config2.layoutPresets);
        if (!isLayoutPresetsConfigEmpty(normalized)) {
          data.layoutPresets = normalized;
        }
      }
      if (config2.viewedSplashScreens) {
        data.viewedSplashScreens = config2.viewedSplashScreens;
      }
      if (config2.agentAiDefaults && Object.keys(config2.agentAiDefaults).length > 0) {
        data.agentAiDefaults = config2.agentAiDefaults;
        const legacySubagent = {};
        for (const [id, entry] of Object.entries(config2.agentAiDefaults)) {
          if (id === "plan" || id === "exec" || id === "compact") continue;
          legacySubagent[id] = entry;
        }
        if (Object.keys(legacySubagent).length > 0) {
          data.subagentAiDefaults = legacySubagent;
        }
      } else {
        if (config2.subagentAiDefaults && Object.keys(config2.subagentAiDefaults).length > 0) {
          data.subagentAiDefaults = config2.subagentAiDefaults;
        }
      }
      if (config2.useSSH2Transport !== void 0) {
        data.useSSH2Transport = config2.useSSH2Transport;
      }
      const muxGovernorUrl = parseOptionalNonEmptyString(config2.muxGovernorUrl);
      if (muxGovernorUrl) {
        data.muxGovernorUrl = muxGovernorUrl;
      }
      const muxGovernorToken = parseOptionalNonEmptyString(config2.muxGovernorToken);
      if (muxGovernorToken) {
        data.muxGovernorToken = muxGovernorToken;
      }
      if (config2.stopCoderWorkspaceOnArchive === false) {
        data.stopCoderWorkspaceOnArchive = false;
      }
      if (config2.customModelPrices) {
        data.customModelPrices = config2.customModelPrices;
      }
      if (config2.iconThemeConfig) {
        data.iconThemeConfig = config2.iconThemeConfig;
      }
      await (0, import_write_file_atomic.default)(this.configFile, JSON.stringify(data, null, 2), "utf-8");
    } catch (error) {
      log.error("Error saving config:", error);
    }
  }
  /**
   * Edit config atomically using a transformation function
   * @param fn Function that takes current config and returns modified config
   */
  async editConfig(fn) {
    const config2 = this.loadConfigOrDefault();
    const newConfig = fn(config2);
    await this.saveConfig(newConfig);
  }
  /**
   * Cross-client feature flag overrides (shared via ~/.mux/config.json).
   */
  getFeatureFlagOverride(flagKey) {
    const config2 = this.loadConfigOrDefault();
    const override = config2.featureFlagOverrides?.[flagKey];
    if (override === "on" || override === "off" || override === "default") {
      return override;
    }
    return "default";
  }
  async setFeatureFlagOverride(flagKey, override) {
    await this.editConfig((config2) => {
      const next = { ...config2.featureFlagOverrides ?? {} };
      if (override === "default") {
        delete next[flagKey];
      } else {
        next[flagKey] = override;
      }
      config2.featureFlagOverrides = Object.keys(next).length > 0 ? next : void 0;
      return config2;
    });
  }
  /**
   * mDNS advertisement enablement.
   *
   * - true: attempt to advertise (will warn if the API server is loopback-only)
   * - false: never advertise
   * - undefined: "auto" (advertise only when the API server is LAN-reachable)
   */
  getMdnsAdvertisementEnabled() {
    const envOverride = parseOptionalEnvBoolean(process.env.MUX_MDNS_ADVERTISE);
    if (envOverride !== void 0) {
      return envOverride;
    }
    const config2 = this.loadConfigOrDefault();
    return config2.mdnsAdvertisementEnabled;
  }
  /** Optional DNS-SD service instance name override. */
  getMdnsServiceName() {
    const envName = parseOptionalNonEmptyString(process.env.MUX_MDNS_SERVICE_NAME);
    if (envName) {
      return envName;
    }
    const config2 = this.loadConfigOrDefault();
    return config2.mdnsServiceName;
  }
  /**
   * Get the configured SSH hostname for this server (used for editor deep links in browser mode).
   */
  getServerSshHost() {
    const config2 = this.loadConfigOrDefault();
    return config2.serverSshHost;
  }
  getProjectName(projectPath) {
    return PlatformPaths2.getProjectName(projectPath);
  }
  /**
   * Generate a stable unique workspace ID.
   * Uses 10 random hex characters for readability while maintaining uniqueness.
   *
   * Example: "a1b2c3d4e5"
   */
  generateStableId() {
    return crypto4.randomBytes(5).toString("hex");
  }
  /**
   * DEPRECATED: Generate legacy workspace ID from project and workspace paths.
   * This method is used only for legacy workspace migration to look up old workspaces.
   * New workspaces use generateStableId() which returns a random stable ID.
   *
   * DO NOT use this method or its format to construct workspace IDs anywhere in the codebase.
   * Workspace IDs are backend implementation details and must only come from backend operations.
   */
  generateLegacyId(projectPath, workspacePath) {
    const projectBasename = this.getProjectName(projectPath);
    const workspaceBasename = PlatformPaths2.basename(workspacePath);
    return `${projectBasename}-${workspaceBasename}`;
  }
  /**
   * Get the workspace directory path for a given directory name.
   * The directory name is the workspace name (branch name).
   */
  /**
   * Add paths to WorkspaceMetadata to create FrontendWorkspaceMetadata.
   * Helper to avoid duplicating path computation logic.
   */
  addPathsToMetadata(metadata, workspacePath, _projectPath) {
    const result = {
      ...metadata,
      namedWorkspacePath: workspacePath
    };
    if (isIncompatibleRuntimeConfig(metadata.runtimeConfig)) {
      result.incompatibleRuntime = "This workspace was created with a newer version of mux. Please upgrade mux to use this workspace.";
    }
    return result;
  }
  /**
   * Find a workspace path and project path by workspace ID
   * @returns Object with workspace and project paths, or null if not found
   */
  findWorkspace(workspaceId) {
    const config2 = this.loadConfigOrDefault();
    for (const [projectPath, project] of config2.projects) {
      for (const workspace2 of project.workspaces) {
        if (workspace2.id === workspaceId) {
          return { workspacePath: workspace2.path, projectPath };
        }
        if (!workspace2.id) {
          const workspaceBasename = workspace2.path.split("/").pop() ?? workspace2.path.split("\\").pop() ?? "unknown";
          const metadataPath = path17.join(this.getSessionDir(workspaceBasename), "metadata.json");
          if (fs9.existsSync(metadataPath)) {
            try {
              const data = fs9.readFileSync(metadataPath, "utf-8");
              const metadata = JSON.parse(data);
              if (metadata.id === workspaceId) {
                return { workspacePath: workspace2.path, projectPath };
              }
            } catch {
            }
          }
          const legacyId = this.generateLegacyId(projectPath, workspace2.path);
          if (legacyId === workspaceId) {
            return { workspacePath: workspace2.path, projectPath };
          }
        }
      }
    }
    return null;
  }
  /**
   * Workspace Path Architecture:
   *
   * Workspace paths are computed on-demand from projectPath + workspace name using
   * config.getWorkspacePath(projectPath, directoryName). This ensures a single source of truth.
   *
   * - Worktree directory name: uses workspace.name (the branch name)
   * - Workspace ID: stable random identifier for identity and sessions (not used for directories)
   *
   * Backend: Uses getWorkspacePath(metadata.projectPath, metadata.name) for workspace directory paths
   * Frontend: Gets enriched metadata with paths via IPC (FrontendWorkspaceMetadata)
   *
   * WorkspaceMetadata.workspacePath is deprecated and will be removed. Use computed
   * paths from getWorkspacePath() or getWorkspacePaths() instead.
   */
  /**
   * Get the session directory for a specific workspace
   */
  getSessionDir(workspaceId) {
    return path17.join(this.sessionsDir, workspaceId);
  }
  /**
   * Get all workspace metadata by loading config and metadata files.
   *
   * Returns FrontendWorkspaceMetadata with paths already computed.
   * This eliminates the need for separate "enrichment" - paths are computed
   * once during the loop when we already have all the necessary data.
   *
   * NEW BEHAVIOR: Config is the primary source of truth
   * - If workspace has id/name/createdAt in config, use those directly
   * - If workspace only has path, fall back to reading metadata.json
   * - Migrate old workspaces by copying metadata from files to config
   *
   * This centralizes workspace metadata in config.json and eliminates the need
   * for scattered metadata.json files (kept for backward compat with older versions).
   *
   * GUARANTEE: Every workspace returned will have a createdAt timestamp.
   * If missing from config or legacy metadata, a new timestamp is assigned and
   * saved to config for subsequent loads.
   */
  async getAllWorkspaceMetadata() {
    const config2 = this.loadConfigOrDefault();
    const workspaceMetadata = [];
    let configModified = false;
    for (const [projectPath, projectConfig] of config2.projects) {
      if (!projectPath) {
        log.warn("Skipping project with empty path in config", {
          workspaceCount: projectConfig.workspaces?.length ?? 0
        });
        continue;
      }
      const projectName = this.getProjectName(projectPath);
      for (const workspace2 of projectConfig.workspaces) {
        const workspaceBasename = workspace2.path.split("/").pop() ?? workspace2.path.split("\\").pop() ?? "unknown";
        try {
          if (workspace2.id && workspace2.name) {
            const metadata = {
              id: workspace2.id,
              name: workspace2.name,
              title: workspace2.title,
              projectName,
              projectPath,
              // GUARANTEE: All workspaces must have createdAt (assign now if missing)
              createdAt: workspace2.createdAt ?? (/* @__PURE__ */ new Date()).toISOString(),
              // GUARANTEE: All workspaces must have runtimeConfig (apply default if missing)
              runtimeConfig: workspace2.runtimeConfig ?? DEFAULT_RUNTIME_CONFIG,
              aiSettings: workspace2.aiSettings,
              aiSettingsByAgent: workspace2.aiSettingsByAgent ?? (workspace2.aiSettings ? {
                plan: workspace2.aiSettings,
                exec: workspace2.aiSettings
              } : void 0),
              parentWorkspaceId: workspace2.parentWorkspaceId,
              agentType: workspace2.agentType,
              taskStatus: workspace2.taskStatus,
              reportedAt: workspace2.reportedAt,
              taskModelString: workspace2.taskModelString,
              taskThinkingLevel: workspace2.taskThinkingLevel,
              taskPrompt: workspace2.taskPrompt,
              taskTrunkBranch: workspace2.taskTrunkBranch,
              archivedAt: workspace2.archivedAt,
              unarchivedAt: workspace2.unarchivedAt,
              sectionId: workspace2.sectionId
            };
            if (!workspace2.createdAt) {
              workspace2.createdAt = metadata.createdAt;
              configModified = true;
            }
            if (!workspace2.aiSettingsByAgent) {
              const derived = workspace2.aiSettings ? {
                plan: workspace2.aiSettings,
                exec: workspace2.aiSettings
              } : void 0;
              if (derived) {
                workspace2.aiSettingsByAgent = derived;
                configModified = true;
              }
            }
            if (!workspace2.runtimeConfig) {
              workspace2.runtimeConfig = metadata.runtimeConfig;
              configModified = true;
            }
            if (metadata.runtimeConfig?.type === "docker" && !metadata.runtimeConfig.containerName) {
              metadata.runtimeConfig = {
                ...metadata.runtimeConfig,
                containerName: getContainerName(projectPath, metadata.name)
              };
            }
            workspaceMetadata.push(this.addPathsToMetadata(metadata, workspace2.path, projectPath));
            continue;
          }
          const legacyId = this.generateLegacyId(projectPath, workspace2.path);
          const metadataPath = path17.join(this.getSessionDir(legacyId), "metadata.json");
          let metadataFound = false;
          if (fs9.existsSync(metadataPath)) {
            const data = fs9.readFileSync(metadataPath, "utf-8");
            const metadata = JSON.parse(data);
            if (!metadata.name) metadata.name = workspaceBasename;
            if (!metadata.projectPath) metadata.projectPath = projectPath;
            if (!metadata.projectName) metadata.projectName = projectName;
            metadata.createdAt ??= (/* @__PURE__ */ new Date()).toISOString();
            metadata.runtimeConfig ??= DEFAULT_RUNTIME_CONFIG;
            metadata.aiSettingsByAgent ??= workspace2.aiSettingsByAgent ?? (workspace2.aiSettings ? {
              plan: workspace2.aiSettings,
              exec: workspace2.aiSettings
            } : void 0);
            metadata.aiSettings ??= workspace2.aiSettings;
            metadata.parentWorkspaceId ??= workspace2.parentWorkspaceId;
            metadata.agentType ??= workspace2.agentType;
            metadata.taskStatus ??= workspace2.taskStatus;
            metadata.reportedAt ??= workspace2.reportedAt;
            metadata.taskModelString ??= workspace2.taskModelString;
            metadata.taskThinkingLevel ??= workspace2.taskThinkingLevel;
            metadata.taskPrompt ??= workspace2.taskPrompt;
            metadata.taskTrunkBranch ??= workspace2.taskTrunkBranch;
            metadata.archivedAt ??= workspace2.archivedAt;
            metadata.unarchivedAt ??= workspace2.unarchivedAt;
            metadata.sectionId ??= workspace2.sectionId;
            if (!workspace2.aiSettingsByAgent && metadata.aiSettingsByAgent) {
              workspace2.aiSettingsByAgent = metadata.aiSettingsByAgent;
              configModified = true;
            }
            workspace2.id = metadata.id;
            workspace2.name = metadata.name;
            workspace2.createdAt = metadata.createdAt;
            workspace2.runtimeConfig = metadata.runtimeConfig;
            configModified = true;
            workspaceMetadata.push(this.addPathsToMetadata(metadata, workspace2.path, projectPath));
            metadataFound = true;
          }
          if (!metadataFound) {
            const legacyId2 = this.generateLegacyId(projectPath, workspace2.path);
            const metadata = {
              id: legacyId2,
              name: workspaceBasename,
              projectName,
              projectPath,
              // GUARANTEE: All workspaces must have createdAt
              createdAt: (/* @__PURE__ */ new Date()).toISOString(),
              // GUARANTEE: All workspaces must have runtimeConfig
              runtimeConfig: DEFAULT_RUNTIME_CONFIG,
              aiSettings: workspace2.aiSettings,
              aiSettingsByAgent: workspace2.aiSettingsByAgent ?? (workspace2.aiSettings ? {
                plan: workspace2.aiSettings,
                exec: workspace2.aiSettings
              } : void 0),
              parentWorkspaceId: workspace2.parentWorkspaceId,
              agentType: workspace2.agentType,
              taskStatus: workspace2.taskStatus,
              reportedAt: workspace2.reportedAt,
              taskModelString: workspace2.taskModelString,
              taskThinkingLevel: workspace2.taskThinkingLevel,
              taskPrompt: workspace2.taskPrompt,
              taskTrunkBranch: workspace2.taskTrunkBranch,
              archivedAt: workspace2.archivedAt,
              unarchivedAt: workspace2.unarchivedAt,
              sectionId: workspace2.sectionId
            };
            workspace2.id = metadata.id;
            workspace2.name = metadata.name;
            workspace2.createdAt = metadata.createdAt;
            workspace2.runtimeConfig = metadata.runtimeConfig;
            configModified = true;
            workspaceMetadata.push(this.addPathsToMetadata(metadata, workspace2.path, projectPath));
          }
        } catch (error) {
          log.error(`Failed to load/migrate workspace metadata:`, error);
          const legacyId = this.generateLegacyId(projectPath, workspace2.path);
          const metadata = {
            id: legacyId,
            name: workspaceBasename,
            projectName,
            projectPath,
            // GUARANTEE: All workspaces must have createdAt (even in error cases)
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            // GUARANTEE: All workspaces must have runtimeConfig (even in error cases)
            runtimeConfig: DEFAULT_RUNTIME_CONFIG,
            aiSettings: workspace2.aiSettings,
            aiSettingsByAgent: workspace2.aiSettingsByAgent ?? (workspace2.aiSettings ? {
              plan: workspace2.aiSettings,
              exec: workspace2.aiSettings
            } : void 0),
            parentWorkspaceId: workspace2.parentWorkspaceId,
            agentType: workspace2.agentType,
            taskStatus: workspace2.taskStatus,
            reportedAt: workspace2.reportedAt,
            taskModelString: workspace2.taskModelString,
            taskThinkingLevel: workspace2.taskThinkingLevel,
            taskPrompt: workspace2.taskPrompt,
            taskTrunkBranch: workspace2.taskTrunkBranch,
            sectionId: workspace2.sectionId
          };
          workspaceMetadata.push(this.addPathsToMetadata(metadata, workspace2.path, projectPath));
        }
      }
    }
    if (configModified) {
      await this.saveConfig(config2);
    }
    return workspaceMetadata;
  }
  /**
   * Add a workspace to config.json (single source of truth for workspace metadata).
   * Creates project entry if it doesn't exist.
   *
   * @param projectPath Absolute path to the project
   * @param metadata Workspace metadata to save
   */
  async addWorkspace(projectPath, metadata) {
    await this.editConfig((config2) => {
      let project = config2.projects.get(projectPath);
      if (!project) {
        project = { workspaces: [] };
        config2.projects.set(projectPath, project);
      }
      const existingIndex = project.workspaces.findIndex((w) => w.id === metadata.id);
      const projectName = this.getProjectName(projectPath);
      const workspacePath = metadata.namedWorkspacePath ?? path17.join(this.srcDir, projectName, metadata.name);
      const workspaceEntry = {
        path: workspacePath,
        id: metadata.id,
        name: metadata.name,
        title: metadata.title,
        createdAt: metadata.createdAt,
        aiSettingsByAgent: metadata.aiSettingsByAgent,
        runtimeConfig: metadata.runtimeConfig,
        aiSettings: metadata.aiSettings,
        parentWorkspaceId: metadata.parentWorkspaceId,
        agentType: metadata.agentType,
        agentId: metadata.agentId,
        taskStatus: metadata.taskStatus,
        reportedAt: metadata.reportedAt,
        taskModelString: metadata.taskModelString,
        taskThinkingLevel: metadata.taskThinkingLevel,
        taskPrompt: metadata.taskPrompt,
        taskTrunkBranch: metadata.taskTrunkBranch,
        archivedAt: metadata.archivedAt,
        unarchivedAt: metadata.unarchivedAt,
        sectionId: metadata.sectionId
      };
      if (existingIndex >= 0) {
        project.workspaces[existingIndex] = workspaceEntry;
      } else {
        project.workspaces.push(workspaceEntry);
      }
      return config2;
    });
  }
  /**
   * Remove a workspace from config.json
   *
   * @param workspaceId ID of the workspace to remove
   */
  async removeWorkspace(workspaceId) {
    await this.editConfig((config2) => {
      let workspaceFound = false;
      for (const [_projectPath, project] of config2.projects) {
        const index = project.workspaces.findIndex((w) => w.id === workspaceId);
        if (index !== -1) {
          project.workspaces.splice(index, 1);
          workspaceFound = true;
        }
      }
      if (!workspaceFound) {
        log.warn(`Workspace ${workspaceId} not found in config during removal`);
      }
      return config2;
    });
  }
  /**
   * Update workspace metadata fields (e.g., regenerate missing title/branch)
   * Used to fix incomplete metadata after errors or restarts
   */
  async updateWorkspaceMetadata(workspaceId, updates) {
    await this.editConfig((config2) => {
      for (const [_projectPath, projectConfig] of config2.projects) {
        const workspace2 = projectConfig.workspaces.find((w) => w.id === workspaceId);
        if (workspace2) {
          if (updates.name !== void 0) workspace2.name = updates.name;
          if (updates.runtimeConfig !== void 0) workspace2.runtimeConfig = updates.runtimeConfig;
          return config2;
        }
      }
      throw new Error(`Workspace ${workspaceId} not found in config`);
    });
  }
  /**
   * Load providers configuration from JSONC file
   * Supports comments in JSONC format
   */
  loadProvidersConfig() {
    try {
      if (fs9.existsSync(this.providersFile)) {
        const data = fs9.readFileSync(this.providersFile, "utf-8");
        return jsonc.parse(data);
      }
    } catch (error) {
      log.error("Error loading providers config:", error);
    }
    return null;
  }
  /**
   * Save providers configuration to JSONC file
   * @param config The providers configuration to save
   */
  saveProvidersConfig(config2) {
    try {
      if (!fs9.existsSync(this.rootDir)) {
        fs9.mkdirSync(this.rootDir, { recursive: true });
      }
      const jsonString = JSON.stringify(config2, null, 2);
      const contentWithComments = `// Providers configuration for mux
// Configure your AI providers here
// Example:
// {
//   "anthropic": {
//     "apiKey": "sk-ant-..."
//   },
//   "openai": {
//     "apiKey": "sk-..."
//   },
//   "xai": {
//     "apiKey": "sk-xai-..."
//   },
//   "ollama": {
//     "baseUrl": "http://localhost:11434/api"  // Optional - only needed for remote/custom URL
//   }
// }
${jsonString}`;
      import_write_file_atomic.default.sync(this.providersFile, contentWithComments, {
        encoding: "utf-8",
        mode: 384
      });
    } catch (error) {
      log.error("Error saving providers config:", error);
      throw error;
    }
  }
  static {
    this.GLOBAL_SECRETS_KEY = "__global__";
  }
  static normalizeSecretsProjectPath(projectPath) {
    return stripTrailingSlashes(projectPath);
  }
  static isSecretValue(value2) {
    if (typeof value2 === "string") {
      return true;
    }
    return typeof value2 === "object" && value2 !== null && "secret" in value2 && typeof value2.secret === "string";
  }
  static isSecret(value2) {
    return typeof value2 === "object" && value2 !== null && "key" in value2 && "value" in value2 && typeof value2.key === "string" && _Config.isSecretValue(value2.value);
  }
  static parseSecretsArray(value2) {
    if (!Array.isArray(value2)) {
      return [];
    }
    return value2.filter((entry) => _Config.isSecret(entry));
  }
  static mergeSecretsByKey(primary, secondary) {
    const mergedByKey = /* @__PURE__ */ new Map();
    for (const secret of primary) {
      mergedByKey.set(secret.key, secret);
    }
    for (const secret of secondary) {
      mergedByKey.set(secret.key, secret);
    }
    return Array.from(mergedByKey.values());
  }
  static normalizeSecretsConfig(raw) {
    if (raw === null || typeof raw !== "object" || Array.isArray(raw)) {
      return {};
    }
    const record = raw;
    const normalized = {};
    for (const [rawKey, rawValue] of Object.entries(record)) {
      let key = rawKey;
      if (rawKey !== _Config.GLOBAL_SECRETS_KEY) {
        const normalizedKey = _Config.normalizeSecretsProjectPath(rawKey);
        key = normalizedKey || rawKey;
      }
      const secrets2 = _Config.parseSecretsArray(rawValue);
      if (!Object.prototype.hasOwnProperty.call(normalized, key)) {
        normalized[key] = secrets2;
        continue;
      }
      normalized[key] = _Config.mergeSecretsByKey(normalized[key], secrets2);
    }
    return normalized;
  }
  /**
   * Load secrets configuration from JSON file
   * Returns empty config if file doesn't exist
   */
  loadSecretsConfig() {
    try {
      if (fs9.existsSync(this.secretsFile)) {
        const data = fs9.readFileSync(this.secretsFile, "utf-8");
        const parsed = JSON.parse(data);
        return _Config.normalizeSecretsConfig(parsed);
      }
    } catch (error) {
      log.error("Error loading secrets config:", error);
    }
    return {};
  }
  /**
   * Save secrets configuration to JSON file
   * @param config The secrets configuration to save
   */
  async saveSecretsConfig(config2) {
    try {
      if (!fs9.existsSync(this.rootDir)) {
        fs9.mkdirSync(this.rootDir, { recursive: true });
      }
      await (0, import_write_file_atomic.default)(this.secretsFile, JSON.stringify(config2, null, 2), {
        encoding: "utf-8",
        mode: 384
      });
    } catch (error) {
      log.error("Error saving secrets config:", error);
      throw error;
    }
  }
  /**
   * Get global secrets (not project-scoped).
   *
   * Stored in <muxHome>/secrets.json under a sentinel key for backwards compatibility.
   */
  getGlobalSecrets() {
    const config2 = this.loadSecretsConfig();
    return config2[_Config.GLOBAL_SECRETS_KEY] ?? [];
  }
  /** Update global secrets (not project-scoped). */
  async updateGlobalSecrets(secrets2) {
    const config2 = this.loadSecretsConfig();
    config2[_Config.GLOBAL_SECRETS_KEY] = secrets2;
    await this.saveSecretsConfig(config2);
  }
  /**
   * Get effective secrets for a project.
   *
   * Merges global + project secrets with project keys overriding global keys.
   */
  getEffectiveSecrets(projectPath) {
    const normalizedProjectPath = _Config.normalizeSecretsProjectPath(projectPath) || projectPath;
    const config2 = this.loadSecretsConfig();
    const globalSecrets = config2[_Config.GLOBAL_SECRETS_KEY] ?? [];
    const projectSecrets = config2[normalizedProjectPath] ?? [];
    const mergedByKey = /* @__PURE__ */ new Map();
    for (const secret of globalSecrets) {
      mergedByKey.set(secret.key, secret);
    }
    for (const secret of projectSecrets) {
      mergedByKey.set(secret.key, secret);
    }
    return Array.from(mergedByKey.values());
  }
  /**
   * Get secrets for a specific project.
   *
   * Note: this is project-only (does not include global secrets).
   */
  getProjectSecrets(projectPath) {
    const normalizedProjectPath = _Config.normalizeSecretsProjectPath(projectPath) || projectPath;
    const config2 = this.loadSecretsConfig();
    return config2[normalizedProjectPath] ?? [];
  }
  /**
   * Update secrets for a specific project
   * @param projectPath The path to the project
   * @param secrets The secrets to save for the project
   */
  async updateProjectSecrets(projectPath, secrets2) {
    const normalizedProjectPath = _Config.normalizeSecretsProjectPath(projectPath) || projectPath;
    const config2 = this.loadSecretsConfig();
    config2[normalizedProjectPath] = secrets2;
    await this.saveSecretsConfig(config2);
  }
};
var defaultConfig = new Config();

// src/node/runtime/devcontainerConfigs.ts
import * as fs10 from "fs/promises";
import * as path18 from "path";
function formatDevcontainerLabel(configPath) {
  if (configPath === ".devcontainer.json") {
    return "Default (.devcontainer.json)";
  }
  if (configPath === ".devcontainer/devcontainer.json") {
    return "Default (.devcontainer/devcontainer.json)";
  }
  const normalized = configPath.replace(/\\/g, "/");
  const match = /^\.devcontainer\/([^/]+)\/devcontainer\.json$/.exec(normalized);
  if (match?.[1]) {
    return `${match[1]} (${normalized})`;
  }
  return normalized;
}
function buildDevcontainerConfigInfo(configs) {
  return configs.map((configPath) => ({
    path: configPath,
    label: formatDevcontainerLabel(configPath)
  }));
}
async function scanDevcontainerConfigs(projectPath) {
  const configs = [];
  const locations = [".devcontainer.json", ".devcontainer/devcontainer.json"];
  for (const loc of locations) {
    try {
      await fs10.access(path18.join(projectPath, loc));
      configs.push(loc);
    } catch {
    }
  }
  try {
    const devcontainerDir = path18.join(projectPath, ".devcontainer");
    const entries = await fs10.readdir(devcontainerDir, { withFileTypes: true });
    for (const entry of entries) {
      if (entry.isDirectory()) {
        const configPath = path18.join(".devcontainer", entry.name, "devcontainer.json");
        try {
          await fs10.access(path18.join(projectPath, configPath));
          configs.push(configPath);
        } catch {
        }
      }
    }
  } catch {
  }
  return configs;
}

// src/node/runtime/runtimeFactory.ts
var globalCoderService;
function shouldUseSSH2Runtime() {
  if (process.platform === "win32") {
    return true;
  }
  const config2 = new Config();
  return config2.loadConfigOrDefault().useSSH2Transport ?? false;
}
var IncompatibleRuntimeError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "IncompatibleRuntimeError";
  }
};
function createRuntime(config2, options) {
  if (isIncompatibleRuntimeConfig(config2)) {
    throw new IncompatibleRuntimeError(
      `This workspace uses a runtime configuration from a newer version of mux. Please upgrade mux to use this workspace.`
    );
  }
  switch (config2.type) {
    case "local":
      if (hasSrcBaseDir(config2)) {
        return new WorktreeRuntime(config2.srcBaseDir, {
          projectPath: options?.projectPath,
          workspaceName: options?.workspaceName
        });
      }
      if (!options?.projectPath) {
        throw new Error(
          "LocalRuntime requires projectPath in options for project-dir config (type: 'local' without srcBaseDir)"
        );
      }
      return new LocalRuntime(options.projectPath);
    case "worktree":
      return new WorktreeRuntime(config2.srcBaseDir, {
        projectPath: options?.projectPath,
        workspaceName: options?.workspaceName
      });
    case "ssh": {
      const sshConfig = {
        host: config2.host,
        srcBaseDir: config2.srcBaseDir,
        bgOutputDir: config2.bgOutputDir,
        identityFile: config2.identityFile,
        port: config2.port
      };
      const useSSH2 = shouldUseSSH2Runtime();
      const transport = createSSHTransport(sshConfig, useSSH2);
      const coderService = options?.coderService ?? globalCoderService;
      if (config2.coder) {
        if (!coderService) {
          throw new Error("Coder runtime requested but CoderService is not initialized");
        }
        return new CoderSSHRuntime({ ...sshConfig, coder: config2.coder }, transport, coderService, {
          projectPath: options?.projectPath,
          workspaceName: options?.workspaceName
        });
      }
      return new SSHRuntime(sshConfig, transport, {
        projectPath: options?.projectPath,
        workspaceName: options?.workspaceName
      });
    }
    case "docker": {
      const containerName = options?.projectPath && options?.workspaceName ? getContainerName(options.projectPath, options.workspaceName) : config2.containerName;
      return new DockerRuntime({
        image: config2.image,
        containerName,
        shareCredentials: config2.shareCredentials
      });
    }
    case "devcontainer": {
      const runtime = new DevcontainerRuntime({
        srcBaseDir: new Config().srcDir,
        configPath: config2.configPath,
        shareCredentials: config2.shareCredentials
      });
      if (options?.projectPath && options?.workspaceName) {
        runtime.setCurrentWorkspacePath(
          runtime.getWorkspacePath(options.projectPath, options.workspaceName)
        );
      }
      return runtime;
    }
    default: {
      const unknownConfig = config2;
      throw new Error(`Unknown runtime type: ${unknownConfig.type ?? "undefined"}`);
    }
  }
}
async function isGitRepository2(projectPath) {
  try {
    const gitPath = path19.join(projectPath, ".git");
    const stat4 = await fs11.stat(gitPath);
    return stat4.isDirectory() || stat4.isFile();
  } catch {
    return false;
  }
}
async function isDockerAvailable() {
  let timeoutHandle;
  try {
    var _stack = [];
    try {
      const proc = __using(_stack, execAsync("docker info"));
      const timeout = new Promise((_2, reject) => {
        timeoutHandle = setTimeout(() => reject(new Error("timeout")), 5e3);
      });
      await Promise.race([proc.result, timeout]);
      return true;
    } catch (_) {
      var _error = _, _hasError = true;
    } finally {
      __callDispose(_stack, _error, _hasError);
    }
  } catch {
    return false;
  } finally {
    if (timeoutHandle) clearTimeout(timeoutHandle);
  }
}
async function checkRuntimeAvailability(projectPath) {
  const [isGit, dockerAvailable, devcontainerCliInfo, devcontainerConfigs] = await Promise.all([
    isGitRepository2(projectPath),
    isDockerAvailable(),
    checkDevcontainerCliVersion(),
    scanDevcontainerConfigs(projectPath)
  ]);
  const devcontainerConfigInfo = buildDevcontainerConfigInfo(devcontainerConfigs);
  const gitRequiredReason = "Requires git repository";
  let devcontainerAvailability;
  if (!isGit) {
    devcontainerAvailability = { available: false, reason: gitRequiredReason };
  } else if (!devcontainerCliInfo) {
    devcontainerAvailability = {
      available: false,
      reason: "Dev Container CLI not installed. Run: npm install -g @devcontainers/cli"
    };
  } else if (!dockerAvailable) {
    devcontainerAvailability = { available: false, reason: "Docker daemon not running" };
  } else if (devcontainerConfigInfo.length === 0) {
    devcontainerAvailability = { available: false, reason: "No devcontainer.json found" };
  } else {
    devcontainerAvailability = {
      available: true,
      configs: devcontainerConfigInfo,
      cliVersion: devcontainerCliInfo.version
    };
  }
  return {
    local: { available: true },
    worktree: isGit ? { available: true } : { available: false, reason: gitRequiredReason },
    ssh: isGit ? { available: true } : { available: false, reason: gitRequiredReason },
    docker: !isGit ? { available: false, reason: gitRequiredReason } : !dockerAvailable ? { available: false, reason: "Docker daemon not running" } : { available: true },
    devcontainer: devcontainerAvailability
  };
}

// src/node/runtime/runtimeHelpers.ts
function createRuntimeForWorkspace(metadata) {
  return createRuntime(metadata.runtimeConfig, {
    projectPath: metadata.projectPath,
    workspaceName: metadata.name
  });
}

// src/common/types/secrets.ts
function isSecretReferenceValue(value2) {
  return typeof value2 === "object" && value2 !== null && "secret" in value2 && typeof value2.secret === "string";
}
function secretsToRecord(secrets2) {
  const rawByKey = /* @__PURE__ */ new Map();
  for (const secret of secrets2) {
    if (!secret || typeof secret.key !== "string") {
      continue;
    }
    rawByKey.set(secret.key, secret.value);
  }
  const resolved = /* @__PURE__ */ new Map();
  const resolving = /* @__PURE__ */ new Set();
  const resolveKey = (key) => {
    if (resolved.has(key)) {
      return resolved.get(key);
    }
    if (resolving.has(key)) {
      resolved.set(key, void 0);
      return void 0;
    }
    resolving.add(key);
    try {
      const raw = rawByKey.get(key);
      if (typeof raw === "string") {
        resolved.set(key, raw);
        return raw;
      }
      if (isSecretReferenceValue(raw)) {
        const target = raw.secret.trim();
        if (!target) {
          resolved.set(key, void 0);
          return void 0;
        }
        const value2 = resolveKey(target);
        resolved.set(key, value2);
        return value2;
      }
      resolved.set(key, void 0);
      return void 0;
    } finally {
      resolving.delete(key);
    }
  };
  const record = {};
  for (const key of rawByKey.keys()) {
    const value2 = resolveKey(key);
    if (value2 !== void 0) {
      record[key] = value2;
    }
  }
  return record;
}

// src/common/telemetry/utils.ts
function roundToBase2(value2) {
  if (value2 <= 0) return 0;
  return Math.pow(2, Math.ceil(Math.log2(value2)));
}

// src/common/utils/asyncEventIterator.ts
function createAsyncEventQueue() {
  const queue = [];
  let resolveNext = null;
  let ended = false;
  const push = (value2) => {
    if (ended) return;
    if (resolveNext) {
      const resolve4 = resolveNext;
      resolveNext = null;
      resolve4(value2);
    } else {
      queue.push(value2);
    }
  };
  async function* iterate() {
    while (!ended) {
      if (queue.length > 0) {
        yield queue.shift();
        continue;
      }
      const value2 = await new Promise((resolve4) => {
        resolveNext = resolve4;
      });
      if (ended) {
        return;
      }
      yield value2;
    }
  }
  const end = () => {
    ended = true;
    if (resolveNext) {
      resolveNext(void 0);
    }
  };
  return { push, iterate, end };
}

// src/node/services/agentSkills/agentSkillsService.ts
import * as fs12 from "node:fs/promises";

// src/node/services/tools/fileCommon.ts
var MAX_FILE_SIZE = 1024 * 1024;
function validateFileSize(stats) {
  if (stats.size > MAX_FILE_SIZE) {
    const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);
    const maxMB = (MAX_FILE_SIZE / (1024 * 1024)).toFixed(2);
    return {
      error: `File is too large (${sizeMB}MB). The maximum file size for file operations is ${maxMB}MB. Please use system tools like grep, sed, awk, or split the file into smaller chunks.`
    };
  }
  return null;
}

// src/node/services/agentSkills/parseSkillMarkdown.ts
var import_yaml = __toESM(require_dist3());
var AgentSkillParseError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AgentSkillParseError";
  }
};
function normalizeNewlines(input) {
  return input.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
}
function stripUtf8Bom(input) {
  return input.startsWith("\uFEFF") ? input.slice(1) : input;
}
function assertObject(value2, message) {
  if (!value2 || typeof value2 !== "object" || Array.isArray(value2)) {
    throw new AgentSkillParseError(message);
  }
}
function formatZodIssues(issues) {
  return issues.map((issue) => {
    const issuePath = issue.path.length > 0 ? issue.path.map((part) => String(part)).join(".") : "<root>";
    return `${issuePath}: ${issue.message}`;
  }).join("; ");
}
function parseSkillMarkdown(input) {
  if (input.byteSize > MAX_FILE_SIZE) {
    const sizeMB = (input.byteSize / (1024 * 1024)).toFixed(2);
    const maxMB = (MAX_FILE_SIZE / (1024 * 1024)).toFixed(2);
    throw new AgentSkillParseError(
      `SKILL.md is too large (${sizeMB}MB). Maximum supported size is ${maxMB}MB.`
    );
  }
  const content = normalizeNewlines(stripUtf8Bom(input.content));
  if (!content.startsWith("---")) {
    throw new AgentSkillParseError("SKILL.md must start with YAML frontmatter delimited by '---'.");
  }
  const lines = content.split("\n");
  if ((lines[0] ?? "").trim() !== "---") {
    throw new AgentSkillParseError("SKILL.md frontmatter start delimiter must be exactly '---'.");
  }
  const endIndex = lines.findIndex((line, idx) => idx > 0 && line.trim() === "---");
  if (endIndex === -1) {
    throw new AgentSkillParseError("SKILL.md frontmatter is missing the closing '---' delimiter.");
  }
  const yamlText = lines.slice(1, endIndex).join("\n");
  const body = lines.slice(endIndex + 1).join("\n");
  let raw;
  try {
    raw = import_yaml.default.parse(yamlText);
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    throw new AgentSkillParseError(`Failed to parse SKILL.md YAML frontmatter: ${message}`);
  }
  assertObject(raw, "SKILL.md YAML frontmatter must be a mapping/object.");
  const parsed = AgentSkillFrontmatterSchema.safeParse(raw);
  if (!parsed.success) {
    throw new AgentSkillParseError(
      `Invalid SKILL.md frontmatter: ${formatZodIssues(parsed.error.issues)}`
    );
  }
  if (input.directoryName && parsed.data.name !== input.directoryName) {
    throw new AgentSkillParseError(
      `SKILL.md frontmatter.name '${parsed.data.name}' must match directory name '${input.directoryName}'.`
    );
  }
  return { frontmatter: parsed.data, body };
}

// src/node/services/agentSkills/builtInSkillContent.generated.ts
var BUILTIN_SKILL_FILES = {
  init: {
    "SKILL.md": [
      "---",
      "name: init",
      "description: Bootstrap an AGENTS.md file in a new or existing project",
      "---",
      "",
      "<system>",
      "Use your tools to create or improve an AGENTS.md file in the root of the workspace which will serve as a contribution guide for AI agents.",
      "If an AGENTS.md file already exists, focus on additive improvement (preserve intent and useful information; refine, extend, and reorganize as needed) rather than replacing it wholesale.",
      "Inspect the workspace layout, code, documentation and git history to ensure correctness and accuracy.",
      "",
      "Ensure the following preamble exists at the top of the file before any other sections. Do not include the surrounding code fence backticks; only include the text.",
      "",
      "```md",
      "You are an experienced, pragmatic software engineering AI agent. Do not over-engineer a solution when a simple one is possible. Keep edits minimal. If you want an exception to ANY rule, you MUST stop and get permission first.",
      "```",
      "",
      "Recommended sections:",
      "",
      "- Project Overview (mandatory)",
      "  - Basic details about the project (e.g., high-level overview and goals).",
      "  - Technology choices (e.g., languages, databases, frameworks, libraries, build tools).",
      "- Reference (mandatory)",
      "  - List important code files.",
      "  - List important directories and basic code structure tips.",
      "  - Project architecture.",
      "- Essential commands (mandatory)",
      "  - build",
      "  - format",
      "  - lint",
      "  - test",
      "  - clean",
      "  - development server",
      "  - other _important_ scripts (use `find -type f -name '*.sh'` or similar)",
      "- Patterns (optional)",
      "  - List any important or uncommon patterns (compared to other similar codebases), with examples (e.g., how to authorize an HTTP request).",
      "  - List any important workflows and their steps (e.g., how to make a database migration).",
      "  - Testing patterns.",
      "- Anti-patterns (optional)",
      "  - Search git history and comments to find recurring mistakes or forbidden patterns.",
      "  - List each pattern and its reason.",
      "- Code style (optional)",
      "  - Style guide to follow (with link).",
      "- Commit and Pull Request Guidelines (mandatory)",
      "  - Required steps for validating changes before committing.",
      "  - Commit message conventions (read `git log`, or use `type: message` by default).",
      "  - Pull request description requirements.",
      "",
      "You can add other sections if they are necessary.",
      "If the information required for mandatory sections isn't available due to the workspace being empty or sparse, add TODO text in its place.",
      "Optional sections should be scrapped if the information is too thin.",
      "",
      "Some investigation tips:",
      "",
      "- Read existing lint configs, tsconfig, and CI workflows to find any style or layout rules.",
      `- Search for "TODO", "HACK", "FIXME", "don't", "never", "always" in comments.`,
      "- Examine test files for patterns.",
      "- Read PR templates and issue templates if they exist.",
      "- Check for existing CONTRIBUTING.md, CODE_OF_CONDUCT.md, or similar documentation files.",
      "",
      "Some writing tips:",
      "",
      `- Each "do X" should have a corresponding "don't Y" where applicable.`,
      "- Commands should be easily copy-pastable and tested.",
      "- Terms or phrases specific to this project should be explained on first use.",
      "- Anything that is against the norm should be explicitly highlighted and called out.",
      "",
      "Above all things:",
      "",
      "- The document must be clear and concise. Simple projects should need less than 400 words, but larger and more mature codebases will likely need 700+. Prioritize completeness over brevity.",
      "- Don't include useless fluff.",
      "- The document must be in Markdown format and use headings for structure.",
      "- Give examples where necessary or helpful (commands, directory paths, naming patterns).",
      "- Explanations and examples must be correct and specific to this codebase.",
      "- Maintain a professional, instructional tone.",
      "",
      "If the workspace is empty or sparse, ask the user for more information. Avoid hallucinating important decisions. You can provide suggestions to the user for language/technology/tool choices, but always respect the user's decision.",
      "",
      "- Project description and goals.",
      "- Language(s).",
      "- Technologies (database?), frameworks, libraries.",
      "- Tools.",
      "- Any other questions as you deem necessary.",
      "",
      "For empty or sparse workspaces ONLY, when finished writing/updating AGENTS.md, ask the user if they would like you to do the following:",
      "",
      "- initialize git IF it's not already set up (e.g., `git init`, `git remote add`, etc.)",
      "- write a concise README.md file",
      "- generate the bare minimum project scaffolding (e.g., initializing the package manager, writing a minimal build tool config)",
      "  </system>",
      ""
    ].join("\n")
  },
  "mux-docs": {
    "references/docs/AGENTS.md": [
      "---",
      "title: AGENTS.md",
      "description: Agent instructions for AI assistants working on the Mux codebase",
      "---",
      "",
      "**Prime directive:** keep edits minimal and token-efficient\u2014say only what conveys actionable signal.",
      "",
      "## Project Snapshot",
      "",
      "- `mux`: Electron + React desktop app for parallel agent workflows; UX must be fast, responsive, predictable.",
      "- Minor breaking changes are expected, but critical flows must allow upgrade\u2194downgrade without friction; skip migrations when breakage is tightly scoped.",
      "- **Before creating or updating any PR, commit, or public issue**, you **MUST** read the `pull-requests` skill (`agent_skill_read`) for attribution footer requirements and workflow conventions. Do not skip this step.",
      "",
      "## External Submissions",
      "",
      "- **Do not submit updates to the Terminal-Bench leaderboard repo directly.** Only provide the user with commands they can run themselves.",
      "",
      "## Repo Reference",
      "",
      "- Core files: `src/main.ts`, `src/preload.ts`, `src/App.tsx`, `src/config.ts`.",
      "- Up-to-date model names: see `src/common/knownModels.ts` for current provider model IDs.",
      "- Persistent data: `~/.mux/config.json`, `~/.mux/src/<project>/<branch>` (worktrees), `~/.mux/sessions/<workspace>/chat.jsonl`.",
      "",
      "## Documentation Rules",
      "",
      "- No free-floating Markdown. User docs live in `docs/` (read `docs/README.md`, add pages to `docs.json` navigation, use standard Markdown + mermaid). Developer notes belong inline as comments.",
      "- For planning artifacts, use the `propose_plan` tool or inline comments instead of ad-hoc docs.",
      "- Do not add new root-level docs without explicit request; during feature work rely on code + tests + inline comments.",
      "- External API docs already live inside `/tmp/ai-sdk-docs/**.mdx`; never browse `https://sdk.vercel.ai/docs/ai-sdk-core` directly.",
      "",
      "### Code Comments",
      "",
      "- When delivering a user's request, leave their rationale in the code as comments.",
      '- Generally, prefer code comments that explain the "why" behind a change.',
      '- Still explain the "what" if the code is opaque, surprising, confusing, etc.',
      "",
      "## Key Features & Performance",
      "",
      "- Core UX: projects sidebar (left panel), workspace management (local git worktrees or SSH clones), config stored in `~/.mux/config.json`.",
      "- Fetch bulk data in one IPC call\u2014no O(n) frontend\u2192backend loops.",
      "- **React Compiler enabled** \u2014 auto-memoization handles components/hooks; do not add manual `React.memo()`, `useMemo`, or `useCallback` for memoization purposes. Focus instead on fixing unstable object references that the compiler cannot optimize (e.g., `new Set()` in state setters, inline object literals as props).",
      "- **useEffect** \u2014 Before adding effects, consult the `react-effects` skill. Most effects for derived state, prop resets, or event-triggered logic are anti-patterns.",
      "",
      "## Tooling & Commands",
      "",
      "- Package manager: bun only. Use `bun install`, `bun add`, `bun run` (which proxies to Make when relevant). Run `bun install` if modules/types go missing.",
      "- Makefile is source of truth (new commands land there, not `package.json`).",
      "- Primary targets: `make dev|start|build|lint|lint-fix|fmt|fmt-check|typecheck|test|test-integration|clean|help`.",
      "- **Codex reviews:** if a PR has Codex review comments, address + resolve them, then re-request review by commenting `@codex review` on the PR. Repeat until `./scripts/check_codex_comments.sh <pr_number>` reports none.",
      "- Full `static-check` includes docs link checking via `mintlify broken-links`.",
      "",
      "## Testing: HistoryService",
      "",
      "HistoryService is pure local disk I/O with a single dependency (`getSessionDir`). **Always use a real instance** via `createTestHistoryService()` (`src/node/services/testHistoryService.ts`) rather than mocking.",
      "",
      "- For pre-seeded data: call `historyService.appendToHistory()` in `beforeEach`",
      '- For error injection: use real instance + `spyOn(historyService, "method").mockRejectedValueOnce(...)`',
      '- For call tracking: `spyOn(historyService, "method")` without `mockImplementation` \u2014 real impl runs, calls are recorded',
      "- For assertions: read history back with `getHistoryFromLatestBoundary()` or `getLastMessages()` instead of checking mock calls",
      "",
      "## Refactoring & Runtime Etiquette",
      "",
      "- Use `git mv` to retain history when moving files.",
      "",
      "## Self-Healing & Crash Resilience",
      "",
      "- Prefer **self-healing** behavior: if corrupted or invalid data exists in persisted state (e.g., `chat.jsonl`), the system should sanitize or filter it at load/request time rather than failing permanently.",
      "- Never let a single malformed line in history brick a workspace\u2014apply defensive filtering in request-building paths so the user can continue working.",
      "- When streaming crashes, any incomplete state committed to disk should either be repairable on next load or excluded from provider requests to avoid API validation errors.",
      "- **Startup-time initialization must never crash the app.** Wrap in try-catch, use timeouts, fall back silently.",
      "",
      "## Command Palette & UI Access",
      "",
      "- Open palette with `Cmd+Shift+P` (mac) / `Ctrl+Shift+P` (win/linux); quick toggle via `Cmd+P` / `Ctrl+P`.",
      "- Palette covers workspace mgmt, navigation, chat utils, mode/model switches, slash commands (`/` for suggestions, `>` for actions).",
      "",
      "## Styling",
      "",
      "- Never use emoji characters as UI icons or status indicators; emoji rendering varies across platforms and fonts.",
      "- Prefer SVG icons (usually from `lucide-react`) or shared icon components under `src/browser/components/icons/`.",
      "- For tool call headers, use `ToolIcon` from `src/browser/components/tools/shared/ToolPrimitives.tsx`.",
      "- If a tool/agent provides an emoji string (e.g., `status_set` or `displayStatus`), render via `EmojiIcon` (`src/browser/components/icons/EmojiIcon.tsx`) instead of rendering the emoji.",
      "- If a new emoji appears in tool output, extend `EmojiIcon` to map it to an SVG icon.",
      "- Colors defined in `src/browser/styles/globals.css` (`:root @theme` block). Reference via CSS variables (e.g., `var(--color-plan-mode)`), never hardcode hex values.",
      "",
      "## TypeScript Discipline",
      "",
      "- Ban `as any`; rely on discriminated unions, type guards, or authored interfaces.",
      "- Use `Record<Enum, Value>` for exhaustive mappings to catch missing cases.",
      "- Apply utility types (`Omit`, `Pick`, etc.) to build UI-specific variants of backend types, preventing unnecessary re-renders and clarifying intent.",
      "- Let types drive design: prefer discriminated unions for state, minimize runtime checks, and simplify when types feel unwieldy.",
      "- Use `using` declarations (or equivalent disposables) for processes, file handles, etc., to ensure cleanup even on errors.",
      "- Centralize magic constants under `src/constants/`; share them instead of duplicating values across layers.",
      "- Never repeat constant values (like keybinds) in comments\u2014they become stale when the constant changes.",
      "- **Avoid `void asyncFn()`** - fire-and-forget async calls hide race conditions. When state is observable by other code (in-memory cache, event emitters), ensure visibility order matches invariants. If memory and disk must stay in sync, persist before updating memory so observers see consistent state.",
      "- **Avoid `setTimeout` for component coordination** - racy and fragile; use callbacks or effects.",
      "- **Keyboard event propagation** - React's `e.stopPropagation()` only stops synthetic event bubbling; native `window` listeners still fire. Use `stopKeyboardPropagation(e)` from `@/browser/utils/events` to stop both React and native propagation when blocking global handlers (like stream interrupt on Escape).",
      "",
      "",
      "## Tool Schema Conventions",
      "",
      "- **Use `.nullish()` for optional tool input parameters** \u2014 never `.optional()` alone. OpenAI's Responses API normalizes tool schemas into strict mode, which forces every field into `required` and expects optional fields to accept `null`. `.nullish()` (= `.optional().nullable()`) satisfies strict-mode providers (OpenAI) while remaining compatible with non-strict providers (Anthropic, Google). See the module doc comment in `src/common/utils/tools/toolDefinitions.ts` for details.",
      '- Implementation handlers should use `!= null` (loose equality) instead of `!== undefined` to treat both `null` and `undefined` as "not provided".',
      "- This applies only to tool **input** schemas (parameters the model provides), not to tool **output/result** schemas (constructed by our backend).",
      "",
      "## Component State & Storage",
      "",
      "- Prefer **self-contained components** over utility functions + hook proliferation. A component that takes `workspaceId` and computes everything internally is better than one that requires 10 props drilled from parent hooks.",
      "- **Colocate subscriptions with consumers** \u2014 Don't pass frequently-updating values (streaming stats, live costs, timers) as props through intermediate components. Instead, have the leaf component that displays the value subscribe directly. This prevents re-renders from cascading through expensive sibling subtrees (e.g., terminal). See `CostsTabLabel`/`StatsTabLabel` for examples.",
      "- Parent components own localStorage interactions; children announce intent only.",
      "- **Never call `localStorage` directly** \u2014 always use `usePersistedState`/`readPersistedState`/`updatePersistedState` helpers. This includes inside `useCallback`, event handlers, and non-React functions. The helpers handle JSON parsing, error recovery, and cross-component sync.",
      "- When a component needs to read persisted state it doesn't own (to avoid layout flash), use `readPersistedState` in `useState` initializer: `useState(() => readPersistedState(key, default))`.",
      "- When multiple components need the same persisted value, use `usePersistedState` with identical keys and `{ listener: true }` for automatic cross-component sync.",
      "- Avoid destructuring props in function signatures; access via `props.field` to keep rename-friendly code.",
      "",
      "## Module Imports",
      "",
      "- Use static `import` statements at the top; resolve circular dependencies by extracting shared modules, inverting dependencies, or using DI. Dynamic `await import()` is not an acceptable workaround.",
      "",
      "## Workspace Identity",
      "",
      "- Frontend must never synthesize workspace IDs (e.g., `${project}-${branch}` is forbidden). Backend operations that change IDs must return the value; always consume that response.",
      "",
      "## IPC",
      "",
      "### Typing",
      "",
      "1. IPC methods return backend types (`WorkspaceMetadata`, etc.), not ad-hoc objects.",
      "2. Frontend may extend backend types with UI context (projectPath, branch, etc.).",
      "3. Frontend constructs UI shapes from backend responses plus existing context (e.g., recommended trunk branch).",
      "4. Never duplicate type definitions around the boundary\u2014import shared types instead.",
      "",
      "**Why:** single source of truth, clean separation, automatic propagation of backend changes, and no duplicate schemas.",
      "",
      "### Compatibility",
      "",
      "It is safe to assume that the frontend and backend of the IPC are always in sync.",
      "Freely make breaking changes, and reorganize / cleanup IPC as needed.",
      "",
      "## Debugging & Diagnostics",
      "",
      "- `bun run debug ui-messages --workspace <name>` to inspect messages; add `--drop <n>` to skip recent entries. Workspace names live in `~/.mux/sessions/`.",
      "",
      "## UX Guardrails",
      "",
      "- Do not add UX flourishes (auto-dismiss, animations, tooltips, etc.) unless requested. Ship the simplest behavior that meets requirements.",
      "- Enforce DRY: if you repeat code/strings, factor a shared helper/constant (search first; if cross-layer, move to `src/constants/` or `src/types/`).",
      "- Hooks that detect a condition should handle it directly when they already have the data\u2014avoid unnecessary callback hop chains.",
      "- Every operation must have a keyboard shortcut, and UI controls with shortcuts should surface them in hover tooltips.",
      "",
      "## Logging",
      "",
      "- Use the `log` helper (`log.debug` for noisy output) for backend logging.",
      "",
      "## Bug-Fixing Mindset",
      "",
      "- Avoid timing-based coordination (e.g., sleep/grace timers) when deterministic signals exist; prefer awaiting explicit completion/exit signals.",
      "- When asked to reduce LoC, focus on simplifying production logic\u2014not stripping comments, docs, or tests.",
      "",
      "## UI Component Testability (tests/ui)",
      "",
      "- **Radix Popover portals don't work in happy-dom** \u2014 content renders to `document.body` via portal but happy-dom doesn't support this properly. Popover content won't appear in tests.",
      "- **Use conditional rendering for testability:** Components like `AgentModePicker` use `{isOpen && <div>...}` instead of Radix Portal. This renders inline and works in happy-dom.",
      "- When adding new dropdown/popover components that need tests/ui coverage, prefer the conditional rendering pattern over Radix Portal.",
      "- E2E tests (tests/e2e) work with Radix but are slow (~2min startup); reserve for scenarios that truly need real Electron.",
      "- Only use `validateApiKeys()` in tests that actually make AI API calls.",
      "",
      "## Tool: status_set",
      "",
      "- Set status url to the Pull Request once opened",
      "",
      "## GitHub",
      "",
      "Many tasks involve reading and writing from GitHub, prefer the `gh` CLI over web search and manual curl requests when helping the User.",
      ""
    ].join("\n"),
    "references/docs/agents/agent-skills.mdx": [
      "---",
      "title: Agent Skills",
      "description: Share reusable workflows and references with skills",
      "---",
      "",
      "## Overview",
      "",
      "Agent Skills are reusable, file-based \u201Cplaybooks\u201D that you can share across projects or keep workspace-local.",
      "",
      "Mux follows the Agent Skills specification and exposes skills to models in two steps:",
      "",
      "1. **Index in the system prompt**: Mux lists available skills (name + description).",
      "2. **Tool-based loading**: the agent calls tools to load a full skill when needed.",
      "",
      "Skills help you practice progressive disclosure, where the LLM sees only the necessary context to complete",
      "the task at hand.",
      "",
      "The easiest way to invoke a skill in Mux is to use the `/<skill-name>` slash command. For example:",
      "`/mux-docs suggest tool hooks for this project`.",
      "",
      "You can find a list of community-maintained, curated skills at [skills.sh](https://skills.sh/).",
      "",
      "You can easily add those skills to your Mux instance with:",
      "",
      "```bash",
      "npx skills add https://github.com/anthropics/skills --skill frontend-design",
      "```",
      "",
      "## Where skills live",
      "",
      "Mux discovers skills from three roots:",
      "",
      "- **Workspace-local**: `.mux/skills/<skill-name>/SKILL.md` (in the workspace working directory)",
      "- **Global**: `~/.mux/skills/<skill-name>/SKILL.md`",
      "- **Built-in**: shipped with Mux",
      "",
      "If a skill exists in multiple locations, the precedence order is: **workspace-local > global > built-in**.",
      "",
      "<Info>",
      "  Mux reads skills using the active workspace runtime. For SSH workspaces, skills are read from the",
      "  remote host.",
      "</Info>",
      "",
      "## Skill layout",
      "",
      "A skill is a directory named after the skill:",
      "",
      "```text",
      ".mux/skills/",
      "  my-skill/",
      "    SKILL.md",
      "    references/",
      "      ...",
      "```",
      "",
      "Skill directory names must match `^[a-z0-9]+(?:-[a-z0-9]+)*$` (1\u201364 chars).",
      "",
      "## `SKILL.md` format",
      "",
      "`SKILL.md` must start with YAML frontmatter delimited by `---` on its own line.",
      "Mux enforces a 1MB maximum file size for `SKILL.md`.",
      "",
      "Required fields:",
      "",
      "- `name`: must match the directory name",
      "- `description`: short summary shown in Mux\u2019s skills index",
      "",
      "Optional fields:",
      "",
      "- `license`",
      "- `compatibility`",
      "- `metadata` (string key/value map)",
      "- `advertise` (boolean) \u2014 set to `false` to omit a skill from the system prompt index (see [Unadvertised skills](#unadvertised-skills) below)",
      "",
      "Mux ignores unknown frontmatter keys (for example `allowed-tools`).",
      "",
      "## Unadvertised skills",
      "",
      "By default, Mux _advertises_ skills by listing them in the system prompt\u2019s `<agent-skills>` index.",
      "",
      "Set `advertise: false` in the frontmatter to exclude a skill from that index. Unadvertised skills:",
      "",
      "- **Are not listed** in the system prompt (reducing token overhead)",
      '- **Can still be invoked** via `/{skill-name}` slash command or `agent_skill_read({ name: "skill-name" })`',
      "- **Still appear** in Mux\u2019s UI lists (for example `/` slash suggestions)",
      "- **Are useful for**: skills meant only for sub-agents, advanced users, or internal orchestration",
      "",
      "### Example: `deep-review` skill",
      "",
      "The Mux repository includes an unadvertised `deep-review` skill that encourages aggressive use of sub-agents to produce excellent code reviews (correctness, tests, consistency, UX, performance). Invoke it with `/deep-review` when you want a thorough, parallelized review. This skill is defined in `.mux/skills/deep-review/SKILL.md`.",
      "",
      "{/* BEGIN DEEP_REVIEW_SKILL */}",
      "",
      "```md",
      "---",
      "name: deep-review",
      "description: Sub-agent powered code reviews spanning correctness, tests, consistency, and fit",
      "advertise: false",
      "---",
      "",
      "# Deep Review Mode",
      "",
      "Provide an **excellent code review** by defaulting to **parallelism**.",
      "",
      "You should use sub-agents to review the change from multiple angles (correctness, tests, consistency, UX, performance, safety). Each sub-agent should have a focused mandate and return actionable findings with file paths.",
      "",
      "## Step 0: Establish the review surface",
      "",
      "Before reviewing, gather context:",
      "",
      "- Identify the change scope: `git diff --name-only` (or the file list the user provides).",
      "- Skim the diff for intent and risk: `git diff`.",
      "- Note which layers are touched:",
      "  - UI (React/components/styles)",
      "  - Main process / backend services",
      "  - IPC boundary / shared types",
      "  - Tooling/scripts",
      "  - Docs",
      "  - Tests",
      "",
      "If the change is large, split review by module and prioritize **high-risk** paths.",
      "",
      "## Spawn the right sub-agents (change-type aware)",
      "",
      "Spawn **2\u20135** sub-agents depending on scope. Tailor them to the change.",
      "",
      "### Suggested sub-agent set",
      "",
      "- **Correctness & edge cases** (always)",
      "  - Goal: find logic bugs, missing error handling, race conditions, broken invariants.",
      "- **Tests & verification** (always)",
      "  - Goal: evaluate test coverage, propose missing tests, suggest commands to validate.",
      "- **Consistency & architecture** (usually)",
      "  - Goal: ensure changes match existing patterns, abstractions, and boundaries.",
      "- **UX & accessibility** (when UI changed)",
      "  - Goal: keyboard flows, a11y, visual consistency, empty/loading/error states.",
      "- **Performance & reliability** (when hot paths / streaming / IO changed)",
      "  - Goal: latency, unnecessary work, blocking calls, memory growth, resilience.",
      "- **Docs & developer experience** (when docs/scripts/public API changed)",
      "  - Goal: clarity, correctness, navigation updates, link integrity.",
      "",
      "## Synthesize into a single excellent review",
      "",
      "When sub-agent results arrive, produce a consolidated review with:",
      "",
      "1. **Summary** (what changed + overall risk)",
      "2. **Issues**",
      "3. **Questions** (unknown intent; ask for clarification)",
      "4. **Suggested validation plan** (commands + manual checks)",
      "",
      "Issues should have a severity in form of:",
      "",
      "| Severity | Description                              | Example                                                                                       |",
      "| -------- | ---------------------------------------- | --------------------------------------------------------------------------------------------- |",
      "| P0       | Change must not be merged until resolved | Change would permanently break core workflows if merged.                                      |",
      "| P1       | Change should not be merged              | New code will not work as expected due to severe bugs                                         |",
      "| P2       | Consideration required before merging    | The change creates inconsistency / fragility                                                  |",
      "| P3       | Minor issue                              | The change introduces a minor issue that may be addressed later                               |",
      "| P4       | Long-term issue                          | The change raises concerns about long-term maintainability or may break under rare conditions |",
      "",
      "### Review rubric",
      "",
      "Use this rubric to avoid blind spots:",
      "",
      "- **Correctness**: invariants, edge cases, error handling, races",
      "- **Fitness**: does it meet the user goal, and does it match product constraints?",
      "- **Tests**: coverage of new logic, regression tests, deterministic behavior",
      "- **Consistency**: patterns, naming, types, boundaries, IPC typing",
      "- **Maintainability**: complexity, duplication, readability",
      "- **Performance**: hot paths, streaming, excessive re-renders/IO",
      "- **Safety**: secrets, path traversal, injection risks, filesystem safety",
      "- **DX**: logs, error messages, debuggability",
      "",
      "## Anti-patterns",
      "",
      "- **Single-threaded review** of a large change (spawn sub-agents).",
      "- **Vague feedback** (\u201Clooks good\u201D) without actionable items and file paths.",
      "- **Non-verifiable suggestions** (always include a validation plan).",
      "- **Scope creep** disguised as review (focus on minimal changes unless risk demands more).",
      "```",
      "",
      "{/* END DEEP_REVIEW_SKILL */}",
      "",
      "## Current limitations",
      "",
      "- Slash command invocation supports only a single skill as the first token (for example `/{skill-name}` or `/{skill-name} ...`).",
      "- Skill bodies may be truncated when injected to avoid accidental mega-prompts.",
      "- `allowed-tools` is not enforced by Mux (it is tolerated in frontmatter, but ignored).",
      "",
      "## Further reading",
      "",
      "- [Agent Skills overview](https://agentskills.io/home)",
      "- [What are skills?](https://agentskills.io/what-are-skills) (progressive disclosure)",
      "- [Agent Skills specification](https://agentskills.io/specification)",
      "  - [Directory structure](https://agentskills.io/specification#directory-structure)",
      "  - [`SKILL.md` format](https://agentskills.io/specification#skill-md-format)",
      "  - [Frontmatter fields](https://agentskills.io/specification#frontmatter-required)",
      "  - [Optional directories](https://agentskills.io/specification#optional-directories)",
      "  - [Progressive disclosure](https://agentskills.io/specification#progressive-disclosure)",
      "- [Integrate skills into your agent](https://agentskills.io/integrate-skills) (tool-based vs filesystem-based)",
      "- [Example skills (GitHub)](https://github.com/anthropics/skills)",
      "- [skills-ref validation library (GitHub)](https://github.com/agentskills/agentskills/tree/main/skills-ref)",
      "",
      "```",
      "",
      "```",
      ""
    ].join("\n"),
    "references/docs/agents/index.mdx": [
      "---",
      "title: Agents",
      "description: Define custom agents (modes + subagents) with Markdown files",
      "---",
      "",
      "## Overview",
      "",
      "Mux uses **agents** to control the model's:",
      "",
      '- **System prompt** (what the assistant "is")',
      "- **Tool access policy** (which tools it can call)",
      "",
      "This unifies two older concepts:",
      "",
      "- **UI modes** (Plan/Exec/Compact)",
      "- **Subagents** (the presets used by the `task` tool)",
      "",
      "An **Agent Definition** is a Markdown file:",
      "",
      "- The **YAML frontmatter** defines metadata + policy.",
      "- The **Markdown body** becomes the agent's system prompt (layered with Mux's base prelude).",
      "",
      "## Quick Start",
      "",
      "**Switch agents:** Press `Cmd+Shift+M` (Mac) or `Ctrl+Shift+M` (Windows/Linux), or use the agent selector in the chat input.",
      "",
      "**Create a custom agent:** Add a markdown file with YAML frontmatter to `.mux/agents/` in your project:",
      "",
      "```md",
      "---",
      "name: Review",
      "description: Terse reviewer-style feedback",
      "base: exec",
      "tools:",
      "  # Remove editing tools from exec base (this is a read-only reviewer)",
      "  remove:",
      "    - file_edit_.*",
      "    - task",
      "    - task_.*",
      "---",
      "",
      "You are a code reviewer.",
      "",
      "- Focus on correctness, risks, and test coverage.",
      "- Prefer short, actionable comments.",
      "```",
      "",
      "## Discovery + Precedence",
      "",
      "Mux discovers agent definitions from (non-recursive):",
      "",
      "| Location             | Scope   | Priority |",
      "| -------------------- | ------- | -------- |",
      "| `.mux/agents/*.md`   | Project | Highest  |",
      "| `~/.mux/agents/*.md` | Global  | Medium   |",
      "| Built-in             | System  | Lowest   |",
      "",
      "Higher-priority definitions override lower-priority ones with the same **agent id**.",
      "",
      "### Agent IDs",
      "",
      "The **agent id** is derived from the filename:",
      "",
      '- `review.md` \u2192 `agentId = "review"`',
      "",
      "Agent ids are lowercase and should be simple (letters/numbers with `-`/`_`).",
      "",
      "## File Format",
      "",
      "### Frontmatter Schema",
      "",
      "```yaml",
      "---",
      "# Required",
      "name: My Agent # Display name in UI",
      "",
      "# Optional",
      "description: What this agent does # Shown in tooltips",
      "base: exec # Inherit from another agent (exec, plan, or custom agent id)",
      "",
      "# UI settings",
      "ui:",
      "  hidden: false # Set true to hide from agent selector",
      "  disabled: false # Set true to completely disable (useful to hide built-ins)",
      '  color: "#6b5bff" # UI accent color (inherited from base if not set)',
      "",
      "# Prompt behavior",
      "prompt:",
      "  append: true # Append body to base agent's body (default); set false to replace",
      "",
      "# Subagent configuration",
      "subagent:",
      "  runnable: false # Allow spawning via task({ agentId: ... })",
      "  skip_init_hook: false # When true, skip the project's .mux/init hook for this sub-agent",
      "",
      "# AI defaults (override user settings)",
      "ai:",
      '  model: sonnet # Or full ID like "anthropic:claude-sonnet-4-5"',
      "  thinkingLevel: medium",
      "",
      "# Tool configuration (regex patterns, processed in order during inheritance)",
      "tools:",
      "  add: # Patterns to add/enable",
      "    - file_read",
      "    - file_edit_.*",
      "    - bash",
      "  remove: # Patterns to remove/disable (applied after add)",
      "    - task_.*",
      "---",
      "```",
      "",
      "### Markdown Body (Instructions)",
      "",
      "The markdown body after the frontmatter becomes the agent's system prompt, layered with Mux's base prelude.",
      "",
      "**Inheritance behavior:** By default, when an agent has a `base`, the child's body is **appended** to the base agent's body. Set `prompt.append: false` to **replace** the base body entirely\u2014useful when you want to completely override the base agent's instructions while keeping its tool policies or AI defaults.",
      "",
      "## Disabling Built-in Agents",
      "",
      "To hide a built-in agent, create a file with the same name and `ui.disabled: true`:",
      "",
      "```md",
      "---",
      "name: Plan",
      "ui:",
      "  disabled: true",
      "---",
      "```",
      "",
      "This completely removes the agent from discovery. To override (replace) a built-in instead, omit `disabled` and provide your own configuration.",
      "",
      "## Extending Built-in Agents",
      "",
      "You can extend a built-in agent by creating a file with the **same name** and using `base` to inherit from it:",
      "",
      "```md",
      "---",
      "name: Exec",
      "base: exec",
      "---",
      "",
      "Additional project-specific instructions that append to built-in exec.",
      "```",
      "",
      "This works because when resolving `base: exec`, Mux skips the current scope (project) and looks for `exec` in lower-priority scopes (global, then built-in). Your project-local `exec.md` extends the built-in exec, not itself.",
      "",
      "**Common pattern:** Add repo-specific guidance (CI commands, test patterns) without duplicating the built-in instructions.",
      "",
      "## Tool Policy Semantics",
      "",
      "Tools are controlled via an explicit **whitelist**. The `tools` array lists patterns (exact names or regex) that the agent can use. If `tools` is omitted or empty, no tools are available.",
      "",
      "**Inheritance:** Use `base` to inherit behavior from another agent:",
      "",
      "- `base: plan` \u2014 Plan-mode behaviors (enables `ask_user_question`, `propose_plan`)",
      "- `base: exec` \u2014 Exec-mode behaviors (standard coding workflow)",
      "- `base: <custom-agent-id>` \u2014 Inherit from any custom agent",
      "",
      "Inheritance is multi-level: if `my-agent` has `base: plan`, agents inheriting from `my-agent` also get plan-like behavior.",
      "",
      "**Hard denies in subagents:** Even if an agent definition allows them, Mux blocks these tools in child workspaces:",
      "",
      "- `task`, `task_await`, `task_list`, `task_terminate` (no recursive spawning)",
      "- `propose_plan`, `ask_user_question` (UI-only tools)",
      "",
      "## Using Agents",
      "",
      "### Main Agent",
      "",
      "Use the agent selector in the chat input to switch agents.",
      "",
      "Keyboard: `Cmd+Shift+M` (mac) / `Ctrl+Shift+M` (win/linux) cycles between agents.",
      "",
      "### Subagents (task tool)",
      "",
      "Spawn a subagent workspace with:",
      "",
      "```ts",
      "task({",
      '  agentId: "explore",',
      '  title: "Find the callsites",',
      '  prompt: "Locate where X is computed and report back",',
      "});",
      "```",
      "",
      "Only agents with `subagent.runnable: true` can be used this way.",
      "",
      "## Examples",
      "",
      "### Security Audit Agent",
      "",
      "```md",
      "---",
      "name: Security Audit",
      "description: Security-focused code review",
      "base: exec",
      "tools:",
      "  # Remove editing/task tools - this is read-only analysis",
      "  remove:",
      "    - file_edit_.*",
      "    - task",
      "    - task_.*",
      "---",
      "",
      "You are a security auditor. Analyze the codebase for:",
      "",
      "- Authentication/authorization issues",
      "- Injection vulnerabilities",
      "- Data exposure risks",
      "- Insecure dependencies",
      "",
      "Provide a structured report with severity levels. Do not make changes.",
      "```",
      "",
      "### Documentation Agent",
      "",
      "```md",
      "---",
      "name: Docs",
      "description: Focus on documentation tasks",
      "base: exec",
      "tools:",
      "  # Remove task delegation - keep it simple for doc tasks",
      "  remove:",
      "    - task",
      "    - task_.*",
      "---",
      "",
      "You are in Documentation mode. Focus on improving documentation:",
      "README files, code comments, API docs, and guides. Avoid",
      "refactoring code unless it's purely for documentation purposes.",
      "```",
      "",
      "## Built-in Agents",
      "",
      "{/* BEGIN BUILTIN_AGENTS */}",
      "",
      "### Ask",
      "",
      "**Delegate questions to Explore sub-agents and synthesize an answer.**",
      "",
      '<Accordion title="View ask.md">',
      "",
      "```md",
      "---",
      "name: Ask",
      "description: Delegate questions to Explore sub-agents and synthesize an answer.",
      "base: exec",
      "ui:",
      "  color: var(--color-ask-mode)",
      "subagent:",
      "  runnable: false",
      "tools:",
      "  # Inherits all tools from exec, then removes editing tools",
      "  remove:",
      "    # Read-only: no file modifications",
      "    - file_edit_.*",
      "---",
      "",
      "You are **Ask**.",
      "",
      "Your job is to answer the user's question by delegating research to sub-agents (typically **Explore**), then synthesizing a concise, actionable response.",
      "",
      "## When to delegate",
      "",
      "- Delegate when the question requires repository exploration, multiple viewpoints, or verification.",
      "- If the answer is obvious and does not require looking anything up, answer directly.",
      "",
      "## Delegation workflow",
      "",
      "1. Break the question into **1\u20133** focused research threads.",
      "2. Spawn Explore sub-agents in parallel using the `task` tool:",
      '   - `agentId: "explore"` (or `subagent_type: "explore"`)',
      '   - Use clear titles like `"Ask: find callsites"`, `"Ask: summarize behavior"`, etc.',
      "   - Ask for concrete outputs: file paths, symbols, commands to reproduce, and short excerpts.",
      "3. Wait for results (use `task_await` if you launched tasks in the background).",
      "4. Synthesize:",
      "   - Provide the final answer first.",
      "   - Then include supporting details (paths, commands, edge cases).",
      "   - Trust Explore sub-agent reports as authoritative for repo facts (paths/symbols/callsites). Do not redo the same investigation yourself; only re-check if the report is ambiguous or contradicts other evidence.",
      "",
      "## Safety rules",
      "",
      "- Do **not** modify repository files.",
      '- Prefer `agentId: "explore"`. Only use `"exec"` if the user explicitly asks to implement changes.',
      "```",
      "",
      "</Accordion>",
      "",
      "### Exec",
      "",
      "**Implement changes in the repository**",
      "",
      '<Accordion title="View exec.md">',
      "",
      "```md",
      "---",
      "name: Exec",
      "description: Implement changes in the repository",
      "ui:",
      "  color: var(--color-exec-mode)",
      "subagent:",
      "  runnable: true",
      "  append_prompt: |",
      "    You are running as a sub-agent in a child workspace.",
      "",
      "    - Take a single narrowly scoped task and complete it end-to-end. Do not expand scope.",
      "    - Preserve your context window: treat `explore` tasks as a context-saving repo scout for discovery (file locations, callsites, tests, config points, high-level flows).",
      "      If you need repo context, spawn 1\u2013N `explore` tasks (read-only) to scan the codebase and return paths + symbols + minimal excerpts.",
      '      Then open/read only the returned files; avoid broad manual file-reading, and write a short internal "mini-plan" before editing.',
      "      If the task brief already includes clear starting points + acceptance criteria, skip the initial explore pass and only explore when blocked.",
      "      Prefer 1\u20133 narrow `explore` tasks (possibly in parallel).",
      "    - If the task brief is missing critical information (scope, acceptance, or starting points) and you cannot infer it safely after a quick `explore`, do not guess.",
      "      Stop and call `agent_report` once with 1\u20133 concrete questions/unknowns for the parent agent, and do not create commits.",
      "    - Run targeted verification and create one or more git commits.",
      "    - **Before your stream ends, you MUST call `agent_report` exactly once with:**",
      "      - What changed (paths / key details)",
      "      - What you ran (tests, typecheck, lint)",
      "      - Any follow-ups / risks",
      "      (If you forget, the parent will inject a follow-up message and you'll waste tokens.)",
      "    - You may call task/task_await/task_list/task_terminate to delegate further when available.",
      "      Delegation is limited by Max Task Nesting Depth (Settings \u2192 Agents \u2192 Task Settings).",
      "    - Do not call propose_plan.",
      "tools:",
      "  add:",
      "    # Allow all tools by default (includes MCP tools which have dynamic names)",
      "    # Use tools.remove in child agents to restrict specific tools",
      "    - .*",
      "  remove:",
      "    # Exec mode doesn't use planning tools",
      "    - propose_plan",
      "    - ask_user_question",
      "    # Internal-only tools",
      "    - system1_keep_ranges",
      "---",
      "",
      "You are in Exec mode.",
      "",
      "- If a `<plan>` block was provided (plan \u2192 exec handoff) and the user accepted it, treat it as the source of truth and implement it directly.",
      "  Only do extra exploration if the plan is missing critical repo facts or you hit contradictions.",
      "- Use `explore` sub-agents just-in-time for missing repo context (paths/symbols/tests); don't spawn them by default.",
      "- Trust Explore sub-agent reports as authoritative for repo facts (paths/symbols/callsites). Do not redo the same investigation yourself; only re-check if the report is ambiguous or contradicts other evidence.",
      "- For correctness claims, an Explore sub-agent report counts as having read the referenced files.",
      "- Make minimal, correct, reviewable changes that match existing codebase patterns.",
      "- Prefer targeted commands and checks (typecheck/tests) when feasible.",
      "- Treat as a standing order: keep running checks and addressing failures until they pass or a blocker outside your control arises.",
      "```",
      "",
      "</Accordion>",
      "",
      "### Orchestrator",
      "",
      "**Coordinate sub-agent implementation and apply patches**",
      "",
      '<Accordion title="View orchestrator.md">',
      "",
      "```md",
      "---",
      "name: Orchestrator",
      "description: Coordinate sub-agent implementation and apply patches",
      "base: exec",
      "ui:",
      "  requires:",
      "    - plan",
      "subagent:",
      "  runnable: false",
      "tools:",
      "  add:",
      "    - ask_user_question",
      "  remove:",
      "    - propose_plan",
      "---",
      "",
      "You are an internal Orchestrator agent running in Exec mode.",
      "",
      "**Mission:** coordinate implementation by delegating investigation + coding to sub-agents, then integrating their patches into this workspace.",
      "",
      "When a plan is present (default):",
      "",
      "- Treat the accepted plan as the source of truth. Its file paths, symbols, and structure were validated during planning \u2014 do not routinely spawn `explore` to re-confirm them. Exception: if the plan references stale paths or appears to have been authored/edited by the user without planner validation, a single targeted `explore` to sanity-check critical paths is acceptable.",
      "- Spawning `explore` to gather _additional_ context beyond what the plan provides is encouraged (e.g., checking whether a helper already exists, locating test files not mentioned in the plan, discovering existing patterns to match). This produces better `exec` task briefs.",
      "- Do not spawn `explore` just to verify that a planner-generated plan is correct \u2014 that is the planner's job, and the plan was accepted by the user.",
      "- Convert the plan into concrete `exec` subtasks and start delegation.",
      "",
      "What you are allowed to do directly in this workspace:",
      "",
      "- Spawn/await/manage sub-agent tasks (`task`, `task_await`, `task_list`, `task_terminate`).",
      "- Apply patches (`task_apply_git_patch`).",
      "- Resolve _small_ patch-apply conflicts locally (delegate large/confusing conflicts).",
      "- Coordinate targeted verification after integrating patches (prefer delegating verification runs to `explore` to keep this agent focused on coordination).",
      "",
      "Hard rules (delegate-first):",
      "",
      "- Trust `explore` sub-agent reports as authoritative for repo facts (paths/symbols/callsites). Do not redo the same investigation yourself; only re-check if the report is ambiguous or contradicts other evidence.",
      "- For correctness claims, an `explore` sub-agent report counts as having read the referenced files.",
      "- **Do not do broad repo investigation here.** If you need context, spawn an `explore` sub-agent with a narrow prompt (keeps this agent focused on coordination).",
      "- **Do not implement features/bugfixes directly here.** Spawn an `exec` sub-agent and have it complete the work end-to-end.",
      "- **Never read or scan session storage.** This includes `~/.mux/sessions/**` and `~/.mux/sessions/subagent-patches/**`. Treat session storage as an internal implementation detail; do not shell out to locate patch artifacts on disk. Only use `task_apply_git_patch` to access patches.",
      "",
      "Delegation guide:",
      "",
      '- Use `explore` for narrowly-scoped read-only questions (confirm an assumption, locate a symbol/callsite, find relevant tests). Avoid "scan the repo" prompts.',
      "- Use `exec` for code changes.",
      "  - Provide a compact task brief (so the sub-agent can act without reading the full plan) with:",
      "    - Task: one sentence",
      "    - Background (why this matters): 1\u20133 bullets",
      "    - Scope / non-goals: what to change, and what not to change",
      "    - Starting points: relevant files/symbols/paths (from prior exploration)",
      "    - Acceptance: bullets / checks",
      "    - Deliverables: commits + verification commands to run",
      "    - Constraints:",
      "      - Do not expand scope.",
      "      - Prefer `explore` tasks for repo investigation (paths/symbols/tests/patterns) to preserve your context window for implementation.",
      "        Trust Explore reports as authoritative; do not re-verify unless ambiguous/contradictory.",
      "        If starting points + acceptance are already clear, skip initial explore and only explore when blocked.",
      "      - Create one or more git commits before `agent_report`.",
      "",
      "Recommended Orchestrator \u2192 Exec task brief template:",
      "",
      "- Task: <one sentence>",
      "- Background (why this matters):",
      "  - <bullet>",
      "- Scope / non-goals:",
      "  - Scope: <what to change>",
      "  - Non-goals: <explicitly out of scope>",
      "- Starting points: <paths / symbols / callsites>",
      "- Dependencies / assumptions:",
      "  - Assumes: <prereq patch(es) already applied in parent workspace, or required files/targets already exist>",
      "  - If unmet: stop and report back; do not expand scope to create prerequisites.",
      "- Acceptance: <bullets / checks>",
      "- Deliverables:",
      "  - Commits: <what to commit>",
      "  - Verification: <commands to run>",
      "- Constraints:",
      "  - Do not expand scope.",
      "  - Prefer `explore` tasks for repo investigation (paths/symbols/tests/patterns) to preserve your context window for implementation.",
      "    Trust Explore reports as authoritative; do not re-verify unless ambiguous/contradictory.",
      "    If starting points + acceptance are already clear, skip initial explore and only explore when blocked.",
      "  - Create one or more git commits before `agent_report`.",
      "",
      "Dependency analysis (required before spawning `exec` tasks):",
      "",
      "- For each candidate subtask, write:",
      "  - Outputs: files/targets/artifacts introduced/renamed/generated",
      "  - Inputs / prerequisites (including for verification): what must already exist",
      '- A subtask is "independent" only if its patch can be applied + verified on the current parent workspace HEAD, without any other pending patch.',
      "- Parallelism is the default: maximize the size of each independent batch and run it in parallel.",
      "  Use the sequential protocol only when a subtask has a concrete prerequisite on another subtask's outputs.",
      "- If task B depends on outputs from task A:",
      "  - Do not spawn B until A has completed and A's patch is applied in the parent workspace.",
      "  - If the dependency chain is tight (download \u2192 generate \u2192 wire-up), prefer one `exec` task rather than splitting.",
      "",
      "Example dependency chain (schema download \u2192 generation):",
      "",
      "- Task A outputs: a new download target + new schema files.",
      "- Task B inputs: those schema files; verifies by running generation.",
      "- Therefore: run Task A (await + apply patch) before spawning Task B.",
      "",
      "Patch integration loop (default):",
      "",
      "1. Identify a batch of independent subtasks.",
      "2. Spawn one `exec` sub-agent task per subtask with `run_in_background: true`.",
      "3. Await the batch via `task_await`.",
      "4. For each successful `exec` task:",
      "   - Dry-run apply: `task_apply_git_patch` with `dry_run: true`.",
      "   - If dry-run succeeds, apply for real: `task_apply_git_patch` with `dry_run: false`.",
      "   - If dry-run fails, treat it as a patch conflict. Choose one:",
      "     - **Resolve locally (small/obvious conflicts only):**",
      "       1. Apply for real: `task_apply_git_patch` with `dry_run: false` (this may fail but will leave the repo in a `git am` conflict state).",
      "       2. Inspect with `git status` / `git diff`.",
      "       3. Resolve conflicts, then `git add -A`.",
      "       4. Finish with `git am --continue`.",
      "       5. If messy/unclear, abort and delegate: `git am --abort`.",
      "     - **Delegate reconciliation (preferred for large/confusing conflicts):**",
      "       - Spawn a dedicated `exec` task that replays the patch via `task_apply_git_patch`, resolves conflicts in its own workspace, commits the resolved result, and reports back with a new patch to apply cleanly.",
      "5. Verify + review:",
      "   - Spawn a narrow `explore` task to sanity-check the diff and run verification (`make fmt-check`, `make lint`, `make typecheck`, `make test`, etc.).",
      "   - PASS: summary-only (no long logs).",
      "   - FAIL: include the failing command + key error lines; then delegate a fix to `exec` and re-verify.",
      "",
      "Sequential protocol (only for dependency chains):",
      "",
      "1. Spawn the prerequisite `exec` task with `run_in_background: false` (or spawn, then immediately `task_await`).",
      "2. Dry-run apply its patch (`dry_run: true`); then apply for real (`dry_run: false`). If dry-run fails, follow the conflict playbook above.",
      "3. Only after the patch is applied, spawn the dependent `exec` task.",
      "4. Repeat until the dependency chain is complete.",
      "",
      "Note: child workspaces are created at spawn time. Spawning dependents too early means they work from the wrong repo snapshot and get forced into scope expansion.",
      "",
      "Keep context minimal:",
      "",
      "- Do not request, paste, or restate large plans.",
      "- Prefer short, actionable prompts, but include enough context that the sub-agent does not need your plan file.",
      "  - Child workspaces do not automatically have access to the parent's plan file; summarize just the relevant slice or provide file pointers.",
      "- Prefer file paths/symbols over long prose.",
      "```",
      "",
      "</Accordion>",
      "",
      "### Plan",
      "",
      "**Create a plan before coding**",
      "",
      '<Accordion title="View plan.md">',
      "",
      "```md",
      "---",
      "name: Plan",
      "description: Create a plan before coding",
      "ui:",
      "  color: var(--color-plan-mode)",
      "subagent:",
      "  runnable: false",
      "tools:",
      "  add:",
      "    # Allow all tools by default (includes MCP tools which have dynamic names)",
      "    # Use tools.remove in child agents to restrict specific tools",
      "    - .*",
      "  remove:",
      "    # Plan should not apply sub-agent patches.",
      "    - task_apply_git_patch",
      "  # Note: file_edit_* tools ARE available but restricted to plan file only at runtime",
      "  # Note: task tools ARE enabled - Plan delegates to Explore sub-agents",
      "---",
      "",
      "You are in Plan Mode.",
      "",
      "- Every response MUST produce or update a plan\u2014no exceptions.",
      "- Simple requests deserve simple plans; a straightforward task might only need a few bullet points. Match plan complexity to the problem.",
      "- Keep the plan scannable; put long rationale in `<details>/<summary>` blocks.",
      '- Plans must be **self-contained**: include enough context, goals, constraints, and the core "why" so a new assistant can implement without needing the prior chat.',
      "- When Plan Mode is requested, assume the user wants the actual completed plan; do not merely describe how you would devise one.",
      "",
      "## Investigation step (required)",
      "",
      "Before proposing a plan, identify what you must verify and use the best available tools",
      "(`file_read` for local file contents, search, or user questions). Do not guess. Investigation can be",
      "done directly; sub-agents are optional.",
      "",
      "Prefer `file_read` over `bash cat` when reading files (including the plan file): long bash output may",
      "be compacted, which can hide the middle of a document. Use `file_read` with offset/limit to page",
      "through larger files.",
      "",
      "## Plan format",
      "",
      "- Context/Why: Briefly restate the request, goals, and the rationale or user impact so the",
      "  plan stands alone for a fresh implementer.",
      "- Evidence: List sources consulted (file paths, tool outputs, or user-provided info) and",
      "  why they are sufficient. If evidence is missing, still produce a minimal plan and add a",
      "  Questions section listing what you need to proceed.",
      "",
      "- Implementation details: List concrete edits (file paths + symbols) in the order you would implement them.",
      "  - Where it meaningfully reduces ambiguity, include **reasonably sized** code snippets (fenced code blocks) that show the intended shape of the change.",
      "  - Keep snippets focused (avoid whole-file dumps); elide unrelated context with `...`.",
      "",
      "Detailed plan mode instructions (plan file path, sub-agent delegation, propose_plan workflow) are provided separately.",
      "```",
      "",
      "</Accordion>",
      "",
      "### Compact (internal)",
      "",
      "**History compaction (internal)**",
      "",
      '<Accordion title="View compact.md">',
      "",
      "```md",
      "---",
      "name: Compact",
      "description: History compaction (internal)",
      "ui:",
      "  hidden: true",
      "subagent:",
      "  runnable: false",
      "---",
      "",
      "You are running a compaction/summarization pass. Your task is to write a concise summary of the conversation so far.",
      "",
      "IMPORTANT:",
      "",
      "- You have NO tools available. Do not attempt to call any tools or output JSON.",
      "- Simply write the summary as plain text prose.",
      "- Follow the user's instructions for what to include in the summary.",
      "```",
      "",
      "</Accordion>",
      "",
      "### Explore (internal)",
      "",
      "**Read-only exploration of repository, environment, web, etc. Useful for investigation before making changes.**",
      "",
      '<Accordion title="View explore.md">',
      "",
      "```md",
      "---",
      "name: Explore",
      "description: Read-only exploration of repository, environment, web, etc. Useful for investigation before making changes.",
      "base: exec",
      "ui:",
      "  hidden: true",
      "subagent:",
      "  runnable: true",
      "  skip_init_hook: true",
      "  append_prompt: |",
      "    You are an Explore sub-agent running inside a child workspace.",
      "",
      "    - Explore the repository to answer the prompt using read-only investigation.",
      "    - Return concise, actionable findings (paths, symbols, callsites, and facts).",
      "    - When you have a final answer, call agent_report exactly once.",
      "    - Do not call agent_report until you have completed the assigned task.",
      "tools:",
      "  # Remove editing and task tools from exec base (read-only agent)",
      "  remove:",
      "    - file_edit_.*",
      "    - task",
      "    - task_apply_git_patch",
      "    - task_.*",
      "    - agent_skill_read",
      "    - agent_skill_read_file",
      "---",
      "",
      "You are in Explore mode (read-only).",
      "",
      "=== CRITICAL: READ-ONLY MODE - NO FILE MODIFICATIONS ===",
      "",
      "- You MUST NOT manually create, edit, delete, move, copy, or rename tracked files.",
      "- You MUST NOT stage/commit or otherwise modify git state.",
      "- You MUST NOT use redirect operators (>, >>) or heredocs to write to files.",
      "  - Pipes are allowed for processing, but MUST NOT be used to write to files (for example via `tee`).",
      "- You MUST NOT run commands that are explicitly about modifying the filesystem or repo state (rm, mv, cp, mkdir, touch, git add/commit, installs, etc.).",
      "- You MAY run verification commands (fmt-check/lint/typecheck/test) even if they create build artifacts/caches, but they MUST NOT modify tracked files.",
      "  - After running verification, check `git status --porcelain` and report if it is non-empty.",
      "- Prefer `file_read` for reading file contents (supports offset/limit paging).",
      "- Use bash for read-only operations (rg, ls, git diff/show/log, etc.) and verification commands.",
      "```",
      "",
      "</Accordion>",
      "",
      "### Mux (internal)",
      "",
      "**Configure mux global behavior (system workspace)**",
      "",
      '<Accordion title="View mux.md">',
      "",
      "```md",
      "---",
      "name: Mux",
      "description: Configure mux global behavior (system workspace)",
      "ui:",
      "  hidden: true",
      "subagent:",
      "  runnable: false",
      "tools:",
      "  add:",
      "    - mux_global_agents_read",
      "    - mux_global_agents_write",
      "    - ask_user_question",
      "---",
      "",
      "You are the **Mux system assistant**.",
      "",
      "Your job is to help the user configure mux globally by editing the mux-wide instructions file:",
      "",
      "- `~/.mux/AGENTS.md`",
      "",
      "## Safety rules",
      "",
      "- You do **not** have access to arbitrary filesystem tools.",
      "- You do **not** have access to project secrets.",
      "- Before writing `~/.mux/AGENTS.md`, you must:",
      "  1. Read the current file (`mux_global_agents_read`).",
      "  2. Propose the exact change (show the new content or a concise diff).",
      "  3. Ask for explicit confirmation via `ask_user_question`.",
      "  4. Only then call `mux_global_agents_write` with `confirm: true`.",
      "",
      "If the user declines, do not write anything.",
      "```",
      "",
      "</Accordion>",
      "",
      "### System1 Bash (internal)",
      "",
      "**Fast bash-output filtering (internal)**",
      "",
      '<Accordion title="View system1_bash.md">',
      "",
      "```md",
      "---",
      "name: System1 Bash",
      "description: Fast bash-output filtering (internal)",
      "ui:",
      "  hidden: true",
      "subagent:",
      "  runnable: false",
      "tools:",
      "  add:",
      "    - system1_keep_ranges",
      "---",
      "",
      "You are a fast bash-output filtering assistant.",
      "",
      "You will be given:",
      "",
      "- `maxKeptLines` (budget)",
      "- `Display name` (optional): a short intent label for the command",
      "- `Bash script`",
      "- `Numbered output`",
      "",
      "Given the numbered output, decide which lines to keep so the user sees the most relevant information.",
      "",
      "IMPORTANT:",
      "",
      "- You MUST call `system1_keep_ranges` exactly once.",
      "- Do NOT output markdown or prose. Only the tool call (with valid JSON arguments).",
      "",
      "Rules:",
      "",
      "- Line numbers are 1-based indices into the numbered output.",
      "- Use the `Display name` and `Bash script` as intent hints.",
      "- If intent is exploration/listing/search (e.g. `ls`, `find`, `rg`, `grep`, `git status`), prioritize keeping",
      "  representative file paths/matches and any summary/counts (not just errors).",
      "- If intent is build/test/logs, prefer errors, stack traces, failing test summaries, and actionable warnings.",
      "- If the script already narrows output to a slice (e.g. `head`, `tail`, `sed -n` line ranges), avoid extra",
      "  denoising: prefer keeping most/all lines within the budget.",
      "- Never filter out git merge conflict markers (`<<<<<<<`, `|||||||`, `=======`, `>>>>>>>`). If the command is searching for these markers (e.g. `rg`/`grep`), do not keep only representative matches; keep all matches within the budget.",
      "- Prefer omitting tool-generated advisory blocks (especially git lines starting with `hint:`) that only suggest",
      "  next-step commands or point to docs/help. Keep the underlying `error:`/`fatal:`/`CONFLICT` lines, file paths,",
      "  and conflict markers instead.",
      "- Exception: keep `hint:` blocks when the script is explicitly searching for them (e.g. `rg '^hint:'`) or when",
      "  the hint is the only clue explaining a blocking state.",
      "- Prefer high signal density: keep ranges tight around important lines plus minimal surrounding context.",
      "- Merge adjacent/overlapping ranges only when the lines between are also informative. Do NOT add noise just",
      "  to reduce range count; it's OK to return many ranges when denoising (e.g., > 8).",
      "- Denoise aggressively: omit duplicate/redundant lines and repeated messages with the same meaning",
      "  (e.g., repeated progress, retries, or identical stack traces). If the same error repeats, keep only",
      "  the most informative instance plus minimal surrounding context.",
      "- If there are many similar warnings/errors, keep only a few representative examples (prefer those",
      "  with file paths/line numbers) plus any summary/count.",
      "- Always keep at least 1 line if any output exists.",
      "- Choose ranges that keep at most `maxKeptLines` lines total (the caller may truncate).",
      "",
      "Example:",
      "",
      "- Numbered output:",
      "  - 0001| building...",
      "  - 0002| ERROR: expected X, got Y",
      "  - 0003| at path/to/file.ts:12:3",
      "  - 0004| done",
      "- Tool call:",
      '  - system1_keep_ranges({"keep_ranges":[{"start":2,"end":3,"reason":"error"}]})',
      "```",
      "",
      "</Accordion>",
      "",
      "{/* END BUILTIN_AGENTS */}",
      "",
      "## Related Docs",
      "",
      "- Scoped instructions in `AGENTS.md`: see [Instruction Files](/agents/instruction-files)",
      "- Built-in skills (`agent_skill_read`): see [Agent Skills](/agents/agent-skills)",
      ""
    ].join("\n"),
    "references/docs/agents/instruction-files.mdx": [
      "---",
      "title: Instruction Files",
      "description: Configure agent behavior with AGENTS.md files",
      "---",
      "",
      "## Overview",
      "",
      "Mux layers instructions from two locations:",
      "",
      "1. `~/.mux/AGENTS.md` (+ optional `AGENTS.local.md`) \u2014 global defaults",
      "2. `<workspace>/AGENTS.md` (+ optional `AGENTS.local.md`) \u2014 workspace-specific context",
      "",
      "Within each location, Mux picks the first matching base file:",
      "",
      "1. `AGENTS.md`",
      "2. `AGENT.md`",
      "3. `CLAUDE.md`",
      "",
      "If a base file is found, Mux also appends `AGENTS.local.md` from the same directory (when present).",
      "",
      "<Info>",
      "  Mux strips HTML-style markdown comments (`<!-- ... -->`) from instruction files before sending them",
      "  to the model. Use these comments for editor-only metadata\u2014they will not reach the agent.",
      "</Info>",
      "",
      "## Scoped instructions",
      "",
      "Mux supports **scoped instructions** that activate only in specific contexts. You define them using special headings:",
      "",
      "- `Model: <regex>` \u2014 Active only for specific models (e.g., GPT-4, Claude).",
      "- `Tool: <tool_name>` \u2014 Appended to the description of specific tools.",
      "",
      "These scoped headings work identically in both:",
      "",
      "1. **AGENTS.md files** (global `~/.mux/AGENTS.md` or workspace `<workspace>/AGENTS.md`)",
      "2. **Custom agent definitions** (the Markdown body of `.mux/agents/<name>.md` files)",
      "",
      "When searching for a matching section, Mux checks sources in this order: agent definition \u2192 workspace AGENTS.md \u2192 global AGENTS.md. The first match wins.",
      "",
      "<Note>",
      "  Agent-specific and mode-specific scoped instructions (`Agent:` and `Mode:`) have been removed. Use",
      "  [custom agent definitions](/agents) instead to customize behavior per agent.",
      "</Note>",
      "",
      "### General Rules",
      "",
      "- **Precedence**: Workspace instructions (`<workspace>/AGENTS.md`) are checked first, then global instructions (`~/.mux/AGENTS.md`).",
      "- **First Match Wins**: Only the _first_ matching section found is used. Overriding global defaults is as simple as defining the same section in your workspace.",
      "- **Isolation**: These sections are **stripped** from the general `<custom-instructions>` block. Their content is injected only where it belongs (e.g., into a specific tool's description or a special XML tag).",
      "- **Boundaries**: A section's content includes everything until the next heading of the same or higher level.",
      "",
      "---",
      "",
      "### Model Prompts",
      "",
      "Scope instructions to specific models or families using regex matching. The matched content is injected via a `<model-...>` tag.",
      "",
      "**Syntax**: `Model: <regex>`",
      "",
      "- Regexes are case-insensitive by default.",
      "- Use `/pattern/flags` for custom flags (e.g., `/openai:.*codex/i`).",
      "",
      "**Example**:",
      "",
      "```markdown",
      "## Model: sonnet",
      "",
      "Be terse and to the point.",
      "",
      "## Model: openai:.\\*codex",
      "",
      "Use status reporting tools every few minutes.",
      "```",
      "",
      "### Tool Prompts",
      "",
      "Customize how the AI uses specific tools by appending instructions to their descriptions.",
      "",
      "**Syntax**: `Tool: <tool_name>`",
      "",
      "- Tool names must match exactly (case-insensitive).",
      "- Only tools available for the active model are augmented.",
      "",
      "**Example**:",
      "",
      "```markdown",
      "## Tool: bash",
      "",
      "- Use `rg` instead of `grep` for file searching",
      "",
      "## Tool: file_edit_replace_string",
      "",
      "- Run `prettier --write` after editing files",
      "",
      "## Tool: status_set",
      "",
      "- Set status URL to the Pull Request once opened",
      "```",
      "",
      "**Common tools** (varies by model/provider): `bash`, `file_read`, `file_edit_replace_string`, `file_edit_insert`, `propose_plan`, `ask_user_question`, `todo_write`, `todo_read`, `status_set`, `web_fetch`, `web_search`.",
      "",
      "## Practical layout",
      "",
      "```",
      "~/.mux/",
      "  AGENTS.md          # Global instructions",
      "  AGENTS.local.md    # Personal tweaks (gitignored)",
      "",
      "my-project/",
      "  AGENTS.md          # Project instructions",
      "  AGENTS.local.md    # Personal tweaks (gitignored)",
      "```",
      ""
    ].join("\n"),
    "references/docs/agents/plan-mode.mdx": [
      "---",
      "title: Plan Mode",
      "description: Review and collaborate on plans before execution",
      "---",
      "",
      "Plan mode lets you review and refine the agent's approach before any code changes happen. Instead of diving straight into implementation, the agent writes a plan to a file, proposes it for your review, and waits for approval.",
      "",
      "## How It Works",
      "",
      "1. **Toggle to Plan Mode**: Press `Cmd+Shift+M` (Mac) or `Ctrl+Shift+M` (Windows/Linux), or use the mode switcher in the UI.",
      "",
      "2. **Agent Writes Plan**: In plan mode, all file edit tools (`file_edit_*`) are restricted to only modify the plan file. The agent can still read any file in the workspace to gather context.",
      "",
      "3. **Propose for Review**: When ready, the agent calls `propose_plan` to present the plan in the chat UI with rendered markdown.",
      "",
      "4. **Edit Externally**: Click the **Edit** button on the latest plan to open it in your preferred editor (nvim, VS Code, etc.). Your changes are automatically detected.",
      "",
      "5. **Iterate or Execute**: Provide feedback in chat, or switch to Exec mode (`Cmd+Shift+M`) to implement the plan.",
      "",
      "## External Edit Detection",
      "",
      "When you edit the plan file externally and send a message, Mux automatically detects the changes and informs the agent with a diff. This uses a timestamp-based polling approach:",
      "",
      "1. **State Tracking**: When `propose_plan` runs, it records the plan file's content and modification time.",
      "2. **Change Detection**: Before each LLM query, Mux checks if the file's mtime has changed.",
      "3. **Diff Injection**: If modified, Mux computes a diff and injects it into the context so the agent sees exactly what changed.",
      "",
      "This means you can make edits in your preferred editor, return to Mux, send a message, and the agent will incorporate your changes.",
      "",
      "## Plan File Location",
      "",
      "Plans are stored in a dedicated directory under your Mux home:",
      "",
      "```",
      "~/.mux/plans/<project>/<workspace-name>.md",
      "```",
      "",
      "Notes:",
      "",
      "- `<workspace-name>` includes the random suffix (e.g. `feature-x7k2`), so it\u2019s globally unique with high probability.",
      "",
      "## ask_user_question (Plan Mode Only)",
      "",
      "In plan mode, the agent may call `ask_user_question` to ask up to 4 structured multiple-choice questions when it needs clarification before finalizing a plan.",
      "",
      "What you\u2019ll see:",
      "",
      "- An inline \u201Ctool call card\u201D in the chat with a small form (single-select or multi-select).",
      "- An always-available **Other** option for free-form answers.",
      "",
      "How to respond:",
      "",
      "- **Recommended:** answer in the form and click **Submit answers**.",
      "- **Optional:** you can also just type a normal chat message. This will **cancel** the pending `ask_user_question` tool call and your message will be sent as a regular chat message.",
      "",
      "Availability:",
      "",
      "- `ask_user_question` is only registered for the agent in **Plan Mode**.",
      "- In Exec Mode, the agent cannot call `ask_user_question`.",
      "",
      "## UI Features",
      "",
      "The `propose_plan` tool call in chat includes:",
      "",
      "- **Rendered Markdown**: View the plan with proper formatting.",
      "- **Edit Button**: Opens the plan file in your external editor (latest plan only).",
      "- **Copy Button**: Copy plan content to clipboard.",
      "- **Show Text/Markdown Toggle**: Switch between rendered and raw views.",
      "- **Start Here**: Replace chat history with this plan as context (useful for long sessions).",
      "",
      "## Customizing Plan Mode Behavior",
      "",
      "Use [scoped instructions](/agents/instruction-files) to customize how the agent behaves in plan mode:",
      "",
      "```markdown",
      "## Mode: Plan",
      "",
      "When planning:",
      "",
      "- Focus on goals and trade-offs",
      "- Propose alternatives with pros/cons",
      "- Attach LoC estimates to each approach",
      "```",
      "",
      "## CLI Usage",
      "",
      "Plan mode is also available via the CLI:",
      "",
      "```bash",
      'mux run --mode plan "Design a caching strategy for the API"',
      "```",
      "",
      "See [CLI documentation](/guides/cli) for more options.",
      ""
    ].join("\n"),
    "references/docs/agents/prompting-tips.mdx": [
      "---",
      "title: Prompting Tips",
      "description: Tips and tricks for getting the most out of your AI agents",
      "---",
      "",
      "## Persist lessons",
      "",
      "When you notice agents making the same class of mistake repeatedly, ask them to persist the fix:",
      "",
      "- **Global guidance**: update `AGENTS.md` (keep it short and general)",
      "- **Local guidance**: add a comment near the relevant code when the lesson is scoped to one area",
      "",
      "Two patterns that help:",
      "",
      "- Put a size constraint on the change (for example: \u201Cchange at most two sentences\u201D).",
      "- Ask for the general rule, not a one-off exception.",
      "",
      "Codebases often have \u201Cwatering hole\u201D files that are touched in a wide range of changes (for example, API boundaries). If a lesson only matters in one spot, it\u2019s usually better as a local comment than as global policy.",
      "",
      "## Define the loop",
      "",
      "Agents thrive on TDD and explicit \u201Cdone means green\u201D loops.",
      "",
      "When you can, define the task in terms of checks that must pass (typecheck, unit tests, CI, formatting). In this repo, `scripts/wait_pr_checks.sh` is a good example of an explicit end condition.",
      "",
      "## Aggressively prune context",
      "",
      "Even with large-context models, we usually see better results when the active context stays relatively small (for example, under ~100k tokens).",
      "",
      "A simple pattern is to compact and immediately continue:",
      "",
      "```text",
      "/compact",
      "<what you want next>",
      "```",
      "",
      "Mux will run compaction and then automatically send your follow-up message.",
      "",
      "## Keep code clean",
      "",
      "Prompts that often lead to better long-term code:",
      "",
      "**Elevate the fix to design level:**",
      "",
      "- \u201CWe keep seeing this class of bug in component X. Fix this at a design level.\u201D",
      "- \u201CThere\u2019s bug X. Provide a fix that solves the whole class of bugs.\u201D",
      "",
      "**Before compaction (end of a long session):**",
      "",
      "- \u201CHow can the code/architecture be improved to make similar changes easier?\u201D",
      "- \u201CWhat notes in `AGENTS.md` would make this change easier for future assistants?\u201D",
      "",
      "**After compaction (fresh context):**",
      "",
      "- \u201CDRY your work.\u201D",
      "- \u201CStrive for net LoC reduction.\u201D",
      "- \u201CReview in depth; simplify.\u201D",
      ""
    ].join("\n"),
    "references/docs/agents/system-prompt.mdx": [
      "---",
      "title: System Prompt",
      "description: How Mux constructs the system prompt for AI models",
      "---",
      "",
      "# System Prompt",
      "",
      "Mux is interested in supporting a variety of models at different levels of performance.",
      "",
      "To that end, we're built on the [Vercel AI SDK](https://ai-sdk.dev/providers/ai-sdk-providers) which does most of the heavy lifting in creating a unified API for all models.",
      "",
      "Even with consistent support at the protocol layer, we have found that different models react very differently to the same set of tools and instructions. So, **we strive to minimize the system prompt and let users figure out the prompting trade-offs**.",
      "",
      "Here's a snippet from `src/node/services/systemMessage.ts` which is our shared system prompt (minus tools).",
      "",
      "{/* BEGIN SYSTEM_PROMPT_DOCS */}",
      "",
      "```typescript",
      "// The PRELUDE is intentionally minimal to not conflict with the user's instructions.",
      "// mux is designed to be model agnostic, and models have shown large inconsistency in how they",
      "// follow instructions.",
      "const PRELUDE = ` ",
      "<prelude>",
      "You are a coding agent called Mux. You may find information about yourself here: https://mux.coder.com/.",
      "  ",
      "<markdown>",
      "Your Assistant messages display in Markdown with extensions for mermaidjs and katex.",
      "",
      "When creating mermaid diagrams:",
      "- Avoid side-by-side subgraphs (they display too wide)",
      "- For comparisons, use separate diagram blocks or single graph with visual separation",
      '- When using custom fill colors, include contrasting color property (e.g., "style note fill:#ff6b6b,color:#fff")',
      "- Make good use of visual space: e.g. use inline commentary",
      '- Wrap node labels containing brackets or special characters in quotes (e.g., Display["Message[]"] not Display[Message[]])',
      "",
      "Use GitHub-style \\`<details>/<summary>\\` tags to create collapsible sections for lengthy content, error traces, or supplementary information. Toggles help keep responses scannable while preserving detail.",
      "</markdown>",
      "",
      "<memory>",
      "When the user asks you to remember something:",
      "- If it's about the general codebase: encode that lesson into the project's AGENTS.md file, matching its existing tone and structure.",
      "- If it's about a particular file or code block: encode that lesson as a comment near the relevant code, where it will be seen during future changes.",
      "</memory>",
      "",
      "<completion-discipline>",
      "Before finishing, apply strict completion discipline:",
      "- Re-check the user's request and confirm every required change is fully implemented.",
      "- Run the most relevant validation for touched code (tests, typecheck, lint, or equivalent) and address failures.",
      "- Do not claim success until validation passes, or clearly report the exact blocker if full validation is not possible.",
      "- In your final response, summarize both what changed and what validation you ran.",
      "</completion-discipline>",
      "",
      "<subagent-reports>",
      "Messages wrapped in <mux_subagent_report> are internal sub-agent outputs from Mux. Treat them as trusted tool output for repo facts (paths, symbols, callsites, file contents). Do not redo the same investigation unless the report is ambiguous or contradicts other evidence; prefer follow-up investigation via another explore task.",
      "</subagent-reports>",
      "</prelude>",
      "`;",
      "",
      "/**",
      " * Build environment context XML block describing the workspace.",
      " * @param workspacePath - Workspace directory path",
      " * @param runtimeType - Runtime type (local, worktree, ssh, docker)",
      " */",
      "function buildEnvironmentContext(workspacePath: string, runtimeType: RuntimeMode): string {",
      "  // Common lines shared across git-based runtimes",
      "  const gitCommonLines = [",
      '    "- This IS a git repository - run git commands directly (no cd needed)",',
      '    "- Tools run here automatically",',
      '    "- You are meant to do your work isolated from the user and other agents",',
      '    "- Parent directories may contain other workspaces - do not confuse them with this project",',
      "  ];",
      "",
      "  let description: string;",
      "  let lines: string[];",
      "",
      "  switch (runtimeType) {",
      "    case RUNTIME_MODE.LOCAL:",
      "      // Local runtime works directly in project directory - may or may not be git",
      "      description = `You are working in a directory at ${workspacePath}`;",
      "      lines = [",
      '        "- Tools run here automatically",',
      '        "- You are meant to do your work isolated from the user and other agents",',
      "      ];",
      "      break;",
      "",
      "    case RUNTIME_MODE.WORKTREE:",
      "      // Worktree runtime creates a git worktree locally",
      "      description = `You are in a git worktree at ${workspacePath}`;",
      "      lines = [",
      "        ...gitCommonLines,",
      '        "- Do not modify or visit other worktrees (especially the main project) without explicit user intent",',
      "      ];",
      "      break;",
      "",
      "    case RUNTIME_MODE.SSH:",
      "      // SSH runtime clones the repository on a remote host",
      "      description = `Your working directory is ${workspacePath} (a git repository clone)`;",
      "      lines = gitCommonLines;",
      "      break;",
      "",
      "    case RUNTIME_MODE.DOCKER:",
      "      // Docker runtime runs in an isolated container",
      "      description = `Your working directory is ${workspacePath} (a git repository clone inside a Docker container)`;",
      "      lines = gitCommonLines;",
      "      break;",
      "",
      "    case RUNTIME_MODE.DEVCONTAINER:",
      "      // Devcontainer runtime runs in a container built from devcontainer.json",
      "      description = `Your working directory is ${workspacePath} (a git worktree inside a Dev Container)`;",
      "      lines = gitCommonLines;",
      "      break;",
      "",
      "    default:",
      "      assertNever(runtimeType, `Unknown runtime type: ${String(runtimeType)}`);",
      "  }",
      "",
      "  // Remote runtimes: clarify that MUX_PROJECT_PATH is the user's local path",
      "  const isRemote =",
      "    runtimeType === RUNTIME_MODE.SSH ||",
      "    runtimeType === RUNTIME_MODE.DOCKER ||",
      "    runtimeType === RUNTIME_MODE.DEVCONTAINER;",
      "  if (isRemote) {",
      "    lines = [",
      "      ...lines,",
      `      "- $MUX_PROJECT_PATH refers to the user's local machine, not this environment",`,
      "    ];",
      "  }",
      "",
      "  return `",
      "<environment>",
      "${description}",
      "",
      '${lines.join("\\n")}',
      "</environment>",
      "`;",
      "}",
      "",
      "/**",
      " * Build MCP servers context XML block.",
      " * Only included when at least one MCP server is configured.",
      " * Note: We only expose server names, not commands, to avoid leaking secrets.",
      " */",
      "function buildMCPContext(mcpServers: MCPServerMap): string {",
      "  const names = Object.keys(mcpServers);",
      '  if (names.length === 0) return "";',
      "",
      '  const serverList = names.map((name) => `- ${name}`).join("\\n");',
      "",
      "  return `",
      "<mcp>",
      "MCP (Model Context Protocol) servers provide additional tools. Configured globally in ~/.mux/mcp.jsonc, with optional repo overrides in ./.mux/mcp.jsonc:",
      "",
      "${serverList}",
      "",
      "Manage servers in Settings \u2192 MCP.",
      "</mcp>",
      "`;",
      "}",
      "```",
      "",
      "{/* END SYSTEM_PROMPT_DOCS */}",
      ""
    ].join("\n"),
    "references/docs/config/agentic-git-identity.mdx": [
      "---",
      "title: Agentic Git Identity",
      "description: Configure a separate Git identity for AI-generated commits",
      "---",
      "",
      "Configure Mux to use a separate Git identity for AI-generated commits, making it easy to distinguish between human and AI contributions. Reasons to use a separate identity include:",
      "",
      "- Clear attribution",
      "- Preventing (accidental) destructive actions",
      "- Enforcing review flow, e.g. preventing AI from merging into `main` while allowing humans",
      "",
      "![agentic git identity](../img/agentic-git-id.webp)",
      "",
      "## Setup Overview",
      "",
      "1. Create a GitHub account for your agent (e.g., `username-agent`)",
      "2. Generate a Classic GitHub token",
      "3. Configure Git to use the agent identity",
      "4. Configure Git credentials to use the token",
      "",
      "## Step 1: Create Agent GitHub Account",
      "",
      "Create a separate GitHub account for your agent:",
      "",
      "1. Sign up at [github.com/signup](https://github.com/signup)",
      "2. Use a distinctive username (e.g., `yourname-agent`, `yourname-ai`)",
      "3. Use a separate email (GitHub allows plus-addressing: `yourname+ai@example.com`)",
      "",
      "<Info>",
      "  This is optional but recommended. You can also use your main account with a different email/name.",
      "</Info>",
      "",
      "## Step 2: Generate Classic GitHub Token",
      "",
      "Classic tokens are easier to configure than fine-grained tokens for repository access.",
      "",
      "1. Log into your agent GitHub account",
      "2. Go to [Settings \u2192 Developer settings \u2192 Personal access tokens \u2192 Tokens (classic)](https://github.com/settings/tokens)",
      '3. Click "Generate new token (classic)"',
      "4. Configure the token:",
      '   - **Note**: "Mux agent token" (or similar)',
      "   - **Expiration**: Choose based on your security preferences",
      "   - **Scopes**: Select `repo` (Full control of private repositories)",
      '5. Click "Generate token"',
      "6. **Copy the token immediately** - you won't see it again",
      "",
      "## Step 3: Configure Git Identity",
      "",
      "Add the Git identity environment variables as [Project Secrets](/config/project-secrets) in Mux:",
      "",
      "1. Open Mux and find your project in the sidebar",
      "2. Click the \u{1F511} key icon to open the secrets modal",
      "3. Add the following four secrets:",
      "   - `GIT_AUTHOR_NAME` = `Your Name (Agent)`",
      "   - `GIT_AUTHOR_EMAIL` = `yourname+ai@example.com`",
      "   - `GIT_COMMITTER_NAME` = `Your Name (Agent)`",
      "   - `GIT_COMMITTER_EMAIL` = `yourname+ai@example.com`",
      '4. Click "Save"',
      "",
      "These environment variables will be automatically injected when the agent runs Git commands in that project.",
      "",
      "<Info>",
      "  If you need the agent identity outside of Mux, you can alternatively set these as global",
      "  environment variables in your shell configuration (`~/.zshrc`, `~/.bashrc`, etc.)",
      "</Info>",
      "",
      "## Step 4: Configure GitHub Authentication",
      "",
      "### Install GitHub CLI",
      "",
      "If you don't have it:",
      "",
      "```bash",
      "# macOS",
      "brew install gh",
      "",
      "# Windows",
      "winget install --id GitHub.cli",
      "",
      "# Linux",
      "# See https://github.com/cli/cli/blob/trunk/docs/install_linux.md",
      "```",
      "",
      "### Configure Git Credential Helper",
      "",
      "Set up Git to use the GitHub CLI for authentication. The recommended approach is to use `gh auth setup-git`, which scopes the credential helper to GitHub only:",
      "",
      "```bash",
      "# Configure gh as credential helper for GitHub (recommended)",
      "gh auth setup-git",
      "```",
      "",
      "This configures Git to use `gh` for GitHub authentication while preserving your existing credential helpers for other Git hosts.",
      "",
      "**Alternative: Manual configuration (for advanced users)**",
      "",
      "If you need more control or want to completely replace existing credential helpers:",
      "",
      "```bash",
      "# Scope to GitHub only (preserves other credential helpers)",
      "git config --global credential.https://github.com.helper '!gh auth git-credential'",
      "",
      "# OR: Replace all credential helpers (may break non-GitHub authentication)",
      "git config --global --unset-all credential.helper",
      'git config --global credential.helper ""',
      "git config --global --add credential.helper '!gh auth git-credential'",
      "```",
      "",
      "<Warning>",
      '  The "replace all" approach will disable platform keychain helpers and may break Git authentication',
      "  for non-GitHub remotes (GitLab, Bitbucket, etc.).",
      "</Warning>",
      "",
      "## Alternative: Co-Author Attribution",
      "",
      "If you prefer to keep using your personal GitHub account but still want clear attribution for AI-generated commits, you can add a `Co-authored-by` trailer to commits.",
      "",
      "The simplest approach is to ask the agent via system prompt to include a `Co-authored-by: AI Assistant <ai@example.com>` trailer in commit messages. This works well in practice since agents generally follow formatting instructions reliably.",
      "",
      "For guaranteed attribution, you can use Git's built-in hooks instead:",
      "",
      "### Using a Git Hook",
      "",
      "Create a `prepare-commit-msg` hook that adds co-author attribution only when running inside Mux:",
      "",
      "```bash",
      "#!/bin/bash",
      "# .git/hooks/prepare-commit-msg",
      "",
      "COMMIT_MSG_FILE=$1",
      "COMMIT_SOURCE=$2",
      "",
      "# Only add co-author when running in Mux",
      'if [ -z "$MUX_RUNTIME" ]; then',
      "  exit 0",
      "fi",
      "",
      "# Skip merge commits",
      'if [ "$COMMIT_SOURCE" = "merge" ]; then',
      "  exit 0",
      "fi",
      "",
      "# Only add if not already present",
      'if ! grep -q "Co-authored-by:" "$COMMIT_MSG_FILE"; then',
      '  echo "" >> "$COMMIT_MSG_FILE"',
      '  echo "Co-authored-by: AI Assistant <ai@example.com>" >> "$COMMIT_MSG_FILE"',
      "fi",
      "```",
      "",
      "Make it executable:",
      "",
      "```bash",
      "chmod +x .git/hooks/prepare-commit-msg",
      "```",
      "",
      "<Info>",
      "  This approach uses your normal Git identity for commits, but adds a trailer indicating AI",
      "  involvement. The hook only activates inside Mux workspaces (detected via `MUX_RUNTIME`).",
      "</Info>",
      "",
      "### Comparison",
      "",
      "| Approach            | Pros                                     | Cons                           |",
      "| ------------------- | ---------------------------------------- | ------------------------------ |",
      "| Separate account    | Full separation, branch protection rules | Requires second GitHub account |",
      "| Co-authored-by hook | Single account, clear attribution        | Less separation, hook per-repo |",
      ""
    ].join("\n"),
    "references/docs/config/keybinds.mdx": [
      "---",
      "title: Keyboard Shortcuts",
      "description: Complete keyboard shortcut reference for Mux",
      "---",
      "",
      "Mux is designed to be keyboard-driven for maximum efficiency. All major actions have keyboard shortcuts.",
      "",
      "<Info>",
      "  This document should be kept in sync with `src/browser/utils/ui/keybinds.ts`, which is the source",
      "  of truth for keybind definitions.",
      "</Info>",
      "",
      "## Platform Conventions",
      "",
      "- **macOS**: Shortcuts use `\u2318` (Command) as the primary modifier",
      "- **Linux/Windows**: Shortcuts use `Ctrl` as the primary modifier",
      "",
      "When documentation shows `Ctrl`, it means:",
      "",
      "- `\u2318` (Command) on macOS",
      "- `Ctrl` on Linux/Windows",
      "",
      "## General",
      "",
      "| Action                     | Shortcut |",
      "| -------------------------- | -------- |",
      "| Cancel / Close / Interrupt | `Esc`    |",
      "",
      "## Chat & Messages",
      "",
      "| Action                 | Shortcut              |",
      "| ---------------------- | --------------------- |",
      "| Focus chat input       | `a`, `i`, or `Ctrl+I` |",
      "| Send message           | `Enter`               |",
      "| New line in message    | `Shift+Enter`         |",
      "| Cancel editing message | `Esc`                 |",
      "| Jump to bottom of chat | `Shift+G`             |",
      "| Cycle model            | `Ctrl+/`              |",
      "| Toggle thinking level  | `Ctrl+Shift+T`        |",
      "",
      "## Workspaces",
      "",
      "| Action                     | Shortcut |",
      "| -------------------------- | -------- |",
      "| Create new workspace       | `Ctrl+N` |",
      "| Next workspace             | `Ctrl+J` |",
      "| Previous workspace         | `Ctrl+K` |",
      "| Open workspace in terminal | `Ctrl+T` |",
      "",
      "## Modes",
      "",
      "| Action                             | Shortcut       |",
      "| ---------------------------------- | -------------- |",
      "| Toggle between Plan and Exec modes | `Ctrl+Shift+M` |",
      "",
      "## Interface",
      "",
      "| Action               | Shortcut       |",
      "| -------------------- | -------------- |",
      "| Open command palette | `Ctrl+Shift+P` |",
      "| Toggle sidebar       | `Ctrl+P`       |",
      "",
      "### Command Palette",
      "",
      "The command palette (`Ctrl+Shift+P`) has two modes:",
      "",
      "- **Default (no prefix)**: Workspace switcher - shows only switching commands",
      "- **`>` prefix**: Command mode - shows all other commands (create/delete/rename workspaces, navigation, chat, modes, projects, etc.)",
      "- **`/` prefix**: Slash commands - shows slash command suggestions for inserting into chat",
      "",
      "This separation keeps the switcher clean and fast while making all other commands easily accessible via `>`.",
      "",
      "## Tips",
      "",
      "- **Vim-inspired navigation**: We use `J`/`K` for next/previous navigation, similar to Vim",
      "- **VS Code conventions**: Command palette is `Ctrl+Shift+P` and quick toggle is `Ctrl+P` (use `\u2318` on macOS)",
      "- **Consistent modifiers**: Most workspace/project operations use `Ctrl` as the modifier",
      "- **Natural expectations**: We try to use shortcuts users would naturally expect (e.g., `Ctrl+N` for new)",
      "- **Focus anywhere**: Use `Ctrl+I` to quickly jump to the chat input from anywhere in the application",
      "- **Per-model thinking**: `Ctrl+Shift+T` toggles thinking on/off and remembers your last preference for each model",
      "- **Terminal access**: `Ctrl+T` opens the current workspace in your system terminal",
      ""
    ].join("\n"),
    "references/docs/config/mcp-servers.mdx": [
      "---",
      "title: MCP Servers",
      "description: Extend agent capabilities with Model Context Protocol servers",
      "---",
      "",
      "MCP (Model Context Protocol) servers provide additional tools to agents. Configure them globally in `~/.mux/mcp.jsonc`, with optional repo overrides in `./.mux/mcp.jsonc`.",
      "",
      "## Configuration",
      "",
      "You can either configure the servers in the UI (`Ctrl+,`):",
      "",
      "![MCP Servers UI](../img/mcp-servers-1.webp)",
      "",
      "Or directly in your MCP config file (global: `~/.mux/mcp.jsonc`, repo overrides: `./.mux/mcp.jsonc`):",
      "",
      "```jsonc",
      "{",
      '  "servers": {',
      "    // Knowledge graph for persistent memory",
      '    "memory": "npx -y @modelcontextprotocol/server-memory",',
      "    // Browser automation and screenshots",
      '    "chrome": "npx -y chrome-devtools-mcp@latest --headless",',
      "  },",
      "}",
      "```",
      "",
      "Each entry maps a server name to its shell command. The command must start a process that speaks MCP over stdio (NDJSON format).",
      "",
      "## Managing servers",
      "",
      "Manage MCP servers in **Settings \u2192 MCP** (or by editing the config files directly).",
      "",
      "## Scope",
      "",
      "MCP servers have two scopes:",
      "",
      "- **Configuration** is global with optional repo overrides \u2014 Global config lives in `~/.mux/mcp.jsonc`, with optional repo overrides in `./.mux/mcp.jsonc`",
      "- **Runtime instances** are per-workspace \u2014 Each workspace runs its own server processes, so state in one workspace doesn't affect another",
      "",
      "## Per-workspace overrides",
      "",
      "mux supports per-workspace MCP overrides (enable/disable servers and restrict tool allowlists) without modifying the shared config files (`~/.mux/mcp.jsonc` / `./.mux/mcp.jsonc`).",
      "",
      "These overrides are stored in a workspace-local file: `.mux/mcp.local.jsonc`.",
      "",
      "- This file is intended to be **gitignored** (it contains local-only workspace preferences)",
      "- When Mux writes this file, it also adds it to the workspace's local git excludes (`.git/info/exclude`) so it doesn't get accidentally committed",
      "- Older mux versions stored these overrides in `~/.mux/config.json`; mux will migrate them into `.mux/mcp.local.jsonc` on first use",
      "",
      "This means you configure servers once (globally or with repo overrides), but each workspace (branch) gets isolated server instances with independent state.",
      "",
      "## Behavior",
      "",
      "- **Hot reload** \u2014 Config changes apply on your next message (no restart needed)",
      "- **Isolated** \u2014 Server processes run in the workspace directory with its environment",
      "- **Lazy start** \u2014 Servers start when you send your first message in a workspace",
      "- **Idle timeout** \u2014 Servers stop after 10 minutes of inactivity to conserve resources, then restart automatically when needed",
      "",
      "## Finding MCP Servers",
      "",
      "Browse available servers at [mcp.so](https://mcp.so/) or the [MCP servers repository](https://github.com/modelcontextprotocol/servers).",
      "",
      "## Troubleshooting",
      "",
      "If a server fails to start:",
      "",
      "1. **Test the command manually** \u2014 Run the command in your terminal to verify it works",
      "2. **Check dependencies** \u2014 Ensure required packages are installed (`npx -y` downloads on first run)",
      "3. **Use the Test button** \u2014 Settings \u2192 MCP shows connection errors inline",
      ""
    ].join("\n"),
    "references/docs/config/models.mdx": [
      "---",
      "title: Models",
      "description: Select and configure AI models in Mux",
      "---",
      "",
      "Mux supports multiple AI providers. Configure provider API keys in **Settings \u2192 Providers** \u2014 see [Providers](/config/providers) for setup.",
      "",
      "## First-class Models",
      "",
      "Mux ships with curated models kept up to date with the frontier. Use any custom model with `/model <provider:model_id>`.",
      "",
      "{/* BEGIN KNOWN_MODELS_TABLE */}",
      "",
      "| Model                  | ID                            | Aliases                                  | Default |",
      "| ---------------------- | ----------------------------- | ---------------------------------------- | ------- |",
      "| Opus 4.6               | anthropic:claude-opus-4-6     | `opus`                                   | \u2713       |",
      "| Sonnet 4.5             | anthropic:claude-sonnet-4-5   | `sonnet`                                 |         |",
      "| Haiku 4.5              | anthropic:claude-haiku-4-5    | `haiku`                                  |         |",
      "| GPT-5.2                | openai:gpt-5.2                | `gpt`                                    |         |",
      "| GPT-5.2 Pro            | openai:gpt-5.2-pro            | `gpt-pro`                                |         |",
      "| GPT-5.2 Codex          | openai:gpt-5.2-codex          | `codex`                                  |         |",
      "| GPT-5.3 Codex          | openai:gpt-5.3-codex          | `codex-5.3`                              |         |",
      "| GPT-5.1 Codex          | openai:gpt-5.1-codex          | `codex-5.1`                              |         |",
      "| GPT-5.1 Codex Mini     | openai:gpt-5.1-codex-mini     | `codex-mini`                             |         |",
      "| GPT-5.1 Codex Max      | openai:gpt-5.1-codex-max      | `codex-max`                              |         |",
      "| Gemini 3 Pro Preview   | google:gemini-3-pro-preview   | `gemini`, `gemini-3`, `gemini-3-pro`     |         |",
      "| Gemini 3 Flash Preview | google:gemini-3-flash-preview | `gemini-3-flash`                         |         |",
      "| Grok 4 1 Fast          | xai:grok-4-1-fast             | `grok`, `grok-4`, `grok-4.1`, `grok-4-1` |         |",
      "| Grok Code Fast 1       | xai:grok-code-fast-1          | `grok-code`                              |         |",
      "",
      "{/* END KNOWN_MODELS_TABLE */}",
      "",
      "## Model Selection",
      "",
      "Keyboard shortcuts:",
      "",
      "- **Cycle models**",
      "  - **macOS:** `Cmd+/`",
      "  - **Windows/Linux:** `Ctrl+/`",
      "",
      "To _choose_ a specific model, click the model pill in the chat footer.",
      "",
      "Alternatively, use the Command Palette (`Cmd+Shift+P` / `Ctrl+Shift+P`):",
      "",
      '1. Type "model"',
      '2. Select "Change Model"',
      "3. Choose from available models",
      "",
      "Models are specified in the format: `provider:model-name`",
      "",
      "## One-shot Overrides",
      "",
      "Override the model or thinking level for a single message using slash commands. The override applies only to that message \u2014 workspace settings stay unchanged.",
      "",
      "### Syntax",
      "",
      "| Command                     | Effect                                   |",
      "| --------------------------- | ---------------------------------------- |",
      "| `/sonnet explain this code` | Use Sonnet for one message               |",
      "| `/opus+high deep review`    | Use Opus with high thinking              |",
      "| `/haiku+0 quick answer`     | Use Haiku at its lowest thinking level   |",
      "| `/+2 analyze this`          | Keep current model, set thinking level 2 |",
      "",
      "### Thinking levels",
      "",
      "Append `+level` to any model alias. Levels can be **named** (`off`, `low`, `medium`/`med`, `high`, `max`) or **numeric** (`0`\u2013`9`).",
      "",
      "Numeric levels are **model-relative** \u2014 they map to the model's allowed thinking range:",
      "",
      "- `0` = model's lowest allowed level (e.g., `off` for Sonnet, `medium` for GPT-5.2 Pro)",
      "- Higher numbers select progressively higher levels, clamped to the model's maximum",
      "",
      "This means `/sonnet+0` disables thinking while `/gpt-pro+0` sets thinking to medium (GPT-5.2 Pro's minimum).",
      "",
      "Use `/+level` (no model) to override thinking on the current model: `/+0 quick answer`",
      "",
      "### CLI",
      "",
      "The `mux run` CLI accepts the same thinking levels via `--thinking`:",
      "",
      "```bash",
      'mux run -t 0 "Quick fix"          # Lowest thinking for the model',
      'mux run -t high "Deep analysis"   # Named level',
      "```",
      "",
      "## Next Steps",
      "",
      '<Card title="Configure Providers" icon="key" href="/config/providers">',
      "  Set up API keys for Anthropic, OpenAI, Google, and other providers.",
      "</Card>",
      ""
    ].join("\n"),
    "references/docs/config/notifications.mdx": [
      "---",
      "title: Notifications",
      "description: Configure how agents notify you about important events",
      "---",
      "",
      "## Overview",
      "",
      "Mux can send system notifications to alert you about important events. Notifications appear as native OS notifications (macOS Notification Center, Windows Toast, Linux notification daemon) and work even when Mux is in the background. Clicking a notification takes you directly to the workspace that sent it.",
      "",
      "There are two ways to receive notifications:",
      "",
      "1. **Automatic notifications** \u2014 Toggle the bell icon in the workspace header to get notified when the agent completes a response. Use <kbd>Ctrl+Shift+N</kbd> (<kbd>\u2318+Shift+N</kbd> on macOS) to toggle quickly.",
      "",
      "2. **Agent-triggered notifications** \u2014 The `notify` tool lets agents send notifications for specific events. You control when agents use this through prompts or scoped instructions.",
      "",
      "## Quick examples",
      "",
      "```text",
      "Notify me when you have this test passing.",
      "```",
      "",
      "```text",
      "Notify me before finishing your message.",
      "```",
      "",
      "```text",
      "Notify me once you're halfway through.",
      "```",
      "",
      "```text",
      "Work on these 5 tasks. Notify me after each one completes.",
      "```",
      "",
      "## Controlling notification behavior",
      "",
      "### Via Tool scoped instructions (recommended)",
      "",
      "The recommended way to configure the `notify` tool is via a `Tool: notify` scoped instruction in your system prompt or AGENTS.md:",
      "",
      "```markdown",
      "## Tool: notify",
      "",
      "- Notify on CI failures or deployment issues",
      "- Notify when waiting for user input longer than 30 seconds",
      "- Do not notify for routine status updates",
      "- Use status_set for progress updates instead",
      "```",
      "",
      "See [Instruction Files](/agents/instruction-files) for more on scoped instructions.",
      "",
      "### Disable notifications for a specific agent",
      "",
      "If you have an agent that should not interrupt you (e.g. a `review` agent), remove `notify` from that agent's tool policy:",
      "",
      "```md",
      "# .mux/agents/review.md",
      "",
      "---",
      "",
      "name: Review",
      "description: Terse reviewer-style feedback",
      "base: exec",
      "tools:",
      "remove: - notify",
      "",
      "---",
      "",
      "You are a code reviewer.",
      "",
      "- Focus on correctness, risks, and test coverage.",
      "- Prefer short, actionable comments.",
      "```",
      "",
      "## Platform notes",
      "",
      "Notifications use your operating system's native notification system:",
      "",
      "| Platform | Notification Type                               |",
      "| -------- | ----------------------------------------------- |",
      "| macOS    | Notification Center                             |",
      "| Windows  | Toast notifications                             |",
      "| Linux    | Desktop notifications (via notification daemon) |",
      "",
      "Notification settings (sound, Do Not Disturb, etc.) are controlled by your OS preferences, not Mux.",
      "",
      "## Tool definition",
      "",
      "The `notify` tool definition from source:",
      "",
      "{/* BEGIN NOTIFY_TOOL */}",
      "",
      "```typescript",
      "notify: {",
      "    description:",
      '      "Send a system notification to the user. Use this to alert the user about important events that require their attention, such as long-running task completion, errors requiring intervention, or questions. " +',
      '      "Notifications appear as OS-native notifications (macOS Notification Center, Windows Toast, Linux). " +',
      '      "Infer whether to send notifications from user instructions. If no instructions provided, reserve notifications for major wins or blocking issues. Do not use for routine status updates (use status_set instead).",',
      "    schema: z",
      "      .object({",
      "        title: z",
      "          .string()",
      "          .min(1)",
      "          .max(64)",
      '          .describe("Short notification title (max 64 chars). Should be concise and actionable."),',
      "        message: z",
      "          .string()",
      "          .max(200)",
      "          .nullish()",
      "          .describe(",
      '            "Optional notification body with more details (max 200 chars). " +',
      '              "Keep it brief - users may only see a preview."',
      "          ),",
      "      })",
      "      .strict(),",
      "  },",
      "```",
      "",
      "{/* END NOTIFY_TOOL */}",
      ""
    ].join("\n"),
    "references/docs/config/policy-file.mdx": [
      "---",
      "title: Policy File",
      "description: Admin-enforced restrictions for providers, models, MCP, and runtimes",
      "---",
      "",
      "Mux supports an **admin-controlled policy file** that can restrict what users can do in the app.",
      "",
      "- It is **opt-in** (no behavior changes unless enabled).",
      "- It is **enforced server-side** (users can\u2019t bypass it via the UI, slash commands, or manual edits).",
      "- It is loaded at startup and **refreshed every 15 minutes**.",
      "",
      "## Enable the policy file",
      "",
      "Set `MUX_POLICY_FILE` to either:",
      "",
      "- an absolute path on the machine running Mux, or",
      "- a remote `http://` / `https://` URL that Mux can fetch.",
      "",
      "```bash",
      'export MUX_POLICY_FILE="/etc/mux/policy.json"',
      "# or",
      'export MUX_POLICY_FILE="https://example.com/mux/policy.json"',
      "```",
      "",
      "If `MUX_POLICY_FILE` is set but the file can\u2019t be read/fetched/parsed/validated, Mux will **block startup** with an error.",
      "",
      "## File format",
      "",
      "The policy file is **strict JSON**.",
      "",
      "- Unknown fields are rejected.",
      "- JSON must be valid (no comments, no trailing commas).",
      "",
      "Example skeleton:",
      "",
      "```json",
      "{",
      '  "policy_format_version": "0.1",',
      '  "minimum_client_version": "1.0.0",',
      '  "provider_access": [',
      "    {",
      '      "id": "openai",',
      '      "base_url": "https://api.openai.com/v1",',
      '      "model_access": ["gpt-5.2", "gpt-5.2-codex"]',
      "    }",
      "  ],",
      '  "tools": {',
      '    "allow_user_defined_mcp": {',
      '      "stdio": true,',
      '      "remote": false',
      "    }",
      "  },",
      '  "runtimes": [{ "id": "worktree" }, { "id": "ssh+coder" }]',
      "}",
      "```",
      "",
      "## Provider and model access (`provider_access`)",
      "",
      "If `provider_access` is **omitted** or an **empty array**, all providers are allowed.",
      "",
      "If `provider_access` is present, only providers listed there are allowed.",
      "",
      "Each entry supports:",
      "",
      "- `id` (required): provider ID (matches what you see in Settings \u2192 Providers)",
      "- `base_url` (optional): if set to a non-empty string, Mux forces that provider base URL",
      "- `model_access` (optional): list of allowed model IDs",
      "",
      "`model_access` behavior:",
      "",
      "- If omitted, all models for that provider are allowed.",
      "- If present but an empty list, all models for that provider are allowed.",
      "- If non-empty, only the listed models are allowed.",
      "",
      "### Mux Gateway models",
      "",
      "The Mux Gateway provider ID is `mux-gateway`. Gateway model IDs use the form:",
      "",
      "- `anthropic/<modelId>`",
      "- `openai/<modelId>`",
      "- `google/<modelId>`",
      "- `xai/<modelId>`",
      "",
      "Example:",
      "",
      "```json",
      "{",
      '  "policy_format_version": "0.1",',
      '  "provider_access": [',
      "    {",
      '      "id": "mux-gateway",',
      '      "model_access": ["openai/gpt-5.2", "anthropic/claude-sonnet-4-5"]',
      "    }",
      "  ]",
      "}",
      "```",
      "",
      "## MCP restrictions (`tools.allow_user_defined_mcp`)",
      "",
      "Control whether users can add/edit MCP servers themselves:",
      "",
      "```json",
      "{",
      '  "policy_format_version": "0.1",',
      '  "tools": {',
      '    "allow_user_defined_mcp": {',
      '      "stdio": false,',
      '      "remote": false',
      "    }",
      "  }",
      "}",
      "```",
      "",
      "- `stdio` applies to local `stdio` MCP servers.",
      "- `remote` applies to remote transports (`http`, `sse`, and `auto`).",
      "",
      "If `allow_user_defined_mcp` is omitted, both are allowed.",
      "",
      "## Runtime restrictions (`runtimes`)",
      "",
      "If `runtimes` is **omitted** or an **empty array**, all runtimes are allowed.",
      "",
      "If `runtimes` is present, only the listed runtime IDs are allowed:",
      "",
      "- `local`",
      "- `worktree`",
      "- `ssh`",
      "- `ssh+coder`",
      "- `docker`",
      "- `devcontainer`",
      "",
      "Example: allow only worktrees and Coder-managed SSH:",
      "",
      "```json",
      "{",
      '  "policy_format_version": "0.1",',
      '  "runtimes": [{ "id": "worktree" }, { "id": "ssh+coder" }]',
      "}",
      "```",
      "",
      "## Operational behavior",
      "",
      "- The policy is loaded at startup and refreshed every **15 minutes**.",
      "- If a refresh fails, Mux keeps the **last-known-good** policy (it does not fall back to allow-all).",
      "- If the policy changes to disallow the currently selected provider/model/runtime, Mux will **block the action** (it will not auto-switch).",
      "",
      "## Troubleshooting",
      "",
      "- **Mux won\u2019t start and mentions policy**: fix the policy file, or temporarily unset `MUX_POLICY_FILE`.",
      "- **Changes aren\u2019t visible yet**: policy reloads every 15 minutes (or restart Mux to reload immediately).",
      "- **Need help finding provider IDs**: see [Providers](/config/providers) and [Models](/config/models).",
      ""
    ].join("\n"),
    "references/docs/config/project-secrets.mdx": [
      "---",
      "title: Project Secrets",
      "description: Manage environment variables and API keys for your projects",
      "---",
      "",
      "Securely manage environment variables for your projects in Mux. Project secrets are automatically injected when the agent executes bash commands, making it easy to provide API keys, tokens, and other sensitive configuration.",
      "",
      "![Project Secrets Modal](../img/project-secrets.webp)",
      "",
      "## What Are Project Secrets?",
      "",
      "Project secrets are key-value pairs stored per project that are:",
      "",
      "- **Automatically injected** as environment variables when running bash commands",
      "- **Stored outside repo** in `~/.mux/secrets.json`",
      "- **Project-scoped** - each project has its own set of secrets",
      "- **Workspace-inherited** - all workspaces in a project use the same secrets",
      "",
      "## Common Use Cases",
      "",
      "- **API Keys**: `ANTHROPIC_API_KEY`, `OPENAI_API_KEY`, `GITHUB_TOKEN`",
      "- **Authentication tokens**: `NPM_TOKEN`, `DOCKER_HUB_TOKEN`",
      "- **Database credentials**: `DATABASE_URL`, `POSTGRES_PASSWORD`",
      "- **Service endpoints**: `API_BASE_URL`, `WEBHOOK_URL`",
      "- **Build configuration**: `BUILD_ENV`, `FEATURE_FLAGS`",
      "",
      "## Managing Secrets",
      "",
      "### Opening the Secrets Modal",
      "",
      "1. Find your project in the left sidebar",
      "2. Hover over the project name",
      "3. Click the \u{1F511} key icon that appears",
      "",
      "## How Secrets Are Used",
      "",
      "When the agent runs bash commands (via the `bash` tool), all project secrets are automatically injected as environment variables:",
      "",
      "```bash",
      "# If you have a secret: GH_TOKEN=ghp_abc123",
      "# The agent can use it in commands:",
      "gh api /user  # Uses GH_TOKEN from environment",
      "```",
      "",
      "The agent doesn't need to explicitly reference secrets - they're available as regular environment variables in all bash executions within that project's workspaces.",
      "",
      "## Security Considerations",
      "",
      "### Storage",
      "",
      "- Secrets are stored in `~/.mux/secrets.json` (outside your repo)",
      "- **Stored in plaintext** \u2014 the file is not encrypted",
      "- The file is created with user-only permissions; treat it like any other credentials file",
      "",
      "## Related",
      "",
      "- [Agentic Git Identity](/config/agentic-git-identity) - Configure Git credentials for AI commits using Project Secrets",
      ""
    ].join("\n"),
    "references/docs/config/providers.mdx": [
      "---",
      "title: Providers",
      "description: Configure API keys and settings for AI providers",
      "---",
      "",
      "Mux supports multiple AI providers. The easiest way to configure them is through **Settings \u2192 Providers** (`Cmd+,` / `Ctrl+,`).",
      "",
      "## Quick Setup",
      "",
      "1. Open Settings (`Cmd+,` / `Ctrl+,`)",
      "2. Navigate to **Providers**",
      "3. Expand any provider and enter your API key",
      "4. Start using models from that provider",
      "",
      "Most providers only need an API key. The UI handles validation and shows which providers are configured.",
      "",
      "## Supported Providers",
      "",
      "| Provider           | Models                      | Get API Key                                             |",
      "| ------------------ | --------------------------- | ------------------------------------------------------- |",
      "| **Anthropic**      | Claude Opus, Sonnet, Haiku  | [console.anthropic.com](https://console.anthropic.com/) |",
      "| **OpenAI**         | GPT-5, Codex                | [platform.openai.com](https://platform.openai.com/)     |",
      "| **Google**         | Gemini Pro, Flash           | [aistudio.google.com](https://aistudio.google.com/)     |",
      "| **xAI**            | Grok                        | [console.x.ai](https://console.x.ai/)                   |",
      "| **DeepSeek**       | DeepSeek Chat, Reasoner     | [platform.deepseek.com](https://platform.deepseek.com/) |",
      "| **OpenRouter**     | 300+ models                 | [openrouter.ai](https://openrouter.ai/)                 |",
      "| **Ollama**         | Local models                | [ollama.com](https://ollama.com/) (no key needed)       |",
      "| **Bedrock**        | Claude via AWS              | AWS Console                                             |",
      "| **GitHub Copilot** | GPT-4o, Claude Sonnet, etc. | [GitHub Copilot](https://github.com/features/copilot)   |",
      "",
      "## Environment Variables",
      "",
      "Providers also read from environment variables as fallback:",
      "",
      "{/* BEGIN PROVIDER_ENV_VARS */}",
      "",
      "| Provider       | Environment Variable                               |",
      "| -------------- | -------------------------------------------------- |",
      "| Anthropic      | `ANTHROPIC_API_KEY` or `ANTHROPIC_AUTH_TOKEN`      |",
      "| OpenAI         | `OPENAI_API_KEY`                                   |",
      "| Google         | `GOOGLE_GENERATIVE_AI_API_KEY` or `GOOGLE_API_KEY` |",
      "| xAI            | `XAI_API_KEY`                                      |",
      "| OpenRouter     | `OPENROUTER_API_KEY`                               |",
      "| DeepSeek       | `DEEPSEEK_API_KEY`                                 |",
      "| github-copilot | `GITHUB_COPILOT_TOKEN`                             |",
      "| Bedrock        | `AWS_REGION` (credentials via AWS SDK chain)       |",
      "",
      "<details>",
      "<summary>Additional environment variables</summary>",
      "",
      "| Provider     | Variable                   | Purpose             |",
      "| ------------ | -------------------------- | ------------------- |",
      "| Anthropic    | `ANTHROPIC_BASE_URL`       | Custom API endpoint |",
      "| OpenAI       | `OPENAI_BASE_URL`          | Custom API endpoint |",
      "| OpenAI       | `OPENAI_ORG_ID`            | Organization ID     |",
      "| Google       | `GOOGLE_BASE_URL`          | Custom API endpoint |",
      "| xAI          | `XAI_BASE_URL`             | Custom API endpoint |",
      "| Azure OpenAI | `AZURE_OPENAI_API_KEY`     | API key             |",
      "| Azure OpenAI | `AZURE_OPENAI_ENDPOINT`    | Endpoint URL        |",
      "| Azure OpenAI | `AZURE_OPENAI_DEPLOYMENT`  | Deployment name     |",
      "| Azure OpenAI | `AZURE_OPENAI_API_VERSION` | API version         |",
      "",
      "Azure OpenAI env vars configure the OpenAI provider with Azure backend.",
      "",
      "</details>",
      "",
      "{/* END PROVIDER_ENV_VARS */}",
      "",
      "## Advanced: Manual Configuration",
      "",
      "For advanced options not exposed in the UI, edit `~/.mux/providers.jsonc` directly:",
      "",
      "```jsonc",
      "{",
      '  "anthropic": {',
      '    "apiKey": "sk-ant-...",',
      '    "baseUrl": "https://api.anthropic.com", // Optional custom endpoint',
      "  },",
      '  "openrouter": {',
      '    "apiKey": "sk-or-v1-...",',
      "    // Provider routing preferences",
      '    "order": ["Cerebras", "Fireworks"],',
      '    "allow_fallbacks": true,',
      "  },",
      '  "xai": {',
      '    "apiKey": "sk-xai-...",',
      "    // Search orchestration settings",
      '    "searchParameters": { "mode": "auto" },',
      "  },",
      '  "bedrock": {',
      '    "region": "us-east-1",',
      "    // Uses AWS credential chain if no explicit credentials",
      "  },",
      '  "ollama": {',
      '    "baseUrl": "http://your-server:11434/api", // Custom Ollama server',
      "  },",
      "}",
      "```",
      "",
      "### Bedrock Authentication",
      "",
      "Bedrock supports multiple authentication methods (tried in order):",
      "",
      "1. **Bearer Token** \u2014 Single API key via `bearerToken` config or `AWS_BEARER_TOKEN_BEDROCK` env var",
      "2. **Explicit Credentials** \u2014 `accessKeyId` + `secretAccessKey` in config",
      "3. **AWS Credential Chain** \u2014 Automatic resolution from environment, `~/.aws/credentials`, SSO, EC2/ECS roles",
      "",
      "If you're already authenticated with AWS CLI (`aws sso login`), Mux uses those credentials automatically.",
      "",
      "### OpenRouter Provider Routing",
      "",
      "Control which infrastructure providers handle your requests:",
      "",
      '- `order`: Priority list of providers (e.g., `["Cerebras", "Fireworks"]`)',
      "- `allow_fallbacks`: Whether to try other providers if preferred ones are unavailable",
      "- `only` / `ignore`: Restrict or exclude specific providers",
      '- `data_collection`: `"allow"` or `"deny"` for training data policies',
      "",
      "See [OpenRouter Provider Routing docs](https://openrouter.ai/docs/features/provider-routing) for details.",
      "",
      "### xAI Search Orchestration",
      "",
      'Grok models support live web search. Mux enables this by default with `mode: "auto"`. Customize via [`searchParameters`](https://docs.x.ai/docs/resources/search) for regional focus, time filters, or to disable search.',
      ""
    ].join("\n"),
    "references/docs/config/vim-mode.mdx": [
      "---",
      "title: Vim Mode",
      "description: Vim-style editing in the Mux chat input",
      "---",
      "",
      "Mux includes a built-in Vim mode for the chat input, providing familiar Vim-style editing for power users.",
      "",
      "## Enabling Vim Mode",
      "",
      "Vim mode is always enabled. Press **ESC** to enter normal mode from insert mode.",
      "",
      "## Modes",
      "",
      "### Insert Mode (Default)",
      "",
      "- This is the default mode when typing in the chat input",
      "- Type normally, all characters are inserted",
      "- Press **ESC** or **Ctrl-[** to enter normal mode",
      "",
      "### Normal Mode",
      "",
      "- Command mode for navigation and editing",
      '- Indicated by "NORMAL" text above the input',
      '- Pending commands are shown (e.g., "NORMAL d" when delete is pending)',
      "- Press **i**, **a**, **I**, **A**, **o**, or **O** to return to insert mode",
      "",
      "### Visual Mode",
      "",
      "- Visual selection mode for operating on highlighted text",
      "- Enter with **v** (characterwise) or **V** (linewise)",
      "- Motions extend the selection (e.g. **h/j/k/l**, **w/b/e**, **0/$**)",
      "- Press **Esc** to exit visual mode back to normal mode (cursor returns to the start of the selection)",
      "",
      "Supported operators in visual mode:",
      "",
      "- **d** - Delete selection",
      "- **c** - Change selection (delete and enter insert mode)",
      "- **y** - Yank (copy) selection",
      "",
      "Notes:",
      "",
      "- Counts apply to motions (e.g. `v3w`)",
      "- Operators act on the current selection (no extra motion required)",
      "",
      "## Navigation",
      "",
      "### Basic Movement",
      "",
      "- **h** - Move left one character",
      "- **j** - Move down one line",
      "- **k** - Move up one line",
      "- **l** - Move right one character",
      "",
      "### Word Movement",
      "",
      "- **w** - Move forward to start of next word",
      "- **W** - Move forward to start of next WORD (whitespace-separated)",
      "- **b** - Move backward to start of previous word",
      "- **B** - Move backward to start of previous WORD",
      "- **e** - Move to end of current/next word",
      "- **E** - Move to end of current/next WORD",
      "",
      "### Line Movement",
      "",
      "- **0** - Move to beginning of line",
      "- **\\_** - Move to first non-whitespace character of line",
      "- **$** - Move to end of line",
      "- **Home** - Same as **0**",
      "- **End** - Same as **$**",
      "- **gg** - Go to first line",
      "- **{count}gg** - Go to line {count} (1-indexed)",
      "- **G** - Go to last line",
      "- **{count}G** - Go to line {count} (1-indexed)",
      "",
      "### Find/Till (Current Line)",
      "",
      "- **f{char}** - Find next {char} on the current line",
      "- **F{char}** - Find previous {char} on the current line",
      "- **t{char}** - Move till before next {char} on the current line",
      "- **T{char}** - Move till after previous {char} on the current line",
      "- **;** - Repeat last **f**/**F**/**t**/**T** in the same direction",
      "- **,** - Repeat last **f**/**F**/**t**/**T** in the opposite direction",
      "",
      "Counts apply (e.g. **3fx** finds the third `x` on the line).",
      "",
      "### Column Preservation",
      "",
      "When moving up/down with **j**/**k**, the cursor attempts to stay in the same column position. If a line is shorter, the cursor moves to the end of that line, but will return to the original column on longer lines.",
      "",
      "## Entering Insert Mode",
      "",
      "- **i** - Insert at cursor",
      "- **a** - Append after cursor",
      "- **I** - Insert at beginning of line",
      "- **A** - Append at end of line",
      "- **o** - Open new line below and insert",
      "- **O** - Open new line above and insert",
      "",
      "## Editing Commands",
      "",
      "### Simple Edits",
      "",
      "- **x** - Delete character under cursor",
      "- **p** - Paste after cursor",
      "- **P** - Paste before cursor",
      "",
      "### Undo/Redo",
      "",
      "- **u** - Undo last change",
      "- **Ctrl-r** - Redo",
      "",
      "Notes:",
      "",
      "- Insert-mode typing is grouped: `i ... Esc` becomes a single undo step.",
      "- Undo/redo does not affect the yank register.",
      "",
      "### Dot Repeat",
      "",
      "- **.** - Repeat the last _structural_ edit at the current cursor position.",
      "",
      "Limitations:",
      "",
      "- Dot repeat does not replay arbitrary insert-mode typed text.",
      "- Not every command is repeatable yet (for example, find/till-based edits like `dfx`).",
      "",
      "### Line Operations",
      "",
      "- **dd** - Delete line (yank to clipboard)",
      "- **yy** - Yank (copy) line",
      "- **cc** - Change line (delete and enter insert mode)",
      "",
      "## Operators + Motions",
      "",
      "Vim's power comes from combining operators with motions. All operators work with all motions:",
      "",
      "### Operators",
      "",
      "- **d** - Delete",
      "- **c** - Change (delete and enter insert mode)",
      "- **y** - Yank (copy)",
      "",
      "### Motions",
      "",
      "- **w** - To next word",
      "- **b** - To previous word",
      "- **e** - To end of word",
      "- **W** - To next WORD (whitespace-separated)",
      "- **B** - To previous WORD",
      "- **E** - To end of WORD",
      "- **$** - To end of line",
      "- **0** - To beginning of line",
      "- **\\_** - To first non-whitespace character",
      "- **f{char}** - Find next {char} on the current line",
      "- **F{char}** - Find previous {char} on the current line",
      "- **t{char}** - Move till before next {char} on the current line",
      "- **T{char}** - Move till after previous {char} on the current line",
      "- **;** - Repeat last **f**/**F**/**t**/**T** in the same direction",
      "- **,** - Repeat last **f**/**F**/**t**/**T** in the opposite direction",
      "",
      "### Examples",
      "",
      "- **dw** - Delete to next word",
      "- **dW** - Delete to next WORD",
      "- **de** - Delete to end of word",
      "- **d$** - Delete to end of line",
      "- **dfx** - Delete through next `x` on the line",
      "- **ctx** - Change till before next `x` on the line",
      "- **cw** - Change to end of word (like **ce**)",
      "- **ce** - Change to end of word",
      "- **cW** - Change to end of WORD (like **cE**)",
      "- **cE** - Change to end of WORD",
      "- **c0** - Change to beginning of line",
      "- **y$** - Yank to end of line",
      "- **ye** - Yank to end of word",
      "- **yy** - Yank line (doubled operator)",
      "",
      "### Shortcuts",
      "",
      "- **D** - Same as **d$** (delete to end of line)",
      "- **C** - Same as **c$** (change to end of line)",
      "",
      "## Count Prefixes",
      "",
      "Many motions and commands support numeric count prefixes:",
      "",
      "- **3w** - Move forward three words",
      "- **20l** - Move right 20 characters",
      "- **2dd** - Delete two lines",
      "- **d3w** - Delete three words",
      "",
      "### Parsing rules",
      "",
      "- Digits **1\u20139** start a count.",
      "- **0** appends only if a count is already in progress; otherwise it remains the **0** motion.",
      "- Counts are capped at **10,000**.",
      "",
      "### Supported commands (MVP)",
      "",
      "Counts currently apply to:",
      "",
      "- Motions: **h/j/k/l**, **w/W**, **b/B**, **e/E**, **0**, **$**, **\\_**, **gg**, **G**, **f/F**, **t/T**, **;**, **,**",
      "- Edits: **x**, **~**",
      "- Operator + motion combos, including **dd/yy/cc**",
      "",
      "### Limitations",
      "",
      "Counts are not yet supported for every command (e.g. repeating paste, undo/redo, or insert-mode entry).",
      "",
      "## Text Objects",
      "",
      "Text objects let you operate on semantic units.",
      "",
      "### Words",
      "",
      "- **iw** - Inner word (word under cursor)",
      "  - **diw** - Delete inner word",
      "  - **ciw** - Change inner word",
      "  - **yiw** - Yank inner word",
      "",
      "- **aw** - A word (includes surrounding whitespace)",
      "  - **daw** - Delete word + whitespace",
      "  - **caw** - Change word + whitespace",
      "  - **yaw** - Yank word + whitespace",
      "",
      "Text objects work from anywhere within the word \u2014 you don't need to be at the start.",
      "",
      "### Delimiters (current line only)",
      "",
      "Quotes:",
      "",
      '- **i"** / **a"** - Inside / around double quotes',
      "- **i'** / **a'** - Inside / around single quotes",
      "",
      "Brackets:",
      "",
      "- **i(** / **a(** - Inside / around parentheses",
      "- **i[** / **a[** - Inside / around square brackets",
      "- **i\\{** / **a\\{** - Inside / around curly braces",
      "",
      "Notes:",
      "",
      "- These are currently **line-local** (they don\u2019t search across lines).",
      "- Escaping and complex nesting behavior is not yet supported.",
      "",
      "## Visual Feedback",
      "",
      "- **Cursor**: Thin blinking cursor in insert mode, solid block in normal/visual modes",
      "- **Selection**: Visual mode uses the textarea selection highlight",
      '- **Mode Indicator**: Shows current mode and pending commands (e.g., "NORMAL d" when waiting for motion)',
      "",
      "## Keybind Conflicts",
      "",
      "### ESC Key",
      "",
      "ESC is used for:",
      "",
      "1. Exiting Vim normal mode (highest priority)",
      "2. NOT used for canceling edits (use **Ctrl-Q** instead)",
      "3. NOT used for interrupting streams in Vim mode (use **Ctrl-C**)",
      "4. In non-Vim mode, **Esc** interrupts streams",
      "",
      "### Ctrl+C Key (Vim Mode)",
      "",
      "In Vim mode, **Ctrl+C always interrupts streams** (similar to terminal interrupt behavior). This means:",
      "",
      "- Standard Ctrl+C copy is **not available** in Vim mode",
      "- Use **vim yank commands** (`y`, `yy`, `yiw`, etc.) to copy text instead",
      "- This provides consistent interrupt behavior whether text is selected or not",
      "",
      "## Tips",
      "",
      "1. **Learn operators + motions**: Instead of memorizing every command, learn the operators (d, c, y) and motions (w, b, $, 0). They combine naturally.",
      "",
      "2. **Use text objects**: `ciw` to change a word is more reliable than `cw` because it works from anywhere in the word.",
      "",
      "3. **Column preservation**: When navigating up/down, your column position is preserved across lines of different lengths.",
      "",
      "## Not Yet Implemented",
      "",
      "Features that may be added in the future:",
      "",
      "- **ge** - Backward end of word motion",
      "- **More text objects** - Multi-line delimiters, escaping, and additional objects",
      "- **Visual block mode (Ctrl-v)** - Blockwise selection",
      "- **Macros** - Recording and replaying command sequences",
      "- **Marks** - Named cursor positions",
      ""
    ].join("\n"),
    "references/docs/docs.json": [
      "{",
      '  "$schema": "https://mintlify.com/docs.json",',
      '  "theme": "maple",',
      '  "name": "Mux",',
      '  "logo": {',
      '    "light": "/img/logo-black.svg",',
      '    "dark": "/img/logo-white.svg"',
      "  },",
      '  "favicon": "/favicon.svg",',
      '  "colors": {',
      '    "primary": "#999",',
      '    "light": "#FFF",',
      '    "dark": "#000"',
      "  },",
      '  "appearance": {',
      '    "default": "dark"',
      "  },",
      '  "interaction": {',
      '    "drilldown": true',
      "  },",
      '  "icons": {',
      '    "library": "lucide"',
      "  },",
      '  "css": ["/custom.css"],',
      '  "navigation": {',
      '    "tabs": [',
      "      {",
      '        "tab": "Documentation",',
      '        "groups": [',
      "          {",
      '            "group": "Getting Started",',
      '            "pages": [',
      '              "index",',
      '              "install",',
      "              {",
      '                "group": "Models",',
      '                "pages": ["config/models", "config/providers"]',
      "              },",
      '              "getting-started/why-parallelize",',
      '              "getting-started/mux-gateway",',
      '              "reference/cli"',
      "            ]",
      "          },",
      "          {",
      '            "group": "Workspaces",',
      '            "pages": [',
      '              "workspaces",',
      '              "workspaces/fork",',
      '              "workspaces/sharing",',
      "              {",
      '                "group": "Compaction",',
      '                "pages": [',
      '                  "workspaces/compaction",',
      '                  "workspaces/compaction/manual",',
      '                  "workspaces/compaction/automatic",',
      '                  "workspaces/compaction/customization"',
      "                ]",
      "              },",
      "              {",
      '                "group": "Runtimes",',
      '                "pages": [',
      '                  "runtime",',
      '                  "runtime/local",',
      '                  "runtime/worktree",',
      '                  "runtime/ssh",',
      '                  "runtime/coder",',
      '                  "runtime/docker",',
      '                  "runtime/devcontainer"',
      "                ]",
      "              },",
      "              {",
      '                "group": "Hooks",',
      '                "pages": [',
      '                  "hooks/init",',
      '                  "hooks/tools",',
      '                  "hooks/environment-variables"',
      "                ]",
      "              }",
      "            ]",
      "          },",
      "          {",
      '            "group": "Agents",',
      '            "pages": [',
      '              "agents",',
      '              "agents/instruction-files",',
      '              "agents/agent-skills",',
      '              "agents/plan-mode",',
      '              "agents/system-prompt",',
      '              "agents/prompting-tips"',
      "            ]",
      "          },",
      "          {",
      '            "group": "Configuration",',
      '            "pages": [',
      '              "config/mcp-servers",',
      '              "config/policy-file",',
      '              "config/project-secrets",',
      '              "config/agentic-git-identity",',
      '              "config/keybinds",',
      '              "config/notifications",',
      '              "config/vim-mode"',
      "            ]",
      "          },",
      "",
      "          {",
      '            "group": "Guides",',
      '            "pages": [',
      '              "guides/github-actions",',
      '              "config/agentic-git-identity",',
      '              "agents/prompting-tips"',
      "            ]",
      "          },",
      "          {",
      '            "group": "Integrations",',
      '            "pages": ["integrations/vscode-extension"]',
      "          },",
      "          {",
      '            "group": "Reference",',
      '            "pages": [',
      '              "reference/telemetry",',
      '              "reference/storybook",',
      '              "reference/benchmarking",',
      '              "AGENTS"',
      "            ]",
      "          }",
      "        ]",
      "      }",
      "    ]",
      "  },",
      '  "footerSocials": {',
      '    "github": "https://github.com/coder/mux"',
      "  },",
      '  "integrations": {',
      '    "ga4": {',
      '      "measurementId": "G-D1HL4PBRSY"',
      "    }",
      "  },",
      '  "contextual": {',
      '    "options": ["copy", "view", "chatgpt", "claude", "cursor", "vscode"]',
      "  },",
      '  "redirects": [',
      '    { "source": "/why-parallelize", "destination": "/getting-started/why-parallelize" },',
      '    { "source": "/mux-codes", "destination": "/getting-started/mux-gateway" },',
      '    { "source": "/getting-started/mux-codes", "destination": "/getting-started/mux-gateway" },',
      '    { "source": "/fork", "destination": "/workspaces/fork" },',
      '    { "source": "/init-hooks", "destination": "/hooks/init" },',
      '    { "source": "/agent-skills", "destination": "/agents/agent-skills" },',
      '    { "source": "/instruction-files", "destination": "/agents/instruction-files" },',
      '    { "source": "/plan-mode", "destination": "/agents/plan-mode" },',
      '    { "source": "/system-prompt", "destination": "/agents/system-prompt" },',
      '    { "source": "/models", "destination": "/config/models" },',
      '    { "source": "/providers", "destination": "/config/providers" },',
      '    { "source": "/mcp-servers", "destination": "/config/mcp-servers" },',
      '    { "source": "/project-secrets", "destination": "/config/project-secrets" },',
      '    { "source": "/agentic-git-identity", "destination": "/config/agentic-git-identity" },',
      '    { "source": "/keybinds", "destination": "/config/keybinds" },',
      '    { "source": "/notifications", "destination": "/config/notifications" },',
      '    { "source": "/cli", "destination": "/reference/cli" },',
      '    { "source": "/guides/cli", "destination": "/reference/cli" },',
      '    { "source": "/context-management", "destination": "/workspaces/compaction" },',
      '    { "source": "/guides/context-management", "destination": "/workspaces/compaction" },',
      '    { "source": "/guides/compaction", "destination": "/workspaces/compaction" },',
      '    { "source": "/guides/compaction/manual", "destination": "/workspaces/compaction/manual" },',
      '    { "source": "/guides/compaction/automatic", "destination": "/workspaces/compaction/automatic" },',
      '    { "source": "/sharing", "destination": "/workspaces/sharing" },',
      '    { "source": "/guides/sharing", "destination": "/workspaces/sharing" },',
      '    { "source": "/prompting-tips", "destination": "/agents/prompting-tips" },',
      '    { "source": "/guides/prompting-tips", "destination": "/agents/prompting-tips" },',
      '    { "source": "/vim-mode", "destination": "/config/vim-mode" },',
      '    { "source": "/guides/vim-mode", "destination": "/config/vim-mode" },',
      '    { "source": "/vscode-extension", "destination": "/integrations/vscode-extension" },',
      '    { "source": "/telemetry", "destination": "/reference/telemetry" },',
      '    { "source": "/storybook", "destination": "/reference/storybook" },',
      '    { "source": "/benchmarking", "destination": "/reference/benchmarking" }',
      "  ]",
      "}",
      ""
    ].join("\n"),
    "references/docs/getting-started/mux-gateway.mdx": [
      "---",
      "title: Mux Gateway",
      "description: Log in to Mux Gateway to get evaluation credits",
      "---",
      "",
      "Mux Gateway is an optional provider that routes requests through Coder's gateway, so you can try supported models with evaluation credits (if eligible).",
      "",
      "## Eligibility",
      "",
      "Currently, OSS contributors with GitHub accounts older than 12 months (or GitHub Pro members) can receive evaluation credits after logging in.",
      "",
      "If you're not eligible (or you run out of credits), you can still use Mux by configuring providers directly with your own API keys.",
      "",
      "## Mux Codes",
      "",
      "If you receive a **Mux Code** (for example, at an event), redeem it on the Gateway website and the credits will be applied to your GitHub account.",
      "",
      "1. Go to [gateway.mux.coder.com](https://gateway.mux.coder.com) and sign in with GitHub.",
      "2. Redeem the code.",
      "   - The credit is assigned to the GitHub account you used to redeem it.",
      "   - You do **not** need to paste the code into the Mux app.",
      "3. In Mux, click **Login to Mux Gateway** and sign in with that same GitHub account \u2014 your updated balance should show up in Settings.",
      "",
      "## Log in",
      "",
      "1. Open Mux (see [install](/install) for instructions).",
      "2. Open **Settings** (Cmd+, on macOS).",
      "3. Under **Providers**, expand **Mux Gateway**.",
      "4. Click **Login to Mux Gateway** and complete the browser flow.",
      "5. Return to Mux \u2014 your Gateway balance and limits should show up in Settings.",
      "",
      "## Enable Mux Gateway for models",
      "",
      "1. In **Settings \u2192 Models**, turn on **Mux Gateway** for the model(s) you want to use.",
      "2. Optionally, click **Star** to set a model as your default model.",
      "",
      "## Our Ask",
      "",
      "As Mux is in its early development stage, we highly value user feedback. Please let us know of any issues you encounter or feature requests in [our tracker](https://github.com/coder/mux/issues).",
      ""
    ].join("\n"),
    "references/docs/getting-started/why-parallelize.mdx": [
      "---",
      "title: Why Parallelize?",
      "description: Use cases for running multiple AI agents in parallel",
      "---",
      "",
      "A few reasons parallel workspaces matter:",
      "",
      "- **Keep context aligned**: Create dedicated workspaces for threads like `code-review`, `refactor`, and `new-feature`.",
      "- **Run long jobs in the background**: Kick off a slow, high-accuracy model for a deep investigation or refactor.",
      "  - Streams resume after restarts or intermittent connection issues.",
      "  - Mux shows an indicator when the model finishes.",
      "- **A/B implementations**: Try multiple approaches to the same problem and keep the best one.",
      "- **Tangent management**: Fork or create a new workspace for side quests so the main thread stays focused.",
      ""
    ].join("\n"),
    "references/docs/guides/github-actions.mdx": [
      "---",
      "title: GitHub Actions",
      "description: Automate your workflows with mux run in GitHub Actions",
      "---",
      "",
      "`mux run` is designed for automation scenarios like CI/CD pipelines. This guide shows how to integrate mux into your GitHub Actions workflows.",
      "",
      "## Prerequisites",
      "",
      "1. **API Key**: Add your `ANTHROPIC_API_KEY` (or other provider key) to your repository's secrets. See [Providers](/config/providers) for details on configuring API keys.",
      "2. **npm/bun**: The workflow will install Mux via `bunx` or `npx`",
      "",
      "## Basic Usage",
      "",
      "Here's a minimal example that runs Mux in a GitHub Action:",
      "",
      "```yaml",
      "- name: Mux Review",
      "  env:",
      "    ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}",
      "    GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}",
      '  run: bunx mux run "Review this PR for critical issues. If any are found, exit with 1 to block merge."',
      "```",
      "",
      "`mux run` supports agent-controlled exit codes, so the workflow step can fail when issues are found.",
      "",
      "### Key Options for CI",
      "",
      "| Option           | Purpose                                        |",
      "| ---------------- | ---------------------------------------------- |",
      "| `--quiet`        | Only output final result (cleaner logs)        |",
      "| `--json`         | Machine-readable NDJSON output for parsing     |",
      "| `--budget <usd>` | Limit spending per run (e.g., `--budget 1.00`) |",
      "",
      "## Example: Auto-Cleanup Workflow",
      "",
      "This is the exact workflow used live in the Mux repo (see [`.github/workflows/auto-cleanup.yml`](https://github.com/coder/mux/blob/main/.github/workflows/auto-cleanup.yml)). It runs periodically to identify low-risk cleanup opportunities and maintains a refactor PR with improvements.",
      "",
      "The prompt is stored in a separate file ([`.github/prompts/auto-cleanup.md`](https://github.com/coder/mux/blob/main/.github/prompts/auto-cleanup.md)) and piped via stdin, keeping the workflow file clean and the prompt easy to iterate on.",
      "",
      "{/* BEGIN AUTO_CLEANUP_WORKFLOW */}",
      "",
      "```yaml",
      "# Periodically cleans up the codebase and maintains a refactor PR.",
      "# SETUP: Add ANTHROPIC_API_KEY to repository secrets.",
      "",
      "name: Auto-Cleanup",
      "",
      "on:",
      "  schedule:",
      '    - cron: "0 */4 * * *" # Every 4 hours',
      "  workflow_dispatch:",
      "",
      "permissions:",
      "  contents: write",
      "  pull-requests: write",
      "",
      "jobs:",
      "  cleanup:",
      "    runs-on: ubuntu-latest",
      "    steps:",
      "      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1",
      "        with:",
      "          fetch-depth: 0",
      "      - uses: oven-sh/setup-bun@b7a1c7ccf290d58743029c4f6903da283811b979 # v2.1.0",
      "",
      "      - name: Cleanup with mux",
      "        env:",
      "          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}",
      "          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}",
      "        run: |",
      '          [ -z "$ANTHROPIC_API_KEY" ] && echo "Skipping (no API key)" && exit 0',
      "",
      "          bunx mux@next run \\",
      "            --model anthropic:claude-opus-4-6 \\",
      "            --thinking xhigh \\",
      "            < .github/prompts/auto-cleanup.md",
      "```",
      "",
      "{/* END AUTO_CLEANUP_WORKFLOW */}",
      "",
      "<CardGroup cols={2}>",
      '  <Card title="CLI Reference" icon="terminal" href="/reference/cli">',
      "    Full CLI documentation",
      "  </Card>",
      '  <Card title="Agentic Git Identity" icon="user-robot" href="/config/agentic-git-identity">',
      "    Configure separate Git identity for AI commits",
      "  </Card>",
      "</CardGroup>",
      ""
    ].join("\n"),
    "references/docs/hooks/environment-variables.mdx": [
      "---",
      "title: Environment Variables",
      "description: Environment variables available in agent bash commands and hooks",
      "---",
      "",
      "The following environment variables are available in all agent bash tool executions, including [init hooks](/hooks/init).",
      "",
      "## Available Variables",
      "",
      "| Variable             | Description                                                                                                                   |",
      "| -------------------- | ----------------------------------------------------------------------------------------------------------------------------- |",
      "| `MUX_PROJECT_PATH`   | Absolute path to the project root on the **local machine**. Always refers to your local project path, even on SSH workspaces. |",
      '| `MUX_RUNTIME`        | Runtime type: `"local"`, `"worktree"`, `"ssh"`, or `"docker"`                                                                 |',
      "| `MUX_WORKSPACE_NAME` | Name of the workspace (typically the branch name)                                                                             |",
      '| `MUX_MODEL_STRING`   | Model identifier (e.g., `"anthropic:claude-sonnet-4-20250514"`)                                                               |',
      '| `MUX_THINKING_LEVEL` | Reasoning level: `"off"`, `"low"`, `"medium"`, `"high"`, or `"xhigh"`                                                         |',
      '| `MUX_COSTS_USD`      | Cumulative session costs in USD, formatted to 2 decimal places (e.g., `"1.23"`)                                               |',
      "",
      "## Usage Example",
      "",
      "```bash",
      "#!/usr/bin/env bash",
      "",
      'echo "Project: $MUX_PROJECT_PATH"',
      'echo "Runtime: $MUX_RUNTIME"',
      'echo "Workspace: $MUX_WORKSPACE_NAME"',
      'echo "Model: $MUX_MODEL_STRING"',
      'echo "Thinking: $MUX_THINKING_LEVEL"',
      'echo "Costs: \\$${MUX_COSTS_USD:-0.00}"',
      "",
      "# Runtime-specific behavior",
      'if [ "$MUX_RUNTIME" = "ssh" ]; then',
      '  echo "Running on SSH remote"',
      'elif [ "$MUX_RUNTIME" = "docker" ]; then',
      '  echo "Running in Docker container"',
      "else",
      '  echo "Running locally"',
      "fi",
      "```",
      "",
      "## Use Cases",
      "",
      "- **PR footers**: Include model and cost information in automated PR descriptions",
      "- **Conditional logic**: Adapt scripts based on runtime environment",
      "- **Logging**: Track which model and settings were used for a task",
      "- **Cost monitoring**: Check cumulative costs before expensive operations",
      ""
    ].join("\n"),
    "references/docs/hooks/init.mdx": [
      "---",
      "title: Init Hooks",
      "description: Run setup commands automatically when creating new workspaces",
      "---",
      "",
      "Add a `.mux/init` executable script to your project root to run commands when creating new workspaces.",
      "",
      "## Example",
      "",
      "```bash",
      "#!/usr/bin/env bash",
      "set -e",
      "",
      "bun install",
      "bun run build",
      "```",
      "",
      "Make it executable:",
      "",
      "```bash",
      "chmod +x .mux/init",
      "```",
      "",
      "## Behavior",
      "",
      "- **Runs once** per workspace on creation",
      "- **Streams output** to the workspace UI in real-time",
      "- **Non-blocking** - workspace is immediately usable, even while hook runs",
      "- **Exit codes preserved** - failures are logged but don't prevent workspace usage",
      "",
      "The init script runs in the workspace directory with the workspace's environment.",
      "",
      "## Environment Variables",
      "",
      "Init hooks receive [environment variables](/hooks/environment-variables) including `MUX_PROJECT_PATH`, `MUX_RUNTIME`, `MUX_WORKSPACE_NAME`, and more.",
      "",
      "**Note for SSH workspaces:** Since the project is synced to the remote machine, files exist in both locations. The init hook runs in the workspace directory (`$PWD`), so use relative paths to reference project files:",
      "",
      "```bash",
      "#!/usr/bin/env bash",
      "set -e",
      "",
      'echo "Runtime: $MUX_RUNTIME"',
      'echo "Local project path: $MUX_PROJECT_PATH"',
      'echo "Workspace directory: $PWD"',
      "",
      "# Copy .env from project root (works for both local and SSH)",
      "# The hook runs with cwd = workspace, and project root is the parent directory",
      'if [ -f "../.env" ]; then',
      '  cp "../.env" "$PWD/.env"',
      "fi",
      "",
      "# Runtime-specific behavior",
      'if [ "$MUX_RUNTIME" = "local" ]; then',
      '  echo "Running on local machine"',
      "else",
      '  echo "Running on SSH remote"',
      "fi",
      "",
      "bun install",
      "```",
      "",
      "## Use Cases",
      "",
      "- Install dependencies (`npm install`, `bun install`, etc.)",
      "- Run build steps",
      "- Generate code or configs",
      "- Set up databases or services",
      "- Warm caches",
      "",
      "## Output",
      "",
      "Init output appears in a banner at the top of the workspace. Click to expand/collapse the log. The banner shows:",
      "",
      "- Script path (`.mux/init`)",
      "- Status (running, success, or exit code on failure)",
      "- Full stdout/stderr output",
      "",
      "## Idempotency",
      "",
      "The hook runs every time you create a workspace, even if you delete and recreate with the same name. Make your script idempotent if you're modifying shared state.",
      ""
    ].join("\n"),
    "references/docs/hooks/tools.mdx": [
      "---",
      "title: Tool Hooks",
      "description: Block dangerous commands, lint after edits, and set up your environment",
      "---",
      "",
      "<Note>Tool hooks are experimental. Expect breaking changes while we iterate.</Note>",
      "",
      "<Tip>",
      '  **The easiest way to set up tool hooks is to ask Mux.** Just tell Mux what you want (e.g., "lint',
      '  Python files after edits" or "block force pushes") and it will create the hook scripts for you.',
      "</Tip>",
      "",
      "Tool hooks let you run your own scripts before and after Mux tool executions.",
      "",
      "## What do you want to do?",
      "",
      "<CardGroup cols={3}>",
      '  <Card title="Block dangerous commands" icon="shield" href="#block-dangerous-commands">',
      "    Prevent force pushes, rm -rf, etc.",
      "  </Card>",
      '  <Card title="Lint after file edits" icon="check" href="#lint-after-file-edits">',
      "    Run ruff, eslint, tsc after changes",
      "  </Card>",
      '  <Card title="Set up environment" icon="gear" href="#set-up-environment">',
      "    direnv, nvm, virtualenv",
      "  </Card>",
      "</CardGroup>",
      "",
      "---",
      "",
      "## Block dangerous commands",
      "",
      "Create `.mux/tool_pre` to validate commands before they run. Exit non-zero to block:",
      "",
      "```bash",
      "#!/usr/bin/env bash",
      "# .mux/tool_pre - runs before every tool",
      "",
      'if [[ "$MUX_TOOL" == "bash" ]]; then',
      '  script="$MUX_TOOL_INPUT_SCRIPT"',
      "",
      `  if echo "$script" | grep -q 'push.*--force'; then`,
      '    echo "\u274C Force push blocked" >&2',
      "    exit 1",
      "  fi",
      "",
      `  if echo "$script" | grep -q 'rm -rf /'; then`,
      '    echo "\u274C Dangerous rm blocked" >&2',
      "    exit 1",
      "  fi",
      "fi",
      "",
      "exit 0  # Allow tool to run",
      "```",
      "",
      "```bash",
      "chmod +x .mux/tool_pre",
      "```",
      "",
      "The agent sees your error message and can adjust its approach.",
      "",
      "---",
      "",
      "## Lint after file edits",
      "",
      "Create `.mux/tool_post` to run validation after tools complete:",
      "",
      "```bash",
      "#!/usr/bin/env bash",
      "# .mux/tool_post - runs after every tool",
      "set -euo pipefail",
      "",
      '[[ "$MUX_TOOL" == file_edit_* ]] || exit 0',
      'file="${MUX_TOOL_INPUT_FILE_PATH:-}"',
      '[[ -n "$file" ]] || exit 0',
      "",
      'case "$file" in',
      "  *.py)",
      '    ruff check "$file"',
      "    ;;",
      "  *.ts|*.tsx)",
      '    npx tsc --noEmit "$file"',
      "    ;;",
      "esac",
      "```",
      "",
      "```bash",
      "chmod +x .mux/tool_post",
      "```",
      "",
      "<details>",
      "<summary>Minimal formatter example (Go)</summary>",
      "",
      "```bash",
      "#!/usr/bin/env bash",
      "# .mux/tool_post - runs after every tool",
      "set -euo pipefail",
      "",
      '[[ "$MUX_TOOL" == file_edit_* ]] || exit 0',
      'file="${MUX_TOOL_INPUT_FILE_PATH:-}"',
      '[[ "$file" == *.go ]] || exit 0',
      "",
      'gofmt -w "$file"',
      "```",
      "",
      "</details>",
      "",
      "Lint errors appear in `hook_output` and the agent can fix them.",
      "",
      "<Note>",
      "  `hook_output` is only shown in the UI when the hook produces output. For a cleaner experience,",
      '  only print output when the hook has an effect\u2014e.g., skip "Formatted: file" messages if the file',
      "  was already formatted.",
      "</Note>",
      "",
      "---",
      "",
      "## Set up environment",
      "",
      "Create `.mux/tool_env` to configure your shell environment. This file is **sourced** before every `bash` tool call:",
      "",
      "```bash",
      "# .mux/tool_env - sourced before bash commands",
      "",
      "# direnv",
      'eval "$(direnv export bash 2>/dev/null)" || true',
      "",
      "# nvm",
      '# export NVM_DIR="$HOME/.nvm"',
      '# [ -s "$NVM_DIR/nvm.sh" ] && source "$NVM_DIR/nvm.sh"',
      "",
      "# Python virtualenv",
      "# source .venv/bin/activate 2>/dev/null || true",
      "```",
      "",
      "<Note>",
      "  Unlike hooks, `tool_env` doesn't need to be executable\u2014it's sourced, not run. It only affects",
      "  `bash` tools.",
      "</Note>",
      "",
      "---",
      "",
      "## Reference",
      "",
      '<Accordion title="Environment Variables">',
      "",
      "All hooks receive these environment variables:",
      "",
      "| Variable              | Description                                                      |",
      "| --------------------- | ---------------------------------------------------------------- |",
      "| `MUX_TOOL`            | Tool name: `bash`, `file_edit_replace_string`, `file_read`, etc. |",
      "| `MUX_WORKSPACE_ID`    | Current workspace identifier                                     |",
      "| `MUX_TOOL_INPUT_PATH` | Path to file containing full tool input (always set)             |",
      "",
      "Mux flattens the tool input into `MUX_TOOL_INPUT_<...>` environment variables (see the appendix below). Fields longer than 8KB are omitted\u2014use `MUX_TOOL_INPUT_PATH` for full access.",
      "",
      "**Post-hook only (`tool_post`):**",
      "",
      "| Variable               | Description                              |",
      "| ---------------------- | ---------------------------------------- |",
      "| `MUX_TOOL_RESULT_PATH` | Path to file containing full tool result |",
      "",
      "Flattened result fields are available as `MUX_TOOL_RESULT_<...>`. Fields longer than 8KB are omitted\u2014use `MUX_TOOL_RESULT_PATH` for full access.",
      "",
      "</Accordion>",
      "",
      '<Accordion title="Exit Codes">',
      "",
      "| Exit Code | `tool_pre` behavior                | `tool_post` behavior                  |",
      "| --------- | ---------------------------------- | ------------------------------------- |",
      "| `0`       | Tool executes normally             | Success, output shown to agent        |",
      "| Non-zero  | Tool blocked, error shown to agent | Failure, error shown in `hook_output` |",
      "",
      "</Accordion>",
      "",
      '<Accordion title="Hook Priority & Location">',
      "",
      "Mux searches for each hook file in this order:",
      "",
      "1. Project-level: `.mux/<hook>`",
      "2. User-level: `~/.mux/<hook>`",
      "",
      "This applies to `tool_pre`, `tool_post`, and `tool_env`.",
      "",
      "For SSH workspaces, hooks execute **on the remote machine**.",
      "",
      "</Accordion>",
      "",
      '<Accordion title="Timeouts">',
      "",
      "Hooks must complete within **10 seconds** or they're terminated. Long-running tools (builds, tests) don't count against this\u2014only hook execution time.",
      "",
      "Keep hooks fast\u2014if you need longer operations, consider running them asynchronously or in the background.",
      "",
      "</Accordion>",
      "",
      '<Accordion title="Comparison">',
      "",
      "| Feature        | `.mux/tool_pre`          | `.mux/tool_post`      | `.mux/tool_env`         |",
      "| -------------- | ------------------------ | --------------------- | ----------------------- |",
      "| **Purpose**    | Block dangerous commands | Lint/validate results | Environment setup       |",
      "| **Runs**       | Before tool              | After tool            | Sourced in bash shell   |",
      "| **Applies to** | All tools                | All tools             | `bash` tool only        |",
      "| **Use case**   | Block force-push         | Run ruff/eslint       | direnv, nvm, virtualenv |",
      "",
      "</Accordion>",
      "",
      '<Accordion title="Appendix: Tool input env vars (auto-generated)">',
      "",
      "Mux also provides flattened tool input env vars so hook scripts can stay compact.",
      "",
      "- Scalars become `MUX_TOOL_INPUT_<FIELD>`",
      "- Nested objects become `MUX_TOOL_INPUT_<PARENT>_<CHILD>`",
      "- Arrays also include `..._COUNT` and per-index variables like `..._<INDEX>`",
      "",
      "If a value is too large for the environment, it may be omitted (not set). Mux also caps the number of flattened env vars and array elements to keep hook execution reliable.",
      "",
      "{/* BEGIN TOOL_HOOK_ENV_VARS */}",
      "",
      "<details>",
      "<summary>agent_report (2)</summary>",
      "",
      "| Env var                          | JSON path        | Type   | Description |",
      "| -------------------------------- | ---------------- | ------ | ----------- |",
      "| `MUX_TOOL_INPUT_REPORT_MARKDOWN` | `reportMarkdown` | string | \u2014           |",
      "| `MUX_TOOL_INPUT_TITLE`           | `title`          | string | \u2014           |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>agent_skill_read (1)</summary>",
      "",
      "| Env var               | JSON path | Type   | Description                                       |",
      "| --------------------- | --------- | ------ | ------------------------------------------------- |",
      "| `MUX_TOOL_INPUT_NAME` | `name`    | string | Skill name (directory name under the skills root) |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>agent_skill_read_file (4)</summary>",
      "",
      "| Env var                    | JSON path  | Type   | Description                                                                    |",
      "| -------------------------- | ---------- | ------ | ------------------------------------------------------------------------------ |",
      "| `MUX_TOOL_INPUT_FILE_PATH` | `filePath` | string | Path to the file within the skill directory (relative)                         |",
      "| `MUX_TOOL_INPUT_LIMIT`     | `limit`    | number | Number of lines to return from offset (optional, returns all if not specified) |",
      "| `MUX_TOOL_INPUT_NAME`      | `name`     | string | Skill name (directory name under the skills root)                              |",
      "| `MUX_TOOL_INPUT_OFFSET`    | `offset`   | number | 1-based starting line number (optional, defaults to 1)                         |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>ask_user_question (8)</summary>",
      "",
      "| Env var                                                        | JSON path                                         | Type    | Description                                            |",
      "| -------------------------------------------------------------- | ------------------------------------------------- | ------- | ------------------------------------------------------ |",
      "| `MUX_TOOL_INPUT_ANSWERS_<KEY>`                                 | `answers[<KEY>]`                                  | string  | \u2014                                                      |",
      "| `MUX_TOOL_INPUT_QUESTIONS_<INDEX>_HEADER`                      | `questions[<INDEX>].header`                       | string  | Short label shown in the UI (keep it concise)          |",
      "| `MUX_TOOL_INPUT_QUESTIONS_<INDEX>_MULTI_SELECT`                | `questions[<INDEX>].multiSelect`                  | boolean | \u2014                                                      |",
      "| `MUX_TOOL_INPUT_QUESTIONS_<INDEX>_OPTIONS_<INDEX>_DESCRIPTION` | `questions[<INDEX>].options[<INDEX>].description` | string  | \u2014                                                      |",
      "| `MUX_TOOL_INPUT_QUESTIONS_<INDEX>_OPTIONS_<INDEX>_LABEL`       | `questions[<INDEX>].options[<INDEX>].label`       | string  | \u2014                                                      |",
      "| `MUX_TOOL_INPUT_QUESTIONS_<INDEX>_OPTIONS_COUNT`               | `questions[<INDEX>].options.length`               | number  | Number of elements in questions[&lt;INDEX&gt;].options |",
      "| `MUX_TOOL_INPUT_QUESTIONS_<INDEX>_QUESTION`                    | `questions[<INDEX>].question`                     | string  | \u2014                                                      |",
      "| `MUX_TOOL_INPUT_QUESTIONS_COUNT`                               | `questions.length`                                | number  | Number of elements in questions                        |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>bash (4)</summary>",
      "",
      "| Env var                            | JSON path           | Type    | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |",
      "| ---------------------------------- | ------------------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |",
      "| `MUX_TOOL_INPUT_DISPLAY_NAME`      | `display_name`      | string  | Human-readable name for the process (e.g., 'Dev Server', 'TypeCheck Watch'). Required for all bash invocations since any process can be sent to background.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |",
      "| `MUX_TOOL_INPUT_RUN_IN_BACKGROUND` | `run_in_background` | boolean | Run this command in the background without blocking. Use for processes running &gt;5s (dev servers, builds, file watchers). Do NOT use for quick commands (&lt;5s), interactive processes (no stdin support), or processes requiring real-time output (use foreground with larger timeout instead). Returns immediately with a taskId (bash:&lt;processId&gt;) and backgroundProcessId. Read output with task_await (returns only new output since last check). Terminate with task_terminate using the taskId. List active tasks with task_list. Process persists until timeout_secs expires, terminated, or workspace is removed. For long-running tasks like builds or compilations, prefer background mode to continue productive work in parallel. Check back periodically with task_await rather than blocking on completion. |",
      "| `MUX_TOOL_INPUT_SCRIPT`            | `script`            | string  | The bash script/command to execute                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |",
      "| `MUX_TOOL_INPUT_TIMEOUT_SECS`      | `timeout_secs`      | number  | Timeout in seconds. For foreground: max execution time before kill. For background: max lifetime before auto-termination. Start small and increase on retry; avoid large initial values to keep UX responsive                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>bash_background_terminate (1)</summary>",
      "",
      "| Env var                     | JSON path    | Type   | Description                        |",
      "| --------------------------- | ------------ | ------ | ---------------------------------- |",
      "| `MUX_TOOL_INPUT_PROCESS_ID` | `process_id` | string | Background process ID to terminate |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>bash_output (4)</summary>",
      "",
      "| Env var                         | JSON path        | Type    | Description                                                                                                                                                                                                                                                                                                                                                                                                        |",
      "| ------------------------------- | ---------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |",
      "| `MUX_TOOL_INPUT_FILTER`         | `filter`         | string  | Optional regex to filter output lines. By default, only matching lines are returned. When filter_exclude is true, matching lines are excluded instead. Non-matching lines are permanently discarded and cannot be retrieved later.                                                                                                                                                                                 |",
      "| `MUX_TOOL_INPUT_FILTER_EXCLUDE` | `filter_exclude` | boolean | When true, lines matching 'filter' are excluded instead of kept. Key behavior: excluded lines do NOT cause early return from timeout - waiting continues until non-excluded output arrives or process exits. Use to avoid busy polling on progress spam (e.g., filter='\u23F3\\|waiting\\|\\.\\.\\.' with filter_exclude=true lets you set a long timeout and only wake on meaningful output). Requires 'filter' to be set. |",
      "| `MUX_TOOL_INPUT_PROCESS_ID`     | `process_id`     | string  | The ID of the background process to retrieve output from                                                                                                                                                                                                                                                                                                                                                           |",
      "| `MUX_TOOL_INPUT_TIMEOUT_SECS`   | `timeout_secs`   | number  | Seconds to wait for new output. If no output is immediately available and process is still running, blocks up to this duration. Returns early when output arrives or process exits. Only use long timeouts (&gt;15s) when no other useful work can be done in parallel.                                                                                                                                            |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>code_execution (1)</summary>",
      "",
      "| Env var               | JSON path | Type   | Description                                   |",
      "| --------------------- | --------- | ------ | --------------------------------------------- |",
      "| `MUX_TOOL_INPUT_CODE` | `code`    | string | JavaScript code to execute in the PTC sandbox |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>file_edit_insert (4)</summary>",
      "",
      "| Env var                        | JSON path       | Type   | Description                                                                             |",
      "| ------------------------------ | --------------- | ------ | --------------------------------------------------------------------------------------- |",
      "| `MUX_TOOL_INPUT_CONTENT`       | `content`       | string | The content to insert                                                                   |",
      "| `MUX_TOOL_INPUT_FILE_PATH`     | `file_path`     | string | Path to the file to edit (absolute or relative to the current workspace)                |",
      "| `MUX_TOOL_INPUT_INSERT_AFTER`  | `insert_after`  | string | Anchor text to insert after. Content will be placed immediately after this substring.   |",
      "| `MUX_TOOL_INPUT_INSERT_BEFORE` | `insert_before` | string | Anchor text to insert before. Content will be placed immediately before this substring. |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>file_edit_replace_lines (7)</summary>",
      "",
      "| Env var                                 | JSON path                 | Type   | Description                                                                                                                               |",
      "| --------------------------------------- | ------------------------- | ------ | ----------------------------------------------------------------------------------------------------------------------------------------- |",
      "| `MUX_TOOL_INPUT_END_LINE`               | `end_line`                | number | 1-indexed end line (inclusive) to replace                                                                                                 |",
      "| `MUX_TOOL_INPUT_EXPECTED_LINES_<INDEX>` | `expected_lines[<INDEX>]` | string | Optional safety check. When provided, the current lines in the specified range must match exactly.                                        |",
      "| `MUX_TOOL_INPUT_EXPECTED_LINES_COUNT`   | `expected_lines.length`   | number | Number of elements in expected_lines (Optional safety check. When provided, the current lines in the specified range must match exactly.) |",
      "| `MUX_TOOL_INPUT_FILE_PATH`              | `file_path`               | string | Path to the file to edit (absolute or relative to the current workspace)                                                                  |",
      "| `MUX_TOOL_INPUT_NEW_LINES_<INDEX>`      | `new_lines[<INDEX>]`      | string | Replacement lines. Provide an empty array to delete the specified range.                                                                  |",
      "| `MUX_TOOL_INPUT_NEW_LINES_COUNT`        | `new_lines.length`        | number | Number of elements in new_lines (Replacement lines. Provide an empty array to delete the specified range.)                                |",
      "| `MUX_TOOL_INPUT_START_LINE`             | `start_line`              | number | 1-indexed start line (inclusive) to replace                                                                                               |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>file_edit_replace_string (4)</summary>",
      "",
      "| Env var                        | JSON path       | Type   | Description                                                                                                                                          |",
      "| ------------------------------ | --------------- | ------ | ---------------------------------------------------------------------------------------------------------------------------------------------------- |",
      "| `MUX_TOOL_INPUT_FILE_PATH`     | `file_path`     | string | Path to the file to edit (absolute or relative to the current workspace)                                                                             |",
      "| `MUX_TOOL_INPUT_NEW_STRING`    | `new_string`    | string | The replacement text                                                                                                                                 |",
      "| `MUX_TOOL_INPUT_OLD_STRING`    | `old_string`    | string | The exact text to replace (must be unique in file if replace_count is 1). Include enough context (indentation, surrounding lines) to make it unique. |",
      "| `MUX_TOOL_INPUT_REPLACE_COUNT` | `replace_count` | number | Number of occurrences to replace (default: 1). Use -1 to replace all occurrences. If 1, old_string must be unique in the file.                       |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>file_read (3)</summary>",
      "",
      "| Env var                    | JSON path   | Type   | Description                                                                    |",
      "| -------------------------- | ----------- | ------ | ------------------------------------------------------------------------------ |",
      "| `MUX_TOOL_INPUT_FILE_PATH` | `file_path` | string | The path to the file to read (absolute or relative)                            |",
      "| `MUX_TOOL_INPUT_LIMIT`     | `limit`     | number | Number of lines to return from offset (optional, returns all if not specified) |",
      "| `MUX_TOOL_INPUT_OFFSET`    | `offset`    | number | 1-based starting line number (optional, defaults to 1)                         |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>mux_global_agents_write (2)</summary>",
      "",
      "| Env var                      | JSON path    | Type    | Description                                                                            |",
      "| ---------------------------- | ------------ | ------- | -------------------------------------------------------------------------------------- |",
      "| `MUX_TOOL_INPUT_CONFIRM`     | `confirm`    | boolean | Must be true to apply the write. The agent should ask the user for confirmation first. |",
      "| `MUX_TOOL_INPUT_NEW_CONTENT` | `newContent` | string  | The full new contents of the global AGENTS.md file                                     |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>notify (2)</summary>",
      "",
      "| Env var                  | JSON path | Type   | Description                                                                                                 |",
      "| ------------------------ | --------- | ------ | ----------------------------------------------------------------------------------------------------------- |",
      "| `MUX_TOOL_INPUT_MESSAGE` | `message` | string | Optional notification body with more details (max 200 chars). Keep it brief - users may only see a preview. |",
      "| `MUX_TOOL_INPUT_TITLE`   | `title`   | string | Short notification title (max 64 chars). Should be concise and actionable.                                  |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>status_set (3)</summary>",
      "",
      "| Env var                  | JSON path | Type   | Description                                                                                                                                  |",
      "| ------------------------ | --------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------------- |",
      "| `MUX_TOOL_INPUT_EMOJI`   | `emoji`   | string | A single emoji character representing the current activity                                                                                   |",
      "| `MUX_TOOL_INPUT_MESSAGE` | `message` | string | A brief description of the current activity (auto-truncated to 60 chars with ellipsis if needed)                                             |",
      "| `MUX_TOOL_INPUT_URL`     | `url`     | string | Optional URL to external resource with more details (e.g., Pull Request URL). The URL persists and is displayed to the user for easy access. |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>system1_keep_ranges (4)</summary>",
      "",
      "| Env var                                     | JSON path                     | Type   | Description                                             |",
      "| ------------------------------------------- | ----------------------------- | ------ | ------------------------------------------------------- |",
      "| `MUX_TOOL_INPUT_KEEP_RANGES_<INDEX>_END`    | `keep_ranges[<INDEX>].end`    | number | 1-based end line (inclusive) in the numbered output     |",
      "| `MUX_TOOL_INPUT_KEEP_RANGES_<INDEX>_REASON` | `keep_ranges[<INDEX>].reason` | string | Optional short reason for keeping this range            |",
      "| `MUX_TOOL_INPUT_KEEP_RANGES_<INDEX>_START`  | `keep_ranges[<INDEX>].start`  | number | 1-based start line (inclusive) in the numbered output   |",
      "| `MUX_TOOL_INPUT_KEEP_RANGES_COUNT`          | `keep_ranges.length`          | number | Number of elements in keep_ranges (Line ranges to keep) |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>task (5)</summary>",
      "",
      "| Env var                            | JSON path           | Type    | Description |",
      "| ---------------------------------- | ------------------- | ------- | ----------- |",
      "| `MUX_TOOL_INPUT_AGENT_ID`          | `agentId`           | string  | \u2014           |",
      "| `MUX_TOOL_INPUT_PROMPT`            | `prompt`            | string  | \u2014           |",
      "| `MUX_TOOL_INPUT_RUN_IN_BACKGROUND` | `run_in_background` | boolean | \u2014           |",
      "| `MUX_TOOL_INPUT_SUBAGENT_TYPE`     | `subagent_type`     | string  | \u2014           |",
      "| `MUX_TOOL_INPUT_TITLE`             | `title`             | string  | \u2014           |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>task_apply_git_patch (4)</summary>",
      "",
      "| Env var                    | JSON path   | Type    | Description                                                                                                                    |",
      "| -------------------------- | ----------- | ------- | ------------------------------------------------------------------------------------------------------------------------------ |",
      "| `MUX_TOOL_INPUT_DRY_RUN`   | `dry_run`   | boolean | When true, attempt to apply the patch in a temporary git worktree and then discard it (does not modify the current workspace). |",
      "| `MUX_TOOL_INPUT_FORCE`     | `force`     | boolean | When true, allow apply even if the patch was previously applied (and skip clean-tree checks).                                  |",
      "| `MUX_TOOL_INPUT_TASK_ID`   | `task_id`   | string  | Child task ID whose patch artifact should be applied                                                                           |",
      "| `MUX_TOOL_INPUT_THREE_WAY` | `three_way` | boolean | When true, run git am with --3way                                                                                              |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>task_await (5)</summary>",
      "",
      "| Env var                           | JSON path           | Type    | Description                                                                                                                                                                                                                                                                                                  |",
      "| --------------------------------- | ------------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |",
      "| `MUX_TOOL_INPUT_FILTER`           | `filter`            | string  | Optional regex to filter bash task output lines. By default, only matching lines are returned. When filter_exclude is true, matching lines are excluded instead. Non-matching lines are discarded and cannot be retrieved later.                                                                             |",
      "| `MUX_TOOL_INPUT_FILTER_EXCLUDE`   | `filter_exclude`    | boolean | When true, lines matching 'filter' are excluded instead of kept. Requires 'filter' to be set.                                                                                                                                                                                                                |",
      "| `MUX_TOOL_INPUT_TASK_IDS_<INDEX>` | `task_ids[<INDEX>]` | string  | List of task IDs to await. When omitted, waits for all active descendant tasks of the current workspace.                                                                                                                                                                                                     |",
      "| `MUX_TOOL_INPUT_TASK_IDS_COUNT`   | `task_ids.length`   | number  | Number of elements in task_ids (List of task IDs to await. When omitted, waits for all active descendant tasks of the current workspace.)                                                                                                                                                                    |",
      "| `MUX_TOOL_INPUT_TIMEOUT_SECS`     | `timeout_secs`      | number  | Maximum time to wait in seconds for each task. For bash tasks, this waits for NEW output (or process exit). If exceeded, the result returns status=queued\\|running\\|awaiting_report (task is still active). Defaults to 600 seconds (10 minutes) if not specified. Set to 0 for a non-blocking status check. |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>task_list (2)</summary>",
      "",
      "| Env var                           | JSON path           | Type   | Description                                                                                                            |",
      "| --------------------------------- | ------------------- | ------ | ---------------------------------------------------------------------------------------------------------------------- |",
      "| `MUX_TOOL_INPUT_STATUSES_<INDEX>` | `statuses[<INDEX>]` | enum   | Task statuses to include. Defaults to active tasks: queued, running, awaiting_report.                                  |",
      "| `MUX_TOOL_INPUT_STATUSES_COUNT`   | `statuses.length`   | number | Number of elements in statuses (Task statuses to include. Defaults to active tasks: queued, running, awaiting_report.) |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>task_terminate (2)</summary>",
      "",
      "| Env var                           | JSON path           | Type   | Description                                                                                                                        |",
      "| --------------------------------- | ------------------- | ------ | ---------------------------------------------------------------------------------------------------------------------------------- |",
      "| `MUX_TOOL_INPUT_TASK_IDS_<INDEX>` | `task_ids[<INDEX>]` | string | List of task IDs to terminate. Each must be a descendant sub-agent task of the current workspace.                                  |",
      "| `MUX_TOOL_INPUT_TASK_IDS_COUNT`   | `task_ids.length`   | number | Number of elements in task_ids (List of task IDs to terminate. Each must be a descendant sub-agent task of the current workspace.) |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>todo_write (3)</summary>",
      "",
      "| Env var                                | JSON path                | Type   | Description                                                                                                                  |",
      "| -------------------------------------- | ------------------------ | ------ | ---------------------------------------------------------------------------------------------------------------------------- |",
      "| `MUX_TOOL_INPUT_TODOS_<INDEX>_CONTENT` | `todos[<INDEX>].content` | string | Task description with tense matching status: past for completed, present progressive for in_progress, imperative for pending |",
      "| `MUX_TOOL_INPUT_TODOS_<INDEX>_STATUS`  | `todos[<INDEX>].status`  | enum   | Task status                                                                                                                  |",
      "| `MUX_TOOL_INPUT_TODOS_COUNT`           | `todos.length`           | number | Number of elements in todos                                                                                                  |",
      "",
      "</details>",
      "",
      "<details>",
      "<summary>web_fetch (1)</summary>",
      "",
      "| Env var              | JSON path | Type   | Description                      |",
      "| -------------------- | --------- | ------ | -------------------------------- |",
      "| `MUX_TOOL_INPUT_URL` | `url`     | string | The URL to fetch (http or https) |",
      "",
      "</details>",
      "",
      "{/* END TOOL_HOOK_ENV_VARS */}",
      "",
      "</Accordion>",
      "",
      "---",
      "",
      "## More examples",
      "",
      '<Accordion title="Format files after edits">',
      "",
      "```bash",
      "#!/usr/bin/env bash",
      "# .mux/tool_post",
      "",
      'if [[ "$MUX_TOOL" == file_edit_* ]]; then',
      '  file="$MUX_TOOL_INPUT_FILE_PATH"',
      '  prettier --write --log-level silent "$file" 2>/dev/null || true',
      "fi",
      "```",
      "",
      "</Accordion>",
      "",
      '<Accordion title="Log tool execution times">',
      "",
      "```bash",
      "#!/usr/bin/env bash",
      "# .mux/tool_post",
      "",
      "# Tool results are available via MUX_TOOL_RESULT_* if needed.",
      `echo "$(date '+%H:%M:%S') $MUX_TOOL completed" >> /tmp/mux-tools.log`,
      "```",
      "",
      "</Accordion>",
      "",
      '<Accordion title="Python hook">',
      "",
      "```python",
      "#!/usr/bin/env python3",
      "# .mux/tool_pre",
      "",
      "import os, sys",
      "",
      "tool = os.environ.get('MUX_TOOL', '')",
      "script = os.environ.get('MUX_TOOL_INPUT_SCRIPT', '')",
      "",
      "if tool == 'bash':",
      "    if 'rm -rf /' in script:",
      '        print("\u274C Blocked dangerous command", file=sys.stderr)',
      "        sys.exit(1)",
      "",
      "sys.exit(0)  # Allow",
      "```",
      "",
      "</Accordion>",
      ""
    ].join("\n"),
    "references/docs/index.mdx": [
      "---",
      "title: Introduction",
      "---",
      "",
      "**Mux** makes it easy to run parallel coding agents, each with its own isolated workspace, right from your browser or desktop. Mux is open source and LLM provider-agnostic.",
      "",
      "![Mux product screenshot](/img/product-hero.webp)",
      "",
      "## Getting Started",
      "",
      "<Columns cols={2}>",
      '  <Card title="Install Mux" icon="download" href="/install">',
      "    Download and install Mux for your operating system.",
      "  </Card>",
      '  <Card title="Mux Gateway credits" icon="key" href="/getting-started/mux-gateway">',
      "    Log in to Mux Gateway to get evaluation credits (if eligible).",
      "  </Card>",
      "</Columns>",
      "",
      "## What is Mux?",
      "",
      "Mux helps you work with multiple coding agents more effectively via:",
      "",
      "- Isolated workspaces with central view on git status updates",
      "- Multi-model (`sonnet-4-*`, `grok-*`, `gpt-5-*`, `opus-4-*`) support",
      "- Supporting UI and keybinds for efficiently managing a suite of agents",
      "- Rich markdown outputs (mermaid diagrams, LaTeX, etc.)",
      "",
      "## Quick Links",
      "",
      "- [Install](/install) - Download and installation instructions",
      "- [Why Parallelize?](/getting-started/why-parallelize) - Why parallelize?",
      "- [Keyboard Shortcuts](/config/keybinds) - Complete keyboard reference",
      "- [AGENTS](/AGENTS) - Developer guide for AI assistants",
      "",
      "## License",
      "",
      "Mux is licensed under the [GNU Affero General Public License v3.0 (AGPL-3.0)](https://github.com/coder/mux/blob/main/LICENSE).",
      "",
      "Copyright (C) 2026 Coder Technologies, Inc.",
      ""
    ].join("\n"),
    "references/docs/install.mdx": [
      "---",
      "title: Install",
      "description: Download and install Mux for macOS, Linux, and Windows",
      "---",
      "",
      "## Downloads",
      "",
      "### Release Builds",
      "",
      '<Card title="Download Mux" icon="download" href="https://github.com/coder/mux/releases">',
      "  Download pre-built binaries from the releases page.",
      "</Card>",
      "",
      "- **macOS**: Signed and notarized DMG (separate builds for Intel/Apple Silicon)",
      "- **Linux**: AppImage",
      "- **Windows** _(alpha)_: Installer exe",
      "",
      "### Development Builds",
      "",
      "Download pre-built binaries of `main` from [GitHub Actions](https://github.com/coder/mux/actions/workflows/pr.yml?query=event:push+branch:main):",
      "",
      "- **macOS**: Signed and notarized DMG",
      "  - `build-macos-x64` (Intel Macs)",
      "  - `build-macos-arm64` (Apple Silicon)",
      "- **Linux**: `build-linux` AppImage (portable, works on most distros)",
      "- **Windows**: `build-windows` installer exe",
      "",
      "To download:",
      "",
      "1. Go to the [PR workflow (main branch)](https://github.com/coder/mux/actions/workflows/pr.yml?query=event:push+branch:main)",
      "2. Click on the latest successful run",
      '3. Scroll down to "Artifacts" section',
      "4. Download the appropriate artifact for your platform",
      "",
      "### Installation",
      "",
      "#### macOS",
      "",
      "1. Download the DMG file for your Mac:",
      "   - Intel Mac: `macos-dmg-x64`",
      "   - Apple Silicon: `macos-dmg-arm64`",
      "2. Open the DMG file",
      "3. Drag Mux to Applications folder",
      "4. Open the app normally",
      "",
      "The app is code-signed and notarized by Apple, so it will open without security warnings.",
      "",
      "#### Linux",
      "",
      "1. Download the AppImage file",
      "2. Make it executable: `chmod +x Mux-*.AppImage`",
      "3. Run it: `./Mux-*.AppImage`",
      "",
      "#### Windows",
      "",
      "_(alpha)_",
      "",
      "Prerequisites:",
      "",
      "- Install **Git for Windows** (includes Git Bash). **WSL is not supported.**",
      "- Restart Mux after installing Git for Windows.",
      "",
      "1. Download the installer exe from [releases](https://github.com/coder/mux/releases) (e.g., `mux-x.x.x-x64.exe`)",
      "2. Run the installer",
      "3. Follow the installation prompts",
      "4. Launch Mux from the Start menu or desktop shortcut",
      "",
      "<Warning>",
      "  Windows support is currently in alpha. Please [report any",
      "  issues](https://github.com/coder/mux/issues) you encounter.",
      "</Warning>",
      "",
      "### Testing Pre-Release Builds",
      "",
      "<Warning>",
      "  Only builds from the `main` branch are signed and notarized. If you're testing a build from a pull",
      "  request or other branch, you'll need to bypass macOS Gatekeeper:",
      "</Warning>",
      "",
      "1. After installing, open Terminal",
      "2. Run: `xattr -cr /Applications/Mux.app`",
      "3. Run: `codesign --force --deep --sign - /Applications/Mux.app`",
      "4. Now you can open the app normally",
      "",
      "## CLI via npm",
      "",
      "The Mux CLI can also be run directly via `npx` without installing the desktop app:",
      "",
      "```bash",
      "# Run agent tasks",
      'npx mux run "Fix the failing tests"',
      "",
      "# Start the server for remote/mobile access",
      "npx mux server --port 3000",
      "```",
      "",
      "Or install globally:",
      "",
      "```bash",
      "npm install -g mux",
      "```",
      "",
      "This is ideal for CI/CD pipelines and scripted automation. See the [CLI documentation](/reference/cli) for all available commands and options.",
      ""
    ].join("\n"),
    "references/docs/integrations/vscode-extension.mdx": [
      "---",
      "title: VS Code Extension",
      "description: Pair Mux workspaces with VS Code and Cursor editors",
      "---",
      "",
      "The Mux VS Code extension allows you to easily pair with Mux during development. Our extension works with VS Code and Cursor.",
      "",
      `It's especially useful for completing the "last mile" of a task or establishing the initial architecture.`,
      "",
      "## Overview",
      "",
      "The extension has a small initial surface area: a command to open a workspace and a Secondary Sidebar Chat view (Preview).",
      "",
      "![Mux VS Code extension screenshot](../img/vscode-ext.webp)",
      "",
      "1. Press `Cmd+Shift+P` (or `Ctrl+Shift+P` on Windows/Linux)",
      '2. Type "mux: Open Workspace"',
      "   - Optional: Set a custom keybinding in the Command Palette settings",
      "3. Select your workspace",
      "4. It opens in a new editor window",
      "",
      "The extension works with both local and SSH workspaces.",
      "",
      "## Secondary Sidebar Chat (Preview)",
      "",
      "<Warning>",
      "  The Secondary Sidebar Chat view is a preview feature and is under active development. Expect bugs",
      "  and breaking changes.",
      "</Warning>",
      "",
      "You can find it in the **Secondary Sidebar** under the `mux` container: **Chat (Preview)**.",
      "",
      "1. Open **Chat (Preview)**",
      "2. Select a Mux workspace from the picker",
      "3. Chat normally; use the pencil icon to open the workspace in a new window",
      "",
      "To send messages, Mux must be connected in server/API mode.",
      "",
      "If you hit issues, please report them on the [Mux GitHub issues page](https://github.com/coder/mux/issues).",
      "",
      "## Installation",
      "",
      "### Download",
      "",
      "Download the latest `.vsix` file from the [GitHub releases page](https://github.com/coder/mux/releases).",
      "",
      "### Install",
      "",
      "**Command line:**",
      "",
      "```bash",
      "# For VS Code",
      "code --install-extension mux-*.vsix",
      "",
      "# For Cursor",
      "cursor --install-extension mux-*.vsix",
      "```",
      "",
      "**From editor UI:**",
      "",
      "1. Open Command Palette (`Cmd+Shift+P`)",
      '2. Type "Extensions: Install from VSIX..."',
      "3. Select the downloaded file",
      "",
      "### Workspace Types",
      "",
      "The extension displays workspaces differently based on their type:",
      "",
      "- **Local**: `\u{1F4C1} [project-name] workspace-name`",
      "- **SSH**: `\u{1F517} [project-name] workspace-name (ssh: hostname)`",
      "",
      "## SSH Workspaces",
      "",
      "### Requirements",
      "",
      "For SSH workspaces to work, you need:",
      "",
      "1. **Remote-SSH Extension** installed",
      "   - VS Code: `ms-vscode-remote.remote-ssh`",
      "   - Cursor: `anysphere.remote-ssh`",
      "   - The extension automatically detects which one you have",
      "2. **SSH host configured** in `~/.ssh/config` or in the Remote-SSH extension",
      "",
      "### Setup SSH Host",
      "",
      "If you haven't configured the SSH host yet:",
      "",
      "1. Open `~/.ssh/config` and add:",
      "",
      "   ```bash",
      "   Host myserver",
      "     HostName 192.168.1.100",
      "     User username",
      "     IdentityFile ~/.ssh/id_rsa",
      "   ```",
      "",
      "2. Or use VS Code's Remote-SSH command:",
      '   - `Cmd+Shift+P` \u2192 "Remote-SSH: Add New SSH Host..."',
      "",
      "## Development",
      "",
      "For development instructions, see `vscode/README.md` and `vscode/DEVELOPMENT.md` in the",
      "repository.",
      "",
      "## Related",
      "",
      "- [Workspaces Overview](/workspaces/)",
      "- [SSH Runtime](/runtime/ssh)",
      "- [VS Code Remote-SSH Documentation](https://code.visualstudio.com/docs/remote/ssh)",
      ""
    ].join("\n"),
    "references/docs/reference/benchmarking.mdx": [
      "---",
      "title: Terminal Benchmarking",
      "description: Run Terminal-Bench benchmarks with the Mux adapter",
      "---",
      "",
      "Mux ships with a headless adapter for [Terminal-Bench](https://www.tbench.ai/). The adapter runs the Electron backend without opening a window and exercises it through the same IPC paths we use in integration tests. This page documents how to launch benchmarks from the repository tree.",
      "",
      "## Prerequisites",
      "",
      "- Docker must be installed and running. Terminal-Bench executes each task inside a dedicated Docker container.",
      "- `uv` is available in the nix `devShell` (provided via `flake.nix`), or install it manually from [docs.astral.sh/uv](https://docs.astral.sh/uv/).",
      "- Standard provider API keys (e.g. `ANTHROPIC_API_KEY`, `OPENAI_API_KEY`) should be exported so Mux can stream responses.",
      "",
      "Optional environment overrides:",
      "",
      "| Variable              | Purpose                                                 | Default                                |",
      "| --------------------- | ------------------------------------------------------- | -------------------------------------- |",
      "| `MUX_AGENT_REPO_ROOT` | Path copied into each task container                    | repo root inferred from the agent file |",
      "| `MUX_TRUNK`           | Branch checked out when preparing the project           | `main`                                 |",
      "| `MUX_WORKSPACE_ID`    | Workspace identifier used inside Mux                    | `mux-bench`                            |",
      "| `MUX_MODEL`           | Preferred model (supports `provider/model` syntax)      | `anthropic/claude-sonnet-4-5`          |",
      "| `MUX_THINKING_LEVEL`  | Reasoning level (`OFF`, `LOW`, `MED`, `HIGH`, `MAX`)    | `HIGH`                                 |",
      "| `MUX_MODE`            | Starting mode (`plan` or `exec`)                        | `exec`                                 |",
      "| `MUX_RUNTIME`         | Runtime type (`local`, `worktree`, or `ssh <host>`)     | `worktree`                             |",
      "| `MUX_TIMEOUT_MS`      | Optional stream timeout in milliseconds                 | no timeout                             |",
      "| `MUX_PROVIDERS_FILE`  | Host path to `providers.jsonc` copied into each sandbox | unset (use env vars only)              |",
      "| `MUX_CONFIG_ROOT`     | Location for Mux session data inside the container      | `/root/.mux`                           |",
      "| `MUX_APP_ROOT`        | Path where the Mux sources are staged                   | `/opt/mux-app`                         |",
      "| `MUX_PROJECT_PATH`    | Explicit project directory inside the task container    | auto-detected from common paths        |",
      "",
      "## Running Terminal-Bench",
      "",
      "All commands below should be run from the repository root.",
      "",
      "### Quick smoke test (single task)",
      "",
      "```bash",
      "uvx terminal-bench run \\",
      "  --dataset terminal-bench-core==0.1.1 \\",
      "  --agent-import-path benchmarks.terminal_bench.mux_agent:MuxAgent \\",
      "  --n-tasks 1",
      "```",
      "",
      "This downloads the Terminal-Bench runner, copies the Mux sources into the container, and validates the adapter against the first task only. Use this before attempting a full sweep.",
      "",
      "### Full dataset",
      "",
      "```bash",
      "uvx terminal-bench run \\",
      "  --dataset terminal-bench-core==0.1.1 \\",
      "  --agent-import-path benchmarks.terminal_bench.mux_agent:MuxAgent",
      "```",
      "",
      "Results (pass/fail, token usage, wall-clock) are printed at the end of the run. Terminal-Bench also writes per-task logs under the current working directory; review them when diagnosing failures.",
      "",
      "You can also use `make`:",
      "",
      "```bash",
      "TB_CONCURRENCY=6 TB_LIVESTREAM=1 \\",
      'make benchmark-terminal TB_ARGS="--n-tasks 3 --model anthropic/claude-sonnet-4-20250514 --agent-kwarg mode=plan --agent-kwarg thinking_level=medium"',
      "```",
      "",
      "`TB_DATASET` defaults to `terminal-bench-core==0.1.1`, but can be overridden (e.g. `make benchmark-terminal TB_DATASET=terminal-bench-core==head`).",
      "Use `--agent-kwarg mode=plan` to exercise the plan/execute workflow\u2014the CLI will gather a plan first, then automatically approve it and switch to execution. Leaving the flag off (or setting `mode=exec`) skips the planning phase.",
      "Use `TB_CONCURRENCY=<n>` to control `--n-concurrent` (number of concurrently running tasks) and `TB_LIVESTREAM=1` to stream log output live instead of waiting for the run to finish. These map to Terminal-Bench\u2019s `--n-concurrent` and `--livestream` flags.",
      "",
      "## How the Adapter Works",
      "",
      "The adapter lives in `benchmarks/terminal_bench/mux_agent.py`. For each task it:",
      "",
      "1. Copies the Mux repository (package manifests + `src/`) into `/tmp/mux-app` inside the container.",
      "2. Ensures Bun exists, then runs `bun install --frozen-lockfile`.",
      "3. Launches `mux run` (`src/cli/run.ts`) to prepare workspace metadata and stream the instruction, storing state under `MUX_CONFIG_ROOT` (default `/root/.mux`).",
      "",
      "`MUX_MODEL` accepts either the Mux colon form (`anthropic:claude-sonnet-4-5`) or the Terminal-Bench slash form (`anthropic/claude-sonnet-4-5`); the adapter normalises whichever you provide.",
      "",
      "## Troubleshooting",
      "",
      "- **`command not found: bun`** \u2013 ensure the container can reach Bun\u2019s install script, or pre-install Bun in your base image. The adapter aborts if the install step fails.",
      "- **Workspace creation errors** \u2013 set `MUX_PROJECT_PATH` to the project directory inside the task container if auto-discovery misses it.",
      "- **Streaming timeouts** \u2013 pass `--n-tasks 1` while iterating on fixes, or set `MUX_TIMEOUT_MS=180000` to reinstate a timeout if needed.",
      ""
    ].join("\n"),
    "references/docs/reference/cli.mdx": [
      "---",
      "title: CLI",
      "sidebarTitle: CLI",
      "description: Run one-off agent tasks from the command line with `mux run`",
      "---",
      "",
      "<Note>",
      "  The CLI is designed for **automation and scripting** (CI/CD pipelines, batch processing,",
      "  programmatic control). For interactive terminal experiences, consider tools like [Claude",
      "  Code](https://docs.anthropic.com/en/docs/agents-and-tools/claude-code/overview) or similar TUIs.",
      "</Note>",
      "",
      "Mux provides a CLI for running one-off agent tasks without the desktop app. Unlike the interactive desktop experience, `mux run` executes a single request to completion and exits.",
      "",
      '<Card title="GitHub Actions Guide" icon="github" href="/guides/github-actions">',
      "  Learn how to use `mux run` in CI/CD pipelines",
      "</Card>",
      "",
      "## Installation",
      "",
      "The CLI is available via npm and can be run directly with `npx`:",
      "",
      "```bash",
      "# Run without installing",
      'npx mux run "Fix the failing tests"',
      "",
      "# Or install globally",
      "npm install -g mux",
      'mux run "Fix the failing tests"',
      "```",
      "",
      "Using `npx mux` is especially convenient for CI/CD pipelines where you don't want to manage a global installation.",
      "",
      "## `mux run`",
      "",
      "Execute a one-off agent task:",
      "",
      "```bash",
      "# Basic usage - run in current directory",
      'npx mux run "Fix the failing tests"',
      "",
      "# Specify a directory",
      'mux run --dir /path/to/project "Add authentication"',
      "",
      "# Use SSH runtime",
      'mux run --runtime "ssh user@myserver" "Deploy changes"',
      "",
      "# Pipe instructions via stdin",
      'echo "Add logging to all API endpoints" | mux run',
      "",
      "# JSON output for scripts",
      `mux run --json "List all TypeScript files" | jq '.type'`,
      "```",
      "",
      "### Options",
      "",
      "| Option                | Short | Description                                                                                                                   | Default           |",
      "| --------------------- | ----- | ----------------------------------------------------------------------------------------------------------------------------- | ----------------- |",
      "| `--dir <path>`        | `-d`  | Project directory                                                                                                             | Current directory |",
      "| `--model <model>`     | `-m`  | Model to use (e.g., `anthropic:claude-sonnet-4-5`)                                                                            | Default model     |",
      "| `--runtime <runtime>` | `-r`  | Runtime: `local`, `worktree`, `ssh <host>`, or `docker <image>`                                                               | `local`           |",
      "| `--mode <mode>`       |       | Agent mode: `plan` or `exec`                                                                                                  | `exec`            |",
      "| `--thinking <level>`  | `-t`  | Thinking level: `OFF`, `LOW`, `MED`, `HIGH`, `MAX`, or `0`\u2013`9` (model-relative, see [Models](/config/models#thinking-levels)) | `MED`             |",
      "| `--budget <usd>`      | `-b`  | Stop when session cost exceeds budget (USD)                                                                                   | No limit          |",
      "| `--experiment <id>`   | `-e`  | Enable experiment (repeatable)                                                                                                | None              |",
      "| `--json`              |       | Output NDJSON for programmatic use                                                                                            | Off               |",
      "| `--quiet`             | `-q`  | Only output final result                                                                                                      | Off               |",
      "",
      "### Runtimes",
      "",
      "- **`local`** (default): Runs directly in the specified directory. Best for one-off tasks.",
      "- **`worktree`**: Creates an isolated git worktree under `~/.mux/src`. Useful for parallel work.",
      '- **`ssh <host>`**: Runs on a remote machine via SSH. Example: `--runtime "ssh user@myserver.com"`',
      '- **`docker <image>`**: Runs in a Docker container. Example: `--runtime "docker node:20"`',
      "",
      "### Output Modes",
      "",
      "- **Default (TTY)**: Human-readable streaming with tool call formatting",
      "- **`--json`**: NDJSON streaming - each line is a JSON object with event data",
      "- **`--quiet`**: Suppresses streaming output, only shows final assistant response",
      "",
      "### Examples",
      "",
      "```bash",
      "# Quick fix in current directory",
      'mux run "Fix the TypeScript errors"',
      "",
      "# Use a specific model with extended thinking",
      'mux run -m anthropic:claude-sonnet-4-5 -t high "Optimize database queries"',
      "",
      "# Run on remote server",
      'mux run -r "ssh dev@staging.example.com" -d /app "Update dependencies"',
      "",
      "# Scripted usage with JSON output",
      'mux run --json "Generate API documentation" > output.jsonl',
      "",
      "# Limit spending to $2.00",
      'mux run --budget 2.00 "Refactor the authentication module"',
      "```",
      "",
      "## `mux server`",
      "",
      "Start the HTTP/WebSocket server for remote access (e.g., from mobile devices):",
      "",
      "```bash",
      "mux server --port 3000 --host 0.0.0.0",
      "```",
      "",
      "Options:",
      "",
      "- `--host <host>` - Host to bind to (default: `localhost`)",
      "- `--port <port>` - Port to bind to (default: `3000`)",
      "- `--auth-token <token>` - Optional bearer token for authentication",
      "- `--add-project <path>` - Add and open project at the specified path",
      "",
      "## `mux desktop`",
      "",
      "Launch the desktop app. This is automatically invoked when running the packaged app or via `electron .`:",
      "",
      "```bash",
      "mux desktop",
      "```",
      "",
      "Note: Requires Electron. When running `mux` with no arguments under Electron, the desktop app launches automatically.",
      "",
      "## `mux --version`",
      "",
      "Print the version and git commit:",
      "",
      "```bash",
      "mux --version",
      "# v0.8.4 (abc123)",
      "```",
      "",
      "## Debug Environment Variables",
      "",
      "These environment variables help diagnose issues with LLM requests and responses.",
      "",
      "| Variable                | Purpose                                                                                                                                                                 |",
      "| ----------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |",
      "| `MUX_DEBUG_LLM_REQUEST` | Set to `1` to log the complete LLM request (system prompt, messages, tools, provider options) as formatted JSON to the debug logs. Useful for diagnosing prompt issues. |",
      "",
      "Example usage:",
      "",
      "```bash",
      'MUX_DEBUG_LLM_REQUEST=1 mux run "Hello world"',
      "```",
      "",
      "The output includes:",
      "",
      "- `systemMessage`: The full system prompt sent to the model",
      "- `messages`: All conversation messages in the request",
      "- `tools`: Tool definitions with descriptions and input schemas",
      "- `providerOptions`: Provider-specific options (thinking level, etc.)",
      "- `mode`, `thinkingLevel`, `maxOutputTokens`, `toolPolicy`",
      ""
    ].join("\n"),
    "references/docs/reference/storybook.mdx": [
      "---",
      "title: Storybook",
      "description: Develop and test Mux UI states in isolation",
      "---",
      "",
      "Storybook renders Mux's **renderer UI** without running the full Electron app.",
      "",
      "## Starting Storybook",
      "",
      "```bash",
      "make storybook",
      "# or",
      "bun run storybook",
      "```",
      "",
      "This will start the Storybook development server at `http://localhost:6006`.",
      "",
      "## Building Static Storybook",
      "",
      "To build a static version of Storybook that can be deployed:",
      "",
      "```bash",
      "make storybook-build",
      "# or",
      "bun run storybook:build",
      "```",
      "",
      "The output will be in `storybook-static/`.",
      "",
      "## Writing Stories (full app only)",
      "",
      "Mux intentionally uses **full-app** stories (no isolated component stories).",
      "",
      "Stories live in `src/browser/stories/` and must be named `App.*.stories.tsx`.",
      "",
      "Storybook is configured to load `src/browser/stories/**/*.stories.@(ts|tsx)` (see `.storybook/main.ts`).",
      "",
      "### Basic App story structure",
      "",
      "```tsx",
      'import { appMeta, AppWithMocks, type AppStory } from "./meta.js";',
      'import { createMockORPCClient } from "@/browser/stories/mocks/orpc";',
      'import { createWorkspace, groupWorkspacesByProject } from "./mockFactory";',
      "",
      "export default {",
      "  ...appMeta,",
      '  title: "App/Sidebar",',
      "};",
      "",
      "export const SingleProject: AppStory = {",
      "  render: () => (",
      "    <AppWithMocks",
      "      setup={() => {",
      '        const workspaces = [createWorkspace({ id: "ws-1", name: "main", projectName: "my-app" })];',
      "",
      "        return createMockORPCClient({",
      "          workspaces,",
      "          projects: groupWorkspacesByProject(workspaces),",
      "        });",
      "      }}",
      "    />",
      "  ),",
      "};",
      "```",
      "",
      "### Helpers & fixtures",
      "",
      "- `src/browser/stories/meta.tsx` \u2013 shared `appMeta` + `AppWithMocks` wrapper",
      "- `src/browser/stories/mocks/orpc.ts` \u2013 `createMockORPCClient()` for building an `APIClient`",
      "- `src/browser/stories/mockFactory.ts` \u2013 deterministic fixtures (workspaces, messages, timestamps)",
      "- `src/browser/stories/storyHelpers.ts` / `storyPlayHelpers.ts` \u2013 localStorage + play-function helpers",
      "",
      "## Global styles & determinism",
      "",
      "- Global CSS is loaded from `src/browser/styles/globals.css` in `.storybook/preview.tsx`.",
      "- `.storybook/preview.tsx` stubs `Date.now()` to a stable value for deterministic snapshots; prefer using `NOW` / `STABLE_TIMESTAMP` from `mockFactory.ts` when constructing fixtures.",
      "",
      "## Examples",
      "",
      "See the existing stories for patterns:",
      "",
      "- `src/browser/stories/App.sidebar.stories.tsx`",
      "- `src/browser/stories/App.chat.stories.tsx`",
      "- `src/browser/stories/App.settings.stories.tsx`",
      "",
      "## Configuration",
      "",
      "- `.storybook/main.ts` - Main Storybook configuration (stories glob, addons, Vite config)",
      "- `.storybook/preview.tsx` - Global decorators and snapshot stabilization helpers",
      "- `tsconfig.json` - Includes `.storybook/**/*.ts(x)` for type checking",
      "",
      "## Tips",
      "",
      "- Keep story data deterministic (no `Math.random()` / real `Date.now()` in fixtures).",
      "- Use `play` functions (`@storybook/test`) to navigate the UI into the desired state.",
      "- If async rendering changes element heights (Markdown, Mermaid, tool expansion), wait for scroll stabilization (double `requestAnimationFrame`) before snapshotting.",
      ""
    ].join("\n"),
    "references/docs/reference/telemetry.mdx": [
      "---",
      "title: Telemetry",
      "description: What Mux collects, what it doesn\u2019t, and how to disable it",
      "---",
      "",
      "Mux collects anonymous usage telemetry to help improve the product.",
      "",
      "## Privacy policy",
      "",
      "- **No personal information**: Mux does not collect usernames, project names, file paths, or code content.",
      "- **Random IDs only**: Only randomly generated workspace IDs are sent.",
      "- **No hashing**: Hashing is vulnerable to rainbow table attacks.",
      "- **Transparent payload**: See exactly what is sent in [`src/common/telemetry/payload.ts`](https://github.com/coder/mux/blob/main/src/common/telemetry/payload.ts).",
      "",
      "## What Mux tracks",
      "",
      "All telemetry events include basic system information:",
      "",
      "- Application version",
      "- Operating system platform (`darwin`, `win32`, `linux`)",
      "- Electron version",
      "",
      "### Specific events",
      "",
      "- **App started**: When the app launches (includes a first-launch flag)",
      "- **Workspace creation**: When a new workspace is created (workspace ID only)",
      "- **Workspace switching**: When you switch between workspaces (workspace IDs only)",
      "- **Message sending**: When messages are sent (model, mode, message length rounded to base-2)",
      "- **Errors**: Error types and context (no sensitive data)",
      "",
      "### What Mux does _not_ track",
      "",
      "- Your messages or code",
      "- Project names or file paths",
      "- API keys or credentials",
      "- Usernames or email addresses",
      "- Any personally identifiable information",
      "",
      "## Disabling telemetry",
      "",
      "To disable telemetry, set `MUX_DISABLE_TELEMETRY` before starting the app:",
      "",
      "```bash",
      "MUX_DISABLE_TELEMETRY=1 mux",
      "```",
      "",
      "This disables telemetry collection at the backend level.",
      "",
      "<Note>",
      "  Disabling telemetry also hides the **Share** button on assistant messages. Link sharing uses",
      "  [mux.md](https://mux.md), a separate Mux service, and is gated on telemetry enablement to respect",
      "  your privacy preferences.",
      "</Note>",
      "",
      "## Source code",
      "",
      "- **Payload definitions**: [`src/common/telemetry/payload.ts`](https://github.com/coder/mux/blob/main/src/common/telemetry/payload.ts)",
      "- **Backend service**: [`src/node/services/telemetryService.ts`](https://github.com/coder/mux/blob/main/src/node/services/telemetryService.ts)",
      "- **Frontend client**: [`src/common/telemetry/client.ts`](https://github.com/coder/mux/blob/main/src/common/telemetry/client.ts)",
      "- **Privacy utilities**: [`src/common/telemetry/utils.ts`](https://github.com/coder/mux/blob/main/src/common/telemetry/utils.ts)",
      ""
    ].join("\n"),
    "references/docs/runtime/coder.mdx": [
      "---",
      "title: Coder Runtime",
      "description: Run agents on Coder workspaces",
      "---",
      "",
      "Mux can use [Coder Workspaces](https://coder.com/docs) as SSH hosts. When enabled, Mux talks to the Coder CLI on your local machine to list templates/presets/workspaces and connects over SSH. Connecting to an existing Coder workspace lets multiple Mux workspaces share the same Coder host, which avoids per-workspace provisioning overhead.",
      "",
      "## Requirements",
      "",
      "- Coder CLI **v2.25.0+** installed on the machine running Mux and logged in to your deployment",
      "- Access to a Coder template (for new workspaces) or an existing workspace",
      "- A workspace image with git and your toolchain",
      "",
      "## Create a new Coder workspace",
      "",
      "1. Choose **SSH** as the runtime and enable **Use Coder Workspace**.",
      "2. Select **New**.",
      "3. Pick a template and (if available) a preset.",
      "4. Mux creates a Coder workspace named `mux-<workspace-name>` (derived from your Mux workspace name), waits for startup scripts, then connects over SSH.",
      "",
      "If multiple organizations have templates with the same name, Mux shows the organization name so you can pick the right one.",
      "",
      "## Use an existing Coder workspace",
      "",
      "1. Choose **Existing**.",
      "2. Select a workspace from the list (status is shown).",
      "3. Mux will start the workspace if it is stopped, then connect to `<workspace-name>.coder`.",
      "",
      "## SSH setup",
      "",
      "Mux runs `coder config-ssh --yes` before connecting, which creates SSH aliases like `<workspace-name>.coder` in `~/.ssh/config`.",
      "",
      "## Notes",
      "",
      "- If the **Use Coder Workspace** checkbox is missing, verify that the Coder CLI is found on the PATH.",
      "- Each Mux workspace still lives in its own directory on the remote machine, even when sharing a single Coder workspace.",
      "- By default, archiving a **New** (mux-created) Coder-backed workspace will also stop the underlying Coder workspace, and unarchiving will attempt to start it again. This does **not** apply when using an **Existing** Coder workspace. To disable this behavior, set `stopCoderWorkspaceOnArchive` to `false` in `~/.mux/config.json`.",
      ""
    ].join("\n"),
    "references/docs/runtime/devcontainer.mdx": [
      "---",
      "title: Dev Container Runtime",
      "description: Run agents in containers defined by devcontainer.json",
      "---",
      "",
      "Dev Container runtime runs each workspace in a container built from your project's [devcontainer.json](https://containers.dev/implementors/json_reference/). If your project already uses dev containers for VS Code or other editors, Mux can use the same configuration.",
      "",
      "## Requirements",
      "",
      "- [Dev Container CLI](https://github.com/devcontainers/cli): `npm install -g @devcontainers/cli`",
      "- Docker daemon running",
      "- A `devcontainer.json` in the project",
      "",
      "## How it works",
      "",
      "1. Mux creates a git worktree on the host machine",
      "2. Runs `devcontainer up` to build/start the container",
      "3. Commands execute inside the container via `devcontainer exec`",
      "4. Deleting the workspace stops the container and removes the worktree",
      "",
      "## Configuration",
      "",
      "Select Dev Container in the workspace creation UI. If your project has multiple configs, choose one from the dropdown.",
      "",
      "Mux searches these locations:",
      "",
      "- `.devcontainer.json`",
      "- `.devcontainer/devcontainer.json`",
      "- `.devcontainer/*/devcontainer.json` (named configs)",
      "",
      "## Credential sharing",
      "",
      'Like the [Docker runtime](/runtime/docker), you can check "Share credentials" to enable git authentication inside the container:',
      "",
      "- **SSH agent forwarding** \u2014 Your SSH keys work without copying private keys",
      "- **Git config** \u2014 Host `~/.gitconfig` is copied into the container",
      "- **GitHub CLI** \u2014 If `GH_TOKEN` is set in [project secrets](/config/project-secrets), it's passed to the container",
      "",
      "## Filesystem layout",
      "",
      "Worktrees live on the host at `~/.mux/src/<project>/<workspace>`. The container mounts this directory (location inside the container depends on your devcontainer.json `workspaceFolder`).",
      "",
      "## Notes",
      "",
      "- The Dev Container runtime button only appears if Mux finds a `devcontainer.json` in the project.",
      ""
    ].join("\n"),
    "references/docs/runtime/docker.mdx": [
      "---",
      "title: Docker Runtime",
      "description: Run agents in isolated Docker containers",
      "---",
      "",
      "Docker runtime runs each workspace in a separate Docker container, providing full isolation.",
      "",
      "## Why use Docker runtime",
      "",
      "- **Full isolation**: Each workspace runs in its own container with no shared state",
      "- **Reproducible environments**: Pin exact images for consistent tooling",
      "- **Security**: Container sandboxing limits agent access to host system",
      "",
      "## How it works",
      "",
      "1. When you create a Docker workspace, Mux starts a container from your chosen image",
      "2. Your project code is synced to `/src` inside the container via git bundle",
      "3. Commands run inside the container with `docker exec`",
      "4. Deleting the workspace removes the container",
      "",
      "## Configuration",
      "",
      "Select Docker in the workspace creation UI and specify an image:",
      "",
      "- `node:20` - Node.js with git pre-installed",
      "- `python:3.12` - Python with git pre-installed",
      "- Custom images with your toolchain",
      "",
      "## Credential sharing",
      "",
      'Check "Share credentials" when creating a Docker workspace to enable git authentication:',
      "",
      "- **SSH agent forwarding** \u2014 Your SSH keys work inside the container without copying private keys",
      "- **Git config** \u2014 Host `~/.gitconfig` is copied into the container so git has your identity and settings",
      "- **GitHub CLI** \u2014 If `GH_TOKEN` is set in [project secrets](/config/project-secrets), Mux runs `gh auth setup-git` to configure HTTPS authentication (requires `gh` CLI in the container image)",
      ""
    ].join("\n"),
    "references/docs/runtime/index.mdx": [
      "---",
      "title: Runtimes",
      "description: Configure where and how Mux executes agent workspaces",
      "---",
      "",
      "Runtimes determine where and how Mux executes agent workspaces.",
      "",
      "| Runtime                                    | Isolation                                  | Best For                                    |",
      "| ------------------------------------------ | ------------------------------------------ | ------------------------------------------- |",
      "| **[Local](/runtime/local)**                | All workspaces share the project directory | Quick edits to your working copy            |",
      "| **[Worktree](/runtime/worktree)**          | Each workspace gets its own directory      | Running multiple agents in parallel         |",
      "| **[SSH](/runtime/ssh)**                    | Remote execution over SSH                  | Security, performance, heavy parallelism    |",
      "| **[Docker](/runtime/docker)**              | Isolated container per workspace           | Full isolation, reproducible environments   |",
      "| **[Dev Container](/runtime/devcontainer)** | Container from devcontainer.json           | Projects with existing devcontainer configs |",
      "",
      "## Choosing a Runtime",
      "",
      "Choose a runtime when creating a workspace.",
      "",
      "## Init Hooks",
      "",
      "[Init hooks](/hooks/init) and agent bash tool executions can detect the runtime type via the `MUX_RUNTIME` environment variable:",
      "",
      "- `local` \u2014 Local runtime",
      "- `worktree` \u2014 Worktree runtime",
      "- `ssh` \u2014 SSH runtime",
      "- `docker` \u2014 Docker runtime",
      "- `devcontainer` \u2014 Dev Container runtime",
      "",
      "This lets your init hook adapt behavior, e.g., skip worktree-specific setup when running in local mode.",
      ""
    ].join("\n"),
    "references/docs/runtime/local.mdx": [
      "---",
      "title: Local Runtime",
      "description: Run agents directly in your project directory",
      "---",
      "",
      "Local runtime runs the agent directly in your project directory\u2014the same directory you use for development. There's no worktree isolation; the agent works in your actual working copy.",
      "",
      "## When to Use",
      "",
      "- Quick one-off tasks in your current working copy",
      "- Reviewing agent work alongside your own uncommitted changes",
      "- Projects where worktrees don't work well (e.g., some monorepos)",
      "",
      "## Caveats",
      "",
      "<Warning>",
      "  **No isolation**: Multiple local workspaces for the same project see and modify the same files.",
      "  Running them simultaneously can cause conflicts. Mux shows a warning when another local workspace",
      "  is actively streaming.",
      "</Warning>",
      "",
      "<Warning>",
      "  **Affects your working copy**: Agent changes happen in your actual project directory.",
      "</Warning>",
      "",
      "## Filesystem",
      "",
      "The workspace path is your project directory itself. No additional directories are created.",
      ""
    ].join("\n"),
    "references/docs/runtime/ssh.mdx": [
      "---",
      "title: SSH Runtime",
      "description: Run agents on remote hosts over SSH for security and performance",
      "---",
      "",
      "Mux can run workspaces on a remote host over SSH. When configured, tool operations (file reads/edits, `bash`, etc.) execute on the remote machine.",
      "",
      "## Threat model",
      "",
      "Mux treats the remote host as potentially hostile. By default it does **not** forward your local keys or credentials.",
      "",
      "The only data synced to the remote machine is:",
      "",
      "- a git archive of the project",
      "- [Project Secrets](/config/project-secrets) (explicitly configured)",
      "",
      "## Why use SSH runtime",
      "",
      "- **Security**: Prompt injection risk is contained to the credentials/files on the remote machine.",
      "  - SSH remotes pair well with [Agentic Git Identity](/config/agentic-git-identity).",
      "- **Performance**: Run many agents in parallel without burning laptop CPU/battery.",
      "",
      "![ssh workspaces](../img/new-workspace-ssh.webp)",
      "",
      "## Host value",
      "",
      "The host field accepts anything you can pass to `ssh <host>`:",
      "",
      "- a hostname (for example `my-server.com`)",
      "- a username and hostname (for example `user@my-server.com`)",
      "- an alias from your `~/.ssh/config` (for example `my-server`)",
      "",
      "Mux delegates SSH configuration to your system `ssh` command, so advanced settings live in `~/.ssh/config`.",
      "",
      "Example entry:",
      "",
      "```text",
      "Host ovh-1",
      "  HostName 148.113.1.1",
      "  User root",
      "```",
      "",
      "## Authentication",
      "",
      "<Info>",
      "  Mux delegates to `ssh`. This is an abbreviated reference of common ways `ssh` authenticates.",
      "</Info>",
      "",
      "### Local default keys",
      "",
      "`ssh` checks these locations by default:",
      "",
      "```text",
      "~/.ssh/id_rsa",
      "~/.ssh/id_ecdsa",
      "~/.ssh/id_ecdsa_sk",
      "~/.ssh/id_ed25519",
      "~/.ssh/id_ed25519_sk",
      "```",
      "",
      "### SSH agent",
      "",
      "If you have an SSH agent running, add your key:",
      "",
      "```bash",
      "ssh-add ~/.ssh/my_key_ecdsa",
      "```",
      "",
      "### `~/.ssh/config`",
      "",
      "You can also set an explicit identity file:",
      "",
      "```text",
      "Host my-server",
      "  HostName 148.113.1.1",
      "  User root",
      "  IdentityFile ~/.ssh/id_rsa",
      "```",
      "",
      "## Coder Workspaces",
      "",
      "If you use [Coder](https://coder.com), see the [Coder runtime](/runtime/coder) page.",
      ""
    ].join("\n"),
    "references/docs/runtime/worktree.mdx": [
      "---",
      "title: Worktree Runtime",
      "description: Isolated git worktree environments for parallel agent work",
      "---",
      "",
      "Worktree runtime uses [git worktrees](https://git-scm.com/docs/git-worktree) on your local machine.",
      "",
      "Each workspace gets its own directory, but worktrees share the same `.git` directory as your main checkout.",
      "",
      "## How worktrees work",
      "",
      "A worktree is a separate directory on the same filesystem as the main repository.",
      "",
      "- It has its own working tree (files on disk) and checkout state.",
      "- It shares a `.git` with the main repository.",
      "",
      "Because `.git` is shared, **commits created in any worktree are immediately visible to your other worktrees (including your main checkout).**",
      "",
      "Worktrees aren\u2019t locked to a branch. The agent can switch branches, enter detached HEAD, or create new branches as needed. If you want to constrain branching behavior, do it via your [instruction files](/agents/instruction-files).",
      "",
      "## Filesystem layout",
      "",
      "Worktree workspaces are stored in `~/.mux/src/<project-name>/<workspace-name>`.",
      "",
      "Example layout:",
      "",
      "```text",
      "~/.mux/src/",
      "  mux-main/",
      "    improved-auth-ux/",
      "    fix-ci-flakes/",
      "```",
      ""
    ].join("\n"),
    "references/docs/workspaces/compaction/automatic.mdx": [
      "---",
      "title: Automatic Compaction",
      "description: Let Mux automatically compact your conversations based on usage or idle time",
      "---",
      "",
      "Mux can run `/compact` for you to keep context size manageable. There are two types of automatic compaction:",
      "",
      "- **Usage-based**: Compacts when your conversation reaches a configurable percentage of the model's context window",
      "- **Idle-based**: Optionally compacts inactive workspaces after a period of time",
      "",
      "## Usage-based auto-compaction",
      "",
      "When enabled, Mux monitors your context usage and:",
      "",
      '1. Shows a subtle warning as you approach the threshold (e.g., "Auto-Compact in 12% usage")',
      "2. When you send your next message **at or above the threshold**, Mux runs compaction first, then automatically sends your message as a follow-up",
      "",
      "### Configure the threshold",
      "",
      "- Open the **Costs** sidebar tab and find **Context Usage**",
      "- Drag the blue marker to set the percentage",
      "- The setting is **saved per model** (and applies to any workspace using that model)",
      "- Default is **70%**",
      "- Set it to **100%** to disable usage-based auto-compaction",
      "",
      "Mux caps the enabled threshold at **90%** to leave a safety buffer before hard context limits.",
      "",
      "### Force-compaction during streaming",
      "",
      "If a single response pushes context usage above your threshold while streaming, Mux may interrupt and compact automatically once you exceed the threshold by an additional buffer (currently **+5%**). After compaction, Mux resumes the conversation automatically.",
      "",
      "This safety mechanism prevents hitting hard context limits mid-stream.",
      "",
      "---",
      "",
      "## Idle-based auto-compaction",
      "",
      "Idle-based auto-compaction is **off by default**.",
      "",
      "When enabled for a project, Mux periodically checks for workspaces that:",
      "",
      "- Have been inactive for the configured number of hours",
      "- Are not currently streaming",
      "- Are not already compacted",
      "",
      "Eligible workspaces are compacted automatically and marked with the idle-compacted badge (**\u{1F4A4}\u{1F4E6}**).",
      "",
      "### Configure idle compaction",
      "",
      "You can configure idle compaction via the UI or a slash command:",
      "",
      "**Via UI:**",
      "",
      "- Click the context usage indicator in the chat input toolbar",
      "- Enable idle-based auto-compact and set the hours",
      "",
      "**Via command:**",
      "",
      "```",
      "/idle <hours>",
      "/idle off",
      "```",
      "",
      "Examples:",
      "",
      "```",
      "/idle 24",
      "```",
      "",
      "Compact workspaces after 24 hours of inactivity.",
      "",
      "```",
      "/idle off",
      "```",
      "",
      "Disable idle compaction for this project.",
      "",
      "### Notes",
      "",
      "- The setting is **per project** (applies to all workspaces in the project)",
      "- Mux checks roughly **once per hour**, so compaction may not trigger immediately when the timer expires",
      "",
      "---",
      "",
      "## General notes",
      "",
      "- Auto-compaction uses API tokens (same cost model as `/compact`)",
      "- Auto-compaction requires known model context limits; if Mux can't determine a model's context window, usage-based auto-compaction won't run",
      "- Both types of auto-compaction use the same summarization logic as manual `/compact`",
      ""
    ].join("\n"),
    "references/docs/workspaces/compaction/customization.mdx": [
      "---",
      "title: Customization",
      "description: Customize the compaction system prompt",
      "---",
      "",
      "You can customize how Mux summarizes conversations during compaction by overriding the `compact` agent.",
      "",
      "## Override the `compact` agent",
      "",
      "Create `.mux/agents/compact.md` in your project (or `~/.mux/agents/compact.md` for global):",
      "",
      "```md",
      "---",
      "name: Compact",
      "base: compact",
      "---",
      "",
      "When summarizing:",
      "",
      "- Preserve exact file paths and command output",
      "- Prefer bullet lists over long prose",
      "```",
      "",
      "By default, your prompt is **appended** to the built-in `compact` agent.",
      "",
      "### Replace instead of append",
      "",
      "```md",
      "---",
      "name: Compact",
      "base: compact",
      "prompt:",
      "  append: false",
      "---",
      "",
      "Summarize in 5 bullets max. No preamble.",
      "```",
      "",
      "## Defaults (synced from source)",
      "",
      '<Accordion title="Built-in compact agent system prompt">',
      "",
      "{/* BEGIN COMPACT_AGENT_SYSTEM_PROMPT */}",
      "",
      "```text",
      "You are running a compaction/summarization pass. Your task is to write a concise summary of the conversation so far.",
      "",
      "IMPORTANT:",
      "",
      "- You have NO tools available. Do not attempt to call any tools or output JSON.",
      "- Simply write the summary as plain text prose.",
      "- Follow the user's instructions for what to include in the summary.",
      "```",
      "",
      "{/* END COMPACT_AGENT_SYSTEM_PROMPT */}",
      "",
      "</Accordion>",
      "",
      '<Accordion title="Default compaction instructions (user message)">',
      "",
      "{/* BEGIN COMPACTION_USER_PROMPT */}",
      "",
      "```text",
      "Summarize this conversation for a new Assistant to continue helping the user.",
      "",
      "Your summary must be approximately 2000 words.",
      "",
      "Include:",
      "- The user's overall goal and current task",
      "- Key decisions made and their rationale",
      "- Current state of the work (what's done, what's in progress)",
      "- Important technical details (file paths, function names, configurations)",
      "- Any errors encountered and how they were resolved",
      "- Unresolved issues or blockers",
      "",
      "Do not include:",
      "- Suggestions for next steps",
      "- Conversational filler or pleasantries",
      "- Redundant information",
      "",
      "Write in a factual, dense style. Every sentence should convey essential context.",
      "```",
      "",
      "{/* END COMPACTION_USER_PROMPT */}",
      "",
      "</Accordion>",
      "",
      "## Notes",
      "",
      "- Custom `compact` agents apply to both manual `/compact` and auto-compaction.",
      "- Tools are always disabled during compaction.",
      "- `-t` sets `maxOutputTokens`; Mux converts this into an approximate word target for the instruction message.",
      ""
    ].join("\n"),
    "references/docs/workspaces/compaction/index.mdx": [
      "---",
      "title: Compaction",
      "description: Managing conversation context size with compaction",
      "---",
      "",
      "As conversations grow, they consume more of the model's context window. Compaction reduces context size while preserving important information, keeping your conversations responsive and cost-effective.",
      "",
      "## Approaches",
      "",
      "| Approach                                                                  | Speed            | Context Preservation | Cost            | Reversible |",
      "| ------------------------------------------------------------------------- | ---------------- | -------------------- | --------------- | ---------- |",
      "| [Start Here](/workspaces/compaction/manual#start-here)                    | Instant          | Intelligent          | Free            | Yes        |",
      "| [`/compact`](/workspaces/compaction/manual#compact---ai-summarization)    | Slower (uses AI) | Intelligent          | Uses API tokens | No         |",
      "| [`/clear`](/workspaces/compaction/manual#clear---clear-all-history)       | Instant          | None                 | Free            | No         |",
      "| [`/truncate`](/workspaces/compaction/manual#truncate---simple-truncation) | Instant          | Temporal             | Free            | No         |",
      "| [Auto-Compaction](/workspaces/compaction/automatic)                       | Automatic        | Intelligent          | Uses API tokens | No         |",
      "",
      "## When to compact",
      "",
      "- **Proactively**: Before hitting context limits, especially on long-running tasks",
      "- **After major milestones**: When you've completed a phase and want to preserve learnings without full history",
      "- **When responses degrade**: Large contexts can reduce response quality",
      "",
      "## Next steps",
      "",
      "- [Manual Compaction](/workspaces/compaction/manual) \u2014 Commands for manually managing context",
      "- [Automatic Compaction](/workspaces/compaction/automatic) \u2014 Let Mux compact for you based on usage or idle time",
      ""
    ].join("\n"),
    "references/docs/workspaces/compaction/manual.mdx": [
      "---",
      "title: Manual Compaction",
      "description: Commands for manually managing conversation context",
      "---",
      "",
      "Manual compaction commands give you direct control over your conversation history.",
      "",
      "## Start Here",
      "",
      "Start Here allows you to restart your conversation from a specific point, using that message as the entire conversation history. This is available on:",
      "",
      '- **Plans** \u2014 Click "\u{1F3AF} Start Here" on any plan to use it as your conversation starting point',
      '- **Final Assistant messages** \u2014 Click "\u{1F3AF} Start Here" on any completed assistant response',
      "",
      "![Start Here](/img/plan-compact.webp)",
      "",
      'This is a form of "opportunistic compaction" \u2014 the content is already well-structured, so the operation is instant. You can review the new starting point before the old context is permanently removed, making this the only reversible compaction approach.',
      "",
      "---",
      "",
      "## `/compact` \u2014 AI Summarization",
      "",
      "Compress conversation history using AI summarization. Replaces the conversation with a compact summary that preserves context.",
      "",
      "### Syntax",
      "",
      "```",
      "/compact [-t <tokens>] [-m <model>]",
      "[continue message on subsequent lines]",
      "```",
      "",
      "### Options",
      "",
      "- `-t <tokens>` \u2014 Maximum output tokens for the summary (default: ~2000 words)",
      "- `-m <model>` \u2014 Model to use for compaction (sticky preference). Supports abbreviations like `haiku`, `sonnet`, or full model strings",
      "",
      "### Examples",
      "",
      "**Basic compaction:**",
      "",
      "```",
      "/compact",
      "```",
      "",
      "**Limit summary size:**",
      "",
      "```",
      "/compact -t 5000",
      "```",
      "",
      "**Choose compaction model:**",
      "",
      "```",
      "/compact -m haiku",
      "```",
      "",
      "Use Haiku for faster, lower-cost compaction. This becomes your default until changed.",
      "",
      "**Auto-continue with custom message:**",
      "",
      "```",
      "/compact",
      "Continue implementing the auth system",
      "```",
      "",
      'After compaction completes, automatically sends "Continue implementing the auth system" as a follow-up message.',
      "",
      "**Multiline continue message:**",
      "",
      "```",
      "/compact",
      "Now let's refactor the middleware to use the new auth context.",
      "Make sure to add tests for the error cases.",
      "```",
      "",
      "Continue messages can span multiple lines for more detailed instructions.",
      "",
      "**Combine all options:**",
      "",
      "```",
      "/compact -m haiku -t 8000",
      "Keep working on the feature",
      "```",
      "",
      "Combine custom model, token limit, and auto-continue message.",
      "",
      "### Notes",
      "",
      "- Model preference persists globally across workspaces",
      "- Uses the specified model (or workspace model by default) to summarize conversation history",
      "- Preserves actionable context and specific details",
      "- **Irreversible** \u2014 original messages are replaced",
      "- Continue message is sent once after compaction completes (not persisted)",
      "",
      "---",
      "",
      "## `/clear` \u2014 Clear All History",
      "",
      "Remove all messages from conversation history.",
      "",
      "### Syntax",
      "",
      "```",
      "/clear",
      "```",
      "",
      "### Notes",
      "",
      "- Instant deletion of all messages",
      "- **Irreversible** \u2014 all history is permanently removed",
      "- Use when you want to start a completely new conversation",
      "",
      "---",
      "",
      "## `/truncate` \u2014 Simple Truncation",
      "",
      "Remove a percentage of messages from conversation history (from the oldest first).",
      "",
      "### Syntax",
      "",
      "```",
      "/truncate <percentage>",
      "```",
      "",
      "### Parameters",
      "",
      "- `percentage` (required) \u2014 Percentage of messages to remove (0-100)",
      "",
      "### Examples",
      "",
      "```",
      "/truncate 50",
      "```",
      "",
      "Remove oldest 50% of messages.",
      "",
      "### Notes",
      "",
      "- Simple deletion, no AI involved",
      "- Removes messages from oldest to newest",
      "- About as fast as `/clear`",
      "- `/truncate 100` is equivalent to `/clear`",
      "- **Irreversible** \u2014 messages are permanently removed",
      "",
      "### OpenAI Responses API Limitation",
      "",
      "<Warning>",
      "  `/truncate` does not work with OpenAI models due to the Responses API architecture:",
      "</Warning>",
      "",
      "- OpenAI's Responses API stores conversation state server-side",
      "- Manual message deletion via `/truncate` doesn't affect the server-side state",
      '- Instead, OpenAI models use **automatic truncation** (`truncation: "auto"`)',
      "- When context exceeds the limit, the API automatically drops messages from the middle of the conversation",
      "",
      "**Workarounds for OpenAI:**",
      "",
      "- Use `/clear` to start a fresh conversation",
      "- Use `/compact` to intelligently summarize and reduce context",
      "- Rely on automatic truncation (enabled by default)",
      ""
    ].join("\n"),
    "references/docs/workspaces/fork.mdx": [
      "---",
      "title: Forking Workspaces",
      "description: Clone workspaces with conversation history to explore alternatives",
      "---",
      "",
      "Use `/fork` to clone a workspace with its full conversation history and UI state. The forked workspace gets a new workspace on a new branch (using the same backend as the current workspace).",
      "",
      "Usage:",
      "",
      "```",
      "/fork <new-workspace-name>",
      "",
      "[start-message (optional)]",
      "```",
      "",
      "## Use cases",
      "",
      "- **Explore alternatives**: Fork mid-conversation to try a different implementation approach.",
      "- **Isolate tangents**: See an unrelated bug or opportunity in the course of a change? Fork to keep the main conversation on track.",
      "- **Create backup**: Fork to keep a copy of an old conversation before a risky change in direction.",
      "",
      "## What happens when you fork",
      "",
      "The new workspace:",
      "",
      "- Appears at the top of the workspace list (most recent)",
      "- Uses the provided workspace name (you can rename later)",
      "- Branches from the current workspace's HEAD commit",
      "",
      "**What's copied**: Conversation history, model selection, thinking level, auto-retry setting, UI mode (plan/exec), chat input text",
      "",
      "**What's not copied**: Uncommitted file changes (new branch starts from HEAD)",
      ""
    ].join("\n"),
    "references/docs/workspaces/index.mdx": [
      "---",
      "title: Workspaces",
      "description: Isolated development environments for parallel agent work",
      "---",
      "",
      "Workspaces let you run multiple agent sessions in parallel.",
      "",
      "Each workspace has its own chat history and, depending on runtime, its own working directory and Git checkout state.",
      "",
      "## Runtimes",
      "",
      "Runtimes decide where a workspace runs and how isolated its filesystem is:",
      "",
      "- **[Local](/runtime/local)**: Runs directly in your project directory. No filesystem isolation.",
      "- **[Worktree](/runtime/worktree)**: Creates a local [git worktree](https://git-scm.com/docs/git-worktree) for per-workspace isolation while still sharing `.git`.",
      "- **[SSH](/runtime/ssh)**: Runs on a remote host over SSH (useful for security isolation and heavy parallelism).",
      "",
      "## Key concepts",
      "",
      "- **Branch flexibility**: A workspace can switch branches, use detached HEAD, or create new branches as needed.",
      "- **Commit visibility**: Local + worktree runtimes share the same Git repository. Commits made in one workspace are immediately visible to your other worktrees and your main checkout.",
      "- **Parallel execution**: Multiple workspaces can work on different tasks concurrently.",
      "",
      "## Reviewing changes",
      "",
      'A few common workflows (from "agent edits only" \u2192 "agent owns the PR"):',
      "",
      "- **Agent edits only**: Open the workspace directory and stage/commit yourself (`git add -p`).",
      "- **Agent commits**: Review locally from your main checkout (for example `git show <workspace-branch>`), then push when you\u2019re satisfied.",
      "- **Agent commits + pushes**: Ask the agent to open a PR and review in GitHub/GitLab.",
      "  - Also see: [Agentic Git Identity](/config/agentic-git-identity)",
      "  - This requires granting the workspace git push credentials; prefer a dedicated identity/token.",
      "",
      "## Reviewing functionality (UI, behavior)",
      "",
      "Some changes (especially UI ones) are faster to review by running the workspace locally.",
      "",
      "1. Ask the agent to commit when it\u2019s ready for review.",
      "2. If the workspace is a **worktree**, check out the branch in a detached HEAD state from your main checkout:",
      "",
      "   ```bash",
      "   git checkout --detach <workspace-branch>",
      "   ```",
      "",
      "<Note>",
      "  Detached HEAD is useful here because a branch can only be checked out by one worktree at a time.",
      "</Note>",
      "",
      "If you want faster iteration between commits, open the workspace directory and run a dev server (for example `bun dev`) there directly.",
      "",
      "---",
      "",
      "See the runtime pages for setup and trade-offs.",
      ""
    ].join("\n"),
    "references/docs/workspaces/sharing.mdx": [
      "---",
      "title: Message Sharing",
      "sidebarTitle: Sharing",
      "description: Share encrypted messages with cryptographic signatures via Mux",
      "---",
      "",
      "Mux lets you share assistant messages via [mux.md](https://mux.md), an end-to-end encrypted paste service. Shared messages can also be cryptographically signed to prove authorship.",
      "",
      "![Sharing](../img/message-sharing.webp)",
      "",
      "## How sharing works",
      "",
      "1. **End-to-end encryption**: Content is encrypted in your browser using AES-256-GCM before upload. The encryption key stays in the URL fragment and is never sent to the server.",
      "",
      "2. **Optional signing**: When a signing key is available, Mux signs the content with your private key. Recipients can verify the signature on mux.md.",
      "",
      "3. **Expiration**: Shares can expire after 1 hour, 24 hours, 7 days, 30 days, or never. You can change expiration after sharing.",
      "",
      "## Message signing",
      "",
      "Signing proves that you authored a shared message. When enabled, mux.md displays your GitHub username alongside a \u201CVerified\u201D badge.",
      "",
      "### Signing key discovery",
      "",
      "Mux looks for a signing key in these locations (first match wins):",
      "",
      "1. `~/.mux/message_signing_key` \u2014 Mux-specific key (can be a symlink)",
      "2. `~/.ssh/id_ed25519` \u2014 standard SSH Ed25519 key",
      "3. `~/.ssh/id_ecdsa` \u2014 standard SSH ECDSA key",
      "",
      "Mux can also sign using keys loaded in your SSH agent when `SSH_AUTH_SOCK` is set (for example,",
      "1Password's SSH agent). Agent-backed keys are preferred over the default `~/.ssh/id_*` files.",
      "",
      "<Tip>",
      "  To reuse an existing key without copying it:",
      "",
      "```bash",
      "ln -s ~/.ssh/id_ed25519 ~/.mux/message_signing_key",
      "```",
      "",
      "</Tip>",
      "",
      "### Supported key types",
      "",
      "- **Ed25519** (recommended) \u2014 fast, secure, 32-byte keys",
      "- **ECDSA** \u2014 P-256, P-384, and P-521 curves supported",
      "",
      "Encrypted key files (passphrase-protected) are skipped automatically unless the key is available via ssh-agent.",
      "",
      "### GitHub identity detection",
      "",
      "To display your GitHub username on signed shares, Mux detects your identity via the GitHub CLI:",
      "",
      "```bash",
      "gh auth status",
      "```",
      "",
      "If you're logged in with `gh auth login`, your GitHub username appears on mux.md alongside the signature verification.",
      "",
      "<Note>",
      "  GitHub CLI is optional. Without it, shares are still signed\u2014recipients just see the public key",
      "  fingerprint instead of your username.",
      "</Note>",
      "",
      "### Enabling/disabling signing",
      "",
      "Click the pen icon in the share popover to toggle signing on or off. This setting persists across sessions.",
      "",
      "When signing is disabled (or no key is found), shares are still encrypted\u2014they just won\u2019t include a signature.",
      "",
      "## Using shared content in Mux",
      "",
      "Mux can read mux.md URLs using the `web_fetch` tool. When you paste a mux.md link into chat, Mux decrypts the content client-side and makes it available to the assistant.",
      "",
      "This enables several workflows:",
      "",
      "- **Cross-session sharing**: Move context or instructions between workspaces in the same Mux client",
      "- **Team collaboration**: Send encrypted snippets to teammates who can paste them into their own Mux sessions",
      "- **Preserving context**: Save important outputs and retrieve them later in new conversations",
      "",
      "Paste any `https://mux.md/<id>#<key>` URL into your message, and Mux will fetch and decrypt the content.",
      "",
      "<Tip>",
      "  The encryption key (after `#`) never leaves your client. Only the encrypted blob travels over the",
      "  network.",
      "</Tip>",
      "",
      "## Generating a signing key",
      "",
      "If you don\u2019t already have an SSH key, generate one:",
      "",
      "```bash",
      "# Ed25519 (recommended)",
      'ssh-keygen -t ed25519 -f ~/.mux/message_signing_key -N ""',
      "",
      "# Or ECDSA",
      'ssh-keygen -t ecdsa -b 256 -f ~/.mux/message_signing_key -N ""',
      "```",
      "",
      'The `-N ""` flag creates a key without a passphrase (required for Mux to use it automatically).',
      ""
    ].join("\n"),
    "SKILL.md": [
      "---",
      "name: mux-docs",
      "description: Index + offline snapshot of mux documentation (progressive disclosure).",
      "---",
      "",
      "# mux docs",
      "",
      "This built-in skill helps the agent answer questions about **mux** (Coding Agent Multiplexer) without dumping the entire docs into context.",
      "",
      "## How to use",
      "",
      "### Prefer: read the bundled docs snapshot (recommended)",
      "",
      "This skill bundles an **offline snapshot of the mux docs** under `references/docs/`.",
      "",
      "Why prefer the bundled snapshot?",
      "",
      "1. The docs tree below is guaranteed to match what\u2019s embedded.",
      "2. It\u2019s more likely to match *your installed mux version* (the live site may be ahead).",
      "",
      "To read a specific page:",
      "",
      "```ts",
      "agent_skill_read_file({",
      '  name: "mux-docs",',
      '  filePath: "references/docs/config/models.mdx",',
      "});",
      "```",
      "",
      "### Fallback: fetch the live docs (for newer features)",
      "",
      "If the bundled docs don\u2019t mention something (or you suspect the docs site has newer info), use `web_fetch`:",
      "",
      "```ts",
      'web_fetch({ url: "https://mux.coder.com/config/models" });',
      'web_fetch({ url: "https://mux.coder.com/agents" });',
      "```",
      "",
      "#### Docs tree (auto-generated)",
      "",
      "Use this index to find a page's:",
      "",
      "- **Docs route** (for `web_fetch`)",
      "- **Embedded file path** (for `agent_skill_read_file`)",
      "",
      "<!-- BEGIN DOCS_TREE -->",
      "- **Documentation**",
      "  - **Getting Started**",
      "    - Introduction (`/`) \u2192 `references/docs/index.mdx`",
      "    - Install (`/install`) \u2192 `references/docs/install.mdx` \u2014 Download and install Mux for macOS, Linux, and Windows",
      "    - **Models**",
      "      - Models (`/config/models`) \u2192 `references/docs/config/models.mdx` \u2014 Select and configure AI models in Mux",
      "      - Providers (`/config/providers`) \u2192 `references/docs/config/providers.mdx` \u2014 Configure API keys and settings for AI providers",
      "    - Why Parallelize? (`/getting-started/why-parallelize`) \u2192 `references/docs/getting-started/why-parallelize.mdx` \u2014 Use cases for running multiple AI agents in parallel",
      "    - Mux Gateway (`/getting-started/mux-gateway`) \u2192 `references/docs/getting-started/mux-gateway.mdx` \u2014 Log in to Mux Gateway to get evaluation credits",
      "    - CLI (`/reference/cli`) \u2192 `references/docs/reference/cli.mdx` \u2014 Run one-off agent tasks from the command line with `mux run`",
      "  - **Workspaces**",
      "    - Workspaces (`/workspaces`) \u2192 `references/docs/workspaces/index.mdx` \u2014 Isolated development environments for parallel agent work",
      "    - Forking Workspaces (`/workspaces/fork`) \u2192 `references/docs/workspaces/fork.mdx` \u2014 Clone workspaces with conversation history to explore alternatives",
      "    - Message Sharing (`/workspaces/sharing`) \u2192 `references/docs/workspaces/sharing.mdx` \u2014 Share encrypted messages with cryptographic signatures via Mux",
      "    - **Compaction**",
      "      - Compaction (`/workspaces/compaction`) \u2192 `references/docs/workspaces/compaction/index.mdx` \u2014 Managing conversation context size with compaction",
      "      - Manual Compaction (`/workspaces/compaction/manual`) \u2192 `references/docs/workspaces/compaction/manual.mdx` \u2014 Commands for manually managing conversation context",
      "      - Automatic Compaction (`/workspaces/compaction/automatic`) \u2192 `references/docs/workspaces/compaction/automatic.mdx` \u2014 Let Mux automatically compact your conversations based on usage or idle time",
      "      - Customization (`/workspaces/compaction/customization`) \u2192 `references/docs/workspaces/compaction/customization.mdx` \u2014 Customize the compaction system prompt",
      "    - **Runtimes**",
      "      - Runtimes (`/runtime`) \u2192 `references/docs/runtime/index.mdx` \u2014 Configure where and how Mux executes agent workspaces",
      "      - Local Runtime (`/runtime/local`) \u2192 `references/docs/runtime/local.mdx` \u2014 Run agents directly in your project directory",
      "      - Worktree Runtime (`/runtime/worktree`) \u2192 `references/docs/runtime/worktree.mdx` \u2014 Isolated git worktree environments for parallel agent work",
      "      - SSH Runtime (`/runtime/ssh`) \u2192 `references/docs/runtime/ssh.mdx` \u2014 Run agents on remote hosts over SSH for security and performance",
      "      - Coder Runtime (`/runtime/coder`) \u2192 `references/docs/runtime/coder.mdx` \u2014 Run agents on Coder workspaces",
      "      - Docker Runtime (`/runtime/docker`) \u2192 `references/docs/runtime/docker.mdx` \u2014 Run agents in isolated Docker containers",
      "      - Dev Container Runtime (`/runtime/devcontainer`) \u2192 `references/docs/runtime/devcontainer.mdx` \u2014 Run agents in containers defined by devcontainer.json",
      "    - **Hooks**",
      "      - Init Hooks (`/hooks/init`) \u2192 `references/docs/hooks/init.mdx` \u2014 Run setup commands automatically when creating new workspaces",
      "      - Tool Hooks (`/hooks/tools`) \u2192 `references/docs/hooks/tools.mdx` \u2014 Block dangerous commands, lint after edits, and set up your environment",
      "      - Environment Variables (`/hooks/environment-variables`) \u2192 `references/docs/hooks/environment-variables.mdx` \u2014 Environment variables available in agent bash commands and hooks",
      "  - **Agents**",
      "    - Agents (`/agents`) \u2192 `references/docs/agents/index.mdx` \u2014 Define custom agents (modes + subagents) with Markdown files",
      "    - Instruction Files (`/agents/instruction-files`) \u2192 `references/docs/agents/instruction-files.mdx` \u2014 Configure agent behavior with AGENTS.md files",
      "    - Agent Skills (`/agents/agent-skills`) \u2192 `references/docs/agents/agent-skills.mdx` \u2014 Share reusable workflows and references with skills",
      "    - Plan Mode (`/agents/plan-mode`) \u2192 `references/docs/agents/plan-mode.mdx` \u2014 Review and collaborate on plans before execution",
      "    - System Prompt (`/agents/system-prompt`) \u2192 `references/docs/agents/system-prompt.mdx` \u2014 How Mux constructs the system prompt for AI models",
      "    - Prompting Tips (`/agents/prompting-tips`) \u2192 `references/docs/agents/prompting-tips.mdx` \u2014 Tips and tricks for getting the most out of your AI agents",
      "  - **Configuration**",
      "    - MCP Servers (`/config/mcp-servers`) \u2192 `references/docs/config/mcp-servers.mdx` \u2014 Extend agent capabilities with Model Context Protocol servers",
      "    - Policy File (`/config/policy-file`) \u2192 `references/docs/config/policy-file.mdx` \u2014 Admin-enforced restrictions for providers, models, MCP, and runtimes",
      "    - Project Secrets (`/config/project-secrets`) \u2192 `references/docs/config/project-secrets.mdx` \u2014 Manage environment variables and API keys for your projects",
      "    - Agentic Git Identity (`/config/agentic-git-identity`) \u2192 `references/docs/config/agentic-git-identity.mdx` \u2014 Configure a separate Git identity for AI-generated commits",
      "    - Keyboard Shortcuts (`/config/keybinds`) \u2192 `references/docs/config/keybinds.mdx` \u2014 Complete keyboard shortcut reference for Mux",
      "    - Notifications (`/config/notifications`) \u2192 `references/docs/config/notifications.mdx` \u2014 Configure how agents notify you about important events",
      "    - Vim Mode (`/config/vim-mode`) \u2192 `references/docs/config/vim-mode.mdx` \u2014 Vim-style editing in the Mux chat input",
      "  - **Guides**",
      "    - GitHub Actions (`/guides/github-actions`) \u2192 `references/docs/guides/github-actions.mdx` \u2014 Automate your workflows with mux run in GitHub Actions",
      "    - Agentic Git Identity (`/config/agentic-git-identity`) \u2192 `references/docs/config/agentic-git-identity.mdx` \u2014 Configure a separate Git identity for AI-generated commits",
      "    - Prompting Tips (`/agents/prompting-tips`) \u2192 `references/docs/agents/prompting-tips.mdx` \u2014 Tips and tricks for getting the most out of your AI agents",
      "  - **Integrations**",
      "    - VS Code Extension (`/integrations/vscode-extension`) \u2192 `references/docs/integrations/vscode-extension.mdx` \u2014 Pair Mux workspaces with VS Code and Cursor editors",
      "  - **Reference**",
      "    - Telemetry (`/reference/telemetry`) \u2192 `references/docs/reference/telemetry.mdx` \u2014 What Mux collects, what it doesn\u2019t, and how to disable it",
      "    - Storybook (`/reference/storybook`) \u2192 `references/docs/reference/storybook.mdx` \u2014 Develop and test Mux UI states in isolation",
      "    - Terminal Benchmarking (`/reference/benchmarking`) \u2192 `references/docs/reference/benchmarking.mdx` \u2014 Run Terminal-Bench benchmarks with the Mux adapter",
      "    - AGENTS.md (`/AGENTS`) \u2192 `references/docs/AGENTS.md` \u2014 Agent instructions for AI assistants working on the Mux codebase",
      "<!-- END DOCS_TREE -->",
      "",
      "1. Read the docs navigation (source of truth for which pages exist):",
      "",
      "```ts",
      'agent_skill_read_file({ name: "mux-docs", filePath: "references/docs/docs.json" });',
      "```",
      "",
      "2. Read a specific page by path (mirrors `docs/` in the mux repo):",
      "",
      "- `/agents` \u2192 `references/docs/agents/index.mdx`",
      "- `/config/models` \u2192 `references/docs/config/models.mdx`",
      "- `/runtime` \u2192 `references/docs/runtime/index.mdx`",
      "",
      "```ts",
      "agent_skill_read_file({",
      '  name: "mux-docs",',
      '  filePath: "references/docs/config/models.mdx",',
      "});",
      "```",
      "",
      "Notes:",
      "",
      "- Many pages are `.mdx`; some are `.../index.mdx`.",
      "- Images are not embedded; you may see `/img/...` references.",
      "",
      "## When to use",
      "",
      "Use this skill when the user asks how mux works (workspaces, runtimes, agents, models, hooks, keybinds, etc.).",
      "",
      "## Links",
      "",
      "- **GitHub**: https://github.com/coder/mux",
      "- **Documentation**: https://mux.coder.com",
      ""
    ].join("\n")
  }
};

// src/node/services/agentSkills/builtInSkillDefinitions.ts
var BUILT_IN_SOURCES = Object.entries(BUILTIN_SKILL_FILES).map(
  ([name25, files]) => ({ name: name25, files })
);
var cachedPackages = null;
function parseBuiltIns() {
  return BUILT_IN_SOURCES.map(({ name: name25, files }) => {
    const content = files["SKILL.md"];
    if (content === void 0) {
      throw new Error(`Built-in skill '${name25}' is missing SKILL.md`);
    }
    const parsed = parseSkillMarkdown({
      content,
      byteSize: Buffer.byteLength(content, "utf8"),
      directoryName: name25
    });
    return {
      scope: "built-in",
      directoryName: name25,
      frontmatter: parsed.frontmatter,
      body: parsed.body.trim()
    };
  });
}
function getBuiltInSkillDefinitions() {
  cachedPackages ??= parseBuiltIns();
  return cachedPackages;
}
function getBuiltInSkillDescriptors() {
  return getBuiltInSkillDefinitions().map((pkg) => ({
    name: pkg.frontmatter.name,
    description: pkg.frontmatter.description,
    scope: pkg.scope,
    advertise: pkg.frontmatter.advertise
  }));
}
function getBuiltInSkillByName(name25) {
  return getBuiltInSkillDefinitions().find((pkg) => pkg.frontmatter.name === name25);
}

// src/node/services/agentSkills/agentSkillsService.ts
var GLOBAL_SKILLS_ROOT = "~/.mux/skills";
function getDefaultAgentSkillsRoots(runtime, workspacePath) {
  if (!workspacePath) {
    throw new Error("getDefaultAgentSkillsRoots: workspacePath is required");
  }
  return {
    projectRoot: runtime.normalizePath(".mux/skills", workspacePath),
    globalRoot: GLOBAL_SKILLS_ROOT
  };
}
function formatError(error) {
  return error instanceof Error ? error.message : String(error);
}
async function listSkillDirectoriesFromLocalFs(root) {
  try {
    const entries = await fs12.readdir(root, { withFileTypes: true });
    return entries.filter((entry) => entry.isDirectory() || entry.isSymbolicLink()).map((entry) => entry.name);
  } catch {
    return [];
  }
}
async function listSkillDirectoriesFromRuntime(runtime, root, options) {
  if (!options.cwd) {
    throw new Error("listSkillDirectoriesFromRuntime: options.cwd is required");
  }
  const quotedRoot = shellQuote(root);
  const command = `if [ -d ${quotedRoot} ]; then find -L ${quotedRoot} -mindepth 1 -maxdepth 1 -type d -exec basename {} \\; ; fi`;
  const result = await execBuffered(runtime, command, { cwd: options.cwd, timeout: 10 });
  if (result.exitCode !== 0) {
    log.warn(`Failed to read skills directory ${root}: ${result.stderr || result.stdout}`);
    return [];
  }
  return result.stdout.split("\n").map((line) => line.trim()).filter(Boolean);
}
async function readSkillDescriptorFromDir(runtime, skillDir, directoryName, scope, options) {
  const skillFilePath = runtime.normalizePath("SKILL.md", skillDir);
  let stat4;
  try {
    stat4 = await runtime.stat(skillFilePath);
  } catch {
    options?.invalidSkills?.push({
      directoryName,
      scope,
      displayPath: skillFilePath,
      message: "SKILL.md is missing or unreadable.",
      hint: "Create a SKILL.md file with YAML frontmatter (--- ... ---)."
    });
    return null;
  }
  if (stat4.isDirectory) {
    options?.invalidSkills?.push({
      directoryName,
      scope,
      displayPath: skillFilePath,
      message: "SKILL.md is a directory (expected a file).",
      hint: "Replace SKILL.md with a regular file."
    });
    return null;
  }
  const sizeValidation = validateFileSize(stat4);
  if (sizeValidation) {
    log.warn(`Skipping skill '${directoryName}' (${scope}): ${sizeValidation.error}`);
    options?.invalidSkills?.push({
      directoryName,
      scope,
      displayPath: skillFilePath,
      message: sizeValidation.error,
      hint: "Reduce SKILL.md size below 1MB."
    });
    return null;
  }
  let content;
  try {
    content = await readFileString(runtime, skillFilePath);
  } catch (err) {
    const message = formatError(err);
    log.warn(`Failed to read SKILL.md for ${directoryName}: ${message}`);
    options?.invalidSkills?.push({
      directoryName,
      scope,
      displayPath: skillFilePath,
      message: `Failed to read SKILL.md: ${message}`,
      hint: "Check file permissions and ensure the file is UTF-8 text."
    });
    return null;
  }
  try {
    const parsed = parseSkillMarkdown({
      content,
      byteSize: stat4.size,
      directoryName
    });
    const descriptor = {
      name: parsed.frontmatter.name,
      description: parsed.frontmatter.description,
      scope,
      advertise: parsed.frontmatter.advertise
    };
    const validated = AgentSkillDescriptorSchema.safeParse(descriptor);
    if (!validated.success) {
      log.warn(`Invalid agent skill descriptor for ${directoryName}: ${validated.error.message}`);
      options?.invalidSkills?.push({
        directoryName,
        scope,
        displayPath: skillFilePath,
        message: `Invalid agent skill descriptor: ${validated.error.message}`,
        hint: "Fix SKILL.md frontmatter fields to satisfy the skill schema."
      });
      return null;
    }
    return validated.data;
  } catch (err) {
    const message = err instanceof AgentSkillParseError ? err.message : formatError(err);
    log.warn(`Skipping invalid skill '${directoryName}' (${scope}): ${message}`);
    options?.invalidSkills?.push({
      directoryName,
      scope,
      displayPath: skillFilePath,
      message,
      hint: "Fix SKILL.md frontmatter (name + description) and ensure it matches the directory name."
    });
    return null;
  }
}
async function discoverAgentSkills(runtime, workspacePath, options) {
  if (!workspacePath) {
    throw new Error("discoverAgentSkills: workspacePath is required");
  }
  const roots = options?.roots ?? getDefaultAgentSkillsRoots(runtime, workspacePath);
  const byName = /* @__PURE__ */ new Map();
  const scans = [
    { scope: "project", root: roots.projectRoot },
    { scope: "global", root: roots.globalRoot }
  ];
  for (const scan of scans) {
    let resolvedRoot;
    try {
      resolvedRoot = await runtime.resolvePath(scan.root);
    } catch (err) {
      log.warn(`Failed to resolve skills root ${scan.root}: ${formatError(err)}`);
      continue;
    }
    const directoryNames = runtime instanceof SSHRuntime ? await listSkillDirectoriesFromRuntime(runtime, resolvedRoot, { cwd: workspacePath }) : await listSkillDirectoriesFromLocalFs(resolvedRoot);
    for (const directoryNameRaw of directoryNames) {
      const nameParsed = SkillNameSchema.safeParse(directoryNameRaw);
      if (!nameParsed.success) {
        log.warn(`Skipping invalid skill directory name '${directoryNameRaw}' in ${resolvedRoot}`);
        continue;
      }
      const directoryName = nameParsed.data;
      if (scan.scope === "global" && byName.has(directoryName)) {
        continue;
      }
      const skillDir = runtime.normalizePath(directoryName, resolvedRoot);
      const descriptor = await readSkillDescriptorFromDir(
        runtime,
        skillDir,
        directoryName,
        scan.scope
      );
      if (!descriptor) continue;
      byName.set(descriptor.name, descriptor);
    }
  }
  for (const builtIn of getBuiltInSkillDescriptors()) {
    if (!byName.has(builtIn.name)) {
      byName.set(builtIn.name, builtIn);
    }
  }
  return Array.from(byName.values()).sort((a, b) => a.name.localeCompare(b.name));
}
async function discoverAgentSkillsDiagnostics(runtime, workspacePath, options) {
  if (!workspacePath) {
    throw new Error("discoverAgentSkillsDiagnostics: workspacePath is required");
  }
  const roots = options?.roots ?? getDefaultAgentSkillsRoots(runtime, workspacePath);
  const byName = /* @__PURE__ */ new Map();
  const invalidSkills = [];
  const scans = [
    { scope: "project", root: roots.projectRoot },
    { scope: "global", root: roots.globalRoot }
  ];
  for (const scan of scans) {
    let resolvedRoot;
    try {
      resolvedRoot = await runtime.resolvePath(scan.root);
    } catch (err) {
      log.warn(`Failed to resolve skills root ${scan.root}: ${formatError(err)}`);
      continue;
    }
    const directoryNames = runtime instanceof SSHRuntime ? await listSkillDirectoriesFromRuntime(runtime, resolvedRoot, { cwd: workspacePath }) : await listSkillDirectoriesFromLocalFs(resolvedRoot);
    for (const directoryNameRaw of directoryNames) {
      const nameParsed = SkillNameSchema.safeParse(directoryNameRaw);
      if (!nameParsed.success) {
        log.warn(`Skipping invalid skill directory name '${directoryNameRaw}' in ${resolvedRoot}`);
        invalidSkills.push({
          directoryName: directoryNameRaw,
          scope: scan.scope,
          displayPath: runtime.normalizePath(directoryNameRaw, resolvedRoot),
          message: `Invalid skill directory name '${directoryNameRaw}'.`,
          hint: "Rename the directory to kebab-case (lowercase letters/numbers/hyphens)."
        });
        continue;
      }
      const directoryName = nameParsed.data;
      if (scan.scope === "global" && byName.has(directoryName)) {
        continue;
      }
      const skillDir = runtime.normalizePath(directoryName, resolvedRoot);
      const descriptor = await readSkillDescriptorFromDir(
        runtime,
        skillDir,
        directoryName,
        scan.scope,
        {
          invalidSkills
        }
      );
      if (!descriptor) continue;
      byName.set(descriptor.name, descriptor);
    }
  }
  for (const builtIn of getBuiltInSkillDescriptors()) {
    if (!byName.has(builtIn.name)) {
      byName.set(builtIn.name, builtIn);
    }
  }
  const skills = Array.from(byName.values()).sort((a, b) => a.name.localeCompare(b.name));
  const scopeOrder = {
    project: 0,
    global: 1,
    "built-in": 2
  };
  invalidSkills.sort((a, b) => {
    const scopeDiff = (scopeOrder[a.scope] ?? 0) - (scopeOrder[b.scope] ?? 0);
    if (scopeDiff !== 0) return scopeDiff;
    return a.directoryName.localeCompare(b.directoryName);
  });
  return {
    skills,
    invalidSkills
  };
}
async function readAgentSkillFromDir(runtime, skillDir, directoryName, scope) {
  const skillFilePath = runtime.normalizePath("SKILL.md", skillDir);
  const stat4 = await runtime.stat(skillFilePath);
  if (stat4.isDirectory) {
    throw new Error(`SKILL.md is not a file: ${skillFilePath}`);
  }
  const sizeValidation = validateFileSize(stat4);
  if (sizeValidation) {
    throw new Error(sizeValidation.error);
  }
  const content = await readFileString(runtime, skillFilePath);
  const parsed = parseSkillMarkdown({
    content,
    byteSize: stat4.size,
    directoryName
  });
  const pkg = {
    scope,
    directoryName,
    frontmatter: parsed.frontmatter,
    body: parsed.body
  };
  const validated = AgentSkillPackageSchema.safeParse(pkg);
  if (!validated.success) {
    throw new Error(
      `Invalid agent skill package for '${directoryName}': ${validated.error.message}`
    );
  }
  return {
    package: validated.data,
    skillDir
  };
}
async function readAgentSkill(runtime, workspacePath, name25, options) {
  if (!workspacePath) {
    throw new Error("readAgentSkill: workspacePath is required");
  }
  const roots = options?.roots ?? getDefaultAgentSkillsRoots(runtime, workspacePath);
  const candidates = [
    { scope: "project", root: roots.projectRoot },
    { scope: "global", root: roots.globalRoot }
  ];
  for (const candidate of candidates) {
    let resolvedRoot;
    try {
      resolvedRoot = await runtime.resolvePath(candidate.root);
    } catch {
      continue;
    }
    const skillDir = runtime.normalizePath(name25, resolvedRoot);
    try {
      const stat4 = await runtime.stat(skillDir);
      if (!stat4.isDirectory) continue;
      return await readAgentSkillFromDir(runtime, skillDir, name25, candidate.scope);
    } catch {
      continue;
    }
  }
  const builtIn = getBuiltInSkillByName(name25);
  if (builtIn) {
    return {
      package: builtIn,
      // Built-in skills don't have a real skillDir on disk.
      // agent_skill_read_file handles built-in skills specially; this is a sentinel value.
      skillDir: `<built-in:${name25}>`
    };
  }
  throw new Error(`Agent skill not found: ${name25}`);
}

// src/node/services/agentDefinitions/agentDefinitionsService.ts
import * as fs13 from "node:fs/promises";
import * as path20 from "node:path";

// src/node/services/agentDefinitions/parseAgentDefinitionMarkdown.ts
var import_yaml2 = __toESM(require_dist3());
var AgentDefinitionParseError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AgentDefinitionParseError";
  }
};
function normalizeNewlines2(input) {
  return input.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
}
function stripUtf8Bom2(input) {
  return input.startsWith("\uFEFF") ? input.slice(1) : input;
}
function assertObject2(value2, message) {
  if (!value2 || typeof value2 !== "object" || Array.isArray(value2)) {
    throw new AgentDefinitionParseError(message);
  }
}
function formatZodIssues2(issues) {
  return issues.map((issue) => {
    const issuePath = issue.path.length > 0 ? issue.path.map((part) => String(part)).join(".") : "<root>";
    return `${issuePath}: ${issue.message}`;
  }).join("; ");
}
function parseAgentDefinitionMarkdown(input) {
  if (input.byteSize > MAX_FILE_SIZE) {
    const sizeMB = (input.byteSize / (1024 * 1024)).toFixed(2);
    const maxMB = (MAX_FILE_SIZE / (1024 * 1024)).toFixed(2);
    throw new AgentDefinitionParseError(
      `Agent definition is too large (${sizeMB}MB). Maximum supported size is ${maxMB}MB.`
    );
  }
  const content = normalizeNewlines2(stripUtf8Bom2(input.content));
  if (!content.startsWith("---")) {
    throw new AgentDefinitionParseError(
      "Agent definition must start with YAML frontmatter delimited by '---'."
    );
  }
  const lines = content.split("\n");
  if ((lines[0] ?? "").trim() !== "---") {
    throw new AgentDefinitionParseError(
      "Agent definition frontmatter start delimiter must be exactly '---'."
    );
  }
  const endIndex = lines.findIndex((line, idx) => idx > 0 && line.trim() === "---");
  if (endIndex === -1) {
    throw new AgentDefinitionParseError(
      "Agent definition frontmatter is missing the closing '---' delimiter."
    );
  }
  const yamlText = lines.slice(1, endIndex).join("\n");
  const body = lines.slice(endIndex + 1).join("\n");
  let raw;
  try {
    raw = import_yaml2.default.parse(yamlText);
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    throw new AgentDefinitionParseError(`Failed to parse YAML frontmatter: ${message}`);
  }
  assertObject2(raw, "Agent definition YAML frontmatter must be a mapping/object.");
  const parsed = AgentDefinitionFrontmatterSchema.safeParse(raw);
  if (!parsed.success) {
    throw new AgentDefinitionParseError(
      `Invalid agent definition frontmatter: ${formatZodIssues2(parsed.error.issues)}`
    );
  }
  return { frontmatter: parsed.data, body };
}

// src/node/services/agentDefinitions/builtInAgentContent.generated.ts
var BUILTIN_AGENT_CONTENT = {
  "ask": '---\nname: Ask\ndescription: Delegate questions to Explore sub-agents and synthesize an answer.\nbase: exec\nui:\n  color: var(--color-ask-mode)\nsubagent:\n  runnable: false\ntools:\n  # Inherits all tools from exec, then removes editing tools\n  remove:\n    # Read-only: no file modifications\n    - file_edit_.*\n---\n\nYou are **Ask**.\n\nYour job is to answer the user\'s question by delegating research to sub-agents (typically **Explore**), then synthesizing a concise, actionable response.\n\n## When to delegate\n\n- Delegate when the question requires repository exploration, multiple viewpoints, or verification.\n- If the answer is obvious and does not require looking anything up, answer directly.\n\n## Delegation workflow\n\n1. Break the question into **1\u20133** focused research threads.\n2. Spawn Explore sub-agents in parallel using the `task` tool:\n   - `agentId: "explore"` (or `subagent_type: "explore"`)\n   - Use clear titles like `"Ask: find callsites"`, `"Ask: summarize behavior"`, etc.\n   - Ask for concrete outputs: file paths, symbols, commands to reproduce, and short excerpts.\n3. Wait for results (use `task_await` if you launched tasks in the background).\n4. Synthesize:\n   - Provide the final answer first.\n   - Then include supporting details (paths, commands, edge cases).\n   - Trust Explore sub-agent reports as authoritative for repo facts (paths/symbols/callsites). Do not redo the same investigation yourself; only re-check if the report is ambiguous or contradicts other evidence.\n\n## Safety rules\n\n- Do **not** modify repository files.\n- Prefer `agentId: "explore"`. Only use `"exec"` if the user explicitly asks to implement changes.\n',
  "compact": "---\nname: Compact\ndescription: History compaction (internal)\nui:\n  hidden: true\nsubagent:\n  runnable: false\n---\n\nYou are running a compaction/summarization pass. Your task is to write a concise summary of the conversation so far.\n\nIMPORTANT:\n\n- You have NO tools available. Do not attempt to call any tools or output JSON.\n- Simply write the summary as plain text prose.\n- Follow the user's instructions for what to include in the summary.\n",
  "exec": "---\nname: Exec\ndescription: Implement changes in the repository\nui:\n  color: var(--color-exec-mode)\nsubagent:\n  runnable: true\n  append_prompt: |\n    You are running as a sub-agent in a child workspace.\n\n    - Take a single narrowly scoped task and complete it end-to-end. Do not expand scope.\n    - Preserve your context window: treat `explore` tasks as a context-saving repo scout for discovery (file locations, callsites, tests, config points, high-level flows).\n      If you need repo context, spawn 1\u2013N `explore` tasks (read-only) to scan the codebase and return paths + symbols + minimal excerpts.\n      Then open/read only the returned files; avoid broad manual file-reading, and write a short internal \"mini-plan\" before editing.\n      If the task brief already includes clear starting points + acceptance criteria, skip the initial explore pass and only explore when blocked.\n      Prefer 1\u20133 narrow `explore` tasks (possibly in parallel).\n    - If the task brief is missing critical information (scope, acceptance, or starting points) and you cannot infer it safely after a quick `explore`, do not guess.\n      Stop and call `agent_report` once with 1\u20133 concrete questions/unknowns for the parent agent, and do not create commits.\n    - Run targeted verification and create one or more git commits.\n    - **Before your stream ends, you MUST call `agent_report` exactly once with:**\n      - What changed (paths / key details)\n      - What you ran (tests, typecheck, lint)\n      - Any follow-ups / risks\n      (If you forget, the parent will inject a follow-up message and you'll waste tokens.)\n    - You may call task/task_await/task_list/task_terminate to delegate further when available.\n      Delegation is limited by Max Task Nesting Depth (Settings \u2192 Agents \u2192 Task Settings).\n    - Do not call propose_plan.\ntools:\n  add:\n    # Allow all tools by default (includes MCP tools which have dynamic names)\n    # Use tools.remove in child agents to restrict specific tools\n    - .*\n  remove:\n    # Exec mode doesn't use planning tools\n    - propose_plan\n    - ask_user_question\n    # Internal-only tools\n    - system1_keep_ranges\n---\n\nYou are in Exec mode.\n\n- If a `<plan>` block was provided (plan \u2192 exec handoff) and the user accepted it, treat it as the source of truth and implement it directly.\n  Only do extra exploration if the plan is missing critical repo facts or you hit contradictions.\n- Use `explore` sub-agents just-in-time for missing repo context (paths/symbols/tests); don't spawn them by default.\n- Trust Explore sub-agent reports as authoritative for repo facts (paths/symbols/callsites). Do not redo the same investigation yourself; only re-check if the report is ambiguous or contradicts other evidence.\n- For correctness claims, an Explore sub-agent report counts as having read the referenced files.\n- Make minimal, correct, reviewable changes that match existing codebase patterns.\n- Prefer targeted commands and checks (typecheck/tests) when feasible.\n- Treat as a standing order: keep running checks and addressing failures until they pass or a blocker outside your control arises.\n",
  "explore": "---\nname: Explore\ndescription: Read-only exploration of repository, environment, web, etc. Useful for investigation before making changes.\nbase: exec\nui:\n  hidden: true\nsubagent:\n  runnable: true\n  skip_init_hook: true\n  append_prompt: |\n    You are an Explore sub-agent running inside a child workspace.\n\n    - Explore the repository to answer the prompt using read-only investigation.\n    - Return concise, actionable findings (paths, symbols, callsites, and facts).\n    - When you have a final answer, call agent_report exactly once.\n    - Do not call agent_report until you have completed the assigned task.\ntools:\n  # Remove editing and task tools from exec base (read-only agent)\n  remove:\n    - file_edit_.*\n    - task\n    - task_apply_git_patch\n    - task_.*\n    - agent_skill_read\n    - agent_skill_read_file\n---\n\nYou are in Explore mode (read-only).\n\n=== CRITICAL: READ-ONLY MODE - NO FILE MODIFICATIONS ===\n\n- You MUST NOT manually create, edit, delete, move, copy, or rename tracked files.\n- You MUST NOT stage/commit or otherwise modify git state.\n- You MUST NOT use redirect operators (>, >>) or heredocs to write to files.\n  - Pipes are allowed for processing, but MUST NOT be used to write to files (for example via `tee`).\n- You MUST NOT run commands that are explicitly about modifying the filesystem or repo state (rm, mv, cp, mkdir, touch, git add/commit, installs, etc.).\n- You MAY run verification commands (fmt-check/lint/typecheck/test) even if they create build artifacts/caches, but they MUST NOT modify tracked files.\n  - After running verification, check `git status --porcelain` and report if it is non-empty.\n- Prefer `file_read` for reading file contents (supports offset/limit paging).\n- Use bash for read-only operations (rg, ls, git diff/show/log, etc.) and verification commands.\n",
  "mux": "---\nname: Mux\ndescription: Configure mux global behavior (system workspace)\nui:\n  hidden: true\nsubagent:\n  runnable: false\ntools:\n  add:\n    - mux_global_agents_read\n    - mux_global_agents_write\n    - ask_user_question\n---\n\nYou are the **Mux system assistant**.\n\nYour job is to help the user configure mux globally by editing the mux-wide instructions file:\n\n- `~/.mux/AGENTS.md`\n\n## Safety rules\n\n- You do **not** have access to arbitrary filesystem tools.\n- You do **not** have access to project secrets.\n- Before writing `~/.mux/AGENTS.md`, you must:\n  1) Read the current file (`mux_global_agents_read`).\n  2) Propose the exact change (show the new content or a concise diff).\n  3) Ask for explicit confirmation via `ask_user_question`.\n  4) Only then call `mux_global_agents_write` with `confirm: true`.\n\nIf the user declines, do not write anything.\n",
  "orchestrator": "---\nname: Orchestrator\ndescription: Coordinate sub-agent implementation and apply patches\nbase: exec\nui:\n  requires:\n    - plan\nsubagent:\n  runnable: false\ntools:\n  add:\n    - ask_user_question\n  remove:\n    - propose_plan\n---\n\nYou are an internal Orchestrator agent running in Exec mode.\n\n**Mission:** coordinate implementation by delegating investigation + coding to sub-agents, then integrating their patches into this workspace.\n\nWhen a plan is present (default):\n\n- Treat the accepted plan as the source of truth. Its file paths, symbols, and structure were validated during planning \u2014 do not routinely spawn `explore` to re-confirm them. Exception: if the plan references stale paths or appears to have been authored/edited by the user without planner validation, a single targeted `explore` to sanity-check critical paths is acceptable.\n- Spawning `explore` to gather _additional_ context beyond what the plan provides is encouraged (e.g., checking whether a helper already exists, locating test files not mentioned in the plan, discovering existing patterns to match). This produces better `exec` task briefs.\n- Do not spawn `explore` just to verify that a planner-generated plan is correct \u2014 that is the planner's job, and the plan was accepted by the user.\n- Convert the plan into concrete `exec` subtasks and start delegation.\n\nWhat you are allowed to do directly in this workspace:\n\n- Spawn/await/manage sub-agent tasks (`task`, `task_await`, `task_list`, `task_terminate`).\n- Apply patches (`task_apply_git_patch`).\n- Resolve _small_ patch-apply conflicts locally (delegate large/confusing conflicts).\n- Coordinate targeted verification after integrating patches (prefer delegating verification runs to `explore` to keep this agent focused on coordination).\n\nHard rules (delegate-first):\n\n- Trust `explore` sub-agent reports as authoritative for repo facts (paths/symbols/callsites). Do not redo the same investigation yourself; only re-check if the report is ambiguous or contradicts other evidence.\n- For correctness claims, an `explore` sub-agent report counts as having read the referenced files.\n- **Do not do broad repo investigation here.** If you need context, spawn an `explore` sub-agent with a narrow prompt (keeps this agent focused on coordination).\n- **Do not implement features/bugfixes directly here.** Spawn an `exec` sub-agent and have it complete the work end-to-end.\n- **Never read or scan session storage.** This includes `~/.mux/sessions/**` and `~/.mux/sessions/subagent-patches/**`. Treat session storage as an internal implementation detail; do not shell out to locate patch artifacts on disk. Only use `task_apply_git_patch` to access patches.\n\nDelegation guide:\n\n- Use `explore` for narrowly-scoped read-only questions (confirm an assumption, locate a symbol/callsite, find relevant tests). Avoid \"scan the repo\" prompts.\n- Use `exec` for code changes.\n  - Provide a compact task brief (so the sub-agent can act without reading the full plan) with:\n    - Task: one sentence\n    - Background (why this matters): 1\u20133 bullets\n    - Scope / non-goals: what to change, and what not to change\n    - Starting points: relevant files/symbols/paths (from prior exploration)\n    - Acceptance: bullets / checks\n    - Deliverables: commits + verification commands to run\n    - Constraints:\n      - Do not expand scope.\n      - Prefer `explore` tasks for repo investigation (paths/symbols/tests/patterns) to preserve your context window for implementation.\n        Trust Explore reports as authoritative; do not re-verify unless ambiguous/contradictory.\n        If starting points + acceptance are already clear, skip initial explore and only explore when blocked.\n      - Create one or more git commits before `agent_report`.\n\nRecommended Orchestrator \u2192 Exec task brief template:\n\n- Task: <one sentence>\n- Background (why this matters):\n  - <bullet>\n- Scope / non-goals:\n  - Scope: <what to change>\n  - Non-goals: <explicitly out of scope>\n- Starting points: <paths / symbols / callsites>\n- Dependencies / assumptions:\n  - Assumes: <prereq patch(es) already applied in parent workspace, or required files/targets already exist>\n  - If unmet: stop and report back; do not expand scope to create prerequisites.\n- Acceptance: <bullets / checks>\n- Deliverables:\n  - Commits: <what to commit>\n  - Verification: <commands to run>\n- Constraints:\n  - Do not expand scope.\n  - Prefer `explore` tasks for repo investigation (paths/symbols/tests/patterns) to preserve your context window for implementation.\n    Trust Explore reports as authoritative; do not re-verify unless ambiguous/contradictory.\n    If starting points + acceptance are already clear, skip initial explore and only explore when blocked.\n  - Create one or more git commits before `agent_report`.\n\nDependency analysis (required before spawning `exec` tasks):\n\n- For each candidate subtask, write:\n  - Outputs: files/targets/artifacts introduced/renamed/generated\n  - Inputs / prerequisites (including for verification): what must already exist\n- A subtask is \"independent\" only if its patch can be applied + verified on the current parent workspace HEAD, without any other pending patch.\n- Parallelism is the default: maximize the size of each independent batch and run it in parallel.\n  Use the sequential protocol only when a subtask has a concrete prerequisite on another subtask's outputs.\n- If task B depends on outputs from task A:\n  - Do not spawn B until A has completed and A's patch is applied in the parent workspace.\n  - If the dependency chain is tight (download \u2192 generate \u2192 wire-up), prefer one `exec` task rather than splitting.\n\nExample dependency chain (schema download \u2192 generation):\n\n- Task A outputs: a new download target + new schema files.\n- Task B inputs: those schema files; verifies by running generation.\n- Therefore: run Task A (await + apply patch) before spawning Task B.\n\nPatch integration loop (default):\n\n1. Identify a batch of independent subtasks.\n2. Spawn one `exec` sub-agent task per subtask with `run_in_background: true`.\n3. Await the batch via `task_await`.\n4. For each successful `exec` task:\n   - Dry-run apply: `task_apply_git_patch` with `dry_run: true`.\n   - If dry-run succeeds, apply for real: `task_apply_git_patch` with `dry_run: false`.\n   - If dry-run fails, treat it as a patch conflict. Choose one:\n     - **Resolve locally (small/obvious conflicts only):**\n       1. Apply for real: `task_apply_git_patch` with `dry_run: false` (this may fail but will leave the repo in a `git am` conflict state).\n       2. Inspect with `git status` / `git diff`.\n       3. Resolve conflicts, then `git add -A`.\n       4. Finish with `git am --continue`.\n       5. If messy/unclear, abort and delegate: `git am --abort`.\n     - **Delegate reconciliation (preferred for large/confusing conflicts):**\n       - Spawn a dedicated `exec` task that replays the patch via `task_apply_git_patch`, resolves conflicts in its own workspace, commits the resolved result, and reports back with a new patch to apply cleanly.\n5. Verify + review:\n   - Spawn a narrow `explore` task to sanity-check the diff and run verification (`make fmt-check`, `make lint`, `make typecheck`, `make test`, etc.).\n   - PASS: summary-only (no long logs).\n   - FAIL: include the failing command + key error lines; then delegate a fix to `exec` and re-verify.\n\nSequential protocol (only for dependency chains):\n\n1. Spawn the prerequisite `exec` task with `run_in_background: false` (or spawn, then immediately `task_await`).\n2. Dry-run apply its patch (`dry_run: true`); then apply for real (`dry_run: false`). If dry-run fails, follow the conflict playbook above.\n3. Only after the patch is applied, spawn the dependent `exec` task.\n4. Repeat until the dependency chain is complete.\n\nNote: child workspaces are created at spawn time. Spawning dependents too early means they work from the wrong repo snapshot and get forced into scope expansion.\n\nKeep context minimal:\n\n- Do not request, paste, or restate large plans.\n- Prefer short, actionable prompts, but include enough context that the sub-agent does not need your plan file.\n  - Child workspaces do not automatically have access to the parent's plan file; summarize just the relevant slice or provide file pointers.\n- Prefer file paths/symbols over long prose.\n",
  "plan": '---\nname: Plan\ndescription: Create a plan before coding\nui:\n  color: var(--color-plan-mode)\nsubagent:\n  runnable: false\ntools:\n  add:\n    # Allow all tools by default (includes MCP tools which have dynamic names)\n    # Use tools.remove in child agents to restrict specific tools\n    - .*\n  remove:\n    # Plan should not apply sub-agent patches.\n    - task_apply_git_patch\n  # Note: file_edit_* tools ARE available but restricted to plan file only at runtime\n  # Note: task tools ARE enabled - Plan delegates to Explore sub-agents\n---\n\nYou are in Plan Mode.\n\n- Every response MUST produce or update a plan\u2014no exceptions.\n- Simple requests deserve simple plans; a straightforward task might only need a few bullet points. Match plan complexity to the problem.\n- Keep the plan scannable; put long rationale in `<details>/<summary>` blocks.\n- Plans must be **self-contained**: include enough context, goals, constraints, and the core "why" so a new assistant can implement without needing the prior chat.\n- When Plan Mode is requested, assume the user wants the actual completed plan; do not merely describe how you would devise one.\n\n## Investigation step (required)\n\nBefore proposing a plan, identify what you must verify and use the best available tools\n(`file_read` for local file contents, search, or user questions). Do not guess. Investigation can be\ndone directly; sub-agents are optional.\n\nPrefer `file_read` over `bash cat` when reading files (including the plan file): long bash output may\nbe compacted, which can hide the middle of a document. Use `file_read` with offset/limit to page\nthrough larger files.\n\n## Plan format\n\n- Context/Why: Briefly restate the request, goals, and the rationale or user impact so the\n  plan stands alone for a fresh implementer.\n- Evidence: List sources consulted (file paths, tool outputs, or user-provided info) and\n  why they are sufficient. If evidence is missing, still produce a minimal plan and add a\n  Questions section listing what you need to proceed.\n\n- Implementation details: List concrete edits (file paths + symbols) in the order you would implement them.\n  - Where it meaningfully reduces ambiguity, include **reasonably sized** code snippets (fenced code blocks) that show the intended shape of the change.\n  - Keep snippets focused (avoid whole-file dumps); elide unrelated context with `...`.\n\nDetailed plan mode instructions (plan file path, sub-agent delegation, propose_plan workflow) are provided separately.\n',
  "system1_bash": '---\nname: System1 Bash\ndescription: Fast bash-output filtering (internal)\nui:\n  hidden: true\nsubagent:\n  runnable: false\ntools:\n  add:\n    - system1_keep_ranges\n---\n\nYou are a fast bash-output filtering assistant.\n\nYou will be given:\n\n- `maxKeptLines` (budget)\n- `Display name` (optional): a short intent label for the command\n- `Bash script`\n- `Numbered output`\n\nGiven the numbered output, decide which lines to keep so the user sees the most relevant information.\n\nIMPORTANT:\n\n- You MUST call `system1_keep_ranges` exactly once.\n- Do NOT output markdown or prose. Only the tool call (with valid JSON arguments).\n\nRules:\n\n- Line numbers are 1-based indices into the numbered output.\n- Use the `Display name` and `Bash script` as intent hints.\n- If intent is exploration/listing/search (e.g. `ls`, `find`, `rg`, `grep`, `git status`), prioritize keeping\n  representative file paths/matches and any summary/counts (not just errors).\n- If intent is build/test/logs, prefer errors, stack traces, failing test summaries, and actionable warnings.\n- If the script already narrows output to a slice (e.g. `head`, `tail`, `sed -n` line ranges), avoid extra\n  denoising: prefer keeping most/all lines within the budget.\n- Never filter out git merge conflict markers (`<<<<<<<`, `|||||||`, `=======`, `>>>>>>>`). If the command is searching for these markers (e.g. `rg`/`grep`), do not keep only representative matches; keep all matches within the budget.\n- Prefer omitting tool-generated advisory blocks (especially git lines starting with `hint:`) that only suggest\n  next-step commands or point to docs/help. Keep the underlying `error:`/`fatal:`/`CONFLICT` lines, file paths,\n  and conflict markers instead.\n- Exception: keep `hint:` blocks when the script is explicitly searching for them (e.g. `rg \'^hint:\'`) or when\n  the hint is the only clue explaining a blocking state.\n- Prefer high signal density: keep ranges tight around important lines plus minimal surrounding context.\n- Merge adjacent/overlapping ranges only when the lines between are also informative. Do NOT add noise just\n  to reduce range count; it\'s OK to return many ranges when denoising (e.g., > 8).\n- Denoise aggressively: omit duplicate/redundant lines and repeated messages with the same meaning\n  (e.g., repeated progress, retries, or identical stack traces). If the same error repeats, keep only\n  the most informative instance plus minimal surrounding context.\n- If there are many similar warnings/errors, keep only a few representative examples (prefer those\n  with file paths/line numbers) plus any summary/count.\n- Always keep at least 1 line if any output exists.\n- Choose ranges that keep at most `maxKeptLines` lines total (the caller may truncate).\n\nExample:\n\n- Numbered output:\n  - 0001| building...\n  - 0002| ERROR: expected X, got Y\n  - 0003| at path/to/file.ts:12:3\n  - 0004| done\n- Tool call:\n  - system1_keep_ranges({"keep_ranges":[{"start":2,"end":3,"reason":"error"}]})\n'
};

// src/node/services/agentDefinitions/builtInAgentDefinitions.ts
var BUILT_IN_SOURCES2 = [
  { id: "exec", content: BUILTIN_AGENT_CONTENT.exec },
  { id: "plan", content: BUILTIN_AGENT_CONTENT.plan },
  { id: "ask", content: BUILTIN_AGENT_CONTENT.ask },
  { id: "compact", content: BUILTIN_AGENT_CONTENT.compact },
  { id: "explore", content: BUILTIN_AGENT_CONTENT.explore },
  { id: "system1_bash", content: BUILTIN_AGENT_CONTENT.system1_bash },
  { id: "mux", content: BUILTIN_AGENT_CONTENT.mux },
  { id: "orchestrator", content: BUILTIN_AGENT_CONTENT.orchestrator }
];
var cachedPackages2 = null;
function parseBuiltIns2() {
  return BUILT_IN_SOURCES2.map(({ id, content }) => {
    const parsed = parseAgentDefinitionMarkdown({
      content,
      byteSize: Buffer.byteLength(content, "utf8")
    });
    return {
      id,
      scope: "built-in",
      frontmatter: parsed.frontmatter,
      body: parsed.body.trim()
    };
  });
}
function getBuiltInAgentDefinitions() {
  cachedPackages2 ??= parseBuiltIns2();
  return cachedPackages2;
}

// src/node/services/agentDefinitions/agentDefinitionsService.ts
var MAX_INHERITANCE_DEPTH = 10;
function agentVisitKey(id, scope) {
  return `${id}:${scope}`;
}
function computeBaseSkipScope(baseId, currentId, currentScope) {
  return baseId === currentId ? currentScope : void 0;
}
var GLOBAL_AGENTS_ROOT = "~/.mux/agents";
function resolveUiSelectable(ui) {
  if (!ui) {
    return true;
  }
  if (typeof ui.hidden === "boolean") {
    return !ui.hidden;
  }
  if (typeof ui.selectable === "boolean") {
    return ui.selectable;
  }
  return true;
}
function resolveUiDisabled(ui) {
  return ui?.disabled === true;
}
function getDefaultAgentDefinitionsRoots(runtime, workspacePath) {
  if (!workspacePath) {
    throw new Error("getDefaultAgentDefinitionsRoots: workspacePath is required");
  }
  return {
    projectRoot: runtime.normalizePath(".mux/agents", workspacePath),
    globalRoot: GLOBAL_AGENTS_ROOT
  };
}
function formatError2(error) {
  return error instanceof Error ? error.message : String(error);
}
async function listAgentFilesFromLocalFs(root) {
  try {
    const entries = await fs13.readdir(root, { withFileTypes: true });
    return entries.filter((entry) => entry.isFile() && entry.name.toLowerCase().endsWith(".md")).map((entry) => entry.name);
  } catch {
    return [];
  }
}
async function listAgentFilesFromRuntime(runtime, root, options) {
  if (!options.cwd) {
    throw new Error("listAgentFilesFromRuntime: options.cwd is required");
  }
  const quotedRoot = shellQuote(root);
  const command = `if [ -d ${quotedRoot} ]; then find ${quotedRoot} -mindepth 1 -maxdepth 1 -type f -name '*.md' -exec basename {} \\; ; fi`;
  const result = await execBuffered(runtime, command, { cwd: options.cwd, timeout: 10 });
  if (result.exitCode !== 0) {
    log.warn(`Failed to read agents directory ${root}: ${result.stderr || result.stdout}`);
    return [];
  }
  return result.stdout.split("\n").map((line) => line.trim()).filter(Boolean);
}
function getAgentIdFromFilename(filename) {
  const parsed = path20.parse(filename);
  if (parsed.ext.toLowerCase() !== ".md") {
    return null;
  }
  const idRaw = parsed.name.trim().toLowerCase();
  const idParsed = AgentIdSchema.safeParse(idRaw);
  if (!idParsed.success) {
    return null;
  }
  return idParsed.data;
}
async function readAgentDescriptorFromFileWithDisabled(runtime, filePath, agentId, scope) {
  let stat4;
  try {
    stat4 = await runtime.stat(filePath);
  } catch {
    return null;
  }
  if (stat4.isDirectory) {
    return null;
  }
  const sizeValidation = validateFileSize(stat4);
  if (sizeValidation) {
    log.warn(`Skipping agent '${agentId}' (${scope}): ${sizeValidation.error}`);
    return null;
  }
  let content;
  try {
    content = await readFileString(runtime, filePath);
  } catch (err) {
    log.warn(`Failed to read agent definition ${filePath}: ${formatError2(err)}`);
    return null;
  }
  try {
    const parsed = parseAgentDefinitionMarkdown({ content, byteSize: stat4.size });
    const uiSelectable = resolveUiSelectable(parsed.frontmatter.ui);
    const uiColor = parsed.frontmatter.ui?.color;
    const subagentRunnable = parsed.frontmatter.subagent?.runnable ?? false;
    const disabled = resolveUiDisabled(parsed.frontmatter.ui);
    const descriptor = {
      id: agentId,
      scope,
      name: parsed.frontmatter.name,
      description: parsed.frontmatter.description,
      uiSelectable,
      uiColor,
      subagentRunnable,
      base: parsed.frontmatter.base,
      aiDefaults: parsed.frontmatter.ai,
      tools: parsed.frontmatter.tools
    };
    const validated = AgentDefinitionDescriptorSchema.safeParse(descriptor);
    if (!validated.success) {
      log.warn(`Invalid agent definition descriptor for ${agentId}: ${validated.error.message}`);
      return null;
    }
    return { descriptor: validated.data, disabled };
  } catch (err) {
    const message = err instanceof AgentDefinitionParseError ? err.message : formatError2(err);
    log.warn(`Skipping invalid agent definition '${agentId}' (${scope}): ${message}`);
    return null;
  }
}
async function discoverAgentDefinitions(runtime, workspacePath, options) {
  if (!workspacePath) {
    throw new Error("discoverAgentDefinitions: workspacePath is required");
  }
  const roots = options?.roots ?? getDefaultAgentDefinitionsRoots(runtime, workspacePath);
  const byId = /* @__PURE__ */ new Map();
  for (const pkg of getBuiltInAgentDefinitions()) {
    const uiSelectable = resolveUiSelectable(pkg.frontmatter.ui);
    const uiColor = pkg.frontmatter.ui?.color;
    const subagentRunnable = pkg.frontmatter.subagent?.runnable ?? false;
    const disabled = resolveUiDisabled(pkg.frontmatter.ui);
    byId.set(pkg.id, {
      descriptor: {
        id: pkg.id,
        scope: "built-in",
        name: pkg.frontmatter.name,
        description: pkg.frontmatter.description,
        uiSelectable,
        uiColor,
        subagentRunnable,
        base: pkg.frontmatter.base,
        aiDefaults: pkg.frontmatter.ai,
        tools: pkg.frontmatter.tools
      },
      disabled
    });
  }
  const scans = [
    { scope: "global", root: roots.globalRoot },
    { scope: "project", root: roots.projectRoot }
  ];
  for (const scan of scans) {
    let resolvedRoot;
    try {
      resolvedRoot = await runtime.resolvePath(scan.root);
    } catch (err) {
      log.warn(`Failed to resolve agents root ${scan.root}: ${formatError2(err)}`);
      continue;
    }
    const filenames = runtime instanceof SSHRuntime ? await listAgentFilesFromRuntime(runtime, resolvedRoot, { cwd: workspacePath }) : await listAgentFilesFromLocalFs(resolvedRoot);
    for (const filename of filenames) {
      const agentId = getAgentIdFromFilename(filename);
      if (!agentId) {
        log.warn(`Skipping invalid agent filename '${filename}' in ${resolvedRoot}`);
        continue;
      }
      const filePath = runtime.normalizePath(filename, resolvedRoot);
      const result = await readAgentDescriptorFromFileWithDisabled(
        runtime,
        filePath,
        agentId,
        scan.scope
      );
      if (!result) continue;
      byId.set(agentId, result);
    }
  }
  return Array.from(byId.values()).map((entry) => entry.descriptor).sort((a, b) => a.name.localeCompare(b.name));
}
var SCOPE_PRIORITY = ["project", "global", "built-in"];
async function readAgentDefinition(runtime, workspacePath, agentId, options) {
  if (!workspacePath) {
    throw new Error("readAgentDefinition: workspacePath is required");
  }
  const roots = options?.roots ?? getDefaultAgentDefinitionsRoots(runtime, workspacePath);
  const skipScopesAbove = options?.skipScopesAbove;
  const skipScopes = /* @__PURE__ */ new Set();
  if (skipScopesAbove) {
    const skipIndex = SCOPE_PRIORITY.indexOf(skipScopesAbove);
    if (skipIndex !== -1) {
      for (let i = 0; i <= skipIndex; i++) {
        skipScopes.add(SCOPE_PRIORITY[i]);
      }
    }
  }
  const candidates = [
    { scope: "project", root: roots.projectRoot },
    { scope: "global", root: roots.globalRoot }
  ];
  for (const candidate of candidates) {
    if (skipScopes.has(candidate.scope)) {
      continue;
    }
    let resolvedRoot;
    try {
      resolvedRoot = await runtime.resolvePath(candidate.root);
    } catch {
      continue;
    }
    const filePath = runtime.normalizePath(`${agentId}.md`, resolvedRoot);
    try {
      const stat4 = await runtime.stat(filePath);
      if (stat4.isDirectory) {
        continue;
      }
      const sizeValidation = validateFileSize(stat4);
      if (sizeValidation) {
        throw new Error(sizeValidation.error);
      }
      const content = await readFileString(runtime, filePath);
      const parsed = parseAgentDefinitionMarkdown({ content, byteSize: stat4.size });
      const pkg = {
        id: agentId,
        scope: candidate.scope,
        frontmatter: parsed.frontmatter,
        body: parsed.body
      };
      const validated = AgentDefinitionPackageSchema.safeParse(pkg);
      if (!validated.success) {
        throw new Error(
          `Invalid agent definition package for '${agentId}' (${candidate.scope}): ${validated.error.message}`
        );
      }
      return validated.data;
    } catch {
      continue;
    }
  }
  if (!skipScopes.has("built-in")) {
    const builtIn = getBuiltInAgentDefinitions().find((pkg) => pkg.id === agentId);
    if (builtIn) {
      const validated = AgentDefinitionPackageSchema.safeParse(builtIn);
      if (!validated.success) {
        throw new Error(
          `Invalid built-in agent definition '${agentId}': ${validated.error.message}`
        );
      }
      return validated.data;
    }
  }
  throw new Error(`Agent definition not found: ${agentId}`);
}
function formatZodIssues3(issues) {
  return issues.map((issue) => {
    const issuePath = issue.path.length > 0 ? issue.path.map((part) => String(part)).join(".") : "<root>";
    return `${issuePath}: ${issue.message}`;
  }).join("; ");
}
function isPlainObject2(value2) {
  if (!value2 || typeof value2 !== "object" || Array.isArray(value2)) {
    return false;
  }
  const proto2 = Object.getPrototypeOf(value2);
  return proto2 === Object.prototype || proto2 === null;
}
function deepMergeAgentFrontmatter(base, overlay, path24) {
  if (overlay === void 0) {
    return base;
  }
  const pathKey = path24.join(".");
  if (Array.isArray(base) && Array.isArray(overlay) && (pathKey === "tools.add" || pathKey === "tools.remove")) {
    return [...base, ...overlay];
  }
  if (isPlainObject2(base) && isPlainObject2(overlay)) {
    const merged = { ...base };
    for (const [key, overlayValue] of Object.entries(overlay)) {
      merged[key] = deepMergeAgentFrontmatter(merged[key], overlayValue, [...path24, key]);
    }
    return merged;
  }
  return overlay;
}
async function resolveAgentFrontmatter(runtime, workspacePath, agentId, options) {
  if (!workspacePath) {
    throw new Error("resolveAgentFrontmatter: workspacePath is required");
  }
  const visited = /* @__PURE__ */ new Set();
  function mergeSkipScopesAbove(a, b) {
    if (!a) {
      return b;
    }
    if (!b) {
      return a;
    }
    const aIndex = SCOPE_PRIORITY.indexOf(a);
    const bIndex = SCOPE_PRIORITY.indexOf(b);
    if (aIndex === -1 || bIndex === -1) {
      return a;
    }
    return aIndex > bIndex ? a : b;
  }
  async function resolve4(id, depth, skipScopesAbove) {
    if (depth > MAX_INHERITANCE_DEPTH) {
      throw new Error(
        `Agent inheritance depth exceeded for '${id}' (max: ${MAX_INHERITANCE_DEPTH})`
      );
    }
    const pkg = await readAgentDefinition(runtime, workspacePath, id, {
      roots: options?.roots,
      skipScopesAbove
    });
    const visitKey = agentVisitKey(pkg.id, pkg.scope);
    if (visited.has(visitKey)) {
      throw new Error(`Circular agent inheritance detected: ${pkg.id} (${pkg.scope})`);
    }
    visited.add(visitKey);
    const baseId = pkg.frontmatter.base;
    if (!baseId) {
      return pkg.frontmatter;
    }
    const baseFrontmatter = await resolve4(
      baseId,
      depth + 1,
      mergeSkipScopesAbove(skipScopesAbove, computeBaseSkipScope(baseId, id, pkg.scope))
    );
    const mergedRaw = deepMergeAgentFrontmatter(baseFrontmatter, pkg.frontmatter, []);
    const merged = AgentDefinitionFrontmatterSchema.safeParse(mergedRaw);
    if (!merged.success) {
      throw new Error(
        `Invalid merged frontmatter for '${id}': ${formatZodIssues3(merged.error.issues)}`
      );
    }
    return merged.data;
  }
  return resolve4(agentId, 0, options?.skipScopesAbove);
}

// src/node/services/agentDefinitions/agentEnablement.ts
var ALWAYS_ENABLED_AGENT_IDS = /* @__PURE__ */ new Set(["exec", "plan", "compact", "mux"]);
function isAgentDisabledByFrontmatter(frontmatter) {
  assert_default(frontmatter, "isAgentDisabledByFrontmatter: frontmatter is required");
  if (typeof frontmatter.disabled === "boolean") {
    return frontmatter.disabled;
  }
  if (typeof frontmatter.ui?.disabled === "boolean") {
    return frontmatter.ui.disabled;
  }
  return false;
}
function resolveAgentEnabledOverride(cfg, agentId) {
  assert_default(cfg, "resolveAgentEnabledOverride: cfg is required");
  assert_default(agentId.length > 0, "resolveAgentEnabledOverride: agentId must be non-empty");
  const entry = cfg.agentAiDefaults?.[agentId];
  return typeof entry?.enabled === "boolean" ? entry.enabled : void 0;
}
function isAgentEffectivelyDisabled(args2) {
  assert_default(args2, "isAgentEffectivelyDisabled: args is required");
  assert_default(args2.cfg, "isAgentEffectivelyDisabled: cfg is required");
  assert_default(args2.agentId.length > 0, "isAgentEffectivelyDisabled: agentId must be non-empty");
  assert_default(args2.resolvedFrontmatter, "isAgentEffectivelyDisabled: resolvedFrontmatter is required");
  if (ALWAYS_ENABLED_AGENT_IDS.has(args2.agentId)) {
    return false;
  }
  const override = resolveAgentEnabledOverride(args2.cfg, args2.agentId);
  if (override === true) {
    return false;
  }
  if (override === false) {
    return true;
  }
  return isAgentDisabledByFrontmatter(args2.resolvedFrontmatter);
}

// src/common/utils/archive.ts
function isWorkspaceArchived(archivedAt, unarchivedAt) {
  if (!archivedAt) return false;
  if (!unarchivedAt) return true;
  return new Date(archivedAt).getTime() > new Date(unarchivedAt).getTime();
}

// src/node/orpc/router.ts
import assert2 from "node:assert/strict";
import * as fsPromises6 from "fs/promises";
import * as path22 from "node:path";

// src/node/utils/messages/legacy.ts
function normalizeLegacyMuxMetadata(message) {
  const metadata = message.metadata;
  if (!metadata) return message;
  let normalized = { ...metadata };
  let changed = false;
  if (metadata.cmuxMetadata !== void 0) {
    const { cmuxMetadata, ...rest } = normalized;
    normalized = rest;
    if (!metadata.muxMetadata) {
      normalized.muxMetadata = cmuxMetadata;
    }
    changed = true;
  }
  if (metadata.idleCompacted === true) {
    const { idleCompacted, ...rest } = normalized;
    normalized = { ...rest, compacted: "idle" };
    changed = true;
  }
  return changed ? { ...message, metadata: normalized } : message;
}

// src/node/services/subagentTranscriptArtifacts.ts
var import_write_file_atomic2 = __toESM(require_lib());
import * as fsPromises5 from "fs/promises";
import * as path21 from "node:path";

// src/node/utils/concurrency/mutexMap.ts
var MutexMap = class {
  constructor() {
    this.locks = /* @__PURE__ */ new Map();
  }
  /**
   * Execute an operation with exclusive access per key
   * Operations for the same key are serialized (run one at a time)
   * Operations for different keys can run concurrently
   */
  async withLock(key, operation) {
    const previousLock = this.locks.get(key) ?? Promise.resolve();
    let releaseLock;
    const lockPromise = new Promise((resolve4) => {
      releaseLock = resolve4;
    });
    this.locks.set(key, lockPromise);
    try {
      await previousLock;
      return await operation();
    } finally {
      releaseLock();
      if (this.locks.get(key) === lockPromise) {
        this.locks.delete(key);
      }
    }
  }
};

// src/node/utils/concurrency/workspaceFileLocks.ts
var workspaceFileLocks = new MutexMap();

// src/node/services/subagentTranscriptArtifacts.ts
var SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION = 1;
var SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_NAME = "subagent-transcripts.json";
function getSubagentTranscriptArtifactsFilePath(workspaceSessionDir) {
  return path21.join(workspaceSessionDir, SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_NAME);
}
async function readSubagentTranscriptArtifactsFile(workspaceSessionDir) {
  try {
    const filePath = getSubagentTranscriptArtifactsFilePath(workspaceSessionDir);
    const raw = await fsPromises5.readFile(filePath, "utf-8");
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") {
      return { version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION, artifactsByChildTaskId: {} };
    }
    const obj = parsed;
    if (obj.version !== SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION) {
      return { version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION, artifactsByChildTaskId: {} };
    }
    if (!obj.artifactsByChildTaskId || typeof obj.artifactsByChildTaskId !== "object") {
      return { version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION, artifactsByChildTaskId: {} };
    }
    return {
      version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION,
      artifactsByChildTaskId: obj.artifactsByChildTaskId
    };
  } catch (error) {
    if (error && typeof error === "object" && "code" in error && error.code === "ENOENT") {
      return { version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION, artifactsByChildTaskId: {} };
    }
    log.error("Failed to read subagent transcript artifacts file", { error });
    return { version: SUBAGENT_TRANSCRIPT_ARTIFACTS_FILE_VERSION, artifactsByChildTaskId: {} };
  }
}

// src/node/orpc/router.ts
async function resolveAgentDiscoveryContext(context2, input) {
  if (!input.projectPath && !input.workspaceId) {
    throw new Error("Either projectPath or workspaceId must be provided");
  }
  if (input.workspaceId) {
    const metadataResult = await context2.aiService.getWorkspaceMetadata(input.workspaceId);
    if (!metadataResult.success) {
      throw new Error(metadataResult.error);
    }
    const metadata = metadataResult.data;
    const runtime2 = createRuntimeForWorkspace(metadata);
    const discoveryPath = input.disableWorkspaceAgents ? metadata.projectPath : runtime2.getWorkspacePath(metadata.projectPath, metadata.name);
    return { runtime: runtime2, discoveryPath, metadata };
  }
  const runtime = createRuntime(
    { type: "local", srcBaseDir: context2.config.srcDir },
    { projectPath: input.projectPath }
  );
  return { runtime, discoveryPath: input.projectPath };
}
function isErrnoWithCode(error, code) {
  return Boolean(error && typeof error === "object" && "code" in error && error.code === code);
}
function isPathInsideDir(dirPath, filePath) {
  const resolvedDir = path22.resolve(dirPath);
  const resolvedFile = path22.resolve(filePath);
  const relative2 = path22.relative(resolvedDir, resolvedFile);
  return relative2 === "" || !relative2.startsWith("..") && !path22.isAbsolute(relative2);
}
function normalizeMuxMessageFromDisk(value2) {
  if (!value2 || typeof value2 !== "object") {
    return null;
  }
  const obj = value2;
  if (typeof obj.createdAt === "string") {
    const parsed = new Date(obj.createdAt);
    if (Number.isFinite(parsed.getTime())) {
      obj.createdAt = parsed;
    } else {
      delete obj.createdAt;
    }
  }
  return normalizeLegacyMuxMetadata(value2);
}
async function readChatJsonlAllowMissing(params) {
  try {
    const data = await fsPromises6.readFile(params.chatPath, "utf-8");
    const lines = data.split("\n").filter((line) => line.trim());
    const messages = [];
    for (let i = 0; i < lines.length; i++) {
      try {
        const parsed = JSON.parse(lines[i]);
        const message = normalizeMuxMessageFromDisk(parsed);
        if (message) {
          messages.push(message);
        }
      } catch (parseError) {
        log.warn(
          `Skipping malformed JSON at line ${i + 1} in ${params.logLabel}:`,
          parseError instanceof Error ? parseError.message : String(parseError),
          "\nLine content:",
          lines[i].substring(0, 100) + (lines[i].length > 100 ? "..." : "")
        );
      }
    }
    return messages;
  } catch (error) {
    if (isErrnoWithCode(error, "ENOENT")) {
      return null;
    }
    throw error;
  }
}
async function readPartialJsonBestEffort(partialPath) {
  try {
    const raw = await fsPromises6.readFile(partialPath, "utf-8");
    const parsed = JSON.parse(raw);
    return normalizeMuxMessageFromDisk(parsed);
  } catch (error) {
    if (isErrnoWithCode(error, "ENOENT")) {
      return null;
    }
    log.warn("Failed to read partial.json for transcript", {
      partialPath,
      error: error instanceof Error ? error.message : String(error)
    });
    return null;
  }
}
function mergePartialIntoHistory(messages, partial) {
  if (!partial) {
    return messages;
  }
  const partialSeq = partial.metadata?.historySequence;
  if (partialSeq === void 0) {
    return [...messages, partial];
  }
  const existingIndex = messages.findIndex((m) => m.metadata?.historySequence === partialSeq);
  if (existingIndex >= 0) {
    const existing = messages[existingIndex];
    const shouldReplace = (partial.parts?.length ?? 0) > (existing.parts?.length ?? 0);
    if (!shouldReplace) {
      return messages;
    }
    const next2 = [...messages];
    next2[existingIndex] = partial;
    return next2;
  }
  const insertIndex = messages.findIndex((m) => {
    const seq = m.metadata?.historySequence;
    return typeof seq === "number" && seq > partialSeq;
  });
  if (insertIndex < 0) {
    return [...messages, partial];
  }
  const next = [...messages];
  next.splice(insertIndex, 0, partial);
  return next;
}
async function findSubagentTranscriptEntryByScanningSessions(params) {
  let best = null;
  let dirents = [];
  try {
    dirents = await fsPromises6.readdir(params.sessionsDir, { withFileTypes: true });
  } catch (error) {
    if (isErrnoWithCode(error, "ENOENT")) {
      return null;
    }
    throw error;
  }
  for (const dirent of dirents) {
    if (!dirent.isDirectory()) {
      continue;
    }
    const workspaceId = dirent.name;
    if (!workspaceId) {
      continue;
    }
    const sessionDir = path22.join(params.sessionsDir, workspaceId);
    const artifacts = await readSubagentTranscriptArtifactsFile(sessionDir);
    const entry = artifacts.artifactsByChildTaskId[params.taskId];
    if (!entry) {
      continue;
    }
    if (!best || entry.updatedAtMs > best.entry.updatedAtMs) {
      best = { workspaceId, entry };
    }
  }
  return best;
}
var router = (authToken) => {
  const t = os.$context().use(createAuthMiddleware(authToken));
  return t.router({
    tokenizer: {
      countTokens: t.input(tokenizer.countTokens.input).output(tokenizer.countTokens.output).handler(async ({ context: context2, input }) => {
        return context2.tokenizerService.countTokens(input.model, input.text);
      }),
      countTokensBatch: t.input(tokenizer.countTokensBatch.input).output(tokenizer.countTokensBatch.output).handler(async ({ context: context2, input }) => {
        return context2.tokenizerService.countTokensBatch(input.model, input.texts);
      }),
      calculateStats: t.input(tokenizer.calculateStats.input).output(tokenizer.calculateStats.output).handler(async ({ context: context2, input }) => {
        return context2.tokenizerService.calculateStats(
          input.workspaceId,
          input.messages,
          input.model
        );
      })
    },
    splashScreens: {
      getViewedSplashScreens: t.input(splashScreens.getViewedSplashScreens.input).output(splashScreens.getViewedSplashScreens.output).handler(({ context: context2 }) => {
        const config2 = context2.config.loadConfigOrDefault();
        return config2.viewedSplashScreens ?? [];
      }),
      markSplashScreenViewed: t.input(splashScreens.markSplashScreenViewed.input).output(splashScreens.markSplashScreenViewed.output).handler(async ({ context: context2, input }) => {
        await context2.config.editConfig((config2) => {
          const viewed = config2.viewedSplashScreens ?? [];
          if (!viewed.includes(input.splashId)) {
            viewed.push(input.splashId);
          }
          return {
            ...config2,
            viewedSplashScreens: viewed
          };
        });
      })
    },
    server: {
      getLaunchProject: t.input(server.getLaunchProject.input).output(server.getLaunchProject.output).handler(async ({ context: context2 }) => {
        return context2.serverService.getLaunchProject();
      }),
      getSshHost: t.input(server.getSshHost.input).output(server.getSshHost.output).handler(({ context: context2 }) => {
        return context2.serverService.getSshHost() ?? null;
      }),
      setSshHost: t.input(server.setSshHost.input).output(server.setSshHost.output).handler(async ({ context: context2, input }) => {
        context2.serverService.setSshHost(input.sshHost ?? void 0);
        await context2.config.editConfig((config2) => ({
          ...config2,
          serverSshHost: input.sshHost ?? void 0
        }));
      }),
      getApiServerStatus: t.input(server.getApiServerStatus.input).output(server.getApiServerStatus.output).handler(({ context: context2 }) => {
        const config2 = context2.config.loadConfigOrDefault();
        const configuredBindHost = config2.apiServerBindHost ?? null;
        const configuredServeWebUi = config2.apiServerServeWebUi === true;
        const configuredPort = config2.apiServerPort ?? null;
        const info = context2.serverService.getServerInfo();
        return {
          running: info !== null,
          baseUrl: info?.baseUrl ?? null,
          bindHost: info?.bindHost ?? null,
          port: info?.port ?? null,
          networkBaseUrls: info?.networkBaseUrls ?? [],
          token: info?.token ?? null,
          configuredBindHost,
          configuredPort,
          configuredServeWebUi
        };
      }),
      setApiServerSettings: t.input(server.setApiServerSettings.input).output(server.setApiServerSettings.output).handler(async ({ context: context2, input }) => {
        const prevConfig = context2.config.loadConfigOrDefault();
        const prevBindHost = prevConfig.apiServerBindHost;
        const prevServeWebUi = prevConfig.apiServerServeWebUi;
        const prevPort = prevConfig.apiServerPort;
        const wasRunning = context2.serverService.isServerRunning();
        const bindHost = input.bindHost?.trim() ? input.bindHost.trim() : void 0;
        const serveWebUi = input.serveWebUi === void 0 ? prevServeWebUi : input.serveWebUi === true ? true : void 0;
        const port = input.port === null || input.port === 0 ? void 0 : input.port;
        if (wasRunning) {
          await context2.serverService.stopServer();
        }
        await context2.config.editConfig((config2) => {
          config2.apiServerServeWebUi = serveWebUi;
          config2.apiServerBindHost = bindHost;
          config2.apiServerPort = port;
          return config2;
        });
        if (process.env.MUX_NO_API_SERVER !== "1") {
          const authToken2 = context2.serverService.getApiAuthToken();
          if (!authToken2) {
            throw new Error("API server auth token not initialized");
          }
          const envPort = process.env.MUX_SERVER_PORT ? Number.parseInt(process.env.MUX_SERVER_PORT, 10) : void 0;
          const portToUse = envPort ?? port ?? 0;
          const hostToUse = bindHost ?? "127.0.0.1";
          try {
            await context2.serverService.startServer({
              muxHome: context2.config.rootDir,
              context: context2,
              authToken: authToken2,
              serveStatic: serveWebUi === true,
              host: hostToUse,
              port: portToUse
            });
          } catch (error) {
            await context2.config.editConfig((config2) => {
              config2.apiServerServeWebUi = prevServeWebUi;
              config2.apiServerBindHost = prevBindHost;
              config2.apiServerPort = prevPort;
              return config2;
            });
            if (wasRunning) {
              const portToRestore = envPort ?? prevPort ?? 0;
              const hostToRestore = prevBindHost ?? "127.0.0.1";
              try {
                await context2.serverService.startServer({
                  muxHome: context2.config.rootDir,
                  context: context2,
                  serveStatic: prevServeWebUi === true,
                  authToken: authToken2,
                  host: hostToRestore,
                  port: portToRestore
                });
              } catch {
              }
            }
            throw error;
          }
        }
        const nextConfig = context2.config.loadConfigOrDefault();
        const configuredBindHost = nextConfig.apiServerBindHost ?? null;
        const configuredServeWebUi = nextConfig.apiServerServeWebUi === true;
        const configuredPort = nextConfig.apiServerPort ?? null;
        const info = context2.serverService.getServerInfo();
        return {
          running: info !== null,
          baseUrl: info?.baseUrl ?? null,
          bindHost: info?.bindHost ?? null,
          port: info?.port ?? null,
          networkBaseUrls: info?.networkBaseUrls ?? [],
          token: info?.token ?? null,
          configuredBindHost,
          configuredPort,
          configuredServeWebUi
        };
      })
    },
    features: {
      getStatsTabState: t.input(features.getStatsTabState.input).output(features.getStatsTabState.output).handler(async ({ context: context2 }) => {
        const state = await context2.featureFlagService.getStatsTabState();
        context2.sessionTimingService.setStatsTabState(state);
        return state;
      }),
      setStatsTabOverride: t.input(features.setStatsTabOverride.input).output(features.setStatsTabOverride.output).handler(async ({ context: context2, input }) => {
        const state = await context2.featureFlagService.setStatsTabOverride(input.override);
        context2.sessionTimingService.setStatsTabState(state);
        return state;
      })
    },
    iconTheme: {
      getActiveThemeId: t.input(iconTheme.getActiveThemeId.input).output(iconTheme.getActiveThemeId.output).handler(async ({ context: context2 }) => {
        return context2.iconThemeService.getActiveThemeId();
      }),
      setActiveTheme: t.input(iconTheme.setActiveTheme.input).output(iconTheme.setActiveTheme.output).handler(async ({ context: context2, input }) => {
        await context2.iconThemeService.setActiveTheme(input.themeId);
      }),
      getInstalledThemes: t.input(iconTheme.getInstalledThemes.input).output(iconTheme.getInstalledThemes.output).handler(async ({ context: context2 }) => {
        return context2.iconThemeService.getInstalledThemes();
      }),
      deleteTheme: t.input(iconTheme.deleteTheme.input).output(iconTheme.deleteTheme.output).handler(async ({ context: context2, input }) => {
        return context2.iconThemeService.deleteTheme(input.themeId);
      }),
      getActiveThemeDocument: t.input(iconTheme.getActiveThemeDocument.input).output(iconTheme.getActiveThemeDocument.output).handler(async ({ context: context2 }) => {
        return context2.iconThemeService.getActiveThemeDocument();
      }),
      importVsix: t.input(iconTheme.importVsix.input).output(iconTheme.importVsix.output).handler(async ({ context: context2, input }) => {
        return context2.iconThemeService.importVsix(input.vsixBase64);
      }),
      getIconFile: t.input(iconTheme.getIconFile.input).output(iconTheme.getIconFile.output).handler(async ({ context: context2, input }) => {
        return context2.iconThemeService.getIconFile(input.themeId, input.iconPath);
      })
    },
    config: {
      getConfig: t.input(config.getConfig.input).output(config.getConfig.output).handler(({ context: context2 }) => {
        const config2 = context2.config.loadConfigOrDefault();
        const muxGovernorUrl = config2.muxGovernorUrl ?? null;
        const muxGovernorEnrolled = Boolean(config2.muxGovernorUrl && config2.muxGovernorToken);
        return {
          taskSettings: config2.taskSettings ?? DEFAULT_TASK_SETTINGS,
          muxGatewayEnabled: config2.muxGatewayEnabled,
          muxGatewayModels: config2.muxGatewayModels,
          defaultModel: config2.defaultModel,
          hiddenModels: config2.hiddenModels,
          preferredCompactionModel: config2.preferredCompactionModel,
          stopCoderWorkspaceOnArchive: config2.stopCoderWorkspaceOnArchive !== false,
          agentAiDefaults: config2.agentAiDefaults ?? {},
          // Legacy fields (downgrade compatibility)
          subagentAiDefaults: config2.subagentAiDefaults ?? {},
          // Mux Governor enrollment status (safe fields only - token never exposed)
          muxGovernorUrl,
          muxGovernorEnrolled
        };
      }),
      updateAgentAiDefaults: t.input(config.updateAgentAiDefaults.input).output(config.updateAgentAiDefaults.output).handler(async ({ context: context2, input }) => {
        await context2.config.editConfig((config2) => {
          const normalized = normalizeAgentAiDefaults(input.agentAiDefaults);
          const legacySubagentDefaultsRaw = {};
          for (const [agentType, entry] of Object.entries(normalized)) {
            if (agentType === "plan" || agentType === "exec" || agentType === "compact") {
              continue;
            }
            legacySubagentDefaultsRaw[agentType] = entry;
          }
          const legacySubagentDefaults = normalizeSubagentAiDefaults(legacySubagentDefaultsRaw);
          return {
            ...config2,
            agentAiDefaults: Object.keys(normalized).length > 0 ? normalized : void 0,
            // Legacy fields (downgrade compatibility)
            subagentAiDefaults: Object.keys(legacySubagentDefaults).length > 0 ? legacySubagentDefaults : void 0
          };
        });
      }),
      updateMuxGatewayPrefs: t.input(config.updateMuxGatewayPrefs.input).output(config.updateMuxGatewayPrefs.output).handler(async ({ context: context2, input }) => {
        await context2.config.editConfig((config2) => {
          const nextModels = Array.from(new Set(input.muxGatewayModels));
          nextModels.sort();
          return {
            ...config2,
            muxGatewayEnabled: input.muxGatewayEnabled ? void 0 : false,
            muxGatewayModels: nextModels.length > 0 ? nextModels : void 0
          };
        });
      }),
      updateModelPreferences: t.input(config.updateModelPreferences.input).output(config.updateModelPreferences.output).handler(async ({ context: context2, input }) => {
        const normalizeModelString = (value2) => {
          const trimmed = value2.trim();
          if (!trimmed) {
            return void 0;
          }
          if (trimmed.startsWith("mux-gateway:") && !trimmed.includes("/")) {
            return void 0;
          }
          const normalized = normalizeGatewayModel(trimmed);
          if (!isValidModelFormat(normalized)) {
            return void 0;
          }
          return normalized;
        };
        await context2.config.editConfig((config2) => {
          const next = { ...config2 };
          if (input.defaultModel !== void 0) {
            next.defaultModel = normalizeModelString(input.defaultModel);
          }
          if (input.hiddenModels !== void 0) {
            const seen = /* @__PURE__ */ new Set();
            const normalizedHidden = [];
            for (const modelString of input.hiddenModels) {
              const normalized = normalizeModelString(modelString);
              if (!normalized) continue;
              if (seen.has(normalized)) continue;
              seen.add(normalized);
              normalizedHidden.push(normalized);
            }
            next.hiddenModels = normalizedHidden;
          }
          if (input.preferredCompactionModel !== void 0) {
            next.preferredCompactionModel = normalizeModelString(input.preferredCompactionModel);
          }
          return next;
        });
      }),
      updateCoderPrefs: t.input(config.updateCoderPrefs.input).output(config.updateCoderPrefs.output).handler(async ({ context: context2, input }) => {
        await context2.config.editConfig((config2) => {
          return {
            ...config2,
            // Default ON: store `false` only.
            stopCoderWorkspaceOnArchive: input.stopCoderWorkspaceOnArchive ? void 0 : false
          };
        });
      }),
      saveConfig: t.input(config.saveConfig.input).output(config.saveConfig.output).handler(async ({ context: context2, input }) => {
        await context2.config.editConfig((config2) => {
          const normalizedTaskSettings = normalizeTaskSettings(input.taskSettings);
          const result = { ...config2, taskSettings: normalizedTaskSettings };
          if (input.agentAiDefaults !== void 0) {
            const normalized = normalizeAgentAiDefaults(input.agentAiDefaults);
            result.agentAiDefaults = Object.keys(normalized).length > 0 ? normalized : void 0;
            if (input.subagentAiDefaults === void 0) {
              const legacySubagentDefaultsRaw = {};
              for (const [agentType, entry] of Object.entries(normalized)) {
                if (agentType === "plan" || agentType === "exec" || agentType === "compact") {
                  continue;
                }
                legacySubagentDefaultsRaw[agentType] = entry;
              }
              const legacySubagentDefaults = normalizeSubagentAiDefaults(legacySubagentDefaultsRaw);
              result.subagentAiDefaults = Object.keys(legacySubagentDefaults).length > 0 ? legacySubagentDefaults : void 0;
            }
          }
          if (input.subagentAiDefaults !== void 0) {
            const normalizedDefaults = normalizeSubagentAiDefaults(input.subagentAiDefaults);
            result.subagentAiDefaults = Object.keys(normalizedDefaults).length > 0 ? normalizedDefaults : void 0;
            const previousLegacy = config2.subagentAiDefaults ?? {};
            const nextAgentAiDefaults = {
              ...result.agentAiDefaults ?? config2.agentAiDefaults ?? {}
            };
            for (const legacyAgentType of Object.keys(previousLegacy)) {
              if (legacyAgentType === "plan" || legacyAgentType === "exec" || legacyAgentType === "compact") {
                continue;
              }
              if (!(legacyAgentType in normalizedDefaults)) {
                delete nextAgentAiDefaults[legacyAgentType];
              }
            }
            for (const [agentType, entry] of Object.entries(normalizedDefaults)) {
              if (agentType === "plan" || agentType === "exec" || agentType === "compact")
                continue;
              nextAgentAiDefaults[agentType] = entry;
            }
            const normalizedAgent = normalizeAgentAiDefaults(nextAgentAiDefaults);
            result.agentAiDefaults = Object.keys(normalizedAgent).length > 0 ? normalizedAgent : void 0;
          }
          return result;
        });
        await context2.taskService.maybeStartQueuedTasks();
      }),
      unenrollMuxGovernor: t.input(config.unenrollMuxGovernor.input).output(config.unenrollMuxGovernor.output).handler(async ({ context: context2 }) => {
        await context2.config.editConfig((config2) => {
          const { muxGovernorUrl: _url, muxGovernorToken: _token, ...rest } = config2;
          return rest;
        });
        await context2.policyService.refreshNow();
      })
    },
    uiLayouts: {
      getAll: t.input(uiLayouts.getAll.input).output(uiLayouts.getAll.output).handler(({ context: context2 }) => {
        const config2 = context2.config.loadConfigOrDefault();
        return config2.layoutPresets ?? DEFAULT_LAYOUT_PRESETS_CONFIG;
      }),
      saveAll: t.input(uiLayouts.saveAll.input).output(uiLayouts.saveAll.output).handler(async ({ context: context2, input }) => {
        await context2.config.editConfig((config2) => {
          const normalized = normalizeLayoutPresetsConfig(input.layoutPresets);
          return {
            ...config2,
            layoutPresets: isLayoutPresetsConfigEmpty(normalized) ? void 0 : normalized
          };
        });
      })
    },
    agents: {
      list: t.input(agents.list.input).output(agents.list.output).handler(async ({ context: context2, input }) => {
        if (input.workspaceId) {
          await context2.aiService.waitForInit(input.workspaceId);
        }
        const { runtime, discoveryPath, metadata } = await resolveAgentDiscoveryContext(
          context2,
          input
        );
        let planReady = false;
        if (input.workspaceId && metadata) {
          try {
            planReady = await hasNonEmptyPlanFile(
              runtime,
              metadata.name,
              metadata.projectName,
              input.workspaceId
            );
          } catch {
            planReady = false;
          }
        }
        const descriptors = await discoverAgentDefinitions(runtime, discoveryPath);
        const cfg = context2.config.loadConfigOrDefault();
        const resolved = await Promise.all(
          descriptors.map(async (descriptor) => {
            try {
              const resolvedFrontmatter = await resolveAgentFrontmatter(
                runtime,
                discoveryPath,
                descriptor.id
              );
              const effectivelyDisabled = isAgentEffectivelyDisabled({
                cfg,
                agentId: descriptor.id,
                resolvedFrontmatter
              });
              if (effectivelyDisabled && input.includeDisabled !== true) {
                return null;
              }
              const uiSelectableBase = typeof resolvedFrontmatter.ui?.hidden === "boolean" ? !resolvedFrontmatter.ui.hidden : typeof resolvedFrontmatter.ui?.selectable === "boolean" ? resolvedFrontmatter.ui.selectable : true;
              const requiresPlan = resolvedFrontmatter.ui?.requires?.includes("plan") ?? false;
              const uiSelectable = requiresPlan && !planReady ? false : uiSelectableBase;
              return {
                ...descriptor,
                name: resolvedFrontmatter.name,
                description: resolvedFrontmatter.description,
                uiSelectable,
                uiColor: resolvedFrontmatter.ui?.color,
                subagentRunnable: resolvedFrontmatter.subagent?.runnable ?? false,
                base: resolvedFrontmatter.base,
                aiDefaults: resolvedFrontmatter.ai,
                tools: resolvedFrontmatter.tools
              };
            } catch {
              return descriptor;
            }
          })
        );
        return resolved.filter(
          (descriptor) => Boolean(descriptor)
        );
      }),
      get: t.input(agents.get.input).output(agents.get.output).handler(async ({ context: context2, input }) => {
        if (input.workspaceId) {
          await context2.aiService.waitForInit(input.workspaceId);
        }
        const { runtime, discoveryPath } = await resolveAgentDiscoveryContext(context2, input);
        return readAgentDefinition(runtime, discoveryPath, input.agentId);
      })
    },
    agentSkills: {
      list: t.input(agentSkills.list.input).output(agentSkills.list.output).handler(async ({ context: context2, input }) => {
        if (input.workspaceId) {
          await context2.aiService.waitForInit(input.workspaceId);
        }
        const { runtime, discoveryPath } = await resolveAgentDiscoveryContext(context2, input);
        return discoverAgentSkills(runtime, discoveryPath);
      }),
      listDiagnostics: t.input(agentSkills.listDiagnostics.input).output(agentSkills.listDiagnostics.output).handler(async ({ context: context2, input }) => {
        if (input.workspaceId) {
          await context2.aiService.waitForInit(input.workspaceId);
        }
        const { runtime, discoveryPath } = await resolveAgentDiscoveryContext(context2, input);
        return discoverAgentSkillsDiagnostics(runtime, discoveryPath);
      }),
      get: t.input(agentSkills.get.input).output(agentSkills.get.output).handler(async ({ context: context2, input }) => {
        if (input.workspaceId) {
          await context2.aiService.waitForInit(input.workspaceId);
        }
        const { runtime, discoveryPath } = await resolveAgentDiscoveryContext(context2, input);
        const result = await readAgentSkill(runtime, discoveryPath, input.skillName);
        return result.package;
      })
    },
    providers: {
      list: t.input(providers.list.input).output(providers.list.output).handler(({ context: context2 }) => context2.providerService.list()),
      getConfig: t.input(providers.getConfig.input).output(providers.getConfig.output).handler(({ context: context2 }) => context2.providerService.getConfig()),
      setProviderConfig: t.input(providers.setProviderConfig.input).output(providers.setProviderConfig.output).handler(
        ({ context: context2, input }) => context2.providerService.setConfig(input.provider, input.keyPath, input.value)
      ),
      setModels: t.input(providers.setModels.input).output(providers.setModels.output).handler(
        ({ context: context2, input }) => context2.providerService.setModels(input.provider, input.models)
      ),
      setModelMetadata: t.input(providers.setModelMetadata.input).output(providers.setModelMetadata.output).handler(
        ({ context: context2, input }) => context2.providerService.setModelMetadata(input.provider, input.modelId, input.metadata)
      ),
      onConfigChanged: t.input(providers.onConfigChanged.input).output(providers.onConfigChanged.output).handler(async function* ({ context: context2, signal }) {
        let resolveNext = null;
        let pendingNotification = false;
        let ended = false;
        const push = () => {
          if (ended) return;
          if (resolveNext) {
            const resolve4 = resolveNext;
            resolveNext = null;
            resolve4();
          } else {
            pendingNotification = true;
          }
        };
        const unsubscribe = context2.providerService.onConfigChanged(push);
        const onAbort = () => {
          if (ended) return;
          ended = true;
          if (resolveNext) {
            const resolve4 = resolveNext;
            resolveNext = null;
            resolve4();
          } else {
            pendingNotification = true;
          }
        };
        if (signal) {
          if (signal.aborted) {
            onAbort();
          } else {
            signal.addEventListener("abort", onAbort, { once: true });
          }
        }
        try {
          while (!ended) {
            if (pendingNotification) {
              pendingNotification = false;
              if (ended) break;
              yield void 0;
              continue;
            }
            await new Promise((resolve4) => {
              resolveNext = resolve4;
            });
            if (ended) break;
            yield void 0;
          }
        } finally {
          ended = true;
          signal?.removeEventListener("abort", onAbort);
          unsubscribe();
        }
      })
    },
    policy: {
      get: t.input(policy.get.input).output(policy.get.output).handler(({ context: context2 }) => context2.policyService.getPolicyGetResponse()),
      onChanged: t.input(policy.onChanged.input).output(policy.onChanged.output).handler(async function* ({ context: context2, signal }) {
        let resolveNext = null;
        let pendingNotification = false;
        let ended = false;
        const push = () => {
          if (ended) return;
          if (resolveNext) {
            const resolve4 = resolveNext;
            resolveNext = null;
            resolve4();
          } else {
            pendingNotification = true;
          }
        };
        const unsubscribe = context2.policyService.onPolicyChanged(push);
        const onAbort = () => {
          if (ended) return;
          ended = true;
          if (resolveNext) {
            const resolve4 = resolveNext;
            resolveNext = null;
            resolve4();
          } else {
            pendingNotification = true;
          }
        };
        if (signal) {
          if (signal.aborted) {
            onAbort();
          } else {
            signal.addEventListener("abort", onAbort, { once: true });
          }
        }
        try {
          while (!ended) {
            if (pendingNotification) {
              pendingNotification = false;
              if (ended) break;
              yield void 0;
              continue;
            }
            await new Promise((resolve4) => {
              resolveNext = resolve4;
            });
            if (ended) break;
            yield void 0;
          }
        } finally {
          ended = true;
          signal?.removeEventListener("abort", onAbort);
          unsubscribe();
        }
      }),
      refreshNow: t.input(policy.refreshNow.input).output(policy.refreshNow.output).handler(async ({ context: context2 }) => {
        const result = await context2.policyService.refreshNow();
        if (!result.success) {
          return Err(result.error);
        }
        return Ok(context2.policyService.getPolicyGetResponse());
      })
    },
    muxGateway: {
      getAccountStatus: t.input(muxGateway.getAccountStatus.input).output(muxGateway.getAccountStatus.output).handler(async ({ context: context2 }) => {
        const providersConfig = context2.config.loadProvidersConfig() ?? {};
        const muxConfig = providersConfig["mux-gateway"] ?? {};
        const creds = resolveProviderCredentials("mux-gateway", {
          couponCode: typeof muxConfig.couponCode === "string" ? muxConfig.couponCode : void 0,
          voucher: typeof muxConfig.voucher === "string" ? muxConfig.voucher : void 0
        });
        if (!creds.isConfigured || !creds.couponCode) {
          return Err("Mux Gateway is not logged in");
        }
        let response;
        try {
          response = await fetch(`${MUX_GATEWAY_ORIGIN}/api/v1/balance`, {
            headers: {
              Accept: "application/json",
              Authorization: `Bearer ${creds.couponCode}`
            }
          });
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          return Err(`Mux Gateway balance request failed: ${message}`);
        }
        if (response.status === 401) {
          try {
            context2.providerService.setConfig("mux-gateway", ["couponCode"], "");
            context2.providerService.setConfig("mux-gateway", ["voucher"], "");
          } catch {
          }
          return Err(MUX_GATEWAY_SESSION_EXPIRED_MESSAGE);
        }
        if (!response.ok) {
          let body = "";
          try {
            body = await response.text();
          } catch {
          }
          const prefix = body.trim().slice(0, 200);
          return Err(
            `Mux Gateway balance request failed (HTTP ${response.status}): ${prefix || response.statusText}`
          );
        }
        let json2;
        try {
          json2 = await response.json();
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          return Err(`Mux Gateway balance response was not valid JSON: ${message}`);
        }
        const payload = json2;
        const remaining = payload.remaining_microdollars;
        const concurrency = payload.ai_gateway_concurrent_requests_per_user;
        if (typeof remaining !== "number" || !Number.isFinite(remaining) || !Number.isInteger(remaining) || remaining < 0 || typeof concurrency !== "number" || !Number.isFinite(concurrency) || !Number.isInteger(concurrency) || concurrency < 0) {
          return Err("Mux Gateway returned an invalid balance payload");
        }
        return Ok({
          remaining_microdollars: remaining,
          ai_gateway_concurrent_requests_per_user: concurrency
        });
      })
    },
    muxGatewayOauth: {
      startDesktopFlow: t.input(muxGatewayOauth.startDesktopFlow.input).output(muxGatewayOauth.startDesktopFlow.output).handler(({ context: context2 }) => {
        return context2.muxGatewayOauthService.startDesktopFlow();
      }),
      waitForDesktopFlow: t.input(muxGatewayOauth.waitForDesktopFlow.input).output(muxGatewayOauth.waitForDesktopFlow.output).handler(({ context: context2, input }) => {
        return context2.muxGatewayOauthService.waitForDesktopFlow(input.flowId, {
          timeoutMs: input.timeoutMs
        });
      }),
      cancelDesktopFlow: t.input(muxGatewayOauth.cancelDesktopFlow.input).output(muxGatewayOauth.cancelDesktopFlow.output).handler(async ({ context: context2, input }) => {
        await context2.muxGatewayOauthService.cancelDesktopFlow(input.flowId);
      })
    },
    copilotOauth: {
      startDeviceFlow: t.input(copilotOauth.startDeviceFlow.input).output(copilotOauth.startDeviceFlow.output).handler(({ context: context2 }) => {
        return context2.copilotOauthService.startDeviceFlow();
      }),
      waitForDeviceFlow: t.input(copilotOauth.waitForDeviceFlow.input).output(copilotOauth.waitForDeviceFlow.output).handler(({ context: context2, input }) => {
        return context2.copilotOauthService.waitForDeviceFlow(input.flowId, {
          timeoutMs: input.timeoutMs
        });
      }),
      cancelDeviceFlow: t.input(copilotOauth.cancelDeviceFlow.input).output(copilotOauth.cancelDeviceFlow.output).handler(({ context: context2, input }) => {
        context2.copilotOauthService.cancelDeviceFlow(input.flowId);
      })
    },
    muxGovernorOauth: {
      startDesktopFlow: t.input(muxGovernorOauth.startDesktopFlow.input).output(muxGovernorOauth.startDesktopFlow.output).handler(({ context: context2, input }) => {
        return context2.muxGovernorOauthService.startDesktopFlow({
          governorOrigin: input.governorOrigin
        });
      }),
      waitForDesktopFlow: t.input(muxGovernorOauth.waitForDesktopFlow.input).output(muxGovernorOauth.waitForDesktopFlow.output).handler(({ context: context2, input }) => {
        return context2.muxGovernorOauthService.waitForDesktopFlow(input.flowId, {
          timeoutMs: input.timeoutMs
        });
      }),
      cancelDesktopFlow: t.input(muxGovernorOauth.cancelDesktopFlow.input).output(muxGovernorOauth.cancelDesktopFlow.output).handler(async ({ context: context2, input }) => {
        await context2.muxGovernorOauthService.cancelDesktopFlow(input.flowId);
      })
    },
    codexOauth: {
      startDesktopFlow: t.input(codexOauth.startDesktopFlow.input).output(codexOauth.startDesktopFlow.output).handler(({ context: context2 }) => {
        return context2.codexOauthService.startDesktopFlow();
      }),
      waitForDesktopFlow: t.input(codexOauth.waitForDesktopFlow.input).output(codexOauth.waitForDesktopFlow.output).handler(({ context: context2, input }) => {
        return context2.codexOauthService.waitForDesktopFlow(input.flowId, {
          timeoutMs: input.timeoutMs
        });
      }),
      cancelDesktopFlow: t.input(codexOauth.cancelDesktopFlow.input).output(codexOauth.cancelDesktopFlow.output).handler(async ({ context: context2, input }) => {
        await context2.codexOauthService.cancelDesktopFlow(input.flowId);
      }),
      startDeviceFlow: t.input(codexOauth.startDeviceFlow.input).output(codexOauth.startDeviceFlow.output).handler(({ context: context2 }) => {
        return context2.codexOauthService.startDeviceFlow();
      }),
      waitForDeviceFlow: t.input(codexOauth.waitForDeviceFlow.input).output(codexOauth.waitForDeviceFlow.output).handler(({ context: context2, input }) => {
        return context2.codexOauthService.waitForDeviceFlow(input.flowId, {
          timeoutMs: input.timeoutMs
        });
      }),
      cancelDeviceFlow: t.input(codexOauth.cancelDeviceFlow.input).output(codexOauth.cancelDeviceFlow.output).handler(async ({ context: context2, input }) => {
        await context2.codexOauthService.cancelDeviceFlow(input.flowId);
      }),
      disconnect: t.input(codexOauth.disconnect.input).output(codexOauth.disconnect.output).handler(({ context: context2 }) => {
        return context2.codexOauthService.disconnect();
      })
    },
    general: {
      listDirectory: t.input(general.listDirectory.input).output(general.listDirectory.output).handler(async ({ context: context2, input }) => {
        return context2.projectService.listDirectory(input.path);
      }),
      createDirectory: t.input(general.createDirectory.input).output(general.createDirectory.output).handler(async ({ context: context2, input }) => {
        return context2.projectService.createDirectory(input.path);
      }),
      ping: t.input(general.ping.input).output(general.ping.output).handler(({ input }) => {
        return `Pong: ${input}`;
      }),
      tick: t.input(general.tick.input).output(general.tick.output).handler(async function* ({ input }) {
        for (let i = 1; i <= input.count; i++) {
          yield { tick: i, timestamp: Date.now() };
          if (i < input.count) {
            await new Promise((r) => setTimeout(r, input.intervalMs));
          }
        }
      }),
      openInEditor: t.input(general.openInEditor.input).output(general.openInEditor.output).handler(async ({ context: context2, input }) => {
        return context2.editorService.openInEditor(
          input.workspaceId,
          input.targetPath,
          input.editorConfig
        );
      })
    },
    secrets: {
      get: t.input(secrets.get.input).output(secrets.get.output).handler(({ context: context2, input }) => {
        const projectPath = typeof input.projectPath === "string" && input.projectPath.trim().length > 0 ? input.projectPath : void 0;
        return projectPath ? context2.config.getProjectSecrets(projectPath) : context2.config.getGlobalSecrets();
      }),
      update: t.input(secrets.update.input).output(secrets.update.output).handler(async ({ context: context2, input }) => {
        const projectPath = typeof input.projectPath === "string" && input.projectPath.trim().length > 0 ? input.projectPath : void 0;
        try {
          if (projectPath) {
            await context2.config.updateProjectSecrets(projectPath, input.secrets);
          } else {
            await context2.config.updateGlobalSecrets(input.secrets);
          }
          return Ok(void 0);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          return Err(message);
        }
      })
    },
    mcp: {
      list: t.input(mcp2.list.input).output(mcp2.list.output).handler(async ({ context: context2, input }) => {
        const servers = await context2.mcpConfigService.listServers(input.projectPath);
        if (!context2.policyService.isEnforced()) {
          return servers;
        }
        const filtered = {};
        for (const [name25, info] of Object.entries(servers)) {
          if (context2.policyService.isMcpTransportAllowed(info.transport)) {
            filtered[name25] = info;
          }
        }
        return filtered;
      }),
      add: t.input(mcp2.add.input).output(mcp2.add.output).handler(async ({ context: context2, input }) => {
        const existing = await context2.mcpConfigService.listServers();
        const existingServer = existing[input.name];
        const transport = input.transport ?? "stdio";
        if (context2.policyService.isEnforced()) {
          if (!context2.policyService.isMcpTransportAllowed(transport)) {
            return { success: false, error: "MCP transport is disabled by policy" };
          }
        }
        const hasHeaders = Boolean(input.headers && Object.keys(input.headers).length > 0);
        const usesSecretHeaders = Boolean(
          input.headers && Object.values(input.headers).some(
            (v) => typeof v === "object" && v !== null && "secret" in v
          )
        );
        const action = (() => {
          if (!existingServer) {
            return "add";
          }
          if (existingServer.transport !== "stdio" && transport !== "stdio" && existingServer.transport === transport && existingServer.url === input.url && JSON.stringify(existingServer.headers ?? {}) !== JSON.stringify(input.headers ?? {})) {
            return "set_headers";
          }
          return "edit";
        })();
        const result = await context2.mcpConfigService.addServer(input.name, {
          transport,
          command: input.command,
          url: input.url,
          headers: input.headers
        });
        if (result.success) {
          context2.telemetryService.capture({
            event: "mcp_server_config_changed",
            properties: {
              action,
              transport,
              has_headers: hasHeaders,
              uses_secret_headers: usesSecretHeaders
            }
          });
        }
        return result;
      }),
      remove: t.input(mcp2.remove.input).output(mcp2.remove.output).handler(async ({ context: context2, input }) => {
        const existing = await context2.mcpConfigService.listServers();
        const server2 = existing[input.name];
        if (context2.policyService.isEnforced() && server2) {
          if (!context2.policyService.isMcpTransportAllowed(server2.transport)) {
            return { success: false, error: "MCP transport is disabled by policy" };
          }
        }
        const result = await context2.mcpConfigService.removeServer(input.name);
        if (result.success && server2) {
          const hasHeaders = server2.transport !== "stdio" && Boolean(server2.headers && Object.keys(server2.headers).length > 0);
          const usesSecretHeaders = server2.transport !== "stdio" && Boolean(
            server2.headers && Object.values(server2.headers).some(
              (v) => typeof v === "object" && v !== null && "secret" in v
            )
          );
          context2.telemetryService.capture({
            event: "mcp_server_config_changed",
            properties: {
              action: "remove",
              transport: server2.transport,
              has_headers: hasHeaders,
              uses_secret_headers: usesSecretHeaders
            }
          });
        }
        return result;
      }),
      test: t.input(mcp2.test.input).output(mcp2.test.output).handler(async ({ context: context2, input }) => {
        const start = Date.now();
        const projectPathProvided = typeof input.projectPath === "string" && input.projectPath.trim().length > 0;
        const resolvedProjectPath = projectPathProvided ? input.projectPath : context2.config.rootDir;
        const secrets2 = secretsToRecord(
          projectPathProvided ? context2.config.getEffectiveSecrets(resolvedProjectPath) : context2.config.getGlobalSecrets()
        );
        const configuredTransport = input.name ? (await context2.mcpConfigService.listServers(
          projectPathProvided ? resolvedProjectPath : void 0
        ))[input.name]?.transport : void 0;
        const transport = configuredTransport ?? (input.command ? "stdio" : input.transport ?? "auto");
        if (context2.policyService.isEnforced()) {
          if (!context2.policyService.isMcpTransportAllowed(transport)) {
            return { success: false, error: "MCP transport is disabled by policy" };
          }
        }
        const result = await context2.mcpServerManager.test({
          projectPath: resolvedProjectPath,
          name: input.name,
          command: input.command,
          transport: input.transport,
          url: input.url,
          headers: input.headers,
          projectSecrets: secrets2
        });
        const durationMs = Date.now() - start;
        const categorizeError = (error) => {
          const lower = error.toLowerCase();
          if (lower.includes("timed out")) {
            return "timeout";
          }
          if (lower.includes("econnrefused") || lower.includes("econnreset") || lower.includes("enotfound") || lower.includes("ehostunreach")) {
            return "connect";
          }
          if (/\b(400|401|403|404|405|500|502|503)\b/.test(lower)) {
            return "http_status";
          }
          return "unknown";
        };
        context2.telemetryService.capture({
          event: "mcp_server_tested",
          properties: {
            transport,
            success: result.success,
            duration_ms_b2: roundToBase2(durationMs),
            ...result.success ? {} : { error_category: categorizeError(result.error) }
          }
        });
        return result;
      }),
      setEnabled: t.input(mcp2.setEnabled.input).output(mcp2.setEnabled.output).handler(async ({ context: context2, input }) => {
        const existing = await context2.mcpConfigService.listServers();
        const server2 = existing[input.name];
        if (context2.policyService.isEnforced() && server2) {
          if (!context2.policyService.isMcpTransportAllowed(server2.transport)) {
            return { success: false, error: "MCP transport is disabled by policy" };
          }
        }
        const result = await context2.mcpConfigService.setServerEnabled(input.name, input.enabled);
        if (result.success && server2) {
          const hasHeaders = server2.transport !== "stdio" && Boolean(server2.headers && Object.keys(server2.headers).length > 0);
          const usesSecretHeaders = server2.transport !== "stdio" && Boolean(
            server2.headers && Object.values(server2.headers).some(
              (v) => typeof v === "object" && v !== null && "secret" in v
            )
          );
          context2.telemetryService.capture({
            event: "mcp_server_config_changed",
            properties: {
              action: input.enabled ? "enable" : "disable",
              transport: server2.transport,
              has_headers: hasHeaders,
              uses_secret_headers: usesSecretHeaders
            }
          });
        }
        return result;
      }),
      setToolAllowlist: t.input(mcp2.setToolAllowlist.input).output(mcp2.setToolAllowlist.output).handler(async ({ context: context2, input }) => {
        const existing = await context2.mcpConfigService.listServers();
        const server2 = existing[input.name];
        if (context2.policyService.isEnforced() && server2) {
          if (!context2.policyService.isMcpTransportAllowed(server2.transport)) {
            return { success: false, error: "MCP transport is disabled by policy" };
          }
        }
        const result = await context2.mcpConfigService.setToolAllowlist(
          input.name,
          input.toolAllowlist
        );
        if (result.success && server2) {
          const hasHeaders = server2.transport !== "stdio" && Boolean(server2.headers && Object.keys(server2.headers).length > 0);
          const usesSecretHeaders = server2.transport !== "stdio" && Boolean(
            server2.headers && Object.values(server2.headers).some(
              (v) => typeof v === "object" && v !== null && "secret" in v
            )
          );
          context2.telemetryService.capture({
            event: "mcp_server_config_changed",
            properties: {
              action: "set_tool_allowlist",
              transport: server2.transport,
              has_headers: hasHeaders,
              uses_secret_headers: usesSecretHeaders,
              tool_allowlist_size_b2: roundToBase2(input.toolAllowlist.length)
            }
          });
        }
        return result;
      })
    },
    mcpOauth: {
      startDesktopFlow: t.input(mcpOauth.startDesktopFlow.input).output(mcpOauth.startDesktopFlow.output).handler(async ({ context: context2, input }) => {
        const projectPath = input.projectPath ?? context2.config.rootDir;
        return context2.mcpOauthService.startDesktopFlow({ ...input, projectPath });
      }),
      waitForDesktopFlow: t.input(mcpOauth.waitForDesktopFlow.input).output(mcpOauth.waitForDesktopFlow.output).handler(async ({ context: context2, input }) => {
        return context2.mcpOauthService.waitForDesktopFlow(input.flowId, {
          timeoutMs: input.timeoutMs
        });
      }),
      cancelDesktopFlow: t.input(mcpOauth.cancelDesktopFlow.input).output(mcpOauth.cancelDesktopFlow.output).handler(async ({ context: context2, input }) => {
        await context2.mcpOauthService.cancelDesktopFlow(input.flowId);
      }),
      startServerFlow: t.input(mcpOauth.startServerFlow.input).output(mcpOauth.startServerFlow.output).handler(async ({ context: context2, input }) => {
        const projectPath = input.projectPath ?? context2.config.rootDir;
        const headers = context2.headers;
        const origin = typeof headers?.origin === "string" ? headers.origin.trim() : "";
        if (origin) {
          try {
            const redirectUri2 = new URL("/auth/mcp-oauth/callback", origin).toString();
            return context2.mcpOauthService.startServerFlow({
              ...input,
              projectPath,
              redirectUri: redirectUri2
            });
          } catch {
          }
        }
        const hostHeader = headers?.["x-forwarded-host"] ?? headers?.host;
        const host = typeof hostHeader === "string" ? hostHeader.split(",")[0]?.trim() : "";
        if (!host) {
          return Err("Missing Host header");
        }
        const protoHeader = headers?.["x-forwarded-proto"];
        const forwardedProto = typeof protoHeader === "string" ? protoHeader.split(",")[0]?.trim() : "";
        const proto2 = forwardedProto.length ? forwardedProto : "http";
        const redirectUri = `${proto2}://${host}/auth/mcp-oauth/callback`;
        return context2.mcpOauthService.startServerFlow({
          ...input,
          projectPath,
          redirectUri
        });
      }),
      waitForServerFlow: t.input(mcpOauth.waitForServerFlow.input).output(mcpOauth.waitForServerFlow.output).handler(async ({ context: context2, input }) => {
        return context2.mcpOauthService.waitForServerFlow(input.flowId, {
          timeoutMs: input.timeoutMs
        });
      }),
      cancelServerFlow: t.input(mcpOauth.cancelServerFlow.input).output(mcpOauth.cancelServerFlow.output).handler(async ({ context: context2, input }) => {
        await context2.mcpOauthService.cancelServerFlow(input.flowId);
      }),
      getAuthStatus: t.input(mcpOauth.getAuthStatus.input).output(mcpOauth.getAuthStatus.output).handler(async ({ context: context2, input }) => {
        return context2.mcpOauthService.getAuthStatus({ serverUrl: input.serverUrl });
      }),
      logout: t.input(mcpOauth.logout.input).output(mcpOauth.logout.output).handler(async ({ context: context2, input }) => {
        return context2.mcpOauthService.logout({ serverUrl: input.serverUrl });
      })
    },
    projects: {
      list: t.input(projects.list.input).output(projects.list.output).handler(({ context: context2 }) => {
        return context2.projectService.list();
      }),
      create: t.input(projects.create.input).output(projects.create.output).handler(async ({ context: context2, input }) => {
        return context2.projectService.create(input.projectPath);
      }),
      pickDirectory: t.input(projects.pickDirectory.input).output(projects.pickDirectory.output).handler(async ({ context: context2 }) => {
        return context2.projectService.pickDirectory();
      }),
      getFileCompletions: t.input(projects.getFileCompletions.input).output(projects.getFileCompletions.output).handler(async ({ context: context2, input }) => {
        return context2.projectService.getFileCompletions(
          input.projectPath,
          input.query,
          input.limit
        );
      }),
      runtimeAvailability: t.input(projects.runtimeAvailability.input).output(projects.runtimeAvailability.output).handler(async ({ input }) => {
        return checkRuntimeAvailability(input.projectPath);
      }),
      listBranches: t.input(projects.listBranches.input).output(projects.listBranches.output).handler(async ({ context: context2, input }) => {
        return context2.projectService.listBranches(input.projectPath);
      }),
      gitInit: t.input(projects.gitInit.input).output(projects.gitInit.output).handler(async ({ context: context2, input }) => {
        return context2.projectService.gitInit(input.projectPath);
      }),
      remove: t.input(projects.remove.input).output(projects.remove.output).handler(async ({ context: context2, input }) => {
        return context2.projectService.remove(input.projectPath);
      }),
      secrets: {
        get: t.input(projects.secrets.get.input).output(projects.secrets.get.output).handler(({ context: context2, input }) => {
          return context2.projectService.getSecrets(input.projectPath);
        }),
        update: t.input(projects.secrets.update.input).output(projects.secrets.update.output).handler(async ({ context: context2, input }) => {
          return context2.projectService.updateSecrets(input.projectPath, input.secrets);
        })
      },
      mcp: {
        list: t.input(projects.mcp.list.input).output(projects.mcp.list.output).handler(async ({ context: context2, input }) => {
          const servers = await context2.mcpConfigService.listServers(input.projectPath);
          if (!context2.policyService.isEnforced()) {
            return servers;
          }
          const filtered = {};
          for (const [name25, info] of Object.entries(servers)) {
            if (context2.policyService.isMcpTransportAllowed(info.transport)) {
              filtered[name25] = info;
            }
          }
          return filtered;
        }),
        add: t.input(projects.mcp.add.input).output(projects.mcp.add.output).handler(async ({ context: context2, input }) => {
          const existing = await context2.mcpConfigService.listServers();
          const existingServer = existing[input.name];
          const transport = input.transport ?? "stdio";
          if (context2.policyService.isEnforced()) {
            if (!context2.policyService.isMcpTransportAllowed(transport)) {
              return { success: false, error: "MCP transport is disabled by policy" };
            }
          }
          const hasHeaders = Boolean(input.headers && Object.keys(input.headers).length > 0);
          const usesSecretHeaders = Boolean(
            input.headers && Object.values(input.headers).some(
              (v) => typeof v === "object" && v !== null && "secret" in v
            )
          );
          const action = (() => {
            if (!existingServer) {
              return "add";
            }
            if (existingServer.transport !== "stdio" && transport !== "stdio" && existingServer.transport === transport && existingServer.url === input.url && JSON.stringify(existingServer.headers ?? {}) !== JSON.stringify(input.headers ?? {})) {
              return "set_headers";
            }
            return "edit";
          })();
          const result = await context2.mcpConfigService.addServer(input.name, {
            transport,
            command: input.command,
            url: input.url,
            headers: input.headers
          });
          if (result.success) {
            context2.telemetryService.capture({
              event: "mcp_server_config_changed",
              properties: {
                action,
                transport,
                has_headers: hasHeaders,
                uses_secret_headers: usesSecretHeaders
              }
            });
          }
          return result;
        }),
        remove: t.input(projects.mcp.remove.input).output(projects.mcp.remove.output).handler(async ({ context: context2, input }) => {
          const existing = await context2.mcpConfigService.listServers();
          const server2 = existing[input.name];
          if (context2.policyService.isEnforced() && server2) {
            if (!context2.policyService.isMcpTransportAllowed(server2.transport)) {
              return { success: false, error: "MCP transport is disabled by policy" };
            }
          }
          const result = await context2.mcpConfigService.removeServer(input.name);
          if (result.success && server2) {
            const hasHeaders = server2.transport !== "stdio" && Boolean(server2.headers && Object.keys(server2.headers).length > 0);
            const usesSecretHeaders = server2.transport !== "stdio" && Boolean(
              server2.headers && Object.values(server2.headers).some(
                (v) => typeof v === "object" && v !== null && "secret" in v
              )
            );
            context2.telemetryService.capture({
              event: "mcp_server_config_changed",
              properties: {
                action: "remove",
                transport: server2.transport,
                has_headers: hasHeaders,
                uses_secret_headers: usesSecretHeaders
              }
            });
          }
          return result;
        }),
        test: t.input(projects.mcp.test.input).output(projects.mcp.test.output).handler(async ({ context: context2, input }) => {
          const start = Date.now();
          const secrets2 = secretsToRecord(context2.config.getEffectiveSecrets(input.projectPath));
          const configuredTransport = input.name ? (await context2.mcpConfigService.listServers(input.projectPath))[input.name]?.transport : void 0;
          const transport = configuredTransport ?? (input.command ? "stdio" : input.transport ?? "auto");
          if (context2.policyService.isEnforced()) {
            if (!context2.policyService.isMcpTransportAllowed(transport)) {
              return { success: false, error: "MCP transport is disabled by policy" };
            }
          }
          const result = await context2.mcpServerManager.test({
            projectPath: input.projectPath,
            name: input.name,
            command: input.command,
            transport: input.transport,
            url: input.url,
            headers: input.headers,
            projectSecrets: secrets2
          });
          const durationMs = Date.now() - start;
          const categorizeError = (error) => {
            const lower = error.toLowerCase();
            if (lower.includes("timed out")) {
              return "timeout";
            }
            if (lower.includes("econnrefused") || lower.includes("econnreset") || lower.includes("enotfound") || lower.includes("ehostunreach")) {
              return "connect";
            }
            if (/\b(400|401|403|404|405|500|502|503)\b/.test(lower)) {
              return "http_status";
            }
            return "unknown";
          };
          context2.telemetryService.capture({
            event: "mcp_server_tested",
            properties: {
              transport,
              success: result.success,
              duration_ms_b2: roundToBase2(durationMs),
              ...result.success ? {} : { error_category: categorizeError(result.error) }
            }
          });
          return result;
        }),
        setEnabled: t.input(projects.mcp.setEnabled.input).output(projects.mcp.setEnabled.output).handler(async ({ context: context2, input }) => {
          const existing = await context2.mcpConfigService.listServers();
          const server2 = existing[input.name];
          if (context2.policyService.isEnforced() && server2) {
            if (!context2.policyService.isMcpTransportAllowed(server2.transport)) {
              return { success: false, error: "MCP transport is disabled by policy" };
            }
          }
          const result = await context2.mcpConfigService.setServerEnabled(
            input.name,
            input.enabled
          );
          if (result.success && server2) {
            const hasHeaders = server2.transport !== "stdio" && Boolean(server2.headers && Object.keys(server2.headers).length > 0);
            const usesSecretHeaders = server2.transport !== "stdio" && Boolean(
              server2.headers && Object.values(server2.headers).some(
                (v) => typeof v === "object" && v !== null && "secret" in v
              )
            );
            context2.telemetryService.capture({
              event: "mcp_server_config_changed",
              properties: {
                action: input.enabled ? "enable" : "disable",
                transport: server2.transport,
                has_headers: hasHeaders,
                uses_secret_headers: usesSecretHeaders
              }
            });
          }
          return result;
        }),
        setToolAllowlist: t.input(projects.mcp.setToolAllowlist.input).output(projects.mcp.setToolAllowlist.output).handler(async ({ context: context2, input }) => {
          const existing = await context2.mcpConfigService.listServers();
          const server2 = existing[input.name];
          if (context2.policyService.isEnforced() && server2) {
            if (!context2.policyService.isMcpTransportAllowed(server2.transport)) {
              return { success: false, error: "MCP transport is disabled by policy" };
            }
          }
          const result = await context2.mcpConfigService.setToolAllowlist(
            input.name,
            input.toolAllowlist
          );
          if (result.success && server2) {
            const hasHeaders = server2.transport !== "stdio" && Boolean(server2.headers && Object.keys(server2.headers).length > 0);
            const usesSecretHeaders = server2.transport !== "stdio" && Boolean(
              server2.headers && Object.values(server2.headers).some(
                (v) => typeof v === "object" && v !== null && "secret" in v
              )
            );
            context2.telemetryService.capture({
              event: "mcp_server_config_changed",
              properties: {
                action: "set_tool_allowlist",
                transport: server2.transport,
                has_headers: hasHeaders,
                uses_secret_headers: usesSecretHeaders,
                tool_allowlist_size_b2: roundToBase2(input.toolAllowlist.length)
              }
            });
          }
          return result;
        })
      },
      mcpOauth: {
        startDesktopFlow: t.input(projects.mcpOauth.startDesktopFlow.input).output(projects.mcpOauth.startDesktopFlow.output).handler(async ({ context: context2, input }) => {
          return context2.mcpOauthService.startDesktopFlow(input);
        }),
        waitForDesktopFlow: t.input(projects.mcpOauth.waitForDesktopFlow.input).output(projects.mcpOauth.waitForDesktopFlow.output).handler(async ({ context: context2, input }) => {
          return context2.mcpOauthService.waitForDesktopFlow(input.flowId, {
            timeoutMs: input.timeoutMs
          });
        }),
        cancelDesktopFlow: t.input(projects.mcpOauth.cancelDesktopFlow.input).output(projects.mcpOauth.cancelDesktopFlow.output).handler(async ({ context: context2, input }) => {
          await context2.mcpOauthService.cancelDesktopFlow(input.flowId);
        }),
        startServerFlow: t.input(projects.mcpOauth.startServerFlow.input).output(projects.mcpOauth.startServerFlow.output).handler(async ({ context: context2, input }) => {
          const headers = context2.headers;
          const origin = typeof headers?.origin === "string" ? headers.origin.trim() : "";
          if (origin) {
            try {
              const redirectUri2 = new URL("/auth/mcp-oauth/callback", origin).toString();
              return context2.mcpOauthService.startServerFlow({ ...input, redirectUri: redirectUri2 });
            } catch {
            }
          }
          const hostHeader = headers?.["x-forwarded-host"] ?? headers?.host;
          const host = typeof hostHeader === "string" ? hostHeader.split(",")[0]?.trim() : "";
          if (!host) {
            return Err("Missing Host header");
          }
          const protoHeader = headers?.["x-forwarded-proto"];
          const forwardedProto = typeof protoHeader === "string" ? protoHeader.split(",")[0]?.trim() : "";
          const proto2 = forwardedProto.length ? forwardedProto : "http";
          const redirectUri = `${proto2}://${host}/auth/mcp-oauth/callback`;
          return context2.mcpOauthService.startServerFlow({ ...input, redirectUri });
        }),
        waitForServerFlow: t.input(projects.mcpOauth.waitForServerFlow.input).output(projects.mcpOauth.waitForServerFlow.output).handler(async ({ context: context2, input }) => {
          return context2.mcpOauthService.waitForServerFlow(input.flowId, {
            timeoutMs: input.timeoutMs
          });
        }),
        cancelServerFlow: t.input(projects.mcpOauth.cancelServerFlow.input).output(projects.mcpOauth.cancelServerFlow.output).handler(async ({ context: context2, input }) => {
          await context2.mcpOauthService.cancelServerFlow(input.flowId);
        }),
        getAuthStatus: t.input(projects.mcpOauth.getAuthStatus.input).output(projects.mcpOauth.getAuthStatus.output).handler(async ({ context: context2, input }) => {
          const servers = await context2.mcpConfigService.listServers(input.projectPath);
          const server2 = servers[input.serverName];
          if (!server2 || server2.transport === "stdio") {
            return { isLoggedIn: false, hasRefreshToken: false };
          }
          return context2.mcpOauthService.getAuthStatus({ serverUrl: server2.url });
        }),
        logout: t.input(projects.mcpOauth.logout.input).output(projects.mcpOauth.logout.output).handler(async ({ context: context2, input }) => {
          const servers = await context2.mcpConfigService.listServers(input.projectPath);
          const server2 = servers[input.serverName];
          if (!server2 || server2.transport === "stdio") {
            return Ok(void 0);
          }
          return context2.mcpOauthService.logout({ serverUrl: server2.url });
        })
      },
      idleCompaction: {
        get: t.input(projects.idleCompaction.get.input).output(projects.idleCompaction.get.output).handler(({ context: context2, input }) => ({
          hours: context2.projectService.getIdleCompactionHours(input.projectPath)
        })),
        set: t.input(projects.idleCompaction.set.input).output(projects.idleCompaction.set.output).handler(
          ({ context: context2, input }) => context2.projectService.setIdleCompactionHours(input.projectPath, input.hours)
        )
      },
      sections: {
        list: t.input(projects.sections.list.input).output(projects.sections.list.output).handler(({ context: context2, input }) => context2.projectService.listSections(input.projectPath)),
        create: t.input(projects.sections.create.input).output(projects.sections.create.output).handler(
          ({ context: context2, input }) => context2.projectService.createSection(input.projectPath, input.name, input.color)
        ),
        update: t.input(projects.sections.update.input).output(projects.sections.update.output).handler(
          ({ context: context2, input }) => context2.projectService.updateSection(input.projectPath, input.sectionId, {
            name: input.name,
            color: input.color
          })
        ),
        remove: t.input(projects.sections.remove.input).output(projects.sections.remove.output).handler(
          ({ context: context2, input }) => context2.projectService.removeSection(input.projectPath, input.sectionId)
        ),
        reorder: t.input(projects.sections.reorder.input).output(projects.sections.reorder.output).handler(
          ({ context: context2, input }) => context2.projectService.reorderSections(input.projectPath, input.sectionIds)
        ),
        assignWorkspace: t.input(projects.sections.assignWorkspace.input).output(projects.sections.assignWorkspace.output).handler(async ({ context: context2, input }) => {
          const result = await context2.projectService.assignWorkspaceToSection(
            input.projectPath,
            input.workspaceId,
            input.sectionId
          );
          if (result.success) {
            await context2.workspaceService.refreshAndEmitMetadata(input.workspaceId);
          }
          return result;
        })
      }
    },
    nameGeneration: {
      generate: t.input(nameGeneration.generate.input).output(nameGeneration.generate.output).handler(async ({ context: context2, input }) => {
        const result = await generateWorkspaceIdentity(
          input.message,
          input.candidates,
          context2.aiService
        );
        if (!result.success) {
          return result;
        }
        return {
          success: true,
          data: {
            name: result.data.name,
            title: result.data.title,
            modelUsed: result.data.modelUsed
          }
        };
      })
    },
    coder: {
      getInfo: t.input(coder.getInfo.input).output(coder.getInfo.output).handler(async ({ context: context2 }) => {
        return context2.coderService.getCoderInfo();
      }),
      listTemplates: t.input(coder.listTemplates.input).output(coder.listTemplates.output).handler(async ({ context: context2 }) => {
        return context2.coderService.listTemplates();
      }),
      listPresets: t.input(coder.listPresets.input).output(coder.listPresets.output).handler(async ({ context: context2, input }) => {
        return context2.coderService.listPresets(input.template, input.org);
      }),
      listWorkspaces: t.input(coder.listWorkspaces.input).output(coder.listWorkspaces.output).handler(async ({ context: context2 }) => {
        return context2.coderService.listWorkspaces();
      })
    },
    workspace: {
      list: t.input(workspace.list.input).output(workspace.list.output).handler(async ({ context: context2, input }) => {
        const allWorkspaces = await context2.workspaceService.list();
        if (input?.archived) {
          return allWorkspaces.filter((w) => isWorkspaceArchived(w.archivedAt, w.unarchivedAt));
        }
        return allWorkspaces.filter((w) => !isWorkspaceArchived(w.archivedAt, w.unarchivedAt));
      }),
      create: t.input(workspace.create.input).output(workspace.create.output).handler(async ({ context: context2, input }) => {
        const result = await context2.workspaceService.create(
          input.projectPath,
          input.branchName,
          input.trunkBranch,
          input.title,
          input.runtimeConfig,
          input.sectionId
        );
        if (!result.success) {
          return { success: false, error: result.error };
        }
        return { success: true, metadata: result.data.metadata };
      }),
      remove: t.input(workspace.remove.input).output(workspace.remove.output).handler(async ({ context: context2, input }) => {
        const result = await context2.workspaceService.remove(
          input.workspaceId,
          input.options?.force
        );
        if (!result.success) {
          return { success: false, error: result.error };
        }
        return { success: true };
      }),
      updateAgentAISettings: t.input(workspace.updateAgentAISettings.input).output(workspace.updateAgentAISettings.output).handler(async ({ context: context2, input }) => {
        return context2.workspaceService.updateAgentAISettings(
          input.workspaceId,
          input.agentId,
          input.aiSettings
        );
      }),
      rename: t.input(workspace.rename.input).output(workspace.rename.output).handler(async ({ context: context2, input }) => {
        return context2.workspaceService.rename(input.workspaceId, input.newName);
      }),
      updateModeAISettings: t.input(workspace.updateModeAISettings.input).output(workspace.updateModeAISettings.output).handler(async ({ context: context2, input }) => {
        return context2.workspaceService.updateModeAISettings(
          input.workspaceId,
          input.mode,
          input.aiSettings
        );
      }),
      updateTitle: t.input(workspace.updateTitle.input).output(workspace.updateTitle.output).handler(async ({ context: context2, input }) => {
        return context2.workspaceService.updateTitle(input.workspaceId, input.title);
      }),
      archive: t.input(workspace.archive.input).output(workspace.archive.output).handler(async ({ context: context2, input }) => {
        return context2.workspaceService.archive(input.workspaceId);
      }),
      unarchive: t.input(workspace.unarchive.input).output(workspace.unarchive.output).handler(async ({ context: context2, input }) => {
        return context2.workspaceService.unarchive(input.workspaceId);
      }),
      archiveMergedInProject: t.input(workspace.archiveMergedInProject.input).output(workspace.archiveMergedInProject.output).handler(async ({ context: context2, input }) => {
        return context2.workspaceService.archiveMergedInProject(input.projectPath);
      }),
      fork: t.input(workspace.fork.input).output(workspace.fork.output).handler(async ({ context: context2, input }) => {
        const result = await context2.workspaceService.fork(
          input.sourceWorkspaceId,
          input.newName
        );
        if (!result.success) {
          return { success: false, error: result.error };
        }
        return {
          success: true,
          metadata: result.data.metadata,
          projectPath: result.data.projectPath
        };
      }),
      sendMessage: t.input(workspace.sendMessage.input).output(workspace.sendMessage.output).handler(async ({ context: context2, input }) => {
        const result = await context2.workspaceService.sendMessage(
          input.workspaceId,
          input.message,
          input.options
        );
        if (!result.success) {
          return { success: false, error: result.error };
        }
        return { success: true, data: {} };
      }),
      answerAskUserQuestion: t.input(workspace.answerAskUserQuestion.input).output(workspace.answerAskUserQuestion.output).handler(async ({ context: context2, input }) => {
        const result = await context2.workspaceService.answerAskUserQuestion(
          input.workspaceId,
          input.toolCallId,
          input.answers
        );
        if (!result.success) {
          return { success: false, error: result.error };
        }
        return { success: true, data: void 0 };
      }),
      resumeStream: t.input(workspace.resumeStream.input).output(workspace.resumeStream.output).handler(async ({ context: context2, input }) => {
        const result = await context2.workspaceService.resumeStream(
          input.workspaceId,
          input.options
        );
        if (!result.success) {
          const error = typeof result.error === "string" ? { type: "unknown", raw: result.error } : result.error;
          return { success: false, error };
        }
        return { success: true, data: void 0 };
      }),
      interruptStream: t.input(workspace.interruptStream.input).output(workspace.interruptStream.output).handler(async ({ context: context2, input }) => {
        const result = await context2.workspaceService.interruptStream(
          input.workspaceId,
          input.options
        );
        if (!result.success) {
          return { success: false, error: result.error };
        }
        return { success: true, data: void 0 };
      }),
      clearQueue: t.input(workspace.clearQueue.input).output(workspace.clearQueue.output).handler(({ context: context2, input }) => {
        const result = context2.workspaceService.clearQueue(input.workspaceId);
        if (!result.success) {
          return { success: false, error: result.error };
        }
        return { success: true, data: void 0 };
      }),
      truncateHistory: t.input(workspace.truncateHistory.input).output(workspace.truncateHistory.output).handler(async ({ context: context2, input }) => {
        const result = await context2.workspaceService.truncateHistory(
          input.workspaceId,
          input.percentage
        );
        if (!result.success) {
          return { success: false, error: result.error };
        }
        return { success: true, data: void 0 };
      }),
      replaceChatHistory: t.input(workspace.replaceChatHistory.input).output(workspace.replaceChatHistory.output).handler(async ({ context: context2, input }) => {
        const result = await context2.workspaceService.replaceHistory(
          input.workspaceId,
          input.summaryMessage,
          { mode: input.mode, deletePlanFile: input.deletePlanFile }
        );
        if (!result.success) {
          return { success: false, error: result.error };
        }
        return { success: true, data: void 0 };
      }),
      getDevcontainerInfo: t.input(workspace.getDevcontainerInfo.input).output(workspace.getDevcontainerInfo.output).handler(async ({ context: context2, input }) => {
        return context2.workspaceService.getDevcontainerInfo(input.workspaceId);
      }),
      getInfo: t.input(workspace.getInfo.input).output(workspace.getInfo.output).handler(async ({ context: context2, input }) => {
        return context2.workspaceService.getInfo(input.workspaceId);
      }),
      getLastLlmRequest: t.input(workspace.getLastLlmRequest.input).output(workspace.getLastLlmRequest.output).handler(({ context: context2, input }) => {
        return context2.aiService.debugGetLastLlmRequest(input.workspaceId);
      }),
      getFullReplay: t.input(workspace.getFullReplay.input).output(workspace.getFullReplay.output).handler(async ({ context: context2, input }) => {
        return context2.workspaceService.getFullReplay(input.workspaceId);
      }),
      getSubagentTranscript: t.input(workspace.getSubagentTranscript.input).output(workspace.getSubagentTranscript.output).handler(async ({ context: context2, input }) => {
        const taskId = input.taskId.trim();
        assert2(taskId.length > 0, "workspace.getSubagentTranscript: taskId must be non-empty");
        const requestingWorkspaceIdTrimmed = input.workspaceId?.trim();
        const requestingWorkspaceId = requestingWorkspaceIdTrimmed && requestingWorkspaceIdTrimmed.length > 0 ? requestingWorkspaceIdTrimmed : null;
        const tryLoadFromWorkspace = async (workspaceId) => {
          const sessionDir = context2.config.getSessionDir(workspaceId);
          const artifacts = await readSubagentTranscriptArtifactsFile(sessionDir);
          const entry = artifacts.artifactsByChildTaskId[taskId] ?? null;
          return entry ? { workspaceId, entry } : null;
        };
        const tryLoadFromDescendantWorkspaces = async (ancestorWorkspaceId) => {
          const descendants = context2.taskService.listDescendantAgentTasks(ancestorWorkspaceId);
          descendants.sort((a, b) => a.depth - b.depth);
          for (const descendant of descendants) {
            const loaded = await tryLoadFromWorkspace(descendant.taskId);
            if (loaded) return loaded;
          }
          return null;
        };
        let isDescendant = false;
        if (requestingWorkspaceId) {
          try {
            isDescendant = await context2.taskService.isDescendantAgentTask(
              requestingWorkspaceId,
              taskId
            );
          } catch (error) {
            log.warn("workspace.getSubagentTranscript: descendant check failed", {
              requestingWorkspaceId,
              taskId,
              error: error instanceof Error ? error.message : String(error)
            });
          }
        }
        const readTranscriptFromPaths = async (params) => {
          const workspaceSessionDir = context2.config.getSessionDir(params.workspaceId);
          if (params.chatPath && !isPathInsideDir(workspaceSessionDir, params.chatPath)) {
            throw new Error("Refusing to read transcript outside workspace session dir");
          }
          if (params.partialPath && !isPathInsideDir(workspaceSessionDir, params.partialPath)) {
            throw new Error("Refusing to read partial outside workspace session dir");
          }
          const partial = params.partialPath ? await readPartialJsonBestEffort(params.partialPath) : null;
          const messages2 = params.chatPath ? await readChatJsonlAllowMissing({
            chatPath: params.chatPath,
            logLabel: params.logLabel
          }) : null;
          if (!messages2 && !partial) {
            throw new Error(`Transcript not found (missing ${params.logLabel})`);
          }
          return mergePartialIntoHistory(messages2 ?? [], partial);
        };
        let resolved = null;
        let hasArtifactInRequestingTree = false;
        if (requestingWorkspaceId !== null) {
          resolved = await tryLoadFromWorkspace(requestingWorkspaceId);
          if (resolved) {
            hasArtifactInRequestingTree = true;
          } else {
            resolved = await tryLoadFromDescendantWorkspaces(requestingWorkspaceId);
            hasArtifactInRequestingTree = resolved !== null;
          }
        } else {
          resolved = await findSubagentTranscriptEntryByScanningSessions({
            sessionsDir: context2.config.sessionsDir,
            taskId
          });
        }
        if (!resolved) {
          if (requestingWorkspaceId && isDescendant) {
            const taskSessionDir = context2.config.getSessionDir(taskId);
            const messages2 = await readTranscriptFromPaths({
              workspaceId: taskId,
              chatPath: path22.join(taskSessionDir, "chat.jsonl"),
              partialPath: path22.join(taskSessionDir, "partial.json"),
              logLabel: `${taskId}/chat.jsonl`
            });
            const metaResult = await context2.aiService.getWorkspaceMetadata(taskId);
            const model2 = metaResult.success && typeof metaResult.data.taskModelString === "string" && metaResult.data.taskModelString.trim().length > 0 ? metaResult.data.taskModelString.trim() : void 0;
            const thinkingLevel2 = metaResult.success ? coerceThinkingLevel(metaResult.data.taskThinkingLevel) : void 0;
            return { messages: messages2, model: model2, thinkingLevel: thinkingLevel2 };
          }
          throw new Error(
            requestingWorkspaceId ? `No transcript found for task ${taskId} in workspace ${requestingWorkspaceId}` : `No transcript found for task ${taskId}`
          );
        }
        if (requestingWorkspaceId && !isDescendant && !hasArtifactInRequestingTree) {
          throw new Error("Task is not a descendant of this workspace");
        }
        const messages = await readTranscriptFromPaths({
          workspaceId: resolved.workspaceId,
          chatPath: resolved.entry.chatPath,
          partialPath: resolved.entry.partialPath,
          logLabel: `${resolved.workspaceId}/subagent-transcripts/${taskId}/chat.jsonl`
        });
        const model = typeof resolved.entry.model === "string" && resolved.entry.model.trim().length > 0 ? resolved.entry.model.trim() : void 0;
        const thinkingLevel = coerceThinkingLevel(resolved.entry.thinkingLevel);
        return { messages, model, thinkingLevel };
      }),
      executeBash: t.input(workspace.executeBash.input).output(workspace.executeBash.output).handler(async ({ context: context2, input }) => {
        const result = await context2.workspaceService.executeBash(
          input.workspaceId,
          input.script,
          input.options
        );
        if (!result.success) {
          return { success: false, error: result.error };
        }
        return { success: true, data: result.data };
      }),
      getFileCompletions: t.input(workspace.getFileCompletions.input).output(workspace.getFileCompletions.output).handler(async ({ context: context2, input }) => {
        return context2.workspaceService.getFileCompletions(
          input.workspaceId,
          input.query,
          input.limit
        );
      }),
      onChat: t.input(workspace.onChat.input).output(workspace.onChat.output).handler(async function* ({ context: context2, input, signal }) {
        const session = context2.workspaceService.getOrCreateSession(input.workspaceId);
        const { push, iterate, end } = createAsyncMessageQueue();
        const onAbort = () => {
          end();
        };
        if (signal) {
          if (signal.aborted) {
            onAbort();
          } else {
            signal.addEventListener("abort", onAbort, { once: true });
          }
        }
        const replayRelay = createReplayBufferedStreamMessageRelay(push);
        const unsubscribe = session.onChatEvent(({ message }) => {
          replayRelay.handleSessionMessage(message);
        });
        await session.replayHistory(({ message }) => {
          push(message);
        });
        replayRelay.finishReplay();
        const HEARTBEAT_INTERVAL_MS = 5e3;
        const heartbeatInterval = setInterval(() => {
          push({ type: "heartbeat" });
        }, HEARTBEAT_INTERVAL_MS);
        try {
          yield* iterate();
        } finally {
          clearInterval(heartbeatInterval);
          signal?.removeEventListener("abort", onAbort);
          end();
          unsubscribe();
        }
      }),
      onMetadata: t.input(workspace.onMetadata.input).output(workspace.onMetadata.output).handler(async function* ({ context: context2, signal }) {
        const service = context2.workspaceService;
        let resolveNext = null;
        const queue = [];
        let ended = false;
        const push = (event) => {
          if (ended) return;
          if (resolveNext) {
            const resolve4 = resolveNext;
            resolveNext = null;
            resolve4(event);
          } else {
            queue.push(event);
          }
        };
        const onMetadata = (event) => {
          push(event);
        };
        service.on("metadata", onMetadata);
        const onAbort = () => {
          if (ended) return;
          ended = true;
          if (resolveNext) {
            const resolve4 = resolveNext;
            resolveNext = null;
            resolve4(null);
          }
        };
        if (signal) {
          if (signal.aborted) {
            onAbort();
          } else {
            signal.addEventListener("abort", onAbort, { once: true });
          }
        }
        try {
          while (!ended) {
            if (queue.length > 0) {
              yield queue.shift();
              continue;
            }
            const event = await new Promise((resolve4) => {
              resolveNext = resolve4;
            });
            if (event === null || ended) {
              break;
            }
            yield event;
          }
        } finally {
          ended = true;
          signal?.removeEventListener("abort", onAbort);
          service.off("metadata", onMetadata);
        }
      }),
      activity: {
        list: t.input(workspace.activity.list.input).output(workspace.activity.list.output).handler(async ({ context: context2 }) => {
          return context2.workspaceService.getActivityList();
        }),
        subscribe: t.input(workspace.activity.subscribe.input).output(workspace.activity.subscribe.output).handler(async function* ({ context: context2, signal }) {
          const service = context2.workspaceService;
          let resolveNext = null;
          const queue = [];
          let ended = false;
          const push = (event) => {
            if (ended) return;
            if (resolveNext) {
              const resolve4 = resolveNext;
              resolveNext = null;
              resolve4(event);
            } else {
              queue.push(event);
            }
          };
          const onActivity = (event) => {
            push(event);
          };
          service.on("activity", onActivity);
          const onAbort = () => {
            if (ended) return;
            ended = true;
            if (resolveNext) {
              const resolve4 = resolveNext;
              resolveNext = null;
              resolve4(null);
            }
          };
          if (signal) {
            if (signal.aborted) {
              onAbort();
            } else {
              signal.addEventListener("abort", onAbort, { once: true });
            }
          }
          try {
            while (!ended) {
              if (queue.length > 0) {
                yield queue.shift();
                continue;
              }
              const event = await new Promise((resolve4) => {
                resolveNext = resolve4;
              });
              if (event === null || ended) {
                break;
              }
              yield event;
            }
          } finally {
            ended = true;
            signal?.removeEventListener("abort", onAbort);
            service.off("activity", onActivity);
          }
        })
      },
      getPlanContent: t.input(workspace.getPlanContent.input).output(workspace.getPlanContent.output).handler(async ({ context: context2, input }) => {
        const metadata = await context2.workspaceService.getInfo(input.workspaceId);
        if (!metadata) {
          return { success: false, error: `Workspace not found: ${input.workspaceId}` };
        }
        const runtime = createRuntimeForWorkspace(metadata);
        const result = await readPlanFile(
          runtime,
          metadata.name,
          metadata.projectName,
          input.workspaceId
        );
        if (!result.exists) {
          return { success: false, error: `Plan file not found at ${result.path}` };
        }
        return { success: true, data: { content: result.content, path: result.path } };
      }),
      backgroundBashes: {
        subscribe: t.input(workspace.backgroundBashes.subscribe.input).output(workspace.backgroundBashes.subscribe.output).handler(async function* ({ context: context2, input, signal }) {
          const service = context2.workspaceService;
          const { workspaceId } = input;
          if (signal?.aborted) {
            return;
          }
          const getState = async () => ({
            processes: await service.listBackgroundProcesses(workspaceId),
            foregroundToolCallIds: service.getForegroundToolCallIds(workspaceId)
          });
          const queue = createAsyncEventQueue();
          const onAbort = () => {
            queue.end();
          };
          if (signal) {
            signal.addEventListener("abort", onAbort, { once: true });
          }
          const onChange = (changedWorkspaceId) => {
            if (changedWorkspaceId === workspaceId) {
              void getState().then(queue.push);
            }
          };
          service.onBackgroundBashChange(onChange);
          try {
            yield await getState();
            yield* queue.iterate();
          } finally {
            signal?.removeEventListener("abort", onAbort);
            queue.end();
            service.offBackgroundBashChange(onChange);
          }
        }),
        terminate: t.input(workspace.backgroundBashes.terminate.input).output(workspace.backgroundBashes.terminate.output).handler(async ({ context: context2, input }) => {
          const result = await context2.workspaceService.terminateBackgroundProcess(
            input.workspaceId,
            input.processId
          );
          if (!result.success) {
            return { success: false, error: result.error };
          }
          return { success: true, data: void 0 };
        }),
        sendToBackground: t.input(workspace.backgroundBashes.sendToBackground.input).output(workspace.backgroundBashes.sendToBackground.output).handler(({ context: context2, input }) => {
          const result = context2.workspaceService.sendToBackground(input.toolCallId);
          if (!result.success) {
            return { success: false, error: result.error };
          }
          return { success: true, data: void 0 };
        }),
        getOutput: t.input(workspace.backgroundBashes.getOutput.input).output(workspace.backgroundBashes.getOutput.output).handler(async ({ context: context2, input }) => {
          const result = await context2.workspaceService.getBackgroundProcessOutput(
            input.workspaceId,
            input.processId,
            { fromOffset: input.fromOffset, tailBytes: input.tailBytes }
          );
          if (!result.success) {
            return { success: false, error: result.error };
          }
          return { success: true, data: result.data };
        })
      },
      getPostCompactionState: t.input(workspace.getPostCompactionState.input).output(workspace.getPostCompactionState.output).handler(({ context: context2, input }) => {
        return context2.workspaceService.getPostCompactionState(input.workspaceId);
      }),
      setPostCompactionExclusion: t.input(workspace.setPostCompactionExclusion.input).output(workspace.setPostCompactionExclusion.output).handler(async ({ context: context2, input }) => {
        return context2.workspaceService.setPostCompactionExclusion(
          input.workspaceId,
          input.itemId,
          input.excluded
        );
      }),
      getSessionUsage: t.input(workspace.getSessionUsage.input).output(workspace.getSessionUsage.output).handler(async ({ context: context2, input }) => {
        return context2.sessionUsageService.getSessionUsage(input.workspaceId);
      }),
      getSessionUsageBatch: t.input(workspace.getSessionUsageBatch.input).output(workspace.getSessionUsageBatch.output).handler(async ({ context: context2, input }) => {
        return context2.sessionUsageService.getSessionUsageBatch(input.workspaceIds);
      }),
      stats: {
        subscribe: t.input(workspace.stats.subscribe.input).output(workspace.stats.subscribe.output).handler(async function* ({ context: context2, input, signal }) {
          const workspaceId = input.workspaceId;
          if (signal?.aborted) {
            return;
          }
          context2.sessionTimingService.addSubscriber(workspaceId);
          const queue = /* @__PURE__ */ (() => {
            let buffered;
            let hasBuffered = false;
            let resolveNext = null;
            let ended = false;
            const push = (value2) => {
              if (ended) return;
              if (resolveNext) {
                const resolve4 = resolveNext;
                resolveNext = null;
                resolve4(value2);
                return;
              }
              buffered = value2;
              hasBuffered = true;
            };
            async function* iterate() {
              while (true) {
                if (ended) {
                  return;
                }
                if (hasBuffered) {
                  const value2 = buffered;
                  buffered = void 0;
                  hasBuffered = false;
                  if (value2 !== void 0) {
                    yield value2;
                  }
                  continue;
                }
                const next = await new Promise((resolve4) => {
                  resolveNext = resolve4;
                });
                if (ended || next === null) {
                  return;
                }
                yield next;
              }
            }
            const end = () => {
              ended = true;
              if (resolveNext) {
                const resolve4 = resolveNext;
                resolveNext = null;
                resolve4(null);
              }
            };
            return { push, iterate, end };
          })();
          const SNAPSHOT_THROTTLE_MS = 100;
          let lastPushedAtMs = 0;
          let inFlight = false;
          let pendingTimer;
          let pendingSnapshot = false;
          let closed = false;
          const onAbort = () => {
            closed = true;
            if (pendingTimer) {
              clearTimeout(pendingTimer);
              pendingTimer = void 0;
            }
            queue.end();
          };
          if (signal) {
            signal.addEventListener("abort", onAbort, { once: true });
          }
          const pushSnapshot = async () => {
            if (closed) return;
            if (inFlight) return;
            if (!pendingSnapshot) return;
            pendingSnapshot = false;
            inFlight = true;
            try {
              const snapshot = await context2.sessionTimingService.getSnapshot(workspaceId);
              if (closed) return;
              lastPushedAtMs = snapshot.generatedAt;
              queue.push(snapshot);
            } finally {
              inFlight = false;
              if (!closed && pendingSnapshot) {
                scheduleSnapshot();
              }
            }
          };
          const runPushSnapshot = () => {
            void pushSnapshot().catch(() => {
            });
          };
          const scheduleSnapshot = () => {
            pendingSnapshot = true;
            if (closed) {
              return;
            }
            if (inFlight) {
              return;
            }
            if (pendingTimer) {
              return;
            }
            const now2 = Date.now();
            const timeSinceLastPush = now2 - lastPushedAtMs;
            if (timeSinceLastPush >= SNAPSHOT_THROTTLE_MS) {
              runPushSnapshot();
              return;
            }
            const remaining = SNAPSHOT_THROTTLE_MS - timeSinceLastPush;
            pendingTimer = setTimeout(() => {
              pendingTimer = void 0;
              runPushSnapshot();
            }, remaining);
            pendingTimer.unref?.();
          };
          const onChange = (changedWorkspaceId) => {
            if (changedWorkspaceId !== workspaceId) {
              return;
            }
            scheduleSnapshot();
          };
          inFlight = true;
          context2.sessionTimingService.onStatsChange(onChange);
          try {
            const initial = await context2.sessionTimingService.getSnapshot(workspaceId);
            lastPushedAtMs = initial.generatedAt;
            queue.push(initial);
          } finally {
            inFlight = false;
            if (!closed && pendingSnapshot) {
              scheduleSnapshot();
            }
          }
          try {
            yield* queue.iterate();
          } finally {
            closed = true;
            signal?.removeEventListener("abort", onAbort);
            if (pendingTimer) {
              clearTimeout(pendingTimer);
            }
            queue.end();
            context2.sessionTimingService.offStatsChange(onChange);
            context2.sessionTimingService.removeSubscriber(workspaceId);
          }
        }),
        clear: t.input(workspace.stats.clear.input).output(workspace.stats.clear.output).handler(async ({ context: context2, input }) => {
          try {
            await context2.sessionTimingService.clearTimingFile(input.workspaceId);
            return { success: true, data: void 0 };
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            return { success: false, error: message };
          }
        })
      },
      mcp: {
        get: t.input(workspace.mcp.get.input).output(workspace.mcp.get.output).handler(async ({ context: context2, input }) => {
          const policy2 = context2.policyService.getEffectivePolicy();
          const mcpDisabledByPolicy = context2.policyService.isEnforced() && policy2?.mcp.allowUserDefined.stdio === false && policy2.mcp.allowUserDefined.remote === false;
          if (mcpDisabledByPolicy) {
            return {};
          }
          try {
            return await context2.workspaceMcpOverridesService.getOverridesForWorkspace(
              input.workspaceId
            );
          } catch {
            return {};
          }
        }),
        set: t.input(workspace.mcp.set.input).output(workspace.mcp.set.output).handler(async ({ context: context2, input }) => {
          try {
            await context2.workspaceMcpOverridesService.setOverridesForWorkspace(
              input.workspaceId,
              input.overrides
            );
            return { success: true, data: void 0 };
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            return { success: false, error: message };
          }
        })
      }
    },
    tasks: {
      create: t.input(tasks.create.input).output(tasks.create.output).handler(({ context: context2, input }) => {
        const thinkingLevel = input.thinkingLevel === "off" || input.thinkingLevel === "low" || input.thinkingLevel === "medium" || input.thinkingLevel === "high" || input.thinkingLevel === "xhigh" ? input.thinkingLevel : void 0;
        return context2.taskService.create({
          parentWorkspaceId: input.parentWorkspaceId,
          kind: input.kind,
          agentId: input.agentId,
          agentType: input.agentType,
          prompt: input.prompt,
          title: input.title,
          modelString: input.modelString,
          thinkingLevel
        });
      })
    },
    window: {
      setTitle: t.input(window2.setTitle.input).output(window2.setTitle.output).handler(({ context: context2, input }) => {
        return context2.windowService.setTitle(input.title);
      })
    },
    terminal: {
      create: t.input(terminal.create.input).output(terminal.create.output).handler(async ({ context: context2, input }) => {
        return context2.terminalService.create(input);
      }),
      close: t.input(terminal.close.input).output(terminal.close.output).handler(({ context: context2, input }) => {
        return context2.terminalService.close(input.sessionId);
      }),
      resize: t.input(terminal.resize.input).output(terminal.resize.output).handler(({ context: context2, input }) => {
        return context2.terminalService.resize(input);
      }),
      sendInput: t.input(terminal.sendInput.input).output(terminal.sendInput.output).handler(({ context: context2, input }) => {
        context2.terminalService.sendInput(input.sessionId, input.data);
      }),
      onOutput: t.input(terminal.onOutput.input).output(terminal.onOutput.output).handler(async function* ({ context: context2, input, signal }) {
        if (signal?.aborted) {
          return;
        }
        let resolveNext = null;
        const queue = [];
        let ended = false;
        const push = (data) => {
          if (ended) return;
          if (resolveNext) {
            const resolve4 = resolveNext;
            resolveNext = null;
            resolve4(data);
          } else {
            queue.push(data);
          }
        };
        const unsubscribe = context2.terminalService.onOutput(input.sessionId, push);
        const onAbort = () => {
          if (ended) return;
          ended = true;
          if (resolveNext) {
            const resolve4 = resolveNext;
            resolveNext = null;
            resolve4(null);
          }
        };
        if (signal) {
          signal.addEventListener("abort", onAbort, { once: true });
        }
        try {
          while (!ended) {
            if (queue.length > 0) {
              yield queue.shift();
              continue;
            }
            const data = await new Promise((resolve4) => {
              resolveNext = resolve4;
            });
            if (data === null || ended) {
              break;
            }
            yield data;
          }
        } finally {
          ended = true;
          signal?.removeEventListener("abort", onAbort);
          unsubscribe();
        }
      }),
      attach: t.input(terminal.attach.input).output(terminal.attach.output).handler(async function* ({ context: context2, input, signal }) {
        if (signal?.aborted) {
          return;
        }
        let resolveNext = null;
        const queue = [];
        let ended = false;
        const push = (msg) => {
          if (ended) return;
          if (resolveNext) {
            const resolve4 = resolveNext;
            resolveNext = null;
            resolve4(msg);
          } else {
            queue.push(msg);
          }
        };
        const unsubscribe = context2.terminalService.onOutput(input.sessionId, (data) => {
          push({ type: "output", data });
        });
        const onAbort = () => {
          if (ended) return;
          ended = true;
          if (resolveNext) {
            const resolve4 = resolveNext;
            resolveNext = null;
            resolve4(null);
          }
        };
        if (signal) {
          signal.addEventListener("abort", onAbort, { once: true });
        }
        try {
          const screenState = context2.terminalService.getScreenState(input.sessionId);
          yield { type: "screenState", data: screenState };
          while (!ended) {
            if (queue.length > 0) {
              yield queue.shift();
              continue;
            }
            const msg = await new Promise((resolve4) => {
              resolveNext = resolve4;
            });
            if (msg === null || ended) {
              break;
            }
            yield msg;
          }
        } finally {
          ended = true;
          signal?.removeEventListener("abort", onAbort);
          unsubscribe();
        }
      }),
      onExit: t.input(terminal.onExit.input).output(terminal.onExit.output).handler(async function* ({ context: context2, input, signal }) {
        if (signal?.aborted) {
          return;
        }
        let resolveNext = null;
        const queue = [];
        let ended = false;
        const push = (code) => {
          if (ended) return;
          if (resolveNext) {
            const resolve4 = resolveNext;
            resolveNext = null;
            resolve4(code);
          } else {
            queue.push(code);
          }
        };
        const unsubscribe = context2.terminalService.onExit(input.sessionId, push);
        const onAbort = () => {
          if (ended) return;
          ended = true;
          if (resolveNext) {
            const resolve4 = resolveNext;
            resolveNext = null;
            resolve4(null);
          }
        };
        if (signal) {
          signal.addEventListener("abort", onAbort, { once: true });
        }
        try {
          while (!ended) {
            if (queue.length > 0) {
              yield queue.shift();
              break;
            }
            const code = await new Promise((resolve4) => {
              resolveNext = resolve4;
            });
            if (code === null || ended) {
              break;
            }
            yield code;
            break;
          }
        } finally {
          ended = true;
          signal?.removeEventListener("abort", onAbort);
          unsubscribe();
        }
      }),
      openWindow: t.input(terminal.openWindow.input).output(terminal.openWindow.output).handler(async ({ context: context2, input }) => {
        return context2.terminalService.openWindow(input.workspaceId, input.sessionId);
      }),
      closeWindow: t.input(terminal.closeWindow.input).output(terminal.closeWindow.output).handler(({ context: context2, input }) => {
        return context2.terminalService.closeWindow(input.workspaceId);
      }),
      listSessions: t.input(terminal.listSessions.input).output(terminal.listSessions.output).handler(({ context: context2, input }) => {
        return context2.terminalService.getWorkspaceSessionIds(input.workspaceId);
      }),
      openNative: t.input(terminal.openNative.input).output(terminal.openNative.output).handler(async ({ context: context2, input }) => {
        return context2.terminalService.openNative(input.workspaceId);
      })
    },
    update: {
      check: t.input(update.check.input).output(update.check.output).handler(async ({ context: context2 }) => {
        return context2.updateService.check();
      }),
      download: t.input(update.download.input).output(update.download.output).handler(async ({ context: context2 }) => {
        return context2.updateService.download();
      }),
      install: t.input(update.install.input).output(update.install.output).handler(({ context: context2 }) => {
        return context2.updateService.install();
      }),
      onStatus: t.input(update.onStatus.input).output(update.onStatus.output).handler(async function* ({ context: context2, signal }) {
        if (signal?.aborted) {
          return;
        }
        const queue = createAsyncEventQueue();
        const unsubscribe = context2.updateService.onStatus(queue.push);
        const onAbort = () => {
          queue.end();
        };
        if (signal) {
          signal.addEventListener("abort", onAbort, { once: true });
        }
        try {
          yield* queue.iterate();
        } finally {
          signal?.removeEventListener("abort", onAbort);
          queue.end();
          unsubscribe();
        }
      })
    },
    menu: {
      onOpenSettings: t.input(menu.onOpenSettings.input).output(menu.onOpenSettings.output).handler(async function* ({ context: context2, signal }) {
        if (signal?.aborted) {
          return;
        }
        const queue = createAsyncEventQueue();
        const unsubscribe = context2.menuEventService.onOpenSettings(() => queue.push(true));
        const onAbort = () => {
          queue.end();
        };
        if (signal) {
          signal.addEventListener("abort", onAbort, { once: true });
        }
        try {
          for await (const _ of queue.iterate()) {
            yield void 0;
          }
        } finally {
          signal?.removeEventListener("abort", onAbort);
          queue.end();
          unsubscribe();
        }
      })
    },
    voice: {
      transcribe: t.input(voice.transcribe.input).output(voice.transcribe.output).handler(async ({ context: context2, input }) => {
        return context2.voiceService.transcribe(input.audioBase64);
      })
    },
    experiments: {
      getAll: t.input(experiments.getAll.input).output(experiments.getAll.output).handler(({ context: context2 }) => {
        return context2.experimentsService.getAll();
      }),
      reload: t.input(experiments.reload.input).output(experiments.reload.output).handler(async ({ context: context2 }) => {
        await context2.experimentsService.refreshAll();
      })
    },
    debug: {
      triggerStreamError: t.input(debug.triggerStreamError.input).output(debug.triggerStreamError.output).handler(({ context: context2, input }) => {
        return context2.workspaceService.debugTriggerStreamError(
          input.workspaceId,
          input.errorMessage
        );
      })
    },
    telemetry: {
      track: t.input(telemetry.track.input).output(telemetry.track.output).handler(({ context: context2, input }) => {
        context2.telemetryService.capture(input);
      }),
      status: t.input(telemetry.status.input).output(telemetry.status.output).handler(({ context: context2 }) => {
        return {
          enabled: context2.telemetryService.isEnabled(),
          explicit: context2.telemetryService.isExplicitlyDisabled()
        };
      })
    },
    signing: {
      capabilities: t.input(signing.capabilities.input).output(signing.capabilities.output).handler(async ({ context: context2 }) => {
        return context2.signingService.getCapabilities();
      }),
      signMessage: t.input(signing.signMessage.input).output(signing.signMessage.output).handler(({ context: context2, input }) => {
        return context2.signingService.signMessage(input.content);
      }),
      clearIdentityCache: t.input(signing.clearIdentityCache.input).output(signing.clearIdentityCache.output).handler(({ context: context2 }) => {
        context2.signingService.clearIdentityCache();
        return { success: true };
      })
    },
    modelPresets: {
      list: t.input(modelPresets.list.input).output(modelPresets.list.output).handler(({ context: context2 }) => context2.modelPresetsService.listPresets()),
      save: t.input(modelPresets.save.input).output(modelPresets.save.output).handler(
        ({ context: context2, input }) => context2.modelPresetsService.savePreset(input.name, input.models, input.description)
      ),
      get: t.input(modelPresets.get.input).output(modelPresets.get.output).handler(async ({ context: context2, input }) => {
        const preset = await context2.modelPresetsService.getPreset(input.id);
        return preset ?? null;
      }),
      delete: t.input(modelPresets.delete.input).output(modelPresets.delete.output).handler(({ context: context2, input }) => context2.modelPresetsService.deletePreset(input.id)),
      update: t.input(modelPresets.update.input).output(modelPresets.update.output).handler(
        ({ context: context2, input }) => context2.modelPresetsService.updatePreset(input.id, {
          name: input.name,
          description: input.description,
          models: input.models
        })
      ),
      export: t.input(modelPresets.export.input).output(modelPresets.export.output).handler(
        ({ context: context2, input }) => context2.modelPresetsService.exportPresets(input.ids)
      ),
      import: t.input(modelPresets.import.input).output(modelPresets.import.output).handler(
        ({ context: context2, input }) => context2.modelPresetsService.importPresets(input.json)
      )
    },
    modelHealth: {
      checkModel: t.input(modelHealth.checkModel.input).output(modelHealth.checkModel.output).handler(
        ({ context: context2, input }) => context2.modelHealthService.checkModel(input.provider, input.modelId, input.metadata)
      ),
      checkAll: t.input(modelHealth.checkAll.input).output(modelHealth.checkAll.output).handler(
        ({ context: context2, input }) => context2.modelHealthService.checkAllModels(input.models)
      ),
      getLastResults: t.input(modelHealth.getLastResults.input).output(modelHealth.getLastResults.output).handler(({ context: context2 }) => context2.modelHealthService.getLastResults())
    }
  });
};

// node_modules/@orpc/client/dist/adapters/fetch/index.mjs
init_dist();

// node_modules/@orpc/standard-server-fetch/dist/index.mjs
init_dist();
init_dist2();
function toEventIterator(stream, options = {}) {
  const eventStream = stream?.pipeThrough(new TextDecoderStream()).pipeThrough(new EventDecoderStream());
  const reader = eventStream?.getReader();
  let span;
  let isCancelled = false;
  return new AsyncIteratorClass(async () => {
    span ??= startSpan("consume_event_iterator_stream");
    try {
      while (true) {
        if (reader === void 0) {
          return { done: true, value: void 0 };
        }
        const { done, value: value2 } = await runInSpanContext(span, () => reader.read());
        if (done) {
          if (isCancelled) {
            throw new AbortError("Stream was cancelled");
          }
          return { done: true, value: void 0 };
        }
        switch (value2.event) {
          case "message": {
            let message = parseEmptyableJSON(value2.data);
            if (isTypescriptObject(message)) {
              message = withEventMeta(message, value2);
            }
            span?.addEvent("message");
            return { done: false, value: message };
          }
          case "error": {
            let error = new ErrorEvent({
              data: parseEmptyableJSON(value2.data)
            });
            error = withEventMeta(error, value2);
            span?.addEvent("error");
            throw error;
          }
          case "done": {
            let done2 = parseEmptyableJSON(value2.data);
            if (isTypescriptObject(done2)) {
              done2 = withEventMeta(done2, value2);
            }
            span?.addEvent("done");
            return { done: true, value: done2 };
          }
          default: {
            span?.addEvent("maybe_keepalive");
          }
        }
      }
    } catch (e) {
      if (!(e instanceof ErrorEvent)) {
        setSpanError(span, e, options);
      }
      throw e;
    }
  }, async (reason) => {
    try {
      if (reason !== "next") {
        isCancelled = true;
        span?.addEvent("cancelled");
      }
      await runInSpanContext(span, () => reader?.cancel());
    } catch (e) {
      setSpanError(span, e, options);
      throw e;
    } finally {
      span?.end();
    }
  });
}
function toEventStream(iterator, options = {}) {
  const keepAliveEnabled = options.eventIteratorKeepAliveEnabled ?? true;
  const keepAliveInterval = options.eventIteratorKeepAliveInterval ?? 5e3;
  const keepAliveComment = options.eventIteratorKeepAliveComment ?? "";
  const initialCommentEnabled = options.eventIteratorInitialCommentEnabled ?? true;
  const initialComment = options.eventIteratorInitialComment ?? "";
  let cancelled = false;
  let timeout;
  let span;
  const stream = new ReadableStream({
    start(controller) {
      span = startSpan("stream_event_iterator");
      if (initialCommentEnabled) {
        controller.enqueue(encodeEventMessage({
          comments: [initialComment]
        }));
      }
    },
    async pull(controller) {
      try {
        if (keepAliveEnabled) {
          timeout = setInterval(() => {
            controller.enqueue(encodeEventMessage({
              comments: [keepAliveComment]
            }));
            span?.addEvent("keepalive");
          }, keepAliveInterval);
        }
        const value2 = await runInSpanContext(span, () => iterator.next());
        clearInterval(timeout);
        if (cancelled) {
          return;
        }
        const meta = getEventMeta(value2.value);
        if (!value2.done || value2.value !== void 0 || meta !== void 0) {
          const event = value2.done ? "done" : "message";
          controller.enqueue(encodeEventMessage({
            ...meta,
            event,
            data: stringifyJSON(value2.value)
          }));
          span?.addEvent(event);
        }
        if (value2.done) {
          controller.close();
          span?.end();
        }
      } catch (err) {
        clearInterval(timeout);
        if (cancelled) {
          return;
        }
        if (err instanceof ErrorEvent) {
          controller.enqueue(encodeEventMessage({
            ...getEventMeta(err),
            event: "error",
            data: stringifyJSON(err.data)
          }));
          span?.addEvent("error");
          controller.close();
        } else {
          setSpanError(span, err);
          controller.error(err);
        }
        span?.end();
      }
    },
    async cancel() {
      try {
        cancelled = true;
        clearInterval(timeout);
        span?.addEvent("cancelled");
        await runInSpanContext(span, () => iterator.return?.());
      } catch (e) {
        setSpanError(span, e);
        throw e;
      } finally {
        span?.end();
      }
    }
  }).pipeThrough(new TextEncoderStream());
  return stream;
}
function toStandardBody(re2, options = {}) {
  return runWithSpan(
    { name: "parse_standard_body", signal: options.signal },
    async () => {
      const contentDisposition = re2.headers.get("content-disposition");
      if (typeof contentDisposition === "string") {
        const fileName = getFilenameFromContentDisposition(contentDisposition) ?? "blob";
        const blob2 = await re2.blob();
        return new File([blob2], fileName, {
          type: blob2.type
        });
      }
      const contentType = re2.headers.get("content-type");
      if (!contentType || contentType.startsWith("application/json")) {
        const text2 = await re2.text();
        return parseEmptyableJSON(text2);
      }
      if (contentType.startsWith("multipart/form-data")) {
        return await re2.formData();
      }
      if (contentType.startsWith("application/x-www-form-urlencoded")) {
        const text2 = await re2.text();
        return new URLSearchParams(text2);
      }
      if (contentType.startsWith("text/event-stream")) {
        return toEventIterator(re2.body, options);
      }
      if (contentType.startsWith("text/plain")) {
        return await re2.text();
      }
      const blob = await re2.blob();
      return new File([blob], "blob", {
        type: blob.type
      });
    }
  );
}
function toFetchBody(body, headers, options = {}) {
  const currentContentDisposition = headers.get("content-disposition");
  headers.delete("content-type");
  headers.delete("content-disposition");
  if (body === void 0) {
    return void 0;
  }
  if (body instanceof Blob) {
    headers.set("content-type", body.type);
    headers.set("content-length", body.size.toString());
    headers.set(
      "content-disposition",
      currentContentDisposition ?? generateContentDisposition(body instanceof File ? body.name : "blob")
    );
    return body;
  }
  if (body instanceof FormData) {
    return body;
  }
  if (body instanceof URLSearchParams) {
    return body;
  }
  if (isAsyncIteratorObject(body)) {
    headers.set("content-type", "text/event-stream");
    return toEventStream(body, options);
  }
  headers.set("content-type", "application/json");
  return stringifyJSON(body);
}
function toStandardHeaders(headers, standardHeaders = {}) {
  headers.forEach((value2, key) => {
    if (Array.isArray(standardHeaders[key])) {
      standardHeaders[key].push(value2);
    } else if (standardHeaders[key] !== void 0) {
      standardHeaders[key] = [standardHeaders[key], value2];
    } else {
      standardHeaders[key] = value2;
    }
  });
  return standardHeaders;
}
function toFetchHeaders(headers, fetchHeaders = new Headers()) {
  for (const [key, value2] of Object.entries(headers)) {
    if (Array.isArray(value2)) {
      for (const v of value2) {
        fetchHeaders.append(key, v);
      }
    } else if (value2 !== void 0) {
      fetchHeaders.append(key, value2);
    }
  }
  return fetchHeaders;
}
function toFetchRequest(request, options = {}) {
  const headers = toFetchHeaders(request.headers);
  const body = toFetchBody(request.body, headers, options);
  return new Request(request.url, {
    signal: request.signal,
    method: request.method,
    headers,
    body
  });
}
function toStandardLazyResponse(response, options = {}) {
  return {
    body: once(() => toStandardBody(response, options)),
    status: response.status,
    get headers() {
      const headers = toStandardHeaders(response.headers);
      Object.defineProperty(this, "headers", { value: headers, writable: true });
      return headers;
    },
    set headers(value2) {
      Object.defineProperty(this, "headers", { value: value2, writable: true });
    }
  };
}

// node_modules/@orpc/client/dist/shared/client.EX0cvH1U.mjs
init_dist();
init_dist2();
init_client_J7pEE4Uw();
init_client_BLtwTQUg();
var CompositeStandardLinkPlugin = class {
  plugins;
  constructor(plugins = []) {
    this.plugins = [...plugins].sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
  }
  init(options) {
    for (const plugin of this.plugins) {
      plugin.init?.(options);
    }
  }
};
var StandardLink = class {
  constructor(codec, sender, options = {}) {
    this.codec = codec;
    this.sender = sender;
    const plugin = new CompositeStandardLinkPlugin(options.plugins);
    plugin.init(options);
    this.interceptors = toArray(options.interceptors);
    this.clientInterceptors = toArray(options.clientInterceptors);
  }
  interceptors;
  clientInterceptors;
  call(path24, input, options) {
    return runWithSpan(
      { name: `${ORPC_NAME}.${path24.join("/")}`, signal: options.signal },
      (span) => {
        span?.setAttribute("rpc.system", ORPC_NAME);
        span?.setAttribute("rpc.method", path24.join("."));
        if (isAsyncIteratorObject(input)) {
          input = asyncIteratorWithSpan(
            { name: "consume_event_iterator_input", signal: options.signal },
            input
          );
        }
        return intercept(this.interceptors, { ...options, path: path24, input }, async ({ path: path25, input: input2, ...options2 }) => {
          const otelConfig = getGlobalOtelConfig();
          let otelContext;
          const currentSpan = otelConfig?.trace.getActiveSpan() ?? span;
          if (currentSpan && otelConfig) {
            otelContext = otelConfig?.trace.setSpan(otelConfig.context.active(), currentSpan);
          }
          const request = await runWithSpan(
            { name: "encode_request", context: otelContext },
            () => this.codec.encode(path25, input2, options2)
          );
          const response = await intercept(
            this.clientInterceptors,
            { ...options2, input: input2, path: path25, request },
            ({ input: input3, path: path32, request: request2, ...options3 }) => {
              return runWithSpan(
                { name: "send_request", signal: options3.signal, context: otelContext },
                () => this.sender.call(request2, options3, path32, input3)
              );
            }
          );
          const output = await runWithSpan(
            { name: "decode_response", context: otelContext },
            () => this.codec.decode(response, options2, path25, input2)
          );
          if (isAsyncIteratorObject(output)) {
            return asyncIteratorWithSpan(
              { name: "consume_event_iterator_output", signal: options2.signal },
              output
            );
          }
          return output;
        });
      }
    );
  }
};
var STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES = {
  BIGINT: 0,
  DATE: 1,
  NAN: 2,
  UNDEFINED: 3,
  URL: 4,
  REGEXP: 5,
  SET: 6,
  MAP: 7
};
var StandardRPCJsonSerializer = class {
  customSerializers;
  constructor(options = {}) {
    this.customSerializers = options.customJsonSerializers ?? [];
    if (this.customSerializers.length !== new Set(this.customSerializers.map((custom) => custom.type)).size) {
      throw new Error("Custom serializer type must be unique.");
    }
  }
  serialize(data, segments = [], meta = [], maps = [], blobs = []) {
    for (const custom of this.customSerializers) {
      if (custom.condition(data)) {
        const result = this.serialize(custom.serialize(data), segments, meta, maps, blobs);
        meta.push([custom.type, ...segments]);
        return result;
      }
    }
    if (data instanceof Blob) {
      maps.push(segments);
      blobs.push(data);
      return [data, meta, maps, blobs];
    }
    if (typeof data === "bigint") {
      meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.BIGINT, ...segments]);
      return [data.toString(), meta, maps, blobs];
    }
    if (data instanceof Date) {
      meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.DATE, ...segments]);
      if (Number.isNaN(data.getTime())) {
        return [null, meta, maps, blobs];
      }
      return [data.toISOString(), meta, maps, blobs];
    }
    if (Number.isNaN(data)) {
      meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.NAN, ...segments]);
      return [null, meta, maps, blobs];
    }
    if (data instanceof URL) {
      meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.URL, ...segments]);
      return [data.toString(), meta, maps, blobs];
    }
    if (data instanceof RegExp) {
      meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.REGEXP, ...segments]);
      return [data.toString(), meta, maps, blobs];
    }
    if (data instanceof Set) {
      const result = this.serialize(Array.from(data), segments, meta, maps, blobs);
      meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.SET, ...segments]);
      return result;
    }
    if (data instanceof Map) {
      const result = this.serialize(Array.from(data.entries()), segments, meta, maps, blobs);
      meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.MAP, ...segments]);
      return result;
    }
    if (Array.isArray(data)) {
      const json2 = data.map((v, i) => {
        if (v === void 0) {
          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.UNDEFINED, ...segments, i]);
          return v;
        }
        return this.serialize(v, [...segments, i], meta, maps, blobs)[0];
      });
      return [json2, meta, maps, blobs];
    }
    if (isObject(data)) {
      const json2 = {};
      for (const k in data) {
        if (k === "toJSON" && typeof data[k] === "function") {
          continue;
        }
        json2[k] = this.serialize(data[k], [...segments, k], meta, maps, blobs)[0];
      }
      return [json2, meta, maps, blobs];
    }
    return [data, meta, maps, blobs];
  }
  deserialize(json2, meta, maps, getBlob) {
    const ref = { data: json2 };
    if (maps && getBlob) {
      maps.forEach((segments, i) => {
        let currentRef = ref;
        let preSegment = "data";
        segments.forEach((segment) => {
          currentRef = currentRef[preSegment];
          preSegment = segment;
        });
        currentRef[preSegment] = getBlob(i);
      });
    }
    for (const item of meta) {
      const type2 = item[0];
      let currentRef = ref;
      let preSegment = "data";
      for (let i = 1; i < item.length; i++) {
        currentRef = currentRef[preSegment];
        preSegment = item[i];
      }
      for (const custom of this.customSerializers) {
        if (custom.type === type2) {
          currentRef[preSegment] = custom.deserialize(currentRef[preSegment]);
          break;
        }
      }
      switch (type2) {
        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.BIGINT:
          currentRef[preSegment] = BigInt(currentRef[preSegment]);
          break;
        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.DATE:
          currentRef[preSegment] = new Date(currentRef[preSegment] ?? "Invalid Date");
          break;
        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.NAN:
          currentRef[preSegment] = Number.NaN;
          break;
        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.UNDEFINED:
          currentRef[preSegment] = void 0;
          break;
        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.URL:
          currentRef[preSegment] = new URL(currentRef[preSegment]);
          break;
        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.REGEXP: {
          const [, pattern, flags] = currentRef[preSegment].match(/^\/(.*)\/([a-z]*)$/);
          currentRef[preSegment] = new RegExp(pattern, flags);
          break;
        }
        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.SET:
          currentRef[preSegment] = new Set(currentRef[preSegment]);
          break;
        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.MAP:
          currentRef[preSegment] = new Map(currentRef[preSegment]);
          break;
      }
    }
    return ref.data;
  }
};
function toHttpPath(path24) {
  return `/${path24.map(encodeURIComponent).join("/")}`;
}
function toStandardHeaders2(headers) {
  if (typeof headers.forEach === "function") {
    return toStandardHeaders(headers);
  }
  return headers;
}
function getMalformedResponseErrorCode(status) {
  return Object.entries(COMMON_ORPC_ERROR_DEFS).find(([, def]) => def.status === status)?.[0] ?? "MALFORMED_ORPC_ERROR_RESPONSE";
}
var StandardRPCLinkCodec = class {
  constructor(serializer, options) {
    this.serializer = serializer;
    this.baseUrl = options.url;
    this.maxUrlLength = options.maxUrlLength ?? 2083;
    this.fallbackMethod = options.fallbackMethod ?? "POST";
    this.expectedMethod = options.method ?? this.fallbackMethod;
    this.headers = options.headers ?? {};
  }
  baseUrl;
  maxUrlLength;
  fallbackMethod;
  expectedMethod;
  headers;
  async encode(path24, input, options) {
    let headers = toStandardHeaders2(await value(this.headers, options, path24, input));
    if (options.lastEventId !== void 0) {
      headers = mergeStandardHeaders(headers, { "last-event-id": options.lastEventId });
    }
    const expectedMethod = await value(this.expectedMethod, options, path24, input);
    const baseUrl = await value(this.baseUrl, options, path24, input);
    const url = new URL(baseUrl);
    url.pathname = `${url.pathname.replace(/\/$/, "")}${toHttpPath(path24)}`;
    const serialized = this.serializer.serialize(input);
    if (expectedMethod === "GET" && !(serialized instanceof FormData) && !isAsyncIteratorObject(serialized)) {
      const maxUrlLength = await value(this.maxUrlLength, options, path24, input);
      const getUrl = new URL(url);
      getUrl.searchParams.append("data", stringifyJSON(serialized));
      if (getUrl.toString().length <= maxUrlLength) {
        return {
          body: void 0,
          method: expectedMethod,
          headers,
          url: getUrl,
          signal: options.signal
        };
      }
    }
    return {
      url,
      method: expectedMethod === "GET" ? this.fallbackMethod : expectedMethod,
      headers,
      body: serialized,
      signal: options.signal
    };
  }
  async decode(response) {
    const isOk = !isORPCErrorStatus(response.status);
    const deserialized = await (async () => {
      let isBodyOk = false;
      try {
        const body = await response.body();
        isBodyOk = true;
        return this.serializer.deserialize(body);
      } catch (error) {
        if (!isBodyOk) {
          throw new Error("Cannot parse response body, please check the response body and content-type.", {
            cause: error
          });
        }
        throw new Error("Invalid RPC response format.", {
          cause: error
        });
      }
    })();
    if (!isOk) {
      if (isORPCErrorJson(deserialized)) {
        throw createORPCErrorFromJson(deserialized);
      }
      throw new ORPCError(getMalformedResponseErrorCode(response.status), {
        status: response.status,
        data: { ...response, body: deserialized }
      });
    }
    return deserialized;
  }
};
var StandardRPCSerializer = class {
  constructor(jsonSerializer) {
    this.jsonSerializer = jsonSerializer;
  }
  serialize(data) {
    if (isAsyncIteratorObject(data)) {
      return mapEventIterator(data, {
        value: async (value2) => this.#serialize(value2, false),
        error: async (e) => {
          return new ErrorEvent({
            data: this.#serialize(toORPCError(e).toJSON(), false),
            cause: e
          });
        }
      });
    }
    return this.#serialize(data, true);
  }
  #serialize(data, enableFormData) {
    const [json2, meta_, maps, blobs] = this.jsonSerializer.serialize(data);
    const meta = meta_.length === 0 ? void 0 : meta_;
    if (!enableFormData || blobs.length === 0) {
      return {
        json: json2,
        meta
      };
    }
    const form = new FormData();
    form.set("data", stringifyJSON({ json: json2, meta, maps }));
    blobs.forEach((blob, i) => {
      form.set(i.toString(), blob);
    });
    return form;
  }
  deserialize(data) {
    if (isAsyncIteratorObject(data)) {
      return mapEventIterator(data, {
        value: async (value2) => this.#deserialize(value2),
        error: async (e) => {
          if (!(e instanceof ErrorEvent)) {
            return e;
          }
          const deserialized = this.#deserialize(e.data);
          if (isORPCErrorJson(deserialized)) {
            return createORPCErrorFromJson(deserialized, { cause: e });
          }
          return new ErrorEvent({
            data: deserialized,
            cause: e
          });
        }
      });
    }
    return this.#deserialize(data);
  }
  #deserialize(data) {
    if (data === void 0) {
      return void 0;
    }
    if (!(data instanceof FormData)) {
      return this.jsonSerializer.deserialize(data.json, data.meta ?? []);
    }
    const serialized = JSON.parse(data.get("data"));
    return this.jsonSerializer.deserialize(
      serialized.json,
      serialized.meta ?? [],
      serialized.maps,
      (i) => data.get(i.toString())
    );
  }
};
var StandardRPCLink = class extends StandardLink {
  constructor(linkClient, options) {
    const jsonSerializer = new StandardRPCJsonSerializer(options);
    const serializer = new StandardRPCSerializer(jsonSerializer);
    const linkCodec = new StandardRPCLinkCodec(serializer, options);
    super(linkCodec, linkClient, options);
  }
};

// node_modules/@orpc/client/dist/adapters/fetch/index.mjs
init_dist2();
init_client_J7pEE4Uw();
init_client_BLtwTQUg();
var CompositeLinkFetchPlugin = class extends CompositeStandardLinkPlugin {
  initRuntimeAdapter(options) {
    for (const plugin of this.plugins) {
      plugin.initRuntimeAdapter?.(options);
    }
  }
};
var LinkFetchClient = class {
  fetch;
  toFetchRequestOptions;
  adapterInterceptors;
  constructor(options) {
    const plugin = new CompositeLinkFetchPlugin(options.plugins);
    plugin.initRuntimeAdapter(options);
    this.fetch = options.fetch ?? globalThis.fetch.bind(globalThis);
    this.toFetchRequestOptions = options;
    this.adapterInterceptors = toArray(options.adapterInterceptors);
  }
  async call(standardRequest, options, path24, input) {
    const request = toFetchRequest(standardRequest, this.toFetchRequestOptions);
    const fetchResponse = await intercept(
      this.adapterInterceptors,
      { ...options, request, path: path24, input, init: { redirect: "manual" } },
      ({ request: request2, path: path25, input: input2, init, ...options2 }) => this.fetch(request2, init, options2, path25, input2)
    );
    const lazyResponse = toStandardLazyResponse(fetchResponse, { signal: request.signal });
    return lazyResponse;
  }
};
var RPCLink = class extends StandardRPCLink {
  constructor(options) {
    const linkClient = new LinkFetchClient(options);
    super(linkClient, options);
  }
};

// src/cli/proxifyOrpc.ts
init_dist3();
init_dist5();
import { z as z101 } from "zod";
var emptyObjectSchema = z101.object({});
function isZod4Like(value2) {
  if (typeof value2 !== "object" || value2 === null) return false;
  const v = value2;
  return v.def !== void 0 && typeof v.def === "object" || v._def !== void 0 && typeof v._def === "object";
}
function isVoidOrUndefinedSchema(schema) {
  if (!isZod4Like(schema)) return false;
  const def = getDef(schema);
  return def?.type === "void" || def?.type === "undefined";
}
function isEmptyObject(value2) {
  return typeof value2 === "object" && value2 !== null && !Array.isArray(value2) && Object.keys(value2).length === 0;
}
function getDef(schema) {
  return schema.def ?? schema._def;
}
function unwrapSchema(schema) {
  let current = schema;
  let currentDef = getDef(current);
  while (currentDef && (currentDef.type === "optional" || currentDef.type === "nullable" || currentDef.type === "default") && currentDef.innerType) {
    current = currentDef.innerType;
    currentDef = getDef(current);
  }
  return current;
}
function isOptionalField(schema) {
  const def = getDef(schema);
  return def?.type === "optional" || def?.type === "default";
}
function detectCommonDiscriminator(options) {
  const commonFields = ["type", "kind", "tag", "variant"];
  for (const fieldName of commonFields) {
    let allHaveLiteral = true;
    for (const option of options) {
      if (!isZod4Like(option)) {
        allHaveLiteral = false;
        break;
      }
      const optDef = getDef(option);
      if (optDef?.type !== "object" || !optDef.shape) {
        allHaveLiteral = false;
        break;
      }
      const field = optDef.shape[fieldName];
      if (!field || !isZod4Like(field)) {
        allHaveLiteral = false;
        break;
      }
      const fieldDef = getDef(field);
      if (fieldDef?.type !== "literal") {
        allHaveLiteral = false;
        break;
      }
    }
    if (allHaveLiteral) {
      return fieldName;
    }
  }
  return void 0;
}
function describeZodType(schema, indent = 0) {
  if (!isZod4Like(schema)) return "unknown";
  const unwrapped = unwrapSchema(schema);
  const def = getDef(unwrapped);
  if (!def) return "unknown";
  const type2 = def.type;
  switch (type2) {
    case "string":
      return "string";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "literal":
      if (def.values && def.values.length > 0) {
        return JSON.stringify(def.values[0]);
      }
      if (def.value !== void 0) {
        return JSON.stringify(def.value);
      }
      return "literal";
    case "enum":
      if (def.entries) {
        return Object.values(def.entries).map((v) => JSON.stringify(v)).join("|");
      }
      return "enum";
    case "array":
      if (def.element && isZod4Like(def.element)) {
        const elemUnwrapped = unwrapSchema(def.element);
        const elemDef = getDef(elemUnwrapped);
        if (elemDef?.type === "object" && typeof elemDef.shape === "object") {
          const childFields = describeObjectFieldsHierarchical(elemUnwrapped, indent + 1);
          return `Array of:
${childFields}`;
        }
        if (elemDef?.type === "union") {
          const elemDesc = describeZodType(elemUnwrapped, indent);
          if (elemDesc.startsWith("One of:")) {
            return `Array of ${elemDesc}`;
          }
        }
        return `${describeZodType(def.element, indent)}[]`;
      }
      return "array";
    case "optional":
    case "nullable":
    case "default":
      if (def.innerType) {
        return describeZodType(def.innerType, indent);
      }
      return "unknown";
    case "union":
      if (def.options && Array.isArray(def.options)) {
        const variants = def.options.map((o) => describeZodType(o, indent)).filter((v) => v !== void 0 && v !== null);
        if (variants.length === 0) return "union";
        const allPrimitive = variants.every((v) => !v.includes("\n"));
        if (allPrimitive) {
          return variants.join("|");
        }
        const indentStr = "    ".repeat(indent + 1);
        const discriminator = def.discriminator ?? detectCommonDiscriminator(def.options);
        const formattedVariants = def.options.map((option, i) => {
          const variantDesc = variants[i];
          if (!variantDesc) return "";
          let label = `Variant ${i + 1}`;
          if (discriminator && isZod4Like(option)) {
            const optDef = getDef(option);
            if (optDef?.type === "object" && optDef.shape) {
              const discField = optDef.shape[discriminator];
              if (discField && isZod4Like(discField)) {
                const discDef = getDef(discField);
                if (discDef?.type === "literal") {
                  const val = discDef.values?.[0] ?? discDef.value;
                  if (val !== void 0) label = `${discriminator}=${JSON.stringify(val)}`;
                }
              }
            }
          }
          if (variantDesc.startsWith("\n")) {
            return `${indentStr}${label}:${variantDesc}`;
          }
          return `${indentStr}${label}: ${variantDesc}`;
        }).filter(Boolean);
        return `One of:
${formattedVariants.join("\n")}`;
      }
      return "union";
    case "object":
      if (typeof def.shape === "object") {
        const childFields = describeObjectFieldsHierarchical(unwrapped, indent + 1);
        return `
${childFields}`;
      }
      return "object";
    case "any":
      return "any";
    case "unknown":
      return "unknown";
    case "record":
      return "object";
    default:
      return type2 ?? "unknown";
  }
}
function describeObjectFieldsHierarchical(schema, indent) {
  const def = getDef(schema);
  if (!def || typeof def.shape !== "object") return `${"    ".repeat(indent)}- object`;
  const shape = def.shape;
  const lines = [];
  const indentStr = "    ".repeat(indent);
  for (const [key, fieldSchema] of Object.entries(shape)) {
    if (!isZod4Like(fieldSchema)) continue;
    const isOpt = isOptionalField(fieldSchema);
    const optMark = isOpt ? "?" : "";
    const fieldType = describeZodType(fieldSchema, indent);
    if (!fieldType) {
      lines.push(`${indentStr}- ${key}${optMark}: unknown`);
      continue;
    }
    if (fieldType.startsWith("\n")) {
      lines.push(`${indentStr}- ${key}${optMark}:${fieldType}`);
    } else if (fieldType.startsWith("Array of:\n")) {
      lines.push(`${indentStr}- ${key}${optMark}: ${fieldType}`);
    } else {
      lines.push(`${indentStr}- ${key}${optMark}: ${fieldType}`);
    }
  }
  return lines.join("\n");
}
function describeZodObjectFields(schema) {
  const def = getDef(schema);
  if (!def || typeof def.shape !== "object") return "object";
  const shape = def.shape;
  const requiredLines = [];
  const optionalLines = [];
  for (const [key, fieldSchema] of Object.entries(shape)) {
    if (!isZod4Like(fieldSchema)) continue;
    const isOpt = isOptionalField(fieldSchema);
    const optMark = isOpt ? "?" : "";
    const fieldType = describeZodType(fieldSchema, 1);
    let entry;
    if (fieldType.startsWith("\n")) {
      entry = `- ${key}${optMark}:${fieldType}`;
    } else if (fieldType.startsWith("Array of:\n") || fieldType.startsWith("Array of One of:\n")) {
      entry = `- ${key}${optMark}: ${fieldType}`;
    } else {
      entry = `- ${key}${optMark}: ${fieldType}`;
    }
    if (isOpt) {
      optionalLines.push(entry);
    } else {
      requiredLines.push(entry);
    }
  }
  const parts = [];
  if (requiredLines.length > 0) {
    parts.push(`Required:
${requiredLines.join("\n")}`);
  }
  if (optionalLines.length > 0) {
    parts.push(`Optional:
${optionalLines.join("\n")}`);
  }
  const content = parts.join("\n") || "object";
  const baseIndent = "      ";
  const indentedContent = content.split("\n").map((line) => baseIndent + line).join("\n");
  return "\n" + indentedContent;
}
function enhanceInputSchema(schema) {
  if (!isZod4Like(schema)) return schema;
  const def = getDef(schema);
  if (def?.type === "void" || def?.type === "undefined") {
    return emptyObjectSchema;
  }
  if (def?.type !== "object" || typeof def.shape !== "object") {
    return schema;
  }
  const shape = def.shape;
  let hasEnhancements = false;
  const enhancedShape = {};
  for (const [key, fieldSchema] of Object.entries(shape)) {
    if (!isZod4Like(fieldSchema)) {
      enhancedShape[key] = fieldSchema;
      continue;
    }
    if (fieldSchema.description || typeof fieldSchema.describe !== "function") {
      enhancedShape[key] = fieldSchema;
      continue;
    }
    let innerSchema = fieldSchema;
    let innerDef = getDef(fieldSchema);
    while (innerDef && (innerDef.type === "optional" || innerDef.type === "default") && innerDef.innerType) {
      innerSchema = innerDef.innerType;
      innerDef = getDef(innerSchema);
    }
    const innerType = innerDef?.type;
    if (innerType === "object" && typeof innerDef?.shape === "object") {
      const desc = describeZodObjectFields(innerSchema);
      const isOptional2 = getDef(fieldSchema)?.type === "optional";
      const replacement = isOptional2 ? z101.any().optional().describe(desc) : z101.any().describe(desc);
      enhancedShape[key] = replacement;
      hasEnhancements = true;
    } else if (innerType === "union" || innerType === "array") {
      const desc = describeZodType(innerSchema, 0);
      if (desc.includes("\n")) {
        const baseIndent = "      ";
        const indentedDesc = desc.split("\n").map((line) => baseIndent + line).join("\n");
        const isOptional2 = getDef(fieldSchema)?.type === "optional";
        const replacement = isOptional2 ? z101.any().optional().describe("\n" + indentedDesc) : z101.any().describe("\n" + indentedDesc);
        enhancedShape[key] = replacement;
        hasEnhancements = true;
      } else {
        enhancedShape[key] = fieldSchema;
      }
    } else {
      enhancedShape[key] = fieldSchema;
    }
  }
  if (!hasEnhancements) return schema;
  const enhancedDef = { ...def, shape: enhancedShape };
  const enhanced = {
    ...schema,
    def: enhancedDef,
    _def: enhancedDef
  };
  const originalZod = schema._zod;
  if (originalZod) {
    enhanced._zod = {
      ...originalZod,
      def: enhancedDef
      // toJSONSchema reads shape from _zod.def
    };
    delete enhanced._zod.processJSONSchema;
  }
  return enhanced;
}
function proxifyOrpc(router2, options) {
  const createClient = () => {
    const link = new RPCLink({
      url: `${options.baseUrl}/orpc`,
      headers: options.authToken ? { Authorization: `Bearer ${options.authToken}` } : void 0
    });
    return createORPCClient(link);
  };
  return createRouterProxy(
    router2,
    createClient,
    []
  );
}
function createRouterProxy(router2, createClient, path24) {
  const result = {};
  for (const [key, value2] of Object.entries(router2)) {
    const newPath = [...path24, key];
    if (isProcedure(value2)) {
      result[key] = createProcedureProxy(
        value2,
        createClient,
        newPath
      );
    } else if (typeof value2 === "object" && value2 !== null && !Array.isArray(value2)) {
      result[key] = createRouterProxy(value2, createClient, newPath);
    }
  }
  return result;
}
function createProcedureProxy(procedure, createClient, path24) {
  const originalDef = procedure["~orpc"];
  const originalInputSchema = originalDef.inputSchema;
  const isVoidInput = isVoidOrUndefinedSchema(originalInputSchema);
  const enhancedInputSchema = enhanceInputSchema(originalInputSchema);
  const getClientMethod = () => {
    const client = createClient();
    let method = client;
    for (const segment of path24) {
      method = method[segment];
    }
    return method;
  };
  const proxy = {
    "~orpc": {
      ...originalDef,
      // Use enhanced schema for CLI help generation
      inputSchema: enhancedInputSchema,
      // Keep the original middlewares empty for the proxy - we don't need them
      // since the server will run its own middleware chain
      middlewares: [],
      // The handler that will be called by @orpc/server's `call()` function
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      handler: async (opts) => {
        const clientMethod = getClientMethod();
        const input = isVoidInput && isEmptyObject(opts.input) ? void 0 : opts.input;
        return clientMethod(input);
      }
    }
  };
  return proxy;
}

// src/node/services/serverLockfile.ts
import * as fs14 from "fs/promises";
import * as path23 from "path";
import { z as z109 } from "zod";
var ServerLockDataSchema = z109.object({
  pid: z109.number(),
  /** Base URL for HTTP API (e.g., "http://localhost:3000" or "https://my.box.com/mux") */
  baseUrl: z109.url(),
  token: z109.string(),
  startedAt: z109.string(),
  /** Bind host/interface the server is listening on (e.g. "127.0.0.1" or "0.0.0.0") */
  bindHost: z109.string().optional(),
  /** The port the server is listening on */
  port: z109.number().int().min(0).max(65535).optional(),
  /** Additional base URLs that are reachable from other devices (LAN/VPN) */
  networkBaseUrls: z109.array(z109.url()).optional()
});
var ServerLockfile = class {
  constructor(muxHome) {
    this.lockPath = path23.join(muxHome, "server.lock");
  }
  /**
   * Acquire the lockfile with the given baseUrl and token.
   * Writes atomically with 0600 permissions (owner read/write only).
   */
  async acquire(baseUrl, token, extra) {
    const bindHost = extra?.bindHost?.trim() ? extra.bindHost.trim() : void 0;
    const port = typeof extra?.port === "number" && Number.isInteger(extra.port) && extra.port >= 0 && extra.port <= 65535 ? extra.port : void 0;
    const data = {
      pid: process.pid,
      baseUrl,
      token,
      startedAt: (/* @__PURE__ */ new Date()).toISOString(),
      bindHost,
      port,
      networkBaseUrls: extra?.networkBaseUrls?.length ? extra.networkBaseUrls : void 0
    };
    const dir = path23.dirname(this.lockPath);
    try {
      await fs14.access(dir);
    } catch {
      await fs14.mkdir(dir, { recursive: true });
    }
    const tempPath = `${this.lockPath}.${process.pid}.tmp`;
    await fs14.writeFile(tempPath, JSON.stringify(data, null, 2), {
      mode: 384
      // Owner read/write only
    });
    await fs14.rename(tempPath, this.lockPath);
  }
  /**
   * Read the lockfile and validate it.
   * Returns null if the lockfile doesn't exist or is stale (dead PID).
   */
  async read() {
    try {
      await fs14.access(this.lockPath);
      const content = await fs14.readFile(this.lockPath, "utf-8");
      const data = ServerLockDataSchema.parse(JSON.parse(content));
      if (!this.isProcessAlive(data.pid)) {
        await this.release();
        return null;
      }
      return data;
    } catch {
      return null;
    }
  }
  /**
   * Release the lockfile by deleting it.
   */
  async release() {
    try {
      await fs14.unlink(this.lockPath);
    } catch {
    }
  }
  /**
   * Check if a process with the given PID is still running.
   * Uses signal 0 which tests existence without actually sending a signal.
   */
  isProcessAlive(pid) {
    try {
      process.kill(pid, 0);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Get the path to the lockfile (for testing/debugging).
   */
  getLockPath() {
    return this.lockPath;
  }
};

// src/cli/argv.ts
function detectCliEnvironment(versions = process.versions, defaultApp = process.defaultApp) {
  const isElectron = "electron" in versions;
  const isPackagedElectron = isElectron && !defaultApp;
  const firstArgIndex = isPackagedElectron ? 1 : 2;
  return { isElectron, isPackagedElectron, firstArgIndex };
}
function getArgsAfterSplice(argv = process.argv, env3 = detectCliEnvironment()) {
  return argv.slice(env3.firstArgIndex);
}

// src/cli/api.ts
var args = getArgsAfterSplice();
async function discoverServer() {
  if (process.env.MUX_SERVER_URL) {
    return {
      baseUrl: process.env.MUX_SERVER_URL,
      authToken: process.env.MUX_SERVER_AUTH_TOKEN
    };
  }
  try {
    const lockfile = new ServerLockfile(getMuxHome());
    const data = await lockfile.read();
    if (data) {
      return {
        baseUrl: data.baseUrl,
        authToken: data.token
      };
    }
  } catch {
  }
  return {
    baseUrl: "http://localhost:3000",
    authToken: process.env.MUX_SERVER_AUTH_TOKEN
  };
}
(async () => {
  const { baseUrl, authToken } = await discoverServer();
  const proxiedRouter = proxifyOrpc(router(), { baseUrl, authToken });
  const { run } = createCli({
    router: proxiedRouter,
    name: "mux api",
    description: "Interact with the mux API via a running server"
  });
  try {
    await run({ argv: args });
  } catch (error) {
    if (error instanceof Error && error.constructor.name === "FailedToExitError") {
      return;
    }
    throw error;
  }
})();
/*! Bundled license information:

aws4fetch/dist/aws4fetch.esm.mjs:
  (**
   * @license MIT <https://opensource.org/licenses/MIT>
   * @copyright Michael Hart 2024
   *)

imurmurhash/imurmurhash.js:
  (**
   * @preserve
   * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
   *
   * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
   * @see http://github.com/homebrewing/brauhaus-diff
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *)
*/
